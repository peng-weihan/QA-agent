{"question": "What architectural design flaw exists in the string formatting conversion method checker that violates the contract-based responsibility separation between type inference layers and their callers?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "StringFormatChecker", "docstring": "Checks string formatting operations to ensure that the format string\nis valid and the arguments match the format string.", "methods": ["visit_binop", "visit_joinedstr", "_check_interpolation", "visit_call", "_detect_vacuous_formatting", "_check_new_format", "_check_new_format_specifiers"], "attributes": ["name", "msgs"], "code_location": {"file": "strings.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 242, "end_line": 636}, "type": "class"}, {"name": "arg_matches_format_type", "is_method": false, "class_name": null, "parameters": ["arg_type", "format_type"], "calls": ["isinstance", "arg_type.pytype"], "code_location": {"file": "strings.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 223, "end_line": 239}, "code_snippet": "def arg_matches_format_type(\n    arg_type: SuccessfulInferenceResult, format_type: str\n) -> bool:\n    if format_type in \"sr\":\n        # All types can be printed with %s and %r\n        return True\n    if isinstance(arg_type, astroid.Instance):\n        arg_type = arg_type.pytype()\n        if arg_type == \"builtins.str\":\n            return format_type == \"c\"\n        if arg_type == \"builtins.float\":\n            return format_type in \"deEfFgGn%\"\n        if arg_type == \"builtins.int\":\n            # Integers allow all types\n            return True\n        return False\n    return True\n", "type": "function"}, {"name": "_check_misplaced_format_function", "is_method": true, "class_name": "BasicChecker", "parameters": ["self", "call_node"], "calls": ["utils.safe_infer", "isinstance", "isinstance", "isinstance", "isinstance", "self.add_message"], "code_location": {"file": "basic_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 676, "end_line": 695}, "code_snippet": "    def _check_misplaced_format_function(self, call_node: nodes.Call) -> None:\n        if not isinstance(call_node.func, nodes.Attribute):\n            return\n        if call_node.func.attrname != \"format\":\n            return\n\n        expr = utils.safe_infer(call_node.func.expr)\n        if isinstance(expr, util.UninferableBase):\n            return\n        if not expr:\n            # we are doubtful on inferred type of node, so here just check if format\n            # was called on print()\n            call_expr = call_node.func.expr\n            if not isinstance(call_expr, nodes.Call):\n                return\n            if (\n                isinstance(call_expr.func, nodes.Name)\n                and call_expr.func.name == \"print\"\n            ):\n                self.add_message(\"misplaced-format-function\", node=call_node)\n", "type": "function"}, {"name": "format_string", "is_method": true, "class_name": "FakeClass", "parameters": ["self"], "calls": ["self.string.format", "format", "format", "print", "format", "self.get_string", "print", "self.get_string", "self.get_string"], "code_location": {"file": "misplaced_format_function.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 49, "end_line": 53}, "code_snippet": "    def format_string(self):\n        self.string.format()\n        self.get_string().format()\n        print(self.get_string()).format()  # [misplaced-format-function]\n        print(self.get_string().format())\n", "type": "function"}, {"name": "_check_new_format", "is_method": true, "class_name": "StringFormatChecker", "parameters": ["self", "node", "func"], "calls": ["sum", "self._detect_vacuous_formatting", "self._check_new_format_specifiers", "isinstance", "next", "astroid.arguments.CallSite.from_call", "utils.parse_format_method_string", "self.add_message", "isinstance", "func.bound.infer", "isinstance", "isinstance", "self.add_message", "isinstance", "self.add_message", "len", "self.add_message", "self.add_message", "self.add_message", "all", "len", "self.add_message"], "code_location": {"file": "strings.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 452, "end_line": 534}, "code_snippet": "    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -> None:\n        \"\"\"Check the new string formatting.\"\"\"\n        # Skip format nodes which don't have an explicit string on the\n        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n        ):\n            return\n        if node.starargs or node.kwargs:\n            return\n        try:\n            strnode = next(func.bound.infer())\n        except astroid.InferenceError:\n            return\n        if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):\n            return\n        try:\n            call_site = astroid.arguments.CallSite.from_call(node)\n        except astroid.InferenceError:\n            return\n\n        try:\n            fields, num_args, manual_pos = utils.parse_format_method_string(\n                strnode.value\n            )\n        except utils.IncompleteFormatString:\n            self.add_message(\"bad-format-string\", node=node)\n            return\n\n        positional_arguments = call_site.positional_arguments\n        named_arguments = call_site.keyword_arguments\n        named_fields = {field[0] for field in fields if isinstance(field[0], str)}\n        if num_args and manual_pos:\n            self.add_message(\"format-combined-specification\", node=node)\n            return\n\n        check_args = False\n        # Consider \"{[0]} {[1]}\" as num_args.\n        num_args += sum(1 for field in named_fields if not field)\n        if named_fields:\n            for field in named_fields:\n                if field and field not in named_arguments:\n                    self.add_message(\n                        \"missing-format-argument-key\", node=node, args=(field,)\n                    )\n            for field in named_arguments:\n                if field not in named_fields:\n                    self.add_message(\n                        \"unused-format-string-argument\", node=node, args=(field,)\n                    )\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if positional_arguments or num_args:\n                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n                    check_args = True\n        else:\n            check_args = True\n        if check_args:\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if not num_args:\n                self.add_message(\"format-string-without-interpolation\", node=node)\n                return\n            if len(positional_arguments) > num_args:\n                self.add_message(\"too-many-format-args\", node=node)\n            elif len(positional_arguments) < num_args:\n                self.add_message(\"too-few-format-args\", node=node)\n\n        self._detect_vacuous_formatting(node, positional_arguments)\n        self._check_new_format_specifiers(node, fields, named_arguments)\n", "type": "function"}, {"name": "AmbiguousFormat", "docstring": "Uninferable return value ", "methods": [], "attributes": ["__format__"], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 54, "end_line": 57}, "type": "class"}, {"name": "_check_call_func", "is_method": true, "class_name": "LoggingChecker", "parameters": ["self", "node"], "calls": ["utils.safe_infer", "isinstance", "is_method_call", "self.add_message", "is_complex_format_str", "self._helper_string"], "code_location": {"file": "logging.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 305, "end_line": 319}, "code_snippet": "    def _check_call_func(self, node: nodes.Call) -> None:\n        \"\"\"Checks that function call is not format_string.format().\"\"\"\n        func = utils.safe_infer(node.func)\n        types = (\"str\", \"unicode\")\n        methods = (\"format\",)\n        if (\n            isinstance(func, astroid.BoundMethod)\n            and is_method_call(func, types, methods)\n            and not is_complex_format_str(func.bound)\n        ):\n            self.add_message(\n                \"logging-format-interpolation\",\n                node=node,\n                args=(self._helper_string(node),),\n            )\n", "type": "function"}, {"name": "__format__", "is_method": true, "class_name": "SecondBadFormat", "parameters": ["self", "format_spec"], "calls": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 43, "end_line": 44}, "code_snippet": "    def __format__(self, format_spec):  # [invalid-format-returned]\n        return 1\n", "type": "function"}, {"name": "__format__", "is_method": true, "class_name": "CustomFormat", "parameters": ["self", "format_spec"], "calls": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-format-returned", "start_line": 4, "end_line": 5}, "code_snippet": "    def __format__(self, format_spec):  # [invalid-format-returned]\n        return 1\n", "type": "function"}, {"name": "FirstBadFormat", "docstring": "__format__ returns bytes ", "methods": ["__format__"], "attributes": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 33, "end_line": 37}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0183680057525635}
{"question": "What is the dependency relationship between the test class's instance initialization method accessing the class name attribute and Python's object model?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "TestMetaclass", "docstring": "Test attribute access for metaclasses. ", "methods": [], "attributes": [], "code_location": {"file": "class_members_py30.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 34, "end_line": 35}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Aaaa", "parameters": ["self"], "calls": ["print", "print"], "code_location": {"file": "access_to__name__.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/access", "start_line": 9, "end_line": 11}, "code_snippet": "    def __init__(self):\n        print(self.__name__)  # [no-member]\n        print(self.__class__.__name__)\n", "type": "function"}, {"name": "NoDunderNameInInstance", "docstring": "Emit a warning when accessing __name__ from an instance.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 167, "end_line": 170}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "NewClass", "parameters": ["self"], "calls": ["print"], "code_location": {"file": "access_to__name__.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/access", "start_line": 20, "end_line": 21}, "code_snippet": "    def __init__(self):\n        print('init', self.__name__)  # [no-member]\n", "type": "function"}, {"name": "ClassWithProperty", "docstring": "This test depends on earlier and later defined module-level functions.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 19, "end_line": 22}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "NoDunderNameInInstance", "parameters": ["self"], "calls": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 169, "end_line": 170}, "code_snippet": "    def __init__(self):\n        self.var = self.__name__ # [no-member]\n", "type": "function"}, {"name": "T", "docstring": "Issue #8754, no crash from unexpected assignment between attribute and variable", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 196, "end_line": 198}, "type": "class"}, {"name": "Test", "docstring": "test format attribute access ", "methods": [], "attributes": [], "code_location": {"file": "string_formatting.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/string", "start_line": 17, "end_line": 20}, "type": "class"}, {"name": "ClassLevelAttributeTest", "docstring": "test attribute docstrings. ", "methods": [], "attributes": [], "code_location": {"file": "statement_without_effect.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 38, "end_line": 68}, "type": "class"}, {"name": "ClassLevelAttributeTest", "docstring": "test attribute docstrings. ", "methods": ["func", "__init__", "test"], "attributes": ["good_attribute_docstring", "second_good_attribute_docstring"], "code_location": {"file": "statement_without_effect_py36.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 5, "end_line": 18}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0307998657226562}
{"question": "How does a custom metaclass implementing a property affect class attribute resolution compared to standard Python class creation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "TestMetaclass", "docstring": "Test attribute access for metaclasses. ", "methods": [], "attributes": [], "code_location": {"file": "class_members_py30.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 34, "end_line": 35}, "type": "class"}, {"name": "ClassWithProperty", "docstring": "This test depends on earlier and later defined module-level functions.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 19, "end_line": 22}, "type": "class"}, {"name": "my_difficult_property", "is_method": true, "class_name": "MyClassWithProxy", "parameters": ["cls"], "calls": ["MyClassWithProxy"], "code_location": {"file": "use_implicit_booleaness_not_comparison.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/use", "start_line": 227, "end_line": 230}, "code_snippet": "    def my_difficult_property(cls):\n        if cls.attribute:\n            return {}\n        return MyClassWithProxy()\n", "type": "function"}, {"name": "my_property", "is_method": true, "class_name": "MyClassWithProxy", "parameters": ["cls"], "calls": [], "code_location": {"file": "use_implicit_booleaness_not_comparison.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/use", "start_line": 222, "end_line": 223}, "code_snippet": "    def my_property(cls):\n        return {}\n", "type": "function"}, {"name": "PropertyGood2", "docstring": "Using properties in the body of the class is safe. ", "methods": ["_getter", "_setter", "__init__"], "attributes": ["__slots__", "test"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 76, "end_line": 90}, "type": "class"}, {"name": "a_method", "is_method": true, "class_name": "Parent2", "parameters": ["self"], "calls": [], "code_location": {"file": "regression_properties_in_class_context.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression", "start_line": 34, "end_line": 35}, "code_snippet": "    def a_method(self):\n        return \"actually a property\"\n", "type": "function"}, {"name": "ClassWithProperty", "docstring": "", "methods": ["f", "value"], "attributes": ["hour", "prop", "prop_defined_earlier"], "code_location": {"file": "regression_node_statement_two.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression_02", "start_line": 16, "end_line": 23}, "type": "class"}, {"name": "ClassWithProperty", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "not_callable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n", "start_line": 132, "end_line": 135}, "type": "class"}, {"name": "custom_prop", "is_method": false, "class_name": null, "parameters": ["F"], "calls": ["property"], "code_location": {"file": "invalid_name_property.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_name", "start_line": 9, "end_line": 10}, "code_snippet": "def custom_prop(F): # [invalid-name]\n    return property(F)\n", "type": "function"}, {"name": "WithMetaclass", "docstring": "Regression test for https://github.com/pylint-dev/pylint/issues/7506.\n\nRequires six.", "methods": [], "attributes": [], "code_location": {"file": "unused_import.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 104, "end_line": 107}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0329084396362305}
{"question": "What is the contract enforcement mechanism for the method decorated with the abstract method decorator in the abstract base class that uses the ABCMeta metaclass in the generic alias test file when inherited by concrete subclasses?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "inherited", "is_method": true, "class_name": "Base", "parameters": ["self", "aaa", "aab", "aac"], "calls": [], "code_location": {"file": "unused_argument.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 22, "end_line": 24}, "code_snippet": "    def inherited(self, aaa, aab, aac):\n        \"abstract method\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "AbstractC", "docstring": "Abstract class.\n\nShould not trigger a warning for unimplemented\nabstract methods, because of explicit abc.ABC inheritance.", "methods": [], "attributes": [], "code_location": {"file": "abstract_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 29, "end_line": 35}, "type": "class"}, {"name": "AbstractD", "docstring": "Abstract class.\n\nShould not trigger a warning for unimplemented\nabstract methods, because of explicit metaclass.", "methods": [], "attributes": [], "code_location": {"file": "abstract_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 38, "end_line": 44}, "type": "class"}, {"name": "abstract_method", "is_method": true, "class_name": "DerivedFromAbstract", "parameters": ["self"], "calls": [], "code_location": {"file": "super_init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 87, "end_line": 88}, "code_snippet": "    def abstract_method(self) -> str:\n        return \"Implemented\"\n", "type": "function"}, {"name": "AbstractB", "docstring": "Abstract class.\n\nthis class is checking that it does not output an error msg for\nunimplemeted methods in abstract classes", "methods": ["cccc"], "attributes": [], "code_location": {"file": "abstract_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 19, "end_line": 27}, "type": "class"}, {"name": "BadClassTwo", "docstring": "Check that instantiating a class with `abc.ABCMeta` as ancestor fails if it\ndefines abstract methods.", "methods": ["test"], "attributes": [], "code_location": {"file": "abstract_class_instantiated.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 131, "end_line": 138}, "type": "class"}, {"name": "abstract_method", "is_method": true, "class_name": "ClsAbstract", "parameters": ["self"], "calls": [], "code_location": {"file": "generic_alias_related_py39.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/g/generic_alias", "start_line": 52, "end_line": 53}, "code_snippet": "    def abstract_method(self):\n        pass\n", "type": "function"}, {"name": "abstract_method", "is_method": true, "class_name": "ClsAbstract", "parameters": ["self"], "calls": [], "code_location": {"file": "generic_alias_related.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/g/generic_alias", "start_line": 50, "end_line": 51}, "code_snippet": "    def abstract_method(self):\n        pass\n", "type": "function"}, {"name": "setup_pair", "is_method": true, "class_name": "AbstrClass", "parameters": ["self"], "calls": [], "code_location": {"file": "unpacking_non_sequence.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unpacking", "start_line": 52, "end_line": 54}, "code_snippet": "    def setup_pair(self):\n        \"abstract method\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "AbcProtocol", "docstring": "Doesn't subclass typing.Protocol but uses metaclass directly", "methods": [], "attributes": [], "code_location": {"file": "protocol_classes_abstract.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/p", "start_line": 36, "end_line": 37}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0532886981964111}
{"question": "What is the lazy initialization pattern using a boolean flag in the private import checker that prevents redundant type annotation scanning across multiple import statements?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "PrivateImportChecker", "parameters": ["self", "linter"], "calls": ["BaseChecker.__init__"], "code_location": {"file": "private_import.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 33, "end_line": 38}, "code_snippet": "    def __init__(self, linter: PyLinter) -> None:\n        BaseChecker.__init__(self, linter)\n\n        # A mapping of private names used as a type annotation to whether it is an acceptable import\n        self.all_used_type_annotations: dict[str, bool] = {}\n        self.populated_annotations = False\n", "type": "function"}, {"name": "PrivateImportChecker", "docstring": "", "methods": ["__init__", "visit_import", "visit_importfrom", "_get_private_imports", "_name_is_private", "_get_type_annotation_names", "_populate_type_annotations", "_populate_type_annotations_function", "_populate_type_annotations_annotation", "_assignments_call_private_name", "same_root_dir"], "attributes": ["name", "msgs"], "code_location": {"file": "private_import.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 21, "end_line": 260}, "type": "class"}, {"name": "visit_import", "is_method": true, "class_name": "PrivateImportChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "utils.in_type_checking_block", "self._get_private_imports", "self._get_type_annotation_names", "join", "self.add_message", "len"], "code_location": {"file": "private_import.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 41, "end_line": 55}, "code_snippet": "    def visit_import(self, node: nodes.Import) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        names = [name[0] for name in node.names]\n        private_names = self._get_private_imports(names)\n        private_names = self._get_type_annotation_names(node, private_names)\n        if private_names:\n            imported_identifier = \"modules\" if len(private_names) > 1 else \"module\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n                confidence=HIGH,\n            )\n", "type": "function"}, {"name": "visit_importfrom", "is_method": true, "class_name": "PrivateImportChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "utils.in_type_checking_block", "self.same_root_dir", "self._get_type_annotation_names", "self._get_private_imports", "self._get_type_annotation_names", "self._get_private_imports", "self.add_message", "join", "self.add_message", "len"], "code_location": {"file": "private_import.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 58, "end_line": 97}, "code_snippet": "    def visit_importfrom(self, node: nodes.ImportFrom) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        # Only check imported names if the module is external\n        if self.same_root_dir(node, node.modname):\n            return\n\n        names = [n[0] for n in node.names]\n\n        # Check the imported objects first. If they are all valid type annotations,\n        # the package can be private\n        private_names = self._get_type_annotation_names(node, names)\n        if not private_names:\n            return\n\n        # There are invalid imported objects, so check the name of the package\n        private_module_imports = self._get_private_imports([node.modname])\n        private_module_imports = self._get_type_annotation_names(\n            node, private_module_imports\n        )\n        if private_module_imports:\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(\"module\", private_module_imports[0]),\n                confidence=HIGH,\n            )\n            return  # Do not emit messages on the objects if the package is private\n\n        private_names = self._get_private_imports(private_names)\n\n        if private_names:\n            imported_identifier = \"objects\" if len(private_names) > 1 else \"object\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n                confidence=HIGH,\n            )\n", "type": "function"}, {"name": "_check_imports", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "not_consumed"], "calls": ["_fix_dot_imports", "set", "defaultdict", "unused_wildcard_imports.items", "self.add_message", "checked.add", "len", "self.linter.config.dummy_variables_rgx.match", "isinstance", "isinstance", "isinstance", "SPECIAL_OBJ.search", "in_type_checking_block", "self.add_message", "isinstance", "SPECIAL_OBJ.search", "_is_from_future_import", "join", "append", "in_type_checking_block", "self.add_message"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 3258, "end_line": 3346}, "code_snippet": "    def _check_imports(self, not_consumed: Consumption) -> None:\n        local_names = _fix_dot_imports(not_consumed)\n        checked = set()\n        unused_wildcard_imports: defaultdict[\n            tuple[str, nodes.ImportFrom],\n            list[str],\n        ] = defaultdict(list)\n        for name, stmt in local_names:\n            for imports in stmt.names:\n                real_name = imported_name = imports[0]\n                if imported_name == \"*\":\n                    real_name = name\n                as_name = imports[1]\n                if real_name in checked:\n                    continue\n                if name not in (real_name, as_name):\n                    continue\n                checked.add(real_name)\n\n                is_type_annotation_import = (\n                    imported_name in self._type_annotation_names\n                    or as_name in self._type_annotation_names\n                )\n\n                is_dummy_import = (\n                    as_name\n                    and self.linter.config.dummy_variables_rgx\n                    and self.linter.config.dummy_variables_rgx.match(as_name)\n                )\n\n                if isinstance(stmt, nodes.Import) or (\n                    isinstance(stmt, nodes.ImportFrom) and not stmt.modname\n                ):\n                    if isinstance(stmt, nodes.ImportFrom) and SPECIAL_OBJ.search(\n                        imported_name\n                    ):\n                        # Filter special objects (__doc__, __all__) etc.,\n                        # because they can be imported for exporting.\n                        continue\n\n                    if is_type_annotation_import or is_dummy_import:\n                        # Most likely a typing import if it wasn't used so far.\n                        # Also filter dummy variables.\n                        continue\n\n                    if as_name is None:\n                        msg = f\"import {imported_name}\"\n                    else:\n                        msg = f\"{imported_name} imported as {as_name}\"\n                    if not in_type_checking_block(stmt):\n                        self.add_message(\"unused-import\", args=msg, node=stmt)\n                elif isinstance(stmt, nodes.ImportFrom) and stmt.modname != FUTURE:\n                    if SPECIAL_OBJ.search(imported_name):\n                        # Filter special objects (__doc__, __all__) etc.,\n                        # because they can be imported for exporting.\n                        continue\n\n                    if _is_from_future_import(stmt, name):\n                        # Check if the name is in fact loaded from a\n                        # __future__ import in another module.\n                        continue\n\n                    if is_type_annotation_import or is_dummy_import:\n                        # Most likely a typing import if it wasn't used so far.\n                        # Also filter dummy variables.\n                        continue\n\n                    if imported_name == \"*\":\n                        unused_wildcard_imports[(stmt.modname, stmt)].append(name)\n                    else:\n                        if as_name is None:\n                            msg = f\"{imported_name} imported from {stmt.modname}\"\n                        else:\n                            msg = f\"{imported_name} imported from {stmt.modname} as {as_name}\"\n                        if not in_type_checking_block(stmt):\n                            self.add_message(\"unused-import\", args=msg, node=stmt)\n\n        # Construct string for unused-wildcard-import message\n        for module, unused_list in unused_wildcard_imports.items():\n            if len(unused_list) == 1:\n                arg_string = unused_list[0]\n            else:\n                arg_string = (\n                    f\"{', '.join(i for i in unused_list[:-1])} and {unused_list[-1]}\"\n                )\n            self.add_message(\n                \"unused-wildcard-import\", args=(arg_string, module[0]), node=module[1]\n            )\n        del self._to_consume\n", "type": "function"}, {"name": "VariableAnnotationsGuardedByTypeChecking", "docstring": "Class to test conditional imports guarded by TYPE_CHECKING then used in\nlocal (function) variable annotations, which are not evaluated at runtime.\n\nSee: https://github.com/pylint-dev/pylint/issues/7609\nand https://github.com/pylint-dev/pylint/issues/7882", "methods": ["print_date"], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 145, "end_line": 159}, "type": "class"}, {"name": "is_close", "is_method": true, "class_name": "MyFourthClass", "parameters": ["self", "comparator", "first", "second"], "calls": ["comparator"], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 140, "end_line": 142}, "code_snippet": "    def is_close(self, comparator: math.isclose, first, second):  # <3.14:[used-before-assignment]\n        \"\"\"Conditional imports guarded are only valid for variable annotations.\"\"\"\n        comparator(first, second)\n", "type": "function"}, {"name": "ConditionalImportGuardedWhenUsed", "docstring": "Conditional imports also guarded by TYPE_CHECKING when used.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 162, "end_line": 165}, "type": "class"}, {"name": "TestPrivateImport", "docstring": "The mocked dirname is the directory of the file being linted, the node is code inside that file.", "methods": ["test_internal_module", "test_external_module_nested", "test_external_module_dot_import", "test_external_module_dot_import_outer_only", "test_external_module"], "attributes": ["CHECKER_CLASS"], "code_location": {"file": "test_private_import.py", "path": "/data3/pwh/swebench-repos/pylint/tests/extensions", "start_line": 16, "end_line": 73}, "type": "class"}, {"name": "test_type_annotation_names", "is_method": true, "class_name": "TestRunTC", "parameters": ["self"], "calls": ["join", "join", "textwrap.dedent", "StringIO", "self._run_pylint", "self._clean_paths", "strip", "self._clean_paths", "actual_output.strip", "expected_output.strip", "out.getvalue"], "code_location": {"file": "test_self.py", "path": "/data3/pwh/swebench-repos/pylint/tests", "start_line": 401, "end_line": 432}, "code_snippet": "    def test_type_annotation_names(self) -> None:\n        \"\"\"Test resetting the `_type_annotation_names` list to `[]` when leaving a module.\n\n        An import inside `module_a`, which is used as a type annotation in `module_a`, should not prevent\n        emitting the `unused-import` message when the same import occurs in `module_b` & is unused.\n        See: https://github.com/pylint-dev/pylint/issues/4150\n        \"\"\"\n        module1 = join(\n            HERE, \"regrtest_data\", \"imported_module_in_typehint\", \"module_a.py\"\n        )\n\n        module2 = join(\n            HERE, \"regrtest_data\", \"imported_module_in_typehint\", \"module_b.py\"\n        )\n        expected_output = textwrap.dedent(\n            f\"\"\"\n        ************* Module module_b\n        {module2}:1:0: W0611: Unused import uuid (unused-import)\n        \"\"\"\n        )\n        args = [\n            module1,\n            module2,\n            \"--disable=all\",\n            \"--enable=unused-import\",\n            \"-rn\",\n            \"-sn\",\n        ]\n        out = StringIO()\n        self._run_pylint(args, out=out)\n        actual_output = self._clean_paths(out.getvalue().strip())\n        assert self._clean_paths(expected_output.strip()) in actual_output.strip()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0618181228637695}
{"question": "What cascading effects would occur if modifications to the exception handling pattern for sibling exception handlers propagate through the unused variable checker's analysis pipeline?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "sibling_except_handlers", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 180, "end_line": 188}, "code_snippet": "def sibling_except_handlers():\n    try:\n        pass\n    except ValueError as e:\n        print(e)\n    try:\n        pass\n    except ValueError as e:\n        print(e)\n", "type": "function"}, {"name": "main3", "is_method": false, "class_name": null, "parameters": [], "calls": ["print"], "code_location": {"file": "used_before_assignment_issue626.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 18, "end_line": 25}, "code_snippet": "def main3():\n    try:\n        raise ValueError\n    except ValueError as e:  # [unused-variable]\n        pass\n\n    e = 10\n    print(e)\n", "type": "function"}, {"name": "function2", "is_method": false, "class_name": null, "parameters": [], "calls": ["Exception"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 109, "end_line": 117}, "code_snippet": "def function2():\n    unused = 1  # [unused-variable]\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except ZeroDivisionError as error:  # [redefined-outer-name]\n            raise Exception(\"\") from error\n", "type": "function"}, {"name": "main4", "is_method": false, "class_name": null, "parameters": [], "calls": ["print"], "code_location": {"file": "used_before_assignment_issue626.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 28, "end_line": 44}, "code_snippet": "def main4():\n    try:\n        raise ValueError\n    except ValueError as e:  # [unused-variable]\n        pass\n\n    try:\n        raise ValueError\n    except ValueError as e:\n        pass\n\n    try:\n        raise ValueError\n    except ValueError as e:\n        pass\n\n    print(e)  # [used-before-assignment]\n", "type": "function"}, {"name": "test_not_redefined_in_except_handler", "is_method": false, "class_name": null, "parameters": ["name"], "calls": [], "code_location": {"file": "redefined_argument_from_local.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/redefined", "start_line": 54, "end_line": 58}, "code_snippet": "def test_not_redefined_in_except_handler(name):\n    try:\n        1 / 0\n    except ZeroDivisionError as test_redefined_in_except_handler:\n        pass\n", "type": "function"}, {"name": "main1", "is_method": false, "class_name": null, "parameters": [], "calls": ["print"], "code_location": {"file": "used_before_assignment_issue626.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 2, "end_line": 8}, "code_snippet": "def main1():\n    try:\n        raise ValueError\n    except ValueError as e:  # [unused-variable]\n        pass\n\n    print(e)  # [used-before-assignment]\n", "type": "function"}, {"name": "test_regression_8595", "is_method": false, "class_name": null, "parameters": [], "calls": ["compute", "logging.error", "compute"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 203, "end_line": 218}, "code_snippet": "def test_regression_8595():\n    # pylint: disable=broad-exception-caught\n    import logging\n    def compute():\n        pass\n    try:\n        compute()\n        error = False\n    except Exception as e:\n        logging.error(e)\n        error = True\n    if error:\n        try:\n            compute()\n        except Exception as e:  # [unused-variable]\n            pass\n", "type": "function"}, {"name": "visit_excepthandler", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self._except_handler_names_queue.append", "isinstance", "self.add_message"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1675, "end_line": 1688}, "code_snippet": "    def visit_excepthandler(self, node: nodes.ExceptHandler) -> None:\n        if not node.name or not isinstance(node.name, nodes.AssignName):\n            return\n\n        for outer_except, outer_except_assign_name in self._except_handler_names_queue:\n            if node.name.name == outer_except_assign_name.name:\n                self.add_message(\n                    \"redefined-outer-name\",\n                    args=(outer_except_assign_name.name, outer_except.fromlineno),\n                    node=node,\n                )\n                break\n\n        self._except_handler_names_queue.append((node, node.name))\n", "type": "function"}, {"name": "test_dont_trigger_in_finally_clause_found_in_exception_handler", "is_method": false, "class_name": null, "parameters": [], "calls": ["ValueError", "IOError"], "code_location": {"file": "misplaced_bare_raise.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 78, "end_line": 85}, "code_snippet": "def test_dont_trigger_in_finally_clause_found_in_exception_handler():\n    try:\n        raise ValueError('bad value')\n    except ValueError:\n        try:\n            raise IOError('failed')\n        finally:\n            raise\n", "type": "function"}, {"name": "func3", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 137, "end_line": 145}, "code_snippet": "def func3():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        print(f\"{error}\")\n        try:\n            1 / 2\n        except TypeError as error:  # [unused-variable, redefined-outer-name]\n            print(\"warning\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0494611263275146}
{"question": "What is the exception handling pattern that catches an exception and raises a new one with 'from None' to decouple error detection from propagation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "raise_catch_raise", "is_method": false, "class_name": null, "parameters": [], "calls": ["exploding_apple", "print", "Exception"], "code_location": {"file": "broad_exception_raised.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/b/broad_exception", "start_line": 33, "end_line": 38}, "code_snippet": "def raise_catch_raise():\n    try:\n        exploding_apple(\"apple\")\n    except Exception as ex:\n        print(ex)\n        raise Exception() from None  # [broad-exception-raised]\n", "type": "function"}, {"name": "raise_catch_raise_using_alias", "is_method": false, "class_name": null, "parameters": [], "calls": ["exploding_apple", "print", "ExceptionAlias"], "code_location": {"file": "broad_exception_raised.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/b/broad_exception", "start_line": 41, "end_line": 46}, "code_snippet": "def raise_catch_raise_using_alias():\n    try:\n        exploding_apple(\"apple\")\n    except Exception as ex:\n        print(ex)\n        raise ExceptionAlias() from None  # [broad-exception-raised]\n", "type": "function"}, {"name": "raise_catch_raise_star", "is_method": false, "class_name": null, "parameters": [], "calls": ["exploding_apple", "print", "Exception"], "code_location": {"file": "broad_exception_raised_trystar.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/b/broad_exception", "start_line": 33, "end_line": 38}, "code_snippet": "def raise_catch_raise_star():\n    try:\n        exploding_apple(\"apple\")\n    except* Exception as ex:\n        print(ex)\n        raise Exception() from None  # [broad-exception-raised]\n", "type": "function"}, {"name": "func2", "is_method": false, "class_name": null, "parameters": [], "calls": ["Exception"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 128, "end_line": 135}, "code_snippet": "def func2():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except:\n            raise Exception(\"\") from error\n", "type": "function"}, {"name": "raise_catch_raise_using_alias_star", "is_method": false, "class_name": null, "parameters": [], "calls": ["exploding_apple", "print", "ExceptionAlias"], "code_location": {"file": "broad_exception_raised_trystar.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/b/broad_exception", "start_line": 41, "end_line": 46}, "code_snippet": "def raise_catch_raise_using_alias_star():\n    try:\n        exploding_apple(\"apple\")\n    except* Exception as ex:\n        print(ex)\n        raise ExceptionAlias() from None  # [broad-exception-raised]\n", "type": "function"}, {"name": "reusing_same_name_picks_the_latest_raised_value", "is_method": false, "class_name": null, "parameters": [], "calls": ["tuple", "Error"], "code_location": {"file": "invalid_exceptions_raised.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_exceptions", "start_line": 78, "end_line": 89}, "code_snippet": "def reusing_same_name_picks_the_latest_raised_value():\n    class Error(Exception):\n        \"\"\"some error\"\"\"\n\n    exceptions = tuple([ValueError, TypeError])\n    try:\n        raise ValueError\n    except exceptions as exc:  # pylint: disable=catching-non-exception\n        # https://github.com/pylint-dev/pylint/issues/1756\n        exc = Error(exc)\n        if exc:\n            raise exc\n", "type": "function"}, {"name": "test", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "misplaced_bare_raise.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 21, "end_line": 30}, "code_snippet": "def test():\n    try:\n        pass\n    except Exception:\n        def chest():\n            try:\n                pass\n            except Exception:\n                raise\n        raise\n", "type": "function"}, {"name": "function2", "is_method": false, "class_name": null, "parameters": [], "calls": ["Exception"], "code_location": {"file": "unused_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 109, "end_line": 117}, "code_snippet": "def function2():\n    unused = 1  # [unused-variable]\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except ZeroDivisionError as error:  # [redefined-outer-name]\n            raise Exception(\"\") from error\n", "type": "function"}, {"name": "test", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "try_except_raise_crash.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/t", "start_line": 20, "end_line": 26}, "code_snippet": "def test():\n    try:\n        1 / 0\n    except TestException:  # [catching-non-exception,try-except-raise]\n        raise\n    except Exception:\n        pass\n", "type": "function"}, {"name": "function5", "is_method": false, "class_name": null, "parameters": ["parameter"], "calls": ["parameter.do"], "code_location": {"file": "useless_return.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/useless", "start_line": 39, "end_line": 43}, "code_snippet": "def function5(parameter):  # [useless-return]\n    try:\n        parameter.do()\n    except RuntimeError:\n        return\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0611379146575928}
{"question": "How would you refactor the configuration option value formatter to implement parameter validation and type checking while maintaining backward compatibility with existing callers that pass arbitrary object types?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_format_option_value", "is_method": false, "class_name": null, "parameters": ["optdict", "value"], "calls": ["str", "optdict.get", "join", "isinstance", "join", "isinstance", "str", "join", "hasattr", "_format_option_value", "optdict.get", "value.items", "isinstance", "value.isspace"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/utils", "start_line": 275, "end_line": 293}, "code_snippet": "def _format_option_value(optdict: OptionDict, value: Any) -> str:\n    \"\"\"Return the user input's value from a 'compiled' value.\n\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value else \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n    return str(value)\n", "type": "function"}, {"name": "_ini_format", "is_method": false, "class_name": null, "parameters": ["stream", "options"], "calls": ["warnings.warn", "_format_option_value", "optdict.get", "isinstance", "isinstance", "normalize_text", "print", "print", "print", "print", "strip", "re.match", "print", "str", "separator.join", "str", "len", "split", "str"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/utils", "start_line": 316, "end_line": 347}, "code_snippet": "def _ini_format(stream: TextIO, options: list[tuple[str, OptionDict, Any]]) -> None:\n    \"\"\"Format options using the INI format.\"\"\"\n    warnings.warn(\n        \"_ini_format has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    for optname, optdict, value in options:\n        # Skip deprecated option\n        if \"kwargs\" in optdict:\n            assert isinstance(optdict[\"kwargs\"], dict)\n            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n            print(file=stream)\n            print(help_opt, file=stream)\n        else:\n            print(file=stream)\n        if value in {\"None\", \"False\"}:\n            print(f\"#{optname}=\", file=stream)\n        else:\n            value = str(value).strip()\n            if re.match(r\"^([\\w-]+,)+[\\w-]+$\", str(value)):\n                separator = \"\\n \" + \" \" * len(optname)\n                value = separator.join(x + \",\" for x in str(value).split(\",\"))\n                # remove trailing ',' from last element of the list\n                value = value[:-1]\n            print(f\"{optname}={value}\", file=stream)\n", "type": "function"}, {"name": "good_multiarg", "is_method": false, "class_name": null, "parameters": ["name", "value"], "calls": ["ValueError"], "code_location": {"file": "raising_format_tuple.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/raising", "start_line": 21, "end_line": 23}, "code_snippet": "def good_multiarg(name, value):\n    '''The arguments have to be written as a tuple for formatting'''\n    raise ValueError('%s measures %.2f' % (name, value))\n", "type": "function"}, {"name": "format_section", "is_method": false, "class_name": null, "parameters": ["stream", "section", "options", "doc"], "calls": ["warnings.warn", "print", "print", "warnings.catch_warnings", "warnings.filterwarnings", "_ini_format", "_comment"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/utils", "start_line": 296, "end_line": 313}, "code_snippet": "def format_section(\n    stream: TextIO,\n    section: str,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> None:\n    \"\"\"Format an option's section using the INI format.\"\"\"\n    warnings.warn(\n        \"format_section has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if doc:\n        print(_comment(doc), file=stream)\n    print(f\"[{section}]\", file=stream)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        _ini_format(stream, options)\n", "type": "function"}, {"name": "_call", "is_method": true, "class_name": "_XableAction", "parameters": ["self", "xabling_function", "values", "option_string"], "calls": ["isinstance", "utils._check_csv", "xabling_function", "append", "append", "str"], "code_location": {"file": "callback_actions.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config", "start_line": 352, "end_line": 372}, "code_snippet": "    def _call(\n        self,\n        xabling_function: Callable[[str], None],\n        values: str | Sequence[Any] | None,\n        option_string: str | None,\n    ) -> None:\n        assert isinstance(values, (tuple, list))\n        for msgid in utils._check_csv(values[0]):\n            try:\n                xabling_function(msgid)\n            except (\n                exceptions.DeletedMessageError,\n                exceptions.MessageBecameExtensionError,\n            ) as e:\n                self.linter._stashed_messages[\n                    (self.linter.current_name, \"useless-option-value\")\n                ].append((option_string, str(e)))\n            except exceptions.UnknownMessageError:\n                self.linter._stashed_messages[\n                    (self.linter.current_name, \"unknown-option-value\")\n                ].append((option_string, msgid))\n", "type": "function"}, {"name": "__call__", "is_method": true, "class_name": "_OutputFormatAction", "parameters": ["self", "parser", "namespace", "values", "option_string"], "calls": ["isinstance", "isinstance", "self.linter._load_reporters"], "code_location": {"file": "callback_actions.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config", "start_line": 414, "end_line": 425}, "code_snippet": "    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = \"--enable\",\n    ) -> None:\n        assert isinstance(values, (tuple, list))\n        assert isinstance(\n            values[0], str\n        ), \"'output-format' should be a comma separated string of reporters\"\n        self.linter._load_reporters(values[0])\n", "type": "function"}, {"name": "get_and_validate_format", "is_method": false, "class_name": null, "parameters": [], "calls": ["lower", "format_type.startswith", "InvalidUserInput", "input", "join", "sorted"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config/_pylint_config", "start_line": 52, "end_line": 64}, "code_snippet": "def get_and_validate_format() -> Literal[\"toml\", \"ini\"]:\n    \"\"\"Make sure that the output format is either .toml or .ini.\"\"\"\n    # pylint: disable-next=bad-builtin\n    format_type = input(\n        \"Please choose the format of configuration, (T)oml or (I)ni (.cfg): \"\n    ).lower()\n\n    if format_type not in SUPPORTED_FORMATS:\n        raise InvalidUserInput(\", \".join(sorted(SUPPORTED_FORMATS)), format_type)\n\n    if format_type.startswith(\"t\"):\n        return \"toml\"\n    return \"ini\"\n", "type": "function"}, {"name": "test_format_of_output", "is_method": false, "class_name": null, "parameters": ["monkeypatch", "capsys"], "calls": ["monkeypatch.setattr", "monkeypatch.setattr", "iter", "monkeypatch.setattr", "warnings.catch_warnings", "warnings.filterwarnings", "Run", "capsys.readouterr", "Run", "capsys.readouterr", "Run", "capsys.readouterr", "Run", "capsys.readouterr", "Run", "capsys.readouterr", "next", "pytest.raises", "Run", "Path"], "code_location": {"file": "test_pylint_config_generate.py", "path": "/data3/pwh/swebench-repos/pylint/tests/config/pylint_config", "start_line": 42, "end_line": 88}, "code_snippet": "def test_format_of_output(\n    monkeypatch: MonkeyPatch, capsys: CaptureFixture[str]\n) -> None:\n    \"\"\"Check that we output the correct format.\"\"\"\n    # Monkeypatch everything we don't want to check in this test\n    monkeypatch.setattr(\n        \"pylint.config._pylint_config.utils.get_minimal_setting\", lambda: False\n    )\n    monkeypatch.setattr(\n        \"pylint.config._pylint_config.utils.get_and_validate_output_file\",\n        lambda: (False, Path()),\n    )\n\n    # Set the answers needed for the input() calls\n    answers = iter([\"T\", \"toml\", \"TOML\", \"I\", \"INI\", \"TOMLINI\", \"exit()\"])\n    monkeypatch.setattr(\"builtins.input\", lambda x: next(answers))\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", message=\"NOTE:.*\", category=UserWarning)\n        # Check 'T'\n        Run([\"generate\", \"--interactive\"], exit=False)\n        captured = capsys.readouterr()\n        assert \"[tool.pylint.main]\" in captured.out\n\n        # Check 'toml'\n        Run([\"generate\", \"--interactive\"], exit=False)\n        captured = capsys.readouterr()\n        assert \"[tool.pylint.main]\" in captured.out\n\n        # Check 'TOML'\n        Run([\"generate\", \"--interactive\"], exit=False)\n        captured = capsys.readouterr()\n        assert \"[tool.pylint.main]\" in captured.out\n\n        # Check 'I'\n        Run([\"generate\", \"--interactive\"], exit=False)\n        captured = capsys.readouterr()\n        assert \"[MAIN]\" in captured.out\n\n        # Check 'INI'\n        Run([\"generate\", \"--interactive\"], exit=False)\n        captured = capsys.readouterr()\n        assert \"[MAIN]\" in captured.out\n\n        # Check 'TOMLINI' and then 'exit()'\n        with pytest.raises(SystemExit):\n            Run([\"generate\", \"--interactive\"], exit=False)\n", "type": "function"}, {"name": "_OutputFormatAction", "docstring": "Callback action for setting the output format.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "callback_actions.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config", "start_line": 411, "end_line": 425}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "_NewNamesAction", "parameters": ["self", "parser", "namespace", "values", "option_string"], "calls": ["isinstance", "setattr", "warnings.warn", "join"], "code_location": {"file": "deprecation_actions.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config", "start_line": 94, "end_line": 108}, "code_snippet": "    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = None,\n    ) -> None:\n        assert isinstance(values, list)\n        setattr(namespace, self.dest, values[0])\n        warnings.warn(\n            f\"{self.option_strings[0]} has been deprecated. Please look into \"\n            f\"using any of the following options: {', '.join(self.new_names)}.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0531702041625977}
{"question": "How should a class-creating type design iteration protocol methods to separate construction logic from iteration behavior while allowing inheriting classes to override either independently?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "IteratorMetaclass", "docstring": "", "methods": ["__next__", "next"], "attributes": [], "code_location": {"file": "non_iterator_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 43, "end_line": 48}, "type": "class"}, {"name": "MetaIter", "docstring": "metaclass that makes classes that use it iterables", "methods": ["__iter__"], "attributes": [], "code_location": {"file": "unpacking_non_sequence.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unpacking", "start_line": 40, "end_line": 43}, "type": "class"}, {"name": "__iter__", "is_method": true, "class_name": "MetaIter", "parameters": ["cls"], "calls": ["iter"], "code_location": {"file": "unpacking_non_sequence.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unpacking", "start_line": 42, "end_line": 43}, "code_snippet": "    def __iter__(cls):\n        return iter((1, 2))\n", "type": "function"}, {"name": "__iter__", "is_method": true, "class_name": "ThirdGoodIterator", "parameters": ["self"], "calls": ["SecondGoodIterator"], "code_location": {"file": "non_iterator_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 32, "end_line": 33}, "code_snippet": "    def __iter__(self):\n        return SecondGoodIterator()\n", "type": "function"}, {"name": "__iter__", "is_method": true, "class_name": "FifthGoodIterator", "parameters": ["self"], "calls": [], "code_location": {"file": "non_iterator_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 58, "end_line": 59}, "code_snippet": "    def __iter__(self):\n        return IteratorClass\n", "type": "function"}, {"name": "FourthGoodIterator", "docstring": "__iter__ returns iter(...) ", "methods": ["__iter__"], "attributes": [], "code_location": {"file": "non_iterator_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 36, "end_line": 40}, "type": "class"}, {"name": "__iter__", "is_method": true, "class_name": "Good", "parameters": ["self"], "calls": ["range", "len"], "code_location": {"file": "consider_using_enumerate.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c/consider", "start_line": 65, "end_line": 68}, "code_snippet": "    def __iter__(self):\n        # Should not suggest enumerate on self\n        for i in range(len(self)):\n            yield self[i]\n", "type": "function"}, {"name": "__iter__", "is_method": true, "class_name": "SecondBadIterator", "parameters": ["self"], "calls": [], "code_location": {"file": "non_iterator_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 86, "end_line": 87}, "code_snippet": "    def __iter__(self):  # [non-iterator-returned]\n        return self\n", "type": "function"}, {"name": "__iter__", "is_method": true, "class_name": "MetaIterable", "parameters": ["cls"], "calls": ["iter"], "code_location": {"file": "membership_protocol_py3.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 5, "end_line": 6}, "code_snippet": "    def __iter__(cls):\n        return iter((1, 2, 3))\n", "type": "function"}, {"name": "__iter__", "is_method": true, "class_name": "MyClass", "parameters": ["self"], "calls": [], "code_location": {"file": "class_protocol_ellipsis.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 19, "end_line": 20}, "code_snippet": "    def __iter__(self) -> Iterator[Any]:\n        ...\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0472280979156494}
{"question": "What is the architectural pattern that distinguishes type-annotated from non-annotated instance attribute initialization using AST node type separation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "visit_annassign", "is_method": true, "class_name": "TypingChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "self._is_deprecated_union_annotation", "self._check_union_types", "self._is_optional_none_annotation", "self._is_deprecated_union_annotation", "isinstance", "self._is_binop_union_annotation", "self.add_message", "self._parse_binops_typehints"], "code_location": {"file": "typing.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 248, "end_line": 268}, "code_snippet": "    def visit_annassign(self, node: nodes.AnnAssign) -> None:\n        annotation = node.annotation\n        if self._is_deprecated_union_annotation(annotation, \"Optional\"):\n            if self._is_optional_none_annotation(annotation):\n                self.add_message(\n                    \"redundant-typehint-argument\",\n                    node=annotation,\n                    args=\"None\",\n                    confidence=HIGH,\n                )\n            return\n        if self._is_deprecated_union_annotation(annotation, \"Union\") and isinstance(\n            annotation.slice, nodes.Tuple\n        ):\n            types = annotation.slice.elts\n        elif self._is_binop_union_annotation(annotation):\n            types = self._parse_binops_typehints(annotation)\n        else:\n            return\n\n        self._check_union_types(types, node)\n", "type": "function"}, {"name": "visit_assignattr", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "self._check_in_slots", "self._check_invalid_class_object", "isinstance", "self._uses_mandatory_method_param", "self._accessed.set_accessed", "node.assign_type"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 1729, "end_line": 1735}, "code_snippet": "    def visit_assignattr(self, node: nodes.AssignAttr) -> None:\n        if isinstance(\n            node.assign_type(), nodes.AugAssign\n        ) and self._uses_mandatory_method_param(node):\n            self._accessed.set_accessed(node)\n        self._check_in_slots(node)\n        self._check_invalid_class_object(node)\n", "type": "function"}, {"name": "test_infer_node_3", "is_method": false, "class_name": null, "parameters": [], "calls": ["astroid.extract_node", "isinstance", "isinstance", "node.instance_attrs.get", "infer_node", "pop", "infer_node"], "code_location": {"file": "test_utils.py", "path": "/data3/pwh/swebench-repos/pylint/tests/pyreverse", "start_line": 132, "end_line": 148}, "code_snippet": "def test_infer_node_3() -> None:\n    \"\"\"Return a set containing a nodes.ClassDef object when the attribute\n    has a type annotation.\n    \"\"\"\n    node = astroid.extract_node(\n        \"\"\"\n        class Component:\n            pass\n\n        class Composite:\n            def __init__(self, component: Component):\n                self.component = component\n    \"\"\"\n    )\n    instance_attr = node.instance_attrs.get(\"component\")[0]\n    assert isinstance(infer_node(instance_attr), set)\n    assert isinstance(infer_node(instance_attr).pop(), nodes.ClassDef)\n", "type": "function"}, {"name": "_store_type_annotation_names", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["self._store_type_annotation_node"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 3019, "end_line": 3026}, "code_snippet": "    def _store_type_annotation_names(\n        self,\n        node: nodes.For | nodes.Assign | nodes.With,\n    ) -> None:\n        type_annotation = node.type_annotation\n        if not type_annotation:\n            return\n        self._store_type_annotation_node(node.type_annotation)\n", "type": "function"}, {"name": "test_get_annotation_assignattr", "is_method": false, "class_name": null, "parameters": ["init_method", "label"], "calls": ["pytest.mark.parametrize", "astroid.extract_node", "instance_attrs.values", "get_annotation", "isinstance"], "code_location": {"file": "test_utils.py", "path": "/data3/pwh/swebench-repos/pylint/tests/pyreverse", "start_line": 72, "end_line": 86}, "code_snippet": "def test_get_annotation_assignattr(init_method: str, label: str) -> None:\n    \"\"\"AssignAttr.\"\"\"\n    assign = rf\"\"\"\n        class A:\n            {init_method}\n    \"\"\"\n    node = astroid.extract_node(assign)\n    instance_attrs = node.instance_attrs\n    for assign_attrs in instance_attrs.values():\n        for assign_attr in assign_attrs:\n            annotation = get_annotation(assign_attr)\n            assert annotation is not None\n            got = annotation.name\n            assert isinstance(assign_attr, nodes.AssignAttr)\n            assert got == label, f\"got {got} instead of {label} for value {node}\"\n", "type": "function"}, {"name": "handle_assignattr_type", "is_method": true, "class_name": "Linker", "parameters": ["node", "parent"], "calls": ["set", "list", "utils.infer_node"], "code_location": {"file": "inspector.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/pyreverse", "start_line": 221, "end_line": 229}, "code_snippet": "    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        \"\"\"Handle an astroid.assignattr node.\n\n        handle instance_attrs_type\n        \"\"\"\n        current = set(parent.instance_attrs_type[node.attrname])\n        parent.instance_attrs_type[node.attrname] = list(\n            current | utils.infer_node(node)\n        )\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "NoSelfUseChecker", "parameters": ["self", "linter"], "calls": ["__init__", "super"], "code_location": {"file": "no_self_use.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 37, "end_line": 40}, "code_snippet": "    def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._first_attrs: list[str | None] = []\n        self._meth_could_be_func: bool | None = None\n", "type": "function"}, {"name": "visit_assignattr", "is_method": true, "class_name": "TypeChecker", "parameters": ["self", "node"], "calls": ["isinstance", "node.assign_type", "self.visit_attribute"], "code_location": {"file": "typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1049, "end_line": 1051}, "code_snippet": "    def visit_assignattr(self, node: nodes.AssignAttr) -> None:\n        if isinstance(node.assign_type(), nodes.AugAssign):\n            self.visit_attribute(node)\n", "type": "function"}, {"name": "handle", "is_method": true, "class_name": "AggregationsHandler", "parameters": ["self", "node", "parent"], "calls": ["isinstance", "isinstance", "handle", "isinstance", "handle", "set", "list", "isinstance", "safe_infer", "safe_infer", "set", "list", "super", "super", "utils.infer_node"], "code_location": {"file": "inspector.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/pyreverse", "start_line": 330, "end_line": 361}, "code_snippet": "    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        # Check if we're not in an assignment context\n        if not isinstance(node.parent, (nodes.AnnAssign, nodes.Assign)):\n            super().handle(node, parent)\n            return\n\n        value = node.parent.value\n\n        # Handle direct name assignments\n        if isinstance(value, astroid.node_classes.Name):\n            current = set(parent.aggregations_type[node.attrname])\n            parent.aggregations_type[node.attrname] = list(\n                current | utils.infer_node(node)\n            )\n            return\n\n        # Handle comprehensions\n        if isinstance(\n            value, (nodes.ListComp, nodes.DictComp, nodes.SetComp, nodes.GeneratorExp)\n        ):\n            # Determine the type of the element in the comprehension\n            if isinstance(value, nodes.DictComp):\n                element_type = safe_infer(value.value)\n            else:\n                element_type = safe_infer(value.elt)\n            if element_type:\n                current = set(parent.aggregations_type[node.attrname])\n                parent.aggregations_type[node.attrname] = list(current | {element_type})\n                return\n\n        # Fallback to parent handler\n        super().handle(node, parent)\n", "type": "function"}, {"name": "leave_assign", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["self._store_type_annotation_names"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 2160, "end_line": 2161}, "code_snippet": "    def leave_assign(self, node: nodes.Assign) -> None:\n        self._store_type_annotation_names(node)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0653064250946045}
{"question": "What is the semantic relationship between input arguments and return values when the functools cache decorator is applied?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__cached_fun", "is_method": true, "class_name": "SomeClass", "parameters": ["cls", "arg"], "calls": ["str"], "code_location": {"file": "no_member_decorator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 10, "end_line": 11}, "code_snippet": "    def __cached_fun(cls, arg: int) -> str:\n        return str(arg)\n", "type": "function"}, {"name": "_check_functools_or_not", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "decorator"], "calls": ["decorator.expr.lookup", "isinstance", "isinstance", "dict"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 1513, "end_line": 1529}, "code_snippet": "    def _check_functools_or_not(self, decorator: nodes.Attribute) -> bool:\n        if decorator.attrname != \"cached_property\":\n            return False\n\n        if not isinstance(decorator.expr, nodes.Name):\n            return False\n\n        _, import_nodes = decorator.expr.lookup(decorator.expr.name)\n\n        if not import_nodes:\n            return False\n        import_node = import_nodes[0]\n\n        if not isinstance(import_node, (astroid.Import, astroid.ImportFrom)):\n            return False\n\n        return \"functools\" in dict(import_node.names)\n", "type": "function"}, {"name": "__new__", "is_method": true, "class_name": "FalsePositive4668", "parameters": ["cls", "func"], "calls": ["__new__", "__new__", "super", "super"], "code_location": {"file": "unused_private_member.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 148, "end_line": 162}, "code_snippet": "    def __new__(cls, func, *args):\n        if args:\n            true_obj = super(FalsePositive4668, cls).__new__(cls)\n            true_obj.func = func\n            true_obj.__args = args  # Do not emit message here\n            return true_obj\n\n        false_obj = super(FalsePositive4668, cls).__new__(cls)\n        false_obj.func = func\n        false_obj.__args = args  # Do not emit message here\n        false_obj.__secret_bool = False\n        false_obj.__unused = None  # [unused-private-member]\n        return false_obj\n        # unreachable but non-Name return value\n        return 3+4\n", "type": "function"}, {"name": "cache_clear", "is_method": true, "class_name": "SomeClass", "parameters": ["cls"], "calls": ["cls.__cached_fun.cache_clear"], "code_location": {"file": "no_member_decorator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 14, "end_line": 16}, "code_snippet": "    def cache_clear(cls):\n        \"\"\"__cached_fun()'s @cache decorator supplies cache_clear().\"\"\"\n        cls.__cached_fun.cache_clear()\n", "type": "function"}, {"name": "test_multiple_return_statements", "is_method": true, "class_name": "TestControlFlow", "parameters": ["self", "predicate"], "calls": ["open", "open"], "code_location": {"file": "consider_using_with_open.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c/consider", "start_line": 158, "end_line": 161}, "code_snippet": "    def test_multiple_return_statements(self, predicate):\n        if predicate:\n            return open(\"foo\", encoding=\"utf8\")  # must not trigger\n        return open(\"bar\", encoding=\"utf8\")  # must not trigger\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "ThirdBadGetNewArgsEx", "parameters": ["self"], "calls": ["dict", "dict"], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 68, "end_line": 69}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n", "type": "function"}, {"name": "test_clear_cache_post_run", "is_method": false, "class_name": null, "parameters": [], "calls": ["TemporaryDirectory", "create_files", "LintRun", "LintRun", "open", "f.write"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pylint/tests/config", "start_line": 191, "end_line": 204}, "code_snippet": "def test_clear_cache_post_run() -> None:\n    modname = \"changing.py\"\n    with TemporaryDirectory() as tmp_dir:\n        create_files([modname], tmp_dir)\n        module = tmp_dir + os.sep + modname\n        # Run class does not produce the wanted failure\n        # must use LintRun to get pylint.lint.Run\n        run_before_edit = LintRun([module, \"--clear-cache-post-run=y\"], exit=False)\n        with open(module, mode=\"a\", encoding=\"utf-8\") as f:\n            f.write(\"undefined\\n\")\n        run_after_edit = LintRun([module, \"--clear-cache-post-run=y\"], exit=False)\n\n    assert not run_before_edit.linter.stats.by_msg\n    assert run_after_edit.linter.stats.by_msg\n", "type": "function"}, {"name": "bad_single_dispatch", "is_method": false, "class_name": null, "parameters": ["arg"], "calls": ["fake_singledispatch_decorator.register"], "code_location": {"file": "singledispatch_functions.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/singledispatch", "start_line": 74, "end_line": 75}, "code_snippet": "def bad_single_dispatch(arg): # [unused-argument, function-redefined]\n    return 24\n", "type": "function"}, {"name": "_is_property_decorator", "is_method": false, "class_name": null, "parameters": ["decorator"], "calls": ["decorator.infer", "isinstance", "inferred.ancestors", "isinstance", "inferred.qname", "list", "inferred._get_return_nodes_skip_functions", "isinstance", "safe_infer", "len", "isinstance", "isinstance", "decorated_with_property", "ancestor.root"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 835, "end_line": 859}, "code_snippet": "def _is_property_decorator(decorator: nodes.Name) -> bool:\n    for inferred in decorator.infer():\n        if isinstance(inferred, nodes.ClassDef):\n            if inferred.qname() in {\"builtins.property\", \"functools.cached_property\"}:\n                return True\n            for ancestor in inferred.ancestors():\n                if ancestor.name == \"property\" and ancestor.root().name == \"builtins\":\n                    return True\n        elif isinstance(inferred, nodes.FunctionDef):\n            # If decorator is function, check if it has exactly one return\n            # and the return is itself a function decorated with property\n            returns: list[nodes.Return] = list(\n                inferred._get_return_nodes_skip_functions()\n            )\n            if len(returns) == 1 and isinstance(\n                returns[0].value, (nodes.Name, nodes.Attribute)\n            ):\n                inferred = safe_infer(returns[0].value)\n                if (\n                    inferred\n                    and isinstance(inferred, astroid.objects.Property)\n                    and isinstance(inferred.function, nodes.FunctionDef)\n                ):\n                    return decorated_with_property(inferred.function)\n    return False\n", "type": "function"}, {"name": "should_have_been_decorated_as_static", "is_method": true, "class_name": "SuperClass", "parameters": ["arg1", "arg2"], "calls": [], "code_location": {"file": "arguments_differ.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a", "start_line": 154, "end_line": 155}, "code_snippet": "    def should_have_been_decorated_as_static(arg1, arg2):  # pylint: disable=no-self-argument\n        return arg1 + arg2\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0856847763061523}
{"question": "How does the filter class that skips Sphinx documentation directive patterns inherit its pattern-based filtering mechanism from the base filter class that provides pattern-based word skipping, enabling the spelling validation system to dynamically compose multiple word filtering components without modifying the external tokenization library interface?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "SphinxDirectives", "docstring": "Filter skipping over Sphinx Directives.\nThis filter skips any words matching the following regular expression:\n\n       ^(:([a-z]+)){1,2}:`([^`]+)(`)?\n\nThat is, for example, :class:`BaseQuery`", "methods": [], "attributes": ["_pattern"], "code_location": {"file": "spelling.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 132, "end_line": 142}, "type": "class"}, {"name": "RegExFilter", "docstring": "Parent class for filters using regular expressions.\n\nThis filter skips any words the match the expression\nassigned to the class attribute ``_pattern``.", "methods": ["_skip"], "attributes": [], "code_location": {"file": "spelling.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 107, "end_line": 117}, "type": "class"}, {"name": "CamelCasedWord", "docstring": "Filter skipping over camelCasedWords.\nThis filter skips any words matching the following regular expression:\n\n       ^([a-z]\\w+[A-Z]+\\w+)\n\nThat is, any words that are camelCasedWords.", "methods": [], "attributes": ["_pattern"], "code_location": {"file": "spelling.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 120, "end_line": 129}, "type": "class"}, {"name": "test_skip_sphinx_directives", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_classdef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 284, "end_line": 300}, "code_snippet": "    def test_skip_sphinx_directives(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :class:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :class:`ComentAbc` with a bad coment\",\n                    \"                                      ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n", "type": "function"}, {"name": "WordsWithDigitsFilter", "docstring": "Skips words with digits.", "methods": ["_skip"], "attributes": [], "code_location": {"file": "spelling.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 90, "end_line": 94}, "type": "class"}, {"name": "test_skip_sphinx_directives_2", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_classdef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 304, "end_line": 320}, "code_snippet": "    def test_skip_sphinx_directives_2(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :py:attr:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :py:attr:`ComentAbc` with a bad coment\",\n                    \"                                        ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n", "type": "function"}, {"name": "test_skip_directives_specified_in_pylintrc", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "self.assertAddsMessages", "self.checker.process_tokens", "MessageTest", "_tokenize_str", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 393, "end_line": 407}, "code_snippet": "    def test_skip_directives_specified_in_pylintrc(self) -> None:\n        full_comment = \"# newdirective: do this newdirective\"\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-comment\",\n                line=1,\n                args=(\n                    \"newdirective\",\n                    full_comment,\n                    \"          ^^^^^^^^^^^^\",\n                    self._get_msg_suggestions(\"newdirective\"),\n                ),\n            )\n        ):\n            self.checker.process_tokens(_tokenize_str(full_comment))\n", "type": "function"}, {"name": "test_skip_wiki_words", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_classdef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 170, "end_line": 186}, "code_snippet": "    def test_skip_wiki_words(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"ComentAbc with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"ComentAbc with a bad coment\",\n                    \"                     ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n", "type": "function"}, {"name": "BaseTokenChecker", "docstring": "Base class for checkers that want to have access to the token stream.", "methods": ["process_tokens"], "attributes": [], "code_location": {"file": "base_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 230, "end_line": 236}, "type": "class"}, {"name": "WordsWithUnderscores", "docstring": "Skips words with underscores.\n\nThey are probably function parameter names.", "methods": ["_skip"], "attributes": [], "code_location": {"file": "spelling.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 97, "end_line": 104}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0896952152252197}
{"question": "How does a base class without a slot restriction declaration interact with the attribute assignment validation checker when inherited by subclasses that define slot restrictions or include the dynamic attribute dictionary in their slot restrictions?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "BaseWithSlotsDict", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 174, "end_line": 175}, "type": "class"}, {"name": "BaseWithSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 159, "end_line": 160}, "type": "class"}, {"name": "release", "is_method": true, "class_name": "ClassReassingingInvalidLayoutClass", "parameters": ["self"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 151, "end_line": 153}, "code_snippet": "    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n", "type": "function"}, {"name": "BaseNoSlots", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 149, "end_line": 150}, "type": "class"}, {"name": "DerivedTypeHintNotInSlots", "docstring": "", "methods": ["__init__"], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 177, "end_line": 183}, "type": "class"}, {"name": "ClassTypeHintNotInSlotsWithoutDict", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 133, "end_line": 138}, "type": "class"}, {"name": "ClassTypeHintNotInSlotsWithDict", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 141, "end_line": 146}, "type": "class"}, {"name": "SuperChecks", "docstring": "Don't fail when the MRO is invalid.", "methods": ["test"], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 128, "end_line": 131}, "type": "class"}, {"name": "ChildNotAffectedByValueInSlot", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 129, "end_line": 130}, "type": "class"}, {"name": "DerivedWithSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 153, "end_line": 156}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0931589603424072}
{"question": "What architectural decision in the while-loop refactoring checker requires a control flow tracking flag when traversing nested if-else chains to identify break statements and prevent false positives?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_check_breaking_after_while_true", "is_method": true, "class_name": "ConsiderRefactorIntoWhileConditionChecker", "parameters": ["self", "node"], "calls": ["join", "self.add_message", "pri_candidates.append", "candidates.append", "len", "utils.not_condition_as_string", "isinstance", "node.test.bool_value", "isinstance", "isinstance", "isinstance", "isinstance", "candidates.append", "isinstance", "node.test.as_string", "utils.not_condition_as_string"], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 48, "end_line": 89}, "code_snippet": "    def _check_breaking_after_while_true(self, node: nodes.While) -> None:\n        \"\"\"Check that any loop with an ``if`` clause has a break statement.\"\"\"\n        if not isinstance(node.test, nodes.Const) or not node.test.bool_value():\n            return\n        pri_candidates: list[nodes.If] = []\n        for n in node.body:\n            if not isinstance(n, nodes.If):\n                break\n            pri_candidates.append(n)\n        candidates = []\n        tainted = False\n        for c in pri_candidates:\n            if tainted or not isinstance(c.body[0], nodes.Break):\n                break\n            candidates.append(c)\n            orelse = c.orelse\n            while orelse:\n                orelse_node = orelse[0]\n                if not isinstance(orelse_node, nodes.If):\n                    tainted = True\n                else:\n                    candidates.append(orelse_node)\n                if not isinstance(orelse_node, nodes.If):\n                    break\n                orelse = orelse_node.orelse\n\n        candidates = [n for n in candidates if isinstance(n.body[0], nodes.Break)]\n        msg = \" and \".join(\n            [f\"({utils.not_condition_as_string(c.test)})\" for c in candidates]\n        )\n        if len(candidates) == 1:\n            msg = utils.not_condition_as_string(candidates[0].test)\n        if not msg:\n            return\n\n        self.add_message(\n            \"consider-refactoring-into-while-condition\",\n            node=node,\n            line=node.lineno,\n            args=(msg, node.test.as_string()),\n            confidence=HIGH,\n        )\n", "type": "function"}, {"name": "test_multi_break_condition_1", "is_method": true, "class_name": "Issue8015", "parameters": ["self"], "calls": [], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "start_line": 200, "end_line": 213}, "code_snippet": "    def test_multi_break_condition_1(self):\n        x = 0\n        # This should chain conditions into\n        # While (x == 0) and (x >= 0) and (x != 0):\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x > 0:\n                x -= 1\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            x -= 10\n", "type": "function"}, {"name": "test_multi_break_condition_2", "is_method": true, "class_name": "Issue8015", "parameters": ["self"], "calls": [], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "start_line": 215, "end_line": 223}, "code_snippet": "    def test_multi_break_condition_2(self):\n        x = 0\n        # This should chain both conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            if x == 0:\n                break\n            x -= 10\n", "type": "function"}, {"name": "test_multi_break_condition_3", "is_method": true, "class_name": "Issue8015", "parameters": ["self"], "calls": [], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "start_line": 225, "end_line": 239}, "code_snippet": "    def test_multi_break_condition_3(self):\n        x = 0\n        # This should chain all conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            if x != 100:\n                break\n            if x == 1000:\n                break\n            x -= 10\n", "type": "function"}, {"name": "test_multi_break_condition_4", "is_method": true, "class_name": "Issue8015", "parameters": ["self"], "calls": [], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "start_line": 241, "end_line": 258}, "code_snippet": "    def test_multi_break_condition_4(self):\n        x = 0\n        # This should chain all conditions except last 2.\n        # The else clause taints the first if-elif-else block by introducing mutation\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            else:\n                x += 1\n            if x != 100:\n                break\n            if x == 1000:\n                break\n            x -= 10\n", "type": "function"}, {"name": "visit_while", "is_method": true, "class_name": "ConsiderRefactorIntoWhileConditionChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self._check_breaking_after_while_true"], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 45, "end_line": 46}, "code_snippet": "    def visit_while(self, node: nodes.While) -> None:\n        self._check_breaking_after_while_true(node)\n", "type": "function"}, {"name": "_check_else_on_loop", "is_method": true, "class_name": "BasicErrorChecker", "parameters": ["self", "node"], "calls": ["self.add_message", "_loop_exits_early"], "code_location": {"file": "basic_error_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 477, "end_line": 487}, "code_snippet": "    def _check_else_on_loop(self, node: nodes.For | nodes.While) -> None:\n        \"\"\"Check that any loop with an else clause has a break statement.\"\"\"\n        if node.orelse and not _loop_exits_early(node):\n            self.add_message(\n                \"useless-else-on-loop\",\n                node=node,\n                # This is not optimal, but the line previous\n                # to the first statement in the else clause\n                # will usually be the one that contains the else:.\n                line=node.orelse[0].lineno - 1,\n            )\n", "type": "function"}, {"name": "_check_loop_finishes_via_except", "is_method": true, "class_name": "NamesConsumer", "parameters": ["node", "other_node_try_except"], "calls": ["utils.get_node_first_ancestor_of_type", "any", "isinstance", "any", "_try_in_loop_body", "closest_loop.node_ancestors", "NamesConsumer._recursive_search_for_continue_before_break", "isinstance", "_try_in_loop_body", "else_statement.parent_of", "loop_body_statement.parent_of"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 993, "end_line": 1065}, "code_snippet": "    def _check_loop_finishes_via_except(\n        node: nodes.NodeNG,\n        other_node_try_except: nodes.Try,\n    ) -> bool:\n        \"\"\"Check for a specific control flow scenario.\n\n        Described in https://github.com/pylint-dev/pylint/issues/5683.\n\n        A scenario where the only non-break exit from a loop consists of the very\n        except handler we are examining, such that code in the `else` branch of\n        the loop can depend on it being assigned.\n\n        Example:\n        for _ in range(3):\n            try:\n                do_something()\n            except:\n                name = 1  <-- only non-break exit from loop\n            else:\n                break\n        else:\n            print(name)\n        \"\"\"\n        if not other_node_try_except.orelse:\n            return False\n        closest_loop: None | (nodes.For | nodes.While) = (\n            utils.get_node_first_ancestor_of_type(node, (nodes.For, nodes.While))\n        )\n        if closest_loop is None:\n            return False\n        if not any(\n            else_statement is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n            return False\n        for inner_else_statement in other_node_try_except.orelse:\n            if isinstance(inner_else_statement, nodes.Break):\n                break_stmt = inner_else_statement\n                break\n        else:\n            # No break statement\n            return False\n\n        def _try_in_loop_body(\n            other_node_try_except: nodes.Try,\n            loop: nodes.For | nodes.While,\n        ) -> bool:\n            \"\"\"Return True if `other_node_try_except` is a descendant of `loop`.\"\"\"\n            return any(\n                loop_body_statement is other_node_try_except\n                or loop_body_statement.parent_of(other_node_try_except)\n                for loop_body_statement in loop.body\n            )\n\n        if not _try_in_loop_body(other_node_try_except, closest_loop):\n            for ancestor in closest_loop.node_ancestors():\n                if isinstance(ancestor, (nodes.For, nodes.While)):\n                    if _try_in_loop_body(other_node_try_except, ancestor):\n                        break\n            else:\n                # `other_node_try_except` didn't have a shared ancestor loop\n                return False\n\n        for loop_stmt in closest_loop.body:\n            if NamesConsumer._recursive_search_for_continue_before_break(\n                loop_stmt, break_stmt\n            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n", "type": "function"}, {"name": "_check_superfluous_else_break", "is_method": true, "class_name": "RefactoringChecker", "parameters": ["self", "node"], "calls": ["self._check_superfluous_else"], "code_location": {"file": "refactoring_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/refactoring", "start_line": 817, "end_line": 820}, "code_snippet": "    def _check_superfluous_else_break(self, node: nodes.If) -> None:\n        return self._check_superfluous_else(\n            node, msg_id=\"no-else-break\", returning_node_class=nodes.Break\n        )\n", "type": "function"}, {"name": "another_bad", "is_method": true, "class_name": "Issue8015", "parameters": ["self"], "calls": [], "code_location": {"file": "consider_refactoring_into_while_condition.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "start_line": 12, "end_line": 17}, "code_snippet": "    def another_bad(self):\n        current_scope = None\n        while 2:  # [consider-refactoring-into-while-condition]\n            if current_scope is None:\n                break\n            current_scope = True\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.105919361114502}
{"question": "What is the scope resolution chain for the namedtuple class attribute used as return type annotation in the nested class that affects static type checking in importing modules?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "nested_class_as_return_annotation", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "namedtuple"], "code_location": {"file": "used_before_assignment_type_annotations.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 77, "end_line": 90}, "code_snippet": "def nested_class_as_return_annotation():\n    \"\"\"A namedtuple as a class attribute is used as a return annotation\n\n    Taken from https://github.com/pylint-dev/pylint/issues/5568\"\"\"\n    class MyObject:\n        \"\"\"namedtuple as class attribute\"\"\"\n        Coords = namedtuple('Point', ['x', 'y'])\n\n        def my_method(self) -> Coords:\n            \"\"\"Return annotation is valid\"\"\"\n            # pylint: disable=unnecessary-pass\n            pass\n\n    print(MyObject)\n", "type": "function"}, {"name": "NamedTupleSubclass", "docstring": "Taken from https://github.com/pylint-dev/pylint/issues/5982", "methods": ["method"], "attributes": [], "code_location": {"file": "used_before_assignment_py37.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 32, "end_line": 35}, "type": "class"}, {"name": "MyNamedTuple", "docstring": "Note: current false negative if outer() called before this declaration.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 208, "end_line": 210}, "type": "class"}, {"name": "VariableAnnotationsGuardedByTypeChecking", "docstring": "Class to test conditional imports guarded by TYPE_CHECKING then used in\nlocal (function) variable annotations, which are not evaluated at runtime.\n\nSee: https://github.com/pylint-dev/pylint/issues/7609\nand https://github.com/pylint-dev/pylint/issues/7882", "methods": ["print_date"], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 145, "end_line": 159}, "type": "class"}, {"name": "outer", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "MyNamedTuple", "inner"], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 201, "end_line": 205}, "code_snippet": "def outer() -> None:\n    def inner() -> MyNamedTuple:\n        return MyNamedTuple(1)\n\n    print(inner())\n", "type": "function"}, {"name": "TestNamedTuple", "docstring": "", "methods": ["__init__", "set_item"], "attributes": [], "code_location": {"file": "not_callable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n", "start_line": 149, "end_line": 155}, "type": "class"}, {"name": "MyFourthClass", "docstring": "Class to test conditional imports guarded by TYPE_CHECKING two levels\nup then used in function annotation. See https://github.com/pylint-dev/pylint/issues/7539", "methods": ["is_close"], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 136, "end_line": 142}, "type": "class"}, {"name": "T", "docstring": "Issue #8754, no crash from unexpected assignment between attribute and variable", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 196, "end_line": 198}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 41, "end_line": 42}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_alias_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 62, "end_line": 63}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1081833839416504}
{"question": "What dependencies exist between the named tuple storing class node metadata with method definitions and the node rendering function's formatting of method signatures with return type annotations in PlantUML output?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "NodeType", "docstring": "", "methods": [], "attributes": ["CLASS", "PACKAGE"], "code_location": {"file": "printer.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/pyreverse", "start_line": 18, "end_line": 20}, "type": "class"}, {"name": "MyNamedTuple", "docstring": "Note: current false negative if outer() called before this declaration.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 208, "end_line": 210}, "type": "class"}, {"name": "Node", "docstring": "", "methods": ["__init__", "get_full_name"], "attributes": [], "code_location": {"file": "regression_2964.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression_02", "start_line": 10, "end_line": 24}, "type": "class"}, {"name": "_build_label_for_node", "is_method": true, "class_name": "DotPrinter", "parameters": ["self", "properties"], "calls": ["join", "replace", "attr.replace", "func.is_abstract", "get_annotation_label", "join", "self._escape_annotation_label", "self._get_method_arguments"], "code_location": {"file": "dot_printer.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/pyreverse", "start_line": 102, "end_line": 131}, "code_snippet": "    def _build_label_for_node(self, properties: NodeProperties) -> str:\n        if not properties.label:\n            return \"\"\n\n        label: str = properties.label\n        if properties.attrs is None and properties.methods is None:\n            # return a \"compact\" form which only displays the class name in a box\n            return label\n\n        # Add class attributes\n        attrs: list[str] = properties.attrs or []\n        attrs_string = rf\"{HTMLLabels.LINEBREAK_LEFT.value}\".join(\n            attr.replace(\"|\", r\"\\|\") for attr in attrs\n        )\n        label = rf\"{{{label}|{attrs_string}{HTMLLabels.LINEBREAK_LEFT.value}|\"\n\n        # Add class methods\n        methods: list[nodes.FunctionDef] = properties.methods or []\n        for func in methods:\n            args = \", \".join(self._get_method_arguments(func)).replace(\"|\", r\"\\|\")\n            method_name = (\n                f\"<I>{func.name}</I>\" if func.is_abstract() else f\"{func.name}\"\n            )\n            label += rf\"{method_name}({args})\"\n            if func.returns:\n                annotation_label = get_annotation_label(func.returns)\n                label += \": \" + self._escape_annotation_label(annotation_label)\n            label += rf\"{HTMLLabels.LINEBREAK_LEFT.value}\"\n        label += \"}\"\n        return label\n", "type": "function"}, {"name": "NodeCheckMetaClass", "docstring": "", "methods": ["__new__"], "attributes": [], "code_location": {"file": "regression_too_many_arguments_2335.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression_02", "start_line": 9, "end_line": 11}, "type": "class"}, {"name": "UndocumentedNodes", "docstring": "TypedDict to store counts of undocumented node types.", "methods": [], "attributes": [], "code_location": {"file": "linterstats.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/utils", "start_line": 56, "end_line": 62}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 41, "end_line": 42}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_alias_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 62, "end_line": 63}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 43, "end_line": 44}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_deprecated_alias.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 55, "end_line": 56}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.114015817642212}
{"question": "Why does the test class that intentionally violates the protocol by returning a three-element tuple instead of the required two-element tuple exist alongside correct implementations in the same test module?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__getnewargs_ex__", "is_method": true, "class_name": "FourthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 75, "end_line": 76}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "SecondBadGetNewArgsEx", "parameters": ["self"], "calls": ["tuple", "dict"], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 61, "end_line": 62}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "CustomGetNewArgsEx", "parameters": ["self"], "calls": ["tuple", "dict"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "start_line": 4, "end_line": 5}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n", "type": "function"}, {"name": "SecondBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 58, "end_line": 62}, "type": "class"}, {"name": "ThirdBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with wrong type for first arg ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 65, "end_line": 69}, "type": "class"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "FifthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 82, "end_line": 83}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ({'x': 'y'}, (2,))\n", "type": "function"}, {"name": "FourthBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with wrong type for second arg ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 72, "end_line": 76}, "type": "class"}, {"name": "CustomGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": [], "attributes": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "start_line": 1, "end_line": 5}, "type": "class"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "SixthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 89, "end_line": 90}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "ThirdBadGetNewArgsEx", "parameters": ["self"], "calls": ["dict", "dict"], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 68, "end_line": 69}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1039066314697266}
{"question": "How does a deep copying hook method with an extra parameter violate the protocol that Python's copy module expects?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__deepcopy__", "is_method": true, "class_name": "Invalid", "parameters": ["self", "memo", "other"], "calls": [], "code_location": {"file": "unexpected_special_method_signature.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u", "start_line": 23, "end_line": 24}, "code_snippet": "    def __deepcopy__(self, memo, other): # [unexpected-special-method-signature]\n        pass\n", "type": "function"}, {"name": "__deepcopy__", "is_method": true, "class_name": "C", "parameters": ["self", "memo"], "calls": ["C"], "code_location": {"file": "invalid_class_object.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 32, "end_line": 35}, "code_snippet": "    def __deepcopy__(self, memo):\n        obj = C()\n        obj.__class__ = self.__class__\n        return obj\n", "type": "function"}, {"name": "CustomGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": [], "attributes": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "start_line": 1, "end_line": 5}, "type": "class"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "CustomGetNewArgsEx", "parameters": ["self"], "calls": ["tuple", "dict"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "start_line": 4, "end_line": 5}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "SecondBadGetNewArgsEx", "parameters": ["self"], "calls": ["tuple", "dict"], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 61, "end_line": 62}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "FourthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 75, "end_line": 76}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n", "type": "function"}, {"name": "SecondBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 58, "end_line": 62}, "type": "class"}, {"name": "FourthBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with wrong type for second arg ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 72, "end_line": 76}, "type": "class"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "SixthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 89, "end_line": 90}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "ThirdBadGetNewArgsEx", "parameters": ["self"], "calls": ["dict", "dict"], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 68, "end_line": 69}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1206824779510498}
{"question": "How should the custom string class architecture be redesigned to separate parameter validation from formatting operations while maintaining backward compatibility with the built-in str interface?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "CustomFormat", "docstring": "__format__ returns <type 'str'>", "methods": ["__format__", "__format__"], "attributes": [], "code_location": {"file": "good.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-format-returned", "start_line": 1, "end_line": 5}, "type": "class"}, {"name": "CustomFormat", "docstring": "__format__ returns <type 'int'>", "methods": [], "attributes": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-format-returned", "start_line": 1, "end_line": 5}, "type": "class"}, {"name": "FirstBadFormat", "docstring": "__format__ returns bytes ", "methods": ["__format__"], "attributes": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 33, "end_line": 37}, "type": "class"}, {"name": "SecondBadFormat", "docstring": "__format__ returns int ", "methods": ["__format__"], "attributes": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 40, "end_line": 44}, "type": "class"}, {"name": "FirstGoodFormat", "docstring": "__format__ returns <type 'str'>", "methods": ["__format__"], "attributes": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 9, "end_line": 13}, "type": "class"}, {"name": "SecondGoodFormat", "docstring": "__format__ returns <type 'str'>", "methods": ["__format__"], "attributes": [], "code_location": {"file": "invalid_format_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 16, "end_line": 20}, "type": "class"}, {"name": "_check_new_format", "is_method": true, "class_name": "StringFormatChecker", "parameters": ["self", "node", "func"], "calls": ["sum", "self._detect_vacuous_formatting", "self._check_new_format_specifiers", "isinstance", "next", "astroid.arguments.CallSite.from_call", "utils.parse_format_method_string", "self.add_message", "isinstance", "func.bound.infer", "isinstance", "isinstance", "self.add_message", "isinstance", "self.add_message", "len", "self.add_message", "self.add_message", "self.add_message", "all", "len", "self.add_message"], "code_location": {"file": "strings.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 452, "end_line": 534}, "code_snippet": "    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -> None:\n        \"\"\"Check the new string formatting.\"\"\"\n        # Skip format nodes which don't have an explicit string on the\n        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n        ):\n            return\n        if node.starargs or node.kwargs:\n            return\n        try:\n            strnode = next(func.bound.infer())\n        except astroid.InferenceError:\n            return\n        if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):\n            return\n        try:\n            call_site = astroid.arguments.CallSite.from_call(node)\n        except astroid.InferenceError:\n            return\n\n        try:\n            fields, num_args, manual_pos = utils.parse_format_method_string(\n                strnode.value\n            )\n        except utils.IncompleteFormatString:\n            self.add_message(\"bad-format-string\", node=node)\n            return\n\n        positional_arguments = call_site.positional_arguments\n        named_arguments = call_site.keyword_arguments\n        named_fields = {field[0] for field in fields if isinstance(field[0], str)}\n        if num_args and manual_pos:\n            self.add_message(\"format-combined-specification\", node=node)\n            return\n\n        check_args = False\n        # Consider \"{[0]} {[1]}\" as num_args.\n        num_args += sum(1 for field in named_fields if not field)\n        if named_fields:\n            for field in named_fields:\n                if field and field not in named_arguments:\n                    self.add_message(\n                        \"missing-format-argument-key\", node=node, args=(field,)\n                    )\n            for field in named_arguments:\n                if field not in named_fields:\n                    self.add_message(\n                        \"unused-format-string-argument\", node=node, args=(field,)\n                    )\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if positional_arguments or num_args:\n                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n                    check_args = True\n        else:\n            check_args = True\n        if check_args:\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if not num_args:\n                self.add_message(\"format-string-without-interpolation\", node=node)\n                return\n            if len(positional_arguments) > num_args:\n                self.add_message(\"too-many-format-args\", node=node)\n            elif len(positional_arguments) < num_args:\n                self.add_message(\"too-few-format-args\", node=node)\n\n        self._detect_vacuous_formatting(node, positional_arguments)\n        self._check_new_format_specifiers(node, fields, named_arguments)\n", "type": "function"}, {"name": "format_string", "is_method": true, "class_name": "FakeClass", "parameters": ["self"], "calls": ["self.string.format", "format", "format", "print", "format", "self.get_string", "print", "self.get_string", "self.get_string"], "code_location": {"file": "misplaced_format_function.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 49, "end_line": 53}, "code_snippet": "    def format_string(self):\n        self.string.format()\n        self.get_string().format()\n        print(self.get_string()).format()  # [misplaced-format-function]\n        print(self.get_string().format())\n", "type": "function"}, {"name": "MyString", "docstring": "Custom str implementation", "methods": ["rjust"], "attributes": [], "code_location": {"file": "unnecessary_dunder_call.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unnecessary", "start_line": 127, "end_line": 131}, "type": "class"}, {"name": "IncompleteFormatString", "docstring": "A format string ended in the middle of a format specifier.", "methods": [], "attributes": [], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 496, "end_line": 497}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1119182109832764}
{"question": "How does the descriptor protocol implementation in the test descriptor class's get method interact with Python's attribute resolution mechanism when accessed through different ownership contexts?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "mymethod2", "is_method": true, "class_name": "MyClass", "parameters": ["self"], "calls": ["self.mymethod1.__get__"], "code_location": {"file": "too_many_arguments.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/t/too", "start_line": 14, "end_line": 15}, "code_snippet": "    def mymethod2(self):\n        return self.mymethod1.__get__(self, MyClass)\n", "type": "function"}, {"name": "dont_emit_for_descriptors", "is_method": false, "class_name": null, "parameters": [], "calls": ["SlotsWithDescriptor"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 129, "end_line": 134}, "code_snippet": "def dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n", "type": "function"}, {"name": "Getattribute", "docstring": "no-member shouldn't be emitted for classes with dunder getattribute.", "methods": ["__getattribute__"], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 77, "end_line": 81}, "type": "class"}, {"name": "__get__", "is_method": true, "class_name": "MyDescriptor", "parameters": ["self", "instance", "owner"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 222, "end_line": 223}, "code_snippet": "    def __get__(self, instance, owner):\n        return 42\n", "type": "function"}, {"name": "NonDataDescriptor", "docstring": "", "methods": ["__get__"], "attributes": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 117, "end_line": 119}, "type": "class"}, {"name": "__get__", "is_method": true, "class_name": "NonDataDescriptor", "parameters": ["self", "inst", "cls"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 118, "end_line": 119}, "code_snippet": "    def __get__(self, inst, cls):\n        return 42\n", "type": "function"}, {"name": "MyDescriptor", "docstring": "Basic descriptor.", "methods": ["__get__", "__set__"], "attributes": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 219, "end_line": 226}, "type": "class"}, {"name": "Getattr", "docstring": "no-member shouldn't be emitted for classes with dunder getattr.", "methods": [], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 70, "end_line": 74}, "type": "class"}, {"name": "DataDescriptor", "docstring": "", "methods": ["__init__", "__get__", "__set__"], "attributes": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 105, "end_line": 114}, "type": "class"}, {"name": "Test", "docstring": "test format attribute access ", "methods": [], "attributes": [], "code_location": {"file": "string_formatting.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/string", "start_line": 17, "end_line": 20}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1219093799591064}
{"question": "How does the test class that extends parent slots using augmentation assignment interact with ancestor slot definitions in the class checker?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "SlotsManipulationTest", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 193, "end_line": 194}, "type": "class"}, {"name": "DerivedWithSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 153, "end_line": 156}, "type": "class"}, {"name": "ChildNotAffectedByValueInSlot", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 129, "end_line": 130}, "type": "class"}, {"name": "release", "is_method": true, "class_name": "ClassReassingingInvalidLayoutClass", "parameters": ["self"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 151, "end_line": 153}, "code_snippet": "    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n", "type": "function"}, {"name": "DerivedWithMoreSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 163, "end_line": 171}, "type": "class"}, {"name": "Subclass3", "docstring": "Adding the `l`, `m`, `n` slots\nRedefining the `a`, `b`, & `c` slot already defined in `Base`\nRedefining the `i`, `j`, `k` slot already defined in `Base2`", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "redefined_slots.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/redefined", "start_line": 28, "end_line": 33}, "type": "class"}, {"name": "DerivedTypeHintNotInSlots", "docstring": "", "methods": ["__init__"], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 177, "end_line": 183}, "type": "class"}, {"name": "BaseWithSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 159, "end_line": 160}, "type": "class"}, {"name": "ClassWithSlots", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 137, "end_line": 138}, "type": "class"}, {"name": "InvalidAccessBySlots", "docstring": "", "methods": ["__init__"], "attributes": ["__slots__"], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 173, "end_line": 177}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1364200115203857}
{"question": "Why does the NamedTuple test class in the PEP 604 alternative union syntax test module use pipe operator syntax instead of typing.Union?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "NamedTupleSubclass", "docstring": "Taken from https://github.com/pylint-dev/pylint/issues/5982", "methods": ["method"], "attributes": [], "code_location": {"file": "used_before_assignment_py37.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 32, "end_line": 35}, "type": "class"}, {"name": "TestNamedTuple", "docstring": "", "methods": ["__init__", "set_item"], "attributes": [], "code_location": {"file": "not_callable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n", "start_line": 149, "end_line": 155}, "type": "class"}, {"name": "MyNamedTuple", "docstring": "Note: current false negative if outer() called before this declaration.", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 208, "end_line": 210}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 41, "end_line": 42}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_alias_without_future.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 62, "end_line": 63}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 43, "end_line": 44}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_deprecated_alias.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 55, "end_line": 56}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_alias.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 64, "end_line": 65}, "type": "class"}, {"name": "CustomNamedTuple", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_consider_using_union_py310.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/typing", "start_line": 35, "end_line": 36}, "type": "class"}, {"name": "func2", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "alternative_union_syntax_error.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/alternative", "start_line": 42, "end_line": 43}, "code_snippet": "def func2() -> int | str:  # [unsupported-binary-operation]\n    pass\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1232926845550537}
{"question": "How should the regex pattern compilation logic in the initialization method that configures fixme detection patterns in the encoding validation checker be refactored to separate pattern construction from compilation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "open", "is_method": true, "class_name": "EncodingChecker", "parameters": ["self"], "calls": ["open", "join", "re.compile", "re.compile", "re.compile", "super", "re.escape"], "code_location": {"file": "misc.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 104, "end_line": 123}, "code_snippet": "    def open(self) -> None:\n        super().open()\n\n        notes = \"|\".join(re.escape(note) for note in self.linter.config.notes)\n        if self.linter.config.notes_rgx:\n            notes += f\"|{self.linter.config.notes_rgx}\"\n\n        comment_regex = rf\"#\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?$)\"\n        self._comment_fixme_pattern = re.compile(comment_regex, re.I)\n\n        # single line docstring like '''this''' or \"\"\"this\"\"\"\n        docstring_regex = rf\"((\\\"\\\"\\\")|(\\'\\'\\'))\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?)((\\\"\\\"\\\")|(\\'\\'\\'))\"\n        self._docstring_fixme_pattern = re.compile(docstring_regex, re.I)\n\n        # multiline docstrings which will be split into newlines\n        # so we do not need to look for quotes/double-quotes\n        multiline_docstring_regex = rf\"^\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*$)\"\n        self._multiline_docstring_fixme_pattern = re.compile(\n            multiline_docstring_regex, re.I\n        )\n", "type": "function"}, {"name": "_cached_encode_search", "is_method": false, "class_name": null, "parameters": ["string", "encoding"], "calls": ["lru_cache", "_encode_without_bom"], "code_location": {"file": "unicode.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 244, "end_line": 246}, "code_snippet": "def _cached_encode_search(string: str, encoding: str) -> bytes:\n    \"\"\"A cached version of encode used for search pattern.\"\"\"\n    return _encode_without_bom(string, encoding)\n", "type": "function"}, {"name": "_regex_transformer", "is_method": false, "class_name": null, "parameters": ["value"], "calls": ["re.compile", "argparse.ArgumentTypeError"], "code_location": {"file": "argument.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/config", "start_line": 106, "end_line": 112}, "code_snippet": "def _regex_transformer(value: str) -> Pattern[str]:\n    \"\"\"Prevents 're.error' from propagating and crash pylint.\"\"\"\n    try:\n        return re.compile(value)\n    except re.error as e:\n        msg = f\"Error in provided regular expression: {value} beginning at index {e.pos}: {e.msg}\"\n        raise argparse.ArgumentTypeError(msg) from e\n", "type": "function"}, {"name": "test_no_crash_with_formatting_regex_defaults", "is_method": true, "class_name": "TestRunTC", "parameters": ["self"], "calls": ["self._runtest", "TextReporter", "StringIO"], "code_location": {"file": "test_self.py", "path": "/data3/pwh/swebench-repos/pylint/tests", "start_line": 591, "end_line": 594}, "code_snippet": "    def test_no_crash_with_formatting_regex_defaults(self) -> None:\n        self._runtest(\n            [\"--ignore-patterns=a\"], reporter=TextReporter(StringIO()), code=32\n        )\n", "type": "function"}, {"name": "test_issue_2321_should_trigger", "is_method": true, "class_name": "TestFixme", "parameters": ["self"], "calls": ["self.assertAddsMessages", "self.checker.process_tokens", "MessageTest", "_tokenize_str"], "code_location": {"file": "unittest_misc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 93, "end_line": 103}, "code_snippet": "    def test_issue_2321_should_trigger(self) -> None:\n        code = \"# TODO this should not trigger a fixme\"\n        with self.assertAddsMessages(\n            MessageTest(\n                msg_id=\"fixme\",\n                line=1,\n                args=\"TODO this should not trigger a fixme\",\n                col_offset=1,\n            )\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n", "type": "function"}, {"name": "test_issue_2321_should_not_trigger", "is_method": true, "class_name": "TestFixme", "parameters": ["self"], "calls": ["self.assertNoMessages", "self.checker.process_tokens", "_tokenize_str"], "code_location": {"file": "unittest_misc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 88, "end_line": 91}, "code_snippet": "    def test_issue_2321_should_not_trigger(self) -> None:\n        code = 'print(\"# TODO this should not trigger a fixme\")'\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n", "type": "function"}, {"name": "test_without_space_fixme", "is_method": true, "class_name": "TestFixme", "parameters": ["self"], "calls": ["self.assertAddsMessages", "self.checker.process_tokens", "MessageTest", "_tokenize_str"], "code_location": {"file": "unittest_misc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 48, "end_line": 55}, "code_snippet": "    def test_without_space_fixme(self) -> None:\n        code = \"\"\"a = 1\n                #FIXME\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"FIXME\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n", "type": "function"}, {"name": "test_non_alphanumeric_codetag", "is_method": true, "class_name": "TestFixme", "parameters": ["self"], "calls": ["set_config", "self.assertAddsMessages", "self.checker.process_tokens", "MessageTest", "_tokenize_str"], "code_location": {"file": "unittest_misc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 58, "end_line": 65}, "code_snippet": "    def test_non_alphanumeric_codetag(self) -> None:\n        code = \"\"\"a = 1\n                #???\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n", "type": "function"}, {"name": "test_xxx_without_space", "is_method": true, "class_name": "TestFixme", "parameters": ["self"], "calls": ["self.assertAddsMessages", "self.checker.process_tokens", "MessageTest", "_tokenize_str"], "code_location": {"file": "unittest_misc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 32, "end_line": 39}, "code_snippet": "    def test_xxx_without_space(self) -> None:\n        code = \"\"\"a = 1\n                #XXX\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"XXX\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n", "type": "function"}, {"name": "test_regex_error", "is_method": false, "class_name": null, "parameters": ["capsys"], "calls": ["capsys.readouterr", "pytest.raises", "Run", "str"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pylint/tests/config", "start_line": 143, "end_line": 156}, "code_snippet": "def test_regex_error(capsys: CaptureFixture) -> None:\n    \"\"\"Check that we correctly error when an an option is passed whose value is an invalid regular expression.\"\"\"\n    with pytest.raises(SystemExit):\n        Run(\n            [str(EMPTY_MODULE), r\"--function-rgx=[\\p{Han}a-z_][\\p{Han}a-z0-9_]{2,30}$\"],\n            exit=False,\n        )\n    output = capsys.readouterr()\n\n    assertString = (\n        r\"Error in provided regular expression: [\\p{Han}a-z_][\\p{Han}a-z0-9_]{2,30}$ \"\n        r\"beginning at index 1: bad escape \\p\"\n    )\n    assert assertString in output.err\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1844308376312256}
{"question": "Why does the example function's docstring structure that starts with a blank line relate to the empty first line validation rule in the docstring style checker extension module?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "foo", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/d/docstring-first-line-empty", "start_line": 1, "end_line": 9}, "code_snippet": "def foo():  # [docstring-first-line-empty]\n    \"\"\"\n    Lorem Ipsum is simply dummy text of the printing and typesetting\n    industry.\n\n    Lorem Ipsum has been the industry's standard dummy text ever since the\n    1500s, when an unknown printer took a galley of type and scrambled it\n    to make a type specimen book\n    \"\"\"\n", "type": "function"}, {"name": "foo", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/e/empty-docstring", "start_line": 1, "end_line": 2}, "code_snippet": "def foo():  # [empty-docstring]\n    \"\"\"\"\"\"\n", "type": "function"}, {"name": "test_ignore_signatures_empty_functions_fail", "is_method": false, "class_name": null, "parameters": [], "calls": ["StringIO", "redirect_stdout", "pytest.raises", "symilar.Run", "strip", "strip", "output.getvalue"], "code_location": {"file": "unittest_symilar.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 257, "end_line": 278}, "code_snippet": "def test_ignore_signatures_empty_functions_fail() -> None:\n    output = StringIO()\n    with redirect_stdout(output), pytest.raises(SystemExit) as ex:\n        symilar.Run([EMPTY_FUNCTION_1, EMPTY_FUNCTION_2])\n    assert ex.value.code == 0\n    assert (\n        output.getvalue().strip()\n        == (\n            f'''\n6 similar lines in 2 files\n=={EMPTY_FUNCTION_1}:[1:7]\n=={EMPTY_FUNCTION_2}:[1:7]\n       arg1: int = 1,\n       arg2: str = \"2\",\n       arg3: int = 3,\n       arg4: bool = True,\n   ) -> None:\n       \"\"\"Valid function definition with docstring only.\"\"\"\nTOTAL lines=14 duplicates=6 percent=42.86\n'''\n        ).strip()\n    )\n", "type": "function"}, {"name": "test_docstring_lines_that_look_like_comments_1", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_functiondef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 492, "end_line": 511}, "code_snippet": "    def test_docstring_lines_that_look_like_comments_1(self) -> None:\n        stmt = astroid.extract_node(\n            '''def f():\n    \"\"\"\n    # msitake\n    \"\"\"'''\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=3,\n                args=(\n                    \"msitake\",\n                    \"    # msitake\",\n                    \"      ^^^^^^^\",\n                    self._get_msg_suggestions(\"msitake\"),\n                ),\n            )\n        ):\n            self.checker.visit_functiondef(stmt)\n", "type": "function"}, {"name": "test_docstring_lines_that_look_like_comments_4", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_functiondef"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 559, "end_line": 567}, "code_snippet": "    def test_docstring_lines_that_look_like_comments_4(self) -> None:\n        stmt = astroid.extract_node(\n            '''def f():\n    \"\"\"\n    # cat\n    \"\"\"'''\n        )\n        with self.assertAddsMessages():\n            self.checker.visit_functiondef(stmt)\n", "type": "function"}, {"name": "function", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "line_too_long.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/l/line", "start_line": 30, "end_line": 36}, "code_snippet": "def function():\n    # +3: [line-too-long]\n    \"\"\"This is a docstring.\n\n    That contains a very, very long line that exceeds the 100 characters limit by a good margin. So good?\n    \"\"\"\n    pass\n", "type": "function"}, {"name": "MyClass", "docstring": "test_no_docstring_rgx\nFunction that matches \"check no functions\" 'no-docstring-rgx' config option\nNo error message is emitted.", "methods": [], "attributes": [], "code_location": {"file": "missing_param_doc_required_no_doc_rgx_check_none.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "start_line": 7, "end_line": 16}, "type": "class"}, {"name": "method1", "is_method": true, "class_name": "FFFF", "parameters": ["self"], "calls": [], "code_location": {"file": "docstyle_first_line_empty.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/docstyle", "start_line": 19, "end_line": 22}, "code_snippet": "    def method1(self):  # [docstring-first-line-empty]\n        '''\n        Test Triple Single Quotes docstring\n        '''\n", "type": "function"}, {"name": "test_docstring_lines_that_look_like_comments_2", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_functiondef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 515, "end_line": 532}, "code_snippet": "    def test_docstring_lines_that_look_like_comments_2(self) -> None:\n        stmt = astroid.extract_node(\n            '''def f():\n    \"\"\"# msitake\"\"\"'''\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"msitake\",\n                    \"# msitake\",\n                    \"  ^^^^^^^\",\n                    self._get_msg_suggestions(\"msitake\"),\n                ),\n            )\n        ):\n            self.checker.visit_functiondef(stmt)\n", "type": "function"}, {"name": "test_docstring_lines_that_look_like_comments_3", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_functiondef", "MessageTest", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 536, "end_line": 555}, "code_snippet": "    def test_docstring_lines_that_look_like_comments_3(self) -> None:\n        stmt = astroid.extract_node(\n            '''def f():\n    \"\"\"\n# msitake\n    \"\"\"'''\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=3,\n                args=(\n                    \"msitake\",\n                    \"# msitake\",\n                    \"  ^^^^^^^\",\n                    self._get_msg_suggestions(\"msitake\"),\n                ),\n            )\n        ):\n            self.checker.visit_functiondef(stmt)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1947689056396484}
{"question": "How should the termination predicate evaluation within the iteration loop be decoupled from the iterable consumption mechanism to enable independent testing of the termination predicate evaluation and the alternative path value emission?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "for_else_break", "is_method": false, "class_name": null, "parameters": ["iterable"], "calls": ["print"], "code_location": {"file": "undefined_loop_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 113, "end_line": 119}, "code_snippet": "def for_else_break(iterable):\n    while True:\n        for thing in iterable:\n            break\n        else:\n            break\n        print(thing)\n", "type": "function"}, {"name": "map_iterable", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "good.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/r/redefined-builtin", "start_line": 1, "end_line": 2}, "code_snippet": "def map_iterable():\n    pass\n", "type": "function"}, {"name": "next_seven_elements", "is_method": false, "class_name": null, "parameters": ["iterator"], "calls": ["enumerate"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/n/no-else-break", "start_line": 1, "end_line": 6}, "code_snippet": "def next_seven_elements(iterator):\n    for i, item in enumerate(iterator):\n        if i == 7:  # [no-else-break]\n            break\n        else:\n            yield item\n", "type": "function"}, {"name": "for_else_returns", "is_method": false, "class_name": null, "parameters": ["iterable"], "calls": ["print"], "code_location": {"file": "undefined_loop_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 97, "end_line": 102}, "code_snippet": "def for_else_returns(iterable):\n    for thing in iterable:\n        break\n    else:\n        return\n    print(thing)\n", "type": "function"}, {"name": "for_else_continue", "is_method": false, "class_name": null, "parameters": ["iterable"], "calls": ["print"], "code_location": {"file": "undefined_loop_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 122, "end_line": 128}, "code_snippet": "def for_else_continue(iterable):\n    while True:\n        for thing in iterable:\n            break\n        else:\n            continue\n        print(thing)\n", "type": "function"}, {"name": "for_else_no_return", "is_method": false, "class_name": null, "parameters": ["iterable"], "calls": ["print", "fail"], "code_location": {"file": "undefined_loop_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 131, "end_line": 140}, "code_snippet": "def for_else_no_return(iterable):\n    def fail() -> NoReturn:\n        ...\n\n    while True:\n        for thing in iterable:\n            break\n        else:\n            fail()\n        print(thing)\n", "type": "function"}, {"name": "two_good_fruits_generator", "is_method": false, "class_name": null, "parameters": ["fruits"], "calls": ["fruit.is_tasty", "next", "next_fruit.is_tasty", "print"], "code_location": {"file": "two_good_fruit_generator.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/s/stop-iteration-return/good", "start_line": 1, "end_line": 16}, "code_snippet": "def two_good_fruits_generator(fruits):\n    \"\"\"A return can be used to end the iterator early, but not a StopIteration.\"\"\"\n    for fruit in fruits:\n        if not fruit.is_tasty():\n            continue\n        while True:\n            next_fruit = next(fruits, None)\n            if next_fruit is None:\n                print(\"Sorry there is only one fruit left.\")\n                yield fruit, None\n                # We reached the end of the 'fruits' generator but raising a\n                # StopIteration instead of returning would create a RuntimeError\n                return\n            if next_fruit.is_tasty():\n                yield fruit, next_fruit\n                break\n", "type": "function"}, {"name": "iterate_leaves", "is_method": false, "class_name": null, "parameters": ["leaves", "current_node"], "calls": ["isinstance", "results.append"], "code_location": {"file": "for_any_all.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/for_any_all", "start_line": 229, "end_line": 238}, "code_snippet": "def iterate_leaves(leaves, current_node):\n    results = []\n\n    current_node.was_checked = True\n    for leaf in leaves:\n        if isinstance(leaf, bool):\n            current_node.was_checked = False\n        else:\n            results.append(leaf)\n    return results\n", "type": "function"}, {"name": "for_else_raises", "is_method": false, "class_name": null, "parameters": ["iterable"], "calls": ["print"], "code_location": {"file": "undefined_loop_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 105, "end_line": 110}, "code_snippet": "def for_else_raises(iterable):\n    for thing in iterable:\n        break\n    else:\n        raise Exception\n    print(thing)\n", "type": "function"}, {"name": "_is_iterator", "is_method": true, "class_name": "SpecialMethodsChecker", "parameters": ["node"], "calls": ["isinstance", "isinstance", "isinstance", "isinstance", "node.local_attr", "node.metaclass", "isinstance", "metaclass.local_attr"], "code_location": {"file": "special_methods_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 298, "end_line": 320}, "code_snippet": "    def _is_iterator(node: InferenceResult) -> bool:\n        if isinstance(node, bases.Generator):\n            # Generators can be iterated.\n            return True\n        if isinstance(node, nodes.ComprehensionScope):\n            # Comprehensions can be iterated.\n            return True\n\n        if isinstance(node, bases.Instance):\n            try:\n                node.local_attr(NEXT_METHOD)\n                return True\n            except astroid.NotFoundError:\n                pass\n        elif isinstance(node, nodes.ClassDef):\n            metaclass = node.metaclass()\n            if metaclass and isinstance(metaclass, nodes.ClassDef):\n                try:\n                    metaclass.local_attr(NEXT_METHOD)\n                    return True\n                except astroid.NotFoundError:\n                    pass\n        return False\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2230446338653564}
{"question": "Why does the function that yields values in the assignment-from-no-return test use yield instead of return to validate exclusion from the no-return checker?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_no_return", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "unexpected_keyword_arg.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u", "start_line": 114, "end_line": 115}, "code_snippet": "def test_no_return():\n    pass\n", "type": "function"}, {"name": "invalid_object_passed_to_next", "is_method": false, "class_name": null, "parameters": [], "calls": ["next", "something_invalid"], "code_location": {"file": "stop_iteration_inside_generator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 145, "end_line": 146}, "code_snippet": "def invalid_object_passed_to_next():\n    yield next(something_invalid())  # [stop-iteration-return]\n", "type": "function"}, {"name": "coroutine_function_return_none", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "iterable_context_asyncio.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i", "start_line": 13, "end_line": 14}, "code_snippet": "def coroutine_function_return_none():\n    return\n", "type": "function"}, {"name": "gen_dont_crash_on_no_exception", "is_method": false, "class_name": null, "parameters": [], "calls": ["gen_ok", "next"], "code_location": {"file": "stop_iteration_inside_generator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 93, "end_line": 99}, "code_snippet": "def gen_dont_crash_on_no_exception():\n    g = gen_ok()\n    while True:\n        try:\n            yield next(g)  # [stop-iteration-return]\n        except ValueError:\n            raise\n", "type": "function"}, {"name": "func5", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "unreachable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u", "start_line": 30, "end_line": 33}, "code_snippet": "def func5():\n    \"\"\"Empty generator functions should be allowed.\"\"\"\n    return\n    yield\n", "type": "function"}, {"name": "gen_yield_from", "is_method": false, "class_name": null, "parameters": [], "calls": ["gen_ok"], "code_location": {"file": "stop_iteration_inside_generator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 89, "end_line": 90}, "code_snippet": "def gen_yield_from():\n    yield from gen_ok()\n", "type": "function"}, {"name": "_falsely_no_return_method", "is_method": true, "class_name": "ClassUnderTest", "parameters": ["self"], "calls": [], "code_location": {"file": "inconsistent_returns_noreturn.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/inconsistent", "start_line": 69, "end_line": 70}, "code_snippet": "    def _falsely_no_return_method(self) -> typing.NoReturn:\n        return 1\n", "type": "function"}, {"name": "test_suppress_on_return", "is_method": false, "class_name": null, "parameters": [], "calls": ["open"], "code_location": {"file": "consider_using_with_open.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c/consider", "start_line": 69, "end_line": 70}, "code_snippet": "def test_suppress_on_return():\n    return open(\"foo\", encoding=\"utf8\")  # must not trigger\n", "type": "function"}, {"name": "gen_next_with_sentinel", "is_method": false, "class_name": null, "parameters": [], "calls": ["next"], "code_location": {"file": "stop_iteration_inside_generator.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 109, "end_line": 110}, "code_snippet": "def gen_next_with_sentinel():\n    yield next([], 42)  # No bad return\n", "type": "function"}, {"name": "to_ten", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "yield_from_iterable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/y", "start_line": 6, "end_line": 7}, "code_snippet": "def to_ten():\n    yield from 10  # [not-an-iterable]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.218501329421997}
{"question": "Why does the inheritance chain from the base role class through the statement role class impact method resolution order computation performance when processing large batches of database query statement instances?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "StatementRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 73, "end_line": 74}, "type": "class"}, {"name": "ReturnsRowsRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 69, "end_line": 70}, "type": "class"}, {"name": "FromClauseRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 57, "end_line": 58}, "type": "class"}, {"name": "SQLRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 1, "end_line": 2}, "type": "class"}, {"name": "OrderByRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 37, "end_line": 38}, "type": "class"}, {"name": "StrictFromClauseRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 61, "end_line": 62}, "type": "class"}, {"name": "LimitOffsetRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 29, "end_line": 30}, "type": "class"}, {"name": "AnonymizedFromClauseRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 65, "end_line": 66}, "type": "class"}, {"name": "ColumnsClauseRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 25, "end_line": 26}, "type": "class"}, {"name": "DMLColumnRole", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "roles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "start_line": 77, "end_line": 78}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.2247941493988037}
{"question": "Why does the current implementation of the method that checks class subscriptability for generic type annotations cause performance overhead when the same class is checked repeatedly during static analysis?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "MaybeSubscriptable", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "unsupported_delete_operation.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unsupported", "start_line": 60, "end_line": 61}, "type": "class"}, {"name": "MaybeSubscriptable", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "unsupported_assignment_operation.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unsupported", "start_line": 60, "end_line": 61}, "type": "class"}, {"name": "MaybeSubscriptable", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "unsubscriptable_value.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u", "start_line": 62, "end_line": 63}, "type": "class"}, {"name": "typing_objects_are_subscriptable", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "generic"], "calls": ["astroid.parse", "self.assertNoMessages", "self.checker.visit_subscript"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 103, "end_line": 112}, "code_snippet": "    def typing_objects_are_subscriptable(self, generic: str) -> None:\n        module = astroid.parse(\n            f\"\"\"\n        import typing\n        test = typing.{generic}[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "test_issue3882_class_decorators", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self"], "calls": ["self.getitem_on_modules", "self.decorated_by_a_subscriptable_class", "self.decorated_by_an_unsubscriptable_class", "self.decorated_by_subscriptable_then_unsubscriptable_class", "self.decorated_by_unsubscriptable_then_subscriptable_class", "self.typing_objects_are_subscriptable"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 57, "end_line": 78}, "code_snippet": "    def test_issue3882_class_decorators(self) -> None:\n        decorators = \"\"\"\n        class Unsubscriptable:\n            def __init__(self, f):\n                self.f = f\n\n        class Subscriptable:\n            def __init__(self, f):\n                self.f = f\n\n            def __getitem__(self, item):\n                return item\n        \"\"\"\n        for generic in \"Optional\", \"List\", \"ClassVar\", \"Final\", \"Literal\":\n            self.typing_objects_are_subscriptable(generic)\n\n        self.getitem_on_modules()\n        self.decorated_by_a_subscriptable_class(decorators)\n        self.decorated_by_an_unsubscriptable_class(decorators)\n\n        self.decorated_by_subscriptable_then_unsubscriptable_class(decorators)\n        self.decorated_by_unsubscriptable_then_subscriptable_class(decorators)\n", "type": "function"}, {"name": "decorated_by_a_subscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertNoMessages", "self.checker.visit_subscript"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 114, "end_line": 127}, "code_snippet": "    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "decorated_by_unsubscriptable_then_subscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertNoMessages", "self.checker.visit_subscript"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 158, "end_line": 174}, "code_snippet": "    def decorated_by_unsubscriptable_then_subscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "ClsUnsubscriptable", "docstring": "", "methods": ["__init__", "__init__"], "attributes": [], "code_location": {"file": "generic_alias_related_py39.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/g/generic_alias", "start_line": 17, "end_line": 19}, "type": "class"}, {"name": "ClsUnsubscriptable", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "generic_alias_related.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/g/generic_alias", "start_line": 15, "end_line": 17}, "type": "class"}, {"name": "SubscriptableClass", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "unsupported_assignment_operation.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unsupported", "start_line": 71, "end_line": 72}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.2308719158172607}
{"question": "Why does the assignment name processing method defer frame node visitation until the local variable type attribute is accessed rather than visiting frames upfront?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "visit_assignname", "is_method": true, "class_name": "Linker", "parameters": ["self", "node"], "calls": ["hasattr", "list", "node.frame", "node.frame", "node.root", "hasattr", "isinstance", "self.visit_classdef", "isinstance", "set", "utils.infer_node", "self.visit_functiondef", "self.visit_module"], "code_location": {"file": "inspector.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/pyreverse", "start_line": 190, "end_line": 218}, "code_snippet": "    def visit_assignname(self, node: nodes.AssignName) -> None:\n        \"\"\"Visit an astroid.AssignName node.\n\n        handle locals_type\n        \"\"\"\n        # avoid double parsing done by different Linkers.visit\n        # running over the same project:\n        if hasattr(node, \"_handled\"):\n            return\n        node._handled = True\n        if node.name in node.frame():\n            frame = node.frame()\n        else:\n            # the name has been defined as 'global' in the frame and belongs\n            # there.\n            frame = node.root()\n        if not hasattr(frame, \"locals_type\"):\n            # If the frame doesn't have a locals_type yet,\n            # it means it wasn't yet visited. Visit it now\n            # to add what's missing from it.\n            if isinstance(frame, nodes.ClassDef):\n                self.visit_classdef(frame)\n            elif isinstance(frame, nodes.FunctionDef):\n                self.visit_functiondef(frame)\n            else:\n                self.visit_module(frame)\n\n        current = frame.locals_type[node.name]\n        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))\n", "type": "function"}, {"name": "visit_assignname", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["isinstance", "node.assign_type", "self.visit_name"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1652, "end_line": 1654}, "code_snippet": "    def visit_assignname(self, node: nodes.AssignName) -> None:\n        if isinstance(node.assign_type(), nodes.AugAssign):\n            self.visit_name(node)\n", "type": "function"}, {"name": "visit_assignname", "is_method": true, "class_name": "NameChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "node.frame", "node.assign_type", "isinstance", "self._check_name", "isinstance", "self._check_name", "isinstance", "self._check_name", "isinstance", "isinstance", "isinstance", "self._assigns_typealias", "self._check_name", "isinstance", "isinstance", "isinstance", "utils.safe_infer", "self._assigns_typevar", "self._assigns_typealias", "isinstance", "isinstance", "self._assigns_typevar", "self._assigns_typealias", "isinstance", "frame.argnames", "_redefines_import", "any", "utils.is_enum_member", "utils.is_assign_name_annotated_with", "self._check_name", "self._check_name", "self._check_name", "self._check_name", "node.parent.elts.index", "len", "node.parent.elts.index", "self._check_name", "self._check_name", "self._check_name", "isinstance", "self._assigns_typealias", "self._check_name", "self._check_name", "frame.local_attr_ancestors", "self._check_name", "node.parent.elts.index", "node.parent.elts.index", "isinstance", "utils.is_reassigned_before_current", "utils.is_reassigned_after_current", "utils.get_node_first_ancestor_of_type", "self._meets_exception_for_non_consts", "self._check_name", "astroid.are_exclusive", "_redefines_import", "tuple", "len", "igetattr", "node.frame"], "code_location": {"file": "checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base/name_checker", "start_line": 403, "end_line": 530}, "code_snippet": "    def visit_assignname(  # pylint: disable=too-many-branches\n        self, node: nodes.AssignName\n    ) -> None:\n        \"\"\"Check module level assigned names.\"\"\"\n        frame = node.frame()\n        assign_type = node.assign_type()\n\n        # Check names defined in comprehensions\n        if isinstance(assign_type, nodes.Comprehension):\n            self._check_name(\"inlinevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeVar):\n            self._check_name(\"typevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeAlias):\n            self._check_name(\"typealias\", node.name, node)\n\n        # Check names defined in module scope\n        elif isinstance(frame, nodes.Module):\n            # Check names defined in AnnAssign nodes\n            if isinstance(assign_type, nodes.AnnAssign) and self._assigns_typealias(\n                assign_type.annotation\n            ):\n                self._check_name(\"typealias\", node.name, node)\n\n            # Check names defined in Assign nodes\n            elif isinstance(assign_type, (nodes.Assign, nodes.AnnAssign)):\n                inferred_assign_type = (\n                    utils.safe_infer(assign_type.value) if assign_type.value else None\n                )\n\n                # Check TypeVar's and TypeAliases assigned alone or in tuple assignment\n                if isinstance(node.parent, nodes.Assign):\n                    if self._assigns_typevar(assign_type.value):\n                        self._check_name(\"typevar\", assign_type.targets[0].name, node)\n                        return\n                    if self._assigns_typealias(assign_type.value):\n                        self._check_name(\"typealias\", assign_type.targets[0].name, node)\n                        return\n\n                if (\n                    isinstance(node.parent, nodes.Tuple)\n                    and isinstance(assign_type.value, nodes.Tuple)\n                    # protect against unbalanced tuple unpacking\n                    and node.parent.elts.index(node) < len(assign_type.value.elts)\n                ):\n                    assigner = assign_type.value.elts[node.parent.elts.index(node)]\n                    if self._assigns_typevar(assigner):\n                        self._check_name(\n                            \"typevar\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_import := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                        and astroid.are_exclusive(*iattrs)\n                    ):\n                        node_type = \"const\"\n                    self._check_name(\n                        node_type,\n                        node.name,\n                        node,\n                        disallowed_check_only=redefines_import,\n                    )\n\n        # Check names defined in function scopes\n        elif isinstance(frame, nodes.FunctionDef):\n            # global introduced variable aren't in the function locals\n            if node.name in frame and node.name not in frame.argnames():\n                if not _redefines_import(node):\n                    if isinstance(\n                        assign_type, nodes.AnnAssign\n                    ) and self._assigns_typealias(assign_type.annotation):\n                        self._check_name(\"typealias\", node.name, node)\n                    else:\n                        self._check_name(\"variable\", node.name, node)\n\n        # Check names defined in class scopes\n        elif isinstance(frame, nodes.ClassDef) and not any(\n            frame.local_attr_ancestors(node.name)\n        ):\n            if utils.is_enum_member(node) or utils.is_assign_name_annotated_with(\n                node, \"Final\"\n            ):\n                self._check_name(\"class_const\", node.name, node)\n            else:\n                self._check_name(\"class_attribute\", node.name, node)\n", "type": "function"}, {"name": "visit_assignname", "is_method": true, "class_name": "RedefinedLoopNameChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "node.assign_type", "node.scope", "isinstance", "self.add_message", "utils.in_for_else_branch"], "code_location": {"file": "redefined_loop_name.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 35, "end_line": 52}, "code_snippet": "    def visit_assignname(self, node: nodes.AssignName) -> None:\n        assign_type = node.assign_type()\n        if not isinstance(assign_type, (nodes.Assign, nodes.AugAssign)):\n            return\n        node_scope = node.scope()\n        for outer_for, outer_variables, outer_for_scope in self._loop_variables:\n            if node_scope is not outer_for_scope:\n                continue\n            if node.name in outer_variables and not utils.in_for_else_branch(\n                outer_for, node\n            ):\n                self.add_message(\n                    \"redefined-loop-name\",\n                    args=(node.name, outer_for.fromlineno),\n                    node=node,\n                    confidence=HIGH,\n                )\n                break\n", "type": "function"}, {"name": "visit_assignname", "is_method": true, "class_name": "NonAsciiNameChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "node.frame", "isinstance", "isinstance", "self._check_name", "self._check_name", "self._check_name"], "code_location": {"file": "non_ascii_names.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 122, "end_line": 144}, "code_snippet": "    def visit_assignname(self, node: nodes.AssignName) -> None:\n        \"\"\"Check module level assigned names.\"\"\"\n        # The NameChecker from which this Checker originates knows a lot of different\n        # versions of variables, i.e. constants, inline variables etc.\n        # To simplify we use only `variable` here, as we don't need to apply different\n        # rules to different types of variables.\n        frame = node.frame()\n\n        if isinstance(frame, nodes.FunctionDef):\n            if node.parent in frame.body:\n                # Only perform the check if the assignment was done in within the body\n                # of the function (and not the function parameter definition\n                # (will be handled in visit_functiondef)\n                # or within a decorator (handled in visit_call)\n                self._check_name(\"variable\", node.name, node)\n        elif isinstance(frame, nodes.ClassDef):\n            self._check_name(\"attr\", node.name, node)\n        else:\n            # Possibilities here:\n            # - isinstance(node.assign_type(), nodes.Comprehension) == inlinevar\n            # - isinstance(frame, nodes.Module) == variable (constant?)\n            # - some other kind of assignment missed but still most likely a variable\n            self._check_name(\"variable\", node.name, node)\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "assign_node"], "calls": ["only_required_for_messages", "self._check_classmethod_declaration", "self._uses_mandatory_method_param", "self._check_protected_attribute_access", "isinstance"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 1843, "end_line": 1851}, "code_snippet": "    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n        if self._uses_mandatory_method_param(node):\n            return\n        self._check_protected_attribute_access(node)\n", "type": "function"}, {"name": "leave_assign", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["self._store_type_annotation_names"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 2160, "end_line": 2161}, "code_snippet": "    def leave_assign(self, node: nodes.Assign) -> None:\n        self._store_type_annotation_names(node)\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "TypeChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "self._check_assignment_from_function_call", "self._check_dundername_is_string"], "code_location": {"file": "typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1221, "end_line": 1224}, "code_snippet": "    def visit_assign(self, node: nodes.Assign) -> None:\n        \"\"\"Process assignments in the AST.\"\"\"\n        self._check_assignment_from_function_call(node)\n        self._check_dundername_is_string(node)\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "MultipleTypesChecker", "parameters": ["self", "node"], "calls": ["isinstance", "is_none", "node_type", "append", "setdefault", "_type.pytype", "target.as_string"], "code_location": {"file": "redefined_variable_type.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 92, "end_line": 104}, "code_snippet": "    def visit_assign(self, node: nodes.Assign) -> None:\n        # we don't handle multiple assignment nor slice assignment\n        target = node.targets[0]\n        if isinstance(target, (nodes.Tuple, nodes.Subscript)):\n            return\n        # ignore NoneType\n        if is_none(node):\n            return\n        _type = node_type(node.value)\n        if _type:\n            self._assigns[-1].setdefault(target.as_string(), []).append(\n                (node, _type.pytype())\n            )\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "BasicChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self._check_self_assigning_variable", "self._check_redeclared_assign_name"], "code_location": {"file": "basic_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 963, "end_line": 965}, "code_snippet": "    def visit_assign(self, node: nodes.Assign) -> None:\n        self._check_self_assigning_variable(node)\n        self._check_redeclared_assign_name(node.targets)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2384722232818604}
{"question": "Why does repeatedly instantiating the mock linter, AST walker, and test checker in the message filtering decorator test method degrade performance across thousands of similar test cases?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_deprecated_methods", "is_method": true, "class_name": "TestASTWalker", "parameters": ["self"], "calls": ["self.MockLinter", "ASTWalker", "Checker", "walker.add_checker", "only_required_for_messages", "warnings.catch_warnings", "warnings.simplefilter", "walker.walk", "astroid.parse"], "code_location": {"file": "unittest_ast_walker.py", "path": "/data3/pwh/swebench-repos/pylint/tests/utils", "start_line": 60, "end_line": 80}, "code_snippet": "    def test_deprecated_methods(self) -> None:\n        class Checker(BaseChecker):\n            # pylint: disable-next=super-init-not-called\n            def __init__(self) -> None:\n                self.called = False\n\n            @only_required_for_messages(\"first-message\")\n            def visit_assname(\n                self, node: nodes.AssignName  # pylint: disable=unused-argument\n            ) -> None:\n                self.called = True\n\n        linter = self.MockLinter({\"first-message\": True})\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = Checker()\n        walker.add_checker(checker)\n        with warnings.catch_warnings(record=True):\n            warnings.simplefilter(\"always\")\n            walker.walk(astroid.parse(\"x = 1\"))\n\n            assert not checker.called\n", "type": "function"}, {"name": "test_only_required_for_messages", "is_method": true, "class_name": "TestASTWalker", "parameters": ["self"], "calls": ["self.MockLinter", "ASTWalker", "self.Checker", "walker.add_checker", "walker.walk", "astroid.parse"], "code_location": {"file": "unittest_ast_walker.py", "path": "/data3/pwh/swebench-repos/pylint/tests/utils", "start_line": 50, "end_line": 58}, "code_snippet": "    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = func()\"))\n        assert {\"module\", \"assignname\"} == checker.called\n", "type": "function"}, {"name": "test_pylint_visit_method_taken_in_account", "is_method": false, "class_name": null, "parameters": ["linter"], "calls": ["linter.register_checker", "linter.open", "StringIO", "linter.set_reporter", "linter.check", "only_required_for_messages", "CustomChecker", "text.TextReporter"], "code_location": {"file": "unittest_lint.py", "path": "/data3/pwh/swebench-repos/pylint/tests/lint", "start_line": 219, "end_line": 232}, "code_snippet": "def test_pylint_visit_method_taken_in_account(linter: PyLinter) -> None:\n    class CustomChecker(checkers.BaseChecker):\n        name = \"custom\"\n        msgs = {\"W9999\": (\"\", \"custom\", \"\")}\n\n        @only_required_for_messages(\"custom\")\n        def visit_class(self, _: nodes.ClassDef) -> None:\n            pass\n\n    linter.register_checker(CustomChecker(linter))\n    linter.open()\n    out = StringIO()\n    linter.set_reporter(text.TextReporter(out))\n    linter.check([\"abc\"])\n", "type": "function"}, {"name": "initialized_linter", "is_method": false, "class_name": null, "parameters": ["linter"], "calls": ["linter.open", "linter.set_current_module", "FileState", "linter.get_ast", "str", "join"], "code_location": {"file": "unittest_lint.py", "path": "/data3/pwh/swebench-repos/pylint/tests/lint", "start_line": 206, "end_line": 216}, "code_snippet": "def initialized_linter(linter: PyLinter) -> PyLinter:\n    linter.open()\n    linter.set_current_module(\"long_test_file\", \"long_test_file\")\n    linter.file_state = FileState(\n        \"long_test_file\",\n        linter.msgs_store,\n        linter.get_ast(\n            str(join(REGRTEST_DATA_DIR, \"long_test_file.py\")), \"long_test_file\"\n        ),\n    )\n    return linter\n", "type": "function"}, {"name": "test_base_checker_consistent_hash", "is_method": false, "class_name": null, "parameters": [], "calls": ["PyLinter", "MessageWithOptionsChecker", "hash", "checker.msgs.items", "checker.create_message_definition_from_tuple", "hash"], "code_location": {"file": "unittest_base_checker.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 173, "end_line": 185}, "code_snippet": "def test_base_checker_consistent_hash() -> None:\n    linter = PyLinter()\n    checker = MessageWithOptionsChecker(linter)\n    some_set = {checker}\n\n    original_hash = hash(checker)\n    assert checker in some_set\n\n    for msgid, msg in checker.msgs.items():\n        checker.create_message_definition_from_tuple(msgid, msg)\n\n    assert hash(checker) == original_hash\n    assert checker in some_set\n", "type": "function"}, {"name": "store", "is_method": false, "class_name": null, "parameters": [], "calls": ["MessageDefinitionStore", "store_.register_messages_from_checker", "Checker", "__init__", "PyLinter", "super"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pylint/tests/message", "start_line": 34, "end_line": 58}, "code_snippet": "def store() -> MessageDefinitionStore:\n    store_ = MessageDefinitionStore()\n\n    class Checker(BaseChecker):\n        def __init__(self) -> None:\n            super().__init__(PyLinter())\n\n        name = \"achecker\"\n        msgs = {\n            \"W1234\": (\n                \"message\",\n                \"msg-symbol\",\n                \"msg description.\",\n                {\"old_names\": [(\"W0001\", \"old-symbol\")]},\n            ),\n            \"E1234\": (\n                \"Duplicate keyword argument %r in %s call\",\n                \"duplicate-keyword-arg\",\n                \"Used when a function call passes the same keyword argument multiple times.\",\n                {\"maxversion\": (2, 6)},\n            ),\n        }\n\n    store_.register_messages_from_checker(Checker())\n    return store_\n", "type": "function"}, {"name": "test_base_checker_invalid_message", "is_method": false, "class_name": null, "parameters": [], "calls": ["PyLinter", "pytest.raises", "linter.register_checker", "MissingFieldsChecker"], "code_location": {"file": "unittest_base_checker.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 167, "end_line": 170}, "code_snippet": "def test_base_checker_invalid_message() -> None:\n    linter = PyLinter()\n    with pytest.raises(InvalidMessageError):\n        linter.register_checker(MissingFieldsChecker(linter))\n", "type": "function"}, {"name": "test_enable_message_block", "is_method": false, "class_name": null, "parameters": ["initialized_linter"], "calls": ["linter.open", "join", "linter.set_current_module", "linter.get_ast", "FileState", "linter.process_tokens", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "tokenize_module", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled", "linter.is_message_enabled"], "code_location": {"file": "unittest_lint.py", "path": "/data3/pwh/swebench-repos/pylint/tests/lint", "start_line": 289, "end_line": 343}, "code_snippet": "def test_enable_message_block(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    linter.open()\n    filepath = join(REGRTEST_DATA_DIR, \"func_block_disable_msg.py\")\n    linter.set_current_module(\"func_block_disable_msg\")\n    astroid = linter.get_ast(filepath, \"func_block_disable_msg\")\n    linter.file_state = FileState(\"func_block_disable_msg\", linter.msgs_store, astroid)\n    linter.process_tokens(tokenize_module(astroid))\n    fs = linter.file_state\n    # global (module level)\n    assert linter.is_message_enabled(\"W0613\")\n    assert linter.is_message_enabled(\"E1101\")\n    # meth1\n    assert linter.is_message_enabled(\"W0613\", 13)\n    # meth2\n    assert not linter.is_message_enabled(\"W0613\", 18)\n    # meth3\n    assert not linter.is_message_enabled(\"E1101\", 24)\n    assert linter.is_message_enabled(\"E1101\", 26)\n    # meth4\n    assert not linter.is_message_enabled(\"E1101\", 32)\n    assert linter.is_message_enabled(\"E1101\", 36)\n    # meth5\n    assert not linter.is_message_enabled(\"E1101\", 42)\n    assert not linter.is_message_enabled(\"E1101\", 43)\n    assert linter.is_message_enabled(\"E1101\", 46)\n    assert not linter.is_message_enabled(\"E1101\", 49)\n    assert not linter.is_message_enabled(\"E1101\", 51)\n    # meth6\n    assert not linter.is_message_enabled(\"E1101\", 57)\n    assert linter.is_message_enabled(\"E1101\", 61)\n    assert linter.is_message_enabled(\"E1101\", 64)\n    assert not linter.is_message_enabled(\"E1101\", 66)\n\n    assert linter.is_message_enabled(\"E0602\", 57)\n    assert linter.is_message_enabled(\"E0602\", 61)\n    assert not linter.is_message_enabled(\"E0602\", 62)\n    assert linter.is_message_enabled(\"E0602\", 64)\n    assert linter.is_message_enabled(\"E0602\", 66)\n    # meth7\n    assert not linter.is_message_enabled(\"E1101\", 70)\n    assert linter.is_message_enabled(\"E1101\", 72)\n    assert linter.is_message_enabled(\"E1101\", 75)\n    assert linter.is_message_enabled(\"E1101\", 77)\n\n    assert fs._suppression_mapping[\"W0613\", 18] == 17\n    assert fs._suppression_mapping[\"E1101\", 33] == 30\n    assert (\"E1101\", 46) not in fs._suppression_mapping\n    assert fs._suppression_mapping[\"C0302\", 18] == 1\n    assert fs._suppression_mapping[\"C0302\", 50] == 1\n    # This is tricky. While the disable in line 106 is disabling\n    # both 108 and 110, this is usually not what the user wanted.\n    # Therefore, we report the closest previous disable comment.\n    assert fs._suppression_mapping[\"E1101\", 108] == 106\n    assert fs._suppression_mapping[\"E1101\", 110] == 109\n", "type": "function"}, {"name": "only_required_for_messages", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 472, "end_line": 493}, "code_snippet": "def only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n\n    def store_messages(\n        func: AstCallbackMethod[_CheckerT, _NodeT],\n    ) -> AstCallbackMethod[_CheckerT, _NodeT]:\n        func.checks_msgs = messages  # type: ignore[attr-defined]\n        return func\n\n    return store_messages\n", "type": "function"}, {"name": "gen_tests", "is_method": false, "class_name": null, "parameters": ["filter_rgx"], "calls": ["_get_tests_info", "UPDATE_FILE.exists", "_get_tests_info", "tests.append", "len", "join", "re.compile", "module_file.endswith", "split", "is_to_run", "str", "module_file.replace"], "code_location": {"file": "test_func.py", "path": "/data3/pwh/swebench-repos/pylint/tests", "start_line": 110, "end_line": 131}, "code_snippet": "def gen_tests(\n    filter_rgx: str | re.Pattern[str] | None,\n) -> list[tuple[str, str, list[tuple[str, str]]]]:\n    if filter_rgx:\n        is_to_run = re.compile(filter_rgx).search\n    else:\n        is_to_run = (  # noqa: E731 we're going to throw all this anyway\n            lambda x: 1  # type: ignore[assignment] # pylint: disable=unnecessary-lambda-assignment\n        )\n    tests: list[tuple[str, str, list[tuple[str, str]]]] = []\n    for module_file, messages_file in _get_tests_info(INPUT_DIR, MSG_DIR, \"func_\", \"\"):\n        if not is_to_run(module_file) or module_file.endswith((\".pyc\", \"$py.class\")):\n            continue\n        base = module_file.replace(\".py\", \"\").split(\"_\")[1]\n        dependencies = _get_tests_info(INPUT_DIR, MSG_DIR, base, \".py\")\n        tests.append((module_file, messages_file, dependencies))\n    if UPDATE_FILE.exists():\n        return tests\n    assert len(tests) < 13, \"Please do not add new test cases here.\" + \"\\n\".join(\n        str(k) for k in tests if not k[2]\n    )\n    return tests\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2368268966674805}
{"question": "Why does the property method that provides controlled access to a private attribute serve as a controlled accessor in the encapsulation pattern demonstrated by the test class?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "PropertyGood", "docstring": "Using properties is safe. ", "methods": ["test", "test", "__init__"], "attributes": ["__slots__"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 59, "end_line": 74}, "type": "class"}, {"name": "Test", "docstring": "test format attribute access ", "methods": [], "attributes": [], "code_location": {"file": "string_formatting.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/string", "start_line": 17, "end_line": 20}, "type": "class"}, {"name": "PropertyGood2", "docstring": "Using properties in the body of the class is safe. ", "methods": ["_getter", "_setter", "__init__"], "attributes": ["__slots__", "test"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 76, "end_line": 90}, "type": "class"}, {"name": "test", "is_method": true, "class_name": "A", "parameters": ["self"], "calls": [], "code_location": {"file": "regression_property_no_member_3269.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression", "start_line": 8, "end_line": 10}, "code_snippet": "    def test(self):\n        \"\"\"A property\"\"\"\n        return \"test\"\n", "type": "function"}, {"name": "a_method", "is_method": true, "class_name": "Parent2", "parameters": ["self"], "calls": [], "code_location": {"file": "regression_properties_in_class_context.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression", "start_line": 34, "end_line": 35}, "code_snippet": "    def a_method(self):\n        return \"actually a property\"\n", "type": "function"}, {"name": "prop", "is_method": true, "class_name": "Mine", "parameters": ["self"], "calls": [], "code_location": {"file": "attribute_defined_outside_init.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a", "start_line": 75, "end_line": 76}, "code_snippet": "    def prop(self):\n        return self.__prop\n", "type": "function"}, {"name": "correct_access", "is_method": true, "class_name": "Issue1031", "parameters": ["self"], "calls": ["type"], "code_location": {"file": "access_to_protected_members.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/access", "start_line": 50, "end_line": 52}, "code_snippet": "    def correct_access(self):\n        \"\"\"Demonstrates correct access\"\"\"\n        return type(self)._attr\n", "type": "function"}, {"name": "PropertyTest", "docstring": "class ", "methods": ["__init__", "test", "test", "custom", "custom"], "attributes": [], "code_location": {"file": "not_callable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n", "start_line": 40, "end_line": 64}, "type": "class"}, {"name": "FooClass", "docstring": "A test case for property names.\n\nSince by default, the regex for attributes is the same as the one\nfor method names, we check the warning messages to contain the\nstring 'attribute'.", "methods": ["PROPERTY_NAME", "ABSTRACT_PROPERTY_NAME", "PROPERTY_NAME_SETTER", "_nice_and_long_descriptive_private_method_name", "FOO", "bar", "BAZ", "QUX"], "attributes": [], "code_location": {"file": "name_styles.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/name", "start_line": 102, "end_line": 127}, "type": "class"}, {"name": "my_public_x", "is_method": true, "class_name": "my_class", "parameters": ["self"], "calls": [], "code_location": {"file": "name_good_bad_names_regex.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/name", "start_line": 15, "end_line": 16}, "code_snippet": "    def my_public_x(self):\n        return self._my_secret_x * 2\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2350764274597168}
{"question": "Why does the test framework use a metaclass that assigns a lambda with an incorrect signature to __or__ for a test class in the alternative union syntax validation tests?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "MetaclassWithInvalidMRO", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "invalid_metaclass.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 75, "end_line": 76}, "type": "class"}, {"name": "valid_metaclass_2", "is_method": false, "class_name": null, "parameters": ["_name", "_bases", "_attrs"], "calls": [], "code_location": {"file": "invalid_metaclass_py3.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 10, "end_line": 11}, "code_snippet": "def valid_metaclass_2(_name, _bases, _attrs):\n    return Unknown\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "SixthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 89, "end_line": 90}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n", "type": "function"}, {"name": "InvalidAsMetaclass", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "invalid_metaclass.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 15, "end_line": 16}, "type": "class"}, {"name": "__or__", "is_method": true, "class_name": "ForwardMetaclass", "parameters": ["cls", "other"], "calls": [], "code_location": {"file": "alternative_union_syntax_error.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/alternative", "start_line": 102, "end_line": 103}, "code_snippet": "    def __or__(cls, other):\n        return True\n", "type": "function"}, {"name": "__or__", "is_method": true, "class_name": "ForwardMetaclass", "parameters": ["cls", "other"], "calls": [], "code_location": {"file": "alternative_union_syntax.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/alternative", "start_line": 89, "end_line": 90}, "code_snippet": "    def __or__(cls, other):\n        return True\n", "type": "function"}, {"name": "func2", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "alternative_union_syntax_error.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/alternative", "start_line": 42, "end_line": 43}, "code_snippet": "def func2() -> int | str:  # [unsupported-binary-operation]\n    pass\n", "type": "function"}, {"name": "func", "is_method": false, "class_name": null, "parameters": ["arg"], "calls": [], "code_location": {"file": "alternative_union_syntax_error.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/alternative", "start_line": 39, "end_line": 40}, "code_snippet": "def func(arg: int | str):  # [unsupported-binary-operation]\n    pass\n", "type": "function"}, {"name": "__getnewargs__", "is_method": true, "class_name": "ThirdBadGetNewArgs", "parameters": ["self"], "calls": ["tuple"], "code_location": {"file": "invalid_getnewargs_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 50, "end_line": 51}, "code_snippet": "    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return lambda: tuple(1, 2)\n", "type": "function"}, {"name": "invalid_metaclass_2", "is_method": false, "class_name": null, "parameters": ["name", "bases", "attrs"], "calls": [], "code_location": {"file": "invalid_metaclass.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 63, "end_line": 64}, "code_snippet": "def invalid_metaclass_2(name, bases, attrs):\n    return 1\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2748243808746338}
{"question": "What determines whether the function call assignment validator or the dunder name string validator executes first in the type checker's assignment processing method?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_check_dundername_is_string", "is_method": true, "class_name": "TypeChecker", "parameters": ["self", "node"], "calls": ["utils.safe_infer", "isinstance", "isinstance", "isinstance", "self.add_message", "isinstance", "isinstance"], "code_location": {"file": "typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1303, "end_line": 1321}, "code_snippet": "    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n        \"\"\"Check a string is assigned to self.__name__.\"\"\"\n        # Check the left-hand side of the assignment is <something>.__name__\n        lhs = node.targets[0]\n        if not isinstance(lhs, nodes.AssignAttr):\n            return\n        if not lhs.attrname == \"__name__\":\n            return\n\n        # If the right-hand side is not a string\n        rhs = node.value\n        if isinstance(rhs, nodes.Const) and isinstance(rhs.value, str):\n            return\n        inferred = utils.safe_infer(rhs)\n        if not inferred:\n            return\n        if not (isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)):\n            # Add the message\n            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n", "type": "function"}, {"name": "visit_call", "is_method": true, "class_name": "DunderCallChecker", "parameters": ["self", "node"], "calls": ["isinstance", "safe_infer", "self.add_message", "self.within_dunder_or_lambda_def", "isinstance", "isinstance", "isinstance"], "code_location": {"file": "dunder_methods.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 74, "end_line": 98}, "code_snippet": "    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check if method being called is an unnecessary dunder method.\"\"\"\n        if (\n            isinstance(node.func, nodes.Attribute)\n            and node.func.attrname in self._dunder_methods\n            and not self.within_dunder_or_lambda_def(node)\n            and not (\n                isinstance(node.func.expr, nodes.Call)\n                and isinstance(node.func.expr.func, nodes.Name)\n                and node.func.expr.func.name == \"super\"\n            )\n        ):\n            inf_expr = safe_infer(node.func.expr)\n            if not (\n                inf_expr is None or isinstance(inf_expr, (Instance, UninferableBase))\n            ):\n                # Skip dunder calls to non instantiated classes.\n                return\n\n            self.add_message(\n                \"unnecessary-dunder-call\",\n                node=node,\n                args=(node.func.attrname, self._dunder_methods[node.func.attrname]),\n                confidence=HIGH,\n            )\n", "type": "function"}, {"name": "within_dunder_or_lambda_def", "is_method": true, "class_name": "DunderCallChecker", "parameters": ["node"], "calls": ["DunderCallChecker.is_lambda_rule_exception", "isinstance", "parent.name.startswith", "parent.name.endswith"], "code_location": {"file": "dunder_methods.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 54, "end_line": 65}, "code_snippet": "    def within_dunder_or_lambda_def(node: nodes.NodeNG) -> bool:\n        \"\"\"Check if dunder method call is within a dunder method definition.\"\"\"\n        parent = node.parent\n        while parent is not None:\n            if (\n                isinstance(parent, nodes.FunctionDef)\n                and parent.name.startswith(\"__\")\n                and parent.name.endswith(\"__\")\n            ) or DunderCallChecker.is_lambda_rule_exception(parent, node):\n                return True\n            parent = parent.parent\n        return False\n", "type": "function"}, {"name": "_meets_exception_for_non_consts", "is_method": true, "class_name": "NameChecker", "parameters": ["self", "inferred_assign_type", "name"], "calls": ["isinstance", "regexp.match"], "code_location": {"file": "checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base/name_checker", "start_line": 532, "end_line": 538}, "code_snippet": "    def _meets_exception_for_non_consts(\n        self, inferred_assign_type: InferenceResult | None, name: str\n    ) -> bool:\n        if isinstance(inferred_assign_type, nodes.Const):\n            return False\n        regexp = self._name_regexps[\"variable\"]\n        return regexp.match(name) is not None\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "assign_node"], "calls": ["only_required_for_messages", "self._check_classmethod_declaration", "self._uses_mandatory_method_param", "self._check_protected_attribute_access", "isinstance"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 1843, "end_line": 1851}, "code_snippet": "    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n        if self._uses_mandatory_method_param(node):\n            return\n        self._check_protected_attribute_access(node)\n", "type": "function"}, {"name": "compute_first_non_import_node", "is_method": true, "class_name": "ImportsChecker", "parameters": ["self", "node"], "calls": ["isinstance", "isinstance", "isinstance", "any", "all", "node.nodes_of_class", "isinstance", "target.name.startswith", "target.name.endswith"], "code_location": {"file": "imports.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 612, "end_line": 647}, "code_snippet": "    def compute_first_non_import_node(\n        self,\n        node: (\n            nodes.If\n            | nodes.Expr\n            | nodes.Comprehension\n            | nodes.IfExp\n            | nodes.Assign\n            | nodes.AssignAttr\n            | nodes.Try\n        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n        if self._first_non_import_node:\n            return\n        if not isinstance(node.parent, nodes.Module):\n            return\n        if isinstance(node, nodes.Try) and any(\n            node.nodes_of_class((nodes.Import, nodes.ImportFrom))\n        ):\n            return\n        if isinstance(node, nodes.Assign):\n            # Add compatibility for module level dunder names\n            # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names\n            valid_targets = [\n                isinstance(target, nodes.AssignName)\n                and target.name.startswith(\"__\")\n                and target.name.endswith(\"__\")\n                for target in node.targets\n            ]\n            if all(valid_targets):\n                return\n        self._first_non_import_node = node\n", "type": "function"}, {"name": "visit_assignname", "is_method": true, "class_name": "NameChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "node.frame", "node.assign_type", "isinstance", "self._check_name", "isinstance", "self._check_name", "isinstance", "self._check_name", "isinstance", "isinstance", "isinstance", "self._assigns_typealias", "self._check_name", "isinstance", "isinstance", "isinstance", "utils.safe_infer", "self._assigns_typevar", "self._assigns_typealias", "isinstance", "isinstance", "self._assigns_typevar", "self._assigns_typealias", "isinstance", "frame.argnames", "_redefines_import", "any", "utils.is_enum_member", "utils.is_assign_name_annotated_with", "self._check_name", "self._check_name", "self._check_name", "self._check_name", "node.parent.elts.index", "len", "node.parent.elts.index", "self._check_name", "self._check_name", "self._check_name", "isinstance", "self._assigns_typealias", "self._check_name", "self._check_name", "frame.local_attr_ancestors", "self._check_name", "node.parent.elts.index", "node.parent.elts.index", "isinstance", "utils.is_reassigned_before_current", "utils.is_reassigned_after_current", "utils.get_node_first_ancestor_of_type", "self._meets_exception_for_non_consts", "self._check_name", "astroid.are_exclusive", "_redefines_import", "tuple", "len", "igetattr", "node.frame"], "code_location": {"file": "checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base/name_checker", "start_line": 403, "end_line": 530}, "code_snippet": "    def visit_assignname(  # pylint: disable=too-many-branches\n        self, node: nodes.AssignName\n    ) -> None:\n        \"\"\"Check module level assigned names.\"\"\"\n        frame = node.frame()\n        assign_type = node.assign_type()\n\n        # Check names defined in comprehensions\n        if isinstance(assign_type, nodes.Comprehension):\n            self._check_name(\"inlinevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeVar):\n            self._check_name(\"typevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeAlias):\n            self._check_name(\"typealias\", node.name, node)\n\n        # Check names defined in module scope\n        elif isinstance(frame, nodes.Module):\n            # Check names defined in AnnAssign nodes\n            if isinstance(assign_type, nodes.AnnAssign) and self._assigns_typealias(\n                assign_type.annotation\n            ):\n                self._check_name(\"typealias\", node.name, node)\n\n            # Check names defined in Assign nodes\n            elif isinstance(assign_type, (nodes.Assign, nodes.AnnAssign)):\n                inferred_assign_type = (\n                    utils.safe_infer(assign_type.value) if assign_type.value else None\n                )\n\n                # Check TypeVar's and TypeAliases assigned alone or in tuple assignment\n                if isinstance(node.parent, nodes.Assign):\n                    if self._assigns_typevar(assign_type.value):\n                        self._check_name(\"typevar\", assign_type.targets[0].name, node)\n                        return\n                    if self._assigns_typealias(assign_type.value):\n                        self._check_name(\"typealias\", assign_type.targets[0].name, node)\n                        return\n\n                if (\n                    isinstance(node.parent, nodes.Tuple)\n                    and isinstance(assign_type.value, nodes.Tuple)\n                    # protect against unbalanced tuple unpacking\n                    and node.parent.elts.index(node) < len(assign_type.value.elts)\n                ):\n                    assigner = assign_type.value.elts[node.parent.elts.index(node)]\n                    if self._assigns_typevar(assigner):\n                        self._check_name(\n                            \"typevar\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_import := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                        and astroid.are_exclusive(*iattrs)\n                    ):\n                        node_type = \"const\"\n                    self._check_name(\n                        node_type,\n                        node.name,\n                        node,\n                        disallowed_check_only=redefines_import,\n                    )\n\n        # Check names defined in function scopes\n        elif isinstance(frame, nodes.FunctionDef):\n            # global introduced variable aren't in the function locals\n            if node.name in frame and node.name not in frame.argnames():\n                if not _redefines_import(node):\n                    if isinstance(\n                        assign_type, nodes.AnnAssign\n                    ) and self._assigns_typealias(assign_type.annotation):\n                        self._check_name(\"typealias\", node.name, node)\n                    else:\n                        self._check_name(\"variable\", node.name, node)\n\n        # Check names defined in class scopes\n        elif isinstance(frame, nodes.ClassDef) and not any(\n            frame.local_attr_ancestors(node.name)\n        ):\n            if utils.is_enum_member(node) or utils.is_assign_name_annotated_with(\n                node, \"Final\"\n            ):\n                self._check_name(\"class_const\", node.name, node)\n            else:\n                self._check_name(\"class_attribute\", node.name, node)\n", "type": "function"}, {"name": "_is_called_inside_special_method", "is_method": true, "class_name": "ClassChecker", "parameters": ["node"], "calls": ["node.frame"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 2000, "end_line": 2003}, "code_snippet": "    def _is_called_inside_special_method(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns true if the node is located inside a special (aka dunder) method.\"\"\"\n        frame_name = node.frame().name\n        return frame_name and frame_name in PYMETHODS\n", "type": "function"}, {"name": "is_lambda_rule_exception", "is_method": true, "class_name": "DunderCallChecker", "parameters": ["ancestor", "node"], "calls": ["isinstance"], "code_location": {"file": "dunder_methods.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 68, "end_line": 72}, "code_snippet": "    def is_lambda_rule_exception(ancestor: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n        return (\n            isinstance(ancestor, nodes.Lambda)\n            and node.func.attrname in UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS\n        )\n", "type": "function"}, {"name": "visit_assign", "is_method": true, "class_name": "StringConstantChecker", "parameters": ["self", "node"], "calls": ["isinstance", "isinstance", "self.check_for_concatenated_strings"], "code_location": {"file": "strings.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 820, "end_line": 822}, "code_snippet": "    def visit_assign(self, node: nodes.Assign) -> None:\n        if isinstance(node.value, nodes.Const) and isinstance(node.value.value, str):\n            self.check_for_concatenated_strings([node.value], \"assignment\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3398125171661377}
{"question": "Where does the yield statement in the context manager function that assigns a context variable and yields it without cleanup establish a data dependency between the variable assignment and the control flow suspension point?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "genfunc_with_cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["cm"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/c/contextmanager-generator-missing-cleanup", "start_line": 12, "end_line": 14}, "code_snippet": "def genfunc_with_cm():\n    with cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n", "type": "function"}, {"name": "genfunc_with_cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["cm"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 17, "end_line": 19}, "code_snippet": "def genfunc_with_cm():\n    with cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n", "type": "function"}, {"name": "genfunc_with_name_cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["name_cm"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 30, "end_line": 32}, "code_snippet": "def genfunc_with_name_cm():\n    with name_cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n", "type": "function"}, {"name": "good_cm_no_cleanup", "is_method": false, "class_name": null, "parameters": [], "calls": ["print"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 181, "end_line": 184}, "code_snippet": "def good_cm_no_cleanup():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n", "type": "function"}, {"name": "good_cm_no_cleanup", "is_method": false, "class_name": null, "parameters": [], "calls": ["print"], "code_location": {"file": "good.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/c/contextmanager-generator-missing-cleanup", "start_line": 53, "end_line": 56}, "code_snippet": "def good_cm_no_cleanup():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n", "type": "function"}, {"name": "cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 10, "end_line": 14}, "code_snippet": "def cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n", "type": "function"}, {"name": "cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/c/contextmanager-generator-missing-cleanup", "start_line": 5, "end_line": 9}, "code_snippet": "def cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n", "type": "function"}, {"name": "name_cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 23, "end_line": 27}, "code_snippet": "def name_cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n", "type": "function"}, {"name": "after_cm", "is_method": false, "class_name": null, "parameters": [], "calls": ["print", "print"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 41, "end_line": 45}, "code_snippet": "def after_cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n", "type": "function"}, {"name": "genfunc_with_cm_after", "is_method": false, "class_name": null, "parameters": [], "calls": ["after_cm"], "code_location": {"file": "contextmanager_generator_missing_cleanup.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 35, "end_line": 37}, "code_snippet": "def genfunc_with_cm_after():\n    with after_cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3393733501434326}
{"question": "What control path determines whether the docstring of a class definition node is accessible to the docstring checking mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "ClassChecker", "docstring": "Checker for class nodes.\n\nChecks for :\n* methods without self as first argument\n* overridden methods signature\n* access only to existent members via self\n* attributes not defined in the __init__ method\n* unreachable code", "methods": ["__init__", "open", "_dummy_rgx", "visit_classdef", "_check_declare_non_slot", "_check_consistent_mro", "_check_enum_base", "_check_proper_bases", "_check_typing_final", "leave_classdef", "_check_unused_private_functions", "_check_unused_private_variables", "_check_unused_private_attributes", "_check_attribute_defined_outside_init", "visit_functiondef", "_check_useless_super_delegation", "_check_property_with_parameters", "_check_invalid_overridden_method", "_check_functools_or_not", "_has_valid_slots", "_check_slots", "_get_classdef_slots_names", "_get_slots_names", "_check_redefined_slots", "_check_slots_elt", "leave_functiondef", "visit_attribute", "_check_super_without_brackets", "visit_assignattr", "_check_invalid_class_object", "_check_in_slots", "visit_assign", "_check_classmethod_declaration", "_check_protected_attribute_access", "_is_called_inside_special_method", "_is_type_self_call", "_is_classmethod", "_is_inferred_instance", "_is_class_or_instance_attribute", "_check_accessed_members", "_check_first_arg_for_type", "_check_first_arg_config", "_check_bases_classes", "_check_init", "_check_signature", "_uses_mandatory_method_param", "_is_mandatory_method_param"], "attributes": ["name", "msgs", "options", "visit_asyncfunctiondef", "leave_asyncfunctiondef"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 762, "end_line": 2425}, "type": "class"}, {"name": "DocstringOnly", "docstring": "The same goes for class stubs: docstring, or `...`, but not both.\n    ", "methods": [], "attributes": [], "code_location": {"file": "unnecessary_ellipsis.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unnecessary", "start_line": 53, "end_line": 55}, "type": "class"}, {"name": "DocstringOnly", "docstring": "The same goes for class stubs: docstring, or `pass`, but not both.\n    ", "methods": [], "attributes": [], "code_location": {"file": "unnecessary_pass.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unnecessary", "start_line": 36, "end_line": 38}, "type": "class"}, {"name": "DocStringChecker", "docstring": "", "methods": ["open", "visit_module", "visit_classdef", "visit_functiondef", "_check_docstring"], "attributes": ["msgs", "options", "visit_asyncfunctiondef"], "code_location": {"file": "docstring_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 45, "end_line": 208}, "type": "class"}, {"name": "Word", "docstring": "Methods decorated with `typing.overload` are excluded\nfrom the docparam checks. For example: `missing-param-doc` and\n`missing-type-doc`.", "methods": ["__init__", "starts_with", "starts_with", "starts_with"], "attributes": [], "code_location": {"file": "missing_param_doc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/docparams", "start_line": 216, "end_line": 241}, "type": "class"}, {"name": "Docstring", "docstring": "", "methods": ["__init__", "__repr__", "matching_sections", "exceptions", "has_params", "has_returns", "has_rtype", "has_property_returns", "has_property_type", "has_yields", "has_yields_type", "match_param_docs", "params_documented_elsewhere"], "attributes": ["re_for_parameters_see"], "code_location": {"file": "_check_docs_utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 282, "end_line": 336}, "type": "class"}, {"name": "_check_docstring", "is_method": true, "class_name": "DocStringChecker", "parameters": ["self", "node_type", "node", "report_missing", "confidence"], "calls": ["_infer_dunder_doc_attribute", "self.add_message", "utils.get_node_last_lineno", "isinstance", "isinstance", "utils.safe_infer", "docstring.strip", "self.add_message", "isinstance", "isinstance"], "code_location": {"file": "docstring_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 152, "end_line": 208}, "code_snippet": "    def _check_docstring(\n        self,\n        node_type: Literal[\"class\", \"function\", \"method\", \"module\"],\n        node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n\n        if docstring is None:\n            if not report_missing:\n                return\n            lines = utils.get_node_last_lineno(node) - node.lineno\n\n            if node_type == \"module\" and not lines:\n                # If the module does not have a body, there's no reason\n                # to require a docstring.\n                return\n            max_lines = self.linter.config.docstring_min_length\n\n            if node_type != \"module\" and max_lines > -1 and lines < max_lines:\n                return\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            if (\n                node.body\n                and isinstance(node.body[0], nodes.Expr)\n                and isinstance(node.body[0].value, nodes.Call)\n            ):\n                # Most likely a string with a format call. Let's see.\n                func = utils.safe_infer(node.body[0].value.func)\n                if isinstance(func, astroid.BoundMethod) and isinstance(\n                    func.bound, astroid.Instance\n                ):\n                    # Strings.\n                    if func.bound.name in {\"str\", \"unicode\", \"bytes\"}:\n                        return\n            if node_type == \"module\":\n                message = \"missing-module-docstring\"\n            elif node_type == \"class\":\n                message = \"missing-class-docstring\"\n            else:\n                message = \"missing-function-docstring\"\n            self.add_message(message, node=node, confidence=confidence)\n        elif not docstring.strip():\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            self.add_message(\n                \"empty-docstring\", node=node, args=(node_type,), confidence=confidence\n            )\n", "type": "function"}, {"name": "MyClass", "docstring": "Regression test for https://github.com/pylint-dev/pylint/issues/7380", "methods": [], "attributes": [], "code_location": {"file": "modified_iterating.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 115, "end_line": 124}, "type": "class"}, {"name": "PathGraphingAstVisitor", "docstring": "", "methods": ["__init__", "default", "dispatch", "visitFunctionDef", "visitSimpleStatement", "visitWith", "_append_node", "_subgraph", "_subgraph_parse"], "attributes": ["visitAsyncFunctionDef", "visitAssert", "visitAssign", "visitAugAssign", "visitDelete", "visitRaise", "visitYield", "visitImport", "visitCall", "visitSubscript", "visitPass", "visitContinue", "visitBreak", "visitGlobal", "visitReturn", "visitExpr", "visitAwait", "visitAsyncWith"], "code_location": {"file": "mccabe.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 54, "end_line": 159}, "type": "class"}, {"name": "NoKnownBases", "docstring": "Don't emit no-member if we don't know the bases of a class.", "methods": [], "attributes": [], "code_location": {"file": "class_members_py30.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 52, "end_line": 53}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.32749438285827637}
{"question": "Where is the call chain through which the forward reference resolution for string literal type annotations in function return type annotations gets processed by the type checking infrastructure?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "visit_const", "is_method": true, "class_name": "VariablesChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "isinstance", "isinstance", "node.pytype", "utils.is_node_in_type_annotation_context", "next", "extract_node", "self._store_type_annotation_node", "parent.get_children", "utils.is_typing_member"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 3461, "end_line": 3489}, "code_snippet": "    def visit_const(self, node: nodes.Const) -> None:\n        \"\"\"Take note of names that appear inside string literal type annotations\n        unless the string is a parameter to `typing.Literal` or `typing.Annotation`.\n        \"\"\"\n        if node.pytype() != \"builtins.str\":\n            return\n        if not utils.is_node_in_type_annotation_context(node):\n            return\n\n        # Check if parent's or grandparent's first child is typing.Literal\n        parent = node.parent\n        if isinstance(parent, nodes.Tuple):\n            parent = parent.parent\n        if isinstance(parent, nodes.Subscript):\n            origin = next(parent.get_children(), None)\n            if origin is not None and utils.is_typing_member(\n                origin, (\"Annotated\", \"Literal\")\n            ):\n                return\n\n        try:\n            annotation = extract_node(node.value)\n            self._store_type_annotation_node(annotation)\n        except ValueError:\n            # e.g. node.value is white space\n            pass\n        except astroid.AstroidSyntaxError:\n            # e.g. \"?\" or \":\" in typing.Literal[\"?\", \":\"]\n            pass\n", "type": "function"}, {"name": "test_get_annotation_label_of_return_type", "is_method": false, "class_name": null, "parameters": ["node_text", "expected_label"], "calls": ["pytest.mark.parametrize", "astroid.extract_node", "isinstance", "get_annotation_label"], "code_location": {"file": "test_utils.py", "path": "/data3/pwh/swebench-repos/pylint/tests/pyreverse", "start_line": 98, "end_line": 103}, "code_snippet": "def test_get_annotation_label_of_return_type(\n    node_text: str, expected_label: str\n) -> None:\n    func = astroid.extract_node(node_text)\n    assert isinstance(func, nodes.FunctionDef)\n    assert get_annotation_label(func.returns) == expected_label\n", "type": "function"}, {"name": "foo", "is_method": true, "class_name": "FooBar", "parameters": ["self"], "calls": [], "code_location": {"file": "protocol_classes_abstract.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/p", "start_line": 45, "end_line": 46}, "code_snippet": "    def foo(self) -> Literal[\"foo\"]:\n        return \"foo\"\n", "type": "function"}, {"name": "_populate_type_annotations_annotation", "is_method": true, "class_name": "PrivateImportChecker", "parameters": ["self", "node", "all_used_type_annotations"], "calls": ["isinstance", "isinstance", "isinstance", "self._populate_type_annotations_annotation", "self._populate_type_annotations_annotation", "self._populate_type_annotations_annotation"], "code_location": {"file": "private_import.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 189, "end_line": 215}, "code_snippet": "    def _populate_type_annotations_annotation(\n        self,\n        node: nodes.Attribute | nodes.Subscript | nodes.Name | None,\n        all_used_type_annotations: dict[str, bool],\n    ) -> str | None:\n        \"\"\"Handles the possibility of an annotation either being a Name, i.e. just type,\n        or a Subscript e.g. `Optional[type]` or an Attribute, e.g. `pylint.lint.linter`.\n        \"\"\"\n        if isinstance(node, nodes.Name) and node.name not in all_used_type_annotations:\n            all_used_type_annotations[node.name] = True\n            return node.name  # type: ignore[no-any-return]\n        if isinstance(node, nodes.Subscript):  # e.g. Optional[List[str]]\n            # slice is the next nested type\n            self._populate_type_annotations_annotation(\n                node.slice, all_used_type_annotations\n            )\n            # value is the current type name: could be a Name or Attribute\n            return self._populate_type_annotations_annotation(\n                node.value, all_used_type_annotations\n            )\n        if isinstance(node, nodes.Attribute):\n            # An attribute is a type like `pylint.lint.pylinter`. node.expr is the next level\n            # up, could be another attribute\n            return self._populate_type_annotations_annotation(\n                node.expr, all_used_type_annotations\n            )\n        return None\n", "type": "function"}, {"name": "find_inferred_fn_from_register", "is_method": false, "class_name": null, "parameters": ["node"], "calls": ["isinstance", "safe_infer", "isinstance", "isinstance", "isinstance"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1547, "end_line": 1564}, "code_snippet": "def find_inferred_fn_from_register(node: nodes.NodeNG) -> nodes.FunctionDef | None:\n    # func.register are function calls or register attributes\n    # when the function is annotated with types\n    if isinstance(node, nodes.Call):\n        func = node.func\n    elif isinstance(node, nodes.Attribute):\n        func = node\n    else:\n        return None\n\n    if not isinstance(func, nodes.Attribute) or func.attrname != \"register\":\n        return None\n\n    func_def = safe_infer(func.expr)\n    if not isinstance(func_def, nodes.FunctionDef):\n        return None\n\n    return func_def\n", "type": "function"}, {"name": "_is_variable_annotation_in_function", "is_method": true, "class_name": "VariablesChecker", "parameters": ["node"], "calls": ["utils.get_node_first_ancestor_of_type", "utils.get_node_first_ancestor_of_type", "ann_assign.annotation.parent_of"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 2550, "end_line": 2558}, "code_snippet": "    def _is_variable_annotation_in_function(node: nodes.Name) -> bool:\n        ann_assign = utils.get_node_first_ancestor_of_type(node, nodes.AnnAssign)\n        return (\n            ann_assign\n            and (node is ann_assign.annotation or ann_assign.annotation.parent_of(node))\n            and utils.get_node_first_ancestor_of_type(  # type: ignore[return-value]\n                ann_assign, nodes.FunctionDef\n            )\n        )\n", "type": "function"}, {"name": "_check_str", "is_method": true, "class_name": "SpecialMethodsChecker", "parameters": ["self", "node", "inferred"], "calls": ["self._is_str", "self.add_message"], "code_location": {"file": "special_methods_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 344, "end_line": 346}, "code_snippet": "    def _check_str(self, node: nodes.FunctionDef, inferred: InferenceResult) -> None:\n        if not self._is_str(inferred):\n            self.add_message(\"invalid-str-returned\", node=node)\n", "type": "function"}, {"name": "my_method", "is_method": true, "class_name": "MyClass1", "parameters": ["self", "option"], "calls": [], "code_location": {"file": "regression_4660.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/r/regression_02", "start_line": 27, "end_line": 28}, "code_snippet": "    def my_method(self, option: Literal[\"mandatory\"]) -> Callable[..., Any]:\n        ...\n", "type": "function"}, {"name": "bar", "is_method": true, "class_name": "FooBar", "parameters": ["self"], "calls": [], "code_location": {"file": "protocol_classes_abstract.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/p", "start_line": 42, "end_line": 43}, "code_snippet": "    def bar(self) -> Literal[\"bar\"]:\n        return \"bar\"\n", "type": "function"}, {"name": "y", "is_method": true, "class_name": "RepeatedReturnAnnotations", "parameters": ["self"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 379, "end_line": 380}, "code_snippet": "    def y(self) -> RepeatedReturnAnnotations:  # <3.14:[undefined-variable]\n        pass\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3396329879760742}
{"question": "Where is the initialization logic that the child class's initialization method delegates to through the parent class delegation mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "TestChild", "docstring": "An implementation which should call the init of TestParent.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "super_init_not_called_extensions_py310.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 18, "end_line": 22}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "ChildOne", "parameters": ["self"], "calls": ["GrandParentWithInit.__init__"], "code_location": {"file": "super_init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 40, "end_line": 41}, "code_snippet": "    def __init__(self):\n        GrandParentWithInit.__init__(self)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Aaaa", "parameters": ["self"], "calls": ["non_init_parent_called.AAAA.__init__"], "code_location": {"file": "dotted_ancestor.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/d", "start_line": 9, "end_line": 10}, "code_snippet": "    def __init__(self):\n        non_init_parent_called.AAAA.__init__(self)\n", "type": "function"}, {"name": "InitSubclassChild", "docstring": "", "methods": ["__init_subclass__"], "attributes": [], "code_location": {"file": "arguments_differ.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a", "start_line": 368, "end_line": 370}, "type": "class"}, {"name": "InitSubclassParent", "docstring": "", "methods": ["__init_subclass__"], "attributes": [], "code_location": {"file": "arguments_differ.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a", "start_line": 364, "end_line": 366}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "ChildTwo", "parameters": ["self"], "calls": ["ParentWithoutInit.__init__"], "code_location": {"file": "super_init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 45, "end_line": 46}, "code_snippet": "    def __init__(self):\n        ParentWithoutInit.__init__(self)\n", "type": "function"}, {"name": "ChildNoInitMethod", "docstring": "", "methods": ["__init__"], "attributes": [], "code_location": {"file": "init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i", "start_line": 95, "end_line": 97}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "AAAA", "parameters": ["self"], "calls": ["print", "BBBBMixin.__init__"], "code_location": {"file": "non_init_parent_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 12, "end_line": 14}, "code_snippet": "    def __init__(self):\n        print('init', self)\n        BBBBMixin.__init__(self)  # [non-parent-init-called]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Super", "parameters": ["self"], "calls": ["super", "base.__init__"], "code_location": {"file": "non_init_parent_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 40, "end_line": 42}, "code_snippet": "    def __init__(self):\n        base = super()\n        base.__init__()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "UselessSuper", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "useless_parent_delegation.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/useless", "start_line": 265, "end_line": 266}, "code_snippet": "    def __init__(self):  # [useless-parent-delegation]\n        super(UselessSuper, self).__init__()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34649181365966797}
{"question": "Where are the linting functions that invoke docstring parameter checking logic to detect missing type annotations for parameters without type hints?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "check_functiondef_params", "is_method": true, "class_name": "DocstringParameterChecker", "parameters": ["self", "node", "node_doc"], "calls": ["self.check_arguments_in_docstring", "checker_utils.node_frame_class", "utils.docstringify", "self.check_single_constructor_params", "self.check_arguments_in_docstring", "class_doc.has_params", "class_doc.params_documented_elsewhere", "node_doc.has_params", "node_doc.params_documented_elsewhere"], "code_location": {"file": "docparams.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 221, "end_line": 252}, "code_snippet": "    def check_functiondef_params(\n        self, node: nodes.FunctionDef, node_doc: Docstring\n    ) -> None:\n        node_allow_no_param = None\n        if node.name in self.constructor_names:\n            class_node = checker_utils.node_frame_class(node)\n            if class_node is not None:\n                class_doc = utils.docstringify(\n                    class_node.doc_node, self.linter.config.default_docstring_type\n                )\n                self.check_single_constructor_params(class_doc, node_doc, class_node)\n\n                # __init__ or class docstrings can have no parameters documented\n                # as long as the other documents them.\n                node_allow_no_param = (\n                    class_doc.has_params()\n                    or class_doc.params_documented_elsewhere()\n                    or None\n                )\n                class_allow_no_param = (\n                    node_doc.has_params()\n                    or node_doc.params_documented_elsewhere()\n                    or None\n                )\n\n                self.check_arguments_in_docstring(\n                    class_doc, node.args, class_node, class_allow_no_param\n                )\n\n        self.check_arguments_in_docstring(\n            node_doc, node.args, node, node_allow_no_param\n        )\n", "type": "function"}, {"name": "DocstringParameterChecker", "docstring": "Checker for Sphinx, Google, or Numpy style docstrings.\n\n* Check that all function, method and constructor parameters are mentioned\n  in the params and types part of the docstring.  Constructor parameters\n  can be documented in either the class docstring or ``__init__`` docstring,\n  but not both.\n* Check that there are no naming inconsistencies between the signature and\n  the documentation, i.e. also report documented parameters that are missing\n  in the signature. This is important to find cases where parameters are\n  renamed only in the code, not in the documentation.\n* Check that all explicitly raised exceptions in a function are documented\n  in the function docstring. Caught exceptions are ignored.\n\nActivate this checker by adding the line::\n\n    load-plugins=pylint.extensions.docparams\n\nto the ``MAIN`` section of your ``.pylintrc``.", "methods": ["visit_functiondef", "check_functiondef_params", "check_functiondef_returns", "check_functiondef_yields", "visit_raise", "visit_return", "visit_yield", "_compare_missing_args", "_compare_different_args", "_compare_ignored_args", "check_arguments_in_docstring", "check_single_constructor_params", "_add_raise_message", "_is_shorter_than_min_length"], "attributes": ["name", "msgs", "options", "constructor_names", "not_needed_param_in_docstring", "visit_asyncfunctiondef", "visit_yieldfrom"], "code_location": {"file": "docparams.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 25, "end_line": 694}, "type": "class"}, {"name": "Word", "docstring": "Methods decorated with `typing.overload` are excluded\nfrom the docparam checks. For example: `missing-param-doc` and\n`missing-type-doc`.", "methods": ["__init__", "starts_with", "starts_with", "starts_with"], "attributes": [], "code_location": {"file": "missing_param_doc.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/docparams", "start_line": 216, "end_line": 241}, "type": "class"}, {"name": "register", "is_method": false, "class_name": null, "parameters": ["linter"], "calls": ["linter.register_checker", "DocstringParameterChecker"], "code_location": {"file": "docparams.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 697, "end_line": 698}, "code_snippet": "def register(linter: PyLinter) -> None:\n    linter.register_checker(DocstringParameterChecker(linter))\n", "type": "function"}, {"name": "check_arguments_in_docstring", "is_method": true, "class_name": "DocstringParameterChecker", "parameters": ["self", "doc", "arguments_node", "warning_node", "accept_no_param_doc"], "calls": ["doc.params_documented_elsewhere", "expected_argument_names.update", "self.not_needed_param_in_docstring.copy", "set", "doc.match_param_docs", "self._compare_ignored_args", "utils.args_with_annotation", "self._compare_different_args", "self._compare_different_args", "self._compare_ignored_args", "expected_argument_names.add", "not_needed_type_in_docstring.add", "expected_argument_names.add", "not_needed_type_in_docstring.add", "self.add_message", "self._compare_missing_args", "self._compare_missing_args", "ignored_argument_names.match", "len"], "code_location": {"file": "docparams.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 509, "end_line": 646}, "code_snippet": "    def check_arguments_in_docstring(\n        self,\n        doc: Docstring,\n        arguments_node: astroid.Arguments,\n        warning_node: astroid.NodeNG,\n        accept_no_param_doc: bool | None = None,\n    ) -> None:\n        \"\"\"Check that all parameters are consistent with the parameters mentioned\n        in the parameter documentation (e.g. the Sphinx tags 'param' and 'type').\n\n        * Undocumented parameters except 'self' are noticed.\n        * Undocumented parameter types except for 'self' and the ``*<args>``\n          and ``**<kwargs>`` parameters are noticed.\n        * Parameters mentioned in the parameter documentation that don't or no\n          longer exist in the function parameter list are noticed.\n        * If the text \"For the parameters, see\" or \"For the other parameters,\n          see\" (ignoring additional white-space) is mentioned in the docstring,\n          missing parameter documentation is tolerated.\n        * If there's no Sphinx style, Google style or NumPy style parameter\n          documentation at all, i.e. ``:param`` is never mentioned etc., the\n          checker assumes that the parameters are documented in another format\n          and the absence is tolerated.\n\n        :param doc: Docstring for the function, method or class.\n        :type doc: :class:`Docstring`\n\n        :param arguments_node: Arguments node for the function, method or\n            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n        :param warning_node: The node to assign the warnings to\n        :type warning_node: :class:`astroid.scoped_nodes.Node`\n\n        :param accept_no_param_doc: Whether to allow no parameters to be\n            documented. If None then this value is read from the configuration.\n        :type accept_no_param_doc: bool or None\n        \"\"\"\n        # Tolerate missing param or type declarations if there is a link to\n        # another method carrying the same name.\n        if not doc.doc:\n            return\n\n        if accept_no_param_doc is None:\n            accept_no_param_doc = self.linter.config.accept_no_param_doc\n        tolerate_missing_params = doc.params_documented_elsewhere()\n\n        # Collect the function arguments.\n        expected_argument_names = {arg.name for arg in arguments_node.args}\n        expected_argument_names.update(\n            a.name for a in arguments_node.posonlyargs + arguments_node.kwonlyargs\n        )\n        not_needed_type_in_docstring = self.not_needed_param_in_docstring.copy()\n\n        expected_but_ignored_argument_names = set()\n        ignored_argument_names = self.linter.config.ignored_argument_names\n        if ignored_argument_names:\n            expected_but_ignored_argument_names = {\n                arg\n                for arg in expected_argument_names\n                if ignored_argument_names.match(arg)\n            }\n\n        if arguments_node.vararg is not None:\n            expected_argument_names.add(f\"*{arguments_node.vararg}\")\n            not_needed_type_in_docstring.add(f\"*{arguments_node.vararg}\")\n        if arguments_node.kwarg is not None:\n            expected_argument_names.add(f\"**{arguments_node.kwarg}\")\n            not_needed_type_in_docstring.add(f\"**{arguments_node.kwarg}\")\n        params_with_doc, params_with_type = doc.match_param_docs()\n        # Tolerate no parameter documentation at all.\n        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n            params_with_type,\n            \"useless-type-doc\",\n            expected_but_ignored_argument_names,\n            warning_node,\n        )\n        params_with_type |= utils.args_with_annotation(arguments_node)\n\n        if not tolerate_missing_params:\n            missing_param_doc = (expected_argument_names - params_with_doc) - (\n                self.not_needed_param_in_docstring | expected_but_ignored_argument_names\n            )\n            missing_type_doc = (expected_argument_names - params_with_type) - (\n                not_needed_type_in_docstring | expected_but_ignored_argument_names\n            )\n            if (\n                missing_param_doc == expected_argument_names == missing_type_doc\n                and len(expected_argument_names) != 0\n            ):\n                self.add_message(\n                    \"missing-any-param-doc\",\n                    args=(warning_node.name,),\n                    node=warning_node,\n                    confidence=HIGH,\n                )\n            else:\n                self._compare_missing_args(\n                    params_with_doc,\n                    \"missing-param-doc\",\n                    self.not_needed_param_in_docstring\n                    | expected_but_ignored_argument_names,\n                    expected_argument_names,\n                    warning_node,\n                )\n                self._compare_missing_args(\n                    params_with_type,\n                    \"missing-type-doc\",\n                    not_needed_type_in_docstring | expected_but_ignored_argument_names,\n                    expected_argument_names,\n                    warning_node,\n                )\n\n        self._compare_different_args(\n            params_with_doc,\n            \"differing-param-doc\",\n            self.not_needed_param_in_docstring,\n            expected_argument_names,\n            warning_node,\n        )\n        self._compare_different_args(\n            params_with_type,\n            \"differing-type-doc\",\n            not_needed_type_in_docstring,\n            expected_argument_names,\n            warning_node,\n        )\n        self._compare_ignored_args(\n            params_with_doc,\n            \"useless-param-doc\",\n            expected_but_ignored_argument_names,\n            warning_node,\n        )\n", "type": "function"}, {"name": "test_missing_func_params_with_partial_annotations_in_google_docstring", "is_method": false, "class_name": null, "parameters": ["x", "y", "z"], "calls": [], "code_location": {"file": "missing_param_doc_required_Google.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "start_line": 83, "end_line": 95}, "code_snippet": "def test_missing_func_params_with_partial_annotations_in_google_docstring(  # [missing-type-doc]\n    x, y: bool, z\n):\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n\n    Args:\n        x: bla\n        y: blah blah\n        z (int): bar\n\n    some other stuff\n    \"\"\"\n", "type": "function"}, {"name": "visit_functiondef", "is_method": true, "class_name": "DocStringChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self.linter.config.no_docstring_rgx.match", "isinstance", "node.is_method", "is_property_setter", "is_property_deleter", "is_overload_stub", "node.parent.frame", "ancestors", "self._check_docstring", "isinstance", "utils.has_known_bases", "node.parent.frame", "self._check_docstring", "node.parent.frame", "node.parent.frame", "ancestor.qname", "isinstance"], "code_location": {"file": "docstring_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 116, "end_line": 148}, "code_snippet": "    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            ftype = \"method\" if node.is_method() else \"function\"\n            if (\n                is_property_setter(node)\n                or is_property_deleter(node)\n                or is_overload_stub(node)\n            ):\n                return\n\n            if isinstance(node.parent.frame(), nodes.ClassDef):\n                overridden = False\n                confidence = (\n                    interfaces.INFERENCE\n                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n                    if node.name in ancestor and isinstance(\n                        ancestor[node.name], nodes.FunctionDef\n                    ):\n                        overridden = True\n                        break\n                self._check_docstring(\n                    ftype, node, report_missing=not overridden, confidence=confidence  # type: ignore[arg-type]\n                )\n            elif isinstance(node.parent.frame(), nodes.Module):\n                self._check_docstring(ftype, node)  # type: ignore[arg-type]\n            else:\n                return\n", "type": "function"}, {"name": "test_check_bad_docstring", "is_method": true, "class_name": "TestSpellingChecker", "parameters": ["self"], "calls": ["set_config", "astroid.extract_node", "astroid.extract_node", "self.assertAddsMessages", "self.checker.visit_functiondef", "self.assertAddsMessages", "self.checker.visit_classdef", "MessageTest", "MessageTest", "self._get_msg_suggestions", "self._get_msg_suggestions"], "code_location": {"file": "unittest_spelling.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 94, "end_line": 123}, "code_snippet": "    def test_check_bad_docstring(self) -> None:\n        stmt = astroid.extract_node('def fff():\\n   \"\"\"bad coment\"\"\"\\n   pass')\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"bad coment\",\n                    \"    ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_functiondef(stmt)\n\n        stmt = astroid.extract_node('class Abc(object):\\n   \"\"\"bad coment\"\"\"\\n   pass')\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"bad coment\",\n                    \"    ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n", "type": "function"}, {"name": "_check_docstring", "is_method": true, "class_name": "DocStringStyleChecker", "parameters": ["self", "node_type", "node"], "calls": ["self.add_message", "lstrip", "self.add_message", "linecache.getline", "line.find", "node.root"], "code_location": {"file": "docstyle.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 51, "end_line": 85}, "code_snippet": "    def _check_docstring(\n        self, node_type: str, node: nodes.Module | nodes.ClassDef | nodes.FunctionDef\n    ) -> None:\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring and docstring[0] == \"\\n\":\n            self.add_message(\n                \"docstring-first-line-empty\",\n                node=node,\n                args=(node_type,),\n                confidence=HIGH,\n            )\n\n        # Use \"linecache\", instead of node.as_string(), because the latter\n        # looses the original form of the docstrings.\n\n        if docstring:\n            lineno = node.fromlineno + 1\n            line = linecache.getline(node.root().file, lineno).lstrip()\n            if line and line.find('\"\"\"') == 0:\n                return\n            if line and \"'''\" in line:\n                quotes = \"'''\"\n            elif line and line[0] == '\"':\n                quotes = '\"'\n            elif line and line[0] == \"'\":\n                quotes = \"'\"\n            else:\n                quotes = \"\"\n            if quotes:\n                self.add_message(\n                    \"bad-docstring-quotes\",\n                    node=node,\n                    args=(node_type, quotes),\n                    confidence=HIGH,\n                )\n", "type": "function"}, {"name": "match_param_docs", "is_method": true, "class_name": "SphinxDocstring", "parameters": ["self"], "calls": ["set", "set", "re.finditer", "params_with_type.update", "match.group", "name.replace", "params_with_doc.add", "match.group", "re.findall", "params_with_type.add"], "code_location": {"file": "_check_docs_utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 469, "end_line": 483}, "code_snippet": "    def match_param_docs(self) -> tuple[set[str], set[str]]:\n        params_with_doc = set()\n        params_with_type = set()\n\n        for match in re.finditer(self.re_param_in_docstring, self.doc):\n            name = match.group(2)\n            # Remove escape characters necessary for asterisks\n            name = name.replace(\"\\\\\", \"\")\n            params_with_doc.add(name)\n            param_type = match.group(1)\n            if param_type is not None:\n                params_with_type.add(name)\n\n        params_with_type.update(re.findall(self.re_type_in_docstring, self.doc))\n        return params_with_doc, params_with_type\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34043264389038086}
{"question": "Where is the example function that searches for even numbers using a loop with an else clause defined in the documentation directory for the checker message category that flags loops with else clauses lacking break statements?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "find_even_number", "is_method": false, "class_name": null, "parameters": ["numbers"], "calls": ["print"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/u/useless-else-on-loop", "start_line": 1, "end_line": 6}, "code_snippet": "def find_even_number(numbers):\n    for x in numbers:\n        if x % 2 == 0:\n            return x\n    else:  # [useless-else-on-loop]\n        print(\"Did not find an even number\")\n", "type": "function"}, {"name": "find_even_number", "is_method": false, "class_name": null, "parameters": ["numbers"], "calls": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/u/undefined-loop-variable", "start_line": 1, "end_line": 5}, "code_snippet": "def find_even_number(numbers):\n    for x in numbers:\n        if x % 2 == 0:\n            break\n    return x  # [undefined-loop-variable]\n", "type": "function"}, {"name": "test_return_for", "is_method": false, "class_name": null, "parameters": [], "calls": ["range", "print"], "code_location": {"file": "useless_else_on_loop.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/useless", "start_line": 4, "end_line": 11}, "code_snippet": "def test_return_for():\n    \"\"\"else + return is not acceptable.\"\"\"\n    for i in range(10):\n        if i % 2:\n            return i\n    else:  # [useless-else-on-loop]\n        print('math is broken')\n    return None\n", "type": "function"}, {"name": "print_even_numbers", "is_method": false, "class_name": null, "parameters": [], "calls": ["range", "print"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/n/not-in-loop", "start_line": 1, "end_line": 6}, "code_snippet": "def print_even_numbers():\n    for i in range(100):\n        if i % 2 == 0:\n            print(i)\n    else:\n        continue  # [not-in-loop]\n", "type": "function"}, {"name": "bar4", "is_method": false, "class_name": null, "parameters": ["x"], "calls": ["range"], "code_location": {"file": "no_else_break.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 108, "end_line": 116}, "code_snippet": "def bar4(x):\n    for i in range(10):\n        if x:  # [no-else-break]\n            break\n        else:\n            try:\n                return\n            except ValueError:\n                break\n", "type": "function"}, {"name": "foo2", "is_method": false, "class_name": null, "parameters": ["x", "y", "w", "z"], "calls": [], "code_location": {"file": "no_else_break.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 14, "end_line": 21}, "code_snippet": "def foo2(x, y, w, z):\n    for i in x:\n        if i > y:  # [no-else-break]\n            break\n        elif i > w:\n            break\n        else:\n            a = z\n", "type": "function"}, {"name": "foo6", "is_method": false, "class_name": null, "parameters": ["x", "y"], "calls": [], "code_location": {"file": "no_else_break.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 67, "end_line": 77}, "code_snippet": "def foo6(x, y):\n    for i in x:\n        if i > x:\n            if y:  # [no-else-break]\n                a = 4\n                break\n            else:\n                b = 2\n        else:\n            c = 3\n        break\n", "type": "function"}, {"name": "foo4", "is_method": false, "class_name": null, "parameters": ["x", "y"], "calls": [], "code_location": {"file": "no_else_break.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 39, "end_line": 49}, "code_snippet": "def foo4(x, y):\n    for i in x:\n        if i > x:  # [no-else-break]\n            if y:\n                a = 4\n            else:\n                b = 2\n            break\n        else:\n            c = 3\n        break\n", "type": "function"}, {"name": "foo1", "is_method": false, "class_name": null, "parameters": ["x", "y", "z"], "calls": [], "code_location": {"file": "no_else_break.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 6, "end_line": 11}, "code_snippet": "def foo1(x, y, z):\n    for i in x:\n        if i > y:  # [no-else-break]\n            break\n        else:\n            a = z\n", "type": "function"}, {"name": "test_return_for2", "is_method": false, "class_name": null, "parameters": [], "calls": ["range", "range", "print"], "code_location": {"file": "useless_else_on_loop.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/useless", "start_line": 45, "end_line": 57}, "code_snippet": "def test_return_for2():\n    \"\"\"no false positive for break in else\n\n    https://bitbucket.org/logilab/pylint/issue/117/useless-else-on-loop-false-positives\n    \"\"\"\n    for i in range(10):\n        for _ in range(i):\n            if i % 2:\n                break\n        else:\n            break\n    else:\n        print('great math')\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.33765530586242676}
{"question": "Why does the memory overhead of the pickle protocol reconstruction method validated by the classes checker during repeated instantiation impact garbage collection cycles and heap fragmentation when thousands of instances are created and destroyed?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "CustomGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": [], "attributes": [], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "start_line": 1, "end_line": 5}, "type": "class"}, {"name": "SecondBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with incorrect arg length", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 58, "end_line": 62}, "type": "class"}, {"name": "FirstBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns an integer ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 51, "end_line": 55}, "type": "class"}, {"name": "FourthBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with wrong type for second arg ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 72, "end_line": 76}, "type": "class"}, {"name": "ThirdBadGetNewArgsEx", "docstring": "__getnewargs_ex__ returns tuple with wrong type for first arg ", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 65, "end_line": 69}, "type": "class"}, {"name": "FirstGoodGetNewArgsEx", "docstring": "__getnewargs_ex__ returns <type 'tuple'>", "methods": ["__getnewargs_ex__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 9, "end_line": 13}, "type": "class"}, {"name": "test_worker_initialize_pickling", "is_method": true, "class_name": "TestCheckParallelFramework", "parameters": ["self"], "calls": ["PyLinter", "argparse.ArgumentParser", "ProcessPoolExecutor", "executor.map", "Reporter", "dill.dumps"], "code_location": {"file": "test_check_parallel.py", "path": "/data3/pwh/swebench-repos/pylint/tests", "start_line": 207, "end_line": 219}, "code_snippet": "    def test_worker_initialize_pickling(self) -> None:\n        \"\"\"Test that we can pickle objects that standard pickling in multiprocessing can't.\n\n        See:\n        https://stackoverflow.com/questions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function\n        https://github.com/pylint-dev/pylint/pull/5584\n        \"\"\"\n        linter = PyLinter(reporter=Reporter())\n        linter.attribute = argparse.ArgumentParser()  # type: ignore[attr-defined]\n        with ProcessPoolExecutor(\n            max_workers=2, initializer=worker_initialize, initargs=(dill.dumps(linter),)\n        ) as executor:\n            executor.map(print, [1, 2])\n", "type": "function"}, {"name": "__getnewargs_ex__", "is_method": true, "class_name": "FourthBadGetNewArgsEx", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_getnewargs_ex_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 75, "end_line": 76}, "code_snippet": "    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n", "type": "function"}, {"name": "FirstBadGetNewArgs", "docstring": "__getnewargs__ returns an integer ", "methods": ["__getnewargs__"], "attributes": [], "code_location": {"file": "invalid_getnewargs_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 33, "end_line": 37}, "type": "class"}, {"name": "__getnewargs__", "is_method": true, "class_name": "SecondGoodGetNewArgs", "parameters": ["self"], "calls": ["tuple"], "code_location": {"file": "invalid_getnewargs_returned.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "start_line": 19, "end_line": 20}, "code_snippet": "    def __getnewargs__(self):\n        return tuple()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3355133533477783}
{"question": "Where does the descriptor protocol implementation that provides __get__ and __set__ methods interact with the slot assignment validation mechanisms across the inheritance hierarchy in the slot assignment test file?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "dont_emit_for_descriptors", "is_method": false, "class_name": null, "parameters": [], "calls": ["SlotsWithDescriptor"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 129, "end_line": 134}, "code_snippet": "def dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n", "type": "function"}, {"name": "release", "is_method": true, "class_name": "ClassReassingingInvalidLayoutClass", "parameters": ["self"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 151, "end_line": 153}, "code_snippet": "    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n", "type": "function"}, {"name": "DerivedTypeHintNotInSlots", "docstring": "", "methods": ["__init__"], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 177, "end_line": 183}, "type": "class"}, {"name": "SlotsManipulationTest", "docstring": "", "methods": [], "attributes": ["__slots__"], "code_location": {"file": "slots_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 193, "end_line": 194}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Student", "parameters": ["self", "name", "surname"], "calls": ["self.setup"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/a/assigning-non-slot", "start_line": 4, "end_line": 7}, "code_snippet": "    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Bad3", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 35, "end_line": 39}, "code_snippet": "    def __init__(self):\n        self.component = 42\n        self.member = 24\n        self.missing = 42 # [assigning-non-slot]\n        super().__init__()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Bad2", "parameters": ["self"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 26, "end_line": 28}, "code_snippet": "    def __init__(self):\n        self.deque = 42\n        self.missing = 42 # [assigning-non-slot]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Bad", "parameters": ["self"], "calls": [], "code_location": {"file": "assigning_non_slot.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/assigning", "start_line": 19, "end_line": 20}, "code_snippet": "    def __init__(self):\n        self.missing = 42 # [assigning-non-slot]\n", "type": "function"}, {"name": "test_descriptor_crash", "is_method": false, "class_name": null, "parameters": ["fname", "finalize_linter"], "calls": ["pytest.mark.parametrize", "finalize_linter.check", "cast", "strip", "join", "finalize_linter.reporter.finalize", "os.listdir", "x.endswith"], "code_location": {"file": "test_regr.py", "path": "/data3/pwh/swebench-repos/pylint/tests", "start_line": 95, "end_line": 100}, "code_snippet": "def test_descriptor_crash(fname: str, finalize_linter: PyLinter) -> None:\n    finalize_linter.check([join(REGR_DATA, fname)])\n    finalize_linter.reporter = cast(  # Due to fixture\n        testutils.GenericTestReporter, finalize_linter.reporter\n    )\n    finalize_linter.reporter.finalize().strip()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Test", "parameters": ["self"], "calls": ["self.test"], "code_location": {"file": "unpacking_non_sequence.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unpacking", "start_line": 111, "end_line": 113}, "code_snippet": "    def __init__(self):\n        # no error should be emitted here as `test` is overridden in this class\n        (self.aaa, self.bbb, self.ccc) = self.test(None)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.336763858795166}
{"question": "Where is the abstract method checking implementation that handles assignments connecting abstract methods to protocol methods located?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_check_inferred_class_is_abstract", "is_method": true, "class_name": "BasicErrorChecker", "parameters": ["self", "inferred", "node"], "calls": ["utils.node_frame_class", "_has_abstract_methods", "inferred.metaclass", "isinstance", "inferred.ancestors", "metaclass.qname", "self.add_message", "ancestor.qname", "self.add_message"], "code_location": {"file": "basic_error_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 434, "end_line": 471}, "code_snippet": "    def _check_inferred_class_is_abstract(\n        self, inferred: InferenceResult, node: nodes.Call\n    ) -> None:\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n\n        klass = utils.node_frame_class(node)\n        if klass is inferred:\n            # Don't emit the warning if the class is instantiated\n            # in its own body or if the call is not an instance\n            # creation. If the class is instantiated into its own\n            # body, we're expecting that it knows what it is doing.\n            return\n\n        # __init__ was called\n        abstract_methods = _has_abstract_methods(inferred)\n\n        if not abstract_methods:\n            return\n\n        metaclass = inferred.metaclass()\n\n        if metaclass is None:\n            # Python 3.4 has `abc.ABC`, which won't be detected\n            # by ClassNode.metaclass()\n            for ancestor in inferred.ancestors():\n                if ancestor.qname() == \"abc.ABC\":\n                    self.add_message(\n                        \"abstract-class-instantiated\", args=(inferred.name,), node=node\n                    )\n                    break\n\n            return\n\n        if metaclass.qname() in ABC_METACLASSES:\n            self.add_message(\n                \"abstract-class-instantiated\", args=(inferred.name,), node=node\n            )\n", "type": "function"}, {"name": "_check_bases_classes", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "node"], "calls": ["class_is_abstract", "sorted", "method.is_abstract", "items", "method.parent.frame", "self.add_message", "unimplemented_abstract_methods"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 2204, "end_line": 2235}, "code_snippet": "    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        \"\"\"\n\n        def is_abstract(method: nodes.FunctionDef) -> bool:\n            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]\n\n        # check if this class abstract\n        if class_is_abstract(node):\n            return\n\n        methods = sorted(\n            unimplemented_abstract_methods(node, is_abstract).items(),\n            key=lambda item: item[0],\n        )\n        for name, method in methods:\n            owner = method.parent.frame()\n            if owner is node:\n                continue\n            # owner is not this class, it must be a parent class\n            # check that the ancestor's method is not abstract\n            if name in node.locals:\n                # it is redefined as an attribute or with a descriptor\n                continue\n\n            self.add_message(\n                \"abstract-method\",\n                node=node,\n                args=(name, owner.name, node.name),\n                confidence=INFERENCE,\n            )\n", "type": "function"}, {"name": "check", "is_method": true, "class_name": "Base", "parameters": ["self", "arg"], "calls": [], "code_location": {"file": "no_self_use.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/ext/no_self_use", "start_line": 35, "end_line": 37}, "code_snippet": "    def check(self, arg):\n        \"\"\"an abstract method, could not be a function\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "visit_call", "is_method": true, "class_name": "BasicErrorChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "infer_all", "self._check_inferred_class_is_abstract"], "code_location": {"file": "basic_error_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 427, "end_line": 432}, "code_snippet": "    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check instantiating abstract class with\n        abc.ABCMeta as metaclass.\n        \"\"\"\n        for inferred in infer_all(node.func):\n            self._check_inferred_class_is_abstract(inferred, node)\n", "type": "function"}, {"name": "AbstractC", "docstring": "Abstract class.\n\nShould not trigger a warning for unimplemented\nabstract methods, because of explicit abc.ABC inheritance.", "methods": [], "attributes": [], "code_location": {"file": "abstract_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 29, "end_line": 35}, "type": "class"}, {"name": "setup_pair", "is_method": true, "class_name": "AbstrClass", "parameters": ["self"], "calls": [], "code_location": {"file": "unpacking_non_sequence.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unpacking", "start_line": 52, "end_line": 54}, "code_snippet": "    def setup_pair(self):\n        \"abstract method\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "AbstractD", "docstring": "Abstract class.\n\nShould not trigger a warning for unimplemented\nabstract methods, because of explicit metaclass.", "methods": [], "attributes": [], "code_location": {"file": "abstract_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 38, "end_line": 44}, "type": "class"}, {"name": "prop", "is_method": true, "class_name": "Parent", "parameters": ["self"], "calls": [], "code_location": {"file": "abstract_abc_methods.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 12, "end_line": 13}, "code_snippet": "    def prop(self):\n        \"\"\" Abstract \"\"\"\n", "type": "function"}, {"name": "BadMroAbstractMethods", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "abstract_class_instantiated.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a/abstract", "start_line": 82, "end_line": 83}, "type": "class"}, {"name": "inherited", "is_method": true, "class_name": "Base", "parameters": ["self", "aaa", "aab", "aac"], "calls": [], "code_location": {"file": "unused_argument.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/unused", "start_line": 22, "end_line": 24}, "code_snippet": "    def inherited(self, aaa, aab, aac):\n        \"abstract method\"\n        raise NotImplementedError\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34594082832336426}
{"question": "What are the semantic implications of a concrete class implementing a typing protocol having an empty __init__ method body containing only ellipsis for protocol conformance while still requiring calls in the inheritance chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "TestChild", "parameters": ["self"], "calls": [], "code_location": {"file": "super_init_not_called_extensions_py310.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 21, "end_line": 22}, "code_snippet": "    def __init__(self):  # [super-init-not-called]\n        ...\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ChildThree", "parameters": ["self"], "calls": [], "code_location": {"file": "super_init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 50, "end_line": 51}, "code_snippet": "    def __init__(self):  # [super-init-not-called]\n        ...\n", "type": "function"}, {"name": "TestProto", "docstring": "A protocol without __init__ using Protocol from typing_extensions.", "methods": [], "attributes": [], "code_location": {"file": "super_init_not_called_extensions_py310.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 7, "end_line": 8}, "type": "class"}, {"name": "IndirectProtocol", "docstring": "Doesn't subclass typing.Protocol directly", "methods": [], "attributes": [], "code_location": {"file": "protocol_classes_abstract.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/p", "start_line": 33, "end_line": 34}, "type": "class"}, {"name": "AbcProtocol", "docstring": "Doesn't subclass typing.Protocol but uses metaclass directly", "methods": [], "attributes": [], "code_location": {"file": "protocol_classes_abstract.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/p", "start_line": 36, "end_line": 37}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "ProtocolImplimentation", "parameters": ["self"], "calls": [], "code_location": {"file": "super_init_not_called_py38.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 19, "end_line": 20}, "code_snippet": "    def __init__(self) -> None:\n        ...\n", "type": "function"}, {"name": "AssignedInit", "docstring": "No init called, but abstract so that is fine.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i", "start_line": 60, "end_line": 64}, "type": "class"}, {"name": "EllipsisBody", "docstring": "Test that an Ellipsis as a body does not trigger the error", "methods": [], "attributes": [], "code_location": {"file": "statement_without_effect.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s", "start_line": 76, "end_line": 78}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "SpecialMethodsChecker", "parameters": ["self", "linter"], "calls": ["__init__", "super"], "code_location": {"file": "special_methods_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 145, "end_line": 162}, "code_snippet": "    def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._protocol_map: dict[\n            str, Callable[[nodes.FunctionDef, InferenceResult], None]\n        ] = {\n            \"__iter__\": self._check_iter,\n            \"__len__\": self._check_len,\n            \"__bool__\": self._check_bool,\n            \"__index__\": self._check_index,\n            \"__repr__\": self._check_repr,\n            \"__str__\": self._check_str,\n            \"__bytes__\": self._check_bytes,\n            \"__hash__\": self._check_hash,\n            \"__length_hint__\": self._check_length_hint,\n            \"__format__\": self._check_format,\n            \"__getnewargs__\": self._check_getnewargs,\n            \"__getnewargs_ex__\": self._check_getnewargs_ex,\n        }\n", "type": "function"}, {"name": "__init_subclass__", "is_method": true, "class_name": "InitSubclassParent", "parameters": ["cls"], "calls": [], "code_location": {"file": "arguments_differ.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/a", "start_line": 365, "end_line": 366}, "code_snippet": "    def __init_subclass__(cls, *args, **kwargs):\n        ...\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3309440612792969}
{"question": "How does explicitly calling a parent constructor via a dotted module path handle method resolution order in multi-level inheritance hierarchies?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "method", "is_method": true, "class_name": "GrandChild", "parameters": ["self"], "calls": ["print", "method", "method", "method", "super", "super", "super"], "code_location": {"file": "super_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 145, "end_line": 149}, "code_snippet": "    def method(self):\n        print(\"Grandchild\")\n        super(GrandChild, self).method()\n        super(Child, self).method()\n        super(Niece, self).method()  # [bad-super-call]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ZZZZ", "parameters": ["self"], "calls": ["AAAA.__init__"], "code_location": {"file": "init_not_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i", "start_line": 31, "end_line": 32}, "code_snippet": "    def __init__(self):  # [super-init-not-called]\n        AAAA.__init__(self)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "UnknownBases", "parameters": ["self"], "calls": ["__init__", "test", "test", "super", "super", "super"], "code_location": {"file": "super_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 67, "end_line": 70}, "code_snippet": "    def __init__(self):\n        super(UnknownBases, self).__init__()\n        super(UnknownBases, self).test()\n        super(Missing, self).test() # [bad-super-call]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Cat", "parameters": ["self"], "calls": ["__init__", "__init__", "super", "super"], "code_location": {"file": "bad.py", "path": "/data3/pwh/swebench-repos/pylint/doc/data/messages/b/bad-super-call", "start_line": 10, "end_line": 12}, "code_snippet": "    def __init__(self):\n        super(Tree, self).__init__()  # [bad-super-call]\n        super(Animal, self).__init__()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AAAA", "parameters": ["self"], "calls": ["print", "BBBBMixin.__init__"], "code_location": {"file": "non_init_parent_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 12, "end_line": 14}, "code_snippet": "    def __init__(self):\n        print('init', self)\n        BBBBMixin.__init__(self)  # [non-parent-init-called]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "CrashSuper", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "super_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 45, "end_line": 46}, "code_snippet": "    def __init__(self):\n        super(Getattr.name, self).__init__()  # [bad-super-call]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "CCC", "parameters": ["self"], "calls": ["BBBBMixin.__init__", "non_init_parent_called.AAAA.__init__", "non_init_parent_called.BBBB.__init__", "nonexistent.AClass.__init__"], "code_location": {"file": "non_init_parent_called.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/non", "start_line": 24, "end_line": 28}, "code_snippet": "    def __init__(self):\n        BBBBMixin.__init__(self)\n        non_init_parent_called.AAAA.__init__(self)\n        non_init_parent_called.BBBB.__init__(self)  # [no-member]\n        nonexistent.AClass.__init__(self)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "SuperWithSelfClass", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "super_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 124, "end_line": 125}, "code_snippet": "    def __init__(self):\n        super(self.__class__, self).__init__() # [bad-super-call]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "NewAaaa", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "super_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 21, "end_line": 22}, "code_snippet": "    def __init__(self):\n        super(Aaaa, self).__init__()  # [bad-super-call]\n", "type": "function"}, {"name": "method_accepting_cls", "is_method": false, "class_name": null, "parameters": ["cls", "self"], "calls": ["__init__", "super"], "code_location": {"file": "super_with_arguments.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/s/super", "start_line": 30, "end_line": 35}, "code_snippet": "def method_accepting_cls(cls, self):\n    # Using plain `super()` is not valid here, since there's no `__class__` cell found\n    # (Exact exception would be 'RuntimeError: super(): __class__ cell not found')\n    # Instead, we expect to *not* see a warning about `super-with-arguments`.\n    # Explicitly passing `cls`, and `self` to `super()` is what's required.\n    super(cls, self).__init__()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3487119674682617}
{"question": "Where is the undefined-variable error triggered for the type annotation parameter in the first-level method that incorrectly references its own class, through the chain of module imports and type-checking guards?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "VariableAnnotationsGuardedByTypeChecking", "docstring": "Class to test conditional imports guarded by TYPE_CHECKING then used in\nlocal (function) variable annotations, which are not evaluated at runtime.\n\nSee: https://github.com/pylint-dev/pylint/issues/7609\nand https://github.com/pylint-dev/pylint/issues/7882", "methods": ["print_date"], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 145, "end_line": 159}, "type": "class"}, {"name": "MyFourthClass", "docstring": "Class to test conditional imports guarded by TYPE_CHECKING two levels\nup then used in function annotation. See https://github.com/pylint-dev/pylint/issues/7539", "methods": ["is_close"], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 136, "end_line": 142}, "type": "class"}, {"name": "z", "is_method": true, "class_name": "RepeatedReturnAnnotations", "parameters": ["self"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 381, "end_line": 382}, "code_snippet": "    def z(self) -> RepeatedReturnAnnotations:  # <3.14:[undefined-variable]\n        pass\n", "type": "function"}, {"name": "incorrect_typing_method", "is_method": true, "class_name": "MyClass", "parameters": ["self", "other"], "calls": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 68, "end_line": 71}, "code_snippet": "    def incorrect_typing_method(\n        self, other: MyClass  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other\n", "type": "function"}, {"name": "incorrect_nested_typing_method", "is_method": true, "class_name": "MyClass", "parameters": ["self", "other"], "calls": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 73, "end_line": 76}, "code_snippet": "    def incorrect_nested_typing_method(\n        self, other: List[MyClass]  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other[0]\n", "type": "function"}, {"name": "say_hello", "is_method": true, "class_name": "A", "parameters": ["self"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 385, "end_line": 386}, "code_snippet": "    def say_hello(self) -> __module__:  # <3.14:[undefined-variable]\n        ...\n", "type": "function"}, {"name": "x", "is_method": true, "class_name": "RepeatedReturnAnnotations", "parameters": ["self", "o"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 377, "end_line": 378}, "code_snippet": "    def x(self, o: RepeatedReturnAnnotations) -> bool:  # <3.14:[undefined-variable]\n        pass\n", "type": "function"}, {"name": "y", "is_method": true, "class_name": "RepeatedReturnAnnotations", "parameters": ["self"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 379, "end_line": 380}, "code_snippet": "    def y(self) -> RepeatedReturnAnnotations:  # <3.14:[undefined-variable]\n        pass\n", "type": "function"}, {"name": "MyClass", "docstring": "Type annotation or default values for first level methods can't refer to their own class", "methods": [], "attributes": [], "code_location": {"file": "used_before_assignment_typing.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/used", "start_line": 65, "end_line": 90}, "type": "class"}, {"name": "undefined_annotation", "is_method": false, "class_name": null, "parameters": ["a"], "calls": [], "code_location": {"file": "undefined_variable.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/u/undefined", "start_line": 308, "end_line": 312}, "code_snippet": "def undefined_annotation(a:x): # [undefined-variable]\n    if x == 2: # [used-before-assignment]\n        for x in [1, 2]:\n            pass\n    return a\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3423116207122803}
{"question": "Where in the no-member validation function is the mechanism that enables modules with dynamic attribute handlers to bypass member checks?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_no_member_in_getattr_ignored", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "no_member_imports.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 12, "end_line": 18}, "code_snippet": "def test_no_member_in_getattr_ignored() -> None:\n    \"\"\"Make sure that a module attribute access check is omitted with a\n    module that is configured to be ignored.\n    \"\"\"\n    import argparse\n\n    argparse.THIS_does_not_EXIST\n", "type": "function"}, {"name": "_emit_no_member", "is_method": false, "class_name": null, "parameters": ["node", "owner", "owner_name", "mixin_class_rgx", "ignored_mixins", "ignored_none"], "calls": ["node_ignores_exception", "isinstance", "isinstance", "isinstance", "node.scope", "isinstance", "is_super", "mixin_class_rgx.match", "isinstance", "owner.has_dynamic_getattr", "utils.is_attribute_typed_annotation", "node.attrname.startswith", "isinstance", "getattr", "owner.is_abstract", "owner.metaclass", "has_known_bases", "owner.super_mro", "all", "owner.getattr", "node.attrname.split", "safe_infer", "owner.getattr", "isinstance", "metaclass.qname", "_enum_has_attribute", "has_known_bases", "inferred.bool_value", "owner.type.mro", "isinstance", "isinstance"], "code_location": {"file": "typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 420, "end_line": 522}, "code_snippet": "def _emit_no_member(\n    node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr,\n    owner: InferenceResult,\n    owner_name: str | None,\n    mixin_class_rgx: Pattern[str],\n    ignored_mixins: bool = True,\n    ignored_none: bool = True,\n) -> bool:\n    \"\"\"Try to see if no-member should be emitted for the given owner.\n\n    The following cases are ignored:\n\n        * the owner is a function and it has decorators.\n        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:\n        return False\n    if is_super(owner) or getattr(owner, \"type\", None) == \"metaclass\":\n        return False\n    if owner_name and ignored_mixins and mixin_class_rgx.match(owner_name):\n        return False\n    if isinstance(owner, nodes.FunctionDef) and (\n        owner.decorators or owner.is_abstract()\n    ):\n        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n            pass\n        else:\n            # Renamed in Python 3.10 to `EnumType`\n            if metaclass and metaclass.qname() in {\"enum.EnumMeta\", \"enum.EnumType\"}:\n                return not _enum_has_attribute(owner, node)\n        if owner.has_dynamic_getattr():\n            return False\n        if not has_known_bases(owner):\n            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n        # Verify if we are dealing with an invalid Super object.\n        # If it is invalid, then there's no point in checking that\n        # it has the required attribute. Also, don't fail if the\n        # MRO is invalid.\n        try:\n            owner.super_mro()\n        except (astroid.MroError, astroid.SuperError):\n            return False\n        if not all(has_known_bases(base) for base in owner.type.mro()):\n            return False\n    if isinstance(owner, nodes.Module):\n        try:\n            owner.getattr(\"__getattr__\")\n            return False\n        except astroid.NotFoundError:\n            pass\n    if owner_name and node.attrname.startswith(\"_\" + owner_name):\n        # Test if an attribute has been mangled ('private' attribute)\n        unmangled_name = node.attrname.split(\"_\" + owner_name)[-1]\n        try:\n            if owner.getattr(unmangled_name, context=None) is not None:\n                return False\n        except astroid.NotFoundError:\n            return True\n\n    # Don't emit no-member if guarded behind `IF` or `IFExp`\n    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n            if (  # pylint: disable=too-many-boolean-expressions\n                isinstance(inferred, nodes.Const)\n                and inferred.bool_value() is False\n                and (\n                    (isinstance(parent, nodes.If) and node_origin in parent.body)\n                    or (isinstance(parent, nodes.IfExp) and node_origin == parent.body)\n                )\n            ):\n                return False\n        node_origin, parent = parent, parent.parent\n\n    return True\n", "type": "function"}, {"name": "test_no_member_in_getattr", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "no_member_imports.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 5, "end_line": 9}, "code_snippet": "def test_no_member_in_getattr():\n    \"\"\"Make sure that a module attribute access is checked by pylint.\"\"\"\n    import math\n\n    math.THIS_does_not_EXIST  # [no-member]\n", "type": "function"}, {"name": "Getattribute", "docstring": "no-member shouldn't be emitted for classes with dunder getattribute.", "methods": ["__getattribute__"], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 77, "end_line": 81}, "type": "class"}, {"name": "Getattr", "docstring": "no-member shouldn't be emitted for classes with dunder getattr.", "methods": [], "attributes": [], "code_location": {"file": "member_checks.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m/member", "start_line": 70, "end_line": 74}, "type": "class"}, {"name": "visit_attribute", "is_method": true, "class_name": "TypeChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "any", "set", "is_node_in_type_annotation_context", "list", "getattr", "_is_owner_ignored", "any", "set", "pattern.match", "node.expr.infer", "len", "len", "owner.getattr", "isinstance", "done.add", "self._get_nomember_msgid_hint", "self.add_message", "isinstance", "owner.pytype", "pattern.match", "missingattr.add", "missingattr.add", "node.as_string", "isinstance", "_emit_no_member", "isinstance", "owner.display_type", "attr_node.statement", "isinstance", "utils.is_augmented_assign"], "code_location": {"file": "typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1058, "end_line": 1190}, "code_snippet": "    def visit_attribute(\n        self, node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr\n    ) -> None:\n        \"\"\"Check that the accessed attribute exists.\n\n        to avoid too much false positives for now, we'll consider the code as\n        correct if a single of the inferred nodes has the accessed attribute.\n\n        function/method, super call and metaclasses are ignored\n        \"\"\"\n        if any(\n            pattern.match(name)\n            for name in (node.attrname, node.as_string())\n            for pattern in self._compiled_generated_members\n        ):\n            return\n\n        if self._postponed_evaluation_enabled and is_node_in_type_annotation_context(\n            node\n        ):\n            return\n\n        try:\n            inferred = list(node.expr.infer())\n        except astroid.InferenceError:\n            return\n\n        # list of (node, nodename) which are missing the attribute\n        missingattr: set[tuple[SuccessfulInferenceResult, str | None]] = set()\n\n        non_opaque_inference_results: list[SuccessfulInferenceResult] = [\n            owner\n            for owner in inferred\n            if not isinstance(owner, (nodes.Unknown, util.UninferableBase))\n        ]\n        if (\n            len(non_opaque_inference_results) != len(inferred)\n            and self.linter.config.ignore_on_opaque_inference\n        ):\n            # There is an ambiguity in the inference. Since we can't\n            # make sure that we won't emit a false positive, we just stop\n            # whenever the inference returns an opaque inference object.\n            return\n        for owner in non_opaque_inference_results:\n            name = getattr(owner, \"name\", None)\n            if _is_owner_ignored(\n                owner,\n                name,\n                self.linter.config.ignored_classes,\n                self.linter.config.ignored_modules,\n            ):\n                continue\n\n            qualname = f\"{owner.pytype()}.{node.attrname}\"\n            if any(\n                pattern.match(qualname) for pattern in self._compiled_generated_members\n            ):\n                return\n\n            try:\n                attr_nodes = owner.getattr(node.attrname)\n            except AttributeError:\n                continue\n            except astroid.DuplicateBasesError:\n                continue\n            except astroid.NotFoundError:\n                # Avoid false positive in case a decorator supplies member.\n                if (\n                    isinstance(owner, (astroid.FunctionDef, astroid.BoundMethod))\n                    and owner.decorators\n                ):\n                    continue\n                # This can't be moved before the actual .getattr call,\n                # because there can be more values inferred and we are\n                # stopping after the first one which has the attribute in question.\n                # The problem is that if the first one has the attribute,\n                # but we continue to the next values which doesn't have the\n                # attribute, then we'll have a false positive.\n                # So call this only after the call has been made.\n                if not _emit_no_member(\n                    node,\n                    owner,\n                    name,\n                    self._mixin_class_rgx,\n                    ignored_mixins=(\n                        \"no-member\" in self.linter.config.ignored_checks_for_mixins\n                    ),\n                    ignored_none=self.linter.config.ignore_none,\n                ):\n                    continue\n                missingattr.add((owner, name))\n                continue\n            else:\n                for attr_node in attr_nodes:\n                    attr_parent = attr_node.parent\n                    # Skip augmented assignments\n                    try:\n                        if isinstance(attr_node.statement(), nodes.AugAssign) or (\n                            isinstance(attr_parent, nodes.Assign)\n                            and utils.is_augmented_assign(attr_parent)[0]\n                        ):\n                            continue\n                    except astroid.exceptions.StatementMissing:\n                        break\n                    # Skip self-referencing assignments\n                    if attr_parent is node.parent:\n                        continue\n                    break\n                else:\n                    missingattr.add((owner, name))\n                    continue\n            # stop on the first found\n            break\n        else:\n            # we have not found any node with the attributes, display the\n            # message for inferred nodes\n            done = set()\n            for owner, name in missingattr:\n                if isinstance(owner, astroid.Instance):\n                    actual = owner._proxied\n                else:\n                    actual = owner\n                if actual in done:\n                    continue\n                done.add(actual)\n\n                msg, hint = self._get_nomember_msgid_hint(node, owner)\n                self.add_message(\n                    msg,\n                    node=node,\n                    args=(owner.display_type(), name, node.attrname, hint),\n                    confidence=INFERENCE,\n                )\n", "type": "function"}, {"name": "test_ignored_modules_invalid_pattern", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "no_member_imports.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/n/no", "start_line": 21, "end_line": 24}, "code_snippet": "def test_ignored_modules_invalid_pattern() -> None:\n    import xml\n\n    xml.etree.THIS_does_not_EXIST  # [no-member]\n", "type": "function"}, {"name": "NoKnownBases", "docstring": "Don't emit no-member if we don't know the bases of a class.", "methods": [], "attributes": [], "code_location": {"file": "class_members_py30.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 52, "end_line": 53}, "type": "class"}, {"name": "visit_attribute", "is_method": true, "class_name": "ClassChecker", "parameters": ["self", "node"], "calls": ["self._check_super_without_brackets", "self._uses_mandatory_method_param", "self._check_protected_attribute_access", "self._accessed.set_accessed", "self.linter.is_message_enabled"], "code_location": {"file": "class_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/classes", "start_line": 1692, "end_line": 1709}, "code_snippet": "    def visit_attribute(self, node: nodes.Attribute) -> None:\n        \"\"\"Check if the getattr is an access to a class member\n        if so, register it.\n\n        Also check for access to protected\n        class member from outside its class (but ignore __special__\n        methods)\n        \"\"\"\n        self._check_super_without_brackets(node)\n\n        # Check self\n        if self._uses_mandatory_method_param(node):\n            self._accessed.set_accessed(node)\n            return\n        if not self.linter.is_message_enabled(\"protected-access\"):\n            return\n\n        self._check_protected_attribute_access(node)\n", "type": "function"}, {"name": "NoMemberMixin", "docstring": "Class that does match the option pattern", "methods": [], "attributes": [], "code_location": {"file": "mixin_class_rgx.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/m", "start_line": 57, "end_line": 58}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.3405923843383789}
{"question": "Where does the control flow in the method that checks ellipsis constants branch differently when the grandparent node is a class definition versus a function definition?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_is_ellipsis", "is_method": false, "class_name": null, "parameters": ["node"], "calls": ["isinstance"], "code_location": {"file": "_check_docs_utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 164, "end_line": 165}, "code_snippet": "def _is_ellipsis(node: nodes.NodeNG) -> bool:\n    return isinstance(node, nodes.Const) and node.value == Ellipsis\n", "type": "function"}, {"name": "visit_const", "is_method": true, "class_name": "EllipsisChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "isinstance", "self.add_message", "node.pytype", "isinstance", "len"], "code_location": {"file": "ellipsis_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 34, "end_line": 54}, "code_snippet": "    def visit_const(self, node: nodes.Const) -> None:\n        \"\"\"Check if the ellipsis constant is used unnecessarily.\n\n        Emits a warning when:\n         - A line consisting of an ellipsis is preceded by a docstring.\n         - A statement exists in the same scope as the ellipsis.\n           For example: A function consisting of an ellipsis followed by a\n           return statement on the next line.\n        \"\"\"\n        if (\n            node.pytype() == \"builtins.Ellipsis\"\n            and isinstance(node.parent, nodes.Expr)\n            and (\n                (\n                    isinstance(node.parent.parent, (nodes.ClassDef, nodes.FunctionDef))\n                    and node.parent.parent.doc_node\n                )\n                or len(node.parent.parent.body) > 1\n            )\n        ):\n            self.add_message(\"unnecessary-ellipsis\", node=node)\n", "type": "function"}, {"name": "is_function_body_ellipsis", "is_method": false, "class_name": null, "parameters": ["node"], "calls": ["isinstance", "isinstance", "len"], "code_location": {"file": "utils.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 1902, "end_line": 1909}, "code_snippet": "def is_function_body_ellipsis(node: nodes.FunctionDef) -> bool:\n    \"\"\"Checks whether a function body only consists of a single Ellipsis.\"\"\"\n    return (\n        len(node.body) == 1\n        and isinstance(node.body[0], nodes.Expr)\n        and isinstance(node.body[0].value, nodes.Const)\n        and node.body[0].value.value == Ellipsis\n    )\n", "type": "function"}, {"name": "_check_using_constant_test", "is_method": true, "class_name": "BasicChecker", "parameters": ["self", "node", "test"], "calls": ["isinstance", "isinstance", "utils.safe_infer", "isinstance", "utils.safe_infer", "isinstance", "self.add_message", "isinstance", "isinstance", "isinstance", "BasicChecker._name_holds_generator", "inferred_call._get_return_nodes_skip_functions", "self.add_message", "self.add_message", "isinstance", "self.add_message", "isinstance", "list", "isinstance", "inferred.infer_call_result", "list", "inferred.infer_call_result"], "code_location": {"file": "basic_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 303, "end_line": 382}, "code_snippet": "    def _check_using_constant_test(\n        self,\n        node: nodes.If | nodes.IfExp | nodes.Comprehension,\n        test: nodes.NodeNG | None,\n    ) -> None:\n        const_nodes = (\n            nodes.Module,\n            nodes.GeneratorExp,\n            nodes.Lambda,\n            nodes.FunctionDef,\n            nodes.ClassDef,\n            astroid.bases.Generator,\n            astroid.UnboundMethod,\n            astroid.BoundMethod,\n            nodes.Module,\n        )\n        structs = (nodes.Dict, nodes.Tuple, nodes.Set, nodes.List)\n\n        # These nodes are excepted, since they are not constant\n        # values, requiring a computation to happen.\n        except_nodes = (\n            nodes.Call,\n            nodes.BinOp,\n            nodes.BoolOp,\n            nodes.UnaryOp,\n            nodes.Subscript,\n        )\n        inferred = None\n        emit = isinstance(test, (nodes.Const, *structs, *const_nodes))\n        maybe_generator_call = None\n        if not isinstance(test, except_nodes):\n            inferred = utils.safe_infer(test)\n            if isinstance(inferred, util.UninferableBase) and isinstance(\n                test, nodes.Name\n            ):\n                emit, maybe_generator_call = BasicChecker._name_holds_generator(test)\n\n        # Emit if calling a function that only returns GeneratorExp (always tests True)\n        elif isinstance(test, nodes.Call):\n            maybe_generator_call = test\n        if maybe_generator_call:\n            inferred_call = utils.safe_infer(maybe_generator_call.func)\n            if isinstance(inferred_call, nodes.FunctionDef):\n                # Can't use all(x) or not any(not x) for this condition, because it\n                # will return True for empty generators, which is not what we want.\n                all_returns_were_generator = None\n                for return_node in inferred_call._get_return_nodes_skip_functions():\n                    if not isinstance(return_node.value, nodes.GeneratorExp):\n                        all_returns_were_generator = False\n                        break\n                    all_returns_were_generator = True\n                if all_returns_were_generator:\n                    self.add_message(\n                        \"using-constant-test\", node=node, confidence=INFERENCE\n                    )\n                    return\n\n        if emit:\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n        elif isinstance(inferred, const_nodes):\n            # If the constant node is a FunctionDef or Lambda then\n            # it may be an illicit function call due to missing parentheses\n            call_inferred = None\n            try:\n                # Just forcing the generator to infer all elements.\n                # astroid.exceptions.InferenceError are false positives\n                # see https://github.com/pylint-dev/pylint/pull/8185\n                if isinstance(inferred, nodes.FunctionDef):\n                    call_inferred = list(inferred.infer_call_result(node))\n                elif isinstance(inferred, nodes.Lambda):\n                    call_inferred = list(inferred.infer_call_result(node))\n            except astroid.InferenceError:\n                call_inferred = None\n            if call_inferred:\n                self.add_message(\n                    \"missing-parentheses-for-call-in-test\",\n                    node=test,\n                    confidence=INFERENCE,\n                )\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n", "type": "function"}, {"name": "visit_ifexp", "is_method": true, "class_name": "BasicChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self._check_using_constant_test"], "code_location": {"file": "basic_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 292, "end_line": 293}, "code_snippet": "    def visit_ifexp(self, node: nodes.IfExp) -> None:\n        self._check_using_constant_test(node, node.test)\n", "type": "function"}, {"name": "visit_trystar", "is_method": true, "class_name": "UnsupportedVersionChecker", "parameters": ["self", "node"], "calls": ["only_required_for_messages", "self.add_message"], "code_location": {"file": "unsupported_version.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 132, "end_line": 138}, "code_snippet": "    def visit_trystar(self, node: nodes.TryStar) -> None:\n        if not self._py311_plus:\n            self.add_message(\n                \"using-exception-groups-in-unsupported-version\",\n                node=node,\n                confidence=HIGH,\n            )\n", "type": "function"}, {"name": "_is_variable_violation", "is_method": true, "class_name": "VariablesChecker", "parameters": ["node", "defnode", "stmt", "defstmt", "frame", "defframe", "base_scope_type", "is_recursive_klass"], "calls": ["_detect_global_scope", "isinstance", "isinstance", "isinstance", "isinstance", "_assigned_locally", "isinstance", "defframe.parent_of", "astroid.builtin_lookup", "isinstance", "isinstance", "lookup", "node.frame", "isinstance", "_is_nonlocal_name", "isinstance", "any", "isinstance", "defframe.parent_of", "defframe.root", "next", "tuple", "isinstance", "VariablesChecker._maybe_used_and_assigned_at_once", "defframe.parent_of", "defframe.node_ancestors", "frame.node_ancestors", "isinstance", "isinstance", "defframe.parent_of", "_is_before", "any", "isinstance", "node.node_ancestors"], "code_location": {"file": "variables.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 2237, "end_line": 2390}, "code_snippet": "    def _is_variable_violation(\n        node: nodes.Name,\n        defnode: nodes.NodeNG,\n        stmt: _base_nodes.Statement,\n        defstmt: _base_nodes.Statement,\n        frame: nodes.LocalsDictNodeNG,  # scope of statement of node\n        defframe: nodes.LocalsDictNodeNG,\n        base_scope_type: str,\n        is_recursive_klass: bool,\n    ) -> tuple[bool, bool, bool]:\n        maybe_before_assign = True\n        annotation_return = False\n        use_outer_definition = False\n        if frame is not defframe:\n            maybe_before_assign = _detect_global_scope(node, frame, defframe)\n        elif defframe.parent is None:\n            # we are at the module level, check the name is not\n            # defined in builtins\n            if (\n                node.name in defframe.scope_attrs\n                or astroid.builtin_lookup(node.name)[1]\n            ):\n                maybe_before_assign = False\n        else:\n            # we are in a local scope, check the name is not\n            # defined in global or builtin scope\n            # skip this lookup if name is assigned later in function scope/lambda\n            # Note: the node.frame() is not the same as the `frame` argument which is\n            # equivalent to frame.statement().scope()\n            forbid_lookup = (\n                isinstance(frame, nodes.FunctionDef)\n                or isinstance(node.frame(), nodes.Lambda)\n            ) and _assigned_locally(node)\n            if not forbid_lookup and defframe.root().lookup(node.name)[1]:\n                maybe_before_assign = False\n                use_outer_definition = stmt == defstmt and not isinstance(\n                    defnode, nodes.Comprehension\n                )\n            # check if we have a nonlocal\n            elif node.name in defframe.locals:\n                maybe_before_assign = not _is_nonlocal_name(node, defframe)\n\n        if (\n            base_scope_type == \"lambda\"\n            and isinstance(frame, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n            #\n            # bar = None\n            # foo = lambda bar=bar: bar\n            #\n            # In this case, maybe_before_assign should be False, otherwise\n            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n            frame, nodes.FunctionDef\n        ):\n            # Special rules for function return annotations.\n            if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_parent := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n                maybe_before_assign and stmt.fromlineno <= defstmt.fromlineno\n            )\n            if maybe_before_assign and stmt.fromlineno == defstmt.fromlineno:\n                if (\n                    isinstance(defframe, nodes.FunctionDef)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and (\n                        defnode in defframe.type_params\n                        # Single statement function, with the statement on the\n                        # same line as the function definition\n                        or stmt is not defstmt\n                    )\n                ):\n                    maybe_before_assign = False\n                elif (\n                    isinstance(defstmt, NODES_WITH_VALUE_ATTR)\n                    and VariablesChecker._maybe_used_and_assigned_at_once(defstmt)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and stmt is defstmt\n                ):\n                    # Single statement if, with assignment expression on same\n                    # line as assignment\n                    # x = b if (b := True) else False\n                    maybe_before_assign = False\n                elif (\n                    isinstance(defnode, nodes.NamedExpr)\n                    and frame is defframe\n                    and defframe.parent_of(stmt)\n                    and stmt is defstmt\n                    and _is_before(defnode, node)\n                ):\n                    # Relation of a name to the same name in a named expression\n                    # Could be used before assignment if self-referencing:\n                    # (b := b)\n                    # Otherwise, safe if used after assignment:\n                    # (b := 2) and b\n                    maybe_before_assign = defnode.value is node or any(\n                        a is defnode.value for a in node.node_ancestors()\n                    )\n                elif (\n                    isinstance(defframe, nodes.ClassDef)\n                    and defnode in defframe.type_params\n                ):\n                    # Generic on parent class:\n                    # class Child[_T](Parent[_T])\n                    maybe_before_assign = False\n\n        return maybe_before_assign, annotation_return, use_outer_definition\n", "type": "function"}, {"name": "visit_comprehension", "is_method": true, "class_name": "BasicChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "self._check_using_constant_test"], "code_location": {"file": "basic_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers/base", "start_line": 298, "end_line": 301}, "code_snippet": "    def visit_comprehension(self, node: nodes.Comprehension) -> None:\n        if node.ifs:\n            for if_test in node.ifs:\n                self._check_using_constant_test(node, if_test)\n", "type": "function"}, {"name": "_common_cond_list_set", "is_method": true, "class_name": "ModifiedIterationChecker", "parameters": ["node", "iter_obj", "infer_val"], "calls": ["isinstance", "utils.safe_infer"], "code_location": {"file": "modified_iterating_checker.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/checkers", "start_line": 110, "end_line": 122}, "code_snippet": "    def _common_cond_list_set(\n        node: nodes.Expr,\n        iter_obj: nodes.Name | nodes.Attribute,\n        infer_val: nodes.List | nodes.Set,\n    ) -> bool:\n        iter_obj_name = (\n            iter_obj.attrname\n            if isinstance(iter_obj, nodes.Attribute)\n            else iter_obj.name\n        )\n        return (infer_val == utils.safe_infer(iter_obj)) and (  # type: ignore[no-any-return]\n            node.value.func.expr.name == iter_obj_name\n        )\n", "type": "function"}, {"name": "visit_compare", "is_method": true, "class_name": "MisplacedComparisonConstantChecker", "parameters": ["self", "node"], "calls": ["utils.only_required_for_messages", "len", "isinstance", "self._check_misplaced_constant"], "code_location": {"file": "comparison_placement.py", "path": "/data3/pwh/swebench-repos/pylint/pylint/extensions", "start_line": 56, "end_line": 65}, "code_snippet": "    def visit_compare(self, node: nodes.Compare) -> None:\n        # NOTE: this checker only works with binary comparisons like 'x == 42'\n        # but not 'x == y == 42'\n        if len(node.ops) != 1:\n            return\n\n        left = node.left\n        operator, right = node.ops[0]\n        if operator in COMPARISON_OPERATORS and isinstance(left, nodes.Const):\n            self._check_misplaced_constant(node, left, right, operator)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3898155689239502}
{"question": "Why does the test case that validates detection of overridden methods marked as immutable use the typing decorator that prevents subclass modifications to maintain behavioral contracts in class hierarchies?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "my_method", "is_method": true, "class_name": "Subclass2", "parameters": ["self"], "calls": [], "code_location": {"file": "overridden_final_method_py38.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/o", "start_line": 30, "end_line": 31}, "code_snippet": "    def my_method(self): # [overridden-final-method]\n        pass\n", "type": "function"}, {"name": "my_method", "is_method": true, "class_name": "Subclass", "parameters": ["self"], "calls": [], "code_location": {"file": "overridden_final_method_py38.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/o", "start_line": 15, "end_line": 16}, "code_snippet": "    def my_method(self): # [overridden-final-method]\n        pass\n", "type": "function"}, {"name": "bar", "is_method": true, "class_name": "B", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_overridden_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 122, "end_line": 123}, "code_snippet": "    def bar(self):  # [invalid-overridden-method]\n        return False\n", "type": "function"}, {"name": "bar2", "is_method": true, "class_name": "B", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_overridden_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 126, "end_line": 127}, "code_snippet": "    def bar2(self):  # [invalid-overridden-method]\n        return False\n", "type": "function"}, {"name": "decorated_by_unsubscriptable_then_subscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertNoMessages", "self.checker.visit_subscript"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 158, "end_line": 174}, "code_snippet": "    def decorated_by_unsubscriptable_then_subscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "decorated_by_subscriptable_then_unsubscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertAddsMessages", "self.checker.visit_subscript", "MessageTest"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 129, "end_line": 156}, "code_snippet": "    def decorated_by_subscriptable_then_unsubscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Unsubscriptable\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=18,\n                col_offset=7,\n                end_line=18,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "func", "is_method": true, "class_name": "Child", "parameters": ["self"], "calls": [], "code_location": {"file": "cached_property.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/c", "start_line": 22, "end_line": 23}, "code_snippet": "    def func(self):  # [invalid-overridden-method]\n        return 42\n", "type": "function"}, {"name": "prop", "is_method": true, "class_name": "InvalidDerived", "parameters": ["self"], "calls": [], "code_location": {"file": "invalid_overridden_method.py", "path": "/data3/pwh/swebench-repos/pylint/tests/functional/i/invalid", "start_line": 38, "end_line": 39}, "code_snippet": "    def prop(self):  # [invalid-overridden-method]\n        return None\n", "type": "function"}, {"name": "decorated_by_an_unsubscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertAddsMessages", "self.checker.visit_subscript", "MessageTest"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 176, "end_line": 200}, "code_snippet": "    def decorated_by_an_unsubscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=17,\n                col_offset=7,\n                end_line=17,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n", "type": "function"}, {"name": "decorated_by_a_subscriptable_class", "is_method": true, "class_name": "TestTypeCheckerOnDecorators", "parameters": ["self", "decorators"], "calls": ["astroid.parse", "self.assertNoMessages", "self.checker.visit_subscript"], "code_location": {"file": "unittest_typecheck.py", "path": "/data3/pwh/swebench-repos/pylint/tests/checkers", "start_line": 114, "end_line": 127}, "code_snippet": "    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.49047350883483887}
