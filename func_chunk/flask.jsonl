{"question": "What is the interaction between the parametrization of import and app name arguments in the exception-raising test and the exception handling semantics that ensures the application location function fails consistently?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_locate_app_suppress_raise", "is_method": false, "class_name": null, "parameters": ["test_apps"], "calls": ["locate_app", "pytest.raises", "locate_app"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 222, "end_line": 228}, "code_snippet": "def test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)\n", "type": "function"}, {"name": "test_locate_app_raises", "is_method": false, "class_name": null, "parameters": ["test_apps", "iname", "aname"], "calls": ["pytest.mark.parametrize", "pytest.raises", "locate_app"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 217, "end_line": 219}, "code_snippet": "def test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)\n", "type": "function"}, {"name": "test_locate_app", "is_method": false, "class_name": null, "parameters": ["test_apps", "iname", "aname", "result"], "calls": ["pytest.mark.parametrize", "locate_app"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 195, "end_line": 196}, "code_snippet": "def test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result\n", "type": "function"}, {"name": "locate_app", "is_method": false, "class_name": null, "parameters": ["module_name", "app_name", "raise_if_not_found"], "calls": ["__import__", "find_best_app", "find_app_by_string", "NoAppException", "sys.exc_info", "NoAppException", "traceback.format_exc"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 241, "end_line": 264}, "code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)\n", "type": "function"}, {"name": "test_name_with_import_error", "is_method": true, "class_name": "TestNoImports", "parameters": ["self", "modules_tmp_path"], "calls": ["write_text", "flask.Flask", "AssertionError"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 228, "end_line": 233}, "code_snippet": "    def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n", "type": "function"}, {"name": "test_apps", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.syspath_prepend", "set", "os.path.join", "sys.modules.keys", "sys.modules.keys", "sys.modules.pop", "os.path.dirname"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 72, "end_line": 81}, "code_snippet": "def test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for key in sys.modules.keys() - original_modules:\n        sys.modules.pop(key)\n", "type": "function"}, {"name": "locate_app", "is_method": false, "class_name": null, "parameters": ["module_name", "app_name", "raise_if_not_found"], "calls": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 236, "end_line": 238}, "code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...\n) -> Flask | None: ...\n", "type": "function"}, {"name": "locate_app", "is_method": false, "class_name": null, "parameters": ["module_name", "app_name", "raise_if_not_found"], "calls": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 230, "end_line": 232}, "code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True\n) -> Flask: ...\n", "type": "function"}, {"name": "test_exception_propagation", "is_method": false, "class_name": null, "parameters": ["app", "client", "key"], "calls": ["pytest.mark.parametrize", "app.route", "pytest.raises", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1582, "end_line": 1595}, "code_snippet": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500\n", "type": "function"}, {"name": "test_find_best_app", "is_method": false, "class_name": null, "parameters": ["test_apps"], "calls": ["find_best_app", "isinstance", "find_best_app", "isinstance", "find_best_app", "isinstance", "pytest.raises", "pytest.raises", "pytest.raises", "pytest.raises", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "TypeError"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 48, "end_line": 132}, "code_snippet": "def test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.012016773223877}
{"question": "What is the modular component registration architecture that separates static asset serving from the main application framework while preserving consistent caching behavior across both components?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_templates_and_static", "is_method": false, "class_name": null, "parameters": ["test_apps"], "calls": ["app.test_client", "client.get", "client.get", "client.get", "client.get", "rv.close", "client.get", "rv.close", "rv.data.strip", "rv.data.strip", "client.get", "parse_cache_control_header", "rv.close", "app.test_request_context", "app.test_request_context", "test_request_context", "flask.url_for", "pytest.raises", "flask.render_template", "flask.render_template", "flask.Flask"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 176, "end_line": 220}, "code_snippet": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"\n", "type": "function"}, {"name": "test_default_static_max_age", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["MyBlueprint", "app.register_blueprint", "app.test_request_context", "blueprint.send_static_file", "parse_cache_control_header", "rv.close"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 223, "end_line": 244}, "code_snippet": "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n", "type": "function"}, {"name": "test_static_route_with_host_matching", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "c.get", "rv.close", "flask.Flask", "app.test_request_context", "flask.url_for", "pytest.raises", "flask.Flask", "pytest.raises", "flask.Flask"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1468, "end_line": 1486}, "code_snippet": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n", "type": "function"}, {"name": "Scaffold", "docstring": "Common behavior shared between :class:`~flask.Flask` and\n:class:`~flask.blueprints.Blueprint`.\n\n:param import_name: The import name of the module where this object\n    is defined. Usually :attr:`__name__` should be used.\n:param static_folder: Path to a folder of static files to serve.\n    If this is set, a static route will be added.\n:param static_url_path: URL prefix for the static route.\n:param template_folder: Path to a folder containing template files.\n    for rendering. If this is set, a Jinja loader will be added.\n:param root_path: The path that static, template, and resource files\n    are relative to. Typically not set, it is discovered based on\n    the ``import_name``.\n\n.. versionadded:: 2.0", "methods": ["__init__", "__repr__", "_check_setup_finished", "static_folder", "static_folder", "has_static_folder", "static_url_path", "static_url_path", "jinja_loader", "_method_route", "get", "post", "put", "delete", "patch", "route", "add_url_rule", "endpoint", "before_request", "after_request", "teardown_request", "context_processor", "url_value_preprocessor", "url_defaults", "errorhandler", "register_error_handler", "_get_exc_class_and_code"], "attributes": [], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 52, "end_line": 698}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Flask", "parameters": ["self", "import_name", "static_url_path", "static_folder", "static_host", "host_matching", "subdomain_matching", "template_folder", "instance_path", "instance_relative_config", "root_path"], "calls": ["__init__", "cli.AppGroup", "weakref.ref", "self.add_url_rule", "super", "bool", "send_static_file", "self_ref"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 226, "end_line": 279}, "code_snippet": "    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_folder=static_folder,\n            static_host=static_host,\n            host_matching=host_matching,\n            subdomain_matching=subdomain_matching,\n            template_folder=template_folder,\n            instance_path=instance_path,\n            instance_relative_config=instance_relative_config,\n            root_path=root_path,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = cli.AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, (\n                \"Invalid static_host/host_matching combination\"\n            )\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n", "type": "function"}, {"name": "test_static_folder_with_ending_slash", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.route", "get", "app.test_client"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1457, "end_line": 1465}, "code_snippet": "def test_static_folder_with_ending_slash():\n    app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\"\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "name", "import_name", "static_folder", "static_url_path", "template_folder", "url_prefix", "subdomain", "url_defaults", "root_path", "cli_group"], "calls": ["__init__", "ValueError", "ValueError", "super"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 174, "end_line": 211}, "code_snippet": "    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n", "type": "function"}, {"name": "test_static_url_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "get", "rv.close", "app.test_request_context", "app.test_client", "flask.url_for"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1412, "end_line": 1420}, "code_snippet": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\n", "type": "function"}, {"name": "test_static_file", "is_method": true, "class_name": "TestSendfile", "parameters": ["self", "app", "req_ctx"], "calls": ["app.send_static_file", "rv.close", "flask.send_file", "rv.close", "app.send_static_file", "rv.close", "flask.send_file", "rv.close", "app.send_static_file", "rv.close", "StaticFileApp", "FakePath", "app.test_request_context", "app.send_static_file", "rv.close", "flask.send_file", "rv.close"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 45, "end_line": 90}, "code_snippet": "    def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n", "type": "function"}, {"name": "test_static_url_empty_path", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Flask", "open", "rv.close", "app.test_client"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1434, "end_line": 1438}, "code_snippet": "def test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0422077178955078}
{"question": "How does the certificate parameter conversion method for the CLI certificate option implement a fallback chain to handle file paths, adhoc certificate strings, and SSLContext object imports?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "convert", "is_method": true, "class_name": "CertParamType", "parameters": ["self", "value", "param", "ctx"], "calls": ["self.path_type", "click.BadParameter", "lower", "import_string", "isinstance", "click.STRING", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 791, "end_line": 825}, "code_snippet": "    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n", "type": "function"}, {"name": "CertParamType", "docstring": "Click option type for the ``--cert`` option. Allows either an\nexisting file, the string ``'adhoc'``, or an import for a\n:class:`~ssl.SSLContext` object.", "methods": ["__init__", "convert"], "attributes": ["name"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 780, "end_line": 825}, "type": "class"}, {"name": "test_run_cert_import", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "ssl.SSLContext", "monkeypatch.setitem", "run_command.make_context", "pytest.raises", "run_command.make_context", "pytest.raises", "run_command.make_context", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 619, "end_line": 638}, "code_snippet": "def test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])\n", "type": "function"}, {"name": "test_run_cert_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["run_command.make_context", "run_command.make_context", "pytest.raises", "run_command.make_context", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 584, "end_line": 599}, "code_snippet": "def test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n", "type": "function"}, {"name": "test_run_cert_adhoc", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "monkeypatch.setitem", "run_command.make_context", "pytest.raises", "run_command.make_context", "types.ModuleType", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 602, "end_line": 616}, "code_snippet": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\n", "type": "function"}, {"name": "test_run_cert_no_ssl", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 641, "end_line": 645}, "code_snippet": "def test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n", "type": "function"}, {"name": "_validate_key", "is_method": false, "class_name": null, "parameters": ["ctx", "param", "value"], "calls": ["ctx.params.get", "isinstance", "click.BadParameter", "click.BadParameter", "click.BadParameter", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 828, "end_line": 864}, "code_snippet": "def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key\" is not used.',\n                ctx,\n                param,\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value\n", "type": "function"}, {"name": "convert", "is_method": true, "class_name": "SeparatedPathType", "parameters": ["self", "value", "param", "ctx"], "calls": ["self.split_envvar_value", "super", "super_convert"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 873, "end_line": 879}, "code_snippet": "    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        items = self.split_envvar_value(value)\n        # can't call no-arg super() inside list comprehension until Python 3.12\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]\n", "type": "function"}, {"name": "_env_file_callback", "is_method": false, "class_name": null, "parameters": ["ctx", "param", "value"], "calls": ["load_dotenv", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 493, "end_line": 512}, "code_snippet": "def _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        # Only show an error if a value was passed, otherwise we still want to\n        # call load_dotenv and show a message without exiting.\n        if value is not None:\n            raise click.BadParameter(\n                \"python-dotenv must be installed to load an env file.\",\n                ctx=ctx,\n                param=param,\n            ) from None\n\n    # Load if a value was passed, or we want to load default files, or both.\n    if value is not None or ctx.obj.load_dotenv_defaults:\n        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\n\n    return value\n", "type": "function"}, {"name": "_set_app", "is_method": false, "class_name": null, "parameters": ["ctx", "param", "value"], "calls": ["ctx.ensure_object"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 440, "end_line": 446}, "code_snippet": "def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.036531925201416}
{"question": "What is the dependency chain in the test function that verifies subdomain routing through configuration, route registration, and request context creation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_proper_test_request_context", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.config.update", "app.route", "app.route", "app.config.update", "app.config.update", "app.test_request_context", "app.test_request_context", "warnings.catch_warnings", "warnings.filterwarnings", "app.test_request_context", "app.test_request_context", "flask.url_for", "flask.url_for", "app.test_request_context"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 63, "end_line": 104}, "code_snippet": "def test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n", "type": "function"}, {"name": "test_subdomain", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "app.route", "app.test_request_context", "flask.url_for", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 302, "end_line": 318}, "code_snippet": "def test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n", "type": "function"}, {"name": "test_subdomain", "is_method": true, "class_name": "TestRoutes", "parameters": ["self", "runner"], "calls": ["Flask", "app.add_url_rule", "app.add_url_rule", "FlaskGroup", "runner.invoke"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 502, "end_line": 509}, "code_snippet": "    def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output\n", "type": "function"}, {"name": "test_subdomain_matching", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "app.route", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1774, "end_line": 1784}, "code_snippet": "def test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"\n", "type": "function"}, {"name": "test_child_and_parent_subdomain", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "child.route", "parent.register_blueprint", "app.register_blueprint", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 972, "end_line": 991}, "code_snippet": "def test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n", "type": "function"}, {"name": "test_nesting_subdomains", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "child.route", "parent.register_blueprint", "app.register_blueprint", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 953, "end_line": 969}, "code_snippet": "def test_nesting_subdomains(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200\n", "type": "function"}, {"name": "test_blueprint_with_subdomain", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "flask.Blueprint", "bp.route", "app.register_blueprint", "app.test_request_context", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 117, "end_line": 138}, "code_snippet": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"\n", "type": "function"}, {"name": "test_subdomain_basic_support", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "app.route", "app.route", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1754, "end_line": 1771}, "code_snippet": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"\n", "type": "function"}, {"name": "test_nosubdomain", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.test_request_context", "flask.url_for", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 321, "end_line": 335}, "code_snippet": "def test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n", "type": "function"}, {"name": "test_server_name_matching", "is_method": false, "class_name": null, "parameters": ["subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"], "calls": ["pytest.mark.parametrize", "flask.Flask", "app.route", "app.route", "app.test_client", "client.get", "client.get", "client.get", "pytest.warns", "nullcontext"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1502, "end_line": 1533}, "code_snippet": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0560431480407715}
{"question": "What hidden coupling exists between the decorator's state management and response lifecycle that causes issues with nested or conditional registration?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_nested_callback_order", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "child.route", "child.route", "parent.register_blueprint", "app.register_blueprint", "append", "append", "dict", "append", "append", "dict", "append", "append", "dict", "join", "flask.render_template_string", "flask.g.seen.pop", "flask.g.seen.pop", "flask.g.seen.pop", "flask.g.seen.pop", "flask.g.seen.pop", "flask.g.seen.pop", "client.get", "client.get", "flask.g.setdefault", "flask.g.setdefault", "flask.g.setdefault", "flask.g.setdefault", "flask.g.setdefault", "flask.g.setdefault"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 842, "end_line": 919}, "code_snippet": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"\n", "type": "function"}, {"name": "test_view_decorators", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "client.get", "flask.make_response", "Index.as_view", "f"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 80, "end_line": 98}, "code_snippet": "def test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"\n", "type": "function"}, {"name": "test_self_registration", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "pytest.raises", "bp.register_blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1011, "end_line": 1014}, "code_snippet": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n", "type": "function"}, {"name": "test_streaming_with_context_as_decorator", "is_method": true, "class_name": "TestStreaming", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "flask.Response", "generate"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 250, "end_line": 262}, "code_snippet": "    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n", "type": "function"}, {"name": "stream_with_context", "is_method": false, "class_name": null, "parameters": ["generator_or_function"], "calls": ["generator", "next", "iter", "_cv_request.get", "update_wrapper", "RuntimeError", "generator_or_function", "stream_with_context", "hasattr", "gen.close"], "code_location": {"file": "helpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 62, "end_line": 136}, "code_snippet": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to encounter\n    memory leaks with badly written WSGI middlewares.  The downside is that if\n    you are using streamed responses, the generator cannot access request bound\n    information any more.\n\n    This function however can help you keep the context around for longer::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(generate())\n\n    Alternatively it can also be used around a specific generator::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]\n", "type": "function"}, {"name": "test_endpoint_decorator", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.url_map.add", "app.endpoint", "app.endpoint", "Submount", "client.get", "client.get", "Rule", "Rule"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 214, "end_line": 231}, "code_snippet": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n", "type": "function"}, {"name": "test_endpoint_decorator", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.url_map.add", "flask.Blueprint", "bp.endpoint", "app.register_blueprint", "Rule", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 345, "end_line": 359}, "code_snippet": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n", "type": "function"}, {"name": "test_nesting_url_prefixes", "is_method": false, "class_name": null, "parameters": ["parent_init", "child_init", "parent_registration", "child_registration", "app", "client"], "calls": ["pytest.mark.parametrize", "flask.Blueprint", "flask.Blueprint", "child.route", "parent.register_blueprint", "app.register_blueprint", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 931, "end_line": 950}, "code_snippet": "def test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200\n", "type": "function"}, {"name": "_check_setup_finished", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f_name"], "calls": ["AssertionError"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 213, "end_line": 221}, "code_snippet": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n", "type": "function"}, {"name": "test_after_request_processing", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 740, "end_line": 752}, "code_snippet": "def test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0465352535247803}
{"question": "What is the relationship between the ASCII-only encoding control parameter in the framework's JSON serialization provider and Unicode character representation in serialized output?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_json_as_unicode", "is_method": false, "class_name": null, "parameters": ["test_value", "expected", "app", "app_ctx"], "calls": ["pytest.mark.parametrize", "app.json.dumps"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 51, "end_line": 54}, "code_snippet": "def test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected\n", "type": "function"}, {"name": "test_environbuilder_json_dumps", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["EnvironBuilder", "decode", "eb.input_stream.read"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 110, "end_line": 114}, "code_snippet": "def test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'\n", "type": "function"}, {"name": "test_json_customization", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["CustomProvider", "app.route", "client.post", "isinstance", "DefaultJSONProvider.default", "flask.json.dumps", "kwargs.setdefault", "loads", "flask.json.dumps", "X", "flask.request.get_json", "len", "super"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 223, "end_line": 257}, "code_snippet": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'\n", "type": "function"}, {"name": "DefaultJSONProvider", "docstring": "Provide JSON operations using Python's built-in :mod:`json`\nlibrary. Serializes the following additional data types:\n\n-   :class:`datetime.datetime` and :class:`datetime.date` are\n    serialized to :rfc:`822` strings. This is the same as the HTTP\n    date format.\n-   :class:`uuid.UUID` is serialized to a string.\n-   :class:`dataclasses.dataclass` is passed to\n    :func:`dataclasses.asdict`.\n-   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n    method) will call the ``__html__`` method to get a string.", "methods": ["dumps", "loads", "response"], "attributes": ["ensure_ascii", "sort_keys", "mimetype"], "code_location": {"file": "provider.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 124, "end_line": 215}, "type": "class"}, {"name": "JSONProvider", "docstring": "A standard set of JSON operations for an application. Subclasses\nof this can be used to customize JSON behavior or use different\nJSON libraries.\n\nTo implement a provider for a specific library, subclass this base\nclass and implement at least :meth:`dumps` and :meth:`loads`. All\nother methods have default implementations.\n\nTo use a different provider, either subclass ``Flask`` and set\n:attr:`~flask.Flask.json_provider_class` to a provider class, or set\n:attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n:param app: An application instance. This will be stored as a\n    :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n.. versionadded:: 2.2", "methods": ["__init__", "dumps", "dump", "loads", "load", "_prepare_response_obj", "response"], "attributes": [], "code_location": {"file": "provider.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 19, "end_line": 105}, "type": "class"}, {"name": "test_jsonify_no_prettyprint", "is_method": false, "class_name": null, "parameters": ["app", "compact"], "calls": ["pytest.mark.parametrize", "app.json.response", "rv.data.strip"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1309, "end_line": 1314}, "code_snippet": "def test_jsonify_no_prettyprint(app, compact):\n    app.json.compact = compact\n    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n    data = rv.data.strip()\n    assert (b\" \" not in data) is compact\n    assert (b\"\\n\" not in data) is compact\n", "type": "function"}, {"name": "test_html_method", "is_method": false, "class_name": null, "parameters": [], "calls": ["json.dumps", "ObjectWithHTML"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 340, "end_line": 346}, "code_snippet": "def test_html_method():\n    class ObjectWithHTML:\n        def __html__(self):\n            return \"<p>test</p>\"\n\n    result = json.dumps(ObjectWithHTML())\n    assert result == '\"<p>test</p>\"'\n", "type": "function"}, {"name": "dumps", "is_method": false, "class_name": null, "parameters": ["obj"], "calls": ["kwargs.setdefault", "_json.dumps", "current_app.json.dumps"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 13, "end_line": 44}, "code_snippet": "def dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)\n", "type": "function"}, {"name": "test_nonascii_pathinfo", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1669, "end_line": 1675}, "code_snippet": "def test_nonascii_pathinfo(app, client):\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello World!\"\n", "type": "function"}, {"name": "test_json_key_sorting", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["dict.fromkeys", "app.route", "client.get", "range", "flask.jsonify", "x.strip", "splitlines", "decode", "rv.data.strip"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 270, "end_line": 337}, "code_snippet": "def test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0725531578063965}
{"question": "What is the purpose of the registration tracking flag in the blueprint collection class that prevents setup methods from being called after the blueprint has been registered once?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_check_setup_finished", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f_name"], "calls": ["AssertionError"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 213, "end_line": 221}, "code_snippet": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n", "type": "function"}, {"name": "BlueprintSetupState", "docstring": "Temporary holder object for registering a blueprint with the\napplication.  An instance of this class is created by the\n:meth:`~flask.Blueprint.make_setup_state` method and later passed\nto all register callback functions.", "methods": ["__init__", "add_url_rule"], "attributes": [], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 34, "end_line": 116}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "BlueprintSetupState", "parameters": ["self", "blueprint", "app", "options", "first_registration"], "calls": ["self.options.get", "self.options.get", "self.options.get", "self.options.get", "dict", "self.url_defaults.update", "self.options.get"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 41, "end_line": 85}, "code_snippet": "    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n", "type": "function"}, {"name": "make_setup_state", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "app", "options", "first_registration"], "calls": ["BlueprintSetupState"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 246, "end_line": 253}, "code_snippet": "    def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n", "type": "function"}, {"name": "register", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "app", "options"], "calls": ["options.get", "options.get", "lstrip", "self.make_setup_state", "options.get", "ValueError", "any", "state.add_url_rule", "self._merge_blueprint_funcs", "deferred", "bp_options.copy", "bp_options.get", "bp_options.get", "blueprint.register", "app.cli.commands.update", "app.cli.add_command", "app.cli.add_command", "bp_url_prefix.lstrip", "app.blueprints.values", "state.url_prefix.rstrip"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 273, "end_line": 377}, "code_snippet": "    def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n            self._merge_blueprint_funcs(app, name)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)\n", "type": "function"}, {"name": "record_once", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "func"], "calls": ["self.record", "update_wrapper", "func"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 233, "end_line": 244}, "code_snippet": "    def record_once(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))\n", "type": "function"}, {"name": "record", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "func"], "calls": ["self.deferred_functions.append"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 224, "end_line": 230}, "code_snippet": "    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)\n", "type": "function"}, {"name": "test_self_registration", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "pytest.raises", "bp.register_blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1011, "end_line": 1014}, "code_snippet": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n", "type": "function"}, {"name": "_check_setup_finished", "is_method": true, "class_name": "App", "parameters": ["self", "f_name"], "calls": ["AssertionError"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 413, "end_line": 423}, "code_snippet": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n", "type": "function"}, {"name": "iter_blueprints", "is_method": true, "class_name": "App", "parameters": ["self"], "calls": ["self.blueprints.values"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 597, "end_line": 602}, "code_snippet": "    def iter_blueprints(self) -> t.ValuesView[Blueprint]:\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.blueprints.values()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1013731956481934}
{"question": "What does the method that enables the test helper class representing pathlib.Path objects return when invoked by the standard library path conversion function?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "FakePath", "docstring": "Fake object to represent a ``PathLike object``.\n\nThis represents a ``pathlib.Path`` object in python 3.\nSee: https://www.python.org/dev/peps/pep-0519/", "methods": ["__init__", "__fspath__"], "attributes": [], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 11, "end_line": 22}, "type": "class"}, {"name": "__fspath__", "is_method": true, "class_name": "FakePath", "parameters": ["self"], "calls": [], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 21, "end_line": 22}, "code_snippet": "    def __fspath__(self):\n        return self.path\n", "type": "function"}, {"name": "modules_tmp_path_prefix", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "monkeypatch"], "calls": ["monkeypatch.setattr", "os.fspath"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 108, "end_line": 110}, "code_snippet": "def modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\n    monkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\n    return modules_tmp_path\n", "type": "function"}, {"name": "convert", "is_method": true, "class_name": "CertParamType", "parameters": ["self", "value", "param", "ctx"], "calls": ["self.path_type", "click.BadParameter", "lower", "import_string", "isinstance", "click.STRING", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 791, "end_line": 825}, "code_snippet": "    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n", "type": "function"}, {"name": "test_static_folder_with_pathlib_path", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Flask", "open", "rv.close", "Path", "app.test_client"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1448, "end_line": 1454}, "code_snippet": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "type": "function"}, {"name": "SeparatedPathType", "docstring": "Click option type that accepts a list of values separated by the\nOS's path separator (``:``, ``;`` on Windows). Each value is\nvalidated as a :class:`click.Path` type.", "methods": ["convert"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 867, "end_line": 879}, "type": "class"}, {"name": "test_installed_module_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "modules_tmp_path_prefix", "purge_module", "site_packages"], "calls": ["write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 65, "end_line": 77}, "code_snippet": "def test_installed_module_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    (site_packages / \"site_app.py\").write_text(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_app-instance\"\n    )\n", "type": "function"}, {"name": "modules_tmp_path", "is_method": false, "class_name": null, "parameters": ["tmp_path", "monkeypatch"], "calls": ["rv.mkdir", "monkeypatch.syspath_prepend", "os.fspath"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 99, "end_line": 104}, "code_snippet": "def modules_tmp_path(tmp_path, monkeypatch):\n    \"\"\"A temporary directory added to sys.path.\"\"\"\n    rv = tmp_path / \"modules_tmp\"\n    rv.mkdir()\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv\n", "type": "function"}, {"name": "test_prefix_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "modules_tmp_path_prefix", "purge_module", "site_packages"], "calls": ["app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 99, "end_line": 111}, "code_snippet": "def test_prefix_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )\n", "type": "function"}, {"name": "test_installed_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "modules_tmp_path_prefix", "purge_module", "monkeypatch"], "calls": ["installed_path.mkdir", "monkeypatch.syspath_prepend", "app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 80, "end_line": 96}, "code_snippet": "def test_installed_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0966804027557373}
{"question": "What architectural decisions are reflected by the dual inheritance from both AssertionError and UnicodeError in the debug-mode exception class for unexpected unicode or binary data regarding separation between validation failures and encoding issues in Flask's layered architecture?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "UnexpectedUnicodeError", "docstring": "Raised in places where we want some better error reporting for\nunexpected unicode or binary data.", "methods": [], "attributes": [], "code_location": {"file": "debughelpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 17, "end_line": 20}, "type": "class"}, {"name": "test_enctype_debug_helper", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "pytest.raises", "client.post", "str", "str"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1107, "end_line": 1119}, "code_snippet": "def test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)\n", "type": "function"}, {"name": "test_bad_request_debug_message", "is_method": false, "class_name": null, "parameters": ["app", "client", "debug"], "calls": ["pytest.mark.parametrize", "app.route", "client.post", "flask.request.get_json"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 15, "end_line": 27}, "code_snippet": "def test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug\n", "type": "function"}, {"name": "DebugFilesKeyError", "docstring": "Raised from request.files during debugging.  The idea is that it can\nprovide a better error message than just a generic KeyError/BadRequest.", "methods": ["__init__", "__str__"], "attributes": [], "code_location": {"file": "debughelpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 23, "end_line": 47}, "type": "class"}, {"name": "test_response_type_errors", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.route", "app.route", "app.route", "app.route", "app.route", "app.test_client", "pytest.raises", "c.get", "str", "str", "pytest.raises", "c.get", "str", "pytest.raises", "c.get", "pytest.raises", "c.get", "str", "pytest.raises", "c.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1216, "end_line": 1262}, "code_snippet": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")\n", "type": "function"}, {"name": "test_bad_environ_raises_bad_request", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "EnvironBuilder", "builder.get_environ", "app.request_context", "app.full_dispatch_request"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 280, "end_line": 293}, "code_snippet": "def test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n    assert response.status_code == 400\n", "type": "function"}, {"name": "test_json_as_unicode", "is_method": false, "class_name": null, "parameters": ["test_value", "expected", "app", "app_ctx"], "calls": ["pytest.mark.parametrize", "app.json.dumps"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 51, "end_line": 54}, "code_snippet": "def test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected\n", "type": "function"}, {"name": "test_json_bad_requests", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.post", "flask.jsonify", "str", "flask.request.get_json"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 30, "end_line": 36}, "code_snippet": "def test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400\n", "type": "function"}, {"name": "test_session_error_pops_context", "is_method": false, "class_name": null, "parameters": [], "calls": ["CustomFlask", "app.route", "get", "FailingSessionInterface", "AssertionError", "SessionError", "app.test_client"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 205, "end_line": 226}, "code_snippet": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n", "type": "function"}, {"name": "test_werkzeug_passthrough_errors", "is_method": false, "class_name": null, "parameters": ["monkeypatch", "debug", "use_debugger", "use_reloader", "propagate_exceptions", "app"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "monkeypatch.setattr", "app.run", "kwargs.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1602, "end_line": 1613}, "code_snippet": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.103534460067749}
{"question": "How does the decorator that copies request contexts handle isolation of lightweight concurrent execution contexts while preserving session data across execution boundaries?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "copy_current_request_context", "is_method": false, "class_name": null, "parameters": ["f"], "calls": ["_cv_request.get", "ctx.copy", "update_wrapper", "RuntimeError", "ctx.app.ensure_sync"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 155, "end_line": 193}, "code_snippet": "def copy_current_request_context(f: F) -> F:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]\n", "type": "function"}, {"name": "copy", "is_method": true, "class_name": "RequestContext", "parameters": ["self"], "calls": ["self.__class__"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 337, "end_line": 355}, "code_snippet": "    def copy(self) -> RequestContext:\n        \"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n\n        .. versionchanged:: 1.1\n           The current session object is used instead of reloading the original\n           data. This prevents `flask.session` pointing to an out-of-date object.\n        \"\"\"\n        return self.__class__(\n            self.app,\n            environ=self.request.environ,\n            request=self.request,\n            session=self.session,\n        )\n", "type": "function"}, {"name": "test_greenlet_context_copying_api", "is_method": true, "class_name": "TestGreenletContextCopying", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "run", "greenlets.append", "greenlet", "flask.session.get"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 179, "end_line": 202}, "code_snippet": "    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "type": "function"}, {"name": "test_greenlet_context_copying", "is_method": true, "class_name": "TestGreenletContextCopying", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "run", "request_ctx.copy", "greenlets.append", "greenlet", "flask.session.get"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 150, "end_line": 177}, "code_snippet": "    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "type": "function"}, {"name": "test_session_transactions_keep_context", "is_method": false, "class_name": null, "parameters": ["app", "client", "req_ctx"], "calls": ["client.get", "flask.request._get_current_object", "client.session_transaction", "flask.request._get_current_object"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 196, "end_line": 201}, "code_snippet": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n", "type": "function"}, {"name": "_copy_environ", "is_method": true, "class_name": "FlaskClient", "parameters": ["self", "other"], "calls": [], "code_location": {"file": "testing.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 185, "end_line": 191}, "code_snippet": "    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out\n", "type": "function"}, {"name": "_default_template_ctx_processor", "is_method": false, "class_name": null, "parameters": [], "calls": ["_cv_app.get", "_cv_request.get"], "code_location": {"file": "templating.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 24, "end_line": 36}, "code_snippet": "def _default_template_ctx_processor() -> dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    appctx = _cv_app.get(None)\n    reqctx = _cv_request.get(None)\n    rv: dict[str, t.Any] = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv\n", "type": "function"}, {"name": "stream_with_context", "is_method": false, "class_name": null, "parameters": ["generator_or_function"], "calls": ["generator", "next", "iter", "_cv_request.get", "update_wrapper", "RuntimeError", "generator_or_function", "stream_with_context", "hasattr", "gen.close"], "code_location": {"file": "helpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 62, "end_line": 136}, "code_snippet": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to encounter\n    memory leaks with badly written WSGI middlewares.  The downside is that if\n    you are using streamed responses, the generator cannot access request bound\n    information any more.\n\n    This function however can help you keep the context around for longer::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(generate())\n\n    Alternatively it can also be used around a specific generator::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]\n", "type": "function"}, {"name": "TestGreenletContextCopying", "docstring": "", "methods": ["test_greenlet_context_copying", "test_greenlet_context_copying_api"], "attributes": [], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 149, "end_line": 202}, "type": "class"}, {"name": "test_context_available", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.get", "client.get"], "code_location": {"file": "test_converters.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 29, "end_line": 42}, "code_snippet": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0955123901367188}
{"question": "How does the deferred registration mechanism ensure that custom template filters registered through the blueprint's application-level filter registration method are accessible in the template rendering environment when the blueprint is mounted with a URL path prefix?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_template_filter_after_route_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 431, "end_line": 444}, "code_snippet": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_template_filter", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 362, "end_line": 372}, "code_snippet": "def test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_name", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 388, "end_line": 398}, "code_snippet": "def test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 414, "end_line": 428}, "code_snippet": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_name_and_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 464, "end_line": 478}, "code_snippet": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 375, "end_line": 385}, "code_snippet": "def test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_name", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 401, "end_line": 411}, "code_snippet": "def test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 447, "end_line": 461}, "code_snippet": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_name_and_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 481, "end_line": 495}, "code_snippet": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "add_app_template_filter", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f", "name"], "calls": ["self.record_once"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 461, "end_line": 475}, "code_snippet": "    def add_app_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Works like the :meth:`app_template_filter` decorator. Equivalent to\n        :meth:`.Flask.add_template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.filters[name or f.__name__] = f\n\n        self.record_once(register_template)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0964300632476807}
{"question": "What is the dependency chain between the application loading helper, the Flask application instance, and the base Click testing runner that ensures proper CLI command execution in isolation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_app_cli_has_app_context", "is_method": false, "class_name": null, "parameters": ["app", "runner"], "calls": ["app.cli.command", "click.argument", "FlaskGroup", "runner.invoke", "bool", "obj.load_app", "current_app._get_current_object", "click.get_current_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 289, "end_line": 304}, "code_snippet": "def test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)\n", "type": "function"}, {"name": "runner", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.test_cli_runner"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/flask/examples/tutorial/tests", "start_line": 42, "end_line": 44}, "code_snippet": "def runner(app):\n    \"\"\"A test runner for the app's Click commands.\"\"\"\n    return app.test_cli_runner()\n", "type": "function"}, {"name": "FlaskCliRunner", "docstring": "A :class:`~click.testing.CliRunner` for testing a Flask app's\nCLI commands. Typically created using\n:meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.", "methods": ["__init__", "invoke"], "attributes": [], "code_location": {"file": "testing.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 265, "end_line": 298}, "type": "class"}, {"name": "invoke", "is_method": true, "class_name": "TestRoutes", "parameters": ["self", "app", "runner"], "calls": ["FlaskGroup", "partial"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 459, "end_line": 461}, "code_snippet": "    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n", "type": "function"}, {"name": "test_flaskgroup_app_context", "is_method": false, "class_name": null, "parameters": ["runner"], "calls": ["click.group", "cli.command", "runner.invoke", "Flask", "click.echo"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 348, "end_line": 362}, "code_snippet": "def test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"\n", "type": "function"}, {"name": "test_no_command_echo_loading_error", "is_method": false, "class_name": null, "parameters": [], "calls": ["runner.invoke", "CliRunner", "CliRunner"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 398, "end_line": 410}, "code_snippet": "def test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr\n", "type": "function"}, {"name": "invoke", "is_method": true, "class_name": "FlaskCliRunner", "parameters": ["self", "cli", "args"], "calls": ["invoke", "ScriptInfo", "super"], "code_location": {"file": "testing.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 275, "end_line": 298}, "code_snippet": "    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)\n", "type": "function"}, {"name": "test_help_echo_loading_error", "is_method": false, "class_name": null, "parameters": [], "calls": ["runner.invoke", "CliRunner", "CliRunner"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 413, "end_line": 425}, "code_snippet": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout\n", "type": "function"}, {"name": "make_context", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "info_name", "args", "parent"], "calls": ["make_context", "ScriptInfo", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 657, "end_line": 676}, "code_snippet": "    def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app,\n                set_debug_flag=self.set_debug_flag,\n                load_dotenv_defaults=self.load_dotenv,\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)\n", "type": "function"}, {"name": "test_with_appcontext", "is_method": false, "class_name": null, "parameters": ["runner"], "calls": ["click.command", "ScriptInfo", "runner.invoke", "click.echo", "Flask"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 307, "end_line": 317}, "code_snippet": "def test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1086726188659668}
{"question": "What is the dependency chain from recursive type tagging method calls within the tuple-to-JSON conversion method that could lead to infinite recursion when serializing nested tuples with circular references?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "to_json", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 77, "end_line": 80}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "TagTuple", "docstring": "", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 133, "end_line": 144}, "type": "class"}, {"name": "TaggedJSONSerializer", "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`", "methods": ["__init__", "register", "tag", "untag", "_untag_scan", "dumps", "loads"], "attributes": ["__slots__", "default_tags"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 219, "end_line": 327}, "type": "class"}, {"name": "tag", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": ["self.to_json"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 87, "end_line": 90}, "code_snippet": "    def tag(self, value: t.Any) -> dict[str, t.Any]:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassList", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 153, "end_line": 154}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagTuple", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 140, "end_line": 141}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "test_duplicate_tag", "is_method": false, "class_name": null, "parameters": [], "calls": ["TaggedJSONSerializer", "pytest.raises", "s.register", "isinstance", "isinstance"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 32, "end_line": 40}, "code_snippet": "def test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.115607500076294}
{"question": "What mechanisms ensure that template processing functions registered during modular component registration are accessible when templates are rendered using the shared template environment?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "context_processor", "is_method": true, "class_name": "Scaffold", "parameters": ["self", "f"], "calls": ["append"], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 542, "end_line": 556}, "code_snippet": "    def context_processor(\n        self,\n        f: T_template_context_processor,\n    ) -> T_template_context_processor:\n        \"\"\"Registers a template context processor function. These functions run before\n        rendering a template. The keys of the returned dict are added as variables\n        available in the template.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every rendered template. When used on a blueprint, this is called\n        for templates rendered from the blueprint's views. To register with a blueprint\n        and affect every template, use :meth:`.Blueprint.app_context_processor`.\n        \"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n", "type": "function"}, {"name": "test_context_processing", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_templating.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 11, "end_line": 21}, "code_snippet": "def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"\n", "type": "function"}, {"name": "app_context_processor", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f"], "calls": ["self.record_once", "append", "s.app.template_context_processors.setdefault"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 584, "end_line": 593}, "code_snippet": "    def app_context_processor(\n        self, f: T_template_context_processor\n    ) -> T_template_context_processor:\n        \"\"\"Like :meth:`context_processor`, but for templates rendered by every view, not\n        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f\n", "type": "function"}, {"name": "app_template_global", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "name"], "calls": ["self.add_app_template_global"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 516, "end_line": 532}, "code_snippet": "    def app_template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator\n", "type": "function"}, {"name": "Environment", "docstring": "Works like a regular Jinja2 environment but has some additional\nknowledge of how Flask's blueprint works so that it can prepend the\nname of the blueprint to referenced templates if necessary.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "templating.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 39, "end_line": 49}, "type": "class"}, {"name": "update_template_context", "is_method": true, "class_name": "Flask", "parameters": ["self", "context"], "calls": ["context.copy", "context.update", "chain", "reversed", "context.update", "self.ensure_sync"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 506, "end_line": 532}, "code_snippet": "    def update_template_context(self, context: dict[str, t.Any]) -> None:\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # A template may be rendered outside a request context.\n        if request:\n            names = chain(names, reversed(request.blueprints))\n\n        # The values passed to render_template take precedence. Keep a\n        # copy to re-apply after all context functions.\n        orig_ctx = context.copy()\n\n        for name in names:\n            if name in self.template_context_processors:\n                for func in self.template_context_processors[name]:\n                    context.update(self.ensure_sync(func)())\n\n        context.update(orig_ctx)\n", "type": "function"}, {"name": "add_app_template_global", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f", "name"], "calls": ["self.record_once"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 535, "end_line": 551}, "code_snippet": "    def add_app_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Works like the :meth:`app_template_global` decorator. Equivalent to\n        :meth:`.Flask.add_template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.globals[name or f.__name__] = f\n\n        self.record_once(register_template)\n", "type": "function"}, {"name": "test_template_filter_after_route_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 431, "end_line": 444}, "code_snippet": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "app_template_filter", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "name"], "calls": ["self.add_app_template_filter"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 444, "end_line": 458}, "code_snippet": "    def app_template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator\n", "type": "function"}, {"name": "test_context_processing", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "answer_bp.route", "app.route", "app.register_blueprint", "flask.render_template_string", "template_string", "template_string", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 634, "end_line": 672}, "code_snippet": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.146599292755127}
{"question": "How does the method that processes unhandled exceptions determine whether to re-raise them or convert them into HTTP 500 responses based on configuration state?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "handle_exception", "is_method": true, "class_name": "Flask", "parameters": ["self", "e"], "calls": ["sys.exc_info", "got_request_exception.send", "self.log_exception", "InternalServerError", "self._find_error_handler", "self.finalize_request", "self.ensure_sync"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 811, "end_line": 862}, "code_snippet": "    def handle_exception(self, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n        mode, the error will be re-raised so that the debugger can\n        display it. Otherwise, the original exception is logged, and\n        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\n        If an error handler is registered for ``InternalServerError`` or\n        ``500``, it will be used. For consistency, the handler will\n        always receive the ``InternalServerError``. The original\n        unhandled exception is available as ``e.original_exception``.\n\n        .. versionchanged:: 1.1.0\n            Always passes the ``InternalServerError`` instance to the\n            handler, setting ``original_exception`` to the unhandled\n            error.\n\n        .. versionchanged:: 1.1.0\n            ``after_request`` functions and other finalization is done\n            even for the default 500 response when there is no handler.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_info = sys.exc_info()\n        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\n        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n\n        if propagate is None:\n            propagate = self.testing or self.debug\n\n        if propagate:\n            # Re-raise if called with an active exception, otherwise\n            # raise the passed in exception.\n            if exc_info[1] is e:\n                raise\n\n            raise e\n\n        self.log_exception(exc_info)\n        server_error: InternalServerError | ft.ResponseReturnValue\n        server_error = InternalServerError(original_exception=e)\n        handler = self._find_error_handler(server_error, request.blueprints)\n\n        if handler is not None:\n            server_error = self.ensure_sync(handler)(server_error)\n\n        return self.finalize_request(server_error, from_error_handler=True)\n", "type": "function"}, {"name": "test_exception_propagation", "is_method": false, "class_name": null, "parameters": ["app", "client", "key"], "calls": ["pytest.mark.parametrize", "app.route", "pytest.raises", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1582, "end_line": 1595}, "code_snippet": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500\n", "type": "function"}, {"name": "trap_http_exception", "is_method": true, "class_name": "App", "parameters": ["self", "e"], "calls": ["isinstance", "isinstance"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 848, "end_line": 881}, "code_snippet": "    def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n", "type": "function"}, {"name": "test_trapping_of_all_http_exceptions", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "flask.abort", "pytest.raises", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1067, "end_line": 1075}, "code_snippet": "def test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")\n", "type": "function"}, {"name": "test_app_tearing_down_with_handled_exception_by_app_handler", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.errorhandler", "cleanup_stuff.append", "Exception", "flask.jsonify", "app.app_context", "client.get", "str"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 91, "end_line": 110}, "code_snippet": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]\n", "type": "function"}, {"name": "handle_http_exception", "is_method": true, "class_name": "Flask", "parameters": ["self", "e"], "calls": ["isinstance", "self._find_error_handler", "self.ensure_sync"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 744, "end_line": 777}, "code_snippet": "    def handle_http_exception(\n        self, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n", "type": "function"}, {"name": "test_teardown_request_handler_error", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.get", "called.append", "called.append", "len", "type", "TypeError", "type", "TypeError"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 791, "end_line": 826}, "code_snippet": "def test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        raise ZeroDivisionError\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2\n", "type": "function"}, {"name": "test_error_handler_after_processor_error", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.errorhandler", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1078, "end_line": 1104}, "code_snippet": "def test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n", "type": "function"}, {"name": "test_error_handling_processing", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.errorhandler", "app.route", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 905, "end_line": 923}, "code_snippet": "def test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n", "type": "function"}, {"name": "test_werkzeug_passthrough_errors", "is_method": false, "class_name": null, "parameters": ["monkeypatch", "debug", "use_debugger", "use_reloader", "propagate_exceptions", "app"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "monkeypatch.setattr", "app.run", "kwargs.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1602, "end_line": 1613}, "code_snippet": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1228294372558594}
{"question": "How does the method that registers URL rules on blueprint objects defer registration by storing an anonymous function in the deferred setup functions list instead of immediately calling the setup state's registration method?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "record", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "func"], "calls": ["self.deferred_functions.append"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 224, "end_line": 230}, "code_snippet": "    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)\n", "type": "function"}, {"name": "add_url_rule", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "rule", "endpoint", "view_func", "provide_automatic_options"], "calls": ["self.record", "ValueError", "hasattr", "ValueError", "s.add_url_rule"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 413, "end_line": 441}, "code_snippet": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )\n", "type": "function"}, {"name": "add_url_rule", "is_method": true, "class_name": "BlueprintSetupState", "parameters": ["self", "rule", "endpoint", "view_func"], "calls": ["options.setdefault", "self.app.add_url_rule", "_endpoint_from_view_func", "dict", "lstrip", "join", "options.pop", "self.url_prefix.rstrip", "rule.lstrip"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 87, "end_line": 116}, "code_snippet": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n", "type": "function"}, {"name": "BlueprintSetupState", "docstring": "Temporary holder object for registering a blueprint with the\napplication.  An instance of this class is created by the\n:meth:`~flask.Blueprint.make_setup_state` method and later passed\nto all register callback functions.", "methods": ["__init__", "add_url_rule"], "attributes": [], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 34, "end_line": 116}, "type": "class"}, {"name": "add_url_rule", "is_method": true, "class_name": "Scaffold", "parameters": ["self", "rule", "endpoint", "view_func", "provide_automatic_options"], "calls": [], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 368, "end_line": 433}, "code_snippet": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "register", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "app", "options"], "calls": ["options.get", "options.get", "lstrip", "self.make_setup_state", "options.get", "ValueError", "any", "state.add_url_rule", "self._merge_blueprint_funcs", "deferred", "bp_options.copy", "bp_options.get", "bp_options.get", "blueprint.register", "app.cli.commands.update", "app.cli.add_command", "app.cli.add_command", "bp_url_prefix.lstrip", "app.blueprints.values", "state.url_prefix.rstrip"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 273, "end_line": 377}, "code_snippet": "    def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n            self._merge_blueprint_funcs(app, name)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "BlueprintSetupState", "parameters": ["self", "blueprint", "app", "options", "first_registration"], "calls": ["self.options.get", "self.options.get", "self.options.get", "self.options.get", "dict", "self.url_defaults.update", "self.options.get"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 41, "end_line": 85}, "code_snippet": "    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n", "type": "function"}, {"name": "Blueprint", "docstring": "Represents a blueprint, a collection of routes and other\napp-related functions that can be registered on a real application\nlater.\n\nA blueprint is an object that allows defining application functions\nwithout requiring an application object ahead of time. It uses the\nsame decorators as :class:`~flask.Flask`, but defers the need for an\napplication by recording them for later registration.\n\nDecorating a function with a blueprint creates a deferred function\nthat is called with :class:`~flask.blueprints.BlueprintSetupState`\nwhen the blueprint is registered on an application.\n\nSee :doc:`/blueprints` for more information.\n\n:param name: The name of the blueprint. Will be prepended to each\n    endpoint name.\n:param import_name: The name of the blueprint package, usually\n    ``__name__``. This helps locate the ``root_path`` for the\n    blueprint.\n:param static_folder: A folder with static files that should be\n    served by the blueprint's static route. The path is relative to\n    the blueprint's root path. Blueprint static files are disabled\n    by default.\n:param static_url_path: The url to serve static files from.\n    Defaults to ``static_folder``. If the blueprint does not have\n    a ``url_prefix``, the app's static route will take precedence,\n    and the blueprint's static files won't be accessible.\n:param template_folder: A folder with templates that should be added\n    to the app's template search path. The path is relative to the\n    blueprint's root path. Blueprint templates are disabled by\n    default. Blueprint templates have a lower precedence than those\n    in the app's templates folder.\n:param url_prefix: A path to prepend to all of the blueprint's URLs,\n    to make them distinct from the rest of the app's routes.\n:param subdomain: A subdomain that blueprint routes will match on by\n    default.\n:param url_defaults: A dict of default values that blueprint routes\n    will receive by default.\n:param root_path: By default, the blueprint will automatically set\n    this based on ``import_name``. In certain situations this\n    automatic detection can fail, so the path can be specified\n    manually instead.\n\n.. versionchanged:: 1.1.0\n    Blueprints have a ``cli`` group to register nested CLI commands.\n    The ``cli_group`` parameter controls the name of the group under\n    the ``flask`` command.\n\n.. versionadded:: 0.7", "methods": [], "attributes": [], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 119, "end_line": 632}, "type": "class"}, {"name": "make_setup_state", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "app", "options", "first_registration"], "calls": ["BlueprintSetupState"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 246, "end_line": 253}, "code_snippet": "    def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n", "type": "function"}, {"name": "_check_setup_finished", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "f_name"], "calls": ["AssertionError"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 213, "end_line": 221}, "code_snippet": "    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1287298202514648}
{"question": "What is the architectural pattern of the test class that isolates request context lifecycle management from streaming response generation logic?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_streaming_with_context", "is_method": true, "class_name": "TestStreaming", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "flask.Response", "flask.stream_with_context", "generate"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 237, "end_line": 248}, "code_snippet": "    def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n", "type": "function"}, {"name": "test_streaming_with_context_as_decorator", "is_method": true, "class_name": "TestStreaming", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "flask.Response", "generate"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 250, "end_line": 262}, "code_snippet": "    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n", "type": "function"}, {"name": "test_streaming_with_context_and_custom_close", "is_method": true, "class_name": "TestStreaming", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "flask.Response", "called.append", "next", "flask.stream_with_context", "Wrapper", "generate"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 264, "end_line": 293}, "code_snippet": "    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n", "type": "function"}, {"name": "test_client_pop_all_preserved", "is_method": false, "class_name": null, "parameters": ["app", "req_ctx", "client"], "calls": ["app.route", "rv.close", "flask.stream_with_context", "client.get", "_cv_request.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 382, "end_line": 396}, "code_snippet": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx\n", "type": "function"}, {"name": "stream_with_context", "is_method": false, "class_name": null, "parameters": ["generator_or_function"], "calls": ["generator", "next", "iter", "_cv_request.get", "update_wrapper", "RuntimeError", "generator_or_function", "stream_with_context", "hasattr", "gen.close"], "code_location": {"file": "helpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 62, "end_line": 136}, "code_snippet": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to encounter\n    memory leaks with badly written WSGI middlewares.  The downside is that if\n    you are using streamed responses, the generator cannot access request bound\n    information any more.\n\n    This function however can help you keep the context around for longer::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(generate())\n\n    Alternatively it can also be used around a specific generator::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]\n", "type": "function"}, {"name": "test_stream_keeps_session", "is_method": true, "class_name": "TestStreaming", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "flask.Response", "gen"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 295, "end_line": 307}, "code_snippet": "    def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"\n", "type": "function"}, {"name": "test_context_test", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.test_request_context", "ctx.push", "flask.has_request_context", "flask.has_request_context", "ctx.pop"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 123, "end_line": 132}, "code_snippet": "def test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n", "type": "function"}, {"name": "req_ctx", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.test_request_context"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 61, "end_line": 63}, "code_snippet": "def req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n", "type": "function"}, {"name": "test_context_binding", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.route", "app.route", "app.test_request_context", "app.test_request_context", "index", "meh"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 107, "end_line": 120}, "code_snippet": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n", "type": "function"}, {"name": "TestStreaming", "docstring": "", "methods": ["test_streaming_with_context", "test_streaming_with_context_as_decorator", "test_streaming_with_context_and_custom_close", "test_stream_keeps_session"], "attributes": [], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 236, "end_line": 307}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1537425518035889}
{"question": "How does the callback-based modification tracking in the session class that inherits from CallbackDict ensure consistency between in-memory session state and persisted cookie data across concurrent requests?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_session_stored_last", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "repr", "flask.session.get", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 434, "end_line": 445}, "code_snippet": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"\n", "type": "function"}, {"name": "test_session_cookie_setting", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.route", "app.route", "run_test", "run_test", "run_test", "run_test", "str", "str", "flask.session.get", "flask.session.get", "app.test_client", "c.get", "rv.headers.get", "c.get", "c.get", "c.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 479, "end_line": 517}, "code_snippet": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n", "type": "function"}, {"name": "SecureCookieSession", "docstring": "Base class for sessions based on signed cookies.\n\nThis session backend will set the :attr:`modified` and\n:attr:`accessed` attributes. It cannot reliably track whether a\nsession is new (vs. empty), so :attr:`new` remains hard coded to\n``False``.", "methods": ["__init__", "__getitem__", "get", "setdefault"], "attributes": ["modified", "accessed"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 52, "end_line": 94}, "type": "class"}, {"name": "test_session", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "flask.session.get", "client.post", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 234, "end_line": 254}, "code_snippet": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"\n", "type": "function"}, {"name": "should_set_cookie", "is_method": true, "class_name": "SessionInterface", "parameters": ["self", "app", "session"], "calls": [], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 247, "end_line": 261}, "code_snippet": "    def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n", "type": "function"}, {"name": "save_session", "is_method": true, "class_name": "SecureCookieSessionInterface", "parameters": ["self", "app", "session", "response"], "calls": ["self.get_cookie_name", "self.get_cookie_domain", "self.get_cookie_path", "self.get_cookie_secure", "self.get_cookie_partitioned", "self.get_cookie_samesite", "self.get_cookie_httponly", "self.get_expiration_time", "dumps", "response.set_cookie", "response.vary.add", "response.vary.add", "self.should_set_cookie", "dict", "response.delete_cookie", "response.vary.add", "self.get_signing_serializer"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 351, "end_line": 399}, "code_snippet": "    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        partitioned = self.get_cookie_partitioned(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    partitioned=partitioned,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n                response.vary.add(\"Cookie\")\n\n            return\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            partitioned=partitioned,\n            samesite=samesite,\n        )\n        response.vary.add(\"Cookie\")\n", "type": "function"}, {"name": "test_session_refresh_vary", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.get", "app.get", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 581, "end_line": 595}, "code_snippet": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n", "type": "function"}, {"name": "test_session_transactions_keep_context", "is_method": false, "class_name": null, "parameters": ["app", "client", "req_ctx"], "calls": ["client.get", "flask.request._get_current_object", "client.session_transaction", "flask.request._get_current_object"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 196, "end_line": 201}, "code_snippet": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n", "type": "function"}, {"name": "test_session_transactions", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "str", "client.get", "client.session_transaction", "client.session_transaction", "len", "len", "len"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 169, "end_line": 183}, "code_snippet": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]\n", "type": "function"}, {"name": "test_session_dynamic_cookie_name", "is_method": false, "class_name": null, "parameters": [], "calls": ["CustomFlask", "app.route", "app.route", "app.route", "app.route", "app.test_client", "PathAwareSessionInterface", "flask.session.get", "flask.session.get", "flask.request.url.endswith", "test_client.post", "test_client.post", "test_client.get", "test_client.get", "get_cookie_name", "super"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 229, "end_line": 277}, "code_snippet": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1583640575408936}
{"question": "How does the error handling strategy in the application context globals namespace class's attribute access, deletion, and removal methods balance between raising AttributeError for missing attributes and providing default values?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_AppCtxGlobals", "docstring": "A plain object. Used as a namespace for storing data during an\napplication context.\n\nCreating an app context automatically creates this object, which is\nmade available as the :data:`g` proxy.\n\n.. describe:: 'key' in g\n\n    Check whether an attribute is present.\n\n    .. versionadded:: 0.10\n\n.. describe:: iter(g)\n\n    Return an iterator over the attribute names.\n\n    .. versionadded:: 0.10", "methods": ["__getattr__", "__setattr__", "__delattr__", "get", "pop", "setdefault", "__contains__", "__iter__", "__repr__"], "attributes": [], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 29, "end_line": 114}, "type": "class"}, {"name": "test_app_ctx_globals_methods", "is_method": false, "class_name": null, "parameters": ["app", "app_ctx"], "calls": ["flask.g.setdefault", "flask.g.setdefault", "flask.g.get", "flask.g.get", "flask.g.pop", "pytest.raises", "flask.g.pop", "flask.g.pop", "list", "repr"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 134, "end_line": 154}, "code_snippet": "def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n", "type": "function"}, {"name": "test_get_method_on_g", "is_method": false, "class_name": null, "parameters": ["app_ctx"], "calls": ["flask.g.get", "flask.g.get", "flask.g.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1738, "end_line": 1743}, "code_snippet": "def test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n", "type": "function"}, {"name": "test_custom_app_ctx_globals_class", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.app_context", "flask.render_template_string"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 157, "end_line": 164}, "code_snippet": "def test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n", "type": "function"}, {"name": "get", "is_method": true, "class_name": "_AppCtxGlobals", "parameters": ["self", "name", "default"], "calls": ["self.__dict__.get"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 67, "end_line": 76}, "code_snippet": "    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__.get(name, default)\n", "type": "function"}, {"name": "__getattr__", "is_method": true, "class_name": "_AppCtxGlobals", "parameters": ["self", "name"], "calls": ["AttributeError"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 52, "end_line": 56}, "code_snippet": "    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n", "type": "function"}, {"name": "pop", "is_method": true, "class_name": "_AppCtxGlobals", "parameters": ["self", "name", "default"], "calls": ["self.__dict__.pop", "self.__dict__.pop"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 78, "end_line": 90}, "code_snippet": "    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n", "type": "function"}, {"name": "setdefault", "is_method": true, "class_name": "_AppCtxGlobals", "parameters": ["self", "name", "default"], "calls": ["self.__dict__.setdefault"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 92, "end_line": 102}, "code_snippet": "    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)\n", "type": "function"}, {"name": "test_app_tearing_down_with_handled_exception_by_except_block", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["cleanup_stuff.append", "app.app_context", "Exception"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 75, "end_line": 88}, "code_snippet": "def test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n", "type": "function"}, {"name": "test_session_error_pops_context", "is_method": false, "class_name": null, "parameters": [], "calls": ["CustomFlask", "app.route", "get", "FailingSessionInterface", "AssertionError", "SessionError", "app.test_client"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 205, "end_line": 226}, "code_snippet": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1670358180999756}
{"question": "How does the subclass initialization hook in the HTTP method-dispatching view class resolve conflicting methods attributes when inheriting from multiple parent classes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init_subclass__", "is_method": true, "class_name": "MethodView", "parameters": ["cls"], "calls": ["__init_subclass__", "set", "super", "getattr", "hasattr", "methods.update", "methods.add", "key.upper"], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 165, "end_line": 180}, "code_snippet": "    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n        if \"methods\" not in cls.__dict__:\n            methods = set()\n\n            for base in cls.__bases__:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)  # type: ignore[attr-defined]\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            if methods:\n                cls.methods = methods\n", "type": "function"}, {"name": "test_remove_method_from_parent", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "sorted", "View.as_view", "client.get", "client.post"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 226, "end_line": 242}, "code_snippet": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]\n", "type": "function"}, {"name": "test_methods_var_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "ChildView.as_view", "client.get", "client.open"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 189, "end_line": 204}, "code_snippet": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}\n", "type": "function"}, {"name": "test_view_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "parse_set_header", "sorted", "BetterIndex.as_view", "client.open"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 62, "end_line": 77}, "code_snippet": "def test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n", "type": "function"}, {"name": "test_multiple_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "sorted", "GetDeleteView.as_view", "client.get", "client.delete"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 207, "end_line": 223}, "code_snippet": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]\n", "type": "function"}, {"name": "test_view_patching", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["Index.as_view", "app.add_url_rule", "common_test"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 41, "end_line": 59}, "code_snippet": "def test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            raise ZeroDivisionError\n\n        def post(self):\n            raise ZeroDivisionError\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)\n", "type": "function"}, {"name": "test_view_provide_automatic_options_attr", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "sorted", "Index1.as_view", "Index2.as_view", "Index3.as_view"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 101, "end_line": 138}, "code_snippet": "def test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow\n", "type": "function"}, {"name": "dispatch_request", "is_method": true, "class_name": "MethodView", "parameters": ["self"], "calls": ["getattr", "request.method.lower", "getattr", "current_app.ensure_sync"], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 182, "end_line": 191}, "code_snippet": "    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n        meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]\n", "type": "function"}, {"name": "View", "docstring": "Subclass this class and override :meth:`dispatch_request` to\ncreate a generic class-based view. Call :meth:`as_view` to create a\nview function that creates an instance of the class with the given\narguments and calls its ``dispatch_request`` method with any URL\nvariables.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class Hello(View):\n        init_every_request = False\n\n        def dispatch_request(self, name):\n            return f\"Hello, {name}!\"\n\n    app.add_url_rule(\n        \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n    )\n\nSet :attr:`methods` on the class to change what methods the view\naccepts.\n\nSet :attr:`decorators` on the class to apply a list of decorators to\nthe generated view function. Decorators applied to the class itself\nwill not be applied to the generated view function!\n\nSet :attr:`init_every_request` to ``False`` for efficiency, unless\nyou need to store request-global data on ``self``.", "methods": ["dispatch_request", "as_view"], "attributes": [], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 16, "end_line": 135}, "type": "class"}, {"name": "MethodView", "docstring": "Dispatches request methods to the corresponding instance methods.\nFor example, if you implement a ``get`` method, it will be used to\nhandle ``GET`` requests.\n\nThis can be useful for defining a REST API.\n\n:attr:`methods` is automatically set based on the methods defined on\nthe class.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class CounterAPI(MethodView):\n        def get(self):\n            return str(session.get(\"counter\", 0))\n\n        def post(self):\n            session[\"counter\"] = session.get(\"counter\", 0) + 1\n            return redirect(url_for(\"counter\"))\n\n    app.add_url_rule(\n        \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n    )", "methods": ["__init_subclass__", "dispatch_request"], "attributes": [], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 138, "end_line": 191}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1628177165985107}
{"question": "How does the namespace object that stores application-level data during an application context maintain thread-safety and context isolation when accessed concurrently through the contextvars mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_AppCtxGlobals", "docstring": "A plain object. Used as a namespace for storing data during an\napplication context.\n\nCreating an app context automatically creates this object, which is\nmade available as the :data:`g` proxy.\n\n.. describe:: 'key' in g\n\n    Check whether an attribute is present.\n\n    .. versionadded:: 0.10\n\n.. describe:: iter(g)\n\n    Return an iterator over the attribute names.\n\n    .. versionadded:: 0.10", "methods": ["__getattr__", "__setattr__", "__delattr__", "get", "pop", "setdefault", "__contains__", "__iter__", "__repr__"], "attributes": [], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 29, "end_line": 114}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "AppContext", "parameters": ["self", "app"], "calls": ["app.create_url_adapter", "app.app_ctx_globals_class"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 245, "end_line": 249}, "code_snippet": "    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n", "type": "function"}, {"name": "AppContext", "docstring": "The app context contains application-specific information. An app\ncontext is created and pushed at the beginning of each request if\none is not already active. An app context is also pushed when\nrunning CLI commands.", "methods": ["__init__", "push", "pop", "__enter__", "__exit__"], "attributes": [], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 238, "end_line": 284}, "type": "class"}, {"name": "test_g_iteration_protocol", "is_method": false, "class_name": null, "parameters": ["app_ctx"], "calls": ["sorted"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1746, "end_line": 1751}, "code_snippet": "def test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n", "type": "function"}, {"name": "test_greenlet_context_copying", "is_method": true, "class_name": "TestGreenletContextCopying", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "run", "request_ctx.copy", "greenlets.append", "greenlet", "flask.session.get"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 150, "end_line": 177}, "code_snippet": "    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "type": "function"}, {"name": "test_app_ctx_globals_methods", "is_method": false, "class_name": null, "parameters": ["app", "app_ctx"], "calls": ["flask.g.setdefault", "flask.g.setdefault", "flask.g.get", "flask.g.get", "flask.g.pop", "pytest.raises", "flask.g.pop", "flask.g.pop", "list", "repr"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 134, "end_line": 154}, "code_snippet": "def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n", "type": "function"}, {"name": "test_get_method_on_g", "is_method": false, "class_name": null, "parameters": ["app_ctx"], "calls": ["flask.g.get", "flask.g.get", "flask.g.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1738, "end_line": 1743}, "code_snippet": "def test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n", "type": "function"}, {"name": "test_get_namespace", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.config.get_namespace", "app.config.get_namespace", "app.config.get_namespace", "app.config.get_namespace", "len", "len", "len", "len"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 217, "end_line": 240}, "code_snippet": "def test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]\n", "type": "function"}, {"name": "test_greenlet_context_copying_api", "is_method": true, "class_name": "TestGreenletContextCopying", "parameters": ["self", "app", "client"], "calls": ["app.route", "client.get", "run", "greenlets.append", "greenlet", "flask.session.get"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 179, "end_line": 202}, "code_snippet": "    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "type": "function"}, {"name": "test_context_available", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.get", "client.get"], "code_location": {"file": "test_converters.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 29, "end_line": 42}, "code_snippet": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.172422170639038}
{"question": "How does the type-safe dictionary structure used as a view function return type annotation decouple JSON response serialization from HTTP status representation to maintain type safety?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "typed_dict", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 46, "end_line": 47}, "code_snippet": "def typed_dict() -> StatusJSON:\n    return {\"status\": \"ok\"}\n", "type": "function"}, {"name": "hello_json_dict", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 32, "end_line": 33}, "code_snippet": "def hello_json_dict() -> dict[str, t.Any]:\n    return {\"response\": \"Hello, World!\"}\n", "type": "function"}, {"name": "tuple_status_enum", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 76, "end_line": 77}, "code_snippet": "def tuple_status_enum() -> tuple[str, int]:\n    return \"hello\", HTTPStatus.OK\n", "type": "function"}, {"name": "tuple_status", "is_method": false, "class_name": null, "parameters": ["code"], "calls": ["app.route", "app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 71, "end_line": 72}, "code_snippet": "def tuple_status(code: int = 200) -> tuple[str, int]:\n    return \"hello\", code\n", "type": "function"}, {"name": "StatusJSON", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 41, "end_line": 42}, "type": "class"}, {"name": "jsonify", "is_method": false, "class_name": null, "parameters": [], "calls": ["current_app.json.response"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 138, "end_line": 170}, "code_snippet": "def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    \"\"\"Serialize the given arguments as JSON, and return a\n    :class:`~flask.Response` object with the ``application/json``\n    mimetype. A dict or list returned from a view will be converted to a\n    JSON response automatically without needing to call this.\n\n    This requires an active request or application context, and calls\n    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\n    In debug mode, the output is formatted with indentation to make it\n    easier to read. This may also be controlled by the provider.\n\n    Either positional or keyword arguments can be given, not both.\n    If no arguments are given, ``None`` is serialized.\n\n    :param args: A single value to serialize, or multiple values to\n        treat as a list to serialize.\n    :param kwargs: Treat as a dict to serialize.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.response``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This was a\n        security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return current_app.json.response(*args, **kwargs)  # type: ignore[return-value]\n", "type": "function"}, {"name": "hello_json", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route", "jsonify"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 27, "end_line": 28}, "code_snippet": "def hello_json() -> Response:\n    return jsonify(\"Hello, World!\")\n", "type": "function"}, {"name": "tuple_headers", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 81, "end_line": 82}, "code_snippet": "def tuple_headers() -> tuple[str, dict[str, str]]:\n    return \"Hello, World!\", {\"Content-Type\": \"text/plain\"}\n", "type": "function"}, {"name": "test_jsonify_dicts", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "flask.jsonify", "flask.jsonify", "client.get", "flask.json.loads"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 78, "end_line": 102}, "code_snippet": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d\n", "type": "function"}, {"name": "make_response", "is_method": true, "class_name": "Flask", "parameters": ["self", "rv"], "calls": ["isinstance", "t.cast", "len", "TypeError", "isinstance", "isinstance", "rv.headers.update", "isinstance", "isinstance", "self.response_class", "isinstance", "isinstance", "TypeError", "self.json.response", "isinstance", "callable", "TypeError", "self.response_class.force_type", "with_traceback", "TypeError", "sys.exc_info", "type", "type"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 1129, "end_line": 1269}, "code_snippet": "    def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str``\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes``\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``list``\n                A list that will be jsonify'd before being returned.\n\n            ``generator`` or ``iterator``\n                A generator that returns ``str`` or ``bytes`` to be\n                streamed as the response.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 2.2\n            A generator will be converted to a streaming response.\n            A list will be converted to a JSON response.\n\n        .. versionchanged:: 1.1\n            A dict will be converted to a JSON response.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status: int | None = None\n        headers: HeadersValue | None = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv  # type: ignore[misc]\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv  # pyright: ignore\n                else:\n                    rv, status = rv  # type: ignore[assignment,misc]\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(\n                    rv,  # pyright: ignore\n                    status=status,\n                    headers=headers,  # type: ignore[arg-type]\n                )\n                status = headers = None\n            elif isinstance(rv, (dict, list)):\n                rv = self.json.response(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(\n                        rv,  # type: ignore[arg-type]\n                        request.environ,\n                    )\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, list, tuple with headers or status,\"\n                        \" Response instance, or WSGI callable, but it\"\n                        f\" was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2]) from None\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, list, tuple with headers or status,\"\n                    \" Response instance, or WSGI callable, but it was a\"\n                    f\" {type(rv).__name__}.\"\n                )\n\n        rv = t.cast(Response, rv)\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.update(headers)\n\n        return rv\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1684303283691406}
{"question": "Why does the class that handles UUID serialization in the tagged JSON serialization system enable bidirectional conversion between UUID instances and their hexadecimal string representations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "TagUUID", "docstring": "", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 191, "end_line": 202}, "type": "class"}, {"name": "to_json", "is_method": true, "class_name": "TagUUID", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 198, "end_line": 199}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return value.hex\n", "type": "function"}, {"name": "TaggedJSONSerializer", "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`", "methods": ["__init__", "register", "tag", "untag", "_untag_scan", "dumps", "loads"], "attributes": ["__slots__", "default_tags"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 219, "end_line": 327}, "type": "class"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "test_jsonify_uuid_types", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["uuid.UUID", "app.add_url_rule", "client.get", "uuid.UUID", "flask.json.loads", "str", "flask.jsonify"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 176, "end_line": 188}, "code_snippet": "def test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "to_python", "is_method": true, "class_name": "TagUUID", "parameters": ["self", "value"], "calls": ["UUID"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 201, "end_line": 202}, "code_snippet": "    def to_python(self, value: t.Any) -> t.Any:\n        return UUID(value)\n", "type": "function"}, {"name": "test_dump_load_unchanged", "is_method": false, "class_name": null, "parameters": ["data"], "calls": ["pytest.mark.parametrize", "TaggedJSONSerializer", "s.loads", "Markup", "uuid4", "replace", "s.dumps", "datetime.now"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 27, "end_line": 29}, "code_snippet": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassList", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 153, "end_line": 154}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1733686923980713}
{"question": "Why does the CLI helper class that manages Flask application loading provide both a direct callable factory parameter and an import path parameter as alternative instantiation mechanisms?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_scriptinfo", "is_method": false, "class_name": null, "parameters": ["test_apps", "monkeypatch"], "calls": ["ScriptInfo", "obj.load_app", "str", "ScriptInfo", "obj.load_app", "ScriptInfo", "obj.load_app", "ScriptInfo", "obj.load_app", "ScriptInfo", "pytest.raises", "monkeypatch.chdir", "ScriptInfo", "obj.load_app", "monkeypatch.chdir", "ScriptInfo", "obj.load_app", "obj.load_app", "obj.load_app", "obj.load_app", "Flask", "obj.load_app"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 247, "end_line": 286}, "code_snippet": "def test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "add_default_commands", "create_app", "add_version_option", "load_dotenv", "set_debug_flag"], "calls": ["list", "params.extend", "setdefault", "__init__", "params.append", "self.add_command", "self.add_command", "self.add_command", "extra.pop", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 563, "end_line": 598}, "code_snippet": "    def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params: list[click.Parameter] = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n", "type": "function"}, {"name": "ScriptInfo", "docstring": "Helper object to deal with Flask applications.  This is usually not\nnecessary to interface with as it's used internally in the dispatching\nto click.  In future versions of Flask this object will most likely play\na bigger role.  Typically it's created automatically by the\n:class:`FlaskGroup` but you can also manually create it and pass it\nonwards as click object.\n\n.. versionchanged:: 3.1\n    Added the ``load_dotenv_defaults`` parameter and attribute.", "methods": ["__init__", "load_app"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 293, "end_line": 372}, "type": "class"}, {"name": "_set_app", "is_method": false, "class_name": null, "parameters": ["ctx", "param", "value"], "calls": ["ctx.ensure_object"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 440, "end_line": 446}, "code_snippet": "def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "name", "import_name", "static_folder", "static_url_path", "template_folder", "url_prefix", "subdomain", "url_defaults", "root_path", "cli_group"], "calls": ["__init__", "AppGroup", "super"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 19, "end_line": 53}, "code_snippet": "    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Flask", "parameters": ["self", "import_name", "static_url_path", "static_folder", "static_host", "host_matching", "subdomain_matching", "template_folder", "instance_path", "instance_relative_config", "root_path"], "calls": ["__init__", "cli.AppGroup", "weakref.ref", "self.add_url_rule", "super", "bool", "send_static_file", "self_ref"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 226, "end_line": 279}, "code_snippet": "    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_folder=static_folder,\n            static_host=static_host,\n            host_matching=host_matching,\n            subdomain_matching=subdomain_matching,\n            template_folder=template_folder,\n            instance_path=instance_path,\n            instance_relative_config=instance_relative_config,\n            root_path=root_path,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = cli.AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, (\n                \"Invalid static_host/host_matching combination\"\n            )\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n", "type": "function"}, {"name": "locate_app", "is_method": false, "class_name": null, "parameters": ["module_name", "app_name", "raise_if_not_found"], "calls": ["__import__", "find_best_app", "find_app_by_string", "NoAppException", "sys.exc_info", "NoAppException", "traceback.format_exc"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 241, "end_line": 264}, "code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)\n", "type": "function"}, {"name": "create_app2", "is_method": false, "class_name": null, "parameters": ["foo", "bar"], "calls": ["Flask", "join"], "code_location": {"file": "factory.py", "path": "/data3/pwh/swebench-repos/flask/tests/test_apps/cliapp", "start_line": 8, "end_line": 9}, "code_snippet": "def create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n", "type": "function"}, {"name": "invoke", "is_method": true, "class_name": "TestRoutes", "parameters": ["self", "app", "runner"], "calls": ["FlaskGroup", "partial"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 459, "end_line": 461}, "code_snippet": "    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n", "type": "function"}, {"name": "App", "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages.", "methods": ["__init__", "_check_setup_finished", "name", "logger", "jinja_env", "create_jinja_environment", "make_config", "make_aborter", "auto_find_instance_path", "create_global_jinja_loader", "select_jinja_autoescape", "debug", "debug", "register_blueprint", "iter_blueprints", "add_url_rule", "template_filter", "add_template_filter", "template_test", "add_template_test", "template_global", "add_template_global", "teardown_appcontext", "shell_context_processor", "_find_error_handler", "trap_http_exception", "should_ignore_error", "redirect", "inject_url_defaults", "handle_url_build_error"], "attributes": ["aborter_class", "jinja_environment", "app_ctx_globals_class", "config_class", "testing", "secret_key", "permanent_session_lifetime", "url_rule_class", "url_map_class"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 59, "end_line": 964}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.18583345413208}
{"question": "How does the tagged JSON serializer class that handles bytes maintain data consistency and reversibility when encoding binary data through base64?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_dump_load_unchanged", "is_method": false, "class_name": null, "parameters": ["data"], "calls": ["pytest.mark.parametrize", "TaggedJSONSerializer", "s.loads", "Markup", "uuid4", "replace", "s.dumps", "datetime.now"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 27, "end_line": 29}, "code_snippet": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data\n", "type": "function"}, {"name": "TagBytes", "docstring": "", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 159, "end_line": 170}, "type": "class"}, {"name": "TaggedJSONSerializer", "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`", "methods": ["__init__", "register", "tag", "untag", "_untag_scan", "dumps", "loads"], "attributes": ["__slots__", "default_tags"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 219, "end_line": 327}, "type": "class"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "test_custom_tag", "is_method": false, "class_name": null, "parameters": [], "calls": ["TaggedJSONSerializer", "s.register", "isinstance", "self.serializer.tag", "Foo", "s.loads", "s.dumps", "Foo"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 43, "end_line": 63}, "code_snippet": "def test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagBytes", "parameters": ["self", "value"], "calls": ["decode", "b64encode"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 166, "end_line": 167}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return b64encode(value).decode(\"ascii\")\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "test_tag_order", "is_method": false, "class_name": null, "parameters": [], "calls": ["TaggedJSONSerializer", "s.register", "isinstance", "s.register", "isinstance"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 73, "end_line": 86}, "code_snippet": "def test_tag_order():\n    class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)\n", "type": "function"}, {"name": "test_duplicate_tag", "is_method": false, "class_name": null, "parameters": [], "calls": ["TaggedJSONSerializer", "pytest.raises", "s.register", "isinstance", "isinstance"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 32, "end_line": 40}, "code_snippet": "def test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2078933715820312}
{"question": "How does the wrapper function that defers hash algorithm access until execution delay cryptographic availability validation until runtime to prevent import-time failures in restricted environments?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_lazy_sha1", "is_method": false, "class_name": null, "parameters": ["string"], "calls": ["hashlib.sha1"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 290, "end_line": 295}, "code_snippet": "def _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)\n", "type": "function"}, {"name": "dotenv_not_available", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 521, "end_line": 527}, "code_snippet": "def dotenv_not_available():\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        return True\n\n    return False\n", "type": "function"}, {"name": "test_run_cert_adhoc", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "monkeypatch.setitem", "run_command.make_context", "pytest.raises", "run_command.make_context", "types.ModuleType", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 602, "end_line": 616}, "code_snippet": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\n", "type": "function"}, {"name": "_fail", "is_method": true, "class_name": "NullSession", "parameters": ["self"], "calls": ["RuntimeError"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 103, "end_line": 108}, "code_snippet": "    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n", "type": "function"}, {"name": "test_run_cert_no_ssl", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 641, "end_line": 645}, "code_snippet": "def test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n", "type": "function"}, {"name": "TestNoImports", "docstring": "Test Flasks are created without import.\n\nAvoiding ``__import__`` helps create Flask instances where there are errors\nat import time.  Those runtime errors will be apparent to the user soon\nenough, but tools which build Flask instances meta-programmatically benefit\nfrom a Flask which does not ``__import__``.  Instead of importing to\nretrieve file paths or metadata on a module or package, use the pkgutil and\nimp modules in the Python standard library.", "methods": ["test_name_with_import_error"], "attributes": [], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 217, "end_line": 233}, "type": "class"}, {"name": "convert", "is_method": true, "class_name": "CertParamType", "parameters": ["self", "value", "param", "ctx"], "calls": ["self.path_type", "click.BadParameter", "lower", "import_string", "isinstance", "click.STRING", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 791, "end_line": 825}, "code_snippet": "    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n", "type": "function"}, {"name": "setupmethod", "is_method": false, "class_name": null, "parameters": ["f"], "calls": ["t.cast", "self._check_setup_finished", "f", "update_wrapper"], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 42, "end_line": 49}, "code_snippet": "def setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n", "type": "function"}, {"name": "_get_werkzeug_version", "is_method": false, "class_name": null, "parameters": [], "calls": ["importlib.metadata.version"], "code_location": {"file": "testing.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 100, "end_line": 106}, "code_snippet": "def _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n", "type": "function"}, {"name": "_env_file_callback", "is_method": false, "class_name": null, "parameters": ["ctx", "param", "value"], "calls": ["load_dotenv", "click.BadParameter"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 493, "end_line": 512}, "code_snippet": "def _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        # Only show an error if a value was passed, otherwise we still want to\n        # call load_dotenv and show a message without exiting.\n        if value is not None:\n            raise click.BadParameter(\n                \"python-dotenv must be installed to load an env file.\",\n                ctx=ctx,\n                param=param,\n            ) from None\n\n    # Load if a value was passed, or we want to load default files, or both.\n    if value is not None or ctx.obj.load_dotenv_defaults:\n        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\n\n    return value\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2190179824829102}
{"question": "Why does the asynchronous HTTP method view class inherit from the synchronous HTTP method dispatch base class rather than implementing async dispatch independently?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "AsyncMethodView", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "test_async.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 30, "end_line": 37}, "type": "class"}, {"name": "AsyncView", "docstring": "", "methods": [], "attributes": ["methods"], "code_location": {"file": "test_async.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 22, "end_line": 27}, "type": "class"}, {"name": "test_view_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "parse_set_header", "sorted", "BetterIndex.as_view", "client.open"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 62, "end_line": 77}, "code_snippet": "def test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n", "type": "function"}, {"name": "test_methods_var_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "ChildView.as_view", "client.get", "client.open"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 189, "end_line": 204}, "code_snippet": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}\n", "type": "function"}, {"name": "MethodView", "docstring": "Dispatches request methods to the corresponding instance methods.\nFor example, if you implement a ``get`` method, it will be used to\nhandle ``GET`` requests.\n\nThis can be useful for defining a REST API.\n\n:attr:`methods` is automatically set based on the methods defined on\nthe class.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class CounterAPI(MethodView):\n        def get(self):\n            return str(session.get(\"counter\", 0))\n\n        def post(self):\n            session[\"counter\"] = session.get(\"counter\", 0) + 1\n            return redirect(url_for(\"counter\"))\n\n    app.add_url_rule(\n        \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n    )", "methods": ["__init_subclass__", "dispatch_request"], "attributes": [], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 138, "end_line": 191}, "type": "class"}, {"name": "test_remove_method_from_parent", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "sorted", "View.as_view", "client.get", "client.post"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 226, "end_line": 242}, "code_snippet": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]\n", "type": "function"}, {"name": "test_multiple_inheritance", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "sorted", "GetDeleteView.as_view", "client.get", "client.delete"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 207, "end_line": 223}, "code_snippet": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]\n", "type": "function"}, {"name": "__init_subclass__", "is_method": true, "class_name": "MethodView", "parameters": ["cls"], "calls": ["__init_subclass__", "set", "super", "getattr", "hasattr", "methods.update", "methods.add", "key.upper"], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 165, "end_line": 180}, "code_snippet": "    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n        if \"methods\" not in cls.__dict__:\n            methods = set()\n\n            for base in cls.__bases__:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)  # type: ignore[attr-defined]\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            if methods:\n                cls.methods = methods\n", "type": "function"}, {"name": "View", "docstring": "Subclass this class and override :meth:`dispatch_request` to\ncreate a generic class-based view. Call :meth:`as_view` to create a\nview function that creates an instance of the class with the given\narguments and calls its ``dispatch_request`` method with any URL\nvariables.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class Hello(View):\n        init_every_request = False\n\n        def dispatch_request(self, name):\n            return f\"Hello, {name}!\"\n\n    app.add_url_rule(\n        \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n    )\n\nSet :attr:`methods` on the class to change what methods the view\naccepts.\n\nSet :attr:`decorators` on the class to apply a list of decorators to\nthe generated view function. Decorators applied to the class itself\nwill not be applied to the generated view function!\n\nSet :attr:`init_every_request` to ``False`` for efficiency, unless\nyou need to store request-global data on ``self``.", "methods": ["dispatch_request", "as_view"], "attributes": [], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 16, "end_line": 135}, "type": "class"}, {"name": "dispatch_request", "is_method": true, "class_name": "MethodView", "parameters": ["self"], "calls": ["getattr", "request.method.lower", "getattr", "current_app.ensure_sync"], "code_location": {"file": "views.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 182, "end_line": 191}, "code_snippet": "    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n        meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2155609130859375}
{"question": "Why would performance degradation occur if the custom template filter registration mechanism used in blueprint test cases were repeated across multiple distinct blueprint objects during application startup?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_add_template_filter", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 375, "end_line": 385}, "code_snippet": "def test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_template_filter_after_route_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 431, "end_line": 444}, "code_snippet": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_template_filter", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 362, "end_line": 372}, "code_snippet": "def test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 447, "end_line": 461}, "code_snippet": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 414, "end_line": 428}, "code_snippet": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_name", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 401, "end_line": 411}, "code_snippet": "def test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_name_and_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 464, "end_line": 478}, "code_snippet": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_add_template_filter_with_name_and_template", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.add_app_template_filter", "app.register_blueprint", "app.route", "client.get", "flask.render_template"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 481, "end_line": 495}, "code_snippet": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "type": "function"}, {"name": "test_template_filter_with_name", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.app_template_filter", "app.register_blueprint", "app.jinja_env.filters.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 388, "end_line": 398}, "code_snippet": "def test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "type": "function"}, {"name": "test_template_test", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.app_template_test", "app.register_blueprint", "isinstance", "app.jinja_env.tests.keys"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 498, "end_line": 508}, "code_snippet": "def test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2224388122558594}
{"question": "Why does the test that validates blueprint names cannot contain dots ensure that creating a modular route component with names containing dot characters raises a ValueError?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_dotted_name_not_allowed", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["pytest.raises", "flask.Blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 254, "end_line": 256}, "code_snippet": "def test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n", "type": "function"}, {"name": "test_route_decorator_custom_endpoint_with_dots", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "pytest.raises", "pytest.raises", "bp.add_url_rule", "pytest.raises", "bp.add_url_rule", "bp.route"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 327, "end_line": 342}, "code_snippet": "def test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n", "type": "function"}, {"name": "test_empty_name_not_allowed", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["pytest.raises", "flask.Blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 259, "end_line": 261}, "code_snippet": "def test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)\n", "type": "function"}, {"name": "test_dotted_names_from_app", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "app.route", "test.route", "app.register_blueprint", "client.get", "flask.url_for", "flask.url_for"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 264, "end_line": 278}, "code_snippet": "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n", "type": "function"}, {"name": "test_unique_blueprint_names", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "app.register_blueprint", "app.register_blueprint", "app.register_blueprint", "pytest.raises", "app.register_blueprint", "pytest.raises", "app.register_blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 994, "end_line": 1008}, "code_snippet": "def test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n", "type": "function"}, {"name": "test_blueprint_renaming", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "bp.get", "bp.get", "bp.errorhandler", "bp2.get", "bp.register_blueprint", "app.register_blueprint", "app.register_blueprint", "flask.abort", "client.get", "client.get", "client.get", "client.get", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1017, "end_line": 1046}, "code_snippet": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n", "type": "function"}, {"name": "test_self_registration", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "pytest.raises", "bp.register_blueprint"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1011, "end_line": 1014}, "code_snippet": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n", "type": "function"}, {"name": "test_blueprint_with_subdomain", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "flask.Blueprint", "bp.route", "app.register_blueprint", "app.test_request_context", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 117, "end_line": 138}, "code_snippet": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"\n", "type": "function"}, {"name": "test_blueprint_prefix_slash", "is_method": false, "class_name": null, "parameters": ["app", "client", "prefix", "rule", "url"], "calls": ["pytest.mark.parametrize", "flask.Blueprint", "bp.route", "app.register_blueprint", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 120, "end_line": 128}, "code_snippet": "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n", "type": "function"}, {"name": "test_route_decorator_custom_endpoint", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "bp.route", "bp.route", "bp.route", "bp.route", "app.register_blueprint", "app.route", "client.get", "client.get", "client.get", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 295, "end_line": 324}, "code_snippet": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2195117473602295}
{"question": "Why does the method that opens application package resources relative to the root path restrict file opening to read-only modes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "open_resource", "is_method": true, "class_name": "Flask", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "ValueError", "open"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 330, "end_line": 361}, "code_snippet": "    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = None\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading.\n\n        For example, if the file ``schema.sql`` is next to the file\n        ``app.py`` where the ``Flask`` app is defined, it can be opened\n        with:\n\n        .. code-block:: python\n\n            with app.open_resource(\"schema.sql\") as f:\n                conn.executescript(f.read())\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "open_resource", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "ValueError", "open"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 104, "end_line": 128}, "code_snippet": "    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading. The\n        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\n        method.\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "test_open_resource", "is_method": false, "class_name": null, "parameters": ["mode"], "calls": ["pytest.mark.parametrize", "flask.Flask", "app.open_resource", "str", "f.read"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 339, "end_line": 343}, "code_snippet": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())\n", "type": "function"}, {"name": "open_instance_resource", "is_method": true, "class_name": "Flask", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "open"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 363, "end_line": 383}, "code_snippet": "    def open_instance_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to the application's instance folder\n        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the\n        instance folder can be opened for writing.\n\n        :param resource: Path to the resource relative to :attr:`instance_path`.\n        :param mode: Open the file in this mode.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        path = os.path.join(self.instance_path, resource)\n\n        if \"b\" in mode:\n            return open(path, mode)\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "test_open_resource_exceptions", "is_method": false, "class_name": null, "parameters": ["mode"], "calls": ["pytest.mark.parametrize", "flask.Flask", "pytest.raises", "app.open_resource"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 347, "end_line": 351}, "code_snippet": "def test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)\n", "type": "function"}, {"name": "test_open_resource_with_encoding", "is_method": false, "class_name": null, "parameters": ["tmp_path", "encoding"], "calls": ["pytest.mark.parametrize", "flask.Flask", "write_text", "app.open_resource", "os.fspath", "f.read"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 355, "end_line": 360}, "code_snippet": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"\n", "type": "function"}, {"name": "get_root_path", "is_method": false, "class_name": null, "parameters": ["import_name"], "calls": ["sys.modules.get", "hasattr", "os.path.dirname", "hasattr", "os.path.dirname", "importlib.util.find_spec", "os.getcwd", "loader.get_filename", "__import__", "getattr", "os.path.abspath", "os.path.abspath", "RuntimeError"], "code_location": {"file": "helpers.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 570, "end_line": 624}, "code_snippet": "def get_root_path(import_name: str) -> str:\n    \"\"\"Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n\n    Not to be confused with the value returned by :func:`find_package`.\n\n    :meta private:\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    try:\n        spec = importlib.util.find_spec(import_name)\n\n        if spec is None:\n            raise ValueError\n    except (ImportError, ValueError):\n        loader = None\n    else:\n        loader = spec.loader\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None:\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # pyright: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]\n", "type": "function"}, {"name": "test_uninstalled_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "purge_module"], "calls": ["app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 30, "end_line": 43}, "code_snippet": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")\n", "type": "function"}, {"name": "test_prefix_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "modules_tmp_path_prefix", "purge_module", "site_packages"], "calls": ["app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 99, "end_line": 111}, "code_snippet": "def test_prefix_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )\n", "type": "function"}, {"name": "_find_package_path", "is_method": false, "class_name": null, "parameters": ["import_name"], "calls": ["import_name.partition", "importlib.util.find_spec", "os.path.dirname", "ValueError", "os.getcwd", "importlib.util.find_spec", "os.path.dirname", "os.path.dirname", "pathlib.Path", "next", "os.path.dirname", "os.path.commonpath", "package_path.is_relative_to"], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 709, "end_line": 751}, "code_snippet": "def _find_package_path(import_name: str) -> str:\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    except (ImportError, ValueError):\n        # ImportError: the machinery told us it does not exist\n        # ValueError:\n        #    - the module name was invalid\n        #    - the module name is __main__\n        #    - we raised `ValueError` due to `root_spec` being `None`\n        return os.getcwd()\n\n    if root_spec.submodule_search_locations:\n        if root_spec.origin is None or root_spec.origin == \"namespace\":\n            # namespace package\n            package_spec = importlib.util.find_spec(import_name)\n\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_location = next(\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if package_path.is_relative_to(location)\n                )\n            else:\n                # Pick the first path.\n                search_location = root_spec.submodule_search_locations[0]\n\n            return os.path.dirname(search_location)\n        else:\n            # package with __init__.py\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n    else:\n        # module\n        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2298438549041748}
{"question": "Why does unconditionally setting the session access tracking attribute in dictionary access methods impact signed cookie string conversion performance during frequent read operations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "SecureCookieSession", "docstring": "Base class for sessions based on signed cookies.\n\nThis session backend will set the :attr:`modified` and\n:attr:`accessed` attributes. It cannot reliably track whether a\nsession is new (vs. empty), so :attr:`new` remains hard coded to\n``False``.", "methods": ["__init__", "__getitem__", "get", "setdefault"], "attributes": ["modified", "accessed"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 52, "end_line": 94}, "type": "class"}, {"name": "test_session_cookie_setting", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.route", "app.route", "run_test", "run_test", "run_test", "run_test", "str", "str", "flask.session.get", "flask.session.get", "app.test_client", "c.get", "rv.headers.get", "c.get", "c.get", "c.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 479, "end_line": 517}, "code_snippet": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n", "type": "function"}, {"name": "setdefault", "is_method": true, "class_name": "SecureCookieSession", "parameters": ["self", "key", "default"], "calls": ["setdefault", "super"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 92, "end_line": 94}, "code_snippet": "    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)\n", "type": "function"}, {"name": "test_session", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "flask.session.get", "client.post", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 234, "end_line": 254}, "code_snippet": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"\n", "type": "function"}, {"name": "SessionMixin", "docstring": "Expands a basic dictionary with session attributes.", "methods": ["permanent", "permanent"], "attributes": ["new", "modified", "accessed"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 24, "end_line": 49}, "type": "class"}, {"name": "get", "is_method": true, "class_name": "SecureCookieSession", "parameters": ["self", "key", "default"], "calls": ["get", "super"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 88, "end_line": 90}, "code_snippet": "    def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)\n", "type": "function"}, {"name": "test_session_vary_cookie", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "app.route", "app.route", "app.route", "app.route", "app.route", "app.route", "expect", "expect", "expect", "expect", "expect", "expect", "expect", "expect", "flask.session.get", "flask.session.setdefault", "flask.session.clear", "flask.Response", "response.vary.add", "flask.Response", "response.vary.update", "client.get", "len", "rv.headers.get_all"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 520, "end_line": 578}, "code_snippet": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)\n", "type": "function"}, {"name": "test_session_using_samesite_attribute", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.config.update", "app.config.update", "client.get", "lower", "app.config.update", "client.get", "lower", "app.config.update", "client.get", "lower", "pytest.raises", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 334, "end_line": 358}, "code_snippet": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie\n", "type": "function"}, {"name": "NullSession", "docstring": "Class used to generate nicer error messages if sessions are not\navailable.  Will still allow read-only access to the empty session\nbut fail on setting.", "methods": ["_fail"], "attributes": ["__setitem__", "__delitem__", "clear", "pop", "popitem", "update", "setdefault"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 97, "end_line": 111}, "type": "class"}, {"name": "test_session_refresh_vary", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.get", "app.get", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 581, "end_line": 595}, "code_snippet": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2401726245880127}
{"question": "Why does the CLI helper class that manages Flask application discovery implement lazy loading through a cached instance attribute rather than during initialization?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "load_app", "is_method": true, "class_name": "ScriptInfo", "parameters": ["self"], "calls": ["self.create_app", "NoAppException", "get_debug_flag", "prepare_import", "locate_app", "prepare_import", "locate_app", "re.split"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 333, "end_line": 372}, "code_snippet": "    def load_app(self) -> Flask:\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        if self._loaded_app is not None:\n            return self._loaded_app\n        app: Flask | None = None\n        if self.create_app is not None:\n            app = self.create_app()\n        else:\n            if self.app_import_path:\n                path, name = (\n                    re.split(r\":(?![\\\\/])\", self.app_import_path, maxsplit=1) + [None]\n                )[:2]\n                import_name = prepare_import(path)\n                app = locate_app(import_name, name)\n            else:\n                for path in (\"wsgi.py\", \"app.py\"):\n                    import_name = prepare_import(path)\n                    app = locate_app(import_name, None, raise_if_not_found=False)\n\n                    if app is not None:\n                        break\n\n        if app is None:\n            raise NoAppException(\n                \"Could not locate a Flask application. Use the\"\n                \" 'flask --app' option, 'FLASK_APP' environment\"\n                \" variable, or a 'wsgi.py' or 'app.py' file in the\"\n                \" current directory.\"\n            )\n\n        if self.set_debug_flag:\n            # Update the app's debug flag through the descriptor so that\n            # other values repopulate as well.\n            app.debug = get_debug_flag()\n\n        self._loaded_app = app\n        return app\n", "type": "function"}, {"name": "ScriptInfo", "docstring": "Helper object to deal with Flask applications.  This is usually not\nnecessary to interface with as it's used internally in the dispatching\nto click.  In future versions of Flask this object will most likely play\na bigger role.  Typically it's created automatically by the\n:class:`FlaskGroup` but you can also manually create it and pass it\nonwards as click object.\n\n.. versionchanged:: 3.1\n    Added the ``load_dotenv_defaults`` parameter and attribute.", "methods": ["__init__", "load_app"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 293, "end_line": 372}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "name", "import_name", "static_folder", "static_url_path", "template_folder", "url_prefix", "subdomain", "url_defaults", "root_path", "cli_group"], "calls": ["__init__", "AppGroup", "super"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 19, "end_line": 53}, "code_snippet": "    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "add_default_commands", "create_app", "add_version_option", "load_dotenv", "set_debug_flag"], "calls": ["list", "params.extend", "setdefault", "__init__", "params.append", "self.add_command", "self.add_command", "self.add_command", "extra.pop", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 563, "end_line": 598}, "code_snippet": "    def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params: list[click.Parameter] = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n", "type": "function"}, {"name": "invoke", "is_method": true, "class_name": "TestRoutes", "parameters": ["self", "app", "runner"], "calls": ["FlaskGroup", "partial"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 459, "end_line": 461}, "code_snippet": "    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n", "type": "function"}, {"name": "get_command", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "ctx", "name"], "calls": ["self._load_plugin_commands", "get_command", "ctx.ensure_object", "app.cli.get_command", "info.load_app", "ctx.with_resource", "super", "click.secho", "current_app._get_current_object", "app.app_context", "e.format_message"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 609, "end_line": 634}, "code_snippet": "    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:\n        self._load_plugin_commands()\n        # Look up built-in and plugin commands, which should be\n        # available even if the app fails to load.\n        rv = super().get_command(ctx, name)\n\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Look up commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            app = info.load_app()\n        except NoAppException as e:\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n            return None\n\n        # Push an app context for the loaded app unless it is already\n        # active somehow. This makes the context available to parameter\n        # and command callbacks without needing @with_appcontext.\n        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]\n            ctx.with_resource(app.app_context())\n\n        return app.cli.get_command(ctx, name)\n", "type": "function"}, {"name": "test_help_echo_loading_error", "is_method": false, "class_name": null, "parameters": [], "calls": ["runner.invoke", "CliRunner", "CliRunner"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 413, "end_line": 425}, "code_snippet": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout\n", "type": "function"}, {"name": "locate_app", "is_method": false, "class_name": null, "parameters": ["module_name", "app_name", "raise_if_not_found"], "calls": ["__import__", "find_best_app", "find_app_by_string", "NoAppException", "sys.exc_info", "NoAppException", "traceback.format_exc"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 241, "end_line": 264}, "code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)\n", "type": "function"}, {"name": "test_find_best_app", "is_method": false, "class_name": null, "parameters": ["test_apps"], "calls": ["find_best_app", "isinstance", "find_best_app", "isinstance", "find_best_app", "isinstance", "pytest.raises", "pytest.raises", "pytest.raises", "pytest.raises", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "find_best_app", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "Flask", "TypeError"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 48, "end_line": 132}, "code_snippet": "def test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)\n", "type": "function"}, {"name": "FlaskGroup", "docstring": "Special subclass of the :class:`AppGroup` group that supports\nloading more commands from the configured Flask app.  Normally a\ndeveloper does not have to interface with this class but there are\nsome very advanced use cases for which it makes sense to create an\ninstance of this. see :ref:`custom-scripts`.\n\n:param add_default_commands: if this is True then the default run and\n    shell commands will be added.\n:param add_version_option: adds the ``--version`` option.\n:param create_app: an optional callback that is passed the script info and\n    returns the loaded app.\n:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n    files to set environment variables. Will also change the working\n    directory to the directory containing the first file found.\n:param set_debug_flag: Set the app's debug flag.\n\n.. versionchanged:: 3.1\n    ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.\n\n.. versionchanged:: 2.2\n    Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.\n\n.. versionchanged:: 2.2\n    An app context is pushed when running ``app.cli`` commands, so\n    ``@with_appcontext`` is no longer required for those commands.\n\n.. versionchanged:: 1.0\n    If installed, python-dotenv will be used to load environment variables\n    from :file:`.env` and :file:`.flaskenv` files.", "methods": ["__init__", "_load_plugin_commands", "get_command", "list_commands", "make_context", "parse_args"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 531, "end_line": 688}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.27402925491333}
{"question": "Why does repeated invocation of the method that instantiates cryptographic serializers within the session persistence handler create a performance bottleneck under high-concurrency conditions?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_signing_serializer", "is_method": true, "class_name": "SecureCookieSessionInterface", "parameters": ["self", "app"], "calls": ["keys.append", "URLSafeTimedSerializer", "keys.extend"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 317, "end_line": 335}, "code_snippet": "    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n        if not app.secret_key:\n            return None\n\n        keys: list[str | bytes] = []\n\n        if fallbacks := app.config[\"SECRET_KEY_FALLBACKS\"]:\n            keys.extend(fallbacks)\n\n        keys.append(app.secret_key)  # itsdangerous expects current key at top\n        return URLSafeTimedSerializer(\n            keys,  # type: ignore[arg-type]\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs={\n                \"key_derivation\": self.key_derivation,\n                \"digest_method\": self.digest_method,\n            },\n        )\n", "type": "function"}, {"name": "open_session", "is_method": true, "class_name": "SecureCookieSessionInterface", "parameters": ["self", "app", "request"], "calls": ["self.get_signing_serializer", "request.cookies.get", "int", "self.get_cookie_name", "self.session_class", "app.permanent_session_lifetime.total_seconds", "s.loads", "self.session_class", "self.session_class"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 337, "end_line": 349}, "code_snippet": "    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n", "type": "function"}, {"name": "_lazy_sha1", "is_method": false, "class_name": null, "parameters": ["string"], "calls": ["hashlib.sha1"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 290, "end_line": 295}, "code_snippet": "def _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)\n", "type": "function"}, {"name": "_fail", "is_method": true, "class_name": "NullSession", "parameters": ["self"], "calls": ["RuntimeError"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 103, "end_line": 108}, "code_snippet": "    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n", "type": "function"}, {"name": "SecureCookieSession", "docstring": "Base class for sessions based on signed cookies.\n\nThis session backend will set the :attr:`modified` and\n:attr:`accessed` attributes. It cannot reliably track whether a\nsession is new (vs. empty), so :attr:`new` remains hard coded to\n``False``.", "methods": ["__init__", "__getitem__", "get", "setdefault"], "attributes": ["modified", "accessed"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 52, "end_line": 94}, "type": "class"}, {"name": "SecureCookieSessionInterface", "docstring": "The default session interface that stores sessions in signed cookies\nthrough the :mod:`itsdangerous` module.", "methods": ["get_signing_serializer", "open_session", "save_session"], "attributes": ["salt", "digest_method", "key_derivation", "serializer", "session_class"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 298, "end_line": 399}, "type": "class"}, {"name": "test_session_transactions_no_null_sessions", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.test_client", "pytest.raises", "str", "c.session_transaction"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 186, "end_line": 193}, "code_snippet": "def test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)\n", "type": "function"}, {"name": "test_run_cert_adhoc", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setitem", "monkeypatch.setitem", "run_command.make_context", "pytest.raises", "run_command.make_context", "types.ModuleType", "pytest.raises", "run_command.make_context"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 602, "end_line": 616}, "code_snippet": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\n", "type": "function"}, {"name": "TaggedJSONSerializer", "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`", "methods": ["__init__", "register", "tag", "untag", "_untag_scan", "dumps", "loads"], "attributes": ["__slots__", "default_tags"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 219, "end_line": 327}, "type": "class"}, {"name": "test_session_secret_key_fallbacks", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.post", "app.get", "client.post", "dict", "client.get", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 374, "end_line": 399}, "code_snippet": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key, and two valid expiring keys\n    app.secret_key, app.config[\"SECRET_KEY_FALLBACKS\"] = (\n        \"0 key\",\n        [\"-1 key\", \"-2 key\"],\n    )\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"? key\"\n    assert client.get().json == {}\n    # Rotate the valid keys, session can be loaded\n    app.secret_key, app.config[\"SECRET_KEY_FALLBACKS\"] = (\n        \"+1 key\",\n        [\"0 key\", \"-1 key\"],\n    )\n    assert client.get().json == {\"a\": 1}\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3379354476928711}
{"question": "Why does the pass-through dictionary tag class's JSON conversion method apply recursive tagging only to dictionary values while avoiding tagging keys?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "tag", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": ["self.to_json"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 87, "end_line": 90}, "code_snippet": "    def tag(self, value: t.Any) -> dict[str, t.Any]:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 77, "end_line": 80}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "TagDict", "docstring": "Tag for 1-item dicts whose only key matches a registered tag.\n\nInternally, the dict key is suffixed with `__`, and the suffix is removed\nwhen deserializing.", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 93, "end_line": 116}, "type": "class"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "tag", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["tag.check", "tag.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 289, "end_line": 295}, "code_snippet": "    def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n", "type": "function"}, {"name": "to_python", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 82, "end_line": 85}, "code_snippet": "    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "_untag_scan", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["isinstance", "self.untag", "isinstance", "self._untag_scan", "value.items", "self._untag_scan"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 309, "end_line": 319}, "code_snippet": "    def _untag_scan(self, value: t.Any) -> t.Any:\n        if isinstance(value, dict):\n            # untag each item recursively\n            value = {k: self._untag_scan(v) for k, v in value.items()}\n            # untag the dict itself\n            value = self.untag(value)\n        elif isinstance(value, list):\n            # untag each item recursively\n            value = [self._untag_scan(item) for item in value]\n\n        return value\n", "type": "function"}, {"name": "dumps", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["dumps", "self.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 321, "end_line": 323}, "code_snippet": "    def dumps(self, value: t.Any) -> str:\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.334881067276001}
{"question": "Why does the test that checks handler behavior when a stream handler exists on the root logger verify that the application logger's handlers list is empty after adding a stream handler to the root logger?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_existing_handler", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["logging.root.addHandler", "logging.StreamHandler"], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 48, "end_line": 51}, "code_snippet": "def test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n", "type": "function"}, {"name": "test_has_level_handler", "is_method": false, "class_name": null, "parameters": [], "calls": ["logging.getLogger", "logging.StreamHandler", "logging.root.addHandler", "has_level_handler", "handler.setLevel", "has_level_handler", "has_level_handler", "has_level_handler"], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 70, "end_line": 83}, "code_snippet": "def test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n", "type": "function"}, {"name": "test_logger", "is_method": false, "class_name": null, "parameters": ["app"], "calls": [], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 36, "end_line": 39}, "code_snippet": "def test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n", "type": "function"}, {"name": "test_logger_debug", "is_method": false, "class_name": null, "parameters": ["app"], "calls": [], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 42, "end_line": 45}, "code_snippet": "def test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n", "type": "function"}, {"name": "test_wsgi_errors_stream", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "StringIO", "client.get", "app.logger.error", "stream.getvalue", "wsgi_errors_stream._get_current_object", "app.test_request_context", "wsgi_errors_stream._get_current_object"], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 54, "end_line": 67}, "code_snippet": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n", "type": "function"}, {"name": "test_log_view_exception", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "StringIO", "client.get", "stream.getvalue", "Exception"], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 86, "end_line": 98}, "code_snippet": "def test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err\n", "type": "function"}, {"name": "reset_logging", "is_method": false, "class_name": null, "parameters": ["pytestconfig"], "calls": ["pytest.fixture", "logging.getLogger", "logger.setLevel", "pytestconfig.pluginmanager.unregister", "logging.root.setLevel", "logger.setLevel", "pytestconfig.pluginmanager.register"], "code_location": {"file": "test_logging.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 13, "end_line": 33}, "code_snippet": "def reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n", "type": "function"}, {"name": "test_suppressed_exception_logging", "is_method": false, "class_name": null, "parameters": [], "calls": ["StringIO", "SuppressedFlask", "app.route", "get", "Exception", "out.getvalue", "app.test_client"], "code_location": {"file": "test_subclassing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 6, "end_line": 21}, "code_snippet": "def test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()\n", "type": "function"}, {"name": "test_teardown_request_handler_debug_mode", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.get", "called.append", "len"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 773, "end_line": 788}, "code_snippet": "def test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n", "type": "function"}, {"name": "test_app_tearing_down_with_handled_exception_by_app_handler", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.errorhandler", "cleanup_stuff.append", "Exception", "flask.jsonify", "app.app_context", "client.get", "str"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 91, "end_line": 110}, "code_snippet": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3257148265838623}
{"question": "Where does the application root path get transformed during initialization when instance-relative configuration mode is enabled before reaching the configuration storage object?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "make_config", "is_method": true, "class_name": "App", "parameters": ["self", "instance_relative"], "calls": ["dict", "get_debug_flag", "self.config_class"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 482, "end_line": 496}, "code_snippet": "    def make_config(self, instance_relative: bool = False) -> Config:\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n", "type": "function"}, {"name": "test_explicit_instance_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path"], "calls": ["flask.Flask", "pytest.raises", "flask.Flask", "os.fspath", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 8, "end_line": 13}, "code_snippet": "def test_explicit_instance_paths(modules_tmp_path):\n    with pytest.raises(ValueError, match=\".*must be absolute\"):\n        flask.Flask(__name__, instance_path=\"instance\")\n\n    app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))\n    assert app.instance_path == os.fspath(modules_tmp_path)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "App", "parameters": ["self", "import_name", "static_url_path", "static_folder", "static_host", "host_matching", "subdomain_matching", "template_folder", "instance_path", "instance_relative_config", "root_path"], "calls": ["__init__", "self.make_config", "self.make_aborter", "self.json_provider_class", "self.url_map_class", "self.auto_find_instance_path", "super", "os.path.isabs", "ValueError"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 282, "end_line": 411}, "code_snippet": "    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ) -> None:\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n", "type": "function"}, {"name": "test_installed_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "modules_tmp_path_prefix", "purge_module", "monkeypatch"], "calls": ["installed_path.mkdir", "monkeypatch.syspath_prepend", "app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 80, "end_line": 96}, "code_snippet": "def test_installed_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )\n", "type": "function"}, {"name": "test_uninstalled_package_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "purge_module"], "calls": ["app.mkdir", "write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 30, "end_line": 43}, "code_snippet": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")\n", "type": "function"}, {"name": "test_session_using_application_root", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["PrefixPathMiddleware", "app.config.update", "app.route", "client.get", "lower", "self.app"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 269, "end_line": 288}, "code_snippet": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Config", "parameters": ["self", "root_path", "defaults"], "calls": ["__init__", "super"], "code_location": {"file": "config.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 94, "end_line": 100}, "code_snippet": "    def __init__(\n        self,\n        root_path: str | os.PathLike[str],\n        defaults: dict[str, t.Any] | None = None,\n    ) -> None:\n        super().__init__(defaults or {})\n        self.root_path = root_path\n", "type": "function"}, {"name": "test_uninstalled_module_paths", "is_method": false, "class_name": null, "parameters": ["modules_tmp_path", "purge_module"], "calls": ["write_text", "purge_module", "os.fspath"], "code_location": {"file": "test_instance_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 16, "end_line": 27}, "code_snippet": "def test_uninstalled_module_paths(modules_tmp_path, purge_module):\n    (modules_tmp_path / \"config_module_app.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")\n", "type": "function"}, {"name": "test_environ_defaults_from_config", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.test_request_context", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 15, "end_line": 27}, "code_snippet": "def test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"\n", "type": "function"}, {"name": "test_session_path", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.config.update", "app.route", "client.get", "lower"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 257, "end_line": 266}, "code_snippet": "def test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34450697898864746}
{"question": "Where does the control flow in the CLI group class's command retrieval method determine whether to return a directly registered command, an entry point loaded command, or an application CLI group command?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_command", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "ctx", "name"], "calls": ["self._load_plugin_commands", "get_command", "ctx.ensure_object", "app.cli.get_command", "info.load_app", "ctx.with_resource", "super", "click.secho", "current_app._get_current_object", "app.app_context", "e.format_message"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 609, "end_line": 634}, "code_snippet": "    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:\n        self._load_plugin_commands()\n        # Look up built-in and plugin commands, which should be\n        # available even if the app fails to load.\n        rv = super().get_command(ctx, name)\n\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Look up commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            app = info.load_app()\n        except NoAppException as e:\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n            return None\n\n        # Push an app context for the loaded app unless it is already\n        # active somehow. This makes the context available to parameter\n        # and command callbacks without needing @with_appcontext.\n        if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]\n            ctx.with_resource(app.app_context())\n\n        return app.cli.get_command(ctx, name)\n", "type": "function"}, {"name": "AppGroup", "docstring": "This works similar to a regular click :class:`~click.Group` but it\nchanges the behavior of the :meth:`command` decorator so that it\nautomatically wraps the functions in :func:`with_appcontext`.\n\nNot to be confused with :class:`FlaskGroup`.", "methods": ["command", "group"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 405, "end_line": 437}, "type": "class"}, {"name": "list_commands", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "ctx"], "calls": ["self._load_plugin_commands", "set", "ctx.ensure_object", "sorted", "list_commands", "rv.update", "cli.list_commands", "click.secho", "click.secho", "super", "info.load_app", "e.format_message", "traceback.format_exc"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 636, "end_line": 655}, "code_snippet": "    def list_commands(self, ctx: click.Context) -> list[str]:\n        self._load_plugin_commands()\n        # Start with the built-in and plugin commands.\n        rv = set(super().list_commands(ctx))\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Add commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except NoAppException as e:\n            # When an app couldn't be loaded, show the error message\n            # without the traceback.\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n        except Exception:\n            # When any other errors occurred during loading, show the\n            # full traceback.\n            click.secho(f\"{traceback.format_exc()}\\n\", err=True, fg=\"red\")\n\n        return sorted(rv)\n", "type": "function"}, {"name": "command", "is_method": true, "class_name": "AppGroup", "parameters": ["self"], "calls": ["kwargs.pop", "with_appcontext", "command", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 413, "end_line": 427}, "code_snippet": "    def command(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f: t.Callable[..., t.Any]) -> click.Command:\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]\n\n        return decorator\n", "type": "function"}, {"name": "group", "is_method": true, "class_name": "AppGroup", "parameters": ["self"], "calls": ["kwargs.setdefault", "group", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 429, "end_line": 437}, "code_snippet": "    def group(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault(\"cls\", AppGroup)\n        return super().group(*args, **kwargs)  # type: ignore[no-any-return]\n", "type": "function"}, {"name": "FlaskGroup", "docstring": "Special subclass of the :class:`AppGroup` group that supports\nloading more commands from the configured Flask app.  Normally a\ndeveloper does not have to interface with this class but there are\nsome very advanced use cases for which it makes sense to create an\ninstance of this. see :ref:`custom-scripts`.\n\n:param add_default_commands: if this is True then the default run and\n    shell commands will be added.\n:param add_version_option: adds the ``--version`` option.\n:param create_app: an optional callback that is passed the script info and\n    returns the loaded app.\n:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n    files to set environment variables. Will also change the working\n    directory to the directory containing the first file found.\n:param set_debug_flag: Set the app's debug flag.\n\n.. versionchanged:: 3.1\n    ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.\n\n.. versionchanged:: 2.2\n    Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.\n\n.. versionchanged:: 2.2\n    An app context is pushed when running ``app.cli`` commands, so\n    ``@with_appcontext`` is no longer required for those commands.\n\n.. versionchanged:: 1.0\n    If installed, python-dotenv will be used to load environment variables\n    from :file:`.env` and :file:`.flaskenv` files.", "methods": ["__init__", "_load_plugin_commands", "get_command", "list_commands", "make_context", "parse_args"], "attributes": [], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 531, "end_line": 688}, "type": "class"}, {"name": "invoke", "is_method": true, "class_name": "TestRoutes", "parameters": ["self", "app", "runner"], "calls": ["FlaskGroup", "partial"], "code_location": {"file": "test_cli.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 459, "end_line": 461}, "code_snippet": "    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n", "type": "function"}, {"name": "parse_args", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "ctx", "args"], "calls": ["parse_args", "_env_file_option.handle_parse_result", "_app_option.handle_parse_result", "super", "len", "self.get_help_option_names"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 678, "end_line": 688}, "code_snippet": "    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n        if (not args and self.no_args_is_help) or (\n            len(args) == 1 and args[0] in self.get_help_option_names(ctx)\n        ):\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n        return super().parse_args(ctx, args)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "add_default_commands", "create_app", "add_version_option", "load_dotenv", "set_debug_flag"], "calls": ["list", "params.extend", "setdefault", "__init__", "params.append", "self.add_command", "self.add_command", "self.add_command", "extra.pop", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 563, "end_line": 598}, "code_snippet": "    def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params: list[click.Parameter] = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n", "type": "function"}, {"name": "make_context", "is_method": true, "class_name": "FlaskGroup", "parameters": ["self", "info_name", "args", "parent"], "calls": ["make_context", "ScriptInfo", "super"], "code_location": {"file": "cli.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 657, "end_line": 676}, "code_snippet": "    def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app,\n                set_debug_flag=self.set_debug_flag,\n                load_dotenv_defaults=self.load_dotenv,\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3428812026977539}
{"question": "Where in the serialization pipeline for the JSON tag class that handles Markup API objects are the lower-level helper functions that the conversion method delegates to?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "to_json", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 77, "end_line": 80}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "TagMarkup", "docstring": "Serialize anything matching the :class:`~markupsafe.Markup` API by\nhaving a ``__html__`` method to the result of that method. Always\ndeserializes to an instance of :class:`~markupsafe.Markup`.", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 173, "end_line": 188}, "type": "class"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "to_json", "is_method": true, "class_name": "PassList", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 153, "end_line": 154}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagTuple", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 140, "end_line": 141}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "TaggedJSONSerializer", "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`", "methods": ["__init__", "register", "tag", "untag", "_untag_scan", "dumps", "loads"], "attributes": ["__slots__", "default_tags"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 219, "end_line": 327}, "type": "class"}, {"name": "tag", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": ["self.to_json"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 87, "end_line": 90}, "code_snippet": "    def tag(self, value: t.Any) -> dict[str, t.Any]:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n", "type": "function"}, {"name": "test_tag_interface", "is_method": false, "class_name": null, "parameters": [], "calls": ["JSONTag", "pytest.raises", "pytest.raises", "pytest.raises"], "code_location": {"file": "test_json_tag.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 66, "end_line": 70}, "code_snippet": "def test_tag_interface():\n    t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3539409637451172}
{"question": "Where does the list serialization tag's item conversion method interact with the serializer's type dispatcher to recursively process nested list structures containing mixed types?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "to_json", "is_method": true, "class_name": "PassList", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 153, "end_line": 154}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagTuple", "parameters": ["self", "value"], "calls": ["self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 140, "end_line": 141}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "type": "function"}, {"name": "_untag_scan", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["isinstance", "self.untag", "isinstance", "self._untag_scan", "value.items", "self._untag_scan"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 309, "end_line": 319}, "code_snippet": "    def _untag_scan(self, value: t.Any) -> t.Any:\n        if isinstance(value, dict):\n            # untag each item recursively\n            value = {k: self._untag_scan(v) for k, v in value.items()}\n            # untag the dict itself\n            value = self.untag(value)\n        elif isinstance(value, list):\n            # untag each item recursively\n            value = [self._untag_scan(item) for item in value]\n\n        return value\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagDict", "parameters": ["self", "value"], "calls": ["next", "iter", "self.serializer.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 110, "end_line": 112}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "type": "function"}, {"name": "tag", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["tag.check", "tag.tag"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 289, "end_line": 295}, "code_snippet": "    def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 77, "end_line": 80}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "untag", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["next", "to_python", "len", "iter"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 297, "end_line": 307}, "code_snippet": "    def untag(self, value: dict[str, t.Any]) -> t.Any:\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n", "type": "function"}, {"name": "TagDict", "docstring": "Tag for 1-item dicts whose only key matches a registered tag.\n\nInternally, the dict key is suffixed with `__`, and the suffix is removed\nwhen deserializing.", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 93, "end_line": 116}, "type": "class"}, {"name": "to_python", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 82, "end_line": 85}, "code_snippet": "    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.35068607330322266}
{"question": "Where is the control flow determining whether a routing rule receives OPTIONS, including branches evaluating the automatic options flag and the application configuration setting?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_provide_automatic_options_attr", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "open", "flask.Flask", "open", "app.route", "app.route", "sorted", "app.test_client", "app.test_client"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 70, "end_line": 89}, "code_snippet": "def test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n", "type": "function"}, {"name": "test_provide_automatic_options_kwarg", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "app.add_url_rule", "client.post", "client.open", "client.head", "client.delete", "client.open", "sorted", "sorted", "client.get", "client.post", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 92, "end_line": 126}, "code_snippet": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n", "type": "function"}, {"name": "test_view_provide_automatic_options_attr", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "flask.Flask", "app.add_url_rule", "app.test_client", "c.open", "sorted", "Index1.as_view", "Index2.as_view", "Index3.as_view"], "code_location": {"file": "test_views.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 101, "end_line": 138}, "code_snippet": "def test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow\n", "type": "function"}, {"name": "test_options_on_multiple_rules", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "client.open", "sorted"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 40, "end_line": 50}, "code_snippet": "def test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n", "type": "function"}, {"name": "add_url_rule", "is_method": true, "class_name": "App", "parameters": ["self", "rule", "endpoint", "view_func", "provide_automatic_options"], "calls": ["options.pop", "isinstance", "set", "self.url_rule_class", "self.url_map.add", "_endpoint_from_view_func", "TypeError", "item.upper", "getattr", "getattr", "self.view_functions.get", "getattr", "required_methods.add", "AssertionError"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 605, "end_line": 661}, "code_snippet": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n", "type": "function"}, {"name": "test_options_work", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "client.open", "sorted"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 30, "end_line": 37}, "code_snippet": "def test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n", "type": "function"}, {"name": "test_url_mapping", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.add_url_rule", "app.add_url_rule", "app.add_url_rule", "client.post", "client.head", "client.delete", "client.open", "sorted", "sorted", "rv.data.decode", "client.get", "client.post", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 157, "end_line": 190}, "code_snippet": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n", "type": "function"}, {"name": "add_url_rule", "is_method": true, "class_name": "Scaffold", "parameters": ["self", "rule", "endpoint", "view_func", "provide_automatic_options"], "calls": [], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 368, "end_line": 433}, "code_snippet": "    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "_method_route", "is_method": true, "class_name": "Scaffold", "parameters": ["self", "method", "rule", "options"], "calls": ["self.route", "TypeError"], "code_location": {"file": "scaffold.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 284, "end_line": 293}, "code_snippet": "    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n", "type": "function"}, {"name": "make_default_options_response", "is_method": true, "class_name": "Flask", "parameters": ["self"], "calls": ["adapter.allowed_methods", "self.response_class", "rv.allow.update"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 953, "end_line": 964}, "code_snippet": "    def make_default_options_response(self) -> Response:\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = request_ctx.url_adapter\n        methods = adapter.allowed_methods()  # type: ignore[union-attr]\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3442826271057129}
{"question": "Where does the encoding parameter flow from the test function that verifies resource opening with encoding into the Flask application's method that opens files relative to the root path?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_open_resource_with_encoding", "is_method": false, "class_name": null, "parameters": ["tmp_path", "encoding"], "calls": ["pytest.mark.parametrize", "flask.Flask", "write_text", "app.open_resource", "os.fspath", "f.read"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 355, "end_line": 360}, "code_snippet": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"\n", "type": "function"}, {"name": "open_resource", "is_method": true, "class_name": "Flask", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "ValueError", "open"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 330, "end_line": 361}, "code_snippet": "    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = None\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading.\n\n        For example, if the file ``schema.sql`` is next to the file\n        ``app.py`` where the ``Flask`` app is defined, it can be opened\n        with:\n\n        .. code-block:: python\n\n            with app.open_resource(\"schema.sql\") as f:\n                conn.executescript(f.read())\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "test_open_resource", "is_method": false, "class_name": null, "parameters": ["mode"], "calls": ["pytest.mark.parametrize", "flask.Flask", "app.open_resource", "str", "f.read"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 339, "end_line": 343}, "code_snippet": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())\n", "type": "function"}, {"name": "open_resource", "is_method": true, "class_name": "Blueprint", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "ValueError", "open"], "code_location": {"file": "blueprints.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 104, "end_line": 128}, "code_snippet": "    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading. The\n        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\n        method.\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "test_open_resource_exceptions", "is_method": false, "class_name": null, "parameters": ["mode"], "calls": ["pytest.mark.parametrize", "flask.Flask", "pytest.raises", "app.open_resource"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 347, "end_line": 351}, "code_snippet": "def test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)\n", "type": "function"}, {"name": "open_instance_resource", "is_method": true, "class_name": "Flask", "parameters": ["self", "resource", "mode", "encoding"], "calls": ["os.path.join", "open", "open"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 363, "end_line": 383}, "code_snippet": "    def open_instance_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to the application's instance folder\n        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the\n        instance folder can be opened for writing.\n\n        :param resource: Path to the resource relative to :attr:`instance_path`.\n        :param mode: Open the file in this mode.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        path = os.path.join(self.instance_path, resource)\n\n        if \"b\" in mode:\n            return open(path, mode)\n\n        return open(path, mode, encoding=encoding)\n", "type": "function"}, {"name": "test_from_pyfile_weird_encoding", "is_method": false, "class_name": null, "parameters": ["tmp_path", "encoding"], "calls": ["pytest.mark.parametrize", "f.write_text", "flask.Flask", "app.config.from_pyfile", "os.fspath"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 244, "end_line": 250}, "code_snippet": "def test_from_pyfile_weird_encoding(tmp_path, encoding):\n    f = tmp_path / \"my_config.py\"\n    f.write_text(f'# -*- coding: {encoding} -*-\\nTEST_VALUE = \"f\"\\n', encoding)\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(os.fspath(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\"\n", "type": "function"}, {"name": "test_send_from_directory", "is_method": true, "class_name": "TestSendfile", "parameters": ["self", "app", "req_ctx"], "calls": ["os.path.join", "flask.send_from_directory", "rv.close", "os.path.dirname", "rv.data.strip"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 92, "end_line": 99}, "code_snippet": "    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n", "type": "function"}, {"name": "test_send_file", "is_method": true, "class_name": "TestSendfile", "parameters": ["self", "app", "req_ctx"], "calls": ["flask.send_file", "rv.close", "app.open_resource", "f.read"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 34, "end_line": 43}, "code_snippet": "    def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()\n", "type": "function"}, {"name": "test_static_folder_with_pathlib_path", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Flask", "open", "rv.close", "Path", "app.test_client"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1448, "end_line": 1454}, "code_snippet": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.33536243438720703}
{"question": "Where does the base64-decoding method for byte sequence tags get invoked during the recursive untagging process after JSON parsing?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_untag_scan", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["isinstance", "self.untag", "isinstance", "self._untag_scan", "value.items", "self._untag_scan"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 309, "end_line": 319}, "code_snippet": "    def _untag_scan(self, value: t.Any) -> t.Any:\n        if isinstance(value, dict):\n            # untag each item recursively\n            value = {k: self._untag_scan(v) for k, v in value.items()}\n            # untag the dict itself\n            value = self.untag(value)\n        elif isinstance(value, list):\n            # untag each item recursively\n            value = [self._untag_scan(item) for item in value]\n\n        return value\n", "type": "function"}, {"name": "TagBytes", "docstring": "", "methods": ["check", "to_json", "to_python"], "attributes": ["__slots__", "key"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 159, "end_line": 170}, "type": "class"}, {"name": "loads", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["self._untag_scan", "loads"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 325, "end_line": 327}, "code_snippet": "    def loads(self, value: str) -> t.Any:\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return self._untag_scan(loads(value))\n", "type": "function"}, {"name": "to_python", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 82, "end_line": 85}, "code_snippet": "    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "JSONTag", "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.", "methods": ["__init__", "check", "to_json", "to_python", "tag"], "attributes": ["__slots__"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 60, "end_line": 90}, "type": "class"}, {"name": "untag", "is_method": true, "class_name": "TaggedJSONSerializer", "parameters": ["self", "value"], "calls": ["next", "to_python", "len", "iter"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 297, "end_line": 307}, "code_snippet": "    def untag(self, value: dict[str, t.Any]) -> t.Any:\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "PassDict", "parameters": ["self", "value"], "calls": ["self.serializer.tag", "value.items"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 125, "end_line": 128}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "TagBytes", "parameters": ["self", "value"], "calls": ["decode", "b64encode"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 166, "end_line": 167}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        return b64encode(value).decode(\"ascii\")\n", "type": "function"}, {"name": "to_python", "is_method": true, "class_name": "TagBytes", "parameters": ["self", "value"], "calls": ["b64decode"], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 169, "end_line": 170}, "code_snippet": "    def to_python(self, value: t.Any) -> t.Any:\n        return b64decode(value)\n", "type": "function"}, {"name": "to_json", "is_method": true, "class_name": "JSONTag", "parameters": ["self", "value"], "calls": [], "code_location": {"file": "tag.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/json", "start_line": 77, "end_line": 80}, "code_snippet": "    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3449215888977051}
{"question": "Where is the test class that validates URL generation with anchors, schemes, and HTTP methods defined?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_url_for_with_anchor", "is_method": true, "class_name": "TestUrlFor", "parameters": ["self", "app", "req_ctx"], "calls": ["app.route", "flask.url_for"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 103, "end_line": 108}, "code_snippet": "    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"\n", "type": "function"}, {"name": "TestUrlFor", "docstring": "", "methods": ["test_url_for_with_anchor", "test_url_for_with_scheme", "test_url_for_with_scheme_not_external", "test_url_for_with_alternating_schemes", "test_url_with_method", "test_url_for_with_self"], "attributes": [], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 102, "end_line": 169}, "type": "class"}, {"name": "test_url_generation", "is_method": false, "class_name": null, "parameters": ["app", "req_ctx"], "calls": ["app.route", "flask.url_for", "flask.url_for"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1339, "end_line": 1348}, "code_snippet": "def test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )\n", "type": "function"}, {"name": "test_basic_url_generation", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.route", "app.app_context", "flask.url_for"], "code_location": {"file": "test_appctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 8, "end_line": 18}, "code_snippet": "def test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n", "type": "function"}, {"name": "test_url_for_passes_special_values_to_build_error_handler", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.test_request_context", "flask.url_for"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1388, "end_line": 1400}, "code_snippet": "def test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")\n", "type": "function"}, {"name": "test_url_for_with_scheme", "is_method": true, "class_name": "TestUrlFor", "parameters": ["self", "app", "req_ctx"], "calls": ["app.route", "flask.url_for"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 110, "end_line": 118}, "code_snippet": "    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n", "type": "function"}, {"name": "test_url_with_method", "is_method": true, "class_name": "TestUrlFor", "parameters": ["self", "app", "req_ctx"], "calls": ["MyView.as_view", "app.add_url_rule", "app.add_url_rule", "app.add_url_rule", "flask.url_for", "flask.url_for", "flask.url_for"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 143, "end_line": 162}, "code_snippet": "    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"\n", "type": "function"}, {"name": "test_url_for_with_scheme_not_external", "is_method": true, "class_name": "TestUrlFor", "parameters": ["self", "app", "req_ctx"], "calls": ["app.add_url_rule", "flask.url_for", "pytest.raises", "flask.url_for"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 120, "end_line": 129}, "code_snippet": "    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)\n", "type": "function"}, {"name": "test_url_for_with_alternating_schemes", "is_method": true, "class_name": "TestUrlFor", "parameters": ["self", "app", "req_ctx"], "calls": ["app.route", "flask.url_for", "flask.url_for", "flask.url_for"], "code_location": {"file": "test_helpers.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 131, "end_line": 141}, "code_snippet": "    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n", "type": "function"}, {"name": "test_specify_url_scheme", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.test_request_context", "client.get"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 90, "end_line": 99}, "code_snippet": "def test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.35183048248291016}
{"question": "Where in the error handler resolution method does the lookup sequence traverse blueprint scopes then HTTP status codes then exception class method resolution order?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_error_handler_blueprint", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["flask.Blueprint", "bp.errorhandler", "bp.route", "app.errorhandler", "app.route", "app.register_blueprint", "app.test_client", "InternalServerError", "InternalServerError", "c.get", "c.get"], "code_location": {"file": "test_user_error_handler.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 136, "end_line": 160}, "code_snippet": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"\n", "type": "function"}, {"name": "_find_error_handler", "is_method": true, "class_name": "App", "parameters": ["self", "e", "blueprints"], "calls": ["self._get_exc_class_and_code", "type", "handler_map.get"], "code_location": {"file": "app.py", "path": "/data3/pwh/swebench-repos/flask/src/flask/sansio", "start_line": 823, "end_line": 846}, "code_snippet": "    def _find_error_handler(\n        self, e: Exception, blueprints: list[str]\n    ) -> ft.ErrorHandlerCallable | None:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None\n", "type": "function"}, {"name": "test_default_error_handler", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Blueprint", "bp.errorhandler", "bp.errorhandler", "bp.route", "bp.route", "flask.Flask", "app.errorhandler", "app.errorhandler", "app.route", "app.route", "app.register_blueprint", "app.test_client", "isinstance", "isinstance", "isinstance", "NotFound", "Forbidden", "isinstance", "isinstance", "isinstance", "Forbidden", "c.get", "c.get", "c.get", "c.get", "c.get"], "code_location": {"file": "test_user_error_handler.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 163, "end_line": 214}, "code_snippet": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"\n", "type": "function"}, {"name": "test_blueprint_specific_user_error_handling", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "blue.errorhandler", "blue.register_error_handler", "blue.route", "blue.route", "app.register_blueprint", "isinstance", "isinstance", "MyDecoratorException", "MyFunctionException", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 46, "end_line": 77}, "code_snippet": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n", "type": "function"}, {"name": "test_errorhandler_precedence", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.errorhandler", "app.errorhandler", "app.route", "app.route", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 999, "end_line": 1029}, "code_snippet": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"\n", "type": "function"}, {"name": "test_blueprint_specific_error_handling", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "flask.Blueprint", "flask.Blueprint", "frontend.errorhandler", "frontend.route", "backend.errorhandler", "backend.route", "sideend.route", "app.register_blueprint", "app.register_blueprint", "app.register_blueprint", "app.errorhandler", "flask.abort", "flask.abort", "flask.abort", "client.get", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 8, "end_line": 43}, "code_snippet": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"\n", "type": "function"}, {"name": "test_error_handler_subclass", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.errorhandler", "app.errorhandler", "app.route", "app.route", "app.route", "app.test_client", "isinstance", "isinstance", "ParentException", "ChildExceptionUnregistered", "ChildExceptionRegistered", "c.get", "c.get", "c.get"], "code_location": {"file": "test_user_error_handler.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 61, "end_line": 97}, "code_snippet": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"\n", "type": "function"}, {"name": "test_blueprint_app_error_handling", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["flask.Blueprint", "errors.app_errorhandler", "app.route", "flask.Blueprint", "forbidden_bp.route", "app.register_blueprint", "app.register_blueprint", "flask.abort", "flask.abort", "client.get", "client.get"], "code_location": {"file": "test_blueprints.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 80, "end_line": 101}, "code_snippet": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n", "type": "function"}, {"name": "test_error_handler_http_subclass", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.errorhandler", "app.errorhandler", "app.route", "app.route", "app.route", "app.test_client", "isinstance", "isinstance", "Forbidden", "ForbiddenSubclassRegistered", "ForbiddenSubclassUnregistered", "c.get", "c.get", "c.get"], "code_location": {"file": "test_user_error_handler.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 100, "end_line": 133}, "code_snippet": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"\n", "type": "function"}, {"name": "test_error_handler_no_match", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.errorhandler", "app.errorhandler", "app.route", "app.route", "app.route", "isinstance", "pytest.raises", "app.register_error_handler", "str", "pytest.raises", "app.register_error_handler", "str", "isinstance", "pytest.raises", "app.register_error_handler", "str", "CustomException", "KeyError", "flask.abort", "CustomException", "client.get", "client.get", "client.get", "type"], "code_location": {"file": "test_user_error_handler.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 10, "end_line": 58}, "code_snippet": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.36168622970581055}
{"question": "Where does the inheritance chain between parent and child configuration classes affect configuration resolution when loading from a class object?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_config_from_class", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.config.from_object", "common_object_test"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 132, "end_line": 141}, "code_snippet": "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)\n", "type": "function"}, {"name": "test_custom_config_class", "is_method": false, "class_name": null, "parameters": [], "calls": ["Flask", "isinstance", "app.config.from_object", "common_object_test"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 198, "end_line": 208}, "code_snippet": "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)\n", "type": "function"}, {"name": "test_config_from_object", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.config.from_object", "common_object_test"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 25, "end_line": 28}, "code_snippet": "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)\n", "type": "function"}, {"name": "ConfigAttribute", "docstring": "Makes an attribute forward to the config", "methods": ["__init__", "__get__", "__get__", "__get__", "__set__"], "attributes": [], "code_location": {"file": "config.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 20, "end_line": 47}, "type": "class"}, {"name": "Config", "docstring": "Works exactly like a dict but provides ways to fill it from files\nor special dictionaries.  There are two common patterns to populate the\nconfig.\n\nEither you can fill the config from a config file::\n\n    app.config.from_pyfile('yourconfig.cfg')\n\nOr alternatively you can define the configuration options in the\nmodule that calls :meth:`from_object` or provide an import path to\na module that should be loaded.  It is also possible to tell it to\nuse the same module and with that provide the configuration values\njust before the call::\n\n    DEBUG = True\n    SECRET_KEY = 'development key'\n    app.config.from_object(__name__)\n\nIn both cases (loading from any Python file or loading from modules),\nonly uppercase keys are added to the config.  This makes it possible to use\nlowercase values in the config file for temporary values that are not added\nto the config or to define the config keys in the same file that implements\nthe application.\n\nProbably the most interesting way to load configurations is from an\nenvironment variable pointing to a file::\n\n    app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\nIn this case before launching the application you have to set this\nenvironment variable to the file you want to use.  On Linux and OS X\nuse the export statement::\n\n    export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\nOn windows use `set` instead.\n\n:param root_path: path to which files are read relative from.  When the\n                  config object is created by the application, this is\n                  the application's :attr:`~flask.Flask.root_path`.\n:param defaults: an optional dictionary of default values", "methods": ["__init__", "from_envvar", "from_prefixed_env", "from_pyfile", "from_object", "from_file", "from_mapping", "get_namespace", "__repr__"], "attributes": [], "code_location": {"file": "config.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 50, "end_line": 367}, "type": "class"}, {"name": "test_config_from_envvar", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["monkeypatch.setattr", "flask.Flask", "monkeypatch.setattr", "app.config.from_envvar", "common_object_test", "pytest.raises", "app.config.from_envvar", "str", "app.config.from_envvar", "__file__.rsplit"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 144, "end_line": 158}, "code_snippet": "def test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)\n", "type": "function"}, {"name": "test_config_from_pyfile", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.config.from_pyfile", "common_object_test", "__file__.rsplit"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 19, "end_line": 22}, "code_snippet": "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)\n", "type": "function"}, {"name": "from_object", "is_method": true, "class_name": "Config", "parameters": ["self", "obj"], "calls": ["isinstance", "dir", "import_string", "key.isupper", "getattr"], "code_location": {"file": "config.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 218, "end_line": 254}, "code_snippet": "    def from_object(self, obj: object | str) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n", "type": "function"}, {"name": "test_config_from_file_json", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "os.path.dirname", "app.config.from_file", "common_object_test", "os.path.abspath", "os.path.join"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 31, "end_line": 35}, "code_snippet": "def test_config_from_file_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)\n", "type": "function"}, {"name": "common_object_test", "is_method": false, "class_name": null, "parameters": ["app"], "calls": [], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 13, "end_line": 16}, "code_snippet": "def common_object_test(app):\n    assert app.secret_key == \"config\"\n    assert app.config[\"TEST_KEY\"] == \"foo\"\n    assert \"TestConfig\" not in app.config\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34258270263671875}
{"question": "Where in the request processing flow does the orchestration between the method that loads session data at request start and the method that persists session data at request end occur to handle concurrent requests with potential race conditions?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "save_session", "is_method": true, "class_name": "SessionInterface", "parameters": ["self", "app", "session", "response"], "calls": ["NotImplementedError"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 277, "end_line": 284}, "code_snippet": "    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        \"\"\"This is called at the end of each request, after generating\n        a response, before removing the request context. It is skipped\n        if :meth:`is_null_session` returns ``True``.\n        \"\"\"\n        raise NotImplementedError()\n", "type": "function"}, {"name": "test_session_transactions_keep_context", "is_method": false, "class_name": null, "parameters": ["app", "client", "req_ctx"], "calls": ["client.get", "flask.request._get_current_object", "client.session_transaction", "flask.request._get_current_object"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 196, "end_line": 201}, "code_snippet": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n", "type": "function"}, {"name": "test_session_stored_last", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "repr", "flask.session.get", "client.get", "client.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 434, "end_line": 445}, "code_snippet": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"\n", "type": "function"}, {"name": "test_open_session_with_endpoint", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "MySessionInterface", "app.get", "get", "request_ctx.match_request", "app.test_client"], "code_location": {"file": "test_session_interface.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 6, "end_line": 28}, "code_snippet": "def test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            request_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200\n", "type": "function"}, {"name": "open_session", "is_method": true, "class_name": "SecureCookieSessionInterface", "parameters": ["self", "app", "request"], "calls": ["self.get_signing_serializer", "request.cookies.get", "int", "self.get_cookie_name", "self.session_class", "app.permanent_session_lifetime.total_seconds", "s.loads", "self.session_class", "self.session_class"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 337, "end_line": 349}, "code_snippet": "    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n", "type": "function"}, {"name": "open_session", "is_method": true, "class_name": "SessionInterface", "parameters": ["self", "app", "request"], "calls": ["NotImplementedError"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 263, "end_line": 275}, "code_snippet": "    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:\n        \"\"\"This is called at the beginning of each request, after\n        pushing the request context, before matching the URL.\n\n        This must return an object which implements a dictionary-like\n        interface as well as the :class:`SessionMixin` interface.\n\n        This will return ``None`` to indicate that loading failed in\n        some way that is not immediately an error. The request\n        context will fall back to using :meth:`make_null_session`\n        in this case.\n        \"\"\"\n        raise NotImplementedError()\n", "type": "function"}, {"name": "test_session_transactions", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "str", "client.get", "client.session_transaction", "client.session_transaction", "len", "len", "len"], "code_location": {"file": "test_testing.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 169, "end_line": 183}, "code_snippet": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]\n", "type": "function"}, {"name": "push", "is_method": true, "class_name": "RequestContext", "parameters": ["self"], "calls": ["_cv_app.get", "self._cv_tokens.append", "self.app.app_context", "app_ctx.push", "session_interface.open_session", "self.match_request", "_cv_request.set", "session_interface.make_null_session"], "code_location": {"file": "ctx.py", "path": "/data3/pwh/swebench-repos/flask/src/flask", "start_line": 367, "end_line": 394}, "code_snippet": "    def push(self) -> None:\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _cv_app.get(None)\n\n        if app_ctx is None or app_ctx.app is not self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n        else:\n            app_ctx = None\n\n        self._cv_tokens.append((_cv_request.set(self), app_ctx))\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(self.app, self.request)\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n        # Match the request URL after loading the session, so that the\n        # session is available in custom URL converters.\n        if self.url_adapter is not None:\n            self.match_request()\n", "type": "function"}, {"name": "test_session_error_pops_context", "is_method": false, "class_name": null, "parameters": [], "calls": ["CustomFlask", "app.route", "get", "FailingSessionInterface", "AssertionError", "SessionError", "app.test_client"], "code_location": {"file": "test_reqctx.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 205, "end_line": 226}, "code_snippet": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n", "type": "function"}, {"name": "test_session_cookie_setting", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["app.route", "app.route", "run_test", "run_test", "run_test", "run_test", "str", "str", "flask.session.get", "flask.session.get", "app.test_client", "c.get", "rv.headers.get", "c.get", "c.get", "c.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 479, "end_line": 517}, "code_snippet": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.35660409927368164}
{"question": "Where does the route handler function that returns a list of dictionaries integrate with the framework's route decorator and static type checker configuration to validate return type annotations in the type checking test files?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "hello_json_list", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 37, "end_line": 38}, "code_snippet": "def hello_json_list() -> list[t.Any]:\n    return [{\"message\": \"Hello\"}, {\"message\": \"World\"}]\n", "type": "function"}, {"name": "typed_dict", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 46, "end_line": 47}, "code_snippet": "def typed_dict() -> StatusJSON:\n    return {\"status\": \"ok\"}\n", "type": "function"}, {"name": "hello_json_dict", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 32, "end_line": 33}, "code_snippet": "def hello_json_dict() -> dict[str, t.Any]:\n    return {\"response\": \"Hello, World!\"}\n", "type": "function"}, {"name": "test_method_route_no_methods", "is_method": false, "class_name": null, "parameters": ["app"], "calls": ["pytest.raises", "app.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 65, "end_line": 67}, "code_snippet": "def test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])\n", "type": "function"}, {"name": "test_async_route", "is_method": false, "class_name": null, "parameters": ["path", "async_app"], "calls": ["pytest.mark.parametrize", "async_app.test_client", "test_client.get", "test_client.post", "response.get_data", "response.get_data"], "code_location": {"file": "test_async.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 82, "end_line": 87}, "code_snippet": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()\n", "type": "function"}, {"name": "test_response_type_errors", "is_method": false, "class_name": null, "parameters": [], "calls": ["flask.Flask", "app.route", "app.route", "app.route", "app.route", "app.route", "app.test_client", "pytest.raises", "c.get", "str", "str", "pytest.raises", "c.get", "str", "pytest.raises", "c.get", "pytest.raises", "c.get", "str", "pytest.raises", "c.get"], "code_location": {"file": "test_basic.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 1216, "end_line": 1262}, "code_snippet": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")\n", "type": "function"}, {"name": "tuple_status_enum", "is_method": false, "class_name": null, "parameters": [], "calls": ["app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 76, "end_line": 77}, "code_snippet": "def tuple_status_enum() -> tuple[str, int]:\n    return \"hello\", HTTPStatus.OK\n", "type": "function"}, {"name": "tuple_status", "is_method": false, "class_name": null, "parameters": ["code"], "calls": ["app.route", "app.route"], "code_location": {"file": "typing_route.py", "path": "/data3/pwh/swebench-repos/flask/tests/type_check", "start_line": 71, "end_line": 72}, "code_snippet": "def tuple_status(code: int = 200) -> tuple[str, int]:\n    return \"hello\", code\n", "type": "function"}, {"name": "test_async_error_handler", "is_method": false, "class_name": null, "parameters": ["path", "async_app"], "calls": ["pytest.mark.parametrize", "async_app.test_client", "test_client.get"], "code_location": {"file": "test_async.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 91, "end_line": 94}, "code_snippet": "def test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412\n", "type": "function"}, {"name": "test_jsonify_dicts", "is_method": false, "class_name": null, "parameters": ["app", "client"], "calls": ["app.route", "app.route", "flask.jsonify", "flask.jsonify", "client.get", "flask.json.loads"], "code_location": {"file": "test_json.py", "path": "/data3/pwh/swebench-repos/flask/tests", "start_line": 78, "end_line": 102}, "code_snippet": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.35536718368530273}
