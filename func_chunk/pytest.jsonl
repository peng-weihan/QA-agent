{"question": "What is the interaction mechanism between Pytest's FixtureManager class and the FixtureRequest class to establish the relationship between fixture dependencies and fixture execution?", "answer": null, "relative_code_list": null, "ground_truth": "The interaction mechanism between FixtureManager and FixtureRequest establishes a dependency resolution and execution system: 1) FixtureManager serves as the central registry that stores all fixture definitions in _arg2fixturedefs mapping fixture names to FixtureDef objects, 2) FixtureManager provides getfixtureinfo() method that analyzes test functions and creates FuncFixtureInfo objects containing fixture dependency information, 3) FixtureRequest acts as the execution context that provides access to fixture information and manages fixture resolution during test execution, 4) FixtureRequest maintains _arg2fixturedefs and _fixture_defs attributes that map fixture names to their definitions and resolved instances, 5) The dependency resolution process involves FixtureRequest calling _get_active_fixturedef() to find and execute the appropriate FixtureDef for each requested fixture, 6) FixtureRequest creates SubRequest instances for each fixture execution, passing scope, parameters, and context information, 7) FixtureManager's parsefactories() method during collection discovers and registers all fixture definitions, 8) FixtureRequest's getfixturevalue() method provides dynamic fixture access during test execution, 9) The interaction ensures proper fixture scoping through _check_scope() validation, 10) Fixture caching is coordinated between FixtureManager's registry and FixtureRequest's execution context, 11) Dependency ordering is handled through the fixture closure calculation in FixtureManager, 12) The relationship enables both static (collection-time) and dynamic (execution-time) fixture resolution.", "score": null, "retrieved_content": [{"name": "_fixturemanager", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self"], "calls": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 411, "end_line": 412}, "code_snippet": "    def _fixturemanager(self) -> FixtureManager:\n        return self._pyfuncitem.session._fixturemanager\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "SubRequest", "parameters": ["self", "request", "scope", "param", "param_index", "fixturedef"], "calls": ["__init__", "super"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 731, "end_line": 753}, "code_snippet": "    def __init__(\n        self,\n        request: FixtureRequest,\n        scope: Scope,\n        param: Any,\n        param_index: int,\n        fixturedef: FixtureDef[object],\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        super().__init__(\n            pyfuncitem=request._pyfuncitem,\n            fixturename=fixturedef.argname,\n            fixture_defs=request._fixture_defs,\n            arg2fixturedefs=request._arg2fixturedefs,\n            _ispytest=_ispytest,\n        )\n        self._parent_request: Final[FixtureRequest] = request\n        self._scope_field: Final = scope\n        self._fixturedef: Final[FixtureDef[object]] = fixturedef\n        if param is not NOTSET:\n            self.param = param\n        self.param_index: Final = param_index\n", "type": "function"}, {"name": "_get_active_fixturedef", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self", "argname"], "calls": ["self._fixture_defs.get", "self._arg2fixturedefs.get", "self._iter_chain", "self._check_scope", "SubRequest", "fixturedef.execute", "PseudoFixtureDef", "self._check_scope", "self._fixturemanager.getfixturedefs", "FixtureLookupError", "FixtureLookupError", "len", "FixtureLookupError", "self._check_fixturedef_without_param"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 566, "end_line": 643}, "code_snippet": "    def _get_active_fixturedef(\n        self, argname: str\n    ) -> FixtureDef[object] | PseudoFixtureDef[object]:\n        if argname == \"request\":\n            cached_result = (self, [0], None)\n            return PseudoFixtureDef(cached_result, Scope.Function)\n\n        # If we already finished computing a fixture by this name in this item,\n        # return it.\n        fixturedef = self._fixture_defs.get(argname)\n        if fixturedef is not None:\n            self._check_scope(fixturedef, fixturedef._scope)\n            return fixturedef\n\n        # Find the appropriate fixturedef.\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) which was naturally\n            # not known at parsing/collection time.\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, self._pyfuncitem)\n            if fixturedefs is not None:\n                self._arg2fixturedefs[argname] = fixturedefs\n        # No fixtures defined with this name.\n        if fixturedefs is None:\n            raise FixtureLookupError(argname, self)\n        # The are no fixtures with this name applicable for the function.\n        if not fixturedefs:\n            raise FixtureLookupError(argname, self)\n\n        # A fixture may override another fixture with the same name, e.g. a\n        # fixture in a module can override a fixture in a conftest, a fixture in\n        # a class can override a fixture in the module, and so on.\n        # An overriding fixture can request its own name (possibly indirectly);\n        # in this case it gets the value of the fixture it overrides, one level\n        # up.\n        # Check how many `argname`s deep we are, and take the next one.\n        # `fixturedefs` is sorted from furthest to closest, so use negative\n        # indexing to go in reverse.\n        index = -1\n        for request in self._iter_chain():\n            if request.fixturename == argname:\n                index -= 1\n        # If already consumed all of the available levels, fail.\n        if -index > len(fixturedefs):\n            raise FixtureLookupError(argname, self)\n        fixturedef = fixturedefs[index]\n\n        # Prepare a SubRequest object for calling the fixture.\n        try:\n            callspec = self._pyfuncitem.callspec\n        except AttributeError:\n            callspec = None\n        if callspec is not None and argname in callspec.params:\n            param = callspec.params[argname]\n            param_index = callspec.indices[argname]\n            # The parametrize invocation scope overrides the fixture's scope.\n            scope = callspec._arg2scope[argname]\n        else:\n            param = NOTSET\n            param_index = 0\n            scope = fixturedef._scope\n            self._check_fixturedef_without_param(fixturedef)\n        # The parametrize invocation scope only controls caching behavior while\n        # allowing wider-scoped fixtures to keep depending on the parametrized\n        # fixture. Scope control is enforced for parametrized fixtures\n        # by recreating the whole fixture tree on parameter change.\n        # Hence `fixturedef._scope`, not `scope`.\n        self._check_scope(fixturedef, fixturedef._scope)\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Make sure the fixture value is cached, running it if it isn't\n        fixturedef.execute(request=subrequest)\n\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self", "pyfuncitem", "fixturename", "arg2fixturedefs", "fixture_defs"], "calls": ["check_ispytest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 379, "end_line": 408}, "code_snippet": "    def __init__(\n        self,\n        pyfuncitem: Function,\n        fixturename: str | None,\n        arg2fixturedefs: dict[str, Sequence[FixtureDef[Any]]],\n        fixture_defs: dict[str, FixtureDef[Any]],\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        #: Fixture for which this request is being performed.\n        self.fixturename: Final = fixturename\n        self._pyfuncitem: Final = pyfuncitem\n        # The FixtureDefs for each fixture name requested by this item.\n        # Starts from the statically-known fixturedefs resolved during\n        # collection. Dynamically requested fixtures (using\n        # `request.getfixturevalue(\"foo\")`) are added dynamically.\n        self._arg2fixturedefs: Final = arg2fixturedefs\n        # The evaluated argnames so far, mapping to the FixtureDef they resolved\n        # to.\n        self._fixture_defs: Final = fixture_defs\n        # Notes on the type of `param`:\n        # -`request.param` is only defined in parametrized fixtures, and will raise\n        #   AttributeError otherwise. Python typing has no notion of \"undefined\", so\n        #   this cannot be reflected in the type.\n        # - Technically `param` is only (possibly) defined on SubRequest, not\n        #   FixtureRequest, but the typing of that is still in flux so this cheats.\n        # - In the future we might consider using a generic for the param type, but\n        #   for now just using Any.\n        self.param: Any\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "PytestArg", "parameters": ["self", "request"], "calls": [], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 206, "end_line": 207}, "code_snippet": "    def __init__(self, request: FixtureRequest) -> None:\n        self._request = request\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["FixtureManager"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 119, "end_line": 120}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n", "type": "function"}, {"name": "test_request_contains_funcarg_arg2fixturedefs", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.getmodulecol", "pytester.genitems", "isinstance", "TopRequest", "len"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 718, "end_line": 735}, "code_snippet": "    def test_request_contains_funcarg_arg2fixturedefs(self, pytester: Pytester) -> None:\n        modcol = pytester.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def something(request):\n                pass\n            class TestClass(object):\n                def test_method(self, something):\n                    pass\n        \"\"\"\n        )\n        (item1,) = pytester.genitems([modcol])\n        assert isinstance(item1, Function)\n        assert item1.name == \"test_method\"\n        arg2fixturedefs = TopRequest(item1, _ispytest=True)._arg2fixturedefs\n        assert len(arg2fixturedefs) == 1\n        assert arg2fixturedefs[\"something\"][0].argname == \"something\"\n", "type": "function"}, {"name": "test_dynamic_fixture_request", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_setuponly.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 214, "end_line": 237}, "code_snippet": "def test_dynamic_fixture_request(pytester: Pytester) -> None:\n    p = pytester.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture()\n        def dynamically_requested_fixture():\n            pass\n        @pytest.fixture()\n        def dependent_fixture(request):\n            request.getfixturevalue('dynamically_requested_fixture')\n        def test_dyn(dependent_fixture):\n            pass\n    \"\"\"\n    )\n\n    result = pytester.runpytest(\"--setup-only\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*SETUP    F dynamically_requested_fixture\",\n            \"*TEARDOWN F dynamically_requested_fixture\",\n        ]\n    )\n", "type": "function"}, {"name": "FuncFixtureInfo", "docstring": "Fixture-related information for a fixture-requesting item (e.g. test\nfunction).\n\nThis is used to examine the fixtures which an item requests statically\n(known during collection). This includes autouse fixtures, fixtures\nrequested by the `usefixtures` marker, fixtures requested in the function\nparameters, and the transitive closure of these.\n\nAn item may also request fixtures dynamically (using `request.getfixturevalue`);\nthese are not reflected here.", "methods": ["prune_dependency_tree"], "attributes": ["__slots__"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 314, "end_line": 369}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.6475014686584473}
{"question": "What is the interaction mechanism between Pytest's Session class and the Collector class to establish the relationship between test collection and test execution?", "answer": null, "relative_code_list": null, "ground_truth": "The interaction mechanism between Pytest's Session class and Collector class establishes a hierarchical relationship for test collection and execution: 1) Session class serves as the root collector that inherits from nodes.Collector and initiates the collection process through perform_collect() method, 2) Session coordinates the collection phase by calling pytest_collection hook which triggers the collection protocol, 3) Collection follows a recursive pattern where Session collects initial paths and delegates to appropriate Collector instances (File, Module, Class, etc.), 4) Each Collector implements the collect() method to discover and yield child nodes (Items or other Collectors), 5) Session maintains the collection tree hierarchy with items list containing all discovered test items, 6) Collection reports are generated through pytest_collectreport hook to track collection progress and failures, 7) Session manages collection state including testsfailed and testscollected counters, 8) After collection, Session triggers pytest_collection_modifyitems hook for post-collection processing, 9) Session then coordinates test execution through pytest_runtestloop hook, 10) The collection-execution relationship is established through the items list that Session maintains, 11) Session provides control flow mechanisms (shouldstop, shouldfail) that affect both collection and execution phases, 12) Collection caching and duplicate handling ensure efficient test discovery and execution coordination.", "score": null, "retrieved_content": [{"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.perform_collect"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 352, "end_line": 353}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    session.perform_collect()\n", "type": "function"}, {"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self", "config"], "calls": ["__init__", "config.trace.root.get", "frozenset", "frozenset", "_bestrelpath_cache", "self.config.pluginmanager.register", "super"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 562, "end_line": 586}, "code_snippet": "    def __init__(self, config: Config) -> None:\n        super().__init__(\n            name=\"\",\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self._shouldstop: bool | str = False\n        self._shouldfail: bool | str = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._initialpaths: frozenset[Path] = frozenset()\n        self._initialpaths_with_parents: frozenset[Path] = frozenset()\n        self._notfound: list[tuple[str, Sequence[nodes.Collector]]] = []\n        self._initial_parts: list[CollectionArgument] = []\n        self._collection_cache: dict[nodes.Collector, CollectReport] = {}\n        self.items: list[nodes.Item] = []\n\n        self._bestrelpathcache: dict[Path, str] = _bestrelpath_cache(config.rootpath)\n\n        self.config.pluginmanager.register(self, name=\"session\")\n", "type": "function"}, {"name": "pytest_collectstart", "is_method": false, "class_name": null, "parameters": ["collector"], "calls": [], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 415, "end_line": 427}, "code_snippet": "def pytest_collectstart(collector: Collector) -> None:\n    \"\"\"Collector starts collecting.\n\n    :param collector:\n        The collector.\n\n    Use in conftest plugins\n    =======================\n\n    Any conftest file can implement this hook. For a given collector, only\n    conftest files in the collector's directory and its parent directories are\n    consulted.\n    \"\"\"\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.config.stash.get", "assertstate.hook.set_session"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 132, "end_line": 139}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    # This hook is only called when test modules are collected\n    # so for example not in the managing process of pytest-xdist\n    # (which does not collect test modules).\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n", "type": "function"}, {"name": "collect", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["self.trace", "argpath.is_dir", "module_name.split", "enumerate", "work.pop", "isinstance", "reversed", "join", "self._notfound.append", "paths.insert", "paths.insert", "isinstance", "isinstance", "matchnode._collect_path", "self._collect_one_node", "isinstance", "notfound_collectors.append", "pm._is_in_confcutdir", "matchnode.ihook.pytest_collectreport", "work.append", "str", "len", "isinstance", "is_file", "os.path.samefile", "len", "os.path.islink", "os.path.islink", "node.name.split"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 847, "end_line": 966}, "code_snippet": "    def collect(self) -> Iterator[nodes.Item | nodes.Collector]:\n        # This is a cache for the root directories of the initial paths.\n        # We can't use collection_cache for Session because of its special\n        # role as the bootstrapping collector.\n        path_cache: dict[Path, Sequence[nodes.Collector]] = {}\n\n        pm = self.config.pluginmanager\n\n        for collection_argument in self._initial_parts:\n            self.trace(\"processing argument\", collection_argument)\n            self.trace.root.indent += 1\n\n            argpath = collection_argument.path\n            names = collection_argument.parts\n            module_name = collection_argument.module_name\n\n            # resolve_collection_argument() ensures this.\n            if argpath.is_dir():\n                assert not names, f\"invalid arg {(argpath, names)!r}\"\n\n            paths = [argpath]\n            # Add relevant parents of the path, from the root, e.g.\n            #   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]\n            if module_name is None:\n                # Paths outside of the confcutdir should not be considered.\n                for path in argpath.parents:\n                    if not pm._is_in_confcutdir(path):\n                        break\n                    paths.insert(0, path)\n            else:\n                # For --pyargs arguments, only consider paths matching the module\n                # name. Paths beyond the package hierarchy are not included.\n                module_name_parts = module_name.split(\".\")\n                for i, path in enumerate(argpath.parents, 2):\n                    if i > len(module_name_parts) or path.stem != module_name_parts[-i]:\n                        break\n                    paths.insert(0, path)\n\n            # Start going over the parts from the root, collecting each level\n            # and discarding all nodes which don't match the level's part.\n            any_matched_in_initial_part = False\n            notfound_collectors = []\n            work: list[tuple[nodes.Collector | nodes.Item, list[Path | str]]] = [\n                (self, [*paths, *names])\n            ]\n            while work:\n                matchnode, matchparts = work.pop()\n\n                # Pop'd all of the parts, this is a match.\n                if not matchparts:\n                    yield matchnode\n                    any_matched_in_initial_part = True\n                    continue\n\n                # Should have been matched by now, discard.\n                if not isinstance(matchnode, nodes.Collector):\n                    continue\n\n                # Collect this level of matching.\n                # Collecting Session (self) is done directly to avoid endless\n                # recursion to this function.\n                subnodes: Sequence[nodes.Collector | nodes.Item]\n                if isinstance(matchnode, Session):\n                    assert isinstance(matchparts[0], Path)\n                    subnodes = matchnode._collect_path(matchparts[0], path_cache)\n                else:\n                    # For backward compat, files given directly multiple\n                    # times on the command line should not be deduplicated.\n                    handle_dupes = not (\n                        len(matchparts) == 1\n                        and isinstance(matchparts[0], Path)\n                        and matchparts[0].is_file()\n                    )\n                    rep, duplicate = self._collect_one_node(matchnode, handle_dupes)\n                    if not duplicate and not rep.passed:\n                        # Report collection failures here to avoid failing to\n                        # run some test specified in the command line because\n                        # the module could not be imported (#134).\n                        matchnode.ihook.pytest_collectreport(report=rep)\n                    if not rep.passed:\n                        continue\n                    subnodes = rep.result\n\n                # Prune this level.\n                any_matched_in_collector = False\n                for node in reversed(subnodes):\n                    # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.\n                    if isinstance(matchparts[0], Path):\n                        is_match = node.path == matchparts[0]\n                        if sys.platform == \"win32\" and not is_match:\n                            # In case the file paths do not match, fallback to samefile() to\n                            # account for short-paths on Windows (#11895).\n                            same_file = os.path.samefile(node.path, matchparts[0])\n                            # We don't want to match links to the current node,\n                            # otherwise we would match the same file more than once (#12039).\n                            is_match = same_file and (\n                                os.path.islink(node.path)\n                                == os.path.islink(matchparts[0])\n                            )\n\n                    # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.\n                    else:\n                        # TODO: Remove parametrized workaround once collection structure contains\n                        # parametrization.\n                        is_match = (\n                            node.name == matchparts[0]\n                            or node.name.split(\"[\")[0] == matchparts[0]\n                        )\n                    if is_match:\n                        work.append((node, matchparts[1:]))\n                        any_matched_in_collector = True\n\n                if not any_matched_in_collector:\n                    notfound_collectors.append(matchnode)\n\n            if not any_matched_in_initial_part:\n                report_arg = \"::\".join((str(argpath), *names))\n                self._notfound.append((report_arg, notfound_collectors))\n\n            self.trace.root.indent -= 1\n", "type": "function"}, {"name": "perform_collect", "is_method": true, "class_name": "Session", "parameters": ["self", "args", "genitems"], "calls": ["self.trace", "self.config.getini", "frozenset", "frozenset", "collect_one_node", "self.ihook.pytest_collectreport", "self.config.pluginmanager.check_pending", "hook.pytest_collection_modifyitems", "hook.pytest_collection_finish", "len", "resolve_collection_argument", "self._initial_parts.append", "initialpaths.append", "initialpaths_with_parents.append", "initialpaths_with_parents.extend", "UsageError", "errors.append", "errors.append", "self.items.extend", "self.genitems"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 748, "end_line": 832}, "code_snippet": "    def perform_collect(\n        self, args: Sequence[str] | None = None, genitems: bool = True\n    ) -> Sequence[nodes.Item | nodes.Collector]:\n        \"\"\"Perform the collection phase for this session.\n\n        This is called by the default :hook:`pytest_collection` hook\n        implementation; see the documentation of this hook for more details.\n        For testing purposes, it may also be called directly on a fresh\n        ``Session``.\n\n        This function normally recursively expands any collectors collected\n        from the session to their items, and only items are returned. For\n        testing purposes, this may be suppressed by passing ``genitems=False``,\n        in which case the return value contains these collectors unexpanded,\n        and ``session.items`` is empty.\n        \"\"\"\n        if args is None:\n            args = self.config.args\n\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n\n        hook = self.config.hook\n\n        self._notfound = []\n        self._initial_parts = []\n        self._collection_cache = {}\n        self.items = []\n        items: Sequence[nodes.Item | nodes.Collector] = self.items\n        consider_namespace_packages: bool = self.config.getini(\n            \"consider_namespace_packages\"\n        )\n        try:\n            initialpaths: list[Path] = []\n            initialpaths_with_parents: list[Path] = []\n            for arg in args:\n                collection_argument = resolve_collection_argument(\n                    self.config.invocation_params.dir,\n                    arg,\n                    as_pypath=self.config.option.pyargs,\n                    consider_namespace_packages=consider_namespace_packages,\n                )\n                self._initial_parts.append(collection_argument)\n                initialpaths.append(collection_argument.path)\n                initialpaths_with_parents.append(collection_argument.path)\n                initialpaths_with_parents.extend(collection_argument.path.parents)\n            self._initialpaths = frozenset(initialpaths)\n            self._initialpaths_with_parents = frozenset(initialpaths_with_parents)\n\n            rep = collect_one_node(self)\n            self.ihook.pytest_collectreport(report=rep)\n            self.trace.root.indent -= 1\n            if self._notfound:\n                errors = []\n                for arg, collectors in self._notfound:\n                    if collectors:\n                        errors.append(\n                            f\"not found: {arg}\\n(no match in any of {collectors!r})\"\n                        )\n                    else:\n                        errors.append(f\"found no collectors for {arg}\")\n\n                raise UsageError(*errors)\n\n            if not genitems:\n                items = rep.result\n            else:\n                if rep.passed:\n                    for node in rep.result:\n                        self.items.extend(self.genitems(node))\n\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            self._notfound = []\n            self._initial_parts = []\n            self._collection_cache = {}\n            hook.pytest_collection_finish(session=self)\n\n        if genitems:\n            self.testscollected = len(items)\n\n        return items\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["hookspec"], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 230, "end_line": 268}, "code_snippet": "def pytest_collection(session: Session) -> object | None:\n    \"\"\"Perform the collection phase for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n    The return value is not used, but only stops further processing.\n\n    The default collection phase is this (see individual hooks for full details):\n\n    1. Starting from ``session`` as the initial collector:\n\n      1. ``pytest_collectstart(collector)``\n      2. ``report = pytest_make_collect_report(collector)``\n      3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred\n      4. For each collected node:\n\n        1. If an item, ``pytest_itemcollected(item)``\n        2. If a collector, recurse into it.\n\n      5. ``pytest_collectreport(report)``\n\n    2. ``pytest_collection_modifyitems(session, config, items)``\n\n      1. ``pytest_deselected(items)`` for any deselected items (may be called multiple times)\n\n    3. ``pytest_collection_finish(session)``\n    4. Set ``session.items`` to the list of collected items\n    5. Set ``session.testscollected`` to the number of collected items\n\n    You can implement this hook to only perform some action before collection,\n    for example the terminal plugin uses it to start displaying the collection\n    counter (and returns `None`).\n\n    :param session: The pytest session object.\n\n    Use in conftest plugins\n    =======================\n\n    This hook is only called for :ref:`initial conftests <pluginorder>`.\n    \"\"\"\n", "type": "function"}, {"name": "test_collect_versus_item", "is_method": true, "class_name": "TestCollector", "parameters": ["self"], "calls": ["issubclass", "issubclass"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 34, "end_line": 39}, "code_snippet": "    def test_collect_versus_item(self) -> None:\n        from pytest import Collector\n        from pytest import Item\n\n        assert not issubclass(Collector, Item)\n        assert not issubclass(Item, Collector)\n", "type": "function"}, {"name": "test_modulecol_roundtrip", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.getmodulecol", "modcol.session.perform_collect"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1067, "end_line": 1071}, "code_snippet": "def test_modulecol_roundtrip(pytester: Pytester) -> None:\n    modcol = pytester.getmodulecol(\"pass\", withinit=False)\n    trail = modcol.nodeid\n    newcol = modcol.session.perform_collect([trail], genitems=0)[0]\n    assert modcol.name == newcol.name\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.714686632156372}
{"question": "What is the structure of Pytest's configuration system?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's configuration system consists of several components: 1) Config class - the main configuration object that holds all settings and provides access to plugin manager and hooks, 2) Multiple configuration file formats supported: pytest.ini (highest precedence), pyproject.toml with [tool.pytest.ini_options] section, tox.ini with [pytest] section, and setup.cfg with [tool:pytest] section, 3) Command-line argument parsing through the Parser class, 4) Configuration file discovery that determines rootdir and configfile based on command line arguments and file existence, 5) Plugin manager integration for registering configuration options from plugins, 6) Environment variable support (PYTEST_ADDOPTS), 7) Configuration inheritance and override mechanisms, 8) Stash object for plugins to store configuration data, 9) InvocationParams class to hold parameters passed during pytest.main() calls, 10) Configuration validation and error handling for invalid settings.", "score": null, "retrieved_content": [{"name": "Config", "docstring": "Access to configuration values, pluginmanager and plugin hooks.\n\n:param PytestPluginManager pluginmanager:\n    A pytest PluginManager.\n\n:param InvocationParams invocation_params:\n    Object containing parameters regarding the :func:`pytest.main`\n    invocation.", "methods": ["__init__", "rootpath", "inipath", "add_cleanup", "_do_configure", "_ensure_unconfigure", "get_terminal_writer", "pytest_cmdline_parse", "notify_exception", "cwd_relative_nodeid", "fromdictargs", "_processopt", "pytest_load_initial_conftests", "_initini", "_consider_importhook", "_mark_plugins_for_rewrite", "_configure_python_path", "_unconfigure_python_path", "_validate_args", "_decide_args", "_preparse", "pytest_collection", "_checkversion", "_validate_config_options", "_validate_plugins", "_warn_or_fail_if_strict", "_get_unknown_ini_keys", "parse", "issue_config_time_warning", "addinivalue_line", "getini", "_getini_unknown_type", "_getini", "_getconftest_pathlist", "_get_override_ini_value", "getoption", "getvalue", "getvalueorskip", "get_verbosity", "_verbosity_ini_name", "_add_verbosity_ini", "_warn_about_missing_assertion", "_warn_about_skipped_plugins"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 968, "end_line": 1864}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self"], "calls": ["__init__", "set", "self.add_hookspecs", "self.register", "os.environ.get", "DummyRewriteHook", "lru_cache", "getattr", "self.trace.root.setwriter", "self.enable_tracing", "super", "open", "os.dup", "err.fileno"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 401, "end_line": 451}, "code_snippet": "    def __init__(self) -> None:\n        from _pytest.assertion import DummyRewriteHook\n        from _pytest.assertion import RewriteHook\n\n        super().__init__(\"pytest\")\n\n        # -- State related to local conftest plugins.\n        # All loaded conftest modules.\n        self._conftest_plugins: set[types.ModuleType] = set()\n        # All conftest modules applicable for a directory.\n        # This includes the directory's own conftest modules as well\n        # as those of its parent directories.\n        self._dirpath2confmods: dict[pathlib.Path, list[types.ModuleType]] = {}\n        # Cutoff directory above which conftests are no longer discovered.\n        self._confcutdir: pathlib.Path | None = None\n        # If set, conftest loading is skipped.\n        self._noconftest = False\n\n        # _getconftestmodules()'s call to _get_directory() causes a stat\n        # storm when it's called potentially thousands of times in a test\n        # session (#9478), often with the same path, so cache it.\n        self._get_directory = lru_cache(256)(_get_directory)\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: list[tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook: RewriteHook = DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getini", "UsageError"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/mark", "start_line": 287, "end_line": 297}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.stash[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            f\"{EMPTY_PARAMETERSET_OPTION!s} must be one of skip, xfail or fail_at_collect\"\n            f\" but it is {empty_parameterset!r}\"\n        )\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.addinivalue_line", "config.addinivalue_line"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 117, "end_line": 134}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures \",\n    )\n", "type": "function"}, {"name": "test_parseconfig", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.parseconfig", "pytester.parseconfig"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 77, "end_line": 80}, "code_snippet": "def test_parseconfig(pytester: Pytester) -> None:\n    config1 = pytester.parseconfig()\n    config2 = pytester.parseconfig()\n    assert config2 is not config1\n", "type": "function"}, {"name": "pytest_addoption", "is_method": false, "class_name": null, "parameters": ["parser"], "calls": ["parser.addini", "parser.addini", "parser.addini", "parser.addini"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 83, "end_line": 109}, "code_snippet": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"python_files\",\n        type=\"args\",\n        # NOTE: default is also used in AssertionRewritingHook.\n        default=[\"test_*.py\", \"*_test.py\"],\n        help=\"Glob-style file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"Prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"Prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n        type=\"bool\",\n        default=False,\n        help=\"Disable string escape non-ASCII characters, might cause unwanted \"\n        \"side effects(use at your own risk)\",\n    )\n", "type": "function"}, {"name": "get_config", "is_method": false, "class_name": null, "parameters": ["args", "plugins"], "calls": ["PytestPluginManager", "Config", "pluginmanager.consider_preparse", "pluginmanager.import_plugin", "Config.InvocationParams", "pathlib.Path.cwd"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 283, "end_line": 305}, "code_snippet": "def get_config(\n    args: list[str] | None = None,\n    plugins: Sequence[str | _PluggyPlugin] | None = None,\n) -> Config:\n    # Subsequent calls to main will create a fresh instance.\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (),\n            plugins=plugins,\n            dir=pathlib.Path.cwd(),\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args, exclude_only=True)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n\n    return config\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Config", "parameters": ["self", "pluginmanager"], "calls": ["argparse.Namespace", "Parser", "Stash", "self.pluginmanager.trace.root.get", "PathAwareHookProxy", "contextlib.ExitStack", "self.pluginmanager.register", "self.hook.pytest_addoption.call_historic", "self.InvocationParams", "dict", "pathlib.Path.cwd"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 1031, "end_line": 1090}, "code_snippet": "    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: InvocationParams | None = None,\n    ) -> None:\n        from .argparsing import FILE_OR_DIR\n        from .argparsing import Parser\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=pathlib.Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n            _ispytest=True,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.stash = Stash()\n        \"\"\"A place where plugins can store information on the config for their\n        own use.\n\n        :type: Stash\n        \"\"\"\n        # Deprecated alias. Was never public. Can be removed in a few releases.\n        self._store = self.stash\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook: pluggy.HookRelay = PathAwareHookProxy(self.pluginmanager.hook)  # type: ignore[assignment]\n        self._inicache: dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: dict[str, str] = {}\n        self._cleanup_stack = contextlib.ExitStack()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n        self.args_source = Config.ArgsSource.ARGS\n        self.args: list[str] = []\n", "type": "function"}, {"name": "pytest_addoption", "is_method": false, "class_name": null, "parameters": ["parser"], "calls": ["parser.getgroup", "group._addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "parser.getgroup", "group.addoption", "parser.addini", "parser.getgroup", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "parser.addini", "parser.addini", "parser.addini", "parser.addini", "parser.getgroup", "group._addoption", "group.addoption", "group.addoption", "functools.partial"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 56, "end_line": 248}, "code_snippet": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(  # private to use reserved lower-case short option\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group.addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group.addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group.addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group.addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    parser.addini(\n        \"collect_imported_tests\",\n        \"Whether to collect tests in imported modules outside `testpaths`\",\n        type=\"bool\",\n        default=True,\n    )\n    parser.addini(\n        \"consider_namespace_packages\",\n        type=\"bool\",\n        default=False,\n        help=\"Consider namespace packages when resolving module names during import\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group._addoption(  # private to use reserved lower-case short option\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group.addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.89357590675354}
{"question": "Why does Pytest use a fixture system with dependency injection instead of traditional setup/teardown methods?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest uses a fixture system with dependency injection instead of traditional setup/teardown methods for several key architectural and practical reasons: 1) Dependency injection provides explicit, declarative dependencies where test functions clearly declare what resources they need through function parameters, making test requirements transparent and self-documenting, 2) Fixture system enables automatic dependency resolution where pytest automatically determines the order of fixture execution based on dependencies, eliminating the need for manual setup ordering, 3) Fixture scoping system (function, class, module, package, session) provides fine-grained control over resource lifecycle, allowing expensive resources to be shared across multiple tests when appropriate, 4) Fixture caching within scope prevents redundant setup/teardown operations, improving performance by reusing fixture instances across tests in the same scope, 5) Fixture system supports parametrization where the same fixture can be used with different parameters, enabling comprehensive testing scenarios, 6) Automatic cleanup through yield statements ensures proper resource cleanup regardless of test outcome, preventing resource leaks, 7) Fixture system integrates seamlessly with pytest's plugin architecture, allowing fixtures to be defined in plugins and shared across projects, 8) Dependency injection makes tests more modular and reusable, as fixtures can be easily shared between different test modules and projects, 9) Fixture system provides better error isolation where fixture failures are clearly attributed to specific fixtures rather than generic setup/teardown methods, 10) The system supports both autouse fixtures for automatic setup and explicit fixtures for on-demand resource creation, providing flexibility for different testing scenarios, 11) Fixture system enables better test organization where related setup logic is grouped with the resources it creates, 12) The dependency injection approach makes tests more testable themselves, as fixtures can be easily mocked or replaced for testing purposes.", "score": null, "retrieved_content": [{"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_fixture_dependency", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "touch", "pytester.mkdir", "touch", "write_text", "sub.joinpath", "subsub.mkdir", "touch", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "textwrap.dedent", "pytester.path.joinpath", "sub.joinpath", "sub.joinpath", "subsub.joinpath", "subsub.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 466, "end_line": 510}, "code_snippet": "def test_fixture_dependency(pytester: Pytester) -> None:\n    pytester.makeconftest(\"\")\n    pytester.path.joinpath(\"__init__.py\").touch()\n    sub = pytester.mkdir(\"sub\")\n    sub.joinpath(\"__init__.py\").touch()\n    sub.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    subsub = sub.joinpath(\"subsub\")\n    subsub.mkdir()\n    subsub.joinpath(\"__init__.py\").touch()\n    subsub.joinpath(\"test_bar.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    result = pytester.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1685, "end_line": 1703}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"conftest\"\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "test_fixture_arg_ordering", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "str"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4738, "end_line": 4770}, "code_snippet": "def test_fixture_arg_ordering(pytester: Pytester) -> None:\n    \"\"\"\n    This test describes how fixtures in the same scope but without explicit dependencies\n    between them are created. While users should make dependencies explicit, often\n    they rely on this order, so this test exists to catch regressions in this regard.\n    See #6540 and #6492.\n    \"\"\"\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import pytest\n\n        suffixes = []\n\n        @pytest.fixture\n        def fix_1(): suffixes.append(\"fix_1\")\n        @pytest.fixture\n        def fix_2(): suffixes.append(\"fix_2\")\n        @pytest.fixture\n        def fix_3(): suffixes.append(\"fix_3\")\n        @pytest.fixture\n        def fix_4(): suffixes.append(\"fix_4\")\n        @pytest.fixture\n        def fix_5(): suffixes.append(\"fix_5\")\n\n        @pytest.fixture\n        def fix_combined(fix_1, fix_2, fix_3, fix_4, fix_5): pass\n\n        def test_suffix(fix_combined):\n            assert suffixes == [\"fix_1\", \"fix_2\", \"fix_3\", \"fix_4\", \"fix_5\"]\n        \"\"\"\n    )\n    result = pytester.runpytest(\"-vv\", str(p1))\n    assert result.ret == 0\n", "type": "function"}, {"name": "test_dynamic_fixture_request", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_setuponly.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 214, "end_line": 237}, "code_snippet": "def test_dynamic_fixture_request(pytester: Pytester) -> None:\n    p = pytester.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture()\n        def dynamically_requested_fixture():\n            pass\n        @pytest.fixture()\n        def dependent_fixture(request):\n            request.getfixturevalue('dynamically_requested_fixture')\n        def test_dyn(dependent_fixture):\n            pass\n    \"\"\"\n    )\n\n    result = pytester.runpytest(\"--setup-only\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*SETUP    F dynamically_requested_fixture\",\n            \"*TEARDOWN F dynamically_requested_fixture\",\n        ]\n    )\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TopRequest", "parameters": ["self", "pyfuncitem"], "calls": ["__init__", "super", "pyfuncitem._fixtureinfo.name2fixturedefs.copy"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 688, "end_line": 695}, "code_snippet": "    def __init__(self, pyfuncitem: Function, *, _ispytest: bool = False) -> None:\n        super().__init__(\n            fixturename=None,\n            pyfuncitem=pyfuncitem,\n            arg2fixturedefs=pyfuncitem._fixtureinfo.name2fixturedefs.copy(),\n            fixture_defs={},\n            _ispytest=_ispytest,\n        )\n", "type": "function"}, {"name": "contest_with_teardown_fixture", "is_method": true, "class_name": "TestProgressWithTeardown", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2415, "end_line": 2425}, "code_snippet": "    def contest_with_teardown_fixture(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def fail_teardown():\n                yield\n                assert False\n        \"\"\"\n        )\n", "type": "function"}, {"name": "test_capture_and_fixtures", "is_method": true, "class_name": "TestPerTestCapturing", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 155, "end_line": 179}, "code_snippet": "    def test_capture_and_fixtures(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def setup_module(mod):\n                print(\"setup module\")\n            def setup_function(function):\n                print(\"setup \" + function.__name__)\n            def test_func1():\n                print(\"in func1\")\n                assert 0\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = pytester.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"setup module*\",\n                \"setup test_func1*\",\n                \"in func1*\",\n                \"setup test_func2*\",\n                \"in func2*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_setupdecorator_and_xunit", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1040, "end_line": 1070}, "code_snippet": "    def test_setupdecorator_and_xunit(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope='module', autouse=True)\n            def setup_module():\n                values.append(\"module\")\n            @pytest.fixture(autouse=True)\n            def setup_function():\n                values.append(\"function\")\n\n            def test_func():\n                pass\n\n            class TestClass(object):\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def setup_class(self):\n                    values.append(\"class\")\n                @pytest.fixture(autouse=True)\n                def setup_method(self):\n                    values.append(\"method\")\n                def test_method(self):\n                    pass\n            def test_all():\n                assert values == [\"module\", \"function\", \"class\",\n                             \"function\", \"method\", \"function\"]\n        \"\"\"\n        )\n        reprec = pytester.inline_run(\"-v\")\n        reprec.assertoutcome(passed=3)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.8762321472167969}
{"question": "What dependencies exist between Pytest's plugin system and the core test runner?", "answer": null, "relative_code_list": null, "ground_truth": "The dependencies between Pytest's plugin system and core test runner create a tightly integrated architecture: 1) Core test runner depends on essential plugins (mark, main, runner, fixtures, helpconfig) that cannot be disabled and provide fundamental functionality, 2) Plugin system is built on pluggy library which provides the hook mechanism that enables all pytest functionality, 3) Core test runner delegates all major operations to plugins through hook calls (pytest_collection, pytest_runtestloop, pytest_runtest_protocol), 4) Configuration system depends on plugins to register command-line options and ini settings through pytest_addoption hook, 5) Test collection is entirely plugin-driven with built-in plugins (python, terminal, debugging) providing the collection logic, 6) Test execution relies on runner plugin to coordinate the three-phase test execution protocol, 7) Fixture system is implemented as a plugin that the core runner depends on for test setup and teardown, 8) Reporting and output formatting are handled by terminal and other reporting plugins, 9) Core runner provides the hook infrastructure but actual functionality comes from plugins, 10) Plugin discovery and loading happens before core runner initialization, establishing the execution environment, 11) Core runner's Config class integrates with PluginManager to coordinate plugin registration and hook invocation, 12) The dependency relationship ensures that the core runner is minimal while plugins provide all the actual testing functionality.", "score": null, "retrieved_content": [{"name": "pytest_plugin_registered", "is_method": false, "class_name": null, "parameters": ["plugin", "manager"], "calls": ["manager.get_plugin", "manager.register", "manager.is_registered"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 463, "end_line": 468}, "code_snippet": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")\n", "type": "function"}, {"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "test_load_initial_conftest_last_ordering", "is_method": false, "class_name": null, "parameters": ["_config_for_test"], "calls": ["My", "pm.register", "hc.get_hookimpls"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1541, "end_line": 1564}, "code_snippet": "def test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    hookimpls = [\n        (\n            hookimpl.function.__module__,\n            \"wrapper\" if (hookimpl.wrapper or hookimpl.hookwrapper) else \"nonwrapper\",\n        )\n        for hookimpl in hc.get_hookimpls()\n    ]\n    assert hookimpls == [\n        (\"_pytest.config\", \"nonwrapper\"),\n        (m.__module__, \"nonwrapper\"),\n        (\"_pytest.legacypath\", \"nonwrapper\"),\n        (\"_pytest.capture\", \"wrapper\"),\n        (\"_pytest.warnings\", \"wrapper\"),\n    ]\n", "type": "function"}, {"name": "test_module_considers_pluginmanager_at_import", "is_method": true, "class_name": "TestModule", "parameters": ["self", "pytester"], "calls": ["pytester.getmodulecol", "pytest.raises"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 78, "end_line": 80}, "code_snippet": "    def test_module_considers_pluginmanager_at_import(self, pytester: Pytester) -> None:\n        modcol = pytester.getmodulecol(\"pytest_plugins='xasdlkj',\")\n        pytest.raises(ImportError, lambda: modcol.obj)\n", "type": "function"}, {"name": "pytestpm", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 21, "end_line": 22}, "code_snippet": "def pytestpm() -> PytestPluginManager:\n    return PytestPluginManager()\n", "type": "function"}, {"name": "test_pytester_runs_with_plugin", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.assert_outcomes"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 83, "end_line": 92}, "code_snippet": "def test_pytester_runs_with_plugin(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        pytest_plugins = \"pytester\"\n        def test_hello(pytester):\n            assert 1\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.assert_outcomes(passed=1)\n", "type": "function"}, {"name": "test_consider_conftest_deps", "is_method": true, "class_name": "TestPytestPluginManager", "parameters": ["self", "pytester", "pytestpm"], "calls": ["import_path", "pytester.makepyfile", "pytest.raises", "pytestpm.consider_conftest"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 410, "end_line": 421}, "code_snippet": "    def test_consider_conftest_deps(\n        self,\n        pytester: Pytester,\n        pytestpm: PytestPluginManager,\n    ) -> None:\n        mod = import_path(\n            pytester.makepyfile(\"pytest_plugins='xyz'\"),\n            root=pytester.path,\n            consider_namespace_packages=False,\n        )\n        with pytest.raises(ImportError):\n            pytestpm.consider_conftest(mod, registration_name=\"unused\")\n", "type": "function"}, {"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "test_disable_plugin_autoload", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch", "enable_plugin_method", "disable_plugin_method"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "monkeypatch.setattr", "monkeypatch.setitem", "pytester.parseconfig", "monkeypatch.setenv", "monkeypatch.setenv", "PseudoPlugin", "config.pluginmanager.get_plugin", "platform.python_implementation", "DummyEntryPoint", "self.attrs_used.append", "object", "Distribution", "monkeypatch.delenv", "parse_args.append", "monkeypatch.delenv", "parse_args.extend", "bool", "bool"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1320, "end_line": 1397}, "code_snippet": "def test_disable_plugin_autoload(\n    pytester: Pytester,\n    monkeypatch: MonkeyPatch,\n    enable_plugin_method: str,\n    disable_plugin_method: str,\n) -> None:\n    class DummyEntryPoint:\n        project_name = name = \"mytestplugin\"\n        group = \"pytest11\"\n        version = \"1.0\"\n\n        def load(self):\n            return sys.modules[self.name]\n\n    class Distribution:\n        metadata = {\"name\": \"foo\"}\n        entry_points = (DummyEntryPoint(),)\n        files = ()\n\n    class PseudoPlugin:\n        x = 42\n\n        attrs_used = []\n\n        def __getattr__(self, name):\n            assert name in (\"__loader__\", \"__spec__\")\n            self.attrs_used.append(name)\n            return object()\n\n    def distributions():\n        return (Distribution(),)\n\n    parse_args: list[str] = []\n\n    if disable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    elif disable_plugin_method == \"flag\":\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        parse_args.append(\"--disable-plugin-autoload\")\n    else:\n        assert disable_plugin_method == \"\"\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n\n    if enable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n    elif enable_plugin_method == \"flag\":\n        parse_args.extend([\"-p\", \"mytestplugin\"])\n    else:\n        assert enable_plugin_method == \"\"\n\n    monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n    monkeypatch.setitem(sys.modules, \"mytestplugin\", PseudoPlugin())\n    config = pytester.parseconfig(*parse_args)\n\n    has_loaded = config.pluginmanager.get_plugin(\"mytestplugin\") is not None\n    # it should load if it's enabled, or we haven't disabled autoloading\n    assert has_loaded == (bool(enable_plugin_method) or not disable_plugin_method)\n\n    # The reason for the discrepancy between 'has_loaded' and __loader__ being accessed\n    # appears to be the monkeypatching of importlib.metadata.distributions; where\n    # files being empty means that _mark_plugins_for_rewrite doesn't find the plugin.\n    # But enable_method==flag ends up in mark_rewrite being called and __loader__\n    # being accessed.\n    assert (\"__loader__\" in PseudoPlugin.attrs_used) == (\n        has_loaded\n        and not (enable_plugin_method in (\"env_var\", \"\") and not disable_plugin_method)\n    )\n\n    # __spec__ is accessed in AssertionRewritingHook.exec_module, which would be\n    # eventually called if we did a full pytest run; but it's only accessed with\n    # enable_plugin_method==\"env_var\" because that will early-load it.\n    # Except when autoloads aren't disabled, in which case PytestPluginManager.import_plugin\n    # bails out before importing it.. because it knows it'll be loaded later?\n    # The above seems a bit weird, but I *think* it's true.\n    if platform.python_implementation() != \"PyPy\":\n        assert (\"__spec__\" in PseudoPlugin.attrs_used) == bool(\n            enable_plugin_method == \"env_var\" and disable_plugin_method\n        )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.933274507522583}
{"question": "What is the purpose of the AssertionRewritingHook?", "answer": null, "relative_code_list": null, "ground_truth": "The AssertionRewritingHook serves as a PEP302/PEP451 import hook that rewrites assert statements in test modules to provide detailed introspection information when assertions fail. Its main purposes are: 1) Intercepts module imports and rewrites assert statements in test files before they are compiled to bytecode, 2) Transforms plain assert statements into detailed if-else blocks that provide intermediate values and explanations when assertions fail, 3) Caches rewritten modules as .pyc files with special pytest tags to avoid re-rewriting, 4) Only rewrites test modules (as defined by python_files config) and plugin modules, not production code, 5) Provides detailed assertion failure messages showing the actual values being compared, 6) Enables the use of plain assert statements instead of unittest-style assertion methods, 7) Supports the pytest_assertion_pass hook for custom behavior when assertions pass, 8) Handles concurrent pytest processes safely through atomic file operations, 9) Can be disabled for specific modules using PYTEST_DONT_REWRITE in docstrings, 10) Integrates with pytest's configuration system to determine which files to rewrite.", "score": null, "retrieved_content": [{"name": "AssertionRewritingHook", "docstring": "PEP302/PEP451 import hook which rewrites asserts.", "methods": ["__init__", "set_session", "find_spec", "create_module", "exec_module", "_early_rewrite_bailout", "_should_rewrite", "_is_marked_for_rewrite", "mark_rewrite", "_warn_already_imported", "get_data"], "attributes": ["_find_spec"], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 65, "end_line": 306}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "AssertionState", "parameters": ["self", "config", "mode"], "calls": ["config.trace.root.get"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 110, "end_line": 113}, "code_snippet": "    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook: rewrite.AssertionRewritingHook | None = None\n", "type": "function"}, {"name": "AssertionRewriter", "docstring": "Assertion rewriting implementation.\n\nThe main entrypoint is to call .run() with an ast.Module instance,\nthis will then find all the assert statements and rewrite them to\nprovide intermediate values and a detailed assertion error.  See\nhttp://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\nfor an overview of how this works.\n\nThe entry point here is .run() which will iterate over all the\nstatements in an ast.Module and for each ast.Assert statement it\nfinds call .visit() with it.  Then .visit_Assert() takes over and\nis responsible for creating new ast statements to replace the\noriginal assert statement: it rewrites the test of an assertion\nto provide intermediate values and replace it with an if statement\nwhich raises an assertion error with a detailed explanation in\ncase the expression is false and calls pytest_assertion_pass hook\nif expression is true.\n\nFor this .visit_Assert() uses the visitor pattern to visit all the\nAST nodes of the ast.Assert.test field, each visit call returning\nan AST node and the corresponding explanation string.  During this\nstate is kept in several instance attributes:\n\n:statements: All the AST statements which will replace the assert\n   statement.\n\n:variables: This is populated by .variable() with each variable\n   used by the statements so that they can all be set to None at\n   the end of the statements.\n\n:variable_counter: Counter to create new unique variables needed\n   by statements.  Variables are created using .variable() and\n   have the form of \"@py_assert0\".\n\n:expl_stmts: The AST statements which will be executed to get\n   data from the assertion.  This is the code which will construct\n   the detailed assertion message that is used in the AssertionError\n   or for the pytest_assertion_pass hook.\n\n:explanation_specifiers: A dict filled by .explanation_param()\n   with %-formatting placeholders and their corresponding\n   expressions to use in the building of an assertion message.\n   This is used by .pop_format_context() to build a message.\n\n:stack: A stack of the explanation_specifiers dicts maintained by\n   .push_format_context() and .pop_format_context() which allows\n   to build another %-formatted string while already building one.\n\n:scope: A tuple containing the current scope used for variables_overwrite.\n\n:variables_overwrite: A dict filled with references to variables\n   that change value within an assert. This happens when a variable is\n   reassigned with the walrus operator\n\nThis state, except the variables_overwrite,  is reset on every new assert\nstatement visited and used by the other visitors.", "methods": ["__init__", "run", "is_rewrite_disabled", "variable", "assign", "display", "helper", "builtin", "explanation_param", "push_format_context", "pop_format_context", "generic_visit", "visit_Assert", "visit_NamedExpr", "visit_Name", "visit_BoolOp", "visit_UnaryOp", "visit_BinOp", "visit_Call", "visit_Starred", "visit_Attribute", "visit_Compare"], "attributes": [], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 615, "end_line": 1176}, "type": "class"}, {"name": "test_rewrite_ast", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 328, "end_line": 371}, "code_snippet": "    def test_rewrite_ast(self, pytester: Pytester) -> None:\n        pytester.mkdir(\"pkg\")\n        contents = {\n            \"pkg/__init__.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite('pkg.helper')\n            \"\"\",\n            \"pkg/helper.py\": \"\"\"\n                def tool():\n                    a, b = 2, 3\n                    assert a == b\n            \"\"\",\n            \"pkg/plugin.py\": \"\"\"\n                import pytest, pkg.helper\n                @pytest.fixture\n                def tool():\n                    return pkg.helper.tool\n            \"\"\",\n            \"pkg/other.py\": \"\"\"\n                values = [3, 2]\n                def tool():\n                    assert values.pop() == 3\n            \"\"\",\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['pkg.plugin']\n            \"\"\",\n            \"test_pkg.py\": \"\"\"\n                import pkg.other\n                def test_tool(tool):\n                    tool()\n                def test_other():\n                    pkg.other.tool()\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(\"--assert=rewrite\")\n        result.stdout.fnmatch_lines(\n            [\n                \">*assert a == b*\",\n                \"E*assert 2 == 3*\",\n                \">*assert values.pop() == 3*\",\n                \"E*AssertionError\",\n            ]\n        )\n", "type": "function"}, {"name": "test_rewrite_infinite_recursion", "is_method": false, "class_name": null, "parameters": ["pytester", "pytestconfig", "monkeypatch"], "calls": ["pytester.syspathinsert", "pytester.makepyfile", "pytester.makepyfile", "monkeypatch.setattr", "monkeypatch.setattr", "AssertionRewritingHook", "hook.find_spec", "importlib.util.module_from_spec", "hook.exec_module", "write_pyc_called.append", "original_write_pyc", "len", "hook.find_spec"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1857, "end_line": 1888}, "code_snippet": "def test_rewrite_infinite_recursion(\n    pytester: Pytester, pytestconfig, monkeypatch\n) -> None:\n    \"\"\"Fix infinite recursion when writing pyc files: if an import happens to be triggered when writing the pyc\n    file, this would cause another call to the hook, which would trigger another pyc writing, which could\n    trigger another import, and so on. (#3506)\"\"\"\n    from _pytest.assertion import rewrite as rewritemod\n\n    pytester.syspathinsert()\n    pytester.makepyfile(test_foo=\"def test_foo(): pass\")\n    pytester.makepyfile(test_bar=\"def test_bar(): pass\")\n\n    original_write_pyc = rewritemod._write_pyc\n\n    write_pyc_called = []\n\n    def spy_write_pyc(*args, **kwargs):\n        # make a note that we have called _write_pyc\n        write_pyc_called.append(True)\n        # try to import a module at this point: we should not try to rewrite this module\n        assert hook.find_spec(\"test_bar\") is None\n        return original_write_pyc(*args, **kwargs)\n\n    monkeypatch.setattr(rewritemod, \"_write_pyc\", spy_write_pyc)\n    monkeypatch.setattr(sys, \"dont_write_bytecode\", False)\n\n    hook = AssertionRewritingHook(pytestconfig)\n    spec = hook.find_spec(\"test_foo\")\n    assert spec is not None\n    module = importlib.util.module_from_spec(spec)\n    hook.exec_module(module)\n    assert len(write_pyc_called) == 1\n", "type": "function"}, {"name": "_consider_importhook", "is_method": true, "class_name": "Config", "parameters": ["self", "args"], "calls": ["self._parser.parse_known_and_unknown_args", "getattr", "self._warn_about_missing_assertion", "getattr", "bool", "os.environ.get", "_pytest.assertion.install_importhook", "self._mark_plugins_for_rewrite"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 1269, "end_line": 1291}, "code_snippet": "    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n\n        disable_autoload = getattr(ns, \"disable_plugin_autoload\", False) or bool(\n            os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        )\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook, disable_autoload)\n        self._warn_about_missing_assertion(mode)\n", "type": "function"}, {"name": "test_assertion_rewrite", "is_method": true, "class_name": "TestGeneralUsage", "parameters": ["self", "pytester", "import_mode"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 159, "end_line": 169}, "code_snippet": "    def test_assertion_rewrite(self, pytester: Pytester, import_mode) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_this():\n                x = 0\n                assert x\n        \"\"\"\n        )\n        result = pytester.runpytest(p, f\"--import-mode={import_mode}\")\n        result.stdout.fnmatch_lines([\">       assert x\", \"E       assert 0\"])\n        assert result.ret == 1\n", "type": "function"}, {"name": "test_remember_rewritten_modules", "is_method": true, "class_name": "TestRewriteOnImport", "parameters": ["self", "pytestconfig", "pytester", "monkeypatch"], "calls": ["monkeypatch.syspath_prepend", "pytester.makepyfile", "AssertionRewritingHook", "monkeypatch.setattr", "hook.find_spec", "importlib.util.module_from_spec", "hook.exec_module", "hook.mark_rewrite", "hook.mark_rewrite", "warnings.append"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1232, "end_line": 1250}, "code_snippet": "    def test_remember_rewritten_modules(\n        self, pytestconfig, pytester: Pytester, monkeypatch\n    ) -> None:\n        \"\"\"`AssertionRewriteHook` should remember rewritten modules so it\n        doesn't give false positives (#2005).\"\"\"\n        monkeypatch.syspath_prepend(pytester.path)\n        pytester.makepyfile(test_remember_rewritten_modules=\"\")\n        warnings = []\n        hook = AssertionRewritingHook(pytestconfig)\n        monkeypatch.setattr(\n            hook, \"_warn_already_imported\", lambda code, msg: warnings.append(msg)\n        )\n        spec = hook.find_spec(\"test_remember_rewritten_modules\")\n        assert spec is not None\n        module = importlib.util.module_from_spec(spec)\n        hook.exec_module(module)\n        hook.mark_rewrite(\"test_remember_rewritten_modules\")\n        hook.mark_rewrite(\"test_remember_rewritten_modules\")\n        assert warnings == []\n", "type": "function"}, {"name": "hook", "is_method": true, "class_name": "TestEarlyRewriteBailout", "parameters": ["self", "pytestconfig", "monkeypatch", "pytester"], "calls": ["set", "AssertionRewritingHook", "self.find_spec_calls.append", "importlib.machinery.PathFinder.find_spec", "mock.patch.object", "monkeypatch.setattr", "hook.set_session", "pytester.syspathinsert", "StubSession"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1893, "end_line": 1920}, "code_snippet": "    def hook(\n        self, pytestconfig, monkeypatch, pytester: Pytester\n    ) -> Generator[AssertionRewritingHook]:\n        \"\"\"Returns a patched AssertionRewritingHook instance so we can configure its initial paths and track\n        if PathFinder.find_spec has been called.\n        \"\"\"\n        import importlib.machinery\n\n        self.find_spec_calls: list[str] = []\n        self.initial_paths: set[Path] = set()\n\n        class StubSession:\n            _initialpaths = self.initial_paths\n\n            def isinitpath(self, p):\n                return p in self._initialpaths\n\n        def spy_find_spec(name, path):\n            self.find_spec_calls.append(name)\n            return importlib.machinery.PathFinder.find_spec(name, path)\n\n        hook = AssertionRewritingHook(pytestconfig)\n        # use default patterns, otherwise we inherit pytest's testing config\n        with mock.patch.object(hook, \"fnpats\", [\"test_*.py\", \"*_test.py\"]):\n            monkeypatch.setattr(hook, \"_find_spec\", spy_find_spec)\n            hook.set_session(StubSession())  # type: ignore[arg-type]\n            pytester.syspathinsert()\n            yield hook\n", "type": "function"}, {"name": "test_basic", "is_method": true, "class_name": "TestEarlyRewriteBailout", "parameters": ["self", "pytester", "hook"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.makepyfile", "pytester.makepyfile", "self.initial_paths.add", "hook.find_spec", "hook.find_spec", "hook.find_spec", "hook.find_spec"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1922, "end_line": 1953}, "code_snippet": "    def test_basic(self, pytester: Pytester, hook: AssertionRewritingHook) -> None:\n        \"\"\"\n        Ensure we avoid calling PathFinder.find_spec when we know for sure a certain\n        module will not be rewritten to optimize assertion rewriting (#3918).\n        \"\"\"\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def fix(): return 1\n        \"\"\"\n        )\n        pytester.makepyfile(test_foo=\"def test_foo(): pass\")\n        pytester.makepyfile(bar=\"def bar(): pass\")\n        foobar_path = pytester.makepyfile(foobar=\"def foobar(): pass\")\n        self.initial_paths.add(foobar_path)\n\n        # conftest files should always be rewritten\n        assert hook.find_spec(\"conftest\") is not None\n        assert self.find_spec_calls == [\"conftest\"]\n\n        # files matching \"python_files\" mask should always be rewritten\n        assert hook.find_spec(\"test_foo\") is not None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\"]\n\n        # file does not match \"python_files\": early bailout\n        assert hook.find_spec(\"bar\") is None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\"]\n\n        # file is an initial path (passed on the command-line): should be rewritten\n        assert hook.find_spec(\"foobar\") is not None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\", \"foobar\"]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.012995481491089}
{"question": "What is the difference between direct and indirect parametrization in pytest?", "answer": null, "relative_code_list": null, "ground_truth": "Direct and indirect parametrization in pytest differ in how parameter values are handled: 1) Direct parametrization (default) - parameter values are passed directly to the test function as arguments during test execution, 2) Indirect parametrization (indirect=True) - parameter values are passed to fixture functions via request.param, allowing the fixture to process or transform the values before providing them to the test, 3) Direct parametrization happens at collection time and creates separate test instances for each parameter value, 4) Indirect parametrization allows expensive setup operations to be performed in fixtures at test execution time rather than collection time, 5) Direct parametrization is simpler and more straightforward for basic parameter passing, 6) Indirect parametrization enables more complex parameter processing, validation, or resource setup in fixtures, 7) Indirect parametrization can be applied selectively to specific arguments using a list of argument names, 8) Direct parametrization creates test IDs based on the parameter values themselves, 9) Indirect parametrization can use fixture-defined IDs and scoping, 10) Direct parametrization is more efficient for simple parameter passing, while indirect is better for complex setup scenarios.", "score": null, "retrieved_content": [{"name": "test_parametrize_auto_scope_indirect", "is_method": true, "class_name": "TestMetafuncFunctionalAuto", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1712, "end_line": 1733}, "code_snippet": "    def test_parametrize_auto_scope_indirect(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session')\n            def echo(request):\n                return request.param\n\n            @pytest.mark.parametrize('animal, echo', [(\"dog\", 1), (\"cat\", 2)], indirect=['echo'])\n            def test_1(animal, echo):\n                assert animal in ('dog', 'cat')\n                assert echo in (1, 2, 3)\n\n            @pytest.mark.parametrize('animal, echo', [('fish', 3)], indirect=['echo'])\n            def test_2(animal, echo):\n                assert animal == 'fish'\n                assert echo in (1, 2, 3)\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])\n", "type": "function"}, {"name": "test_parametrize_all_indirects", "is_method": true, "class_name": "TestMetafuncFunctionalAuto", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1752, "end_line": 1777}, "code_snippet": "    def test_parametrize_all_indirects(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def animal(request):\n                return request.param\n\n            @pytest.fixture(scope='session')\n            def echo(request):\n                return request.param\n\n            @pytest.mark.parametrize('animal, echo', [(\"dog\", 1), (\"cat\", 2)], indirect=True)\n            def test_1(animal, echo):\n                assert animal in ('dog', 'cat')\n                assert echo in (1, 2, 3)\n\n            @pytest.mark.parametrize('animal, echo', [(\"fish\", 3)], indirect=True)\n            def test_2(animal, echo):\n                assert animal == 'fish'\n                assert echo in (1, 2, 3)\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])\n", "type": "function"}, {"name": "test_parametrize_functional", "is_method": true, "class_name": "TestMetafunc", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 974, "end_line": 993}, "code_snippet": "    def test_parametrize_functional(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('x', [1,2], indirect=True)\n                metafunc.parametrize('y', [2])\n            @pytest.fixture\n            def x(request):\n                return request.param * 10\n\n            def test_simple(x,y):\n                assert x in (10,20)\n                assert y == 2\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_simple*1-2*\", \"*test_simple*2-2*\", \"*2 passed*\"]\n        )\n", "type": "function"}, {"name": "test_parametrize_and_inner_getfixturevalue", "is_method": true, "class_name": "TestMetafuncFunctional", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1258, "end_line": 1280}, "code_snippet": "    def test_parametrize_and_inner_getfixturevalue(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize(\"arg1\", [1], indirect=True)\n                metafunc.parametrize(\"arg2\", [10], indirect=True)\n\n            import pytest\n            @pytest.fixture\n            def arg1(request):\n                x = request.getfixturevalue(\"arg2\")\n                return x + request.param\n\n            @pytest.fixture\n            def arg2(request):\n                return request.param\n\n            def test_func1(arg1, arg2):\n                assert arg1 == 11\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines([\"*test_func1*1*PASS*\", \"*1 passed*\"])\n", "type": "function"}, {"name": "test_parametrize_on_setup_arg", "is_method": true, "class_name": "TestMetafuncFunctional", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1282, "end_line": 1303}, "code_snippet": "    def test_parametrize_on_setup_arg(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                assert \"arg1\" in metafunc.fixturenames\n                metafunc.parametrize(\"arg1\", [1], indirect=True)\n\n            import pytest\n            @pytest.fixture\n            def arg1(request):\n                return request.param\n\n            @pytest.fixture\n            def arg2(request, arg1):\n                return 10 * arg1\n\n            def test_func(arg2):\n                assert arg2 == 10\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines([\"*test_func*1*PASS*\", \"*1 passed*\"])\n", "type": "function"}, {"name": "test_parametrize_onearg_indirect", "is_method": true, "class_name": "TestMetafunc", "parameters": ["self"], "calls": ["self.Metafunc", "metafunc.parametrize", "dict", "dict"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1004, "end_line": 1010}, "code_snippet": "    def test_parametrize_onearg_indirect(self) -> None:\n        metafunc = self.Metafunc(lambda x: None)\n        metafunc.parametrize(\"x\", [1, 2], indirect=True)\n        assert metafunc._calls[0].params == dict(x=1)\n        assert metafunc._calls[0].id == \"1\"\n        assert metafunc._calls[1].params == dict(x=2)\n        assert metafunc._calls[1].id == \"2\"\n", "type": "function"}, {"name": "test_parametrize_overrides_indirect_dependency_fixture", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "rec.assertoutcome"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 527, "end_line": 558}, "code_snippet": "    def test_parametrize_overrides_indirect_dependency_fixture(\n        self, pytester: Pytester\n    ) -> None:\n        \"\"\"Test parametrization when parameter overrides a fixture that a test indirectly depends on\"\"\"\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            fix3_instantiated = False\n\n            @pytest.fixture\n            def fix1(fix2):\n               return fix2 + '1'\n\n            @pytest.fixture\n            def fix2(fix3):\n               return fix3 + '2'\n\n            @pytest.fixture\n            def fix3():\n               global fix3_instantiated\n               fix3_instantiated = True\n               return '3'\n\n            @pytest.mark.parametrize('fix2', ['2'])\n            def test_it(fix1):\n               assert fix1 == '21'\n               assert not fix3_instantiated\n        \"\"\"\n        )\n        rec = pytester.inline_run()\n        rec.assertoutcome(passed=1)\n", "type": "function"}, {"name": "get_direct_param_fixture_func", "is_method": false, "class_name": null, "parameters": ["request"], "calls": [], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1109, "end_line": 1110}, "code_snippet": "def get_direct_param_fixture_func(request: FixtureRequest) -> Any:\n    return request.param\n", "type": "function"}, {"name": "test_override_parametrize_fixture_and_indirect", "is_method": true, "class_name": "TestFillFixtures", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 490, "end_line": 524}, "code_snippet": "    def test_override_parametrize_fixture_and_indirect(\n        self, pytester: Pytester\n    ) -> None:\n        \"\"\"Override a fixture at a lower level, reusing the higher-level fixture that\n        is parametrized, while also using indirect parametrization.\n        \"\"\"\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2])\n            def foo(request):\n                return request.param\n            \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def foo(foo):\n                return foo * 2\n\n            @pytest.fixture\n            def bar(request):\n                return request.param * 100\n\n            @pytest.mark.parametrize(\"bar\", [42], indirect=True)\n            def test_spam(bar, foo):\n                assert bar == 4200\n                assert foo in (2, 4)\n            \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_parametrize_scope_overrides", "is_method": true, "class_name": "TestMetafuncFunctional", "parameters": ["self", "pytester", "scope", "length"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1442, "end_line": 1466}, "code_snippet": "    def test_parametrize_scope_overrides(\n        self, pytester: Pytester, scope: str, length: int\n    ) -> None:\n        pytester.makepyfile(\n            f\"\"\"\n            import pytest\n            values = []\n            def pytest_generate_tests(metafunc):\n                if \"arg\" in metafunc.fixturenames:\n                    metafunc.parametrize(\"arg\", [1,2], indirect=True,\n                                         scope={scope!r})\n            @pytest.fixture\n            def arg(request):\n                values.append(request.param)\n                return request.param\n            def test_hello(arg):\n                assert arg in (1,2)\n            def test_world(arg):\n                assert arg in (1,2)\n            def test_checklength():\n                assert len(values) == {length}\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=5)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.0567355155944824}
{"question": "What are the core components of Pytest's test runner?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's test runner consists of several core components: 1) Session class - the root of the collection tree that manages test collection and execution state, 2) Config class - handles configuration, plugin management, and command-line options, 3) PytestPluginManager - manages plugin registration and hook invocation, 4) Test execution protocol with three phases: setup, call, and teardown, 5) Runner module that implements the runtestprotocol function for executing individual test items, 6) Hook system using pluggy for extensibility, 7) Essential plugins including main, runner, fixtures, and mark plugins that provide core functionality.", "score": null, "retrieved_content": [{"name": "pytest_runtestloop", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["enumerate", "session.Interrupted", "item.config.hook.pytest_runtest_protocol", "session.Failed", "session.Interrupted", "len"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 356, "end_line": 372}, "code_snippet": "def pytest_runtestloop(session: Session) -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            f\"{session.testsfailed} error{'s' if session.testsfailed != 1 else ''} during collection\"\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n", "type": "function"}, {"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self"], "calls": ["__init__", "set", "self.add_hookspecs", "self.register", "os.environ.get", "DummyRewriteHook", "lru_cache", "getattr", "self.trace.root.setwriter", "self.enable_tracing", "super", "open", "os.dup", "err.fileno"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 401, "end_line": 451}, "code_snippet": "    def __init__(self) -> None:\n        from _pytest.assertion import DummyRewriteHook\n        from _pytest.assertion import RewriteHook\n\n        super().__init__(\"pytest\")\n\n        # -- State related to local conftest plugins.\n        # All loaded conftest modules.\n        self._conftest_plugins: set[types.ModuleType] = set()\n        # All conftest modules applicable for a directory.\n        # This includes the directory's own conftest modules as well\n        # as those of its parent directories.\n        self._dirpath2confmods: dict[pathlib.Path, list[types.ModuleType]] = {}\n        # Cutoff directory above which conftests are no longer discovered.\n        self._confcutdir: pathlib.Path | None = None\n        # If set, conftest loading is skipped.\n        self._noconftest = False\n\n        # _getconftestmodules()'s call to _get_directory() causes a stat\n        # storm when it's called potentially thousands of times in a test\n        # session (#9478), often with the same path, so cache it.\n        self._get_directory = lru_cache(256)(_get_directory)\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: list[tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook: RewriteHook = DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Testdir", "parameters": ["self", "pytester"], "calls": ["check_ispytest"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 55, "end_line": 57}, "code_snippet": "    def __init__(self, pytester: Pytester, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pytester = pytester\n", "type": "function"}, {"name": "Pytester", "docstring": "Facilities to write tests/configuration files, execute pytest in isolation, and match\nagainst expected output, perfect for black-box testing of pytest plugins.\n\nIt attempts to isolate the test run from external factors as much as possible, modifying\nthe current working directory to :attr:`path` and environment variables during initialization.", "methods": ["__init__", "path", "__repr__", "_finalize", "__take_sys_modules_snapshot", "make_hook_recorder", "chdir", "_makefile", "makefile", "makeconftest", "makeini", "getinicfg", "makepyprojecttoml", "makepyfile", "maketxtfile", "syspathinsert", "mkdir", "mkpydir", "copy_example", "getnode", "getpathnode", "genitems", "runitem", "inline_runsource", "inline_genitems", "inline_run", "runpytest_inprocess", "runpytest", "_ensure_basetemp", "parseconfig", "parseconfigure", "getitem", "getitems", "getmodulecol", "collect_by_name", "popen", "run", "_dump_lines", "_getpytestargs", "runpython", "runpython_c", "runpytest_subprocess", "spawn_pytest", "spawn"], "attributes": ["__test__"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 649, "end_line": 1536}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Pytester", "parameters": ["self", "request", "tmp_path_factory", "monkeypatch"], "calls": ["check_ispytest", "WeakKeyDictionary", "tmp_path_factory.mktemp", "SysPathsSnapshot", "self.__take_sys_modules_snapshot", "self._request.addfinalizer", "self._request.config.getoption", "tmp_path_factory.mktemp", "self.chdir", "mp.setenv", "mp.delenv", "mp.delenv", "str", "mp.setenv", "mp.setenv", "mp.setenv", "str"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 665, "end_line": 709}, "code_snippet": "    def __init__(\n        self,\n        request: FixtureRequest,\n        tmp_path_factory: TempPathFactory,\n        monkeypatch: MonkeyPatch,\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._request = request\n        self._mod_collections: WeakKeyDictionary[Collector, list[Item | Collector]] = (\n            WeakKeyDictionary()\n        )\n        if request.function:\n            name: str = request.function.__name__\n        else:\n            name = request.node.name\n        self._name = name\n        self._path: Path = tmp_path_factory.mktemp(name, numbered=True)\n        #: A list of plugins to use with :py:meth:`parseconfig` and\n        #: :py:meth:`runpytest`. Initially this is an empty list but plugins can\n        #: be added to the list.\n        #:\n        #: When running in subprocess mode, specify plugins by name (str) - adding\n        #: plugin objects directly is not supported.\n        self.plugins: list[str | _PluggyPlugin] = []\n        self._sys_path_snapshot = SysPathsSnapshot()\n        self._sys_modules_snapshot = self.__take_sys_modules_snapshot()\n        self._request.addfinalizer(self._finalize)\n        self._method = self._request.config.getoption(\"--runpytest\")\n        self._test_tmproot = tmp_path_factory.mktemp(f\"tmp-{name}\", numbered=True)\n\n        self._monkeypatch = mp = monkeypatch\n        self.chdir()\n        mp.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(self._test_tmproot))\n        # Ensure no unexpected caching via tox.\n        mp.delenv(\"TOX_ENV_DIR\", raising=False)\n        # Discard outer pytest options.\n        mp.delenv(\"PYTEST_ADDOPTS\", raising=False)\n        # Ensure no user config is used.\n        tmphome = str(self.path)\n        mp.setenv(\"HOME\", tmphome)\n        mp.setenv(\"USERPROFILE\", tmphome)\n        # Do not use colors for inner runs by default.\n        mp.setenv(\"PY_COLORS\", \"0\")\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "MarkGenerator", "parameters": ["self"], "calls": ["check_ispytest", "set"], "code_location": {"file": "structures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/mark", "start_line": 559, "end_line": 562}, "code_snippet": "    def __init__(self, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._config: Config | None = None\n        self._markers: set[str] = set()\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "pytest_runtest_protocol", "is_method": false, "class_name": null, "parameters": ["item", "nextitem"], "calls": ["ihook.pytest_runtest_logstart", "runtestprotocol", "ihook.pytest_runtest_logfinish"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 114, "end_line": 119}, "code_snippet": "def pytest_runtest_protocol(item: Item, nextitem: Item | None) -> bool:\n    ihook = item.ihook\n    ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True\n", "type": "function"}, {"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}], "retrieved_count": 10, "cost_time": 2.1417853832244873}
{"question": "What is Pytest's approach to handling test isolation?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's approach to test isolation is based on fixture scoping and automatic cleanup: 1) Fixture scoping system with five levels: function (default), class, module, package, and session - each test gets its own instance based on scope, 2) Automatic fixture execution where each test receives fresh fixture instances to ensure clean state, 3) Fixture dependency injection that creates isolated objects for each test, 4) Teardown/cleanup mechanism using yield statements in fixtures for automatic resource cleanup, 5) Scope hierarchy where higher-scoped fixtures are created before lower-scoped ones, 6) Fixture caching within scope - only one instance per scope is maintained, 7) Automatic grouping of tests by fixture instances to minimize active fixtures, 8) Fixture finalization that ensures proper cleanup even when tests fail, 9) Dependency resolution that ensures fixtures are executed in correct order, 10) Autouse fixtures for automatic setup/teardown without explicit requests, 11) Fixture availability rules that prevent cross-contamination between different test scopes, 12) Deterministic fixture collection and execution order.", "score": null, "retrieved_content": [{"name": "pytester", "is_method": false, "class_name": null, "parameters": ["request", "tmp_path_factory", "monkeypatch"], "calls": ["Pytester"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 477, "end_line": 490}, "code_snippet": "def pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.\n    \"\"\"\n    return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)\n", "type": "function"}, {"name": "Pytester", "docstring": "Facilities to write tests/configuration files, execute pytest in isolation, and match\nagainst expected output, perfect for black-box testing of pytest plugins.\n\nIt attempts to isolate the test run from external factors as much as possible, modifying\nthe current working directory to :attr:`path` and environment variables during initialization.", "methods": ["__init__", "path", "__repr__", "_finalize", "__take_sys_modules_snapshot", "make_hook_recorder", "chdir", "_makefile", "makefile", "makeconftest", "makeini", "getinicfg", "makepyprojecttoml", "makepyfile", "maketxtfile", "syspathinsert", "mkdir", "mkpydir", "copy_example", "getnode", "getpathnode", "genitems", "runitem", "inline_runsource", "inline_genitems", "inline_run", "runpytest_inprocess", "runpytest", "_ensure_basetemp", "parseconfig", "parseconfigure", "getitem", "getitems", "getmodulecol", "collect_by_name", "popen", "run", "_dump_lines", "_getpytestargs", "runpython", "runpython_c", "runpytest_subprocess", "spawn_pytest", "spawn"], "attributes": ["__test__"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 649, "end_line": 1536}, "type": "class"}, {"name": "test_method_setup_uses_fresh_instances", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.inline_runsource", "reprec.assertoutcome"], "code_location": {"file": "test_runner_xunit.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 170, "end_line": 182}, "code_snippet": "def test_method_setup_uses_fresh_instances(pytester: Pytester) -> None:\n    reprec = pytester.inline_runsource(\n        \"\"\"\n        class TestSelfState1(object):\n            memory = []\n            def test_hello(self):\n                self.memory.append(self)\n\n            def test_afterhello(self):\n                assert self != self.memory[0]\n    \"\"\"\n    )\n    reprec.assertoutcome(passed=2, failed=0)\n", "type": "function"}, {"name": "test_no_carry_over", "is_method": true, "class_name": "TestPerTestCapturing", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.str"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 209, "end_line": 222}, "code_snippet": "    def test_no_carry_over(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_func1():\n                print(\"in func1\")\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = pytester.runpytest(p)\n        s = result.stdout.str()\n        assert \"in func1\" not in s\n        assert \"in func2\" in s\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 161, "end_line": 163}, "code_snippet": "def pytester(pytester: Pytester, monkeypatch: MonkeyPatch) -> Pytester:\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return pytester\n", "type": "function"}, {"name": "test_inline_run_test_module_not_cleaned_up", "is_method": true, "class_name": "TestInlineRunModulesCleanup", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "test_mod.write_text", "pytester.inline_run", "str", "str"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 220, "end_line": 227}, "code_snippet": "    def test_inline_run_test_module_not_cleaned_up(self, pytester: Pytester) -> None:\n        test_mod = pytester.makepyfile(\"def test_foo(): assert True\")\n        result = pytester.inline_run(str(test_mod))\n        assert result.ret == ExitCode.OK\n        # rewrite module, now test should fail if module was re-imported\n        test_mod.write_text(\"def test_foo(): assert False\", encoding=\"utf-8\")\n        result2 = pytester.inline_run(str(test_mod))\n        assert result2.ret == ExitCode.TESTS_FAILED\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_new_instances", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 132, "end_line": 144}, "code_snippet": "def test_new_instances(pytester: Pytester) -> None:\n    testpath = pytester.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            def test_func1(self):\n                self.x = 2\n            def test_func2(self):\n                assert not hasattr(self, 'x')\n    \"\"\"\n    )\n    reprec = pytester.inline_run(testpath)\n    reprec.assertoutcome(passed=2)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TempdirFactory", "parameters": ["self", "tmppath_factory"], "calls": ["check_ispytest"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 281, "end_line": 285}, "code_snippet": "    def __init__(\n        self, tmppath_factory: TempPathFactory, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._tmppath_factory = tmppath_factory\n", "type": "function"}, {"name": "autouse_pytester", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytest.fixture"], "code_location": {"file": "test_pathlib.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 52, "end_line": 62}, "code_snippet": "def autouse_pytester(pytester: Pytester) -> None:\n    \"\"\"\n    Fixture to make pytester() being autouse for all tests in this module.\n\n    pytester makes sure to restore sys.path to its previous state, and many tests in this module\n    import modules and change sys.path because of that, so common module names such as \"test\" or \"test.conftest\"\n    end up leaking to tests in other modules.\n\n    Note: we might consider extracting the sys.path restoration aspect into its own fixture, and apply it\n    to the entire test suite always.\n    \"\"\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.1841988563537598}
{"question": "What is the purpose of the FixtureDef class?", "answer": null, "relative_code_list": null, "ground_truth": "The FixtureDef class serves as a container for fixture definitions and manages the lifecycle of fixtures in pytest. Its main purposes include: 1) Encapsulating all metadata about a fixture including its function, scope, parameters, and IDs, 2) Managing fixture visibility through baseid which determines which nodes can access the fixture, 3) Handling fixture parametrization with params and ids attributes for multiple fixture instances, 4) Storing cached results to avoid re-executing fixtures within their scope, 5) Managing fixture dependencies through argnames which lists the fixtures this fixture requires, 6) Providing scope management with _scope attribute that determines fixture lifecycle, 7) Handling fixture finalization through _finalizers list for cleanup operations, 8) Supporting fixture execution through execute() method that runs the fixture function, 9) Managing fixture caching through cache_key() method for efficient reuse, 10) Providing fixture lookup and resolution in the fixture manager system, 11) Supporting autouse fixtures through _autouse flag for automatic activation, 12) Enabling fixture override mechanisms where fixtures can override others with the same name.", "score": null, "retrieved_content": [{"name": "FixtureDef", "docstring": "A container for a fixture definition.\n\nNote: At this time, only explicitly documented fields and methods are\nconsidered public stable API.", "methods": ["__init__", "scope", "addfinalizer", "finish", "execute", "cache_key", "__repr__"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 976, "end_line": 1140}, "type": "class"}, {"name": "PseudoFixtureDef", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 114, "end_line": 116}, "type": "class"}, {"name": "FixtureFunctionDefinition", "docstring": "", "methods": ["__init__", "__repr__", "__get__", "__call__", "_get_wrapped_function"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1252, "end_line": 1297}, "type": "class"}, {"name": "TestFixtureMarker", "docstring": "", "methods": ["test_parametrize", "test_multiple_parametrization_issue_736", "test_override_parametrized_fixture_issue_979", "test_scope_session", "test_scope_session_exc", "test_scope_session_exc_two_fix", "test_scope_exc", "test_scope_module_uses_session", "test_scope_module_and_finalizer", "test_scope_mismatch_various", "test_scope_mismatch_already_computed_dynamic", "test_dynamic_scope", "test_dynamic_scope_bad_return", "test_register_only_with_mark", "test_parametrize_and_scope", "test_scope_mismatch", "test_parametrize_separated_order", "test_module_parametrized_ordering", "test_dynamic_parametrized_ordering", "test_class_ordering", "test_parametrize_separated_order_higher_scope_first", "test_parametrized_fixture_teardown_order", "test_fixture_finalizer", "test_class_scope_with_normal_tests", "test_request_is_clean", "test_parametrize_separated_lifecycle", "test_parametrize_function_scoped_finalizers_called", "test_finalizer_order_on_parametrization", "test_class_scope_parametrization_ordering", "test_parametrize_setup_function", "test_fixture_marked_function_not_collected_as_test", "test_params_and_ids", "test_params_and_ids_yieldfixture", "test_deterministic_fixture_collection"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2375, "end_line": 3427}, "type": "class"}, {"name": "FixtureFunctionMarker", "docstring": "", "methods": ["__post_init__", "__call__"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1212, "end_line": 1248}, "type": "class"}, {"name": "TestFixtureUsages", "docstring": "", "methods": ["test_noargfixturedec", "test_receives_funcargs", "test_receives_funcargs_scope_mismatch", "test_receives_funcargs_scope_mismatch_issue660", "test_invalid_scope", "test_parameters_without_eq_semantics", "test_funcarg_parametrized_and_used_twice", "test_factory_uses_unknown_funcarg_as_dependency_error", "test_factory_setup_as_classes_fails", "test_usefixtures_marker", "test_empty_usefixtures_marker", "test_usefixtures_ini", "test_usefixtures_seen_in_showmarkers", "test_request_instance_issue203", "test_fixture_parametrized_with_iterator", "test_setup_functions_as_fixtures", "test_parameterized_fixture_caching", "test_unwrapping_pytest_fixture", "test_fixture_wrapped_looks_liked_wrapped_function"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1221, "end_line": 1680}, "type": "class"}, {"name": "TestFixtureReporting", "docstring": "", "methods": ["test_setup_fixture_error", "test_teardown_fixture_error", "test_teardown_fixture_error_and_test_failure", "test_setup_teardown_output_and_test_failure"], "attributes": [], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 652, "end_line": 749}, "type": "class"}, {"name": "FixtureLookupError", "docstring": "Could not return a requested fixture (missing or invalid).", "methods": ["__init__", "formatrepr"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 816, "end_line": 879}, "type": "class"}, {"name": "FunctionDefinition", "docstring": "This class is a stop gap solution until we evolve to have actual function\ndefinition nodes and manage to get rid of ``metafunc``.", "methods": ["runtest"], "attributes": ["setup"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1716, "end_line": 1723}, "type": "class"}, {"name": "TestFillFixtures", "docstring": "", "methods": ["test_funcarg_lookupfails", "test_detect_recursive_dependency_error", "test_funcarg_basic", "test_funcarg_lookup_modulelevel", "test_funcarg_lookup_classlevel", "test_conftest_funcargs_only_available_in_subdir", "test_extend_fixture_module_class", "test_extend_fixture_conftest_module", "test_extend_fixture_conftest_conftest", "test_extend_fixture_conftest_plugin", "test_extend_fixture_plugin_plugin", "test_override_parametrized_fixture_conftest_module", "test_override_parametrized_fixture_conftest_conftest", "test_override_non_parametrized_fixture_conftest_module", "test_override_non_parametrized_fixture_conftest_conftest", "test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest", "test_override_fixture_reusing_super_fixture_parametrization", "test_override_parametrize_fixture_and_indirect", "test_override_top_level_fixture_reusing_super_fixture_parametrization", "test_override_parametrized_fixture_with_new_parametrized_fixture", "test_autouse_fixture_plugin", "test_funcarg_lookup_error", "test_fixture_excinfo_leak"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 134, "end_line": 676}, "type": "class"}], "retrieved_count": 10, "cost_time": 2.499323606491089}
{"question": "What error handling mechanisms does Pytest use for test failures?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest uses several error handling mechanisms for test failures: 1) TestReport class - captures test outcomes (passed, failed, skipped) with detailed exception information, 2) CallInfo class - wraps function calls with exception handling and timing information, 3) ExceptionInfo class - provides detailed exception representation with traceback information, 4) Three-phase test execution (setup, call, teardown) with separate error handling for each phase, 5) sys.last_type, sys.last_value, sys.last_traceback storage for postmortem debugging, 6) Interactive exception handling with pytest_exception_interact hook, 7) Different outcome types: passed, failed, skipped, error (for setup/teardown failures), 8) Longrepr mechanism for detailed failure reporting, 9) Exception chaining support for complex error scenarios, 10) Error categorization (E for errors, F for failures) in test summaries, 11) Maxfail mechanism to stop after N failures, 12) PDB integration for debugging on failures.", "score": null, "retrieved_content": [{"name": "test_pytest_fail", "is_method": false, "class_name": null, "parameters": [], "calls": ["excinfo.exconly", "s.startswith", "pytest.raises", "pytest.fail"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 621, "end_line": 625}, "code_snippet": "def test_pytest_fail() -> None:\n    with pytest.raises(pytest.fail.Exception) as excinfo:\n        pytest.fail(\"hello\")\n    s = excinfo.exconly(tryshort=True)\n    assert s.startswith(\"Failed\")\n", "type": "function"}, {"name": "test_conftest_exception_handling", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "line.strip"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 728, "end_line": 742}, "code_snippet": "def test_conftest_exception_handling(pytester: Pytester) -> None:\n    pytester.makeconftest(\n        \"\"\"\\\n        raise ValueError()\n        \"\"\"\n    )\n    pytester.makepyfile(\n        \"\"\"\\\n        def test_some():\n            pass\n        \"\"\"\n    )\n    res = pytester.runpytest()\n    assert res.ret == 4\n    assert \"raise ValueError()\" in [line.strip() for line in res.errlines]\n", "type": "function"}, {"name": "test_teardown_fixture_error_and_test_failure", "is_method": true, "class_name": "TestFixtureReporting", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 697, "end_line": 721}, "code_snippet": "    def test_teardown_fixture_error_and_test_failure(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_fail():\n                assert 0, \"failingfunc\"\n\n            def teardown_function(function):\n                print(\"teardown func\")\n                assert False\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR at teardown of test_fail*\",\n                \"*teardown_function(function):*\",\n                \"*assert False*\",\n                \"*Captured stdout*\",\n                \"*teardown func*\",\n                \"*test_fail*\",\n                \"*def test_fail():\",\n                \"*failingfunc*\",\n                \"*1 failed*1 error*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_stop_iteration_runtest_protocol", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.assert_outcomes", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1626, "end_line": 1654}, "code_snippet": "def test_stop_iteration_runtest_protocol(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        test_it=\"\"\"\n        import pytest\n        @pytest.fixture\n        def fail_setup():\n            raise StopIteration(1)\n        def test_fail_setup(fail_setup):\n            pass\n        def test_fail_teardown(request):\n            def stop_iteration():\n                raise StopIteration(2)\n            request.addfinalizer(stop_iteration)\n        def test_fail_call():\n            raise StopIteration(3)\n        \"\"\"\n    )\n    result = pytester.runpytest()\n    assert result.ret == ExitCode.TESTS_FAILED\n    result.assert_outcomes(failed=1, passed=1, errors=2)\n    result.stdout.fnmatch_lines(\n        [\n            \"=* short test summary info =*\",\n            \"FAILED test_it.py::test_fail_call - StopIteration: 3\",\n            \"ERROR test_it.py::test_fail_setup - StopIteration: 1\",\n            \"ERROR test_it.py::test_fail_teardown - StopIteration: 2\",\n            \"=* 1 failed, 1 passed, 2 errors in * =*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_wrap_session_notify_exception", "is_method": false, "class_name": null, "parameters": ["ret_exc", "pytester"], "calls": ["pytest.mark.parametrize", "pytester.makeconftest", "pytester.runpytest", "pytest.param", "pytest.param", "pytest.param"], "code_location": {"file": "test_main.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 26, "end_line": 65}, "code_snippet": "def test_wrap_session_notify_exception(ret_exc, pytester: Pytester) -> None:\n    returncode, exc = ret_exc\n    c1 = pytester.makeconftest(\n        f\"\"\"\n        import pytest\n\n        def pytest_sessionstart():\n            raise {exc.__name__}(\"boom\")\n\n        def pytest_internalerror(excrepr, excinfo):\n            returncode = {returncode!r}\n            if returncode is not False:\n                pytest.exit(\"exiting after %s...\" % excinfo.typename, returncode={returncode!r})\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    if returncode:\n        assert result.ret == returncode\n    else:\n        assert result.ret == ExitCode.INTERNAL_ERROR\n    assert result.stdout.lines[0] == \"INTERNALERROR> Traceback (most recent call last):\"\n\n    end_lines = result.stdout.lines[-3:]\n\n    if exc == SystemExit:\n        assert end_lines == [\n            f'INTERNALERROR>   File \"{c1}\", line 4, in pytest_sessionstart',\n            'INTERNALERROR>     raise SystemExit(\"boom\")',\n            \"INTERNALERROR> SystemExit: boom\",\n        ]\n    else:\n        assert end_lines == [\n            f'INTERNALERROR>   File \"{c1}\", line 4, in pytest_sessionstart',\n            'INTERNALERROR>     raise ValueError(\"boom\")',\n            \"INTERNALERROR> ValueError: boom\",\n        ]\n    if returncode is False:\n        assert result.stderr.lines == [\"mainloop: caught unexpected SystemExit!\"]\n    else:\n        assert result.stderr.lines == [f\"Exit: exiting after {exc.__name__}...\"]\n", "type": "function"}, {"name": "test_notify_exception", "is_method": false, "class_name": null, "parameters": ["pytester", "capfd"], "calls": ["pytester.parseconfig", "config.notify_exception", "capfd.readouterr", "config.pluginmanager.register", "config.notify_exception", "capfd.readouterr", "pytester.parseconfig", "config.notify_exception", "capfd.readouterr", "pytest.raises", "ValueError", "A", "pytest.raises", "ValueError"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1510, "end_line": 1532}, "code_snippet": "def test_notify_exception(pytester: Pytester, capfd) -> None:\n    config = pytester.parseconfig()\n    with pytest.raises(ValueError) as excinfo:\n        raise ValueError(1)\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert \"ValueError\" in err\n\n    class A:\n        def pytest_internalerror(self):\n            return True\n\n    config.pluginmanager.register(A())\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert not err\n\n    config = pytester.parseconfig(\"-p\", \"no:terminal\")\n    with pytest.raises(ValueError) as excinfo:\n        raise ValueError(1)\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert \"ValueError\" in err\n", "type": "function"}, {"name": "test_internal_error", "is_method": true, "class_name": "TestPython", "parameters": ["self", "pytester", "run_and_parse", "xunit_family"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "run_and_parse", "dom.get_first_by_tag", "node.assert_attr", "node.get_first_by_tag", "tnode.assert_attr", "tnode.get_first_by_tag", "fnode.assert_attr", "fnode.toxml"], "code_location": {"file": "test_junitxml.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 541, "end_line": 554}, "code_snippet": "    def test_internal_error(\n        self, pytester: Pytester, run_and_parse: RunAndParse, xunit_family: str\n    ) -> None:\n        pytester.makeconftest(\"def pytest_runtest_protocol(): 0 / 0\")\n        pytester.makepyfile(\"def test_function(): pass\")\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.get_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=1, tests=1)\n        tnode = node.get_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"pytest\", name=\"internal\")\n        fnode = tnode.get_first_by_tag(\"error\")\n        fnode.assert_attr(message=\"internal error\")\n        assert \"Division\" in fnode.toxml()\n", "type": "function"}, {"name": "test_teardown_with_test_also_failing", "is_method": true, "class_name": "TestProgressWithTeardown", "parameters": ["self", "pytester", "contest_with_teardown_fixture"], "calls": ["pytester.makepyfile", "pytester.runpytest", "output.stdout.re_match_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2456, "end_line": 2472}, "code_snippet": "    def test_teardown_with_test_also_failing(\n        self, pytester: Pytester, contest_with_teardown_fixture\n    ) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_foo(fail_teardown):\n                assert 0\n        \"\"\"\n        )\n        output = pytester.runpytest(\"-rfE\")\n        output.stdout.re_match_lines(\n            [\n                r\"test_teardown_with_test_also_failing.py FE\\s+\\[100%\\]\",\n                \"FAILED test_teardown_with_test_also_failing.py::test_foo - assert 0\",\n                \"ERROR test_teardown_with_test_also_failing.py::test_foo - assert False\",\n            ]\n        )\n", "type": "function"}, {"name": "test_fail_on_errors", "is_method": false, "class_name": null, "parameters": ["error_pytester"], "calls": ["error_pytester.runpytest", "result.stdout.str", "_strip_resource_warnings"], "code_location": {"file": "test_stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 170, "end_line": 177}, "code_snippet": "def test_fail_on_errors(error_pytester: Pytester) -> None:\n    result = error_pytester.runpytest(\"-v\", \"--strict-markers\", \"--stepwise\")\n\n    assert _strip_resource_warnings(result.stderr.lines) == []\n    stdout = result.stdout.str()\n\n    assert \"test_error ERROR\" in stdout\n    assert \"test_success_after_fail\" not in stdout\n", "type": "function"}, {"name": "error_pytester", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile"], "code_location": {"file": "test_stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 67, "end_line": 78}, "code_snippet": "def error_pytester(pytester: Pytester) -> Pytester:\n    pytester.makepyfile(\n        test_a=\"\"\"\ndef test_error(nonexisting_fixture):\n    assert 1\n\ndef test_success_after_fail():\n    assert 1\n\"\"\"\n    )\n\n    return pytester\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.7690787315368652}
{"question": "What is the role of the Session class in pytest?", "answer": null, "relative_code_list": null, "ground_truth": "The Session class serves as the root of the collection tree and the main orchestrator of the pytest test execution process. Its key roles include: 1) Root collector that initiates test collection from the initial paths given as command line arguments, 2) Manages the overall test session state including testsfailed and testscollected counters, 3) Coordinates the collection phase through perform_collect() method which discovers and organizes test items, 4) Maintains the collection tree hierarchy with items list containing all discovered test items, 5) Handles session-level control flow with shouldstop and shouldfail flags for early termination, 6) Integrates with fixture management through _fixturemanager and setup state through _setupstate, 7) Provides session-scoped configuration access and plugin management, 8) Manages collection caching and duplicate handling for efficient test discovery, 9) Coordinates with the test runner through pytest_runtestloop hook, 10) Handles session-level hooks like pytest_sessionstart and pytest_sessionfinish, 11) Maintains exit status and error handling for the entire test session, 12) Serves as the entry point for the main test execution protocol.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "pytest_sessionstart", "is_method": true, "class_name": "StepwisePlugin", "parameters": ["self", "session"], "calls": [], "code_location": {"file": "stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 126, "end_line": 127}, "code_snippet": "    def pytest_sessionstart(self, session: Session) -> None:\n        self.session = session\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["SetupState"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 106, "end_line": 107}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._setupstate = SetupState()\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["FixtureManager"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 119, "end_line": 120}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": [], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 922, "end_line": 932}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    \"\"\"Called after the ``Session`` object has been created and before performing collection\n    and entering the run test loop.\n\n    :param session: The pytest session object.\n\n    Use in conftest plugins\n    =======================\n\n    This hook is only called for :ref:`initial conftests <pluginorder>`.\n    \"\"\"\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.config.stash.get", "assertstate.hook.set_session"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 132, "end_line": 139}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    # This hook is only called when test modules are collected\n    # so for example not in the managing process of pytest-xdist\n    # (which does not collect test modules).\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.perform_collect"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 352, "end_line": 353}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    session.perform_collect()\n", "type": "function"}, {"name": "pytest_sessionfinish", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session._setupstate.teardown_exact"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 110, "end_line": 111}, "code_snippet": "def pytest_sessionfinish(session: Session) -> None:\n    session._setupstate.teardown_exact(None)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FixtureManager", "parameters": ["self", "session"], "calls": ["set", "session.config.pluginmanager.register", "self.config.getini"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1532, "end_line": 1545}, "code_snippet": "    def __init__(self, session: Session) -> None:\n        self.session = session\n        self.config: Config = session.config\n        # Maps a fixture name (argname) to all of the FixtureDefs in the test\n        # suite/plugins defined with this name. Populated by parsefactories().\n        # TODO: The order of the FixtureDefs list of each arg is significant,\n        #       explain.\n        self._arg2fixturedefs: Final[dict[str, list[FixtureDef[Any]]]] = {}\n        self._holderobjseen: Final[set[object]] = set()\n        # A mapping from a nodeid to a list of autouse fixtures it defines.\n        self._nodeid_autousenames: Final[dict[str, list[str]]] = {\n            \"\": self.config.getini(\"usefixtures\"),\n        }\n        session.config.pluginmanager.register(self, \"funcmanage\")\n", "type": "function"}, {"name": "pytest_sessionfinish", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.config.stash.get", "assertstate.hook.set_session"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 198, "end_line": 202}, "code_snippet": "def pytest_sessionfinish(session: Session) -> None:\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(None)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.7974493503570557}
{"question": "What is the relationship between Pytest's hook system and plugin execution order in the test lifecycle?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between Pytest's hook system and plugin execution order in the test lifecycle is fundamental to how pytest orchestrates test execution. The relationship works as follows: 1) Hook system provides the execution framework where plugins implement hook functions that are called at specific points in the test lifecycle, with execution order controlled by tryfirst/trylast markers and plugin loading order, 2) Plugin execution order is determined by the plugin discovery sequence: command line blocking, built-in plugins, external plugins, environment variables, and conftest files, with later-loaded plugins generally executing after earlier ones, 3) Hook execution follows a 1:N pattern where multiple plugins can implement the same hook specification, with the plugin manager calling all implementations in order, 4) Hook wrappers execute around other hook implementations, providing cross-cutting functionality and allowing pre/post processing of hook results, 5) The test lifecycle is divided into distinct phases (initialization, collection, test running, reporting) with specific hooks for each phase, and plugin execution order affects behavior at each phase, 6) Plugin execution order impacts fixture resolution, as plugins that define fixtures earlier in the loading order may be overridden by later plugins with the same fixture names, 7) Hook execution order affects configuration processing, as plugins that load earlier can influence configuration that affects later plugins, 8) The hook system enables plugin collaboration where plugins can access other plugins through the plugin manager and modify behavior based on execution order, 9) Plugin execution order affects error handling and reporting, as earlier plugins may handle errors that prevent later plugins from executing, 10) The hook system provides hooks like pytest_plugin_registered that allow plugins to be notified when other plugins are loaded, enabling coordination based on execution order, 11) Plugin execution order impacts the overall test execution flow, as plugins that implement critical hooks (like pytest_runtestloop) must execute in the correct order to maintain proper test lifecycle, 12) The relationship ensures that the test lifecycle proceeds in a predictable, coordinated manner while allowing plugins to extend and modify behavior at appropriate points.", "score": null, "retrieved_content": [{"name": "test_load_initial_conftest_last_ordering", "is_method": false, "class_name": null, "parameters": ["_config_for_test"], "calls": ["My", "pm.register", "hc.get_hookimpls"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1541, "end_line": 1564}, "code_snippet": "def test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    hookimpls = [\n        (\n            hookimpl.function.__module__,\n            \"wrapper\" if (hookimpl.wrapper or hookimpl.hookwrapper) else \"nonwrapper\",\n        )\n        for hookimpl in hc.get_hookimpls()\n    ]\n    assert hookimpls == [\n        (\"_pytest.config\", \"nonwrapper\"),\n        (m.__module__, \"nonwrapper\"),\n        (\"_pytest.legacypath\", \"nonwrapper\"),\n        (\"_pytest.capture\", \"wrapper\"),\n        (\"_pytest.warnings\", \"wrapper\"),\n    ]\n", "type": "function"}, {"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "test_pytest_fixture_setup_and_post_finalizer_hook", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4144, "end_line": 4184}, "code_snippet": "def test_pytest_fixture_setup_and_post_finalizer_hook(pytester: Pytester) -> None:\n    pytester.makeconftest(\n        \"\"\"\n        def pytest_fixture_setup(fixturedef, request):\n            print('ROOT setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        def pytest_fixture_post_finalizer(fixturedef, request):\n            print('ROOT finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n    \"\"\"\n    )\n    pytester.makepyfile(\n        **{\n            \"tests/conftest.py\": \"\"\"\n            def pytest_fixture_setup(fixturedef, request):\n                print('TESTS setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n            def pytest_fixture_post_finalizer(fixturedef, request):\n                print('TESTS finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        \"\"\",\n            \"tests/test_hooks.py\": \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def my_fixture():\n                return 'some'\n\n            def test_func(my_fixture):\n                print('TEST test_func')\n                assert my_fixture == 'some'\n        \"\"\",\n        }\n    )\n    result = pytester.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*TESTS setup hook called for my_fixture from test_func*\",\n            \"*ROOT setup hook called for my_fixture from test_func*\",\n            \"*TEST test_func*\",\n            \"*TESTS finalizer hook called for my_fixture from test_func*\",\n            \"*ROOT finalizer hook called for my_fixture from test_func*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_plugin_loading_order", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.syspathinsert", "pytester.runpytest", "str"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1401, "end_line": 1422}, "code_snippet": "def test_plugin_loading_order(pytester: Pytester) -> None:\n    \"\"\"Test order of plugin loading with `-p`.\"\"\"\n    p1 = pytester.makepyfile(\n        \"\"\"\n        def test_terminal_plugin(request):\n            import myplugin\n            assert myplugin.terminal_plugin == [False, True]\n        \"\"\",\n        myplugin=\"\"\"\n            terminal_plugin = []\n\n            def pytest_configure(config):\n                terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n\n            def pytest_sessionstart(session):\n                config = session.config\n                terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n            \"\"\",\n    )\n    pytester.syspathinsert()\n    result = pytester.runpytest(\"-p\", \"myplugin\", str(p1))\n    assert result.ret == 0\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "test_addhooks_conftestplugin", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester", "_config_for_test"], "calls": ["pytester.makepyfile", "pytester.makeconftest", "pm.hook.pytest_addhooks.call_historic", "config.pluginmanager._importconftest", "config.hook.pytest_myhook", "dict"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 26, "end_line": 57}, "code_snippet": "    def test_addhooks_conftestplugin(\n        self, pytester: Pytester, _config_for_test: Config\n    ) -> None:\n        pytester.makepyfile(\n            newhooks=\"\"\"\n            def pytest_myhook(xyz):\n                \"new hook\"\n        \"\"\"\n        )\n        conf = pytester.makeconftest(\n            \"\"\"\n            import newhooks\n            def pytest_addhooks(pluginmanager):\n                pluginmanager.add_hookspecs(newhooks)\n            def pytest_myhook(xyz):\n                return xyz + 1\n        \"\"\"\n        )\n        config = _config_for_test\n        pm = config.pluginmanager\n        pm.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=config.pluginmanager)\n        )\n        config.pluginmanager._importconftest(\n            conf,\n            importmode=\"prepend\",\n            rootpath=pytester.path,\n            consider_namespace_packages=False,\n        )\n        # print(config.pluginmanager.get_plugins())\n        res = config.hook.pytest_myhook(xyz=10)\n        assert res == [11]\n", "type": "function"}, {"name": "test_runtest_in_module_ordering", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 570, "end_line": 599}, "code_snippet": "def test_runtest_in_module_ordering(pytester: Pytester) -> None:\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import pytest\n        def pytest_runtest_setup(item): # runs after class-level!\n            item.function.mylist.append(\"module\")\n        class TestClass(object):\n            def pytest_runtest_setup(self, item):\n                assert not hasattr(item.function, 'mylist')\n                item.function.mylist = ['class']\n            @pytest.fixture\n            def mylist(self, request):\n                return request.function.mylist\n            @pytest.hookimpl(wrapper=True)\n            def pytest_runtest_call(self, item):\n                try:\n                    yield\n                except ValueError:\n                    pass\n            def test_hello1(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n                raise ValueError()\n            def test_hello2(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n        def pytest_runtest_teardown(item):\n            del item.function.mylist\n    \"\"\"\n    )\n    result = pytester.runpytest(p1)\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_early_load_setuptools_name", "is_method": true, "class_name": "TestGeneralUsage", "parameters": ["self", "pytester", "monkeypatch", "load_cov_early"], "calls": ["pytest.mark.parametrize", "monkeypatch.delenv", "pytester.makepyfile", "pytester.makepyfile", "pytester.makepyfile", "pytester.syspathinsert", "monkeypatch.setattr", "pytester.runpytest_inprocess", "DummyEntryPoint", "DummyEntryPoint", "DummyEntryPoint", "__import__", "loaded.append", "DummyDist"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 113, "end_line": 156}, "code_snippet": "    def test_early_load_setuptools_name(\n        self, pytester: Pytester, monkeypatch, load_cov_early\n    ) -> None:\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n\n        pytester.makepyfile(mytestplugin1_module=\"\")\n        pytester.makepyfile(mytestplugin2_module=\"\")\n        pytester.makepyfile(mycov_module=\"\")\n        pytester.syspathinsert()\n\n        loaded = []\n\n        @dataclasses.dataclass\n        class DummyEntryPoint:\n            name: str\n            module: str\n            group: str = \"pytest11\"\n\n            def load(self):\n                __import__(self.module)\n                loaded.append(self.name)\n                return sys.modules[self.module]\n\n        entry_points = [\n            DummyEntryPoint(\"myplugin1\", \"mytestplugin1_module\"),\n            DummyEntryPoint(\"myplugin2\", \"mytestplugin2_module\"),\n            DummyEntryPoint(\"mycov\", \"mycov_module\"),\n        ]\n\n        @dataclasses.dataclass\n        class DummyDist:\n            entry_points: object\n            files: object = ()\n\n        def my_dists():\n            return (DummyDist(entry_points),)\n\n        monkeypatch.setattr(importlib.metadata, \"distributions\", my_dists)\n        params = (\"-p\", \"mycov\") if load_cov_early else ()\n        pytester.runpytest_inprocess(*params)\n        if load_cov_early:\n            assert loaded == [\"mycov\", \"myplugin1\", \"myplugin2\"]\n        else:\n            assert loaded == [\"myplugin1\", \"myplugin2\", \"mycov\"]\n", "type": "function"}, {"name": "test_preparse_ordering_with_setuptools", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.delenv", "monkeypatch.setattr", "pytester.makeconftest", "monkeypatch.setenv", "pytester.parseconfig", "config.pluginmanager.getplugin", "PseudoPlugin", "EntryPoint"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1194, "end_line": 1226}, "code_snippet": "def test_preparse_ordering_with_setuptools(\n    pytester: Pytester, monkeypatch: MonkeyPatch\n) -> None:\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n    class EntryPoint:\n        name = \"mytestplugin\"\n        group = \"pytest11\"\n\n        def load(self):\n            class PseudoPlugin:\n                x = 42\n\n            return PseudoPlugin()\n\n    class Dist:\n        files = ()\n        metadata = {\"name\": \"foo\"}\n        entry_points = (EntryPoint(),)\n\n    def my_dists():\n        return (Dist,)\n\n    monkeypatch.setattr(importlib.metadata, \"distributions\", my_dists)\n    pytester.makeconftest(\n        \"\"\"\n        pytest_plugins = \"mytestplugin\",\n    \"\"\"\n    )\n    monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n    config = pytester.parseconfig()\n    plugin = config.pluginmanager.getplugin(\"mytestplugin\")\n    assert plugin.x == 42\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HookRecorder", "parameters": ["self", "pluginmanager"], "calls": ["check_ispytest", "pluginmanager.add_hookcall_monitoring", "self.calls.append", "RecordedHookCall"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 258, "end_line": 273}, "code_snippet": "    def __init__(\n        self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n\n        self._pluginmanager = pluginmanager\n        self.calls: list[RecordedHookCall] = []\n        self.ret: int | ExitCode | None = None\n\n        def before(hook_name: str, hook_impls, kwargs) -> None:\n            self.calls.append(RecordedHookCall(hook_name, kwargs))\n\n        def after(outcome, hook_name: str, hook_impls, kwargs) -> None:\n            pass\n\n        self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.810093641281128}
{"question": "Where is the \"pytest_runtest_setup\" hook defined in the plugin hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "The \"pytest_runtest_setup\" hook is defined in the plugin hierarchy in src/_pytest/hookspec.py at line 732. This hook specification is defined using the @hookspec decorator and serves as part of the test running (runtest) hooks category in pytest's hook system. The hook is called to perform the setup phase for a test item and is part of the three-phase test execution protocol (setup, call, teardown). The hook signature takes a single parameter 'item' of type Item, which represents the test item being set up. The default implementation runs setup() on the item and all of its parents that haven't been setup yet, including obtaining the values of fixtures required by the item. The hook can be implemented by any conftest plugin, and for a given item, only conftest files in the item's directory and its parent directories are consulted. The hook is part of the runtest protocol that includes pytest_runtest_logstart, pytest_runtest_setup, pytest_runtest_call, pytest_runtest_teardown, and pytest_runtest_logfinish hooks, all orchestrated by the pytest_runtest_protocol hook.", "score": null, "retrieved_content": [{"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "test_capture_conftest_runtest_setup", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.no_fnmatch_line"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 789, "end_line": 799}, "code_snippet": "def test_capture_conftest_runtest_setup(pytester: Pytester) -> None:\n    pytester.makeconftest(\n        \"\"\"\n        def pytest_runtest_setup():\n            print(\"hello19\")\n    \"\"\"\n    )\n    pytester.makepyfile(\"def test_func(): pass\")\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.no_fnmatch_line(\"*hello19*\")\n", "type": "function"}, {"name": "pytest_runtest_setup", "is_method": false, "class_name": null, "parameters": ["item"], "calls": ["_update_current_test_var", "item.session._setupstate.setup"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 162, "end_line": 164}, "code_snippet": "def pytest_runtest_setup(item: Item) -> None:\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.setup(item)\n", "type": "function"}, {"name": "test_runtest_in_module_ordering", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 570, "end_line": 599}, "code_snippet": "def test_runtest_in_module_ordering(pytester: Pytester) -> None:\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import pytest\n        def pytest_runtest_setup(item): # runs after class-level!\n            item.function.mylist.append(\"module\")\n        class TestClass(object):\n            def pytest_runtest_setup(self, item):\n                assert not hasattr(item.function, 'mylist')\n                item.function.mylist = ['class']\n            @pytest.fixture\n            def mylist(self, request):\n                return request.function.mylist\n            @pytest.hookimpl(wrapper=True)\n            def pytest_runtest_call(self, item):\n                try:\n                    yield\n                except ValueError:\n                    pass\n            def test_hello1(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n                raise ValueError()\n            def test_hello2(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n        def pytest_runtest_teardown(item):\n            del item.function.mylist\n    \"\"\"\n    )\n    result = pytester.runpytest(p1)\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "pytest_runtest_setup", "is_method": true, "class_name": "LoggingPlugin", "parameters": ["self", "item"], "calls": ["hookimpl", "self.log_cli_handler.set_when", "self._runtest_for"], "code_location": {"file": "logging.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 837, "end_line": 843}, "code_snippet": "    def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None]:\n        self.log_cli_handler.set_when(\"setup\")\n\n        empty: dict[str, list[logging.LogRecord]] = {}\n        item.stash[caplog_records_key] = empty\n        with self._runtest_for(item, \"setup\"):\n            yield\n", "type": "function"}, {"name": "pytest_runtest_setup", "is_method": false, "class_name": null, "parameters": ["item"], "calls": ["isinstance", "hasattr", "item.fspath.relto", "item.getparent", "print"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/doc/en/example/assertion/global_testmodule_config", "start_line": 11, "end_line": 17}, "code_snippet": "def pytest_runtest_setup(item):\n    if isinstance(item, pytest.Function):\n        if not item.fspath.relto(mydir):\n            return\n        mod = item.getparent(pytest.Module).obj\n        if hasattr(mod, \"hello\"):\n            print(f\"mod.hello {mod.hello!r}\")\n", "type": "function"}, {"name": "pytest_runtest_setup", "is_method": true, "class_name": "CaptureManager", "parameters": ["self", "item"], "calls": ["hookimpl", "self.item_capture"], "code_location": {"file": "capture.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 893, "end_line": 895}, "code_snippet": "    def pytest_runtest_setup(self, item: Item) -> Generator[None]:\n        with self.item_capture(\"setup\", item):\n            return (yield)\n", "type": "function"}, {"name": "test_load_initial_conftest_last_ordering", "is_method": false, "class_name": null, "parameters": ["_config_for_test"], "calls": ["My", "pm.register", "hc.get_hookimpls"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1541, "end_line": 1564}, "code_snippet": "def test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    hookimpls = [\n        (\n            hookimpl.function.__module__,\n            \"wrapper\" if (hookimpl.wrapper or hookimpl.hookwrapper) else \"nonwrapper\",\n        )\n        for hookimpl in hc.get_hookimpls()\n    ]\n    assert hookimpls == [\n        (\"_pytest.config\", \"nonwrapper\"),\n        (m.__module__, \"nonwrapper\"),\n        (\"_pytest.legacypath\", \"nonwrapper\"),\n        (\"_pytest.capture\", \"wrapper\"),\n        (\"_pytest.warnings\", \"wrapper\"),\n    ]\n", "type": "function"}, {"name": "test_hookimpl_via_function_attributes_are_deprecated", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager", "pytest.warns", "pm.register", "DeprecatedMarkImplPlugin"], "code_location": {"file": "deprecated_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 49, "end_line": 70}, "code_snippet": "def test_hookimpl_via_function_attributes_are_deprecated():\n    from _pytest.config import PytestPluginManager\n\n    pm = PytestPluginManager()\n\n    class DeprecatedMarkImplPlugin:\n        def pytest_runtest_call(self):\n            pass\n\n        pytest_runtest_call.tryfirst = True  # type: ignore[attr-defined]\n\n    with pytest.warns(\n        PytestDeprecationWarning,\n        match=r\"Please use the pytest.hookimpl\\(tryfirst=True\\)\",\n    ) as recorder:\n        pm.register(DeprecatedMarkImplPlugin())\n    (record,) = recorder\n    assert (\n        record.lineno\n        == DeprecatedMarkImplPlugin.pytest_runtest_call.__code__.co_firstlineno\n    )\n    assert record.filename == __file__\n", "type": "function"}, {"name": "pytest_runtest_setup", "is_method": false, "class_name": null, "parameters": ["item"], "calls": [], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 732, "end_line": 748}, "code_snippet": "def pytest_runtest_setup(item: Item) -> None:\n    \"\"\"Called to perform the setup phase for a test item.\n\n    The default implementation runs ``setup()`` on ``item`` and all of its\n    parents (which haven't been setup yet). This includes obtaining the\n    values of fixtures required by the item (which haven't been obtained\n    yet).\n\n    :param item:\n        The item.\n\n    Use in conftest plugins\n    =======================\n\n    Any conftest file can implement this hook. For a given item, only conftest\n    files in the item's directory and its parent directories are consulted.\n    \"\"\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1381478309631348}
{"question": "Where in Pytest's codebase is the \"pytest_configure\" hook defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"pytest_configure\" hook is defined in the pytest codebase in src/_pytest/hookspec.py at line 141. This hook specification is defined using the @hookspec decorator and serves as the initialization hook that allows plugins and conftest files to perform initial configuration. The hook is called for every initial conftest file after command line options have been parsed, and then called for other conftest files as they are registered. The hook signature takes a single parameter 'config' of type Config, which is the pytest config object. The hook is marked as historic=True, meaning it can be called multiple times during the test session lifecycle. The hook is incompatible with hook wrappers and is part of the initialization hooks category in pytest's hook system. The actual implementation of this hook is provided by various plugins and conftest files throughout the pytest ecosystem, with the hook system calling all registered implementations when the hook is invoked.", "score": null, "retrieved_content": [{"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getoption", "config.pluginmanager.register", "StepwisePlugin"], "code_location": {"file": "stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 53, "end_line": 58}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    # --stepwise-skip/--stepwise-reset implies stepwise.\n    if config.option.stepwise_skip or config.option.stepwise_reset:\n        config.option.stepwise = True\n    if config.getoption(\"stepwise\"):\n        config.pluginmanager.register(StepwisePlugin(config), \"stepwiseplugin\")\n", "type": "function"}, {"name": "_do_configure", "is_method": true, "class_name": "Config", "parameters": ["self"], "calls": ["self.hook.pytest_configure.call_historic", "dict"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 1116, "end_line": 1119}, "code_snippet": "    def _do_configure(self) -> None:\n        assert not self._configured\n        self._configured = True\n        self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getini", "UsageError"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/mark", "start_line": 287, "end_line": 297}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.stash[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            f\"{EMPTY_PARAMETERSET_OPTION!s} must be one of skip, xfail or fail_at_collect\"\n            f\" but it is {empty_parameterset!r}\"\n        )\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["TerminalReporter", "config.pluginmanager.register", "config.trace.root.setprocessor", "join", "reporter.write_line", "map"], "code_location": {"file": "terminal.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 287, "end_line": 296}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    reporter = TerminalReporter(config, sys.stdout)\n    config.pluginmanager.register(reporter, \"terminalreporter\")\n    if config.option.debug or config.option.traceconfig:\n\n        def mywriter(tags, args):\n            msg = \" \".join(map(str, args))\n            reporter.write_line(\"[traceconfig] \" + msg)\n\n        config.trace.root.setprocessor(\"pytest:config\", mywriter)\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["collections.deque", "config.add_cleanup", "functools.partial", "functools.partial"], "code_location": {"file": "unraisableexception.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 143, "end_line": 148}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    prev_hook = sys.unraisablehook\n    deque: collections.deque[UnraisableMeta | BaseException] = collections.deque()\n    config.stash[unraisable_exceptions] = deque\n    config.add_cleanup(functools.partial(cleanup, config=config, prev_hook=prev_hook))\n    sys.unraisablehook = functools.partial(unraisable_hook, append=deque.append)\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getvalue", "config.addinivalue_line", "LsofFdLeakChecker", "checker.matching_platform", "config.pluginmanager.register"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 108, "end_line": 118}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    if config.getvalue(\"lsof\"):\n        checker = LsofFdLeakChecker()\n        if checker.matching_platform():\n            config.pluginmanager.register(checker)\n\n    config.addinivalue_line(\n        \"markers\",\n        \"pytester_example_path(*path_segments): join the given path \"\n        \"segments to `pytester_example_dir` for this test.\",\n    )\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.addinivalue_line", "config.addinivalue_line"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 117, "end_line": 134}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures \",\n    )\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["hookimpl", "Cache.for_config", "config.pluginmanager.register", "config.pluginmanager.register", "LFPlugin", "NFPlugin"], "code_location": {"file": "cacheprovider.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 551}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.cache = Cache.for_config(config, _ispytest=True)\n    config.pluginmanager.register(LFPlugin(config), \"lfplugin\")\n    config.pluginmanager.register(NFPlugin(config), \"nfplugin\")\n", "type": "function"}, {"name": "pytest_configure", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self", "config"], "calls": ["config.addinivalue_line", "config.addinivalue_line"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 526, "end_line": 542}, "code_snippet": "    def pytest_configure(self, config: Config) -> None:\n        \"\"\":meta private:\"\"\"\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers.\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible. \"\n            \"DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible. \"\n            \"DEPRECATED, use @pytest.hookimpl(trylast=True) instead.\",\n        )\n        self._configured = True\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2451660633087158}
{"question": "Where are Pytest's built-in fixture implementations located?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's built-in fixture implementations are located across multiple modules in the src/_pytest/ directory, with each fixture implemented in its respective plugin module: 1) Capture-related fixtures (capfd, capfdbinary, capsys, capsysbinary, capteesys) are implemented in src/_pytest/capture.py, 2) Logging fixture (caplog) is implemented in src/_pytest/logging.py, 3) Cache fixture is implemented in src/_pytest/cacheprovider.py, 4) Monkeypatch fixture is implemented in src/_pytest/monkeypatch.py, 5) Temporary directory fixtures (tmp_path, tmp_path_factory) are implemented in src/_pytest/tmpdir.py, 6) Warning recording fixture (recwarn) is implemented in src/_pytest/recwarn.py, 7) Configuration fixture (pytestconfig) is implemented in src/_pytest/config/__init__.py, 8) Request fixture is implemented in src/_pytest/fixtures.py as part of the FixtureRequest class, 9) Test directory fixture (testdir) is implemented in src/_pytest/pytester.py, 10) Doctest namespace fixture is implemented in src/_pytest/doctest.py, 11) Property recording fixtures (record_property, record_testsuite_property) are implemented in src/_pytest/junitxml.py, 12) These fixtures are automatically loaded as part of the default plugins defined in src/_pytest/config/__init__.py and are available to all tests without requiring explicit import or registration.", "score": null, "retrieved_content": [{"name": "_showfixtures_main", "is_method": false, "class_name": null, "parameters": ["config", "session"], "calls": ["session.perform_collect", "_pytest.config.create_terminal_writer", "config.get_verbosity", "set", "fm._arg2fixturedefs.items", "available.sort", "tw.write", "tw.write", "tw.write", "inspect.getdoc", "tw.line", "getlocation", "seen.add", "available.append", "argname.startswith", "tw.write", "write_docstring", "tw.line", "module.startswith", "tw.line", "tw.sep", "len", "_pretty_fixture_path", "doc.split"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1959, "end_line": 2013}, "code_snippet": "def _showfixtures_main(config: Config, session: Session) -> None:\n    import _pytest.config\n\n    session.perform_collect()\n    invocation_dir = config.invocation_params.dir\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.get_verbosity()\n\n    fm = session._fixturemanager\n\n    available = []\n    seen: set[tuple[str, str]] = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, invocation_dir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    _pretty_fixture_path(invocation_dir, fixturedef.func),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, prettypath, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", f\"fixtures defined from {module}\")\n                currentmodule = module\n        if verbose <= 0 and argname.startswith(\"_\"):\n            continue\n        tw.write(f\"{argname}\", green=True)\n        if fixturedef.scope != \"function\":\n            tw.write(f\" [{fixturedef.scope} scope]\", cyan=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        doc = inspect.getdoc(fixturedef.func)\n        if doc:\n            write_docstring(\n                tw, doc.split(\"\\n\\n\", maxsplit=1)[0] if verbose <= 0 else doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n        tw.line()\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_show_fixtures", "is_method": true, "class_name": "TestShowFixtures", "parameters": ["self", "pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3580, "end_line": 3589}, "code_snippet": "    def test_show_fixtures(self, pytester: Pytester) -> None:\n        result = pytester.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmp_path_factory [[]session scope[]] -- .../_pytest/tmpdir.py:*\",\n                \"*for the test session*\",\n                \"tmp_path -- .../_pytest/tmpdir.py:*\",\n                \"*temporary directory*\",\n            ]\n        )\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1685, "end_line": 1703}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"conftest\"\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_pytestconfig_is_session_scoped", "is_method": false, "class_name": null, "parameters": [], "calls": ["getfixturemarker"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 266, "end_line": 271}, "code_snippet": "def test_pytestconfig_is_session_scoped() -> None:\n    from _pytest.fixtures import pytestconfig\n\n    marker = getfixturemarker(pytestconfig)\n    assert marker is not None\n    assert marker.scope == \"session\"\n", "type": "function"}, {"name": "test_fixture_help", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_fixture.py", "path": "/data3/pwh/swebench-repos/pytest/testing/logging", "start_line": 30, "end_line": 32}, "code_snippet": "def test_fixture_help(pytester: Pytester) -> None:\n    result = pytester.runpytest(\"--fixtures\")\n    result.stdout.fnmatch_lines([\"*caplog*\"])\n", "type": "function"}, {"name": "test_show_fixtures_verbose", "is_method": true, "class_name": "TestShowFixtures", "parameters": ["self", "pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3591, "end_line": 3600}, "code_snippet": "    def test_show_fixtures_verbose(self, pytester: Pytester) -> None:\n        result = pytester.runpytest(\"--fixtures\", \"-v\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmp_path_factory [[]session scope[]] -- .../_pytest/tmpdir.py:*\",\n                \"*for the test session*\",\n                \"tmp_path -- .../_pytest/tmpdir.py:*\",\n                \"*temporary directory*\",\n            ]\n        )\n", "type": "function"}, {"name": "showfixtures", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["wrap_session"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1953, "end_line": 1956}, "code_snippet": "def showfixtures(config: Config) -> int | ExitCode:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n", "type": "function"}, {"name": "test_parsefactories_conftest", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1721, "end_line": 1733}, "code_snippet": "    def test_parsefactories_conftest(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_hello(item, fm):\n                for name in (\"fm\", \"hello\", \"item\"):\n                    faclist = fm.getfixturedefs(name, item)\n                    assert len(faclist) == 1\n                    fac = faclist[0]\n                    assert fac.func.__name__ == name\n        \"\"\"\n        )\n        reprec = pytester.inline_run(\"-s\")\n        reprec.assertoutcome(passed=1)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0436689853668213}
{"question": "Where in Pytest's codebase is the \"Session\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"Session\" class is defined in the pytest codebase in src/_pytest/main.py at line 548. This class inherits from nodes.Collector and serves as the root of the collection tree in pytest's test discovery and execution system. The Session class is responsible for collecting the initial paths given as arguments to pytest and orchestrating the overall test session. Key attributes of the Session class include testsfailed and testscollected counters, shouldstop and shouldfail flags for controlling test execution flow, and items list containing all discovered test items. The class has a from_config class method for creating Session instances from Config objects, and it registers itself as a plugin with the name \"session\" in the plugin manager. The Session class is marked with the @final decorator, indicating it is not meant to be subclassed. It serves as the main orchestrator for the pytest test execution process, coordinating between test collection, fixture management, and test execution phases.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "session", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self"], "calls": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 498, "end_line": 500}, "code_snippet": "    def session(self) -> Session:\n        \"\"\"Pytest session object.\"\"\"\n        return self._pyfuncitem.session\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": true, "class_name": "StepwisePlugin", "parameters": ["self", "session"], "calls": [], "code_location": {"file": "stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 126, "end_line": 127}, "code_snippet": "    def pytest_sessionstart(self, session: Session) -> None:\n        self.session = session\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["SetupState"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 106, "end_line": 107}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._setupstate = SetupState()\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["FixtureManager"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 119, "end_line": 120}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": true, "class_name": "TerminalReporter", "parameters": ["self", "session"], "calls": ["hookimpl", "timing.Instant", "self.write_sep", "platform.python_version", "getattr", "self.write_line", "self.config.hook.pytest_report_header", "self._write_report_lines_from_hooks", "join", "getattr", "map", "str"], "code_location": {"file": "terminal.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 827, "end_line": 851}, "code_snippet": "    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._session_start = timing.Instant()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        if not self.no_header:\n            msg = f\"platform {sys.platform} -- Python {verinfo}\"\n            pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n            if pypy_version_info:\n                verinfo = \".\".join(map(str, pypy_version_info[:3]))\n                msg += f\"[pypy-{verinfo}-{pypy_version_info[3]}]\"\n            msg += f\", pytest-{_pytest._version.version}, pluggy-{pluggy.__version__}\"\n            if (\n                self.verbosity > 0\n                or self.config.option.debug\n                or getattr(self.config.option, \"pastebin\", None)\n            ):\n                msg += \" -- \" + str(sys.executable)\n            self.write_line(msg)\n            lines = self.config.hook.pytest_report_header(\n                config=self.config, start_path=self.startpath\n            )\n            self._write_report_lines_from_hooks(lines)\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.perform_collect"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 352, "end_line": 353}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    session.perform_collect()\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": [], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 922, "end_line": 932}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    \"\"\"Called after the ``Session`` object has been created and before performing collection\n    and entering the run test loop.\n\n    :param session: The pytest session object.\n\n    Use in conftest plugins\n    =======================\n\n    This hook is only called for :ref:`initial conftests <pluginorder>`.\n    \"\"\"\n", "type": "function"}, {"name": "test_pytestconfig_is_session_scoped", "is_method": false, "class_name": null, "parameters": [], "calls": ["getfixturemarker"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 266, "end_line": 271}, "code_snippet": "def test_pytestconfig_is_session_scoped() -> None:\n    from _pytest.fixtures import pytestconfig\n\n    marker = getfixturemarker(pytestconfig)\n    assert marker is not None\n    assert marker.scope == \"session\"\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.config.stash.get", "assertstate.hook.set_session"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 132, "end_line": 139}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    # This hook is only called when test modules are collected\n    # so for example not in the managing process of pytest-xdist\n    # (which does not collect test modules).\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0562829971313477}
{"question": "How does Pytest implement its plugin architecture for extensibility?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements its plugin architecture for extensibility through a comprehensive hook-based system built on the pluggy library: 1) Hook specification system where all pytest functionality is defined through hook specifications in src/_pytest/hookspec.py using the @hookspec decorator, 2) Plugin manager (PytestPluginManager) that extends pluggy.PluginManager to handle pytest-specific plugin loading and discovery, 3) Multiple plugin types including built-in plugins (stored in src/_pytest/), external plugins (discovered through entry points), and local conftest.py plugins (auto-discovered in test directories), 4) Plugin discovery order that loads plugins in a specific sequence: command line blocking, built-in plugins, external plugins, environment variables, and conftest files, 5) Hook implementation system where plugins implement hook functions with the @hookimpl decorator to provide functionality, 6) 1:N relationship where multiple plugins can implement the same hook specification, with execution order controlled by tryfirst/trylast markers, 7) Hook wrappers that execute around other hook implementations for cross-cutting functionality, 8) Plugin registration through entry points in pyproject.toml or setup.py for external plugins, 9) Local plugin support through conftest.py files that can be placed in any directory for directory-specific functionality, 10) Plugin communication through the config object and stash mechanism for sharing data between plugins, 11) Plugin validation and error handling with proper cleanup mechanisms, 12) Backward compatibility through dynamic argument pruning that allows new hook parameters without breaking existing implementations.", "score": null, "retrieved_content": [{"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "pytestpm", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 21, "end_line": 22}, "code_snippet": "def pytestpm() -> PytestPluginManager:\n    return PytestPluginManager()\n", "type": "function"}, {"name": "test_pytest_collect_file", "is_method": true, "class_name": "TestCollectPluginHookRelay", "parameters": ["self", "pytester"], "calls": ["pytester.makefile", "pytest.main", "len", "file_path.name.startswith", "wascalled.append", "Plugin"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 281, "end_line": 293}, "code_snippet": "    def test_pytest_collect_file(self, pytester: Pytester) -> None:\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, file_path: Path) -> None:\n                if not file_path.name.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(file_path)\n\n        pytester.makefile(\".abc\", \"xyz\")\n        pytest.main(pytester.path, plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].suffix == \".abc\"\n", "type": "function"}, {"name": "test_invoke_plugin_api", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "capsys"], "calls": ["pytest.main", "capsys.readouterr", "parser.addoption", "MyPlugin"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 652, "end_line": 659}, "code_snippet": "    def test_invoke_plugin_api(self, capsys) -> None:\n        class MyPlugin:\n            def pytest_addoption(self, parser):\n                parser.addoption(\"--myopt\")\n\n        pytest.main([\"-h\"], plugins=[MyPlugin()])\n        out, err = capsys.readouterr()\n        assert \"--myopt\" in out\n", "type": "function"}, {"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 161, "end_line": 163}, "code_snippet": "def pytester(pytester: Pytester, monkeypatch: MonkeyPatch) -> Pytester:\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return pytester\n", "type": "function"}, {"name": "test_plugin_skip", "is_method": true, "class_name": "TestPytestPluginManager", "parameters": ["self", "pytester", "monkeypatch"], "calls": ["pytest.mark.filterwarnings", "pytester.makepyfile", "shutil.copy", "monkeypatch.setenv", "pytester.runpytest", "result.stdout.fnmatch_lines", "p.with_name"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 326, "end_line": 339}, "code_snippet": "    def test_plugin_skip(self, pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n        p = pytester.makepyfile(\n            skipping1=\"\"\"\n            import pytest\n            pytest.skip(\"hello\", allow_module_level=True)\n        \"\"\"\n        )\n        shutil.copy(p, p.with_name(\"skipping2.py\"))\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"skipping2\")\n        result = pytester.runpytest(\"-p\", \"skipping1\", syspathinsert=True)\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines(\n            [\"*skipped plugin*skipping1*hello*\", \"*skipped plugin*skipping2*hello*\"]\n        )\n", "type": "function"}, {"name": "pytest_plugin_registered", "is_method": true, "class_name": "FixtureManager", "parameters": ["self", "plugin", "plugin_name"], "calls": ["self.parsefactories", "plugin_name.endswith", "absolutepath", "str", "nodeid.replace", "conftestpath.parent.relative_to"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1583, "end_line": 1605}, "code_snippet": "    def pytest_plugin_registered(self, plugin: _PluggyPlugin, plugin_name: str) -> None:\n        # Fixtures defined in conftest plugins are only visible to within the\n        # conftest's directory. This is unlike fixtures in non-conftest plugins\n        # which have global visibility. So for conftests, construct the base\n        # nodeid from the plugin name (which is the conftest path).\n        if plugin_name and plugin_name.endswith(\"conftest.py\"):\n            # Note: we explicitly do *not* use `plugin.__file__` here -- The\n            # difference is that plugin_name has the correct capitalization on\n            # case-insensitive systems (Windows) and other normalization issues\n            # (issue #11816).\n            conftestpath = absolutepath(plugin_name)\n            try:\n                nodeid = str(conftestpath.parent.relative_to(self.config.rootpath))\n            except ValueError:\n                nodeid = \"\"\n            if nodeid == \".\":\n                nodeid = \"\"\n            if os.sep != nodes.SEP:\n                nodeid = nodeid.replace(os.sep, nodes.SEP)\n        else:\n            nodeid = None\n\n        self.parsefactories(plugin, nodeid)\n", "type": "function"}, {"name": "test_pytest_fs_collect_hooks_are_seen", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 449, "end_line": 463}, "code_snippet": "    def test_pytest_fs_collect_hooks_are_seen(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        pytester.mkdir(\"sub\")\n        pytester.makepyfile(\"def test_x(): pass\")\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.022174596786499}
{"question": "How does Pytest ensure backward compatibility when introducing new features?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest ensures backward compatibility when introducing new features through a comprehensive policy and implementation strategy: 1) Backward compatibility policy that categorizes changes into three types: trivial (APIs that trivially translate to new mechanisms), transitional (old and new APIs don't conflict and can coexist), and true breakage (only for APIs with very small user bases), 2) Deprecation warning system using custom warning hierarchy (PytestDeprecationWarning, PytestRemovedInXWarning) to communicate upcoming changes to users, 3) Gradual deprecation process where deprecated features are kept for at least two minor releases before removal, with deprecation warnings becoming errors by default in the release before removal, 4) Dynamic argument pruning in hook system that allows new hook parameters to be added without breaking existing implementations, 5) Plugin system design that enables multiple plugins to implement the same hook specification, maintaining compatibility while allowing new functionality, 6) Configuration system that supports multiple file formats (pytest.ini, pyproject.toml, tox.ini, setup.cfg) and allows gradual migration between formats, 7) Fixture system that maintains compatibility with both old funcarg-style fixtures and new @pytest.fixture decorator, 8) Mark system that preserves old marker behavior while introducing new functionality, 9) Python version support policy that maintains compatibility with actively maintained Python versions, 10) Documentation of deprecations and migration paths in doc/en/deprecations.rst to help users transition, 11) Changelog tracking that clearly documents breaking changes, deprecations, and new features, 12) Community coordination through GitHub issues and pull requests to assess impact before making breaking changes.", "score": null, "retrieved_content": [{"name": "test_pytest_addopts_before_pytester", "is_method": false, "class_name": null, "parameters": ["request", "monkeypatch"], "calls": ["monkeypatch.setenv", "request.getfixturevalue"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 608, "end_line": 611}, "code_snippet": "def test_pytest_addopts_before_pytester(request, monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"--orig-unused\")\n    _: Pytester = request.getfixturevalue(\"pytester\")\n    assert \"PYTEST_ADDOPTS\" not in os.environ\n", "type": "function"}, {"name": "test_core_backward_compatibility", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self"], "calls": ["type", "_pytest.config.get_plugin_manager"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 928, "end_line": 935}, "code_snippet": "    def test_core_backward_compatibility(self) -> None:\n        \"\"\"Test backward compatibility for get_plugin_manager function. See #787.\"\"\"\n        import _pytest.config\n\n        assert (\n            type(_pytest.config.get_plugin_manager())\n            is _pytest.config.PytestPluginManager\n        )\n", "type": "function"}, {"name": "test_hookspec_via_function_attributes_are_deprecated", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager", "pytest.warns", "pm.add_hookspecs"], "code_location": {"file": "deprecated_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 25, "end_line": 46}, "code_snippet": "def test_hookspec_via_function_attributes_are_deprecated():\n    from _pytest.config import PytestPluginManager\n\n    pm = PytestPluginManager()\n\n    class DeprecatedHookMarkerSpec:\n        def pytest_bad_hook(self):\n            pass\n\n        pytest_bad_hook.historic = False  # type: ignore[attr-defined]\n\n    with pytest.warns(\n        PytestDeprecationWarning,\n        match=r\"Please use the pytest\\.hookspec\\(historic=False\\) decorator\",\n    ) as recorder:\n        pm.add_hookspecs(DeprecatedHookMarkerSpec)\n    (record,) = recorder\n    assert (\n        record.lineno\n        == DeprecatedHookMarkerSpec.pytest_bad_hook.__code__.co_firstlineno\n    )\n    assert record.filename == __file__\n", "type": "function"}, {"name": "test_hookimpl_via_function_attributes_are_deprecated", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager", "pytest.warns", "pm.register", "DeprecatedMarkImplPlugin"], "code_location": {"file": "deprecated_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 49, "end_line": 70}, "code_snippet": "def test_hookimpl_via_function_attributes_are_deprecated():\n    from _pytest.config import PytestPluginManager\n\n    pm = PytestPluginManager()\n\n    class DeprecatedMarkImplPlugin:\n        def pytest_runtest_call(self):\n            pass\n\n        pytest_runtest_call.tryfirst = True  # type: ignore[attr-defined]\n\n    with pytest.warns(\n        PytestDeprecationWarning,\n        match=r\"Please use the pytest.hookimpl\\(tryfirst=True\\)\",\n    ) as recorder:\n        pm.register(DeprecatedMarkImplPlugin())\n    (record,) = recorder\n    assert (\n        record.lineno\n        == DeprecatedMarkImplPlugin.pytest_runtest_call.__code__.co_firstlineno\n    )\n    assert record.filename == __file__\n", "type": "function"}, {"name": "test_conftest_existing_junitxml", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.mkdir", "write_text", "pytester.makefile", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "x.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 427, "end_line": 440}, "code_snippet": "def test_conftest_existing_junitxml(pytester: Pytester) -> None:\n    x = pytester.mkdir(\"tests\")\n    x.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", action=\"store_true\")\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    pytester.makefile(ext=\".xml\", junit=\"\")  # Writes junit.xml\n    result = pytester.runpytest(\"-h\", \"--junitxml\", \"junit.xml\")\n    result.stdout.fnmatch_lines([\"*--xyz*\"])\n", "type": "function"}, {"name": "test_pytest_version_env_var", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv", "pytester.makepyfile", "pytester.runpytest_inprocess"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1202, "end_line": 1216}, "code_snippet": "def test_pytest_version_env_var(pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setenv(\"PYTEST_VERSION\", \"old version\")\n    pytester.makepyfile(\n        \"\"\"\n        import pytest\n        import os\n\n\n        def test():\n            assert os.environ.get(\"PYTEST_VERSION\") == pytest.__version__\n    \"\"\"\n    )\n    result = pytester.runpytest_inprocess()\n    assert result.ret == ExitCode.OK\n    assert os.environ[\"PYTEST_VERSION\"] == \"old version\"\n", "type": "function"}, {"name": "pytest_addoption", "is_method": false, "class_name": null, "parameters": ["parser"], "calls": ["parser.getgroup", "group._addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "parser.getgroup", "group.addoption", "parser.addini", "parser.getgroup", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "group.addoption", "parser.addini", "parser.addini", "parser.addini", "parser.addini", "parser.getgroup", "group._addoption", "group.addoption", "group.addoption", "functools.partial"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 56, "end_line": 248}, "code_snippet": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(  # private to use reserved lower-case short option\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group.addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group.addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group.addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group.addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    parser.addini(\n        \"collect_imported_tests\",\n        \"Whether to collect tests in imported modules outside `testpaths`\",\n        type=\"bool\",\n        default=True,\n    )\n    parser.addini(\n        \"consider_namespace_packages\",\n        type=\"bool\",\n        default=False,\n        help=\"Consider namespace packages when resolving module names during import\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group._addoption(  # private to use reserved lower-case short option\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group.addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n", "type": "function"}, {"name": "pytest_plugin_registered", "is_method": false, "class_name": null, "parameters": ["plugin", "manager"], "calls": ["manager.get_plugin", "manager.register", "manager.is_registered"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 463, "end_line": 468}, "code_snippet": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")\n", "type": "function"}, {"name": "test_node_ctor_fspath_argument_is_deprecated", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.getmodulecol", "pytest.warns", "MyFile.from_parent", "NotImplementedError", "re.escape", "legacy_path"], "code_location": {"file": "deprecated_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 152, "end_line": 168}, "code_snippet": "def test_node_ctor_fspath_argument_is_deprecated(pytester: Pytester) -> None:\n    mod = pytester.getmodulecol(\"\")\n\n    class MyFile(pytest.File):\n        def collect(self):\n            raise NotImplementedError()\n\n    with pytest.warns(\n        pytest.PytestDeprecationWarning,\n        match=re.escape(\n            \"The (fspath: py.path.local) argument to MyFile is deprecated.\"\n        ),\n    ):\n        MyFile.from_parent(\n            parent=mod.parent,\n            fspath=legacy_path(\"bla\"),\n        )\n", "type": "function"}, {"name": "pytest_addoption", "is_method": false, "class_name": null, "parameters": ["parser"], "calls": ["parser.addini", "parser.addini", "parser.addini", "parser.addini"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 83, "end_line": 109}, "code_snippet": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"python_files\",\n        type=\"args\",\n        # NOTE: default is also used in AssertionRewritingHook.\n        default=[\"test_*.py\", \"*_test.py\"],\n        help=\"Glob-style file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"Prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"Prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n        type=\"bool\",\n        default=False,\n        help=\"Disable string escape non-ASCII characters, might cause unwanted \"\n        \"side effects(use at your own risk)\",\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.9808833599090576}
{"question": "How does Pytest's design facilitate integration with other development tools?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's design facilitates integration with other development tools through multiple architectural and design choices: 1) Command-line interface that follows standard conventions and can be easily invoked from build systems, CI/CD pipelines, and IDEs, 2) Exit code system that provides clear success/failure indicators for automated systems to interpret test results, 3) Plugin architecture that allows third-party tools to extend pytest functionality through hooks and custom plugins, 4) Configuration system that supports multiple file formats (pytest.ini, pyproject.toml, tox.ini, setup.cfg) for integration with different build tools, 5) JUnit XML reporting through the junitxml plugin that enables integration with CI/CD systems like Jenkins, GitLab CI, and GitHub Actions, 6) Environment variable support (PYTEST_ADDOPTS, PYTEST_PLUGINS) for configuration without file modification, 7) Python API through pytest.main() function that allows programmatic execution from other Python tools, 8) Modular fixture system that enables sharing test resources and setup across different tools and frameworks, 9) Standard test discovery conventions that work with most Python project structures, 10) Support for running existing unittest test suites without modification, enabling gradual migration from other testing frameworks, 11) Rich plugin ecosystem with over 1300+ external plugins that provide integrations with specific tools and frameworks, 12) Documentation and examples for integration with popular tools like tox, pre-commit, and various CI/CD platforms.", "score": null, "retrieved_content": [{"name": "test_PYTEST_DEBUG", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv", "pytester.runpytest_subprocess", "result.stderr.fnmatch_lines"], "code_location": {"file": "test_helpconfig.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 123, "end_line": 129}, "code_snippet": "def test_PYTEST_DEBUG(pytester: Pytester, monkeypatch) -> None:\n    monkeypatch.setenv(\"PYTEST_DEBUG\", \"1\")\n    result = pytester.runpytest_subprocess()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n    result.stderr.fnmatch_lines(\n        [\"*pytest_plugin_registered*\", \"*manager*PluginManager*\"]\n    )\n", "type": "function"}, {"name": "test_python_pytest_package", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.run", "res.stdout.fnmatch_lines", "str"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 635, "end_line": 639}, "code_snippet": "    def test_python_pytest_package(self, pytester: Pytester) -> None:\n        p1 = pytester.makepyfile(\"def test_pass(): pass\")\n        res = pytester.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_pytester_runs_with_plugin", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.assert_outcomes"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 83, "end_line": 92}, "code_snippet": "def test_pytester_runs_with_plugin(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        pytest_plugins = \"pytester\"\n        def test_hello(pytester):\n            assert 1\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.assert_outcomes(passed=1)\n", "type": "function"}, {"name": "test_pytest_collect_file", "is_method": true, "class_name": "TestCollectPluginHookRelay", "parameters": ["self", "pytester"], "calls": ["pytester.makefile", "pytest.main", "len", "file_path.name.startswith", "wascalled.append", "Plugin"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 281, "end_line": 293}, "code_snippet": "    def test_pytest_collect_file(self, pytester: Pytester) -> None:\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, file_path: Path) -> None:\n                if not file_path.name.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(file_path)\n\n        pytester.makefile(\".abc\", \"xyz\")\n        pytest.main(pytester.path, plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].suffix == \".abc\"\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["request", "tmp_path_factory", "monkeypatch"], "calls": ["Pytester"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 477, "end_line": 490}, "code_snippet": "def pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.\n    \"\"\"\n    return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)\n", "type": "function"}, {"name": "pytest_addoption", "is_method": false, "class_name": null, "parameters": ["parser"], "calls": ["parser.addoption", "parser.addoption", "parser.addini"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 83, "end_line": 105}, "code_snippet": "def pytest_addoption(parser: Parser) -> None:\n    parser.addoption(\n        \"--lsof\",\n        action=\"store_true\",\n        dest=\"lsof\",\n        default=False,\n        help=\"Run FD checks if lsof is available\",\n    )\n\n    parser.addoption(\n        \"--runpytest\",\n        default=\"inprocess\",\n        dest=\"runpytest\",\n        choices=(\"inprocess\", \"subprocess\"),\n        help=(\n            \"Run pytest sub runs in tests using an 'inprocess' \"\n            \"or 'subprocess' (python -m main) method\"\n        ),\n    )\n\n    parser.addini(\n        \"pytester_example_dir\", help=\"Directory to take the pytester example files from\"\n    )\n", "type": "function"}, {"name": "test_traceconfig", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_helpconfig.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 111, "end_line": 113}, "code_snippet": "def test_traceconfig(pytester: Pytester) -> None:\n    result = pytester.runpytest(\"--traceconfig\")\n    result.stdout.fnmatch_lines([\"*using*pytest*\", \"*active plugins*\"])\n", "type": "function"}, {"name": "test_traceconfig", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1502, "end_line": 1505}, "code_snippet": "def test_traceconfig(pytester: Pytester) -> None:\n    result = pytester.runpytest(\"--traceconfig\")\n    result.stdout.fnmatch_lines([\"*active plugins*\"])\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n", "type": "function"}, {"name": "get_plugin_manager", "is_method": false, "class_name": null, "parameters": [], "calls": ["get_config"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 308, "end_line": 316}, "code_snippet": "def get_plugin_manager() -> PytestPluginManager:\n    \"\"\"Obtain a new instance of the\n    :py:class:`pytest.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n", "type": "function"}, {"name": "test_trace", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setattr", "pytester.makepyfile", "pytester.runpytest", "calls.append", "str", "len", "calls.append"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1183, "end_line": 1209}, "code_snippet": "def test_trace(pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n    calls = []\n\n    def check_call(*args, **kwargs):\n        calls.append((args, kwargs))\n        assert args == (\"runcall\",)\n\n        class _pdb:\n            def runcall(*args, **kwargs):\n                calls.append((args, kwargs))\n\n        return _pdb\n\n    monkeypatch.setattr(\"_pytest.debugging.pytestPDB._init_pdb\", check_call)\n\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test(self):\n                self.assertEqual('foo', 'foo')\n    \"\"\"\n    )\n    result = pytester.runpytest(\"--trace\", str(p1))\n    assert len(calls) == 2\n    assert result.ret == 0\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.9599623680114746}
{"question": "How does Pytest implement its configuration management system?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements its configuration management system through a comprehensive multi-layered approach: 1) Config class in src/_pytest/config/__init__.py serves as the central configuration object that provides access to all settings, plugin manager, and plugin hooks, 2) Multiple configuration file formats support including pytest.ini (highest precedence), pyproject.toml with [tool.pytest.ini_options] section, tox.ini with [pytest] section, and setup.cfg with [tool:pytest] section, 3) Configuration file discovery through locate_config() function that searches for configuration files in a specific order and determines rootdir and configfile, 4) Command-line argument parsing through Parser class that processes both command-line options and ini-file values, 5) Environment variable support through PYTEST_ADDOPTS for adding default command-line options and PYTEST_PLUGINS for loading plugins, 6) Configuration value access through methods like getini() for ini-file values and getoption() for command-line options, 7) Plugin configuration through pytest_addoption hook that allows plugins to register their own configuration options, 8) Configuration validation and error handling with proper error messages for invalid configurations, 9) Configuration inheritance and override system where command-line options take precedence over configuration file settings, 10) Root directory determination that finds the common ancestor of specified test paths or uses current working directory, 11) Configuration caching through _inicache attribute to avoid repeated file parsing, 12) Integration with the plugin system where configuration is accessible to all plugins through the config object.", "score": null, "retrieved_content": [{"name": "Config", "docstring": "Access to configuration values, pluginmanager and plugin hooks.\n\n:param PytestPluginManager pluginmanager:\n    A pytest PluginManager.\n\n:param InvocationParams invocation_params:\n    Object containing parameters regarding the :func:`pytest.main`\n    invocation.", "methods": ["__init__", "rootpath", "inipath", "add_cleanup", "_do_configure", "_ensure_unconfigure", "get_terminal_writer", "pytest_cmdline_parse", "notify_exception", "cwd_relative_nodeid", "fromdictargs", "_processopt", "pytest_load_initial_conftests", "_initini", "_consider_importhook", "_mark_plugins_for_rewrite", "_configure_python_path", "_unconfigure_python_path", "_validate_args", "_decide_args", "_preparse", "pytest_collection", "_checkversion", "_validate_config_options", "_validate_plugins", "_warn_or_fail_if_strict", "_get_unknown_ini_keys", "parse", "issue_config_time_warning", "addinivalue_line", "getini", "_getini_unknown_type", "_getini", "_getconftest_pathlist", "_get_override_ini_value", "getoption", "getvalue", "getvalueorskip", "get_verbosity", "_verbosity_ini_name", "_add_verbosity_ini", "_warn_about_missing_assertion", "_warn_about_skipped_plugins"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 968, "end_line": 1864}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self"], "calls": ["__init__", "set", "self.add_hookspecs", "self.register", "os.environ.get", "DummyRewriteHook", "lru_cache", "getattr", "self.trace.root.setwriter", "self.enable_tracing", "super", "open", "os.dup", "err.fileno"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 401, "end_line": 451}, "code_snippet": "    def __init__(self) -> None:\n        from _pytest.assertion import DummyRewriteHook\n        from _pytest.assertion import RewriteHook\n\n        super().__init__(\"pytest\")\n\n        # -- State related to local conftest plugins.\n        # All loaded conftest modules.\n        self._conftest_plugins: set[types.ModuleType] = set()\n        # All conftest modules applicable for a directory.\n        # This includes the directory's own conftest modules as well\n        # as those of its parent directories.\n        self._dirpath2confmods: dict[pathlib.Path, list[types.ModuleType]] = {}\n        # Cutoff directory above which conftests are no longer discovered.\n        self._confcutdir: pathlib.Path | None = None\n        # If set, conftest loading is skipped.\n        self._noconftest = False\n\n        # _getconftestmodules()'s call to _get_directory() causes a stat\n        # storm when it's called potentially thousands of times in a test\n        # session (#9478), often with the same path, so cache it.\n        self._get_directory = lru_cache(256)(_get_directory)\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: list[tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook: RewriteHook = DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Config", "parameters": ["self", "pluginmanager"], "calls": ["argparse.Namespace", "Parser", "Stash", "self.pluginmanager.trace.root.get", "PathAwareHookProxy", "contextlib.ExitStack", "self.pluginmanager.register", "self.hook.pytest_addoption.call_historic", "self.InvocationParams", "dict", "pathlib.Path.cwd"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 1031, "end_line": 1090}, "code_snippet": "    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: InvocationParams | None = None,\n    ) -> None:\n        from .argparsing import FILE_OR_DIR\n        from .argparsing import Parser\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=pathlib.Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n            _ispytest=True,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.stash = Stash()\n        \"\"\"A place where plugins can store information on the config for their\n        own use.\n\n        :type: Stash\n        \"\"\"\n        # Deprecated alias. Was never public. Can be removed in a few releases.\n        self._store = self.stash\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook: pluggy.HookRelay = PathAwareHookProxy(self.pluginmanager.hook)  # type: ignore[assignment]\n        self._inicache: dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: dict[str, str] = {}\n        self._cleanup_stack = contextlib.ExitStack()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n        self.args_source = Config.ArgsSource.ARGS\n        self.args: list[str] = []\n", "type": "function"}, {"name": "get_config", "is_method": false, "class_name": null, "parameters": ["args", "plugins"], "calls": ["PytestPluginManager", "Config", "pluginmanager.consider_preparse", "pluginmanager.import_plugin", "Config.InvocationParams", "pathlib.Path.cwd"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 283, "end_line": 305}, "code_snippet": "def get_config(\n    args: list[str] | None = None,\n    plugins: Sequence[str | _PluggyPlugin] | None = None,\n) -> Config:\n    # Subsequent calls to main will create a fresh instance.\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (),\n            plugins=plugins,\n            dir=pathlib.Path.cwd(),\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args, exclude_only=True)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n\n    return config\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getini", "UsageError"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/mark", "start_line": 287, "end_line": 297}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.stash[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            f\"{EMPTY_PARAMETERSET_OPTION!s} must be one of skip, xfail or fail_at_collect\"\n            f\" but it is {empty_parameterset!r}\"\n        )\n", "type": "function"}, {"name": "test_parseconfig", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.parseconfig", "pytester.parseconfig"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 77, "end_line": 80}, "code_snippet": "def test_parseconfig(pytester: Pytester) -> None:\n    config1 = pytester.parseconfig()\n    config2 = pytester.parseconfig()\n    assert config2 is not config1\n", "type": "function"}, {"name": "_config_for_test", "is_method": false, "class_name": null, "parameters": [], "calls": ["get_config", "config._ensure_unconfigure"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 503, "end_line": 508}, "code_snippet": "def _config_for_test() -> Generator[Config]:\n    from _pytest.config import get_config\n\n    config = get_config()\n    yield config\n    config._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "_prepareconfig", "is_method": false, "class_name": null, "parameters": ["args", "plugins"], "calls": ["get_config", "isinstance", "pluginmanager.hook.pytest_cmdline_parse", "initial_config._ensure_unconfigure", "os.fspath", "isinstance", "TypeError", "isinstance", "msg.format", "pluginmanager.consider_pluginarg", "pluginmanager.register", "type"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 319, "end_line": 348}, "code_snippet": "def _prepareconfig(\n    args: list[str] | os.PathLike[str] | None = None,\n    plugins: Sequence[str | _PluggyPlugin] | None = None,\n) -> Config:\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, os.PathLike):\n        args = [os.fspath(args)]\n    elif not isinstance(args, list):\n        msg = (  # type:ignore[unreachable]\n            \"`args` parameter expected to be a list of strings, got: {!r} (type: {})\"\n        )\n        raise TypeError(msg.format(args, type(args)))\n\n    initial_config = get_config(args, plugins)\n    pluginmanager = initial_config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        config: Config = pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n        return config\n    except BaseException:\n        initial_config._ensure_unconfigure()\n        raise\n", "type": "function"}, {"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.9133422374725342}
{"question": "How does Pytest identify test functions and classes?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest identifies test functions and classes through a combination of naming conventions and configuration-based pattern matching: 1) Test function identification using the funcnamefilter() method in PyCollector class that checks if function names match the python_functions configuration pattern (default: 'test' prefix), 2) Test class identification using the classnamefilter() method that checks if class names match the python_classes configuration pattern (default: 'Test' prefix), 3) Configuration-based pattern matching through _matches_prefix_or_glob_option() method that supports both prefix matching and glob-style patterns, 4) Support for nose-style test identification through isnosetest() method that looks for the __test__ attribute set to True, 5) Function validation through istestfunction() method that ensures the object is callable and not a fixture (checked via fixtures.getfixturemarker()), 6) Class validation through istestclass() method that excludes abstract classes and ensures the class matches naming patterns, 7) Special handling for staticmethods and classmethods by unwrapping them to check their underlying functions, 8) Automatic collection of unittest.TestCase subclasses regardless of naming patterns, as pytest delegates to unittest's collection framework, 9) Configuration options that allow customization of naming patterns through python_files, python_classes, and python_functions settings, 10) Support for multiple glob patterns by adding spaces between patterns in configuration, 11) Node ID generation that creates unique identifiers based on the discovered test structure, 12) Plugin integration through pytest_pycollect_makeitem hook that allows plugins to customize test item creation.", "score": null, "retrieved_content": [{"name": "test_class_and_method", "is_method": true, "class_name": "TestNoselikeTestAttribute", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.getreports", "reprec.getfailedcollections"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 288, "end_line": 305}, "code_snippet": "    def test_class_and_method(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            __test__ = True\n            def test_func():\n                pass\n            test_func.__test__ = False\n\n            class TestSome(object):\n                __test__ = False\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        assert not reprec.getfailedcollections()\n        calls = reprec.getreports(\"pytest_runtest_logreport\")\n        assert not calls\n", "type": "function"}, {"name": "test_function_instance", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.getitems", "isinstance", "isinstance", "isinstance", "isinstance", "len"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 428, "end_line": 465}, "code_snippet": "def test_function_instance(pytester: Pytester) -> None:\n    items = pytester.getitems(\n        \"\"\"\n        def test_func(): pass\n\n        class TestIt:\n            def test_method(self): pass\n\n            @classmethod\n            def test_class(cls): pass\n\n            @staticmethod\n            def test_static(): pass\n        \"\"\"\n    )\n    assert len(items) == 4\n\n    assert isinstance(items[0], Function)\n    assert items[0].name == \"test_func\"\n    assert items[0].instance is None\n\n    assert isinstance(items[1], Function)\n    assert items[1].name == \"test_method\"\n    assert items[1].instance is not None\n    assert items[1].instance.__class__.__name__ == \"TestIt\"\n\n    # Even class and static methods get an instance!\n    # This is the instance used for bound fixture methods, which\n    # class/staticmethod tests are perfectly able to request.\n    assert isinstance(items[2], Function)\n    assert items[2].name == \"test_class\"\n    assert items[2].instance is not None\n\n    assert isinstance(items[3], Function)\n    assert items[3].name == \"test_static\"\n    assert items[3].instance is not None\n\n    assert items[1].instance is not items[2].instance is not items[3].instance\n", "type": "function"}, {"name": "pytest_pycollect_makeitem", "is_method": false, "class_name": null, "parameters": ["collector", "name", "obj"], "calls": ["hookimpl", "isinstance", "type", "safe_isclass", "collector.istestclass", "collector.istestfunction", "Class.from_parent", "getattr", "getfslineno", "warnings.warn_explicit", "getattr", "inspect.isfunction", "inspect.isfunction", "inspect.isgeneratorfunction", "list", "get_real_func", "PytestCollectionWarning", "str", "fail", "collector._genfunctions"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 210, "end_line": 242}, "code_snippet": "def pytest_pycollect_makeitem(\n    collector: Module | Class, name: str, obj: object\n) -> None | nodes.Item | nodes.Collector | list[nodes.Item | nodes.Collector]:\n    assert isinstance(collector, (Class, Module)), type(collector)\n    # Nothing was collected elsewhere, let's do it here.\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it.\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only).\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    f\"cannot collect {name!r} because it is not a function.\"\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if inspect.isgeneratorfunction(obj):\n                fail(\n                    f\"'yield' keyword is allowed in fixtures, but not in tests ({name})\",\n                    pytrace=False,\n                )\n            return list(collector._genfunctions(name, obj))\n        return None\n    return None\n", "type": "function"}, {"name": "test_customized_python_discovery", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeini", "pytester.makepyfile", "p.with_name", "p.rename", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "p.name.replace"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1282, "end_line": 1309}, "code_snippet": "def test_customized_python_discovery(pytester: Pytester) -> None:\n    pytester.makeini(\n        \"\"\"\n        [pytest]\n        python_files=check_*.py\n        python_classes=Check\n        python_functions=check\n    \"\"\"\n    )\n    p = pytester.makepyfile(\n        \"\"\"\n        def check_simple():\n            pass\n        class CheckMyApp(object):\n            def check_meth(self):\n                pass\n    \"\"\"\n    )\n    p2 = p.with_name(p.name.replace(\"test\", \"check\"))\n    p.rename(p2)\n    result = pytester.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines(\n        [\"*check_customized*\", \"*check_simple*\", \"*CheckMyApp*\", \"*check_meth*\"]\n    )\n\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_customized_python_discovery_functions", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeini", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1312, "end_line": 1330}, "code_snippet": "def test_customized_python_discovery_functions(pytester: Pytester) -> None:\n    pytester.makeini(\n        \"\"\"\n        [pytest]\n        python_functions=_test\n    \"\"\"\n    )\n    pytester.makepyfile(\n        \"\"\"\n        def _test_underscore():\n            pass\n    \"\"\"\n    )\n    result = pytester.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines([\"*_test_underscore*\"])\n\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_function_as_object_instance_ignored", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytest.mark.filterwarnings", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 338, "end_line": 355}, "code_snippet": "    def test_function_as_object_instance_ignored(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            class A(object):\n                def __call__(self, tmp_path):\n                    0/0\n\n            test_a = A()\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 0 items\",\n                \"*test_function_as_object_instance_ignored.py:2: \"\n                \"*cannot collect 'test_a' because it is not a function.\",\n            ]\n        )\n", "type": "function"}, {"name": "test_unittest_class", "is_method": true, "class_name": "TestNoselikeTestAttribute", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.getfailedcollections", "reprec.getcalls", "len"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 307, "end_line": 324}, "code_snippet": "    def test_unittest_class(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import unittest\n            class TC(unittest.TestCase):\n                def test_1(self):\n                    pass\n            class TC2(unittest.TestCase):\n                __test__ = False\n                def test_2(self):\n                    pass\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        assert not reprec.getfailedcollections()\n        call = reprec.getcalls(\"pytest_collection_modifyitems\")[0]\n        assert len(call.items) == 1\n        assert call.items[0].cls.__name__ == \"TC\"\n", "type": "function"}, {"name": "Metafunc", "docstring": "Objects passed to the :hook:`pytest_generate_tests` hook.\n\nThey help to inspect a test function and to generate tests according to\ntest configuration or values specified in the class or module where a\ntest function is defined.", "methods": ["__init__", "parametrize", "_resolve_parameter_set_ids", "_validate_ids", "_resolve_args_directness", "_validate_if_using_arg_names", "_recompute_direct_params_indices"], "attributes": [], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1118, "end_line": 1490}, "type": "class"}, {"name": "test_class_subclassobject", "is_method": true, "class_name": "TestClass", "parameters": ["self", "pytester"], "calls": ["pytester.getmodulecol", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 179, "end_line": 187}, "code_snippet": "    def test_class_subclassobject(self, pytester: Pytester) -> None:\n        pytester.getmodulecol(\n            \"\"\"\n            class test(object):\n                pass\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"*collected 0*\"])\n", "type": "function"}, {"name": "test_isclasscheck_issue53", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 52, "end_line": 63}, "code_snippet": "def test_isclasscheck_issue53(pytester: Pytester) -> None:\n    testpath = pytester.makepyfile(\n        \"\"\"\n        import unittest\n        class _E(object):\n            def __getattr__(self, tag):\n                pass\n        E = _E()\n    \"\"\"\n    )\n    result = pytester.runpytest(testpath)\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.8946132659912109}
{"question": "Why does Pytest provide multiple assertion rewriting mechanisms for different test scenarios?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest provides multiple assertion rewriting mechanisms for different test scenarios to accommodate various testing needs and environments: 1) Default assertion rewriting mode transforms assert statements to provide detailed introspection information when assertions fail, 2) Plain assertion mode (--assert=plain) disables rewriting entirely for compatibility with certain environments or when detailed introspection is not needed, 3) Selective rewriting through pytest.register_assert_rewrite() allows specific modules to be rewritten even if they're not test modules, 4) Automatic rewriting for test modules and plugin modules ensures that test code gets detailed assertion information, 5) PYTEST_DONT_REWRITE docstring marker allows individual modules to opt out of rewriting when needed, 6) Different rewriting strategies for different Python versions and environments ensure compatibility, 7) Caching mechanisms for rewritten modules to avoid repeated rewriting and improve performance, 8) Integration with pytest_assertion_pass hook for custom behavior when assertions pass, 9) Support for different encoding scenarios (UTF-8, Latin-1) in assertion rewriting, 10) Multi-line assertion support for complex test expressions, 11) Backward compatibility mechanisms to ensure existing test suites continue to work, 12) Environment-specific rewriting behavior for CI/CD pipelines and different deployment scenarios.", "score": null, "retrieved_content": [{"name": "test_rewrite_ast", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 328, "end_line": 371}, "code_snippet": "    def test_rewrite_ast(self, pytester: Pytester) -> None:\n        pytester.mkdir(\"pkg\")\n        contents = {\n            \"pkg/__init__.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite('pkg.helper')\n            \"\"\",\n            \"pkg/helper.py\": \"\"\"\n                def tool():\n                    a, b = 2, 3\n                    assert a == b\n            \"\"\",\n            \"pkg/plugin.py\": \"\"\"\n                import pytest, pkg.helper\n                @pytest.fixture\n                def tool():\n                    return pkg.helper.tool\n            \"\"\",\n            \"pkg/other.py\": \"\"\"\n                values = [3, 2]\n                def tool():\n                    assert values.pop() == 3\n            \"\"\",\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['pkg.plugin']\n            \"\"\",\n            \"test_pkg.py\": \"\"\"\n                import pkg.other\n                def test_tool(tool):\n                    tool()\n                def test_other():\n                    pkg.other.tool()\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(\"--assert=rewrite\")\n        result.stdout.fnmatch_lines(\n            [\n                \">*assert a == b*\",\n                \"E*assert 2 == 3*\",\n                \">*assert values.pop() == 3*\",\n                \"E*AssertionError\",\n            ]\n        )\n", "type": "function"}, {"name": "AssertionRewriter", "docstring": "Assertion rewriting implementation.\n\nThe main entrypoint is to call .run() with an ast.Module instance,\nthis will then find all the assert statements and rewrite them to\nprovide intermediate values and a detailed assertion error.  See\nhttp://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\nfor an overview of how this works.\n\nThe entry point here is .run() which will iterate over all the\nstatements in an ast.Module and for each ast.Assert statement it\nfinds call .visit() with it.  Then .visit_Assert() takes over and\nis responsible for creating new ast statements to replace the\noriginal assert statement: it rewrites the test of an assertion\nto provide intermediate values and replace it with an if statement\nwhich raises an assertion error with a detailed explanation in\ncase the expression is false and calls pytest_assertion_pass hook\nif expression is true.\n\nFor this .visit_Assert() uses the visitor pattern to visit all the\nAST nodes of the ast.Assert.test field, each visit call returning\nan AST node and the corresponding explanation string.  During this\nstate is kept in several instance attributes:\n\n:statements: All the AST statements which will replace the assert\n   statement.\n\n:variables: This is populated by .variable() with each variable\n   used by the statements so that they can all be set to None at\n   the end of the statements.\n\n:variable_counter: Counter to create new unique variables needed\n   by statements.  Variables are created using .variable() and\n   have the form of \"@py_assert0\".\n\n:expl_stmts: The AST statements which will be executed to get\n   data from the assertion.  This is the code which will construct\n   the detailed assertion message that is used in the AssertionError\n   or for the pytest_assertion_pass hook.\n\n:explanation_specifiers: A dict filled by .explanation_param()\n   with %-formatting placeholders and their corresponding\n   expressions to use in the building of an assertion message.\n   This is used by .pop_format_context() to build a message.\n\n:stack: A stack of the explanation_specifiers dicts maintained by\n   .push_format_context() and .pop_format_context() which allows\n   to build another %-formatted string while already building one.\n\n:scope: A tuple containing the current scope used for variables_overwrite.\n\n:variables_overwrite: A dict filled with references to variables\n   that change value within an assert. This happens when a variable is\n   reassigned with the walrus operator\n\nThis state, except the variables_overwrite,  is reset on every new assert\nstatement visited and used by the other visitors.", "methods": ["__init__", "run", "is_rewrite_disabled", "variable", "assign", "display", "helper", "builtin", "explanation_param", "push_format_context", "pop_format_context", "generic_visit", "visit_Assert", "visit_NamedExpr", "visit_Name", "visit_BoolOp", "visit_UnaryOp", "visit_BinOp", "visit_Call", "visit_Starred", "visit_Attribute", "visit_Compare"], "attributes": [], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 615, "end_line": 1176}, "type": "class"}, {"name": "test_rewrite_assertions_pytester_plugin", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines", "result.stdout.fnmatch_lines_random"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 113, "end_line": 144}, "code_snippet": "    def test_rewrite_assertions_pytester_plugin(self, pytester: Pytester) -> None:\n        \"\"\"\n        Assertions in the pytester plugin must also benefit from assertion\n        rewriting (#1920).\n        \"\"\"\n        pytester.makepyfile(\n            \"\"\"\n            pytest_plugins = ['pytester']\n            def test_dummy_failure(pytester):  # how meta!\n                pytester.makepyfile('def test(): assert 0')\n                r = pytester.inline_run()\n                r.assertoutcome(passed=1)\n        \"\"\"\n        )\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \">       r.assertoutcome(passed=1)\",\n                \"E       AssertionError: ([[][]], [[][]], [[]<TestReport *>[]])*\",\n                \"E       assert {'failed': 1,... 'skipped': 0} == {'failed': 0,... 'skipped': 0}\",\n                \"E         Omitting 1 identical items, use -vv to show\",\n                \"E         Differing items:\",\n                \"E         Use -v to get more diff\",\n            ]\n        )\n        # XXX: unstable output.\n        result.stdout.fnmatch_lines_random(\n            [\n                \"E         {'failed': 1} != {'failed': 0}\",\n                \"E         {'passed': 0} != {'passed': 1}\",\n            ]\n        )\n", "type": "function"}, {"name": "test_assertion_rewrite", "is_method": true, "class_name": "TestGeneralUsage", "parameters": ["self", "pytester", "import_mode"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 159, "end_line": 169}, "code_snippet": "    def test_assertion_rewrite(self, pytester: Pytester, import_mode) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_this():\n                x = 0\n                assert x\n        \"\"\"\n        )\n        result = pytester.runpytest(p, f\"--import-mode={import_mode}\")\n        result.stdout.fnmatch_lines([\">       assert x\", \"E       assert 0\"])\n        assert result.ret == 1\n", "type": "function"}, {"name": "test_rewrite_warning", "is_method": true, "class_name": "TestRewriteOnImport", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1191, "end_line": 1200}, "code_snippet": "    def test_rewrite_warning(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            pytest.register_assert_rewrite(\"_pytest\")\n        \"\"\"\n        )\n        # needs to be a subprocess because pytester explicitly disables this warning\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*Module already imported*; _pytest\"])\n", "type": "function"}, {"name": "test_conftest_assertion_rewrite", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester", "initial_conftest", "mode"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytester.mkdir", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 82, "end_line": 111}, "code_snippet": "    def test_conftest_assertion_rewrite(\n        self, pytester: Pytester, initial_conftest, mode\n    ) -> None:\n        \"\"\"Test that conftest files are using assertion rewrite on import (#1619).\"\"\"\n        pytester.mkdir(\"foo\")\n        pytester.mkdir(\"foo/tests\")\n        conftest_path = \"conftest.py\" if initial_conftest else \"foo/conftest.py\"\n        contents = {\n            conftest_path: \"\"\"\n                import pytest\n                @pytest.fixture\n                def check_first():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"foo/tests/test_foo.py\": \"\"\"\n                def test(check_first):\n                    check_first([10, 30], 30)\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(f\"--assert={mode}\")\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n        result.stdout.fnmatch_lines([expected])\n", "type": "function"}, {"name": "test_assertion_walrus_operator_dont_rewrite", "is_method": true, "class_name": "TestIssue10743", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1574, "end_line": 1591}, "code_snippet": "    def test_assertion_walrus_operator_dont_rewrite(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            'PYTEST_DONT_REWRITE'\n            def my_func(before, after):\n                return before == after\n\n            def change_value(value):\n                return value.lower()\n\n            def test_walrus_conversion_dont_rewrite():\n                a = \"Hello\"\n                assert not my_func(a, a := change_value(a))\n                assert a == \"hello\"\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        assert result.ret == 0\n", "type": "function"}, {"name": "test_write_pyc", "is_method": true, "class_name": "TestAssertionRewriteHookDetails", "parameters": ["self", "pytester", "tmp_path"], "calls": ["pytester.parseconfig", "AssertionState", "touch", "str", "tmp_path.joinpath", "compile", "_write_pyc", "os.stat", "mock.patch.object", "tmp_path.joinpath", "_write_pyc", "os.stat"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1297, "end_line": 1310}, "code_snippet": "    def test_write_pyc(self, pytester: Pytester, tmp_path) -> None:\n        from _pytest.assertion import AssertionState\n        from _pytest.assertion.rewrite import _write_pyc\n\n        config = pytester.parseconfig()\n        state = AssertionState(config, \"rewrite\")\n        tmp_path.joinpath(\"source.py\").touch()\n        source_path = str(tmp_path)\n        pycpath = tmp_path.joinpath(\"pyc\")\n        co = compile(\"1\", \"f.py\", \"single\")\n        assert _write_pyc(state, co, os.stat(source_path), pycpath)\n\n        with mock.patch.object(os, \"replace\", side_effect=OSError):\n            assert not _write_pyc(state, co, os.stat(source_path), pycpath)\n", "type": "function"}, {"name": "test_assertrepr_loaded_per_dir", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.mkdir", "write_text", "write_text", "pytester.mkdir", "write_text", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "a.joinpath", "a.joinpath", "b.joinpath", "b.joinpath"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1658, "end_line": 1681}, "code_snippet": "def test_assertrepr_loaded_per_dir(pytester: Pytester) -> None:\n    pytester.makepyfile(test_base=[\"def test_base(): assert 1 == 2\"])\n    a = pytester.mkdir(\"a\")\n    a.joinpath(\"test_a.py\").write_text(\"def test_a(): assert 1 == 2\", encoding=\"utf-8\")\n    a.joinpath(\"conftest.py\").write_text(\n        'def pytest_assertrepr_compare(): return [\"summary a\"]', encoding=\"utf-8\"\n    )\n    b = pytester.mkdir(\"b\")\n    b.joinpath(\"test_b.py\").write_text(\"def test_b(): assert 1 == 2\", encoding=\"utf-8\")\n    b.joinpath(\"conftest.py\").write_text(\n        'def pytest_assertrepr_compare(): return [\"summary b\"]', encoding=\"utf-8\"\n    )\n\n    result = pytester.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*def test_a():*\",\n            \"*E*assert summary a*\",\n            \"*def test_b():*\",\n            \"*E*assert summary b*\",\n            \"*def test_base():*\",\n            \"*E*assert 1 == 2*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_rewrite_infinite_recursion", "is_method": false, "class_name": null, "parameters": ["pytester", "pytestconfig", "monkeypatch"], "calls": ["pytester.syspathinsert", "pytester.makepyfile", "pytester.makepyfile", "monkeypatch.setattr", "monkeypatch.setattr", "AssertionRewritingHook", "hook.find_spec", "importlib.util.module_from_spec", "hook.exec_module", "write_pyc_called.append", "original_write_pyc", "len", "hook.find_spec"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1857, "end_line": 1888}, "code_snippet": "def test_rewrite_infinite_recursion(\n    pytester: Pytester, pytestconfig, monkeypatch\n) -> None:\n    \"\"\"Fix infinite recursion when writing pyc files: if an import happens to be triggered when writing the pyc\n    file, this would cause another call to the hook, which would trigger another pyc writing, which could\n    trigger another import, and so on. (#3506)\"\"\"\n    from _pytest.assertion import rewrite as rewritemod\n\n    pytester.syspathinsert()\n    pytester.makepyfile(test_foo=\"def test_foo(): pass\")\n    pytester.makepyfile(test_bar=\"def test_bar(): pass\")\n\n    original_write_pyc = rewritemod._write_pyc\n\n    write_pyc_called = []\n\n    def spy_write_pyc(*args, **kwargs):\n        # make a note that we have called _write_pyc\n        write_pyc_called.append(True)\n        # try to import a module at this point: we should not try to rewrite this module\n        assert hook.find_spec(\"test_bar\") is None\n        return original_write_pyc(*args, **kwargs)\n\n    monkeypatch.setattr(rewritemod, \"_write_pyc\", spy_write_pyc)\n    monkeypatch.setattr(sys, \"dont_write_bytecode\", False)\n\n    hook = AssertionRewritingHook(pytestconfig)\n    spec = hook.find_spec(\"test_foo\")\n    assert spec is not None\n    module = importlib.util.module_from_spec(spec)\n    hook.exec_module(module)\n    assert len(write_pyc_called) == 1\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.808087110519409}
{"question": "Why does Pytest use a hook-based plugin system instead of inheritance-based extension mechanisms?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest uses a hook-based plugin system instead of inheritance-based extension mechanisms for several key architectural and practical reasons: 1) Hook-based system provides loose coupling where plugins can be added or removed without modifying core code, unlike inheritance which creates tight coupling between base and derived classes, 2) Hook system enables multiple plugins to implement the same hook specification (1:N relationship), while inheritance typically creates a 1:1 relationship between base and derived classes, 3) Hook system allows for dynamic plugin discovery and registration at runtime, whereas inheritance requires compile-time class definitions, 4) Hook system provides better separation of concerns where each plugin focuses on specific functionality without needing to understand the entire inheritance hierarchy, 5) Hook system enables conditional plugin loading and plugin conflicts resolution through the plugin manager, 6) Hook system supports hook wrappers that can execute around other hook implementations, providing cross-cutting functionality, 7) Hook system allows for future-compatible extensions where new hook parameters can be added without breaking existing plugin signatures, 8) Hook system provides better testability as plugins can be tested in isolation without complex inheritance hierarchies, 9) Hook system enables plugin ordering control through tryfirst/trylast markers, which is difficult to achieve with inheritance, 10) Hook system supports plugin collaboration where plugins can access other plugins through the plugin manager, 11) Hook system provides better error isolation where a failing plugin doesn't break the entire system, 12) Hook system enables the core test runner to remain minimal while all functionality is provided through plugins, creating a more modular and maintainable architecture.", "score": null, "retrieved_content": [{"name": "test_pytest_fs_collect_hooks_are_seen", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 449, "end_line": 463}, "code_snippet": "    def test_pytest_fs_collect_hooks_are_seen(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        pytester.mkdir(\"sub\")\n        pytester.makepyfile(\"def test_x(): pass\")\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HookRecorder", "parameters": ["self", "pluginmanager"], "calls": ["check_ispytest", "pluginmanager.add_hookcall_monitoring", "self.calls.append", "RecordedHookCall"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 258, "end_line": 273}, "code_snippet": "    def __init__(\n        self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n\n        self._pluginmanager = pluginmanager\n        self.calls: list[RecordedHookCall] = []\n        self.ret: int | ExitCode | None = None\n\n        def before(hook_name: str, hook_impls, kwargs) -> None:\n            self.calls.append(RecordedHookCall(hook_name, kwargs))\n\n        def after(outcome, hook_name: str, hook_impls, kwargs) -> None:\n            pass\n\n        self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)\n", "type": "function"}, {"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self"], "calls": ["__init__", "set", "self.add_hookspecs", "self.register", "os.environ.get", "DummyRewriteHook", "lru_cache", "getattr", "self.trace.root.setwriter", "self.enable_tracing", "super", "open", "os.dup", "err.fileno"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 401, "end_line": 451}, "code_snippet": "    def __init__(self) -> None:\n        from _pytest.assertion import DummyRewriteHook\n        from _pytest.assertion import RewriteHook\n\n        super().__init__(\"pytest\")\n\n        # -- State related to local conftest plugins.\n        # All loaded conftest modules.\n        self._conftest_plugins: set[types.ModuleType] = set()\n        # All conftest modules applicable for a directory.\n        # This includes the directory's own conftest modules as well\n        # as those of its parent directories.\n        self._dirpath2confmods: dict[pathlib.Path, list[types.ModuleType]] = {}\n        # Cutoff directory above which conftests are no longer discovered.\n        self._confcutdir: pathlib.Path | None = None\n        # If set, conftest loading is skipped.\n        self._noconftest = False\n\n        # _getconftestmodules()'s call to _get_directory() causes a stat\n        # storm when it's called potentially thousands of times in a test\n        # session (#9478), often with the same path, so cache it.\n        self._get_directory = lru_cache(256)(_get_directory)\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: list[tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook: RewriteHook = DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "PathAwareHookProxy", "parameters": ["self", "hook_relay"], "calls": [], "code_location": {"file": "compat.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 43, "end_line": 44}, "code_snippet": "    def __init__(self, hook_relay: pluggy.HookRelay) -> None:\n        self._hook_relay = hook_relay\n", "type": "function"}, {"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "test_addhooks_conftestplugin", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester", "_config_for_test"], "calls": ["pytester.makepyfile", "pytester.makeconftest", "pm.hook.pytest_addhooks.call_historic", "config.pluginmanager._importconftest", "config.hook.pytest_myhook", "dict"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 26, "end_line": 57}, "code_snippet": "    def test_addhooks_conftestplugin(\n        self, pytester: Pytester, _config_for_test: Config\n    ) -> None:\n        pytester.makepyfile(\n            newhooks=\"\"\"\n            def pytest_myhook(xyz):\n                \"new hook\"\n        \"\"\"\n        )\n        conf = pytester.makeconftest(\n            \"\"\"\n            import newhooks\n            def pytest_addhooks(pluginmanager):\n                pluginmanager.add_hookspecs(newhooks)\n            def pytest_myhook(xyz):\n                return xyz + 1\n        \"\"\"\n        )\n        config = _config_for_test\n        pm = config.pluginmanager\n        pm.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=config.pluginmanager)\n        )\n        config.pluginmanager._importconftest(\n            conf,\n            importmode=\"prepend\",\n            rootpath=pytester.path,\n            consider_namespace_packages=False,\n        )\n        # print(config.pluginmanager.get_plugins())\n        res = config.hook.pytest_myhook(xyz=10)\n        assert res == [11]\n", "type": "function"}, {"name": "gethookproxy", "is_method": true, "class_name": "Session", "parameters": ["self", "fspath"], "calls": ["pm._getconftestmodules", "pm._conftest_plugins.difference", "isinstance", "Path", "PathAwareHookProxy", "FSHookProxy"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 690, "end_line": 705}, "code_snippet": "    def gethookproxy(self, fspath: os.PathLike[str]) -> pluggy.HookRelay:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(path)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        proxy: pluggy.HookRelay\n        if remove_mods:\n            # One or more conftests are not in use at this path.\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))  # type: ignore[arg-type,assignment]\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n", "type": "function"}, {"name": "test_load_initial_conftest_last_ordering", "is_method": false, "class_name": null, "parameters": ["_config_for_test"], "calls": ["My", "pm.register", "hc.get_hookimpls"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1541, "end_line": 1564}, "code_snippet": "def test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    hookimpls = [\n        (\n            hookimpl.function.__module__,\n            \"wrapper\" if (hookimpl.wrapper or hookimpl.hookwrapper) else \"nonwrapper\",\n        )\n        for hookimpl in hc.get_hookimpls()\n    ]\n    assert hookimpls == [\n        (\"_pytest.config\", \"nonwrapper\"),\n        (m.__module__, \"nonwrapper\"),\n        (\"_pytest.legacypath\", \"nonwrapper\"),\n        (\"_pytest.capture\", \"wrapper\"),\n        (\"_pytest.warnings\", \"wrapper\"),\n    ]\n", "type": "function"}, {"name": "test_hook_tracing", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "_config_for_test"], "calls": ["pytestpm.trace.root.setwriter", "pytestpm.enable_tracing", "api1", "pytestpm.register", "undo", "saveindent.append", "saveindent.append", "ValueError", "len", "pytest.raises", "pytestpm.register", "api2"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 143, "end_line": 174}, "code_snippet": "    def test_hook_tracing(self, _config_for_test: Config) -> None:\n        pytestpm = _config_for_test.pluginmanager  # fully initialized with plugins\n        saveindent = []\n\n        class api1:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n\n        class api2:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n                raise ValueError()\n\n        values: list[str] = []\n        pytestpm.trace.root.setwriter(values.append)\n        undo = pytestpm.enable_tracing()\n        try:\n            indent = pytestpm.trace.root.indent\n            p = api1()\n            pytestpm.register(p)\n            assert pytestpm.trace.root.indent == indent\n            assert len(values) >= 2\n            assert \"pytest_plugin_registered\" in values[0]\n            assert \"finish\" in values[1]\n\n            values[:] = []\n            with pytest.raises(ValueError):\n                pytestpm.register(api2())\n            assert pytestpm.trace.root.indent == indent\n            assert saveindent[0] > indent\n        finally:\n            undo()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.846287727355957}
{"question": "Why does Pytest implement assertion rewriting instead of using Python's built-in assert statements directly?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements assertion rewriting instead of using Python's built-in assert statements directly to provide detailed introspection information when assertions fail. The key reasons include: 1) Built-in assert statements only provide basic AssertionError messages without showing intermediate values or detailed context, 2) Assertion rewriting transforms assert statements into detailed if-else blocks that capture and display intermediate values during assertion evaluation, 3) The rewriting process provides rich introspection showing the actual values being compared, function call results, and attribute access details, 4) Without rewriting, users would need to manually add debug prints or use unittest-style assertion methods to get detailed failure information, 5) Assertion rewriting enables the use of idiomatic Python assert statements while maintaining detailed debugging information, 6) The rewriting process caches transformed modules as .pyc files to avoid re-rewriting on subsequent runs, 7) Rewriting allows pytest to integrate with the pytest_assertion_pass hook for custom behavior when assertions pass, 8) The transformation provides better error messages that show the exact values being compared, making debugging much easier, 9) Assertion rewriting works transparently without requiring users to change their coding style or use special assertion libraries, 10) The rewriting process can be selectively disabled for specific modules using PYTEST_DONT_REWRITE in docstrings, 11) Rewriting enables pytest to provide consistent, detailed error reporting across all test scenarios, 12) The approach maintains backward compatibility while significantly improving the debugging experience for test failures.", "score": null, "retrieved_content": [{"name": "test_rewrite_assertions_pytester_plugin", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines", "result.stdout.fnmatch_lines_random"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 113, "end_line": 144}, "code_snippet": "    def test_rewrite_assertions_pytester_plugin(self, pytester: Pytester) -> None:\n        \"\"\"\n        Assertions in the pytester plugin must also benefit from assertion\n        rewriting (#1920).\n        \"\"\"\n        pytester.makepyfile(\n            \"\"\"\n            pytest_plugins = ['pytester']\n            def test_dummy_failure(pytester):  # how meta!\n                pytester.makepyfile('def test(): assert 0')\n                r = pytester.inline_run()\n                r.assertoutcome(passed=1)\n        \"\"\"\n        )\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \">       r.assertoutcome(passed=1)\",\n                \"E       AssertionError: ([[][]], [[][]], [[]<TestReport *>[]])*\",\n                \"E       assert {'failed': 1,... 'skipped': 0} == {'failed': 0,... 'skipped': 0}\",\n                \"E         Omitting 1 identical items, use -vv to show\",\n                \"E         Differing items:\",\n                \"E         Use -v to get more diff\",\n            ]\n        )\n        # XXX: unstable output.\n        result.stdout.fnmatch_lines_random(\n            [\n                \"E         {'failed': 1} != {'failed': 0}\",\n                \"E         {'passed': 0} != {'passed': 1}\",\n            ]\n        )\n", "type": "function"}, {"name": "AssertionRewriter", "docstring": "Assertion rewriting implementation.\n\nThe main entrypoint is to call .run() with an ast.Module instance,\nthis will then find all the assert statements and rewrite them to\nprovide intermediate values and a detailed assertion error.  See\nhttp://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\nfor an overview of how this works.\n\nThe entry point here is .run() which will iterate over all the\nstatements in an ast.Module and for each ast.Assert statement it\nfinds call .visit() with it.  Then .visit_Assert() takes over and\nis responsible for creating new ast statements to replace the\noriginal assert statement: it rewrites the test of an assertion\nto provide intermediate values and replace it with an if statement\nwhich raises an assertion error with a detailed explanation in\ncase the expression is false and calls pytest_assertion_pass hook\nif expression is true.\n\nFor this .visit_Assert() uses the visitor pattern to visit all the\nAST nodes of the ast.Assert.test field, each visit call returning\nan AST node and the corresponding explanation string.  During this\nstate is kept in several instance attributes:\n\n:statements: All the AST statements which will replace the assert\n   statement.\n\n:variables: This is populated by .variable() with each variable\n   used by the statements so that they can all be set to None at\n   the end of the statements.\n\n:variable_counter: Counter to create new unique variables needed\n   by statements.  Variables are created using .variable() and\n   have the form of \"@py_assert0\".\n\n:expl_stmts: The AST statements which will be executed to get\n   data from the assertion.  This is the code which will construct\n   the detailed assertion message that is used in the AssertionError\n   or for the pytest_assertion_pass hook.\n\n:explanation_specifiers: A dict filled by .explanation_param()\n   with %-formatting placeholders and their corresponding\n   expressions to use in the building of an assertion message.\n   This is used by .pop_format_context() to build a message.\n\n:stack: A stack of the explanation_specifiers dicts maintained by\n   .push_format_context() and .pop_format_context() which allows\n   to build another %-formatted string while already building one.\n\n:scope: A tuple containing the current scope used for variables_overwrite.\n\n:variables_overwrite: A dict filled with references to variables\n   that change value within an assert. This happens when a variable is\n   reassigned with the walrus operator\n\nThis state, except the variables_overwrite,  is reset on every new assert\nstatement visited and used by the other visitors.", "methods": ["__init__", "run", "is_rewrite_disabled", "variable", "assign", "display", "helper", "builtin", "explanation_param", "push_format_context", "pop_format_context", "generic_visit", "visit_Assert", "visit_NamedExpr", "visit_Name", "visit_BoolOp", "visit_UnaryOp", "visit_BinOp", "visit_Call", "visit_Starred", "visit_Attribute", "visit_Compare"], "attributes": [], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 615, "end_line": 1176}, "type": "class"}, {"name": "test_rewrite_ast", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 328, "end_line": 371}, "code_snippet": "    def test_rewrite_ast(self, pytester: Pytester) -> None:\n        pytester.mkdir(\"pkg\")\n        contents = {\n            \"pkg/__init__.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite('pkg.helper')\n            \"\"\",\n            \"pkg/helper.py\": \"\"\"\n                def tool():\n                    a, b = 2, 3\n                    assert a == b\n            \"\"\",\n            \"pkg/plugin.py\": \"\"\"\n                import pytest, pkg.helper\n                @pytest.fixture\n                def tool():\n                    return pkg.helper.tool\n            \"\"\",\n            \"pkg/other.py\": \"\"\"\n                values = [3, 2]\n                def tool():\n                    assert values.pop() == 3\n            \"\"\",\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['pkg.plugin']\n            \"\"\",\n            \"test_pkg.py\": \"\"\"\n                import pkg.other\n                def test_tool(tool):\n                    tool()\n                def test_other():\n                    pkg.other.tool()\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(\"--assert=rewrite\")\n        result.stdout.fnmatch_lines(\n            [\n                \">*assert a == b*\",\n                \"E*assert 2 == 3*\",\n                \">*assert values.pop() == 3*\",\n                \"E*AssertionError\",\n            ]\n        )\n", "type": "function"}, {"name": "test_pdb_can_be_rewritten", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1409, "end_line": 1441}, "code_snippet": "def test_pdb_can_be_rewritten(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        **{\n            \"conftest.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite(\"pdb\")\n                \"\"\",\n            \"__init__.py\": \"\",\n            \"pdb.py\": \"\"\"\n                def check():\n                    assert 1 == 2\n                \"\"\",\n            \"test_pdb.py\": \"\"\"\n                def test():\n                    import pdb\n                    assert pdb.check()\n                \"\"\",\n        }\n    )\n    # Disable debugging plugin itself to avoid:\n    # > INTERNALERROR> AttributeError: module 'pdb' has no attribute 'set_trace'\n    result = pytester.runpytest_subprocess(\"-p\", \"no:debugging\", \"-vv\")\n    result.stdout.fnmatch_lines(\n        [\n            \"    def check():\",\n            \">       assert 1 == 2\",\n            \"E       assert 1 == 2\",\n            \"\",\n            \"pdb.py:2: AssertionError\",\n            \"*= 1 failed in *\",\n        ]\n    )\n    assert result.ret == 1\n", "type": "function"}, {"name": "test_assertion_rewrite", "is_method": true, "class_name": "TestGeneralUsage", "parameters": ["self", "pytester", "import_mode"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 159, "end_line": 169}, "code_snippet": "    def test_assertion_rewrite(self, pytester: Pytester, import_mode) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_this():\n                x = 0\n                assert x\n        \"\"\"\n        )\n        result = pytester.runpytest(p, f\"--import-mode={import_mode}\")\n        result.stdout.fnmatch_lines([\">       assert x\", \"E       assert 0\"])\n        assert result.ret == 1\n", "type": "function"}, {"name": "test_rewrite_warning", "is_method": true, "class_name": "TestRewriteOnImport", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1191, "end_line": 1200}, "code_snippet": "    def test_rewrite_warning(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            pytest.register_assert_rewrite(\"_pytest\")\n        \"\"\"\n        )\n        # needs to be a subprocess because pytester explicitly disables this warning\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*Module already imported*; _pytest\"])\n", "type": "function"}, {"name": "test_rewritten", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1551, "end_line": 1558}, "code_snippet": "def test_rewritten(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def test_rewritten():\n            assert \"@py_builtins\" in globals()\n    \"\"\"\n    )\n    assert pytester.runpytest().ret == 0\n", "type": "function"}, {"name": "test_dont_rewrite", "is_method": true, "class_name": "TestAssertionRewrite", "parameters": ["self"], "calls": ["rewrite", "isinstance", "len"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 342, "end_line": 347}, "code_snippet": "    def test_dont_rewrite(self) -> None:\n        s = \"\"\"'PYTEST_DONT_REWRITE'\\nassert 14\"\"\"\n        m = rewrite(s)\n        assert len(m.body) == 2\n        assert isinstance(m.body[1], ast.Assert)\n        assert m.body[1].msg is None\n", "type": "function"}, {"name": "test_assertion_walrus_operator_dont_rewrite", "is_method": true, "class_name": "TestIssue10743", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1574, "end_line": 1591}, "code_snippet": "    def test_assertion_walrus_operator_dont_rewrite(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            'PYTEST_DONT_REWRITE'\n            def my_func(before, after):\n                return before == after\n\n            def change_value(value):\n                return value.lower()\n\n            def test_walrus_conversion_dont_rewrite():\n                a = \"Hello\"\n                assert not my_func(a, a := change_value(a))\n                assert a == \"hello\"\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        assert result.ret == 0\n", "type": "function"}, {"name": "test_conftest_assertion_rewrite", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester", "initial_conftest", "mode"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytester.mkdir", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 82, "end_line": 111}, "code_snippet": "    def test_conftest_assertion_rewrite(\n        self, pytester: Pytester, initial_conftest, mode\n    ) -> None:\n        \"\"\"Test that conftest files are using assertion rewrite on import (#1619).\"\"\"\n        pytester.mkdir(\"foo\")\n        pytester.mkdir(\"foo/tests\")\n        conftest_path = \"conftest.py\" if initial_conftest else \"foo/conftest.py\"\n        contents = {\n            conftest_path: \"\"\"\n                import pytest\n                @pytest.fixture\n                def check_first():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"foo/tests/test_foo.py\": \"\"\"\n                def test(check_first):\n                    check_first([10, 30], 30)\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(f\"--assert={mode}\")\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n        result.stdout.fnmatch_lines([expected])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.151528835296631}
{"question": "Why does Pytest implement a plugin-based architecture instead of a monolithic testing framework?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements a plugin-based architecture instead of a monolithic testing framework for several key architectural and practical reasons: 1) Plugin-based architecture enables modularity where each piece of functionality is implemented as a separate plugin, making the codebase more maintainable and easier to understand, 2) Plugin system allows for selective feature loading where users only load the plugins they need, reducing memory footprint and startup time, 3) Plugin architecture enables community-driven development where third-party developers can extend pytest without modifying core code, 4) Plugin system provides better separation of concerns where each plugin focuses on specific functionality (collection, execution, reporting, etc.), 5) Plugin-based approach enables easier testing and debugging as individual plugins can be tested in isolation, 6) Plugin architecture supports conditional loading where plugins can be enabled/disabled based on configuration or environment, 7) Plugin system enables better error isolation where a failing plugin doesn't break the entire testing framework, 8) Plugin-based architecture supports the ecosystem of over 1300+ external plugins that extend pytest's functionality, 9) Plugin system enables easier maintenance and updates as individual plugins can be updated independently, 10) Plugin architecture provides better extensibility where new features can be added without modifying core pytest code, 11) Plugin system enables better integration with different testing scenarios and frameworks through specialized plugins, 12) Plugin-based approach creates a more sustainable development model where the core team can focus on essential functionality while the community provides specialized features.", "score": null, "retrieved_content": [{"name": "pytester", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 161, "end_line": 163}, "code_snippet": "def pytester(pytester: Pytester, monkeypatch: MonkeyPatch) -> Pytester:\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return pytester\n", "type": "function"}, {"name": "pytestpm", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 21, "end_line": 22}, "code_snippet": "def pytestpm() -> PytestPluginManager:\n    return PytestPluginManager()\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["request", "tmp_path_factory", "monkeypatch"], "calls": ["Pytester"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 477, "end_line": 490}, "code_snippet": "def pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.\n    \"\"\"\n    return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)\n", "type": "function"}, {"name": "test_rewrites_plugin_as_a_package", "is_method": true, "class_name": "TestAssertionRewrite", "parameters": ["self", "pytester"], "calls": ["pytester.mkpydir", "write_text", "pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "pkgdir.joinpath"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 359, "end_line": 373}, "code_snippet": "    def test_rewrites_plugin_as_a_package(self, pytester: Pytester) -> None:\n        pkgdir = pytester.mkpydir(\"plugin\")\n        pkgdir.joinpath(\"__init__.py\").write_text(\n            \"import pytest\\n\"\n            \"@pytest.fixture\\n\"\n            \"def special_asserter():\\n\"\n            \"    def special_assert(x, y):\\n\"\n            \"        assert x == y\\n\"\n            \"    return special_assert\\n\",\n            encoding=\"utf-8\",\n        )\n        pytester.makeconftest('pytest_plugins = [\"plugin\"]')\n        pytester.makepyfile(\"def test(special_asserter): special_asserter(1, 2)\\n\")\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"*assert 1 == 2*\"])\n", "type": "function"}, {"name": "test_pytest_collect_file", "is_method": true, "class_name": "TestCollectPluginHookRelay", "parameters": ["self", "pytester"], "calls": ["pytester.makefile", "pytest.main", "len", "file_path.name.startswith", "wascalled.append", "Plugin"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 281, "end_line": 293}, "code_snippet": "    def test_pytest_collect_file(self, pytester: Pytester) -> None:\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, file_path: Path) -> None:\n                if not file_path.name.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(file_path)\n\n        pytester.makefile(\".abc\", \"xyz\")\n        pytest.main(pytester.path, plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].suffix == \".abc\"\n", "type": "function"}, {"name": "test_pytester_runs_with_plugin", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.assert_outcomes"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 83, "end_line": 92}, "code_snippet": "def test_pytester_runs_with_plugin(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        pytest_plugins = \"pytester\"\n        def test_hello(pytester):\n            assert 1\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.assert_outcomes(passed=1)\n", "type": "function"}, {"name": "test_disable_plugin_autoload", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch", "enable_plugin_method", "disable_plugin_method"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "monkeypatch.setattr", "monkeypatch.setitem", "pytester.parseconfig", "monkeypatch.setenv", "monkeypatch.setenv", "PseudoPlugin", "config.pluginmanager.get_plugin", "platform.python_implementation", "DummyEntryPoint", "self.attrs_used.append", "object", "Distribution", "monkeypatch.delenv", "parse_args.append", "monkeypatch.delenv", "parse_args.extend", "bool", "bool"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1320, "end_line": 1397}, "code_snippet": "def test_disable_plugin_autoload(\n    pytester: Pytester,\n    monkeypatch: MonkeyPatch,\n    enable_plugin_method: str,\n    disable_plugin_method: str,\n) -> None:\n    class DummyEntryPoint:\n        project_name = name = \"mytestplugin\"\n        group = \"pytest11\"\n        version = \"1.0\"\n\n        def load(self):\n            return sys.modules[self.name]\n\n    class Distribution:\n        metadata = {\"name\": \"foo\"}\n        entry_points = (DummyEntryPoint(),)\n        files = ()\n\n    class PseudoPlugin:\n        x = 42\n\n        attrs_used = []\n\n        def __getattr__(self, name):\n            assert name in (\"__loader__\", \"__spec__\")\n            self.attrs_used.append(name)\n            return object()\n\n    def distributions():\n        return (Distribution(),)\n\n    parse_args: list[str] = []\n\n    if disable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    elif disable_plugin_method == \"flag\":\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        parse_args.append(\"--disable-plugin-autoload\")\n    else:\n        assert disable_plugin_method == \"\"\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n\n    if enable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n    elif enable_plugin_method == \"flag\":\n        parse_args.extend([\"-p\", \"mytestplugin\"])\n    else:\n        assert enable_plugin_method == \"\"\n\n    monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n    monkeypatch.setitem(sys.modules, \"mytestplugin\", PseudoPlugin())\n    config = pytester.parseconfig(*parse_args)\n\n    has_loaded = config.pluginmanager.get_plugin(\"mytestplugin\") is not None\n    # it should load if it's enabled, or we haven't disabled autoloading\n    assert has_loaded == (bool(enable_plugin_method) or not disable_plugin_method)\n\n    # The reason for the discrepancy between 'has_loaded' and __loader__ being accessed\n    # appears to be the monkeypatching of importlib.metadata.distributions; where\n    # files being empty means that _mark_plugins_for_rewrite doesn't find the plugin.\n    # But enable_method==flag ends up in mark_rewrite being called and __loader__\n    # being accessed.\n    assert (\"__loader__\" in PseudoPlugin.attrs_used) == (\n        has_loaded\n        and not (enable_plugin_method in (\"env_var\", \"\") and not disable_plugin_method)\n    )\n\n    # __spec__ is accessed in AssertionRewritingHook.exec_module, which would be\n    # eventually called if we did a full pytest run; but it's only accessed with\n    # enable_plugin_method==\"env_var\" because that will early-load it.\n    # Except when autoloads aren't disabled, in which case PytestPluginManager.import_plugin\n    # bails out before importing it.. because it knows it'll be loaded later?\n    # The above seems a bit weird, but I *think* it's true.\n    if platform.python_implementation() != \"PyPy\":\n        assert (\"__spec__\" in PseudoPlugin.attrs_used) == bool(\n            enable_plugin_method == \"env_var\" and disable_plugin_method\n        )\n", "type": "function"}, {"name": "test_installed_plugin_rewrite", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester", "mode", "monkeypatch", "disable_plugin_autoload", "explicit_specify"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytester.mkdir", "pytester.makepyfile", "pytester.run", "monkeypatch.setenv", "monkeypatch.setenv", "result.assert_outcomes", "result.stdout.fnmatch_lines", "result.assert_outcomes", "result.stdout.fnmatch_lines", "monkeypatch.delenv", "args.append", "monkeypatch.delenv", "args.append", "args.append"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 223, "end_line": 326}, "code_snippet": "    def test_installed_plugin_rewrite(\n        self,\n        pytester: Pytester,\n        mode: str,\n        monkeypatch: pytest.MonkeyPatch,\n        disable_plugin_autoload: str,\n        explicit_specify: str,\n    ) -> None:\n        args = [\"mainwrapper.py\", \"-s\", f\"--assert={mode}\"]\n        if disable_plugin_autoload == \"env_var\":\n            monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n        elif disable_plugin_autoload == \"cli\":\n            monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n            args.append(\"--disable-plugin-autoload\")\n        else:\n            assert disable_plugin_autoload == \"\"\n            monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n        name = \"spamplugin\"\n\n        if explicit_specify == \"env_var\":\n            monkeypatch.setenv(\"PYTEST_PLUGINS\", name)\n        elif explicit_specify == \"cli\":\n            args.append(\"-p\")\n            args.append(name)\n        else:\n            assert explicit_specify == \"\"\n\n        # Make sure the hook is installed early enough so that plugins\n        # installed via distribution package are rewritten.\n        pytester.mkdir(\"hampkg\")\n        contents = {\n            \"hampkg/__init__.py\": \"\"\"\\\n                import pytest\n\n                @pytest.fixture\n                def check_first2():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"spamplugin.py\": \"\"\"\\\n            import pytest\n            from hampkg import check_first2\n\n            @pytest.fixture\n            def check_first():\n                def check(values, value):\n                    assert values.pop(0) == value\n                return check\n            \"\"\",\n            \"mainwrapper.py\": \"\"\"\\\n            import importlib.metadata\n            import pytest\n\n            class DummyEntryPoint(object):\n                name = 'spamplugin'\n                module_name = 'spam.py'\n                group = 'pytest11'\n\n                def load(self):\n                    import spamplugin\n                    return spamplugin\n\n            class DummyDistInfo(object):\n                version = '1.0'\n                files = ('spamplugin.py', 'hampkg/__init__.py')\n                entry_points = (DummyEntryPoint(),)\n                metadata = {'name': 'foo'}\n\n            def distributions():\n                return (DummyDistInfo(),)\n\n            importlib.metadata.distributions = distributions\n            pytest.main()\n            \"\"\",\n            \"test_foo.py\": \"\"\"\\\n            def test(check_first):\n                check_first([10, 30], 30)\n\n            def test2(check_first2):\n                check_first2([10, 30], 30)\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.run(sys.executable, *args)\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n\n        if not disable_plugin_autoload or explicit_specify:\n            result.assert_outcomes(failed=2)\n            result.stdout.fnmatch_lines([expected, expected])\n        else:\n            result.assert_outcomes(errors=2)\n            result.stdout.fnmatch_lines(\n                [\n                    \"E       fixture 'check_first' not found\",\n                    \"E       fixture 'check_first2' not found\",\n                ]\n            )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.9157488346099854}
{"question": "Why does Pytest's fixture caching system impact memory usage and performance in large test suites?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's fixture caching system impacts memory usage and performance in large test suites due to several factors: 1) Fixture instances are cached in memory for the duration of their scope (function, class, module, package, session), leading to increased memory consumption as more fixtures are created, 2) Session-scoped fixtures remain in memory for the entire test session, potentially holding large objects or resources that consume significant memory, 3) Fixture dependency chains can create complex caching hierarchies where multiple fixtures are cached simultaneously, multiplying memory usage, 4) Parametrized fixtures create separate cached instances for each parameter value, exponentially increasing memory usage with parameter combinations, 5) Fixture finalization and cleanup operations add overhead as cached fixtures must be properly torn down when their scope ends, 6) Cache key generation and comparison overhead for determining cache hits/misses in large fixture dependency graphs, 7) Memory fragmentation from fixture objects that may have different lifetimes and cleanup schedules, 8) Fixture caching can lead to memory leaks if fixtures hold references to large objects that aren't properly cleaned up, 9) The FixtureDef.cached_result attribute stores fixture values, cache keys, and exception information, consuming memory for each cached fixture, 10) Large test suites with many fixtures can overwhelm the garbage collector, leading to performance degradation, 11) Fixture caching prevents parallel execution of tests that share the same fixture scope, limiting performance optimization opportunities, 12) Memory pressure from cached fixtures can cause system slowdowns and affect overall test execution performance.", "score": null, "retrieved_content": [{"name": "test_request_garbage", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytest.mark.skipif", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines", "hasattr", "pytest.xfail"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 741, "end_line": 775}, "code_snippet": "    def test_request_garbage(self, pytester: Pytester) -> None:\n        try:\n            import xdist  # noqa: F401\n        except ImportError:\n            pass\n        else:\n            pytest.xfail(\"this test is flaky when executed with xdist\")\n        pytester.makepyfile(\n            \"\"\"\n            import sys\n            import pytest\n            from _pytest.fixtures import PseudoFixtureDef\n            import gc\n\n            @pytest.fixture(autouse=True)\n            def something(request):\n                original = gc.get_debug()\n                gc.set_debug(gc.DEBUG_SAVEALL)\n                gc.collect()\n\n                yield\n\n                try:\n                    gc.collect()\n                    leaked = [x for _ in gc.garbage if isinstance(_, PseudoFixtureDef)]\n                    assert leaked == []\n                finally:\n                    gc.set_debug(original)\n\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n", "type": "function"}, {"name": "test_fixture_values_leak", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1142, "end_line": 1187}, "code_snippet": "def test_fixture_values_leak(pytester: Pytester) -> None:\n    \"\"\"Ensure that fixture objects are properly destroyed by the garbage collector at the end of their expected\n    life-times (#2981).\n    \"\"\"\n    pytester.makepyfile(\n        \"\"\"\n        import dataclasses\n        import gc\n        import pytest\n        import weakref\n\n        @dataclasses.dataclass\n        class SomeObj:\n            name: str\n\n        fix_of_test1_ref = None\n        session_ref = None\n\n        @pytest.fixture(scope='session')\n        def session_fix():\n            global session_ref\n            obj = SomeObj(name='session-fixture')\n            session_ref = weakref.ref(obj)\n            return obj\n\n        @pytest.fixture\n        def fix(session_fix):\n            global fix_of_test1_ref\n            obj = SomeObj(name='local-fixture')\n            fix_of_test1_ref = weakref.ref(obj)\n            return obj\n\n        def test1(fix):\n            assert fix_of_test1_ref() is fix\n\n        def test2():\n            gc.collect()\n            # fixture \"fix\" created during test1 must have been destroyed by now\n            assert fix_of_test1_ref() is None\n    \"\"\"\n    )\n    # Running on subprocess does not activate the HookRecorder\n    # which holds itself a reference to objects in case of the\n    # pytest_assert_reprcompare hook\n    result = pytester.runpytest_subprocess()\n    result.stdout.fnmatch_lines([\"* 2 passed *\"])\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_subfixture_teardown_order", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4974, "end_line": 5023}, "code_snippet": "def test_subfixture_teardown_order(pytester: Pytester) -> None:\n    \"\"\"\n    Make sure fixtures don't re-register their finalization in parent fixtures multiple\n    times, causing ordering failure in their teardowns.\n\n    Regression test for #12135\n    \"\"\"\n    pytester.makepyfile(\n        \"\"\"\n        import pytest\n\n        execution_order = []\n\n        @pytest.fixture(scope=\"class\")\n        def fixture_1():\n            ...\n\n        @pytest.fixture(scope=\"class\")\n        def fixture_2(fixture_1):\n            execution_order.append(\"setup 2\")\n            yield\n            execution_order.append(\"teardown 2\")\n\n        @pytest.fixture(scope=\"class\")\n        def fixture_3(fixture_1):\n            execution_order.append(\"setup 3\")\n            yield\n            execution_order.append(\"teardown 3\")\n\n        class TestFoo:\n            def test_initialize_fixtures(self, fixture_2, fixture_3):\n                ...\n\n            # This would previously reschedule fixture_2's finalizer in the parent fixture,\n            # causing it to be torn down before fixture 3.\n            def test_reschedule_fixture_2(self, fixture_2):\n                ...\n\n            # Force finalization directly on fixture_1\n            # Otherwise the cleanup would sequence 3&2 before 1 as normal.\n            @pytest.mark.parametrize(\"fixture_1\", [None], indirect=[\"fixture_1\"])\n            def test_finalize_fixture_1(self, fixture_1):\n                ...\n\n        def test_result():\n            assert execution_order == [\"setup 2\", \"setup 3\", \"teardown 3\", \"teardown 2\"]\n        \"\"\"\n    )\n    result = pytester.runpytest()\n    assert result.ret == 0\n", "type": "function"}, {"name": "test_capture_scope_cache", "is_method": true, "class_name": "TestPerTestCapturing", "parameters": ["self", "pytester"], "calls": ["pytest.mark.xfail", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 182, "end_line": 207}, "code_snippet": "    def test_capture_scope_cache(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            import sys\n            def setup_module(func):\n                print(\"module-setup\")\n            def setup_function(func):\n                print(\"function-setup\")\n            def test_func():\n                print(\"in function\")\n                assert 0\n            def teardown_function(func):\n                print(\"in teardown\")\n        \"\"\"\n        )\n        result = pytester.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_func():*\",\n                \"*Captured stdout during setup*\",\n                \"module-setup*\",\n                \"function-setup*\",\n                \"*Captured stdout*\",\n                \"in teardown*\",\n            ]\n        )\n", "type": "function"}, {"name": "show_fixtures_per_test", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["wrap_session"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1882, "end_line": 1885}, "code_snippet": "def show_fixtures_per_test(config: Config) -> int | ExitCode:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _show_fixtures_per_test)\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Cache", "parameters": ["self", "cachedir", "config"], "calls": ["check_ispytest"], "code_location": {"file": "cacheprovider.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 69, "end_line": 74}, "code_snippet": "    def __init__(\n        self, cachedir: Path, config: Config, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._cachedir = cachedir\n        self._config = config\n", "type": "function"}, {"name": "test_parameterized_fixture_caching", "is_method": true, "class_name": "TestFixtureUsages", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.no_fnmatch_line"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1593, "end_line": 1623}, "code_snippet": "    def test_parameterized_fixture_caching(self, pytester: Pytester) -> None:\n        \"\"\"Regression test for #12600.\"\"\"\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            from itertools import count\n\n            CACHE_MISSES = count(0)\n\n            def pytest_generate_tests(metafunc):\n                if \"my_fixture\" in metafunc.fixturenames:\n                    # Use unique objects for parametrization (as opposed to small strings\n                    # and small integers which are singletons).\n                    metafunc.parametrize(\"my_fixture\", [[1], [2]], indirect=True)\n\n            @pytest.fixture(scope='session')\n            def my_fixture(request):\n                next(CACHE_MISSES)\n\n            def test1(my_fixture):\n                pass\n\n            def test2(my_fixture):\n                pass\n\n            def teardown_module():\n                assert next(CACHE_MISSES) == 2\n            \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.no_fnmatch_line(\"* ERROR at teardown *\")\n", "type": "function"}, {"name": "test_fixture_dependency", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "touch", "pytester.mkdir", "touch", "write_text", "sub.joinpath", "subsub.mkdir", "touch", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "textwrap.dedent", "pytester.path.joinpath", "sub.joinpath", "sub.joinpath", "subsub.joinpath", "subsub.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 466, "end_line": 510}, "code_snippet": "def test_fixture_dependency(pytester: Pytester) -> None:\n    pytester.makeconftest(\"\")\n    pytester.path.joinpath(\"__init__.py\").touch()\n    sub = pytester.mkdir(\"sub\")\n    sub.joinpath(\"__init__.py\").touch()\n    sub.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    subsub = sub.joinpath(\"subsub\")\n    subsub.mkdir()\n    subsub.joinpath(\"__init__.py\").touch()\n    subsub.joinpath(\"test_bar.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    result = pytester.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.9061832427978516}
{"question": "Why does Pytest implement a collector-based test discovery system instead of simple file scanning?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements a collector-based test discovery system instead of simple file scanning for several key architectural and functional reasons: 1) Collector-based system provides a hierarchical structure (Session -> Directory -> Package -> Module -> Class -> Function) that mirrors the actual test organization, 2) Each collector type (Session, Dir, Package, Module, Class) can implement custom collection logic through the collect() method, 3) The collector hierarchy enables sophisticated filtering and customization at each level through hooks like pytest_ignore_collect and pytest_collect_directory, 4) Collector-based system supports complex test discovery scenarios like custom directory collectors that can read manifest files or implement custom logic, 5) The hierarchical structure allows for proper scope management where higher-level collectors can influence lower-level ones, 6) Collector system enables plugin extensibility where plugins can provide custom collectors for specific file types or directory structures, 7) The collector hierarchy supports proper test organization where tests can be grouped by package, module, or class structure, 8) Collector-based system provides better error handling and reporting at each level of the discovery process, 9) The system enables incremental collection where only changed parts of the test tree need to be re-collected, 10) Collector hierarchy supports proper fixture scoping where fixtures can be defined at different levels (session, package, module, class), 11) The collector system enables sophisticated test filtering and deselection at multiple levels, 12) Collector-based approach provides better integration with pytest's plugin architecture and hook system for extensible test discovery.", "score": null, "retrieved_content": [{"name": "collect", "is_method": true, "class_name": "ManifestDirectory", "parameters": ["self"], "calls": ["json.loads", "manifest_path.read_text", "ihook.pytest_collect_file"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/doc/en/example/customdirectory", "start_line": 10, "end_line": 21}, "code_snippet": "    def collect(self):\n        # The standard pytest behavior is to loop over all `test_*.py` files and\n        # call `pytest_collect_file` on each file. This collector instead reads\n        # the `manifest.json` file and only calls `pytest_collect_file` for the\n        # files defined there.\n        manifest_path = self.path / \"manifest.json\"\n        manifest = json.loads(manifest_path.read_text(encoding=\"utf-8\"))\n        ihook = self.ihook\n        for file in manifest[\"files\"]:\n            yield from ihook.pytest_collect_file(\n                file_path=self.path / file, parent=self\n            )\n", "type": "function"}, {"name": "test_collection_hierarchy", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1583, "end_line": 1685}, "code_snippet": "def test_collection_hierarchy(pytester: Pytester) -> None:\n    \"\"\"A general test checking that a filesystem hierarchy is collected as\n    expected in various scenarios.\n\n    top/\n     aaa\n        pkg\n           __init__.py\n           test_pkg.py\n        test_aaa.py\n     test_a.py\n     test_b\n        __init__.py\n        test_b.py\n     test_c.py\n     zzz\n         dir\n            test_dir.py\n         __init__.py\n         test_zzz.py\n    \"\"\"\n    pytester.makepyfile(\n        **{\n            \"top/aaa/test_aaa.py\": \"def test_it(): pass\",\n            \"top/aaa/pkg/__init__.py\": \"\",\n            \"top/aaa/pkg/test_pkg.py\": \"def test_it(): pass\",\n            \"top/test_a.py\": \"def test_it(): pass\",\n            \"top/test_b/__init__.py\": \"\",\n            \"top/test_b/test_b.py\": \"def test_it(): pass\",\n            \"top/test_c.py\": \"def test_it(): pass\",\n            \"top/zzz/__init__.py\": \"\",\n            \"top/zzz/test_zzz.py\": \"def test_it(): pass\",\n            \"top/zzz/dir/test_dir.py\": \"def test_it(): pass\",\n        }\n    )\n\n    full = [\n        \"<Dir test_collection_hierarchy*>\",\n        \"  <Dir top>\",\n        \"    <Dir aaa>\",\n        \"      <Package pkg>\",\n        \"        <Module test_pkg.py>\",\n        \"          <Function test_it>\",\n        \"      <Module test_aaa.py>\",\n        \"        <Function test_it>\",\n        \"    <Module test_a.py>\",\n        \"      <Function test_it>\",\n        \"    <Package test_b>\",\n        \"      <Module test_b.py>\",\n        \"        <Function test_it>\",\n        \"    <Module test_c.py>\",\n        \"      <Function test_it>\",\n        \"    <Package zzz>\",\n        \"      <Dir dir>\",\n        \"        <Module test_dir.py>\",\n        \"          <Function test_it>\",\n        \"      <Module test_zzz.py>\",\n        \"        <Function test_it>\",\n    ]\n    result = pytester.runpytest(\"--collect-only\")\n    result.stdout.fnmatch_lines(full, consecutive=True)\n    result = pytester.runpytest(\"top\", \"--collect-only\")\n    result.stdout.fnmatch_lines(full, consecutive=True)\n    result = pytester.runpytest(\"top\", \"top\", \"--collect-only\")\n    result.stdout.fnmatch_lines(full, consecutive=True)\n\n    result = pytester.runpytest(\n        \"top/aaa\", \"top/aaa/pkg\", \"--collect-only\", \"--keep-duplicates\"\n    )\n    result.stdout.fnmatch_lines(\n        [\n            \"<Dir test_collection_hierarchy*>\",\n            \"  <Dir top>\",\n            \"    <Dir aaa>\",\n            \"      <Package pkg>\",\n            \"        <Module test_pkg.py>\",\n            \"          <Function test_it>\",\n            \"      <Module test_aaa.py>\",\n            \"        <Function test_it>\",\n            \"      <Package pkg>\",\n            \"        <Module test_pkg.py>\",\n            \"          <Function test_it>\",\n        ],\n        consecutive=True,\n    )\n\n    result = pytester.runpytest(\n        \"top/aaa/pkg\", \"top/aaa\", \"--collect-only\", \"--keep-duplicates\"\n    )\n    result.stdout.fnmatch_lines(\n        [\n            \"<Dir test_collection_hierarchy*>\",\n            \"  <Dir top>\",\n            \"    <Dir aaa>\",\n            \"      <Package pkg>\",\n            \"        <Module test_pkg.py>\",\n            \"          <Function test_it>\",\n            \"          <Function test_it>\",\n            \"      <Module test_aaa.py>\",\n            \"        <Function test_it>\",\n        ],\n        consecutive=True,\n    )\n", "type": "function"}, {"name": "test_collect_pkg_init_and_file_in_args", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.mkdir", "subdir.joinpath", "init.write_text", "subdir.joinpath", "p.write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1475, "end_line": 1509}, "code_snippet": "def test_collect_pkg_init_and_file_in_args(pytester: Pytester) -> None:\n    subdir = pytester.mkdir(\"sub\")\n    init = subdir.joinpath(\"__init__.py\")\n    init.write_text(\"def test_init(): pass\", encoding=\"utf-8\")\n    p = subdir.joinpath(\"test_file.py\")\n    p.write_text(\"def test_file(): pass\", encoding=\"utf-8\")\n\n    # Just the package directory, the __init__.py module is filtered out.\n    result = pytester.runpytest(\"-v\", subdir)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*1 passed in*\",\n        ]\n    )\n\n    # But it's included if specified directly.\n    result = pytester.runpytest(\"-v\", init, p)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/__init__.py::test_init PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )\n\n    # Or if the pattern allows it.\n    result = pytester.runpytest(\"-v\", \"-o\", \"python_files=*.py\", subdir)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/__init__.py::test_init PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )\n", "type": "function"}, {"name": "collect", "is_method": true, "class_name": "Package", "parameters": ["self"], "calls": ["scandir", "direntry.is_dir", "Path", "ihook.pytest_collect_directory", "direntry.is_file", "self.session.isinitpath", "ihook.pytest_ignore_collect", "Path", "ihook.pytest_collect_file", "self.session.isinitpath", "ihook.pytest_ignore_collect"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 685, "end_line": 710}, "code_snippet": "    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\n        # Always collect __init__.py first.\n        def sort_key(entry: os.DirEntry[str]) -> object:\n            return (entry.name != \"__init__.py\", entry.name)\n\n        config = self.config\n        col: nodes.Collector | None\n        cols: Sequence[nodes.Collector]\n        ihook = self.ihook\n        for direntry in scandir(self.path, sort_key):\n            if direntry.is_dir():\n                path = Path(direntry.path)\n                if not self.session.isinitpath(path, with_parents=True):\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n                        continue\n                col = ihook.pytest_collect_directory(path=path, parent=self)\n                if col is not None:\n                    yield col\n\n            elif direntry.is_file():\n                path = Path(direntry.path)\n                if not self.session.isinitpath(path):\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n                        continue\n                cols = ihook.pytest_collect_file(file_path=path, parent=self)\n                yield from cols\n", "type": "function"}, {"name": "collect", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["self.trace", "argpath.is_dir", "module_name.split", "enumerate", "work.pop", "isinstance", "reversed", "join", "self._notfound.append", "paths.insert", "paths.insert", "isinstance", "isinstance", "matchnode._collect_path", "self._collect_one_node", "isinstance", "notfound_collectors.append", "pm._is_in_confcutdir", "matchnode.ihook.pytest_collectreport", "work.append", "str", "len", "isinstance", "is_file", "os.path.samefile", "len", "os.path.islink", "os.path.islink", "node.name.split"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 847, "end_line": 966}, "code_snippet": "    def collect(self) -> Iterator[nodes.Item | nodes.Collector]:\n        # This is a cache for the root directories of the initial paths.\n        # We can't use collection_cache for Session because of its special\n        # role as the bootstrapping collector.\n        path_cache: dict[Path, Sequence[nodes.Collector]] = {}\n\n        pm = self.config.pluginmanager\n\n        for collection_argument in self._initial_parts:\n            self.trace(\"processing argument\", collection_argument)\n            self.trace.root.indent += 1\n\n            argpath = collection_argument.path\n            names = collection_argument.parts\n            module_name = collection_argument.module_name\n\n            # resolve_collection_argument() ensures this.\n            if argpath.is_dir():\n                assert not names, f\"invalid arg {(argpath, names)!r}\"\n\n            paths = [argpath]\n            # Add relevant parents of the path, from the root, e.g.\n            #   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]\n            if module_name is None:\n                # Paths outside of the confcutdir should not be considered.\n                for path in argpath.parents:\n                    if not pm._is_in_confcutdir(path):\n                        break\n                    paths.insert(0, path)\n            else:\n                # For --pyargs arguments, only consider paths matching the module\n                # name. Paths beyond the package hierarchy are not included.\n                module_name_parts = module_name.split(\".\")\n                for i, path in enumerate(argpath.parents, 2):\n                    if i > len(module_name_parts) or path.stem != module_name_parts[-i]:\n                        break\n                    paths.insert(0, path)\n\n            # Start going over the parts from the root, collecting each level\n            # and discarding all nodes which don't match the level's part.\n            any_matched_in_initial_part = False\n            notfound_collectors = []\n            work: list[tuple[nodes.Collector | nodes.Item, list[Path | str]]] = [\n                (self, [*paths, *names])\n            ]\n            while work:\n                matchnode, matchparts = work.pop()\n\n                # Pop'd all of the parts, this is a match.\n                if not matchparts:\n                    yield matchnode\n                    any_matched_in_initial_part = True\n                    continue\n\n                # Should have been matched by now, discard.\n                if not isinstance(matchnode, nodes.Collector):\n                    continue\n\n                # Collect this level of matching.\n                # Collecting Session (self) is done directly to avoid endless\n                # recursion to this function.\n                subnodes: Sequence[nodes.Collector | nodes.Item]\n                if isinstance(matchnode, Session):\n                    assert isinstance(matchparts[0], Path)\n                    subnodes = matchnode._collect_path(matchparts[0], path_cache)\n                else:\n                    # For backward compat, files given directly multiple\n                    # times on the command line should not be deduplicated.\n                    handle_dupes = not (\n                        len(matchparts) == 1\n                        and isinstance(matchparts[0], Path)\n                        and matchparts[0].is_file()\n                    )\n                    rep, duplicate = self._collect_one_node(matchnode, handle_dupes)\n                    if not duplicate and not rep.passed:\n                        # Report collection failures here to avoid failing to\n                        # run some test specified in the command line because\n                        # the module could not be imported (#134).\n                        matchnode.ihook.pytest_collectreport(report=rep)\n                    if not rep.passed:\n                        continue\n                    subnodes = rep.result\n\n                # Prune this level.\n                any_matched_in_collector = False\n                for node in reversed(subnodes):\n                    # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.\n                    if isinstance(matchparts[0], Path):\n                        is_match = node.path == matchparts[0]\n                        if sys.platform == \"win32\" and not is_match:\n                            # In case the file paths do not match, fallback to samefile() to\n                            # account for short-paths on Windows (#11895).\n                            same_file = os.path.samefile(node.path, matchparts[0])\n                            # We don't want to match links to the current node,\n                            # otherwise we would match the same file more than once (#12039).\n                            is_match = same_file and (\n                                os.path.islink(node.path)\n                                == os.path.islink(matchparts[0])\n                            )\n\n                    # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.\n                    else:\n                        # TODO: Remove parametrized workaround once collection structure contains\n                        # parametrization.\n                        is_match = (\n                            node.name == matchparts[0]\n                            or node.name.split(\"[\")[0] == matchparts[0]\n                        )\n                    if is_match:\n                        work.append((node, matchparts[1:]))\n                        any_matched_in_collector = True\n\n                if not any_matched_in_collector:\n                    notfound_collectors.append(matchnode)\n\n            if not any_matched_in_initial_part:\n                report_arg = \"::\".join((str(argpath), *names))\n                self._notfound.append((report_arg, notfound_collectors))\n\n            self.trace.root.indent -= 1\n", "type": "function"}, {"name": "collect", "is_method": true, "class_name": "Dir", "parameters": ["self"], "calls": ["scandir", "direntry.is_dir", "Path", "ihook.pytest_collect_directory", "direntry.is_file", "self.session.isinitpath", "ihook.pytest_ignore_collect", "Path", "ihook.pytest_collect_file", "self.session.isinitpath", "ihook.pytest_ignore_collect"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 523, "end_line": 544}, "code_snippet": "    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:\n        config = self.config\n        col: nodes.Collector | None\n        cols: Sequence[nodes.Collector]\n        ihook = self.ihook\n        for direntry in scandir(self.path):\n            if direntry.is_dir():\n                path = Path(direntry.path)\n                if not self.session.isinitpath(path, with_parents=True):\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n                        continue\n                col = ihook.pytest_collect_directory(path=path, parent=self)\n                if col is not None:\n                    yield col\n\n            elif direntry.is_file():\n                path = Path(direntry.path)\n                if not self.session.isinitpath(path):\n                    if ihook.pytest_ignore_collect(collection_path=path, config=config):\n                        continue\n                cols = ihook.pytest_collect_file(file_path=path, parent=self)\n                yield from cols\n", "type": "function"}, {"name": "test_pytest_collect_file_from_sister_dir", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.mkpydir", "pytester.mkpydir", "pytester.makeconftest", "conf1.replace", "pytester.makeconftest", "conf2.replace", "pytester.makepyfile", "shutil.copy", "shutil.copy", "pytester.runpytest", "result.stdout.fnmatch_lines", "sub1.joinpath", "sub2.joinpath", "sub1.joinpath", "sub2.joinpath"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 465, "end_line": 494}, "code_snippet": "    def test_pytest_collect_file_from_sister_dir(self, pytester: Pytester) -> None:\n        sub1 = pytester.mkpydir(\"sub1\")\n        sub2 = pytester.mkpydir(\"sub2\")\n        conf1 = pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule1(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule1.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        conf1.replace(sub1.joinpath(conf1.name))\n        conf2 = pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule2(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule2.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        conf2.replace(sub2.joinpath(conf2.name))\n        p = pytester.makepyfile(\"def test_x(): pass\")\n        shutil.copy(p, sub1.joinpath(p.name))\n        shutil.copy(p, sub2.joinpath(p.name))\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n", "type": "function"}, {"name": "test_pytest_fs_collect_hooks_are_seen", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 449, "end_line": 463}, "code_snippet": "    def test_pytest_fs_collect_hooks_are_seen(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        pytester.mkdir(\"sub\")\n        pytester.makepyfile(\"def test_x(): pass\")\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n", "type": "function"}, {"name": "pytest_collectstart", "is_method": false, "class_name": null, "parameters": ["collector"], "calls": [], "code_location": {"file": "hookspec.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 415, "end_line": 427}, "code_snippet": "def pytest_collectstart(collector: Collector) -> None:\n    \"\"\"Collector starts collecting.\n\n    :param collector:\n        The collector.\n\n    Use in conftest plugins\n    =======================\n\n    Any conftest file can implement this hook. For a given collector, only\n    conftest files in the collector's directory and its parent directories are\n    consulted.\n    \"\"\"\n", "type": "function"}, {"name": "test_collect_pkg_init_only", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.mkdir", "subdir.joinpath", "init.write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1512, "end_line": 1524}, "code_snippet": "def test_collect_pkg_init_only(pytester: Pytester) -> None:\n    subdir = pytester.mkdir(\"sub\")\n    init = subdir.joinpath(\"__init__.py\")\n    init.write_text(\"def test_init(): pass\", encoding=\"utf-8\")\n\n    result = pytester.runpytest(subdir)\n    result.stdout.fnmatch_lines([\"*no tests ran in*\"])\n\n    result = pytester.runpytest(\"-v\", init)\n    result.stdout.fnmatch_lines([\"sub/__init__.py::test_init PASSED*\", \"*1 passed in*\"])\n\n    result = pytester.runpytest(\"-v\", \"-o\", \"python_files=*.py\", subdir)\n    result.stdout.fnmatch_lines([\"sub/__init__.py::test_init PASSED*\", \"*1 passed in*\"])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.9652085304260254}
{"question": "Why does Pytest's assertion rewriting mechanism impact test execution performance compared to traditional assertion libraries?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's assertion rewriting mechanism impacts test execution performance compared to traditional assertion libraries due to several factors: 1) AST transformation overhead where assert statements are parsed and rewritten into more complex if-else blocks during module import, 2) Additional code execution during assertion evaluation as rewritten assertions execute multiple statements to capture intermediate values and build detailed error messages, 3) Memory overhead from storing rewritten bytecode and maintaining assertion state information, 4) Import hook overhead where the AssertionRewritingHook intercepts module imports to perform rewriting, 5) Caching mechanism overhead for storing and retrieving rewritten .pyc files, 6) Variable creation and management overhead as rewritten assertions create temporary variables to store intermediate values, 7) String formatting overhead for building detailed assertion failure messages with intermediate values, 8) Hook execution overhead when pytest_assertion_pass hook is enabled for passing assertions, 9) File I/O overhead for writing cached rewritten modules to disk, 10) Module loading overhead as rewritten modules are larger and more complex than original modules, 11) Startup time impact as assertion rewriting happens during the import phase before test execution begins, 12) Runtime overhead from executing the more complex rewritten assertion code compared to simple assert statements.", "score": null, "retrieved_content": [{"name": "test_rewrite_ast", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.mkdir", "pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 328, "end_line": 371}, "code_snippet": "    def test_rewrite_ast(self, pytester: Pytester) -> None:\n        pytester.mkdir(\"pkg\")\n        contents = {\n            \"pkg/__init__.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite('pkg.helper')\n            \"\"\",\n            \"pkg/helper.py\": \"\"\"\n                def tool():\n                    a, b = 2, 3\n                    assert a == b\n            \"\"\",\n            \"pkg/plugin.py\": \"\"\"\n                import pytest, pkg.helper\n                @pytest.fixture\n                def tool():\n                    return pkg.helper.tool\n            \"\"\",\n            \"pkg/other.py\": \"\"\"\n                values = [3, 2]\n                def tool():\n                    assert values.pop() == 3\n            \"\"\",\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['pkg.plugin']\n            \"\"\",\n            \"test_pkg.py\": \"\"\"\n                import pkg.other\n                def test_tool(tool):\n                    tool()\n                def test_other():\n                    pkg.other.tool()\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.runpytest_subprocess(\"--assert=rewrite\")\n        result.stdout.fnmatch_lines(\n            [\n                \">*assert a == b*\",\n                \"E*assert 2 == 3*\",\n                \">*assert values.pop() == 3*\",\n                \"E*AssertionError\",\n            ]\n        )\n", "type": "function"}, {"name": "test_rewrite_assertions_pytester_plugin", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines", "result.stdout.fnmatch_lines_random"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 113, "end_line": 144}, "code_snippet": "    def test_rewrite_assertions_pytester_plugin(self, pytester: Pytester) -> None:\n        \"\"\"\n        Assertions in the pytester plugin must also benefit from assertion\n        rewriting (#1920).\n        \"\"\"\n        pytester.makepyfile(\n            \"\"\"\n            pytest_plugins = ['pytester']\n            def test_dummy_failure(pytester):  # how meta!\n                pytester.makepyfile('def test(): assert 0')\n                r = pytester.inline_run()\n                r.assertoutcome(passed=1)\n        \"\"\"\n        )\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \">       r.assertoutcome(passed=1)\",\n                \"E       AssertionError: ([[][]], [[][]], [[]<TestReport *>[]])*\",\n                \"E       assert {'failed': 1,... 'skipped': 0} == {'failed': 0,... 'skipped': 0}\",\n                \"E         Omitting 1 identical items, use -vv to show\",\n                \"E         Differing items:\",\n                \"E         Use -v to get more diff\",\n            ]\n        )\n        # XXX: unstable output.\n        result.stdout.fnmatch_lines_random(\n            [\n                \"E         {'failed': 1} != {'failed': 0}\",\n                \"E         {'passed': 0} != {'passed': 1}\",\n            ]\n        )\n", "type": "function"}, {"name": "test_assertion_rewrite", "is_method": true, "class_name": "TestGeneralUsage", "parameters": ["self", "pytester", "import_mode"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 159, "end_line": 169}, "code_snippet": "    def test_assertion_rewrite(self, pytester: Pytester, import_mode) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_this():\n                x = 0\n                assert x\n        \"\"\"\n        )\n        result = pytester.runpytest(p, f\"--import-mode={import_mode}\")\n        result.stdout.fnmatch_lines([\">       assert x\", \"E       assert 0\"])\n        assert result.ret == 1\n", "type": "function"}, {"name": "AssertionRewriter", "docstring": "Assertion rewriting implementation.\n\nThe main entrypoint is to call .run() with an ast.Module instance,\nthis will then find all the assert statements and rewrite them to\nprovide intermediate values and a detailed assertion error.  See\nhttp://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\nfor an overview of how this works.\n\nThe entry point here is .run() which will iterate over all the\nstatements in an ast.Module and for each ast.Assert statement it\nfinds call .visit() with it.  Then .visit_Assert() takes over and\nis responsible for creating new ast statements to replace the\noriginal assert statement: it rewrites the test of an assertion\nto provide intermediate values and replace it with an if statement\nwhich raises an assertion error with a detailed explanation in\ncase the expression is false and calls pytest_assertion_pass hook\nif expression is true.\n\nFor this .visit_Assert() uses the visitor pattern to visit all the\nAST nodes of the ast.Assert.test field, each visit call returning\nan AST node and the corresponding explanation string.  During this\nstate is kept in several instance attributes:\n\n:statements: All the AST statements which will replace the assert\n   statement.\n\n:variables: This is populated by .variable() with each variable\n   used by the statements so that they can all be set to None at\n   the end of the statements.\n\n:variable_counter: Counter to create new unique variables needed\n   by statements.  Variables are created using .variable() and\n   have the form of \"@py_assert0\".\n\n:expl_stmts: The AST statements which will be executed to get\n   data from the assertion.  This is the code which will construct\n   the detailed assertion message that is used in the AssertionError\n   or for the pytest_assertion_pass hook.\n\n:explanation_specifiers: A dict filled by .explanation_param()\n   with %-formatting placeholders and their corresponding\n   expressions to use in the building of an assertion message.\n   This is used by .pop_format_context() to build a message.\n\n:stack: A stack of the explanation_specifiers dicts maintained by\n   .push_format_context() and .pop_format_context() which allows\n   to build another %-formatted string while already building one.\n\n:scope: A tuple containing the current scope used for variables_overwrite.\n\n:variables_overwrite: A dict filled with references to variables\n   that change value within an assert. This happens when a variable is\n   reassigned with the walrus operator\n\nThis state, except the variables_overwrite,  is reset on every new assert\nstatement visited and used by the other visitors.", "methods": ["__init__", "run", "is_rewrite_disabled", "variable", "assign", "display", "helper", "builtin", "explanation_param", "push_format_context", "pop_format_context", "generic_visit", "visit_Assert", "visit_NamedExpr", "visit_Name", "visit_BoolOp", "visit_UnaryOp", "visit_BinOp", "visit_Call", "visit_Starred", "visit_Attribute", "visit_Compare"], "attributes": [], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 615, "end_line": 1176}, "type": "class"}, {"name": "test_rewrite_warning", "is_method": true, "class_name": "TestRewriteOnImport", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.runpytest_subprocess", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1191, "end_line": 1200}, "code_snippet": "    def test_rewrite_warning(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            pytest.register_assert_rewrite(\"_pytest\")\n        \"\"\"\n        )\n        # needs to be a subprocess because pytester explicitly disables this warning\n        result = pytester.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*Module already imported*; _pytest\"])\n", "type": "function"}, {"name": "test_assertion_options", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "pytester.runpytest_subprocess", "result.stdout.no_fnmatch_line", "result.stdout.str"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1684, "end_line": 1695}, "code_snippet": "def test_assertion_options(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def test_hello():\n            x = 3\n            assert x == 4\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    assert \"3 == 4\" in result.stdout.str()\n    result = pytester.runpytest_subprocess(\"--assert=plain\")\n    result.stdout.no_fnmatch_line(\"*3 == 4*\")\n", "type": "function"}, {"name": "test_rewritten", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1551, "end_line": 1558}, "code_snippet": "def test_rewritten(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def test_rewritten():\n            assert \"@py_builtins\" in globals()\n    \"\"\"\n    )\n    assert pytester.runpytest().ret == 0\n", "type": "function"}, {"name": "test_assertion_walrus_operator_dont_rewrite", "is_method": true, "class_name": "TestIssue10743", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest"], "code_location": {"file": "test_assertrewrite.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1574, "end_line": 1591}, "code_snippet": "    def test_assertion_walrus_operator_dont_rewrite(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            'PYTEST_DONT_REWRITE'\n            def my_func(before, after):\n                return before == after\n\n            def change_value(value):\n                return value.lower()\n\n            def test_walrus_conversion_dont_rewrite():\n                a = \"Hello\"\n                assert not my_func(a, a := change_value(a))\n                assert a == \"hello\"\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        assert result.ret == 0\n", "type": "function"}, {"name": "test_pytest_assertrepr_compare_called", "is_method": true, "class_name": "TestBinReprIntegration", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 382, "end_line": 404}, "code_snippet": "    def test_pytest_assertrepr_compare_called(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            values = []\n            def pytest_assertrepr_compare(op, left, right):\n                values.append((op, left, right))\n\n            @pytest.fixture\n            def list(request):\n                return values\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n            def test_hello():\n                assert 0 == 1\n            def test_check(list):\n                assert list == [(\"==\", 0, 1)]\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_hello*FAIL*\", \"*test_check*PASS*\"])\n", "type": "function"}, {"name": "test_python25_compile_issue257", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1533, "end_line": 1548}, "code_snippet": "def test_python25_compile_issue257(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def test_rewritten():\n            assert 1 == 2\n        # some comment\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        \"\"\"\n            *E*assert 1 == 2*\n            *1 failed*\n    \"\"\"\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.971424102783203}
{"question": "Why does Pytest include built-in support for test parametrization and marking?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest includes built-in support for test parametrization and marking to provide essential testing functionality that addresses common testing needs: 1) Test parametrization allows the same test logic to be executed with multiple sets of input data, reducing code duplication and improving test coverage, 2) Built-in parametrization through @pytest.mark.parametrize decorator provides a clean, declarative way to define multiple test scenarios, 3) Test marking enables categorization and organization of tests through metadata that can be used for selective test execution, 4) Built-in markers like skip, xfail, usefixtures, and filterwarnings provide common testing patterns that users need frequently, 5) Marking system enables test selection and filtering through command-line options like -m for running specific test categories, 6) Parametrization supports both direct and indirect parameter passing, allowing flexible test data handling, 7) Built-in support ensures consistent behavior and reduces the need for users to implement common testing patterns themselves, 8) Marking system integrates with pytest's plugin architecture, allowing plugins to define and use custom markers, 9) Parametrization supports individual test marking within parameter sets using pytest.param for fine-grained control, 10) Built-in markers provide standardized ways to handle common testing scenarios like conditional skipping and expected failures, 11) The combination of parametrization and marking enables complex test organization and execution strategies, 12) Built-in support ensures that these essential features are always available without requiring additional dependencies or plugins.", "score": null, "retrieved_content": [{"name": "pytest_generate_tests", "is_method": false, "class_name": null, "parameters": ["metafunc"], "calls": ["metafunc.definition.iter_markers", "metafunc.parametrize"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 112, "end_line": 114}, "code_snippet": "def pytest_generate_tests(metafunc: Metafunc) -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.addinivalue_line", "config.addinivalue_line"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 117, "end_line": 134}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures \",\n    )\n", "type": "function"}, {"name": "test_pytest_make_parametrize_id", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2059, "end_line": 2076}, "code_snippet": "    def test_pytest_make_parametrize_id(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val):\n                return str(val * 2)\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func(x):\n                    pass\n                \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_func*0*PASS*\", \"*test_func*2*PASS*\"])\n", "type": "function"}, {"name": "test_param_rejects_usefixtures", "is_method": true, "class_name": "TestParameterize", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "res.stdout.fnmatch_lines"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 410, "end_line": 425}, "code_snippet": "    def test_param_rejects_usefixtures(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize(\"x\", [\n                pytest.param(1, marks=[pytest.mark.usefixtures(\"foo\")]),\n            ])\n            def test_foo(x):\n                pass\n        \"\"\"\n        )\n        res = pytester.runpytest(\"--collect-only\")\n        res.stdout.fnmatch_lines(\n            [\"*test_param_rejects_usefixtures.py:4*\", \"*pytest.param(*\"]\n        )\n", "type": "function"}, {"name": "test_pytest_make_parametrize_id_with_argname", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2078, "end_line": 2101}, "code_snippet": "    def test_pytest_make_parametrize_id_with_argname(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val, argname):\n                return str(val * 2 if argname == 'x' else val * 10)\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func_a(x):\n                    pass\n\n                @pytest.mark.parametrize(\"y\", [1])\n                def test_func_b(y):\n                    pass\n                \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_func_a*0*PASS*\", \"*test_func_a*2*PASS*\", \"*test_func_b*10*PASS*\"]\n        )\n", "type": "function"}, {"name": "test_parametrize_with_mark", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitems"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 560, "end_line": 579}, "code_snippet": "    def test_parametrize_with_mark(self, pytester: Pytester) -> None:\n        items = pytester.getitems(\n            \"\"\"\n            import pytest\n            @pytest.mark.foo\n            @pytest.mark.parametrize('arg', [\n                1,\n                pytest.param(2, marks=[pytest.mark.baz, pytest.mark.bar])\n            ])\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        keywords = [item.keywords for item in items]\n        assert (\n            \"foo\" in keywords[0]\n            and \"bar\" not in keywords[0]\n            and \"baz\" not in keywords[0]\n        )\n        assert \"foo\" in keywords[1] and \"bar\" in keywords[1] and \"baz\" in keywords[1]\n", "type": "function"}, {"name": "test_select_based_on_mark", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "rec.listoutcomes", "len", "len", "len"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1873, "end_line": 1890}, "code_snippet": "    def test_select_based_on_mark(self, pytester: Pytester) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(2, 3, marks=pytest.mark.foo),\n                (3, 4),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        pytester.makepyfile(s)\n        rec = pytester.inline_run(\"-m\", \"foo\")\n        passed, skipped, fail = rec.listoutcomes()\n        assert len(passed) == 1\n        assert len(skipped) == 0\n        assert len(fail) == 0\n", "type": "function"}, {"name": "test_parameterset_for_parametrize_bad_markname", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytest.raises", "test_parameterset_for_parametrize_marks"], "code_location": {"file": "test_mark.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1077, "end_line": 1079}, "code_snippet": "def test_parameterset_for_parametrize_bad_markname(pytester: Pytester) -> None:\n    with pytest.raises(pytest.UsageError):\n        test_parameterset_for_parametrize_marks(pytester, \"bad\")\n", "type": "function"}, {"name": "test_simple_mark", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.getitems", "len"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1852, "end_line": 1871}, "code_snippet": "    def test_simple_mark(self, pytester: Pytester) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.foo\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.bar),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        items = pytester.getitems(s)\n        assert len(items) == 3\n        for item in items:\n            assert \"foo\" in item.keywords\n        assert \"bar\" not in items[0].keywords\n        assert \"bar\" in items[1].keywords\n        assert \"bar\" not in items[2].keywords\n", "type": "function"}, {"name": "test_parametrize_skip", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 673, "end_line": 686}, "code_snippet": "    def test_parametrize_skip(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.skip('')\n\n            @pytest.mark.parametrize('x', [0, 1, pytest.param(2, marks=m)])\n            def test_skip(x):\n                assert x < 2\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed, 1 skipped in *\"])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 2.9771063327789307}
{"question": "Why does Pytest implement parallel test execution for performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements parallel test execution for performance optimization to address the need for faster test execution in large test suites: 1) Parallel execution allows multiple tests to run simultaneously, reducing total test execution time by utilizing multiple CPU cores and processes, 2) Large test suites can take significant time to complete sequentially, making parallel execution essential for maintaining fast feedback cycles in development workflows, 3) Modern hardware with multiple CPU cores provides the capability to run tests in parallel, and pytest leverages this through plugins like pytest-xdist, 4) Parallel execution is particularly beneficial for I/O-bound tests that spend time waiting for external resources, allowing CPU-bound tests to run concurrently, 5) CI/CD pipelines benefit from faster test execution, reducing build times and improving developer productivity, 6) Parallel execution helps distribute the computational load across multiple processes, preventing single-process bottlenecks, 7) Test isolation is maintained through process-based parallelism rather than threading, avoiding issues with shared state and GIL limitations, 8) Parallel execution can be configured to match available system resources, optimizing performance for different environments, 9) Large test suites with thousands of tests can see dramatic performance improvements when executed in parallel, 10) Parallel execution supports different distribution strategies (load balancing, round-robin) to optimize resource utilization, 11) The pytest-xdist plugin provides sophisticated parallel execution capabilities including worker management and result collection, 12) Parallel execution enables better resource utilization in cloud and containerized environments where multiple cores are available.", "score": null, "retrieved_content": [{"name": "test_xdist_normal", "is_method": true, "class_name": "TestProgressOutputStyle", "parameters": ["self", "many_tests_files", "pytester", "monkeypatch"], "calls": ["pytest.importorskip", "monkeypatch.delenv", "pytester.runpytest", "output.stdout.re_match_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2311, "end_line": 2317}, "code_snippet": "    def test_xdist_normal(\n        self, many_tests_files, pytester: Pytester, monkeypatch\n    ) -> None:\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = pytester.runpytest(\"-n2\")\n        output.stdout.re_match_lines([r\"\\.{20} \\s+ \\[100%\\]\"])\n", "type": "function"}, {"name": "test_runs_twice_xdist", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch", "run_and_parse"], "calls": ["pytest.importorskip", "monkeypatch.delenv", "pytester.makepyfile", "run_and_parse", "result.stdout.no_fnmatch_line", "dom.find_by_tag"], "code_location": {"file": "test_junitxml.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1477, "end_line": 1492}, "code_snippet": "def test_runs_twice_xdist(\n    pytester: Pytester, monkeypatch: MonkeyPatch, run_and_parse: RunAndParse\n) -> None:\n    pytest.importorskip(\"xdist\")\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n    f = pytester.makepyfile(\n        \"\"\"\n        def test_pass():\n            pass\n    \"\"\"\n    )\n\n    result, dom = run_and_parse(f, \"--dist\", \"each\", \"--tx\", \"2*popen\")\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    first, second = (x[\"classname\"] for x in dom.find_by_tag(\"testcase\"))\n    assert first == second\n", "type": "function"}, {"name": "many_tests_files", "is_method": true, "class_name": "TestProgressOutputStyle", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2093, "end_line": 2110}, "code_snippet": "    def many_tests_files(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            test_bar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(10))\n                def test_bar(i): pass\n            \"\"\",\n            test_foo=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_foo(i): pass\n            \"\"\",\n            test_foobar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_foobar(i): pass\n            \"\"\",\n        )\n", "type": "function"}, {"name": "test_xdist_verbose", "is_method": true, "class_name": "TestProgressOutputStyle", "parameters": ["self", "many_tests_files", "pytester", "monkeypatch"], "calls": ["pytest.importorskip", "monkeypatch.delenv", "pytester.runpytest", "output.stdout.re_match_lines_random", "output.stdout.fnmatch_lines_random", "line.translate"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2333, "end_line": 2361}, "code_snippet": "    def test_xdist_verbose(\n        self, many_tests_files, pytester: Pytester, monkeypatch\n    ) -> None:\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = pytester.runpytest(\"-n2\", \"-v\")\n        output.stdout.re_match_lines_random(\n            [\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_bar.py::test_bar\\[1\\]\",\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_foo.py::test_foo\\[1\\]\",\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_foobar.py::test_foobar\\[1\\]\",\n            ]\n        )\n        output.stdout.fnmatch_lines_random(\n            [\n                line.translate(TRANS_FNMATCH)\n                for line in [\n                    \"test_bar.py::test_bar[0] \",\n                    \"test_foo.py::test_foo[0] \",\n                    \"test_foobar.py::test_foobar[0] \",\n                    \"[gw?] [  5%] PASSED test_*[?] \",\n                    \"[gw?] [ 10%] PASSED test_*[?] \",\n                    \"[gw?] [ 55%] PASSED test_*[?] \",\n                    \"[gw?] [ 60%] PASSED test_*[?] \",\n                    \"[gw?] [ 95%] PASSED test_*[?] \",\n                    \"[gw?] [100%] PASSED test_*[?] \",\n                ]\n            ]\n        )\n", "type": "function"}, {"name": "test_xdist_normal", "is_method": true, "class_name": "TestProgressWithTeardown", "parameters": ["self", "many_files", "pytester", "monkeypatch"], "calls": ["pytest.importorskip", "monkeypatch.delenv", "pytester.runpytest", "output.stdout.re_match_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2497, "end_line": 2501}, "code_snippet": "    def test_xdist_normal(self, many_files, pytester: Pytester, monkeypatch) -> None:\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = pytester.runpytest(\"-n2\")\n        output.stdout.re_match_lines([r\"[\\.E]{40} \\s+ \\[100%\\]\"])\n", "type": "function"}, {"name": "test_xdist_times", "is_method": true, "class_name": "TestProgressOutputStyle", "parameters": ["self", "many_tests_files", "pytester", "monkeypatch"], "calls": ["pytest.importorskip", "monkeypatch.delenv", "pytester.makeini", "pytester.runpytest", "output.stdout.re_match_lines_random"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2363, "end_line": 2381}, "code_snippet": "    def test_xdist_times(\n        self, many_tests_files, pytester: Pytester, monkeypatch\n    ) -> None:\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        pytester.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style = times\n        \"\"\"\n        )\n        output = pytester.runpytest(\"-n2\", \"-v\")\n        output.stdout.re_match_lines_random(\n            [\n                r\"\\[gw\\d\\] \\d{1,3}[\\.[a-z\\ ]{1,2}\\d{0,3}\\w{1,2} PASSED test_bar.py::test_bar\\[1\\]\",\n                r\"\\[gw\\d\\] \\d{1,3}[\\.[a-z\\ ]{1,2}\\d{0,3}\\w{1,2} PASSED test_foo.py::test_foo\\[1\\]\",\n                r\"\\[gw\\d\\] \\d{1,3}[\\.[a-z\\ ]{1,2}\\d{0,3}\\w{1,2} PASSED test_foobar.py::test_foobar\\[1\\]\",\n            ]\n        )\n", "type": "function"}, {"name": "pytest_runtestloop", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["enumerate", "session.Interrupted", "item.config.hook.pytest_runtest_protocol", "session.Failed", "session.Interrupted", "len"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 356, "end_line": 372}, "code_snippet": "def pytest_runtestloop(session: Session) -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            f\"{session.testsfailed} error{'s' if session.testsfailed != 1 else ''} during collection\"\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n", "type": "function"}, {"name": "many_files", "is_method": true, "class_name": "TestProgressWithTeardown", "parameters": ["self", "pytester", "contest_with_teardown_fixture"], "calls": ["pytester.makepyfile"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2428, "end_line": 2442}, "code_snippet": "    def many_files(self, pytester: Pytester, contest_with_teardown_fixture) -> None:\n        pytester.makepyfile(\n            test_bar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_bar(fail_teardown, i):\n                    pass\n            \"\"\",\n            test_foo=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(15))\n                def test_foo(fail_teardown, i):\n                    pass\n            \"\"\",\n        )\n", "type": "function"}, {"name": "test_teardown_many_verbose", "is_method": true, "class_name": "TestProgressWithTeardown", "parameters": ["self", "pytester", "many_files", "color_mapping"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines", "color_mapping.format_for_fnmatch"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 2480, "end_line": 2495}, "code_snippet": "    def test_teardown_many_verbose(\n        self, pytester: Pytester, many_files, color_mapping\n    ) -> None:\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            color_mapping.format_for_fnmatch(\n                [\n                    \"test_bar.py::test_bar[0] PASSED  * [  5%]\",\n                    \"test_bar.py::test_bar[0] ERROR   * [  5%]\",\n                    \"test_bar.py::test_bar[4] PASSED  * [ 25%]\",\n                    \"test_foo.py::test_foo[14] PASSED * [100%]\",\n                    \"test_foo.py::test_foo[14] ERROR  * [100%]\",\n                    \"=* 20 passed, 20 errors in *\",\n                ]\n            )\n        )\n", "type": "function"}, {"name": "pytest_runtestloop", "is_method": true, "class_name": "LoggingPlugin", "parameters": ["self", "session"], "calls": ["hookimpl", "self._log_cli_enabled", "catching_logs", "self._config.get_verbosity", "catching_logs"], "code_location": {"file": "logging.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 791, "end_line": 801}, "code_snippet": "    def pytest_runtestloop(self, session: Session) -> Generator[None, object, object]:\n        if session.config.option.collectonly:\n            return (yield)\n\n        if self._log_cli_enabled() and self._config.get_verbosity() < 1:\n            # The verbose flag is needed to avoid messy test progress output.\n            self._config.option.verbose = 1\n\n        with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n            with catching_logs(self.log_file_handler, level=self.log_file_level):\n                return (yield)  # Run all the tests.\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.0113365650177}
{"question": "Why does Pytest use incremental test discovery for performance improvement?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest uses incremental test discovery for performance improvement to optimize test execution in large test suites and development workflows: 1) Incremental discovery allows pytest to skip tests that have already passed in previous runs, reducing redundant test execution and improving overall performance, 2) The --lf (last-failed) option runs only the tests that failed in the previous run, enabling developers to focus on fixing broken tests quickly, 3) The --ff (failed-first) option runs failed tests first, then previously passed tests, providing faster feedback on critical issues, 4) The --nf (new-first) option prioritizes newly added tests, ensuring new code is tested before running the full suite, 5) Incremental discovery reduces test execution time in development cycles where only a subset of tests need to be run, 6) Caching mechanisms store test results and node IDs to enable intelligent test selection in subsequent runs, 7) The stepwise plugin provides incremental testing for test classes, stopping execution when a test fails to avoid unnecessary test runs, 8) Incremental discovery supports CI/CD pipelines by allowing selective test execution based on code changes, 9) Large test suites benefit significantly from incremental discovery as only relevant tests are executed, 10) The caching system maintains test state across multiple pytest invocations, enabling persistent incremental behavior, 11) Incremental discovery reduces resource consumption by avoiding redundant test setup and teardown operations, 12) The approach improves developer productivity by providing faster feedback loops and reducing wait times for test results.", "score": null, "retrieved_content": [{"name": "test_immediate_initialization_and_incremental_are_the_same", "is_method": true, "class_name": "TestConftestValueAccessGlobal", "parameters": ["self", "basedir"], "calls": ["PytestPluginManager", "conftest._loadconftestmodules", "len", "conftest._loadconftestmodules", "conftest._loadconftestmodules", "len", "len", "len"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 69, "end_line": 95}, "code_snippet": "    def test_immediate_initialization_and_incremental_are_the_same(\n        self, basedir: Path\n    ) -> None:\n        conftest = PytestPluginManager()\n        assert not len(conftest._dirpath2confmods)\n        conftest._loadconftestmodules(\n            basedir,\n            importmode=\"prepend\",\n            rootpath=basedir,\n            consider_namespace_packages=False,\n        )\n        snap1 = len(conftest._dirpath2confmods)\n        assert snap1 == 1\n        conftest._loadconftestmodules(\n            basedir / \"adir\",\n            importmode=\"prepend\",\n            rootpath=basedir,\n            consider_namespace_packages=False,\n        )\n        assert len(conftest._dirpath2confmods) == snap1 + 1\n        conftest._loadconftestmodules(\n            basedir / \"b\",\n            importmode=\"prepend\",\n            rootpath=basedir,\n            consider_namespace_packages=False,\n        )\n        assert len(conftest._dirpath2confmods) == snap1 + 2\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AssertionRewritingHook", "parameters": ["self", "config"], "calls": ["set", "config.getini"], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 68, "end_line": 82}, "code_snippet": "    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session: Session | None = None\n        self._rewritten_names: dict[str, Path] = {}\n        self._must_rewrite: set[str] = set()\n        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n        # which might result in infinite recursion (#3506)\n        self._writing_pyc = False\n        self._basenames_to_check_rewrite = {\"conftest\"}\n        self._marked_for_rewrite_cache: dict[str, bool] = {}\n        self._session_paths_checked = False\n", "type": "function"}, {"name": "test_does_not_eagerly_collect_packages", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.mkpydir", "write_text", "pytester.runpytest", "pydir.joinpath"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1568, "end_line": 1573}, "code_snippet": "def test_does_not_eagerly_collect_packages(pytester: Pytester) -> None:\n    pytester.makepyfile(\"def test(): pass\")\n    pydir = pytester.mkpydir(\"foopkg\")\n    pydir.joinpath(\"__init__.py\").write_text(\"assert False\", encoding=\"utf-8\")\n    result = pytester.runpytest()\n    assert result.ret == ExitCode.OK\n", "type": "function"}, {"name": "test_collect_pkg_init_and_file_in_args", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.mkdir", "subdir.joinpath", "init.write_text", "subdir.joinpath", "p.write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1475, "end_line": 1509}, "code_snippet": "def test_collect_pkg_init_and_file_in_args(pytester: Pytester) -> None:\n    subdir = pytester.mkdir(\"sub\")\n    init = subdir.joinpath(\"__init__.py\")\n    init.write_text(\"def test_init(): pass\", encoding=\"utf-8\")\n    p = subdir.joinpath(\"test_file.py\")\n    p.write_text(\"def test_file(): pass\", encoding=\"utf-8\")\n\n    # Just the package directory, the __init__.py module is filtered out.\n    result = pytester.runpytest(\"-v\", subdir)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*1 passed in*\",\n        ]\n    )\n\n    # But it's included if specified directly.\n    result = pytester.runpytest(\"-v\", init, p)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/__init__.py::test_init PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )\n\n    # Or if the pattern allows it.\n    result = pytester.runpytest(\"-v\", \"-o\", \"python_files=*.py\", subdir)\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/__init__.py::test_init PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_collection_collect_only_live_logging", "is_method": false, "class_name": null, "parameters": ["pytester", "verbose"], "calls": ["pytest.mark.parametrize", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "expected_lines.extend", "result.stdout.no_fnmatch_line", "expected_lines.extend", "result.stdout.no_fnmatch_line", "expected_lines.extend"], "code_location": {"file": "test_reporting.py", "path": "/data3/pwh/swebench-repos/pytest/testing/logging", "start_line": 990, "end_line": 1022}, "code_snippet": "def test_collection_collect_only_live_logging(pytester: Pytester, verbose: str) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def test_simple():\n            pass\n    \"\"\"\n    )\n\n    result = pytester.runpytest(\"--collect-only\", \"--log-cli-level=INFO\", verbose)\n\n    expected_lines = []\n\n    if not verbose:\n        expected_lines.extend(\n            [\n                \"*collected 1 item*\",\n                \"*<Module test_collection_collect_only_live_logging.py>*\",\n                \"*1 test collected*\",\n            ]\n        )\n    elif verbose == \"-q\":\n        result.stdout.no_fnmatch_line(\"*collected 1 item**\")\n        expected_lines.extend(\n            [\n                \"*test_collection_collect_only_live_logging.py::test_simple*\",\n                \"1 test collected in [0-9].[0-9][0-9]s\",\n            ]\n        )\n    elif verbose == \"-qq\":\n        result.stdout.no_fnmatch_line(\"*collected 1 item**\")\n        expected_lines.extend([\"*test_collection_collect_only_live_logging.py: 1*\"])\n\n    result.stdout.fnmatch_lines(expected_lines)\n", "type": "function"}, {"name": "test_generate_tests_only_done_in_subdir", "is_method": true, "class_name": "TestMetafuncFunctional", "parameters": ["self", "pytester"], "calls": ["pytester.mkpydir", "pytester.mkpydir", "write_text", "write_text", "write_text", "write_text", "pytester.runpytest", "result.assert_outcomes", "textwrap.dedent", "textwrap.dedent", "sub1.joinpath", "sub2.joinpath", "sub1.joinpath", "sub2.joinpath"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1502, "end_line": 1530}, "code_snippet": "    def test_generate_tests_only_done_in_subdir(self, pytester: Pytester) -> None:\n        sub1 = pytester.mkpydir(\"sub1\")\n        sub2 = pytester.mkpydir(\"sub2\")\n        sub1.joinpath(\"conftest.py\").write_text(\n            textwrap.dedent(\n                \"\"\"\\\n                def pytest_generate_tests(metafunc):\n                    assert metafunc.function.__name__ == \"test_1\"\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        sub2.joinpath(\"conftest.py\").write_text(\n            textwrap.dedent(\n                \"\"\"\\\n                def pytest_generate_tests(metafunc):\n                    assert metafunc.function.__name__ == \"test_2\"\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        sub1.joinpath(\"test_in_sub1.py\").write_text(\n            \"def test_1(): pass\", encoding=\"utf-8\"\n        )\n        sub2.joinpath(\"test_in_sub2.py\").write_text(\n            \"def test_2(): pass\", encoding=\"utf-8\"\n        )\n        result = pytester.runpytest(\"--keep-duplicates\", \"-v\", \"-s\", sub1, sub2, sub1)\n        result.assert_outcomes(passed=3)\n", "type": "function"}, {"name": "test_pyargs_collection_tree", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["site_packages.mkdir", "monkeypatch.syspath_prepend", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "monkeypatch.chdir", "pytester.runpytest", "result.stdout.fnmatch_lines", "tempfile.gettempdir"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1783, "end_line": 1825}, "code_snippet": "def test_pyargs_collection_tree(pytester: Pytester, monkeypatch: MonkeyPatch) -> None:\n    \"\"\"When using `--pyargs`, the collection tree of a pyargs collection\n    argument should only include parents in the import path, not up to confcutdir.\n\n    Regression test for #11904.\n    \"\"\"\n    site_packages = pytester.path / \"venv/lib/site-packages\"\n    site_packages.mkdir(parents=True)\n    monkeypatch.syspath_prepend(site_packages)\n    pytester.makepyfile(\n        **{\n            \"venv/lib/site-packages/pkg/__init__.py\": \"\",\n            \"venv/lib/site-packages/pkg/sub/__init__.py\": \"\",\n            \"venv/lib/site-packages/pkg/sub/test_it.py\": \"def test(): pass\",\n        }\n    )\n\n    result = pytester.runpytest(\"--pyargs\", \"--collect-only\", \"pkg.sub.test_it\")\n    assert result.ret == ExitCode.OK\n    result.stdout.fnmatch_lines(\n        [\n            \"<Package venv/lib/site-packages/pkg>\",\n            \"  <Package sub>\",\n            \"    <Module test_it.py>\",\n            \"      <Function test>\",\n        ],\n        consecutive=True,\n    )\n\n    # Now with an unrelated rootdir with unrelated files.\n    monkeypatch.chdir(tempfile.gettempdir())\n\n    result = pytester.runpytest(\"--pyargs\", \"--collect-only\", \"pkg.sub.test_it\")\n    assert result.ret == ExitCode.OK\n    result.stdout.fnmatch_lines(\n        [\n            \"<Package *pkg>\",\n            \"  <Package sub>\",\n            \"    <Module test_it.py>\",\n            \"      <Function test>\",\n        ],\n        consecutive=True,\n    )\n", "type": "function"}, {"name": "pytest_collection", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["session.perform_collect"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 352, "end_line": 353}, "code_snippet": "def pytest_collection(session: Session) -> None:\n    session.perform_collect()\n", "type": "function"}, {"name": "test_collect_two_commandline_args", "is_method": true, "class_name": "TestSession", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.mkpydir", "pytester.mkpydir", "aaa.joinpath", "shutil.copy", "bbb.joinpath", "p.replace", "pytester.inline_genitems", "pprint.pprint", "hookrec.assert_contains", "len"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 616, "end_line": 639}, "code_snippet": "    def test_collect_two_commandline_args(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\"def test_func(): pass\")\n        aaa = pytester.mkpydir(\"aaa\")\n        bbb = pytester.mkpydir(\"bbb\")\n        test_aaa = aaa.joinpath(\"test_aaa.py\")\n        shutil.copy(p, test_aaa)\n        test_bbb = bbb.joinpath(\"test_bbb.py\")\n        p.replace(test_bbb)\n\n        id = \".\"\n\n        items, hookrec = pytester.inline_genitems(id)\n        assert len(items) == 2\n        pprint.pprint(hookrec.calls)\n        hookrec.assert_contains(\n            [\n                (\"pytest_collectstart\", \"collector.path == test_aaa\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid == 'aaa/test_aaa.py'\"),\n                (\"pytest_collectstart\", \"collector.path == test_bbb\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid == 'bbb/test_bbb.py'\"),\n            ]\n        )\n", "type": "function"}, {"name": "test_ignored_certain_directories", "is_method": true, "class_name": "TestCollectFS", "parameters": ["self", "pytester"], "calls": ["ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "tmp_path.rglob", "pytester.runpytest", "result.stdout.str", "x.write_text"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 138, "end_line": 154}, "code_snippet": "    def test_ignored_certain_directories(self, pytester: Pytester) -> None:\n        tmp_path = pytester.path\n        ensure_file(tmp_path / \"build\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"dist\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"_darcs\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"CVS\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"{arch}\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \".whatever\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \".bzr\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"normal\" / \"test_found.py\")\n        for x in tmp_path.rglob(\"test_*.py\"):\n            x.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n\n        result = pytester.runpytest(\"--collect-only\")\n        s = result.stdout.str()\n        assert \"test_notfound\" not in s\n        assert \"test_found\" in s\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.056246042251587}
{"question": "Why does Pytest use a session-based test execution model instead of individual test isolation?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest uses a session-based test execution model for three main reasons: 1) Performance - reuses expensive setup operations and cached fixtures across tests, reducing execution time for large test suites; 2) Fixture System - enables fixture sharing and dependency injection with different scopes (function, class, module, session), which is core to Pytest's design; 3) Plugin Architecture - allows plugins to maintain state and interact with the test lifecycle through session-level hooks and context management. The session model balances test isolation with efficiency, enabling Pytest's powerful features while maintaining good performance.", "score": null, "retrieved_content": [{"name": "test_scope_session", "is_method": true, "class_name": "TestFixtureMarker", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2438, "end_line": 2460}, "code_snippet": "    def test_scope_session(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"module\")\n            def arg():\n                values.append(1)\n                return 1\n\n            def test_1(arg):\n                assert arg == 1\n            def test_2(arg):\n                assert arg == 1\n                assert len(values) == 1\n            class TestClass(object):\n                def test3(self, arg):\n                    assert arg == 1\n                    assert len(values) == 1\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=3)\n", "type": "function"}, {"name": "test_scope_module_uses_session", "is_method": true, "class_name": "TestFixtureMarker", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2538, "end_line": 2560}, "code_snippet": "    def test_scope_module_uses_session(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"module\")\n            def arg():\n                values.append(1)\n                return 1\n\n            def test_1(arg):\n                assert arg == 1\n            def test_2(arg):\n                assert arg == 1\n                assert len(values) == 1\n            class TestClass(object):\n                def test3(self, arg):\n                    assert arg == 1\n                    assert len(values) == 1\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=3)\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["SetupState"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 106, "end_line": 107}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._setupstate = SetupState()\n", "type": "function"}, {"name": "test_hook_proxy", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 745, "end_line": 764}, "code_snippet": "def test_hook_proxy(pytester: Pytester) -> None:\n    \"\"\"Session's gethookproxy() would cache conftests incorrectly (#2016).\n    It was decided to remove the cache altogether.\n    \"\"\"\n    pytester.makepyfile(\n        **{\n            \"root/demo-0/test_foo1.py\": \"def test1(): pass\",\n            \"root/demo-a/test_foo2.py\": \"def test1(): pass\",\n            \"root/demo-a/conftest.py\": \"\"\"\\\n            def pytest_ignore_collect(collection_path, config):\n                return True\n            \"\"\",\n            \"root/demo-b/test_foo3.py\": \"def test1(): pass\",\n            \"root/demo-c/test_foo4.py\": \"def test1(): pass\",\n        }\n    )\n    result = pytester.runpytest()\n    result.stdout.fnmatch_lines(\n        [\"*test_foo1.py*\", \"*test_foo3.py*\", \"*test_foo4.py*\", \"*3 passed*\"]\n    )\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["request", "tmp_path_factory", "monkeypatch"], "calls": ["Pytester"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 477, "end_line": 490}, "code_snippet": "def pytester(\n    request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n) -> Pytester:\n    \"\"\"\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.\n    \"\"\"\n    return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)\n", "type": "function"}, {"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["FixtureManager"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 119, "end_line": 120}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n", "type": "function"}, {"name": "Pytester", "docstring": "Facilities to write tests/configuration files, execute pytest in isolation, and match\nagainst expected output, perfect for black-box testing of pytest plugins.\n\nIt attempts to isolate the test run from external factors as much as possible, modifying\nthe current working directory to :attr:`path` and environment variables during initialization.", "methods": ["__init__", "path", "__repr__", "_finalize", "__take_sys_modules_snapshot", "make_hook_recorder", "chdir", "_makefile", "makefile", "makeconftest", "makeini", "getinicfg", "makepyprojecttoml", "makepyfile", "maketxtfile", "syspathinsert", "mkdir", "mkpydir", "copy_example", "getnode", "getpathnode", "genitems", "runitem", "inline_runsource", "inline_genitems", "inline_run", "runpytest_inprocess", "runpytest", "_ensure_basetemp", "parseconfig", "parseconfigure", "getitem", "getitems", "getmodulecol", "collect_by_name", "popen", "run", "_dump_lines", "_getpytestargs", "runpython", "runpython_c", "runpytest_subprocess", "spawn_pytest", "spawn"], "attributes": ["__test__"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 649, "end_line": 1536}, "type": "class"}, {"name": "test_scope_session_exc", "is_method": true, "class_name": "TestFixtureMarker", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2462, "end_line": 2481}, "code_snippet": "    def test_scope_session_exc(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"session\")\n            def fix():\n                values.append(1)\n                pytest.skip('skipping')\n\n            def test_1(fix):\n                pass\n            def test_2(fix):\n                pass\n            def test_last():\n                assert values == [1]\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(skipped=2, passed=1)\n", "type": "function"}, {"name": "pytest_sessionstart", "is_method": true, "class_name": "StepwisePlugin", "parameters": ["self", "session"], "calls": [], "code_location": {"file": "stepwise.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 126, "end_line": 127}, "code_snippet": "    def pytest_sessionstart(self, session: Session) -> None:\n        self.session = session\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.0588812828063965}
{"question": "How does Pytest's fixture system work?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's fixture system works through a comprehensive dependency injection and lifecycle management system: 1) Fixture definition using the @pytest.fixture decorator that marks functions as fixture factories, with configurable scope, parameters, and autouse behavior, 2) FixtureManager class that serves as the central registry storing all fixture definitions in _arg2fixturedefs mapping fixture names to FixtureDef objects, 3) Fixture discovery during collection through parsefactories() method that scans modules and plugins for fixture definitions, 4) Dependency resolution through getfixtureinfo() method that analyzes test functions to identify required fixtures and their dependencies, 5) Fixture execution through pytest_fixture_setup hook that calls fixture functions and manages their lifecycle, 6) Scope management with five levels (function, class, module, package, session) that determine when fixtures are created and destroyed, 7) Caching mechanism where fixture instances are stored in FixtureDef.cached_result and reused within their scope, 8) Parameter support through params attribute that allows fixtures to be parametrized and run multiple times, 9) Teardown/cleanup through yield statements in fixtures that execute cleanup code regardless of test outcome, 10) Autouse fixtures that are automatically activated for all tests in their scope without explicit requests, 11) FixtureRequest class that provides access to test context and parameter values during fixture execution, 12) Integration with the plugin system where fixtures can be defined in plugins, conftest files, or test modules.", "score": null, "retrieved_content": [{"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "pytester", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1685, "end_line": 1703}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"conftest\"\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_fixture_dependency", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "touch", "pytester.mkdir", "touch", "write_text", "sub.joinpath", "subsub.mkdir", "touch", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "textwrap.dedent", "pytester.path.joinpath", "sub.joinpath", "sub.joinpath", "subsub.joinpath", "subsub.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 466, "end_line": 510}, "code_snippet": "def test_fixture_dependency(pytester: Pytester) -> None:\n    pytester.makeconftest(\"\")\n    pytester.path.joinpath(\"__init__.py\").touch()\n    sub = pytester.mkdir(\"sub\")\n    sub.joinpath(\"__init__.py\").touch()\n    sub.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    subsub = sub.joinpath(\"subsub\")\n    subsub.mkdir()\n    subsub.joinpath(\"__init__.py\").touch()\n    subsub.joinpath(\"test_bar.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    result = pytester.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_show_fixtures", "is_method": true, "class_name": "TestShowFixtures", "parameters": ["self", "pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3580, "end_line": 3589}, "code_snippet": "    def test_show_fixtures(self, pytester: Pytester) -> None:\n        result = pytester.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmp_path_factory [[]session scope[]] -- .../_pytest/tmpdir.py:*\",\n                \"*for the test session*\",\n                \"tmp_path -- .../_pytest/tmpdir.py:*\",\n                \"*temporary directory*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_capture_and_fixtures", "is_method": true, "class_name": "TestPerTestCapturing", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 155, "end_line": 179}, "code_snippet": "    def test_capture_and_fixtures(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def setup_module(mod):\n                print(\"setup module\")\n            def setup_function(function):\n                print(\"setup \" + function.__name__)\n            def test_func1():\n                print(\"in func1\")\n                assert 0\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = pytester.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"setup module*\",\n                \"setup test_func1*\",\n                \"in func1*\",\n                \"setup test_func2*\",\n                \"in func2*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_pytestconfig_is_session_scoped", "is_method": false, "class_name": null, "parameters": [], "calls": ["getfixturemarker"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 266, "end_line": 271}, "code_snippet": "def test_pytestconfig_is_session_scoped() -> None:\n    from _pytest.fixtures import pytestconfig\n\n    marker = getfixturemarker(pytestconfig)\n    assert marker is not None\n    assert marker.scope == \"session\"\n", "type": "function"}, {"name": "test_package_fixture_complex", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.syspathinsert", "pytester.mkdir", "write_text", "write_text", "write_text", "pytester.inline_run", "reprec.assertoutcome", "textwrap.dedent", "textwrap.dedent", "package.joinpath", "package.joinpath", "package.joinpath"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1874, "end_line": 1915}, "code_snippet": "    def test_package_fixture_complex(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            __init__=\"\"\"\\\n            values = []\n        \"\"\"\n        )\n        pytester.syspathinsert(pytester.path.name)\n        package = pytester.mkdir(\"package\")\n        package.joinpath(\"__init__.py\").write_text(\"\", encoding=\"utf-8\")\n        package.joinpath(\"conftest.py\").write_text(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                from .. import values\n                @pytest.fixture(scope=\"package\")\n                def one():\n                    values.append(\"package\")\n                    yield values\n                    values.pop()\n                @pytest.fixture(scope=\"package\", autouse=True)\n                def two():\n                    values.append(\"package-auto\")\n                    yield values\n                    values.pop()\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        package.joinpath(\"test_x.py\").write_text(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def test_package_autouse():\n                    assert values == [\"package-auto\"]\n                def test_package(one):\n                    assert values == [\"package-auto\", \"package\"]\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=2)\n", "type": "function"}, {"name": "test_usefixtures_marker", "is_method": true, "class_name": "TestFixtureUsages", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1429, "end_line": 1452}, "code_snippet": "    def test_usefixtures_marker(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n\n            @pytest.fixture(scope=\"class\")\n            def myfix(request):\n                request.cls.hello = \"world\"\n                values.append(1)\n\n            class TestClass(object):\n                def test_one(self):\n                    assert self.hello == \"world\"\n                    assert len(values) == 1\n                def test_two(self):\n                    assert self.hello == \"world\"\n                    assert len(values) == 1\n            pytest.mark.usefixtures(\"myfix\")(TestClass)\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=2)\n", "type": "function"}, {"name": "test_pytest_fixture_setup_and_post_finalizer_hook", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4144, "end_line": 4184}, "code_snippet": "def test_pytest_fixture_setup_and_post_finalizer_hook(pytester: Pytester) -> None:\n    pytester.makeconftest(\n        \"\"\"\n        def pytest_fixture_setup(fixturedef, request):\n            print('ROOT setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        def pytest_fixture_post_finalizer(fixturedef, request):\n            print('ROOT finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n    \"\"\"\n    )\n    pytester.makepyfile(\n        **{\n            \"tests/conftest.py\": \"\"\"\n            def pytest_fixture_setup(fixturedef, request):\n                print('TESTS setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n            def pytest_fixture_post_finalizer(fixturedef, request):\n                print('TESTS finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        \"\"\",\n            \"tests/test_hooks.py\": \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def my_fixture():\n                return 'some'\n\n            def test_func(my_fixture):\n                print('TEST test_func')\n                assert my_fixture == 'some'\n        \"\"\",\n        }\n    )\n    result = pytester.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*TESTS setup hook called for my_fixture from test_func*\",\n            \"*ROOT setup hook called for my_fixture from test_func*\",\n            \"*TEST test_func*\",\n            \"*TESTS finalizer hook called for my_fixture from test_func*\",\n            \"*ROOT finalizer hook called for my_fixture from test_func*\",\n        ]\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.8581764698028564}
{"question": "Where does the configuration loading flow from file discovery to test execution?", "answer": null, "relative_code_list": null, "ground_truth": "The configuration loading flow in pytest follows a structured sequence from file discovery to test execution: 1) Configuration file discovery begins with locate_config() function which searches for configuration files in a specific order: pytest.ini, .pytest.ini, pyproject.toml, tox.ini, and setup.cfg, 2) Root directory determination occurs through get_common_ancestor() which finds the common ancestor directory of specified test paths or uses current working directory as fallback, 3) Configuration file parsing happens through load_config_dict_from_file() which reads and parses the selected configuration file format (INI, TOML, or CFG), 4) Configuration object creation occurs in Config.__init__() which initializes the configuration with parsed values and sets up the plugin manager, 5) Plugin loading phase begins with get_config() which loads essential plugins (mark, main, runner, fixtures, helpconfig) and default plugins, 6) Command-line argument parsing happens through Parser.parse() which processes command-line options and overrides configuration file settings, 7) Configuration validation occurs where settings are validated and any conflicts between command-line and file settings are resolved, 8) Plugin configuration phase happens through pytest_configure hook where plugins can access and modify configuration settings, 9) Test discovery configuration is applied where settings like testpaths, python_files, python_classes, and python_functions influence test collection, 10) Execution configuration is established where settings like addopts, maxfail, and verbosity affect test execution behavior, 11) Configuration integration occurs where the Config object provides access to all settings throughout the test execution process, 12) The entire configuration flow is coordinated through the Config class which serves as the central configuration object accessible to all pytest components and plugins.", "score": null, "retrieved_content": [{"name": "pytest_load_initial_conftests", "is_method": true, "class_name": "Config", "parameters": ["self", "early_config"], "calls": ["hookimpl", "early_config._decide_args", "self.pluginmanager._set_initial_conftests", "early_config.getini", "early_config.getini"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 1215, "end_line": 1239}, "code_snippet": "    def pytest_load_initial_conftests(self, early_config: Config) -> None:\n        # We haven't fully parsed the command line arguments yet, so\n        # early_config.args it not set yet. But we need it for\n        # discovering the initial conftests. So \"pre-run\" the logic here.\n        # It will be done for real in `parse()`.\n        args, args_source = early_config._decide_args(\n            args=early_config.known_args_namespace.file_or_dir,\n            pyargs=early_config.known_args_namespace.pyargs,\n            testpaths=early_config.getini(\"testpaths\"),\n            invocation_dir=early_config.invocation_params.dir,\n            rootpath=early_config.rootpath,\n            warn=False,\n        )\n        self.pluginmanager._set_initial_conftests(\n            args=args,\n            pyargs=early_config.known_args_namespace.pyargs,\n            noconftest=early_config.known_args_namespace.noconftest,\n            rootpath=early_config.rootpath,\n            confcutdir=early_config.known_args_namespace.confcutdir,\n            invocation_dir=early_config.invocation_params.dir,\n            importmode=early_config.known_args_namespace.importmode,\n            consider_namespace_packages=early_config.getini(\n                \"consider_namespace_packages\"\n            ),\n        )\n", "type": "function"}, {"name": "_try_load_conftest", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self", "anchor", "importmode", "rootpath"], "calls": ["self._loadconftestmodules", "anchor.is_dir", "anchor.glob", "x.is_dir", "self._loadconftestmodules"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 613, "end_line": 636}, "code_snippet": "    def _try_load_conftest(\n        self,\n        anchor: pathlib.Path,\n        importmode: str | ImportMode,\n        rootpath: pathlib.Path,\n        *,\n        consider_namespace_packages: bool,\n    ) -> None:\n        self._loadconftestmodules(\n            anchor,\n            importmode,\n            rootpath,\n            consider_namespace_packages=consider_namespace_packages,\n        )\n        # let's also consider test* subdirs\n        if anchor.is_dir():\n            for x in anchor.glob(\"test*\"):\n                if x.is_dir():\n                    self._loadconftestmodules(\n                        x,\n                        importmode,\n                        rootpath,\n                        consider_namespace_packages=consider_namespace_packages,\n                    )\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AssertionRewritingHook", "parameters": ["self", "config"], "calls": ["set", "config.getini"], "code_location": {"file": "rewrite.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/assertion", "start_line": 68, "end_line": 82}, "code_snippet": "    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session: Session | None = None\n        self._rewritten_names: dict[str, Path] = {}\n        self._must_rewrite: set[str] = set()\n        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n        # which might result in infinite recursion (#3506)\n        self._writing_pyc = False\n        self._basenames_to_check_rewrite = {\"conftest\"}\n        self._marked_for_rewrite_cache: dict[str, bool] = {}\n        self._session_paths_checked = False\n", "type": "function"}, {"name": "test_customized_python_discovery", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeini", "pytester.makepyfile", "p.with_name", "p.rename", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "p.name.replace"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1282, "end_line": 1309}, "code_snippet": "def test_customized_python_discovery(pytester: Pytester) -> None:\n    pytester.makeini(\n        \"\"\"\n        [pytest]\n        python_files=check_*.py\n        python_classes=Check\n        python_functions=check\n    \"\"\"\n    )\n    p = pytester.makepyfile(\n        \"\"\"\n        def check_simple():\n            pass\n        class CheckMyApp(object):\n            def check_meth(self):\n                pass\n    \"\"\"\n    )\n    p2 = p.with_name(p.name.replace(\"test\", \"check\"))\n    p.rename(p2)\n    result = pytester.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines(\n        [\"*check_customized*\", \"*check_simple*\", \"*CheckMyApp*\", \"*check_meth*\"]\n    )\n\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_args_source_testpaths", "is_method": true, "class_name": "TestParseIni", "parameters": ["self", "pytester"], "calls": ["pytester.makeini", "pytester.parseconfig"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 545, "end_line": 553}, "code_snippet": "    def test_args_source_testpaths(self, pytester: Pytester):\n        pytester.makeini(\n            \"\"\"\n            [pytest]\n            testpaths=*\n        \"\"\"\n        )\n        config = pytester.parseconfig()\n        assert config.args_source == Config.ArgsSource.TESTPATHS\n", "type": "function"}, {"name": "pytest_collect_file", "is_method": false, "class_name": null, "parameters": ["parent", "file_path"], "calls": ["file_path.name.startswith", "YamlFile.from_parent"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/doc/en/example/nonpython", "start_line": 7, "end_line": 9}, "code_snippet": "def pytest_collect_file(parent, file_path):\n    if file_path.suffix == \".yaml\" and file_path.name.startswith(\"test\"):\n        return YamlFile.from_parent(parent, path=file_path)\n", "type": "function"}, {"name": "test_getcfg_and_config", "is_method": true, "class_name": "TestParseIni", "parameters": ["self", "pytester", "tmp_path", "section", "filename", "monkeypatch"], "calls": ["pytest.mark.parametrize", "sub.mkdir", "monkeypatch.chdir", "write_text", "locate_config", "pytester.parseconfigure", "textwrap.dedent", "Path.cwd", "str"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 39, "end_line": 62}, "code_snippet": "    def test_getcfg_and_config(\n        self,\n        pytester: Pytester,\n        tmp_path: Path,\n        section: str,\n        filename: str,\n        monkeypatch: MonkeyPatch,\n    ) -> None:\n        sub = tmp_path / \"sub\"\n        sub.mkdir()\n        monkeypatch.chdir(sub)\n        (tmp_path / filename).write_text(\n            textwrap.dedent(\n                f\"\"\"\\\n                [{section}]\n                name = value\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        _, _, cfg = locate_config(Path.cwd(), [sub])\n        assert cfg[\"name\"] == \"value\"\n        config = pytester.parseconfigure(str(sub))\n        assert config.inicfg[\"name\"] == \"value\"\n", "type": "function"}, {"name": "test_empty_pytest_ini", "is_method": true, "class_name": "TestLoadConfigDictFromFile", "parameters": ["self", "tmp_path"], "calls": ["fn.write_text", "load_config_dict_from_file"], "code_location": {"file": "test_findpaths.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 17, "end_line": 21}, "code_snippet": "    def test_empty_pytest_ini(self, tmp_path: Path) -> None:\n        \"\"\"pytest.ini files are always considered for configuration, even if empty\"\"\"\n        fn = tmp_path / \"pytest.ini\"\n        fn.write_text(\"\", encoding=\"utf-8\")\n        assert load_config_dict_from_file(fn) == {}\n", "type": "function"}, {"name": "test_explicitly_specified_config_file_is_loaded", "is_method": true, "class_name": "TestConfigCmdlineParsing", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makeini", "pytester.makefile", "pytester.parseconfig", "pytester.parseconfig", "pytester.makefile", "pytester.parseconfig", "pytester.parseconfig", "pytester.makefile", "pytester.parseconfig", "pytester.parseconfig", "config.getini", "config.getini", "config.getini", "config.getini", "config.getini", "config.getini"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 561, "end_line": 612}, "code_snippet": "    def test_explicitly_specified_config_file_is_loaded(\n        self, pytester: Pytester\n    ) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"custom\", \"\")\n        \"\"\"\n        )\n        pytester.makeini(\n            \"\"\"\n            [pytest]\n            custom = 0\n        \"\"\"\n        )\n        pytester.makefile(\n            \".ini\",\n            custom=\"\"\"\n            [pytest]\n            custom = 1\n        \"\"\",\n        )\n        config = pytester.parseconfig(\"-c\", \"custom.ini\")\n        assert config.getini(\"custom\") == \"1\"\n        config = pytester.parseconfig(\"--config-file\", \"custom.ini\")\n        assert config.getini(\"custom\") == \"1\"\n\n        pytester.makefile(\n            \".cfg\",\n            custom_tool_pytest_section=\"\"\"\n            [tool:pytest]\n            custom = 1\n        \"\"\",\n        )\n        config = pytester.parseconfig(\"-c\", \"custom_tool_pytest_section.cfg\")\n        assert config.getini(\"custom\") == \"1\"\n        config = pytester.parseconfig(\"--config-file\", \"custom_tool_pytest_section.cfg\")\n        assert config.getini(\"custom\") == \"1\"\n\n        pytester.makefile(\n            \".toml\",\n            custom=\"\"\"\n                [tool.pytest.ini_options]\n                custom = 1\n                value = [\n                ]  # this is here on purpose, as it makes this an invalid '.ini' file\n            \"\"\",\n        )\n        config = pytester.parseconfig(\"-c\", \"custom.toml\")\n        assert config.getini(\"custom\") == \"1\"\n        config = pytester.parseconfig(\"--config-file\", \"custom.toml\")\n        assert config.getini(\"custom\") == \"1\"\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["config.getvalue", "config.addinivalue_line", "LsofFdLeakChecker", "checker.matching_platform", "config.pluginmanager.register"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 108, "end_line": 118}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    if config.getvalue(\"lsof\"):\n        checker = LsofFdLeakChecker()\n        if checker.matching_platform():\n            config.pluginmanager.register(checker)\n\n    config.addinivalue_line(\n        \"markers\",\n        \"pytester_example_path(*path_segments): join the given path \"\n        \"segments to `pytester_example_dir` for this test.\",\n    )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.098944664001465}
{"question": "Where does Pytest's plugin system flow from plugin registration through hook execution to result collection?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's plugin system flow follows a structured sequence from plugin registration through hook execution to result collection: 1) Plugin discovery and registration phase begins with scanning command line for -p no:name options to block plugins, followed by loading builtin plugins, then external plugins through entry points, and finally conftest.py plugins, 2) Plugin registration occurs through PytestPluginManager.register() which adds plugins to the plugin manager and triggers pytest_plugin_registered hook for notification, 3) Hook specification registration happens when plugins define hook functions with pytest_ prefix, which are automatically discovered and registered with the plugin manager, 4) Hook execution follows a 1:N pattern where multiple plugins can implement the same hook specification, with execution order controlled by tryfirst/trylast markers, 5) Hook wrappers execute around other hook implementations, providing cross-cutting functionality and allowing pre/post processing of hook results, 6) Hook execution phases include bootstrapping hooks (pytest_cmdline_parse), initialization hooks (pytest_configure), collection hooks (pytest_collection), test running hooks (pytest_runtestloop), and reporting hooks (pytest_runtest_logreport), 7) Result collection occurs through TestReport objects that are created during test execution and passed to reporting hooks for processing, 8) Plugin system integrates with the main execution flow through hooks like pytest_cmdline_main which orchestrates the overall test execution process, 9) Hook results are collected and processed according to hook specifications, with firstresult hooks stopping at the first non-None result, 10) Plugin communication happens through the plugin manager's hook system, allowing plugins to interact and share data, 11) Error handling and exception propagation occurs through the hook system, with proper cleanup and reporting mechanisms, 12) The entire plugin system is built on the pluggy library, providing a robust foundation for extensible plugin architecture.", "score": null, "retrieved_content": [{"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "test_hook_tracing", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "_config_for_test"], "calls": ["pytestpm.trace.root.setwriter", "pytestpm.enable_tracing", "api1", "pytestpm.register", "undo", "saveindent.append", "saveindent.append", "ValueError", "len", "pytest.raises", "pytestpm.register", "api2"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 143, "end_line": 174}, "code_snippet": "    def test_hook_tracing(self, _config_for_test: Config) -> None:\n        pytestpm = _config_for_test.pluginmanager  # fully initialized with plugins\n        saveindent = []\n\n        class api1:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n\n        class api2:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n                raise ValueError()\n\n        values: list[str] = []\n        pytestpm.trace.root.setwriter(values.append)\n        undo = pytestpm.enable_tracing()\n        try:\n            indent = pytestpm.trace.root.indent\n            p = api1()\n            pytestpm.register(p)\n            assert pytestpm.trace.root.indent == indent\n            assert len(values) >= 2\n            assert \"pytest_plugin_registered\" in values[0]\n            assert \"finish\" in values[1]\n\n            values[:] = []\n            with pytest.raises(ValueError):\n                pytestpm.register(api2())\n            assert pytestpm.trace.root.indent == indent\n            assert saveindent[0] > indent\n        finally:\n            undo()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HookRecorder", "parameters": ["self", "pluginmanager"], "calls": ["check_ispytest", "pluginmanager.add_hookcall_monitoring", "self.calls.append", "RecordedHookCall"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 258, "end_line": 273}, "code_snippet": "    def __init__(\n        self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False\n    ) -> None:\n        check_ispytest(_ispytest)\n\n        self._pluginmanager = pluginmanager\n        self.calls: list[RecordedHookCall] = []\n        self.ret: int | ExitCode | None = None\n\n        def before(hook_name: str, hook_impls, kwargs) -> None:\n            self.calls.append(RecordedHookCall(hook_name, kwargs))\n\n        def after(outcome, hook_name: str, hook_impls, kwargs) -> None:\n            pass\n\n        self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)\n", "type": "function"}, {"name": "test_load_initial_conftest_last_ordering", "is_method": false, "class_name": null, "parameters": ["_config_for_test"], "calls": ["My", "pm.register", "hc.get_hookimpls"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1541, "end_line": 1564}, "code_snippet": "def test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    hookimpls = [\n        (\n            hookimpl.function.__module__,\n            \"wrapper\" if (hookimpl.wrapper or hookimpl.hookwrapper) else \"nonwrapper\",\n        )\n        for hookimpl in hc.get_hookimpls()\n    ]\n    assert hookimpls == [\n        (\"_pytest.config\", \"nonwrapper\"),\n        (m.__module__, \"nonwrapper\"),\n        (\"_pytest.legacypath\", \"nonwrapper\"),\n        (\"_pytest.capture\", \"wrapper\"),\n        (\"_pytest.warnings\", \"wrapper\"),\n    ]\n", "type": "function"}, {"name": "test_pytest_fs_collect_hooks_are_seen", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 449, "end_line": 463}, "code_snippet": "    def test_pytest_fs_collect_hooks_are_seen(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        pytester.mkdir(\"sub\")\n        pytester.makepyfile(\"def test_x(): pass\")\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n", "type": "function"}, {"name": "test_report_collectionfinish_hook", "is_method": true, "class_name": "TestTerminalFunctional", "parameters": ["self", "pytester", "params"], "calls": ["pytest.mark.parametrize", "pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1137, "end_line": 1153}, "code_snippet": "    def test_report_collectionfinish_hook(self, pytester: Pytester, params) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_report_collectionfinish(config, start_path, items):\n                return [f'hello from hook: {len(items)} items']\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('i', range(3))\n            def test(i):\n                pass\n        \"\"\"\n        )\n        result = pytester.runpytest(*params)\n        result.stdout.fnmatch_lines([\"collected 3 items\", \"hello from hook: 3 items\"])\n", "type": "function"}, {"name": "test_pytest_collect_file", "is_method": true, "class_name": "TestCollectPluginHookRelay", "parameters": ["self", "pytester"], "calls": ["pytester.makefile", "pytest.main", "len", "file_path.name.startswith", "wascalled.append", "Plugin"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 281, "end_line": 293}, "code_snippet": "    def test_pytest_collect_file(self, pytester: Pytester) -> None:\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, file_path: Path) -> None:\n                if not file_path.name.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(file_path)\n\n        pytester.makefile(\".abc\", \"xyz\")\n        pytest.main(pytester.path, plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].suffix == \".abc\"\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "pytest_plugin_registered", "is_method": false, "class_name": null, "parameters": ["plugin", "manager"], "calls": ["manager.get_plugin", "manager.register", "manager.is_registered"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 463, "end_line": 468}, "code_snippet": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.1014816761016846}
{"question": "Where does the fixture resolution flow from dependency analysis to fixture execution?", "answer": null, "relative_code_list": null, "ground_truth": "The fixture resolution flow in pytest follows a structured sequence from dependency analysis to fixture execution: 1) Fixture discovery phase begins during collection where FixtureManager.parsefactories() scans for fixture definitions and creates FixtureDef objects, 2) Dependency analysis occurs through FixtureManager.getfixtureinfo() which analyzes test functions to identify required fixtures and their dependencies, 3) Fixture closure calculation happens in getfixtureclosure() which computes the transitive closure of all fixtures needed by a test, including dependencies of dependencies, 4) Fixture ordering determination follows three factors: scope hierarchy (higher-scoped fixtures first), dependency relationships (dependencies before dependents), and autouse status (autouse fixtures first within their scope), 5) Fixture lookup occurs through FixtureRequest._get_active_fixturedef() which finds the appropriate FixtureDef for each requested fixture name, 6) Cache checking happens in FixtureDef.execute() where pytest checks if a fixture value is already cached and returns it if available, 7) Dependency resolution occurs where fixtures recursively resolve their own dependencies through request.getfixturevalue() calls, 8) Fixture execution happens through pytest_fixture_setup hook which calls the actual fixture function with resolved dependencies as keyword arguments, 9) Result caching occurs where fixture results are stored in FixtureDef.cached_result for reuse within the fixture's scope, 10) Fixture finalization setup happens where finalizers are registered to ensure proper cleanup when fixtures go out of scope, 11) Error handling occurs where fixture execution errors are captured and stored in the cache to prevent repeated failures, 12) The entire resolution flow is coordinated through the FixtureManager class which maintains the fixture registry and manages the resolution process.", "score": null, "retrieved_content": [{"name": "pytest_fixture_setup", "is_method": false, "class_name": null, "parameters": ["fixturedef", "request"], "calls": ["resolve_fixture_function", "fixturedef.cache_key", "request.getfixturevalue", "inspect.isasyncgenfunction", "inspect.iscoroutinefunction", "warnings.warn", "call_fixture_func", "PytestRemovedIn9Warning", "isinstance"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1167, "end_line": 1207}, "code_snippet": "def pytest_fixture_setup(\n    fixturedef: FixtureDef[FixtureValue], request: SubRequest\n) -> FixtureValue:\n    \"\"\"Execution of fixture setup.\"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        kwargs[argname] = request.getfixturevalue(argname)\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = fixturedef.cache_key(request)\n\n    if inspect.isasyncgenfunction(fixturefunc) or inspect.iscoroutinefunction(\n        fixturefunc\n    ):\n        auto_str = \" with autouse=True\" if fixturedef._autouse else \"\"\n\n        warnings.warn(\n            PytestRemovedIn9Warning(\n                f\"{request.node.name!r} requested an async fixture \"\n                f\"{request.fixturename!r}{auto_str}, with no plugin or hook that \"\n                \"handled it. This is usually an error, as pytest does not natively \"\n                \"support it. \"\n                \"This will turn into an error in pytest 9.\\n\"\n                \"See: https://docs.pytest.org/en/stable/deprecations.html#sync-test-depending-on-async-fixture\"\n            ),\n            # no stacklevel will point at users code, so we just point here\n            stacklevel=1,\n        )\n\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME as e:\n        if isinstance(e, skip.Exception):\n            # The test requested a fixture which caused a skip.\n            # Don't show the fixture as the skip location, as then the user\n            # wouldn't know which test skipped.\n            e._use_item_location = True\n        fixturedef.cached_result = (None, my_cache_key, (e, e.__traceback__))\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result\n", "type": "function"}, {"name": "TestScopeOrdering", "docstring": "Class of tests that ensure fixtures are ordered based on their scopes (#2405)", "methods": ["test_func_closure_module_auto", "test_func_closure_with_native_fixtures", "test_func_closure_module", "test_func_closure_scopes_reordered", "test_func_closure_same_scope_closer_root_first", "test_func_closure_all_scopes_complex", "test_parametrized_package_scope_reordering", "test_multiple_packages", "test_class_fixture_self_instance"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4187, "end_line": 4563}, "type": "class"}, {"name": "getfixtureclosure", "is_method": true, "class_name": "FixtureManager", "parameters": ["self", "parentnode", "initialnames", "ignore_args"], "calls": ["list", "fixturenames_closure.sort", "len", "len", "self.getfixturedefs", "fixturenames_closure.append"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1625, "end_line": 1665}, "code_snippet": "    def getfixtureclosure(\n        self,\n        parentnode: nodes.Node,\n        initialnames: tuple[str, ...],\n        ignore_args: AbstractSet[str],\n    ) -> tuple[list[str], dict[str, Sequence[FixtureDef[Any]]]]:\n        # Collect the closure of all fixtures, starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive).\n\n        fixturenames_closure = list(initialnames)\n\n        arg2fixturedefs: dict[str, Sequence[FixtureDef[Any]]] = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentnode)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    for arg in fixturedefs[-1].argnames:\n                        if arg not in fixturenames_closure:\n                            fixturenames_closure.append(arg)\n\n        def sort_by_scope(arg_name: str) -> Scope:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return Scope.Function\n            else:\n                return fixturedefs[-1]._scope\n\n        fixturenames_closure.sort(key=sort_by_scope, reverse=True)\n        return fixturenames_closure, arg2fixturedefs\n", "type": "function"}, {"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "_get_active_fixturedef", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self", "argname"], "calls": ["self._fixture_defs.get", "self._arg2fixturedefs.get", "self._iter_chain", "self._check_scope", "SubRequest", "fixturedef.execute", "PseudoFixtureDef", "self._check_scope", "self._fixturemanager.getfixturedefs", "FixtureLookupError", "FixtureLookupError", "len", "FixtureLookupError", "self._check_fixturedef_without_param"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 566, "end_line": 643}, "code_snippet": "    def _get_active_fixturedef(\n        self, argname: str\n    ) -> FixtureDef[object] | PseudoFixtureDef[object]:\n        if argname == \"request\":\n            cached_result = (self, [0], None)\n            return PseudoFixtureDef(cached_result, Scope.Function)\n\n        # If we already finished computing a fixture by this name in this item,\n        # return it.\n        fixturedef = self._fixture_defs.get(argname)\n        if fixturedef is not None:\n            self._check_scope(fixturedef, fixturedef._scope)\n            return fixturedef\n\n        # Find the appropriate fixturedef.\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) which was naturally\n            # not known at parsing/collection time.\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, self._pyfuncitem)\n            if fixturedefs is not None:\n                self._arg2fixturedefs[argname] = fixturedefs\n        # No fixtures defined with this name.\n        if fixturedefs is None:\n            raise FixtureLookupError(argname, self)\n        # The are no fixtures with this name applicable for the function.\n        if not fixturedefs:\n            raise FixtureLookupError(argname, self)\n\n        # A fixture may override another fixture with the same name, e.g. a\n        # fixture in a module can override a fixture in a conftest, a fixture in\n        # a class can override a fixture in the module, and so on.\n        # An overriding fixture can request its own name (possibly indirectly);\n        # in this case it gets the value of the fixture it overrides, one level\n        # up.\n        # Check how many `argname`s deep we are, and take the next one.\n        # `fixturedefs` is sorted from furthest to closest, so use negative\n        # indexing to go in reverse.\n        index = -1\n        for request in self._iter_chain():\n            if request.fixturename == argname:\n                index -= 1\n        # If already consumed all of the available levels, fail.\n        if -index > len(fixturedefs):\n            raise FixtureLookupError(argname, self)\n        fixturedef = fixturedefs[index]\n\n        # Prepare a SubRequest object for calling the fixture.\n        try:\n            callspec = self._pyfuncitem.callspec\n        except AttributeError:\n            callspec = None\n        if callspec is not None and argname in callspec.params:\n            param = callspec.params[argname]\n            param_index = callspec.indices[argname]\n            # The parametrize invocation scope overrides the fixture's scope.\n            scope = callspec._arg2scope[argname]\n        else:\n            param = NOTSET\n            param_index = 0\n            scope = fixturedef._scope\n            self._check_fixturedef_without_param(fixturedef)\n        # The parametrize invocation scope only controls caching behavior while\n        # allowing wider-scoped fixtures to keep depending on the parametrized\n        # fixture. Scope control is enforced for parametrized fixtures\n        # by recreating the whole fixture tree on parameter change.\n        # Hence `fixturedef._scope`, not `scope`.\n        self._check_scope(fixturedef, fixturedef._scope)\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Make sure the fixture value is cached, running it if it isn't\n        fixturedef.execute(request=subrequest)\n\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n", "type": "function"}, {"name": "_get_fixturestack", "is_method": true, "class_name": "FixtureRequest", "parameters": ["self"], "calls": ["values.reverse", "self._iter_chain"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 678, "end_line": 681}, "code_snippet": "    def _get_fixturestack(self) -> list[FixtureDef[Any]]:\n        values = [request._fixturedef for request in self._iter_chain()]\n        values.reverse()\n        return values\n", "type": "function"}, {"name": "test_fixture_dependency", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "touch", "pytester.mkdir", "touch", "write_text", "sub.joinpath", "subsub.mkdir", "touch", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "textwrap.dedent", "pytester.path.joinpath", "sub.joinpath", "sub.joinpath", "subsub.joinpath", "subsub.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 466, "end_line": 510}, "code_snippet": "def test_fixture_dependency(pytester: Pytester) -> None:\n    pytester.makeconftest(\"\")\n    pytester.path.joinpath(\"__init__.py\").touch()\n    sub = pytester.mkdir(\"sub\")\n    sub.joinpath(\"__init__.py\").touch()\n    sub.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    subsub = sub.joinpath(\"subsub\")\n    subsub.mkdir()\n    subsub.joinpath(\"__init__.py\").touch()\n    subsub.joinpath(\"test_bar.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    result = pytester.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_func_closure_with_native_fixtures", "is_method": true, "class_name": "TestScopeOrdering", "parameters": ["self", "pytester", "monkeypatch"], "calls": ["monkeypatch.setattr", "pytester.makepyfile", "pytester.inline_genitems", "isinstance", "TopRequest", "pytester.runpytest", "split", "split"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4227, "end_line": 4282}, "code_snippet": "    def test_func_closure_with_native_fixtures(\n        self, pytester: Pytester, monkeypatch: MonkeyPatch\n    ) -> None:\n        \"\"\"Sanity check that verifies the order returned by the closures and the actual fixture execution order:\n        The execution order may differ because of fixture inter-dependencies.\n        \"\"\"\n        monkeypatch.setattr(pytest, \"FIXTURE_ORDER\", [], raising=False)\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            FIXTURE_ORDER = pytest.FIXTURE_ORDER\n\n            @pytest.fixture(scope=\"session\")\n            def s1():\n                FIXTURE_ORDER.append('s1')\n\n            @pytest.fixture(scope=\"package\")\n            def p1():\n                FIXTURE_ORDER.append('p1')\n\n            @pytest.fixture(scope=\"module\")\n            def m1():\n                FIXTURE_ORDER.append('m1')\n\n            @pytest.fixture(scope='session')\n            def my_tmp_path_factory():\n                FIXTURE_ORDER.append('my_tmp_path_factory')\n\n            @pytest.fixture\n            def my_tmp_path(my_tmp_path_factory):\n                FIXTURE_ORDER.append('my_tmp_path')\n\n            @pytest.fixture\n            def f1(my_tmp_path):\n                FIXTURE_ORDER.append('f1')\n\n            @pytest.fixture\n            def f2():\n                FIXTURE_ORDER.append('f2')\n\n            def test_foo(f1, p1, m1, f2, s1): pass\n        \"\"\"\n        )\n        items, _ = pytester.inline_genitems()\n        assert isinstance(items[0], Function)\n        request = TopRequest(items[0], _ispytest=True)\n        # order of fixtures based on their scope and position in the parameter list\n        assert (\n            request.fixturenames\n            == \"s1 my_tmp_path_factory p1 m1 f1 f2 my_tmp_path\".split()\n        )\n        pytester.runpytest()\n        # actual fixture execution differs: dependent fixtures must be created first (\"my_tmp_path\")\n        FIXTURE_ORDER = pytest.FIXTURE_ORDER  # type: ignore[attr-defined]\n        assert FIXTURE_ORDER == \"s1 my_tmp_path_factory p1 m1 my_tmp_path f1 f2\".split()\n", "type": "function"}, {"name": "test_fixture_arg_ordering", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "str"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4738, "end_line": 4770}, "code_snippet": "def test_fixture_arg_ordering(pytester: Pytester) -> None:\n    \"\"\"\n    This test describes how fixtures in the same scope but without explicit dependencies\n    between them are created. While users should make dependencies explicit, often\n    they rely on this order, so this test exists to catch regressions in this regard.\n    See #6540 and #6492.\n    \"\"\"\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import pytest\n\n        suffixes = []\n\n        @pytest.fixture\n        def fix_1(): suffixes.append(\"fix_1\")\n        @pytest.fixture\n        def fix_2(): suffixes.append(\"fix_2\")\n        @pytest.fixture\n        def fix_3(): suffixes.append(\"fix_3\")\n        @pytest.fixture\n        def fix_4(): suffixes.append(\"fix_4\")\n        @pytest.fixture\n        def fix_5(): suffixes.append(\"fix_5\")\n\n        @pytest.fixture\n        def fix_combined(fix_1, fix_2, fix_3, fix_4, fix_5): pass\n\n        def test_suffix(fix_combined):\n            assert suffixes == [\"fix_1\", \"fix_2\", \"fix_3\", \"fix_4\", \"fix_5\"]\n        \"\"\"\n    )\n    result = pytester.runpytest(\"-vv\", str(p1))\n    assert result.ret == 0\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TopRequest", "parameters": ["self", "pyfuncitem"], "calls": ["__init__", "super", "pyfuncitem._fixtureinfo.name2fixturedefs.copy"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 688, "end_line": 695}, "code_snippet": "    def __init__(self, pyfuncitem: Function, *, _ispytest: bool = False) -> None:\n        super().__init__(\n            fixturename=None,\n            pyfuncitem=pyfuncitem,\n            arg2fixturedefs=pyfuncitem._fixtureinfo.name2fixturedefs.copy(),\n            fixture_defs={},\n            _ispytest=_ispytest,\n        )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.121265411376953}
{"question": "Where does Pytest implement its test discovery logic?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements its test discovery logic across several key modules in the codebase: 1) The main test discovery entry point is in src/_pytest/main.py where the Session.perform_collect() method initiates the collection process, 2) The pytest_collection hook in src/_pytest/main.py orchestrates the overall collection phase and coordinates the discovery process, 3) The collector hierarchy is implemented in src/_pytest/nodes.py with classes like Session, Directory, File, Module, Class, and Function that form the collection tree, 4) Python-specific test discovery is implemented in src/_pytest/python.py which handles discovery of test files, classes, and functions based on naming conventions, 5) The pytest_addoption hook in src/_pytest/python.py defines configuration options for test discovery like python_files, python_classes, and python_functions, 6) File system scanning and path handling is implemented in src/_pytest/pathlib.py with functions like scandir() and fnmatch_ex() for directory traversal and pattern matching, 7) Configuration-based discovery settings are managed in src/_pytest/config/__init__.py where testpaths, norecursedirs, and other discovery options are processed, 8) The _decide_args method in Config class determines which paths to search based on command line arguments, testpaths configuration, or current directory, 9) Test file pattern matching is handled through configuration options that define which files are considered test files (default: test_*.py, *_test.py), 10) Test class and function discovery uses pattern matching against configured prefixes (default: Test for classes, test for functions), 11) The collect_one_node function in src/_pytest/runner.py handles the collection of individual test nodes during the discovery process, 12) The entire discovery system is extensible through the plugin system, allowing custom collectors to be implemented for different file types or test frameworks.", "score": null, "retrieved_content": [{"name": "test_customized_python_discovery", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeini", "pytester.makepyfile", "p.with_name", "p.rename", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines", "p.name.replace"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1282, "end_line": 1309}, "code_snippet": "def test_customized_python_discovery(pytester: Pytester) -> None:\n    pytester.makeini(\n        \"\"\"\n        [pytest]\n        python_files=check_*.py\n        python_classes=Check\n        python_functions=check\n    \"\"\"\n    )\n    p = pytester.makepyfile(\n        \"\"\"\n        def check_simple():\n            pass\n        class CheckMyApp(object):\n            def check_meth(self):\n                pass\n    \"\"\"\n    )\n    p2 = p.with_name(p.name.replace(\"test\", \"check\"))\n    p.rename(p2)\n    result = pytester.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines(\n        [\"*check_customized*\", \"*check_simple*\", \"*CheckMyApp*\", \"*check_meth*\"]\n    )\n\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_customized_python_discovery_functions", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeini", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1312, "end_line": 1330}, "code_snippet": "def test_customized_python_discovery_functions(pytester: Pytester) -> None:\n    pytester.makeini(\n        \"\"\"\n        [pytest]\n        python_functions=_test\n    \"\"\"\n    )\n    pytester.makepyfile(\n        \"\"\"\n        def _test_underscore():\n            pass\n    \"\"\"\n    )\n    result = pytester.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines([\"*_test_underscore*\"])\n\n    result = pytester.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "collect", "is_method": true, "class_name": "ManifestDirectory", "parameters": ["self"], "calls": ["json.loads", "manifest_path.read_text", "ihook.pytest_collect_file"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/doc/en/example/customdirectory", "start_line": 10, "end_line": 21}, "code_snippet": "    def collect(self):\n        # The standard pytest behavior is to loop over all `test_*.py` files and\n        # call `pytest_collect_file` on each file. This collector instead reads\n        # the `manifest.json` file and only calls `pytest_collect_file` for the\n        # files defined there.\n        manifest_path = self.path / \"manifest.json\"\n        manifest = json.loads(manifest_path.read_text(encoding=\"utf-8\"))\n        ihook = self.ihook\n        for file in manifest[\"files\"]:\n            yield from ihook.pytest_collect_file(\n                file_path=self.path / file, parent=self\n            )\n", "type": "function"}, {"name": "test_pytest_fs_collect_hooks_are_seen", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.mkdir", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 449, "end_line": 463}, "code_snippet": "    def test_pytest_fs_collect_hooks_are_seen(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        pytester.mkdir(\"sub\")\n        pytester.makepyfile(\"def test_x(): pass\")\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n", "type": "function"}, {"name": "pytest_pycollect_makeitem", "is_method": false, "class_name": null, "parameters": ["collector", "name", "obj"], "calls": ["hookimpl", "isinstance", "type", "safe_isclass", "collector.istestclass", "collector.istestfunction", "Class.from_parent", "getattr", "getfslineno", "warnings.warn_explicit", "getattr", "inspect.isfunction", "inspect.isfunction", "inspect.isgeneratorfunction", "list", "get_real_func", "PytestCollectionWarning", "str", "fail", "collector._genfunctions"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 210, "end_line": 242}, "code_snippet": "def pytest_pycollect_makeitem(\n    collector: Module | Class, name: str, obj: object\n) -> None | nodes.Item | nodes.Collector | list[nodes.Item | nodes.Collector]:\n    assert isinstance(collector, (Class, Module)), type(collector)\n    # Nothing was collected elsewhere, let's do it here.\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it.\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only).\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    f\"cannot collect {name!r} because it is not a function.\"\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if inspect.isgeneratorfunction(obj):\n                fail(\n                    f\"'yield' keyword is allowed in fixtures, but not in tests ({name})\",\n                    pytrace=False,\n                )\n            return list(collector._genfunctions(name, obj))\n        return None\n    return None\n", "type": "function"}, {"name": "test_collectonly_simple", "is_method": true, "class_name": "TestCollectonly", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 553, "end_line": 573}, "code_snippet": "    def test_collectonly_simple(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def test_func1():\n                pass\n            class TestClass(object):\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        result = pytester.runpytest(\"--collect-only\", p)\n        # assert stderr.startswith(\"inserting into sys.path\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            [\n                \"*<Module *.py>\",\n                \"* <Function test_func1>\",\n                \"* <Class TestClass>\",\n                \"*   <Function test_method>\",\n            ]\n        )\n", "type": "function"}, {"name": "test_ignored_certain_directories", "is_method": true, "class_name": "TestCollectFS", "parameters": ["self", "pytester"], "calls": ["ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "ensure_file", "tmp_path.rglob", "pytester.runpytest", "result.stdout.str", "x.write_text"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 138, "end_line": 154}, "code_snippet": "    def test_ignored_certain_directories(self, pytester: Pytester) -> None:\n        tmp_path = pytester.path\n        ensure_file(tmp_path / \"build\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"dist\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"_darcs\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"CVS\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"{arch}\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \".whatever\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \".bzr\" / \"test_notfound.py\")\n        ensure_file(tmp_path / \"normal\" / \"test_found.py\")\n        for x in tmp_path.rglob(\"test_*.py\"):\n            x.write_text(\"def test_hello(): pass\", encoding=\"utf-8\")\n\n        result = pytester.runpytest(\"--collect-only\")\n        s = result.stdout.str()\n        assert \"test_notfound\" not in s\n        assert \"test_found\" in s\n", "type": "function"}, {"name": "test_pytest_collect_file_from_sister_dir", "is_method": true, "class_name": "TestCustomConftests", "parameters": ["self", "pytester"], "calls": ["pytester.mkpydir", "pytester.mkpydir", "pytester.makeconftest", "conf1.replace", "pytester.makeconftest", "conf2.replace", "pytester.makepyfile", "shutil.copy", "shutil.copy", "pytester.runpytest", "result.stdout.fnmatch_lines", "sub1.joinpath", "sub2.joinpath", "sub1.joinpath", "sub2.joinpath"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 465, "end_line": 494}, "code_snippet": "    def test_pytest_collect_file_from_sister_dir(self, pytester: Pytester) -> None:\n        sub1 = pytester.mkpydir(\"sub1\")\n        sub2 = pytester.mkpydir(\"sub2\")\n        conf1 = pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule1(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule1.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        conf1.replace(sub1.joinpath(conf1.name))\n        conf2 = pytester.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule2(pytest.Module):\n                pass\n            def pytest_collect_file(file_path, parent):\n                if file_path.suffix == \".py\":\n                    return MyModule2.from_parent(path=file_path, parent=parent)\n        \"\"\"\n        )\n        conf2.replace(sub2.joinpath(conf2.name))\n        p = pytester.makepyfile(\"def test_x(): pass\")\n        shutil.copy(p, sub1.joinpath(p.name))\n        shutil.copy(p, sub2.joinpath(p.name))\n        result = pytester.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n", "type": "function"}, {"name": "pytest_collect_file", "is_method": false, "class_name": null, "parameters": ["file_path", "parent"], "calls": ["parent.session.gethookproxy", "ihook.pytest_pycollect_makemodule", "parent.session.isinitpath", "path_matches_patterns", "parent.config.getini"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 185, "end_line": 197}, "code_snippet": "def pytest_collect_file(file_path: Path, parent: nodes.Collector) -> Module | None:\n    if file_path.suffix == \".py\":\n        if not parent.session.isinitpath(file_path):\n            if not path_matches_patterns(\n                file_path, parent.config.getini(\"python_files\")\n            ):\n                return None\n        ihook = parent.session.gethookproxy(file_path)\n        module: Module = ihook.pytest_pycollect_makemodule(\n            module_path=file_path, parent=parent\n        )\n        return module\n    return None\n", "type": "function"}, {"name": "pytest_pycollect_makeitem", "is_method": false, "class_name": null, "parameters": ["collector", "name", "obj"], "calls": ["inspect.isabstract", "UnitTestCase.from_parent", "issubclass"], "code_location": {"file": "unittest.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 52, "end_line": 69}, "code_snippet": "def pytest_pycollect_makeitem(\n    collector: Module | Class, name: str, obj: object\n) -> UnitTestCase | None:\n    try:\n        # Has unittest been imported?\n        ut = sys.modules[\"unittest\"]\n        # Is obj a subclass of unittest.TestCase?\n        # Type ignored because `ut` is an opaque module.\n        if not issubclass(obj, ut.TestCase):  # type: ignore\n            return None\n    except Exception:\n        return None\n    # Is obj a concrete class?\n    # Abstract classes can't be instantiated so no point collecting them.\n    if inspect.isabstract(obj):\n        return None\n    # Yes, so let's collect it.\n    return UnitTestCase.from_parent(collector, name=name, obj=obj)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.165450096130371}
{"question": "Where does Pytest store its plugin implementations?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest stores its plugin implementations across multiple locations in the codebase: 1) Built-in plugins are stored in the src/_pytest/ directory as individual modules, with each plugin implemented as a separate Python module containing hook functions, 2) Essential plugins (mark, main, runner, fixtures, helpconfig) are defined in src/_pytest/config/__init__.py in the essential_plugins tuple and cannot be disabled, 3) Default plugins are listed in src/_pytest/config/__init__.py in the default_plugins tuple and include core functionality like python, terminal, debugging, unittest, capture, skipping, etc., 4) Built-in plugins are stored in src/_pytest/config/__init__.py in the builtin_plugins set which includes all default plugins plus pytester and pytester_assertions, 5) Plugin modules are organized by functionality in the src/_pytest/ directory, such as src/_pytest/fixtures.py for fixture system, src/_pytest/assertion/ for assertion rewriting, src/_pytest/cacheprovider.py for caching functionality, 6) External plugins are discovered through entry points in their packaging metadata and loaded dynamically at runtime, 7) Local conftest.py plugins are auto-discovered in test directories and loaded as modules during test collection, 8) Plugin registration and management is handled by the PytestPluginManager class in src/_pytest/config/__init__.py, 9) Plugin loading order is controlled by the plugin discovery sequence: command line blocking, builtin plugins, external plugins, environment variables, and conftest files, 10) Plugin implementations are stored as Python modules with hook functions that follow the pytest_ prefix naming convention, 11) The plugin system is built on the pluggy library, with plugins registered through the plugin manager's register() method, 12) Plugin state and data can be stored using the stash mechanism on test items and configuration objects for cross-hook communication.", "score": null, "retrieved_content": [{"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "pytestpm", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 21, "end_line": 22}, "code_snippet": "def pytestpm() -> PytestPluginManager:\n    return PytestPluginManager()\n", "type": "function"}, {"name": "pytest_plugin_registered", "is_method": true, "class_name": "FixtureManager", "parameters": ["self", "plugin", "plugin_name"], "calls": ["self.parsefactories", "plugin_name.endswith", "absolutepath", "str", "nodeid.replace", "conftestpath.parent.relative_to"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1583, "end_line": 1605}, "code_snippet": "    def pytest_plugin_registered(self, plugin: _PluggyPlugin, plugin_name: str) -> None:\n        # Fixtures defined in conftest plugins are only visible to within the\n        # conftest's directory. This is unlike fixtures in non-conftest plugins\n        # which have global visibility. So for conftests, construct the base\n        # nodeid from the plugin name (which is the conftest path).\n        if plugin_name and plugin_name.endswith(\"conftest.py\"):\n            # Note: we explicitly do *not* use `plugin.__file__` here -- The\n            # difference is that plugin_name has the correct capitalization on\n            # case-insensitive systems (Windows) and other normalization issues\n            # (issue #11816).\n            conftestpath = absolutepath(plugin_name)\n            try:\n                nodeid = str(conftestpath.parent.relative_to(self.config.rootpath))\n            except ValueError:\n                nodeid = \"\"\n            if nodeid == \".\":\n                nodeid = \"\"\n            if os.sep != nodes.SEP:\n                nodeid = nodeid.replace(os.sep, nodes.SEP)\n        else:\n            nodeid = None\n\n        self.parsefactories(plugin, nodeid)\n", "type": "function"}, {"name": "plugins", "is_method": true, "class_name": "Testdir", "parameters": ["self"], "calls": [], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 73, "end_line": 74}, "code_snippet": "    def plugins(self):\n        return self._pytester.plugins\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "pytest_plugin_registered", "is_method": false, "class_name": null, "parameters": ["plugin", "manager"], "calls": ["manager.get_plugin", "manager.register", "manager.is_registered"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 463, "end_line": 468}, "code_snippet": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")\n", "type": "function"}, {"name": "parse_hookimpl_opts", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self", "plugin", "name"], "calls": ["parse_hookimpl_opts", "getattr", "_get_legacy_hook_marks", "cast", "name.startswith", "inspect.isroutine", "super"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 453, "end_line": 478}, "code_snippet": "    def parse_hookimpl_opts(\n        self, plugin: _PluggyPlugin, name: str\n    ) -> HookimplOpts | None:\n        \"\"\":meta private:\"\"\"\n        # pytest hooks are always prefixed with \"pytest_\",\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073).\n        if not name.startswith(\"pytest_\"):\n            return None\n        # Ignore names which cannot be hooks.\n        if name == \"pytest_plugins\":\n            return None\n\n        opts = super().parse_hookimpl_opts(plugin, name)\n        if opts is not None:\n            return opts\n\n        method = getattr(plugin, name)\n        # Consider only actual functions for hooks (#3775).\n        if not inspect.isroutine(method):\n            return None\n        # Collect unmarked hooks as long as they have the `pytest_' prefix.\n        legacy = _get_legacy_hook_marks(\n            method, \"impl\", (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\")\n        )\n        return cast(HookimplOpts, legacy)\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["hookimpl", "Cache.for_config", "config.pluginmanager.register", "config.pluginmanager.register", "LFPlugin", "NFPlugin"], "code_location": {"file": "cacheprovider.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 551}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    config.cache = Cache.for_config(config, _ispytest=True)\n    config.pluginmanager.register(LFPlugin(config), \"lfplugin\")\n    config.pluginmanager.register(NFPlugin(config), \"nfplugin\")\n", "type": "function"}, {"name": "plugins", "is_method": true, "class_name": "Testdir", "parameters": ["self", "plugins"], "calls": [], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 77, "end_line": 78}, "code_snippet": "    def plugins(self, plugins):\n        self._pytester.plugins = plugins\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "PytestPluginManager", "parameters": ["self"], "calls": ["__init__", "set", "self.add_hookspecs", "self.register", "os.environ.get", "DummyRewriteHook", "lru_cache", "getattr", "self.trace.root.setwriter", "self.enable_tracing", "super", "open", "os.dup", "err.fileno"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 401, "end_line": 451}, "code_snippet": "    def __init__(self) -> None:\n        from _pytest.assertion import DummyRewriteHook\n        from _pytest.assertion import RewriteHook\n\n        super().__init__(\"pytest\")\n\n        # -- State related to local conftest plugins.\n        # All loaded conftest modules.\n        self._conftest_plugins: set[types.ModuleType] = set()\n        # All conftest modules applicable for a directory.\n        # This includes the directory's own conftest modules as well\n        # as those of its parent directories.\n        self._dirpath2confmods: dict[pathlib.Path, list[types.ModuleType]] = {}\n        # Cutoff directory above which conftests are no longer discovered.\n        self._confcutdir: pathlib.Path | None = None\n        # If set, conftest loading is skipped.\n        self._noconftest = False\n\n        # _getconftestmodules()'s call to _get_directory() causes a stat\n        # storm when it's called potentially thousands of times in a test\n        # session (#9478), often with the same path, so cache it.\n        self._get_directory = lru_cache(256)(_get_directory)\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: list[tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook: RewriteHook = DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.1694915294647217}
{"question": "Where in the Pytest codebase is the core test runner implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The core test runner in pytest is implemented across several key modules in the codebase: 1) Main entry point is in src/_pytest/main.py which contains the core testing process implementation including initialization, session management, and the main runtest loop, 2) The Session class in src/_pytest/main.py serves as the root collector and orchestrates the overall test execution process, 3) The pytest_runtestloop hook in src/_pytest/main.py implements the main test execution loop that iterates through collected test items, 4) The pytest_runtest_protocol hook in src/_pytest/runner.py orchestrates the three-phase test execution (setup, call, teardown) for individual tests, 5) The SetupState class in src/_pytest/runner.py manages the setup and teardown of test items and collectors, 6) The collect_one_node function in src/_pytest/runner.py handles the collection of individual test nodes, 7) The _main function in src/_pytest/main.py provides the default command line protocol for initialization, session management, test running, and reporting, 8) The pytest_cmdline_main hook in src/_pytest/main.py serves as the main entry point for command line execution, 9) The wrap_session function in src/_pytest/main.py coordinates the overall test session lifecycle, 10) The Config class in src/_pytest/config/__init__.py provides the central configuration object that the test runner uses, 11) The PytestPluginManager in src/_pytest/config/__init__.py manages plugin registration and hook execution that the test runner relies on, 12) The entire test runner architecture is built on the pluggy library, with all major operations delegated to plugins through the hook system.", "score": null, "retrieved_content": [{"name": "pytest_runtestloop", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["enumerate", "session.Interrupted", "item.config.hook.pytest_runtest_protocol", "session.Failed", "session.Interrupted", "len"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 356, "end_line": 372}, "code_snippet": "def pytest_runtestloop(session: Session) -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            f\"{session.testsfailed} error{'s' if session.testsfailed != 1 else ''} during collection\"\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n", "type": "function"}, {"name": "Session", "docstring": "The root of the collection tree.\n\n``Session`` collects the initial paths given as arguments to pytest.", "methods": ["__init__", "from_config", "__repr__", "shouldstop", "shouldstop", "shouldfail", "shouldfail", "startpath", "_node_location_to_relpath", "pytest_collectstart", "pytest_runtest_logreport", "isinitpath", "gethookproxy", "_collect_path", "perform_collect", "perform_collect", "perform_collect", "_collect_one_node", "collect", "genitems"], "attributes": ["Interrupted", "Failed", "pytest_collectreport"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 548, "end_line": 985}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Testdir", "parameters": ["self", "pytester"], "calls": ["check_ispytest"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 55, "end_line": 57}, "code_snippet": "    def __init__(self, pytester: Pytester, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pytester = pytester\n", "type": "function"}, {"name": "Pytester", "docstring": "Facilities to write tests/configuration files, execute pytest in isolation, and match\nagainst expected output, perfect for black-box testing of pytest plugins.\n\nIt attempts to isolate the test run from external factors as much as possible, modifying\nthe current working directory to :attr:`path` and environment variables during initialization.", "methods": ["__init__", "path", "__repr__", "_finalize", "__take_sys_modules_snapshot", "make_hook_recorder", "chdir", "_makefile", "makefile", "makeconftest", "makeini", "getinicfg", "makepyprojecttoml", "makepyfile", "maketxtfile", "syspathinsert", "mkdir", "mkpydir", "copy_example", "getnode", "getpathnode", "genitems", "runitem", "inline_runsource", "inline_genitems", "inline_run", "runpytest_inprocess", "runpytest", "_ensure_basetemp", "parseconfig", "parseconfigure", "getitem", "getitems", "getmodulecol", "collect_by_name", "popen", "run", "_dump_lines", "_getpytestargs", "runpython", "runpython_c", "runpytest_subprocess", "spawn_pytest", "spawn"], "attributes": ["__test__"], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 649, "end_line": 1536}, "type": "class"}, {"name": "test_collect_result", "is_method": true, "class_name": "TestSessionReports", "parameters": ["self", "pytester"], "calls": ["pytester.getmodulecol", "runner.collect_one_node", "len"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 500, "end_line": 521}, "code_snippet": "    def test_collect_result(self, pytester: Pytester) -> None:\n        col = pytester.getmodulecol(\n            \"\"\"\n            def test_func1():\n                pass\n            class TestClass(object):\n                pass\n        \"\"\"\n        )\n        rep = runner.collect_one_node(col)\n        assert not rep.failed\n        assert not rep.skipped\n        assert rep.passed\n        locinfo = rep.location\n        assert locinfo is not None\n        assert locinfo[0] == col.path.name\n        assert not locinfo[1]\n        assert locinfo[2] == col.path.name\n        res = rep.result\n        assert len(res) == 2\n        assert res[0].name == \"test_func1\"\n        assert res[1].name == \"TestClass\"\n", "type": "function"}, {"name": "test_earlyinit", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpython"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 578, "end_line": 586}, "code_snippet": "    def test_earlyinit(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            import pytest\n            assert hasattr(pytest, 'mark')\n        \"\"\"\n        )\n        result = pytester.runpython(p)\n        assert result.ret == 0\n", "type": "function"}, {"name": "test_python_pytest_package", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.run", "res.stdout.fnmatch_lines", "str"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 635, "end_line": 639}, "code_snippet": "    def test_python_pytest_package(self, pytester: Pytester) -> None:\n        p1 = pytester.makepyfile(\"def test_pass(): pass\")\n        res = pytester.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "pytest_runtest_call", "is_method": false, "class_name": null, "parameters": ["item"], "calls": ["_update_current_test_var", "item.runtest", "type"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 167, "end_line": 188}, "code_snippet": "def pytest_runtest_call(item: Item) -> None:\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n        if sys.version_info >= (3, 12, 0):\n            del sys.last_exc  # type:ignore[attr-defined]\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        if sys.version_info >= (3, 12, 0):\n            sys.last_exc = e  # type:ignore[attr-defined]\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise\n", "type": "function"}, {"name": "test_runtest_location_shown_before_test_starts", "is_method": true, "class_name": "TestTerminal", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.spawn_pytest", "child.expect", "child.sendeof", "child.kill"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 168, "end_line": 181}, "code_snippet": "    def test_runtest_location_shown_before_test_starts(\n        self, pytester: Pytester\n    ) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_1():\n                import time\n                time.sleep(20)\n        \"\"\"\n        )\n        child = pytester.spawn_pytest(\"\")\n        child.expect(\".*test_runtest_location.*py\")\n        child.sendeof()\n        child.kill(15)\n", "type": "function"}, {"name": "test_collect_topdir", "is_method": true, "class_name": "TestSession", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "join", "pytester.parseconfig", "Session.from_config", "rcol.perform_collect", "len"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 498, "end_line": 511}, "code_snippet": "    def test_collect_topdir(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\"def test_func(): pass\")\n        id = \"::\".join([p.name, \"test_func\"])\n        # XXX migrate to collectonly? (see below)\n        config = pytester.parseconfig(id)\n        topdir = pytester.path\n        rcol = Session.from_config(config)\n        assert topdir == rcol.path\n        # rootid = rcol.nodeid\n        # root2 = rcol.perform_collect([rcol.nodeid], genitems=False)[0]\n        # assert root2 == rcol, rootid\n        colitems = rcol.perform_collect([rcol.nodeid], genitems=False)\n        assert len(colitems) == 1\n        assert colitems[0].path == topdir\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.1964993476867676}
{"question": "Where does Pytest's test execution flow from test discovery through fixture setup to test execution and teardown?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest's test execution flow follows a structured sequence from test discovery through fixture setup to test execution and teardown: 1) Test discovery phase begins with Session.perform_collect() which scans filesystem paths and identifies test files, modules, classes, and functions, 2) Collection phase uses the collector hierarchy (Session -> Directory -> Package -> Module -> Class -> Function) to build a tree of test items, 3) Fixture discovery occurs during collection where pytest identifies fixtures used by each test through FixtureManager.parsefactories(), 4) Fixture dependency analysis determines the order of fixture execution based on scope hierarchy and dependency relationships, 5) Test execution phase starts with pytest_runtestloop hook which iterates through collected test items, 6) For each test, pytest_runtest_protocol hook orchestrates the three-phase execution: setup, call, and teardown, 7) Setup phase (pytest_runtest_setup) resolves and executes fixtures in dependency order, with higher-scoped fixtures executed first, 8) Call phase (pytest_runtest_call) executes the actual test function with resolved fixture values injected as parameters, 9) Teardown phase (pytest_runtest_teardown) executes fixture finalizers and cleanup operations in reverse order, 10) Fixture execution follows scope-based caching where fixtures are created once per scope and reused across tests, 11) Test results are collected through TestReport objects and passed to reporting hooks for output generation, 12) The entire flow is coordinated through the hook system, allowing plugins to intercept and modify behavior at each phase.", "score": null, "retrieved_content": [{"name": "pytest_runtestloop", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["enumerate", "session.Interrupted", "item.config.hook.pytest_runtest_protocol", "session.Failed", "session.Interrupted", "len"], "code_location": {"file": "main.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 356, "end_line": 372}, "code_snippet": "def pytest_runtestloop(session: Session) -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            f\"{session.testsfailed} error{'s' if session.testsfailed != 1 else ''} during collection\"\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n", "type": "function"}, {"name": "test_capture_and_fixtures", "is_method": true, "class_name": "TestPerTestCapturing", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_capture.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 155, "end_line": 179}, "code_snippet": "    def test_capture_and_fixtures(self, pytester: Pytester) -> None:\n        p = pytester.makepyfile(\n            \"\"\"\n            def setup_module(mod):\n                print(\"setup module\")\n            def setup_function(function):\n                print(\"setup \" + function.__name__)\n            def test_func1():\n                print(\"in func1\")\n                assert 0\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = pytester.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"setup module*\",\n                \"setup test_func1*\",\n                \"in func1*\",\n                \"setup test_func2*\",\n                \"in func2*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_runtest_in_module_ordering", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 570, "end_line": 599}, "code_snippet": "def test_runtest_in_module_ordering(pytester: Pytester) -> None:\n    p1 = pytester.makepyfile(\n        \"\"\"\n        import pytest\n        def pytest_runtest_setup(item): # runs after class-level!\n            item.function.mylist.append(\"module\")\n        class TestClass(object):\n            def pytest_runtest_setup(self, item):\n                assert not hasattr(item.function, 'mylist')\n                item.function.mylist = ['class']\n            @pytest.fixture\n            def mylist(self, request):\n                return request.function.mylist\n            @pytest.hookimpl(wrapper=True)\n            def pytest_runtest_call(self, item):\n                try:\n                    yield\n                except ValueError:\n                    pass\n            def test_hello1(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n                raise ValueError()\n            def test_hello2(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n        def pytest_runtest_teardown(item):\n            del item.function.mylist\n    \"\"\"\n    )\n    result = pytester.runpytest(p1)\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n", "type": "function"}, {"name": "test_simple", "is_method": true, "class_name": "TestContextManagerFixtureFuncs", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3864, "end_line": 3890}, "code_snippet": "    def test_simple(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg1():\n                print(\"setup\")\n                yield 1\n                print(\"teardown\")\n            def test_1(arg1):\n                print(\"test1\", arg1)\n            def test_2(arg1):\n                print(\"test2\", arg1)\n                assert 0\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *setup*\n            *test1 1*\n            *teardown*\n            *setup*\n            *test2 1*\n            *teardown*\n        \"\"\"\n        )\n", "type": "function"}, {"name": "pytest_runtest_protocol", "is_method": false, "class_name": null, "parameters": ["item", "nextitem"], "calls": ["ihook.pytest_runtest_logstart", "runtestprotocol", "ihook.pytest_runtest_logfinish"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 114, "end_line": 119}, "code_snippet": "def pytest_runtest_protocol(item: Item, nextitem: Item | None) -> bool:\n    ihook = item.ihook\n    ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True\n", "type": "function"}, {"name": "runtestprotocol", "is_method": false, "class_name": null, "parameters": ["item", "log", "nextitem"], "calls": ["hasattr", "call_and_report", "reports.append", "item._initrequest", "item.config.getoption", "call_and_report", "show_test_item", "item.config.getoption", "reports.append", "call_and_report"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 122, "end_line": 147}, "code_snippet": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Item | None = None\n) -> list[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    # If the session is about to fail or stop, teardown everything - this is\n    # necessary to correctly report fixture teardown errors (see #11706)\n    if item.session.shouldfail or item.session.shouldstop:\n        nextitem = None\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # After all teardown hooks have been called\n    # want funcargs and request info to go away.\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports\n", "type": "function"}, {"name": "test_rerun", "is_method": true, "class_name": "TestReRunTests", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "result.stdout.fnmatch_lines"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 227, "end_line": 263}, "code_snippet": "    def test_rerun(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            from _pytest.runner import runtestprotocol\n            def pytest_runtest_protocol(item, nextitem):\n                runtestprotocol(item, log=False, nextitem=nextitem)\n                runtestprotocol(item, log=True, nextitem=nextitem)\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            count = 0\n            req = None\n            @pytest.fixture\n            def fix(request):\n                global count, req\n                assert request != req\n                req = request\n                print(\"fix count %s\" % count)\n                count += 1\n            def test_fix(fix):\n                pass\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *fix count 0*\n            *fix count 1*\n        \"\"\"\n        )\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *2 passed*\n        \"\"\"\n        )\n", "type": "function"}, {"name": "show_fixtures_per_test", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["wrap_session"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1882, "end_line": 1885}, "code_snippet": "def show_fixtures_per_test(config: Config) -> int | ExitCode:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _show_fixtures_per_test)\n", "type": "function"}, {"name": "test_pytest_fixture_setup_and_post_finalizer_hook", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4144, "end_line": 4184}, "code_snippet": "def test_pytest_fixture_setup_and_post_finalizer_hook(pytester: Pytester) -> None:\n    pytester.makeconftest(\n        \"\"\"\n        def pytest_fixture_setup(fixturedef, request):\n            print('ROOT setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        def pytest_fixture_post_finalizer(fixturedef, request):\n            print('ROOT finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n    \"\"\"\n    )\n    pytester.makepyfile(\n        **{\n            \"tests/conftest.py\": \"\"\"\n            def pytest_fixture_setup(fixturedef, request):\n                print('TESTS setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n            def pytest_fixture_post_finalizer(fixturedef, request):\n                print('TESTS finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        \"\"\",\n            \"tests/test_hooks.py\": \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def my_fixture():\n                return 'some'\n\n            def test_func(my_fixture):\n                print('TEST test_func')\n                assert my_fixture == 'some'\n        \"\"\",\n        }\n    )\n    result = pytester.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*TESTS setup hook called for my_fixture from test_func*\",\n            \"*ROOT setup hook called for my_fixture from test_func*\",\n            \"*TEST test_func*\",\n            \"*TESTS finalizer hook called for my_fixture from test_func*\",\n            \"*ROOT finalizer hook called for my_fixture from test_func*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_parametrization_setup_teardown_ordering", "is_method": true, "class_name": "TestAutouseManagement", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2279, "end_line": 2306}, "code_snippet": "    def test_parametrization_setup_teardown_ordering(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            def pytest_generate_tests(metafunc):\n                if metafunc.cls is None:\n                    assert metafunc.function is test_finish\n                if metafunc.cls is not None:\n                    metafunc.parametrize(\"item\", [1,2], scope=\"class\")\n            class TestClass(object):\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def addteardown(self, item, request):\n                    values.append(\"setup-%d\" % item)\n                    request.addfinalizer(lambda: values.append(\"teardown-%d\" % item))\n                def test_step1(self, item):\n                    values.append(\"step1-%d\" % item)\n                def test_step2(self, item):\n                    values.append(\"step2-%d\" % item)\n\n            def test_finish():\n                print(values)\n                assert values == [\"setup-1\", \"step1-1\", \"step2-1\", \"teardown-1\",\n                             \"setup-2\", \"step1-2\", \"step2-2\", \"teardown-2\",]\n        \"\"\"\n        )\n        reprec = pytester.inline_run(\"-s\")\n        reprec.assertoutcome(passed=5)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.227609157562256}
{"question": "Where in Pytest is the fixture system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The fixture system in pytest is implemented primarily in the src/_pytest/fixtures.py module, which contains the core fixture functionality: 1) The FixtureManager class serves as the central manager for fixture definitions and information, handling fixture discovery, registration, and resolution, 2) The FixtureDef class represents individual fixture definitions, containing metadata about fixtures including their function, scope, parameters, and caching behavior, 3) The FixtureRequest class provides access to the requesting test context and fixture information during fixture execution, 4) The SubRequest class handles fixture execution within specific scopes and manages parameter passing for parametrized fixtures, 5) The FuncFixtureInfo class holds fixture-related information for test functions, including fixture names, dependencies, and closure calculations, 6) The fixture decorator function in src/_pytest/fixtures.py provides the @pytest.fixture decorator for defining fixtures, 7) The pytest_fixture_setup hook in src/_pytest/fixtures.py handles the actual execution of fixture functions, 8) Fixture resolution logic is implemented in methods like getfixtureclosure() which computes the transitive closure of fixture dependencies, 9) Fixture caching and scope management is handled through the FixtureDef.cached_result attribute and scope-based execution, 10) Fixture finalization and cleanup is managed through the finish() method in FixtureDef and finalizer registration, 11) The fixture system integrates with the plugin system through the PytestPluginManager, allowing fixtures to be defined in plugins and conftest files, 12) Fixture discovery and parsing occurs during collection through FixtureManager.parsefactories() which scans for fixture definitions in modules and plugins.", "score": null, "retrieved_content": [{"name": "FixtureManager", "docstring": "pytest fixture definitions and information is stored and managed\nfrom this class.\n\nDuring collection fm.parsefactories() is called multiple times to parse\nfixture function definitions into FixtureDef objects and internal\ndata structures.\n\nDuring collection of test functions, metafunc-mechanics instantiate\na FuncFixtureInfo object which is cached per node/func-name.\nThis FuncFixtureInfo object is later retrieved by Function nodes\nwhich themselves offer a fixturenames attribute.\n\nThe FuncFixtureInfo object holds information about fixtures and FixtureDefs\nrelevant for a particular function. An initial list of fixtures is\nassembled like this:\n\n- ini-defined usefixtures\n- autouse-marked fixtures along the collection chain up from the function\n- usefixtures markers at module/class/function level\n- test function funcargs\n\nSubsequently the funcfixtureinfo.fixturenames attribute is computed\nas the closure of the fixtures needed to setup the initial fixtures,\ni.e. fixtures needed by fixture functions themselves are appended\nto the fixturenames list.\n\nUpon the test-setup phases all fixturenames are instantiated, retrieved\nby a lookup of their FuncFixtureInfo.", "methods": ["__init__", "getfixtureinfo", "pytest_plugin_registered", "_getautousenames", "_getusefixturesnames", "getfixtureclosure", "pytest_generate_tests", "pytest_collection_modifyitems", "_register_fixture", "parsefactories", "parsefactories", "parsefactories", "getfixturedefs", "_matchfactories"], "attributes": [], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1501, "end_line": 1879}, "type": "class"}, {"name": "pytest_sessionstart", "is_method": false, "class_name": null, "parameters": ["session"], "calls": ["FixtureManager"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 119, "end_line": 120}, "code_snippet": "def pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestAutouseDiscovery", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1925, "end_line": 1949}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmp_path):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmp_path):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "test_pytestconfig_is_session_scoped", "is_method": false, "class_name": null, "parameters": [], "calls": ["getfixturemarker"], "code_location": {"file": "integration.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 266, "end_line": 271}, "code_snippet": "def test_pytestconfig_is_session_scoped() -> None:\n    from _pytest.fixtures import pytestconfig\n\n    marker = getfixturemarker(pytestconfig)\n    assert marker is not None\n    assert marker.scope == \"session\"\n", "type": "function"}, {"name": "pytester", "is_method": true, "class_name": "TestFixtureManagerParseFactories", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1685, "end_line": 1703}, "code_snippet": "    def pytester(self, pytester: Pytester) -> Pytester:\n        pytester.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"conftest\"\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return pytester\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TopRequest", "parameters": ["self", "pyfuncitem"], "calls": ["__init__", "super", "pyfuncitem._fixtureinfo.name2fixturedefs.copy"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 688, "end_line": 695}, "code_snippet": "    def __init__(self, pyfuncitem: Function, *, _ispytest: bool = False) -> None:\n        super().__init__(\n            fixturename=None,\n            pyfuncitem=pyfuncitem,\n            arg2fixturedefs=pyfuncitem._fixtureinfo.name2fixturedefs.copy(),\n            fixture_defs={},\n            _ispytest=_ispytest,\n        )\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FixtureDef", "parameters": ["self", "config", "baseid", "argname", "func", "scope", "params", "ids"], "calls": ["check_ispytest", "isinstance", "getfuncargnames", "callable", "Scope.from_user", "_eval_scope_callable"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 983, "end_line": 1043}, "code_snippet": "    def __init__(\n        self,\n        config: Config,\n        baseid: str | None,\n        argname: str,\n        func: _FixtureFunc[FixtureValue],\n        scope: Scope | _ScopeName | Callable[[str, Config], _ScopeName] | None,\n        params: Sequence[object] | None,\n        ids: tuple[object | None, ...] | Callable[[Any], object | None] | None = None,\n        *,\n        _ispytest: bool = False,\n        # only used in a deprecationwarning msg, can be removed in pytest9\n        _autouse: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        # The \"base\" node ID for the fixture.\n        #\n        # This is a node ID prefix. A fixture is only available to a node (e.g.\n        # a `Function` item) if the fixture's baseid is a nodeid of a parent of\n        # node.\n        #\n        # For a fixture found in a Collector's object (e.g. a `Module`s module,\n        # a `Class`'s class), the baseid is the Collector's nodeid.\n        #\n        # For a fixture found in a conftest plugin, the baseid is the conftest's\n        # directory path relative to the rootdir.\n        #\n        # For other plugins, the baseid is the empty string (always matches).\n        self.baseid: Final = baseid or \"\"\n        # Whether the fixture was found from a node or a conftest in the\n        # collection tree. Will be false for fixtures defined in non-conftest\n        # plugins.\n        self.has_location: Final = baseid is not None\n        # The fixture factory function.\n        self.func: Final = func\n        # The name by which the fixture may be requested.\n        self.argname: Final = argname\n        if scope is None:\n            scope = Scope.Function\n        elif callable(scope):\n            scope = _eval_scope_callable(scope, argname, config)\n        if isinstance(scope, str):\n            scope = Scope.from_user(\n                scope, descr=f\"Fixture '{func.__name__}'\", where=baseid\n            )\n        self._scope: Final = scope\n        # If the fixture is directly parametrized, the parameter values.\n        self.params: Final = params\n        # If the fixture is directly parametrized, a tuple of explicit IDs to\n        # assign to the parameter values, or a callable to generate an ID given\n        # a parameter value.\n        self.ids: Final = ids\n        # The names requested by the fixtures.\n        self.argnames: Final = getfuncargnames(func, name=argname)\n        # If the fixture was executed, the current value of the fixture.\n        # Can change if the fixture is executed with different parameters.\n        self.cached_result: _FixtureCachedResult[FixtureValue] | None = None\n        self._finalizers: Final[list[Callable[[], object]]] = []\n\n        # only used to emit a deprecationwarning, can be removed in pytest9\n        self._autouse = _autouse\n", "type": "function"}, {"name": "_showfixtures_main", "is_method": false, "class_name": null, "parameters": ["config", "session"], "calls": ["session.perform_collect", "_pytest.config.create_terminal_writer", "config.get_verbosity", "set", "fm._arg2fixturedefs.items", "available.sort", "tw.write", "tw.write", "tw.write", "inspect.getdoc", "tw.line", "getlocation", "seen.add", "available.append", "argname.startswith", "tw.write", "write_docstring", "tw.line", "module.startswith", "tw.line", "tw.sep", "len", "_pretty_fixture_path", "doc.split"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1959, "end_line": 2013}, "code_snippet": "def _showfixtures_main(config: Config, session: Session) -> None:\n    import _pytest.config\n\n    session.perform_collect()\n    invocation_dir = config.invocation_params.dir\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.get_verbosity()\n\n    fm = session._fixturemanager\n\n    available = []\n    seen: set[tuple[str, str]] = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, invocation_dir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    _pretty_fixture_path(invocation_dir, fixturedef.func),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, prettypath, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", f\"fixtures defined from {module}\")\n                currentmodule = module\n        if verbose <= 0 and argname.startswith(\"_\"):\n            continue\n        tw.write(f\"{argname}\", green=True)\n        if fixturedef.scope != \"function\":\n            tw.write(f\" [{fixturedef.scope} scope]\", cyan=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        doc = inspect.getdoc(fixturedef.func)\n        if doc:\n            write_docstring(\n                tw, doc.split(\"\\n\\n\", maxsplit=1)[0] if verbose <= 0 else doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n        tw.line()\n", "type": "function"}, {"name": "test_show_fixtures", "is_method": true, "class_name": "TestShowFixtures", "parameters": ["self", "pytester"], "calls": ["pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3580, "end_line": 3589}, "code_snippet": "    def test_show_fixtures(self, pytester: Pytester) -> None:\n        result = pytester.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmp_path_factory [[]session scope[]] -- .../_pytest/tmpdir.py:*\",\n                \"*for the test session*\",\n                \"tmp_path -- .../_pytest/tmpdir.py:*\",\n                \"*temporary directory*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_fixture_dependency", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makeconftest", "touch", "pytester.mkdir", "touch", "write_text", "sub.joinpath", "subsub.mkdir", "touch", "write_text", "pytester.runpytest", "result.stdout.fnmatch_lines", "textwrap.dedent", "textwrap.dedent", "pytester.path.joinpath", "sub.joinpath", "sub.joinpath", "subsub.joinpath", "subsub.joinpath"], "code_location": {"file": "test_conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 466, "end_line": 510}, "code_snippet": "def test_fixture_dependency(pytester: Pytester) -> None:\n    pytester.makeconftest(\"\")\n    pytester.path.joinpath(\"__init__.py\").touch()\n    sub = pytester.mkdir(\"sub\")\n    sub.joinpath(\"__init__.py\").touch()\n    sub.joinpath(\"conftest.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    subsub = sub.joinpath(\"subsub\")\n    subsub.mkdir()\n    subsub.joinpath(\"__init__.py\").touch()\n    subsub.joinpath(\"test_bar.py\").write_text(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        ),\n        encoding=\"utf-8\",\n    )\n    result = pytester.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.2190778255462646}
{"question": "How does Pytest implement its plugin architecture?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements its plugin architecture through a comprehensive hook-based system built on the pluggy library: 1) PytestPluginManager class that extends pluggy.PluginManager to handle pytest-specific plugin loading and discovery, 2) Hook specification system where all pytest functionality is defined through hook specifications in src/_pytest/hookspec.py using the @hookspec decorator, 3) Multiple plugin types including built-in plugins (stored in src/_pytest/), external plugins (discovered through entry points), and local conftest.py plugins (auto-discovered in test directories), 4) Plugin discovery order that loads plugins in a specific sequence: command line blocking, built-in plugins, external plugins, environment variables, and conftest files, 5) Hook implementation system where plugins implement hook functions with the @hookimpl decorator to provide functionality, 6) 1:N relationship where multiple plugins can implement the same hook specification, with execution order controlled by tryfirst/trylast markers, 7) Hook wrappers that execute around other hook implementations for cross-cutting functionality, 8) Plugin registration through entry points in pyproject.toml or setup.py for external plugins, 9) Local plugin support through conftest.py files that can be placed in any directory for directory-specific functionality, 10) Plugin communication through the config object and stash mechanism for sharing data between plugins, 11) Plugin validation and error handling with proper cleanup mechanisms, 12) Backward compatibility through dynamic argument pruning that allows new hook parameters without breaking existing implementations.", "score": null, "retrieved_content": [{"name": "PytestPluginManager", "docstring": "A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\nadditional pytest-specific functionality:\n\n* Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n  ``pytest_plugins`` global variables found in plugins being loaded.\n* ``conftest.py`` loading during start-up.", "methods": ["__init__", "parse_hookimpl_opts", "parse_hookspec_opts", "register", "getplugin", "hasplugin", "pytest_configure", "_set_initial_conftests", "_is_in_confcutdir", "_try_load_conftest", "_loadconftestmodules", "_getconftestmodules", "_rget_with_confmod", "_importconftest", "_check_non_top_pytest_plugins", "consider_preparse", "consider_pluginarg", "consider_conftest", "consider_env", "consider_module", "_import_plugin_specs", "import_plugin"], "attributes": [], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest/config", "start_line": 392, "end_line": 870}, "type": "class"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "pytestpm", "is_method": false, "class_name": null, "parameters": [], "calls": ["PytestPluginManager"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 21, "end_line": 22}, "code_snippet": "def pytestpm() -> PytestPluginManager:\n    return PytestPluginManager()\n", "type": "function"}, {"name": "test_pytest_collect_file", "is_method": true, "class_name": "TestCollectPluginHookRelay", "parameters": ["self", "pytester"], "calls": ["pytester.makefile", "pytest.main", "len", "file_path.name.startswith", "wascalled.append", "Plugin"], "code_location": {"file": "test_collection.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 281, "end_line": 293}, "code_snippet": "    def test_pytest_collect_file(self, pytester: Pytester) -> None:\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, file_path: Path) -> None:\n                if not file_path.name.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(file_path)\n\n        pytester.makefile(\".abc\", \"xyz\")\n        pytest.main(pytester.path, plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].suffix == \".abc\"\n", "type": "function"}, {"name": "test_invoke_plugin_api", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "capsys"], "calls": ["pytest.main", "capsys.readouterr", "parser.addoption", "MyPlugin"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 652, "end_line": 659}, "code_snippet": "    def test_invoke_plugin_api(self, capsys) -> None:\n        class MyPlugin:\n            def pytest_addoption(self, parser):\n                parser.addoption(\"--myopt\")\n\n        pytest.main([\"-h\"], plugins=[MyPlugin()])\n        out, err = capsys.readouterr()\n        assert \"--myopt\" in out\n", "type": "function"}, {"name": "pytest_plugin_registered", "is_method": true, "class_name": "FixtureManager", "parameters": ["self", "plugin", "plugin_name"], "calls": ["self.parsefactories", "plugin_name.endswith", "absolutepath", "str", "nodeid.replace", "conftestpath.parent.relative_to"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 1583, "end_line": 1605}, "code_snippet": "    def pytest_plugin_registered(self, plugin: _PluggyPlugin, plugin_name: str) -> None:\n        # Fixtures defined in conftest plugins are only visible to within the\n        # conftest's directory. This is unlike fixtures in non-conftest plugins\n        # which have global visibility. So for conftests, construct the base\n        # nodeid from the plugin name (which is the conftest path).\n        if plugin_name and plugin_name.endswith(\"conftest.py\"):\n            # Note: we explicitly do *not* use `plugin.__file__` here -- The\n            # difference is that plugin_name has the correct capitalization on\n            # case-insensitive systems (Windows) and other normalization issues\n            # (issue #11816).\n            conftestpath = absolutepath(plugin_name)\n            try:\n                nodeid = str(conftestpath.parent.relative_to(self.config.rootpath))\n            except ValueError:\n                nodeid = \"\"\n            if nodeid == \".\":\n                nodeid = \"\"\n            if os.sep != nodes.SEP:\n                nodeid = nodeid.replace(os.sep, nodes.SEP)\n        else:\n            nodeid = None\n\n        self.parsefactories(plugin, nodeid)\n", "type": "function"}, {"name": "test_pyfunc_call", "is_method": true, "class_name": "TestFunction", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "config.pluginmanager.register", "config.pluginmanager.register", "config.hook.pytest_runtest_setup", "config.hook.pytest_pyfunc_call", "MyPlugin1", "MyPlugin2"], "code_location": {"file": "collect.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 606, "end_line": 621}, "code_snippet": "    def test_pyfunc_call(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)\n", "type": "function"}, {"name": "pytest_plugin_registered", "is_method": false, "class_name": null, "parameters": ["plugin", "manager"], "calls": ["manager.get_plugin", "manager.register", "manager.is_registered"], "code_location": {"file": "legacypath.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 463, "end_line": 468}, "code_snippet": "def pytest_plugin_registered(plugin: object, manager: PytestPluginManager) -> None:\n    # pytester is not loaded by default and is commonly loaded from a conftest,\n    # so checking for it in `pytest_configure` is not enough.\n    is_pytester = plugin is manager.get_plugin(\"pytester\")\n    if is_pytester and not manager.is_registered(LegacyTestdirPlugin):\n        manager.register(LegacyTestdirPlugin, \"legacypath-pytester\")\n", "type": "function"}, {"name": "test_configure", "is_method": true, "class_name": "TestPytestPluginInteractions", "parameters": ["self", "pytester"], "calls": ["pytester.parseconfig", "config.pluginmanager.register", "config._do_configure", "config.pluginmanager.register", "config._ensure_unconfigure", "config.pluginmanager.register", "A", "len", "len", "A", "len", "A", "len", "values.append"], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 89, "end_line": 107}, "code_snippet": "    def test_configure(self, pytester: Pytester) -> None:\n        config = pytester.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2\n", "type": "function"}, {"name": "test_disable_plugin_autoload", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch", "enable_plugin_method", "disable_plugin_method"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "monkeypatch.setattr", "monkeypatch.setitem", "pytester.parseconfig", "monkeypatch.setenv", "monkeypatch.setenv", "PseudoPlugin", "config.pluginmanager.get_plugin", "platform.python_implementation", "DummyEntryPoint", "self.attrs_used.append", "object", "Distribution", "monkeypatch.delenv", "parse_args.append", "monkeypatch.delenv", "parse_args.extend", "bool", "bool"], "code_location": {"file": "test_config.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1320, "end_line": 1397}, "code_snippet": "def test_disable_plugin_autoload(\n    pytester: Pytester,\n    monkeypatch: MonkeyPatch,\n    enable_plugin_method: str,\n    disable_plugin_method: str,\n) -> None:\n    class DummyEntryPoint:\n        project_name = name = \"mytestplugin\"\n        group = \"pytest11\"\n        version = \"1.0\"\n\n        def load(self):\n            return sys.modules[self.name]\n\n    class Distribution:\n        metadata = {\"name\": \"foo\"}\n        entry_points = (DummyEntryPoint(),)\n        files = ()\n\n    class PseudoPlugin:\n        x = 42\n\n        attrs_used = []\n\n        def __getattr__(self, name):\n            assert name in (\"__loader__\", \"__spec__\")\n            self.attrs_used.append(name)\n            return object()\n\n    def distributions():\n        return (Distribution(),)\n\n    parse_args: list[str] = []\n\n    if disable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    elif disable_plugin_method == \"flag\":\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        parse_args.append(\"--disable-plugin-autoload\")\n    else:\n        assert disable_plugin_method == \"\"\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n\n    if enable_plugin_method == \"env_var\":\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n    elif enable_plugin_method == \"flag\":\n        parse_args.extend([\"-p\", \"mytestplugin\"])\n    else:\n        assert enable_plugin_method == \"\"\n\n    monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n    monkeypatch.setitem(sys.modules, \"mytestplugin\", PseudoPlugin())\n    config = pytester.parseconfig(*parse_args)\n\n    has_loaded = config.pluginmanager.get_plugin(\"mytestplugin\") is not None\n    # it should load if it's enabled, or we haven't disabled autoloading\n    assert has_loaded == (bool(enable_plugin_method) or not disable_plugin_method)\n\n    # The reason for the discrepancy between 'has_loaded' and __loader__ being accessed\n    # appears to be the monkeypatching of importlib.metadata.distributions; where\n    # files being empty means that _mark_plugins_for_rewrite doesn't find the plugin.\n    # But enable_method==flag ends up in mark_rewrite being called and __loader__\n    # being accessed.\n    assert (\"__loader__\" in PseudoPlugin.attrs_used) == (\n        has_loaded\n        and not (enable_plugin_method in (\"env_var\", \"\") and not disable_plugin_method)\n    )\n\n    # __spec__ is accessed in AssertionRewritingHook.exec_module, which would be\n    # eventually called if we did a full pytest run; but it's only accessed with\n    # enable_plugin_method==\"env_var\" because that will early-load it.\n    # Except when autoloads aren't disabled, in which case PytestPluginManager.import_plugin\n    # bails out before importing it.. because it knows it'll be loaded later?\n    # The above seems a bit weird, but I *think* it's true.\n    if platform.python_implementation() != \"PyPy\":\n        assert (\"__spec__\" in PseudoPlugin.attrs_used) == bool(\n            enable_plugin_method == \"env_var\" and disable_plugin_method\n        )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7938716411590576}
{"question": "How does Pytest implement its reporting system?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest implements its reporting system through a comprehensive hook-based architecture that captures and presents test execution results: 1) BaseReport class in src/_pytest/reports.py that serves as the foundation for all report types with common attributes like outcome, longrepr, sections, and nodeid, 2) TestReport class that extends BaseReport to represent individual test execution results with specific attributes like location, keywords, when (setup/call/teardown), and user_properties, 3) Hook-based reporting through pytest_runtest_logreport hook that is called for each test phase (setup, call, teardown) to generate and distribute reports, 4) Terminal reporting through TerminalReporter class that formats and displays reports in the console with configurable output styles and verbosity levels, 5) Report serialization through pytest_report_to_serializable and pytest_report_from_serializable hooks for storing and transmitting reports, 6) Capture integration where reports include sections for captured stdout, stderr, and log output through the sections attribute, 7) Exception handling where failed tests include detailed exception information in the longrepr attribute with traceback formatting, 8) Status reporting through pytest_report_teststatus hook that allows plugins to customize how test outcomes are displayed, 9) Summary reporting through pytest_terminal_summary hook that generates final test execution summaries, 10) Plugin extensibility where custom plugins can implement reporting hooks to add their own report types or modify existing ones, 11) JUnit XML reporting through the junitxml plugin that generates XML reports compatible with CI/CD systems, 12) Integration with the test execution protocol where reports are generated at each phase of test execution and can be intercepted or modified by plugins.", "score": null, "retrieved_content": [{"name": "pytest_runtest_makereport", "is_method": false, "class_name": null, "parameters": ["item", "call"], "calls": ["TestReport.from_item_and_call"], "code_location": {"file": "runner.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 367, "end_line": 368}, "code_snippet": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\n", "type": "function"}, {"name": "test_pass_extra_reporting", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.no_fnmatch_line", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1257, "end_line": 1262}, "code_snippet": "def test_pass_extra_reporting(pytester: Pytester) -> None:\n    pytester.makepyfile(\"def test_this(): assert 1\")\n    result = pytester.runpytest()\n    result.stdout.no_fnmatch_line(\"*short test summary*\")\n    result = pytester.runpytest(\"-rp\")\n    result.stdout.fnmatch_lines([\"*test summary*\", \"PASS*test_pass_extra_reporting*\"])\n", "type": "function"}, {"name": "test_getreportopt", "is_method": false, "class_name": null, "parameters": [], "calls": ["cast", "Option", "FakeConfig", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt", "getreportopt"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1400, "end_line": 1456}, "code_snippet": "def test_getreportopt() -> None:\n    from _pytest.terminal import _REPORTCHARS_DEFAULT\n\n    class FakeConfig:\n        class Option:\n            reportchars = _REPORTCHARS_DEFAULT\n            disable_warnings = False\n\n        option = Option()\n\n    config = cast(Config, FakeConfig())\n\n    assert _REPORTCHARS_DEFAULT == \"fE\"\n\n    # Default.\n    assert getreportopt(config) == \"wfE\"\n\n    config.option.reportchars = \"sf\"\n    assert getreportopt(config) == \"wsf\"\n\n    config.option.reportchars = \"sfxw\"\n    assert getreportopt(config) == \"sfxw\"\n\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"wsxXEf\"\n\n    config.option.reportchars = \"N\"\n    assert getreportopt(config) == \"w\"\n\n    config.option.reportchars = \"NwfE\"\n    assert getreportopt(config) == \"wfE\"\n\n    config.option.reportchars = \"NfENx\"\n    assert getreportopt(config) == \"wx\"\n\n    # Now with --disable-warnings.\n    config.option.disable_warnings = True\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"sxXEf\"\n\n    config.option.reportchars = \"sfx\"\n    assert getreportopt(config) == \"sfx\"\n\n    config.option.reportchars = \"sfxw\"\n    assert getreportopt(config) == \"sfx\"\n\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"sxXEf\"\n\n    config.option.reportchars = \"A\"\n    assert getreportopt(config) == \"PpsxXEf\"\n\n    config.option.reportchars = \"AN\"\n    assert getreportopt(config) == \"\"\n\n    config.option.reportchars = \"NwfE\"\n    assert getreportopt(config) == \"fE\"\n", "type": "function"}, {"name": "test_test_report", "is_method": true, "class_name": "TestHooks", "parameters": ["self", "pytester", "pytestconfig"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.getreports", "len", "pytestconfig.hook.pytest_report_to_serializable", "pytestconfig.hook.pytest_report_from_serializable"], "code_location": {"file": "test_reports.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 443, "end_line": 463}, "code_snippet": "    def test_test_report(self, pytester: Pytester, pytestconfig: Config) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_a(): assert False\n            def test_b(): pass\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 6\n        for rep in reports:\n            data = pytestconfig.hook.pytest_report_to_serializable(\n                config=pytestconfig, report=rep\n            )\n            assert data[\"$report_type\"] == \"TestReport\"\n            new_rep = pytestconfig.hook.pytest_report_from_serializable(\n                config=pytestconfig, data=data\n            )\n            assert new_rep.nodeid == rep.nodeid\n            assert new_rep.when == rep.when\n            assert new_rep.outcome == rep.outcome\n", "type": "function"}, {"name": "test_pass_reporting_on_fail", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.no_fnmatch_line"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1265, "end_line": 1268}, "code_snippet": "def test_pass_reporting_on_fail(pytester: Pytester) -> None:\n    pytester.makepyfile(\"def test_this(): assert 0\")\n    result = pytester.runpytest(\"-rp\")\n    result.stdout.no_fnmatch_line(\"*short test summary*\")\n", "type": "function"}, {"name": "pytest_configure", "is_method": false, "class_name": null, "parameters": ["config"], "calls": ["TerminalReporter", "config.pluginmanager.register", "config.trace.root.setprocessor", "join", "reporter.write_line", "map"], "code_location": {"file": "terminal.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 287, "end_line": 296}, "code_snippet": "def pytest_configure(config: Config) -> None:\n    reporter = TerminalReporter(config, sys.stdout)\n    config.pluginmanager.register(reporter, \"terminalreporter\")\n    if config.option.debug or config.option.traceconfig:\n\n        def mywriter(tags, args):\n            msg = \" \".join(map(str, args))\n            reporter.write_line(\"[traceconfig] \" + msg)\n\n        config.trace.root.setprocessor(\"pytest:config\", mywriter)\n", "type": "function"}, {"name": "test_pass_output_reporting", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.str", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_terminal.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1271, "end_line": 1308}, "code_snippet": "def test_pass_output_reporting(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        def setup_module():\n            print(\"setup_module\")\n\n        def teardown_module():\n            print(\"teardown_module\")\n\n        def test_pass_has_output():\n            print(\"Four score and seven years ago...\")\n\n        def test_pass_no_output():\n            pass\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    s = result.stdout.str()\n    assert \"test_pass_has_output\" not in s\n    assert \"Four score and seven years ago...\" not in s\n    assert \"test_pass_no_output\" not in s\n    result = pytester.runpytest(\"-rPp\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*= PASSES =*\",\n            \"*_ test_pass_has_output _*\",\n            \"*- Captured stdout setup -*\",\n            \"setup_module\",\n            \"*- Captured stdout call -*\",\n            \"Four score and seven years ago...\",\n            \"*- Captured stdout teardown -*\",\n            \"teardown_module\",\n            \"*= short test summary info =*\",\n            \"PASSED test_pass_output_reporting.py::test_pass_has_output\",\n            \"PASSED test_pass_output_reporting.py::test_pass_no_output\",\n            \"*= 2 passed in *\",\n        ]\n    )\n", "type": "function"}, {"name": "test_make_hook_recorder", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.getitem", "pytester.make_hook_recorder", "recorder.hook.pytest_runtest_logreport", "recorder.getfailures", "recorder.getfailures", "recorder.hook.pytest_runtest_logreport", "pytester.getmodulecol", "modcol.config.hook.pytest_make_collect_report", "recorder.hook.pytest_collectreport", "recorder.listoutcomes", "recorder.countoutcomes", "recorder.unregister", "recorder.clear", "recorder.hook.pytest_runtest_logreport", "pytest.raises", "recorder.getfailures", "pytest.xfail", "len", "recorder.getfailedcollections"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 22, "end_line": 74}, "code_snippet": "def test_make_hook_recorder(pytester: Pytester) -> None:\n    item = pytester.getitem(\"def test_func(): pass\")\n    recorder = pytester.make_hook_recorder(item.config.pluginmanager)\n    assert not recorder.getfailures()\n\n    # (The silly condition is to fool mypy that the code below this is reachable)\n    if 1 + 1 == 2:\n        pytest.xfail(\"internal reportrecorder tests need refactoring\")\n\n    class rep:\n        excinfo = None\n        passed = False\n        failed = True\n        skipped = False\n        when = \"call\"\n\n    recorder.hook.pytest_runtest_logreport(report=rep)  # type: ignore[attr-defined]\n    failures = recorder.getfailures()\n    assert failures == [rep]  # type: ignore[comparison-overlap]\n    failures = recorder.getfailures()\n    assert failures == [rep]  # type: ignore[comparison-overlap]\n\n    class rep2:\n        excinfo = None\n        passed = False\n        failed = False\n        skipped = True\n        when = \"call\"\n\n    rep2.passed = False\n    rep2.skipped = True\n    recorder.hook.pytest_runtest_logreport(report=rep2)  # type: ignore[attr-defined]\n\n    modcol = pytester.getmodulecol(\"\")\n    rep3 = modcol.config.hook.pytest_make_collect_report(collector=modcol)\n    rep3.passed = False\n    rep3.failed = True\n    rep3.skipped = False\n    recorder.hook.pytest_collectreport(report=rep3)  # type: ignore[attr-defined]\n\n    passed, skipped, failed = recorder.listoutcomes()\n    assert not passed and skipped and failed\n\n    numpassed, numskipped, numfailed = recorder.countoutcomes()\n    assert numpassed == 0\n    assert numskipped == 1\n    assert numfailed == 1\n    assert len(recorder.getfailedcollections()) == 1\n\n    recorder.unregister()  # type: ignore[attr-defined]\n    recorder.clear()\n    recorder.hook.pytest_runtest_logreport(report=rep3)  # type: ignore[attr-defined]\n    pytest.raises(ValueError, recorder.getfailures)\n", "type": "function"}, {"name": "test_collect_report", "is_method": true, "class_name": "TestHooks", "parameters": ["self", "pytester", "pytestconfig"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.getreports", "len", "pytestconfig.hook.pytest_report_to_serializable", "pytestconfig.hook.pytest_report_from_serializable"], "code_location": {"file": "test_reports.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 465, "end_line": 485}, "code_snippet": "    def test_collect_report(self, pytester: Pytester, pytestconfig: Config) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_a(): assert False\n            def test_b(): pass\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reports = reprec.getreports(\"pytest_collectreport\")\n        assert len(reports) == 3\n        for rep in reports:\n            data = pytestconfig.hook.pytest_report_to_serializable(\n                config=pytestconfig, report=rep\n            )\n            assert data[\"$report_type\"] == \"CollectReport\"\n            new_rep = pytestconfig.hook.pytest_report_from_serializable(\n                config=pytestconfig, data=data\n            )\n            assert new_rep.nodeid == rep.nodeid\n            assert new_rep.when == \"collect\"\n            assert new_rep.outcome == rep.outcome\n", "type": "function"}, {"name": "getreports", "is_method": true, "class_name": "HookRecorder", "parameters": ["self", "names"], "calls": [], "code_location": {"file": "pytester.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 330, "end_line": 333}, "code_snippet": "    def getreports(\n        self,\n        names: Literal[\"pytest_runtest_logreport\"],\n    ) -> Sequence[TestReport]: ...\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7799923419952393}
{"question": "How does Pytest support testing asynchronous code using the asyncio framework?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest does not natively support testing asynchronous code using the asyncio framework, but provides integration points for third-party plugins. The core implementation includes: 1) Detection of async test functions through the is_async_function() helper that checks for coroutine functions and async generator functions, 2) The pytest_pyfunc_call hook that detects async functions and calls async_fail() to provide helpful error messages, 3) Integration with external async testing plugins like pytest-asyncio, pytest-trio, pytest-twisted, and anyio that handle async test execution, 4) Support for async fixtures through plugins that can handle async fixture setup and teardown, 5) Warning system for sync tests that depend on async fixtures without proper plugin support, 6) Configuration options like asyncio_mode in pytest.ini for plugin-specific settings, 7) Integration with unittest's IsolatedAsyncioTestCase for async test support in unittest-style tests, 8) Error messages that guide users to install appropriate async testing plugins, 9) Support for async test functions in plugin integration tests using @pytest.mark.asyncio decorator, 10) Deprecation warnings for sync tests using async fixtures without proper handling, 11) Plugin architecture that allows async frameworks to register their own test execution hooks, 12) Integration with the test execution protocol where async plugins can intercept and handle async test execution.", "score": null, "retrieved_content": [{"name": "test_async_support", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytest.importorskip", "pytester.copy_example", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1317, "end_line": 1322}, "code_snippet": "def test_async_support(pytester: Pytester) -> None:\n    pytest.importorskip(\"unittest.async_case\")\n\n    pytester.copy_example(\"unittest/test_unittest_asyncio.py\")\n    reprec = pytester.inline_run()\n    reprec.assertoutcome(failed=1, passed=2)\n", "type": "function"}, {"name": "test_error_on_async_function", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "result.assert_outcomes"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1260, "end_line": 1285}, "code_snippet": "def test_error_on_async_function(pytester: Pytester) -> None:\n    # In the below we .close() the coroutine only to avoid\n    # \"RuntimeWarning: coroutine 'test_2' was never awaited\"\n    # which messes with other tests.\n    pytester.makepyfile(\n        test_async=\"\"\"\n        async def test_1():\n            pass\n        async def test_2():\n            pass\n        def test_3():\n            coro = test_2()\n            coro.close()\n            return coro\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*async def functions are not natively supported*\",\n            \"*test_async.py::test_1*\",\n            \"*test_async.py::test_2*\",\n            \"*test_async.py::test_3*\",\n        ]\n    )\n    result.assert_outcomes(failed=3)\n", "type": "function"}, {"name": "test_error_on_async_gen_function", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines", "result.assert_outcomes"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1288, "end_line": 1308}, "code_snippet": "def test_error_on_async_gen_function(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        test_async=\"\"\"\n        async def test_1():\n            yield\n        async def test_2():\n            yield\n        def test_3():\n            return test_2()\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*async def functions are not natively supported*\",\n            \"*test_async.py::test_1*\",\n            \"*test_async.py::test_2*\",\n            \"*test_async.py::test_3*\",\n        ]\n    )\n    result.assert_outcomes(failed=3)\n", "type": "function"}, {"name": "async_fail", "is_method": false, "class_name": null, "parameters": ["nodeid"], "calls": ["fail"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 137, "end_line": 147}, "code_snippet": "def async_fail(nodeid: str) -> None:\n    msg = (\n        \"async def functions are not natively supported.\\n\"\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n        \"  - anyio\\n\"\n        \"  - pytest-asyncio\\n\"\n        \"  - pytest-tornasync\\n\"\n        \"  - pytest-trio\\n\"\n        \"  - pytest-twisted\"\n    )\n    fail(msg, pytrace=False)\n", "type": "function"}, {"name": "pytest_pyfunc_call", "is_method": false, "class_name": null, "parameters": ["pyfuncitem"], "calls": ["hookimpl", "is_async_function", "testfunction", "async_fail", "hasattr", "hasattr", "async_fail", "warnings.warn", "PytestReturnNotNoneWarning", "type"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 151, "end_line": 168}, "code_snippet": "def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_fail(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_fail(pyfuncitem.nodeid)\n    elif result is not None:\n        warnings.warn(\n            PytestReturnNotNoneWarning(\n                f\"Test functions should return None, but {pyfuncitem.nodeid} returned {type(result)!r}.\\n\"\n                \"Did you mean to use `assert` instead of `return`?\\n\"\n                \"See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.\"\n            )\n        )\n    return True\n", "type": "function"}, {"name": "test_asynctest_support", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytest.importorskip", "pytester.copy_example", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1325, "end_line": 1331}, "code_snippet": "def test_asynctest_support(pytester: Pytester) -> None:\n    \"\"\"Check asynctest support (#7110)\"\"\"\n    pytest.importorskip(\"asynctest\")\n\n    pytester.copy_example(\"unittest/test_unittest_asynctest.py\")\n    reprec = pytester.inline_run()\n    reprec.assertoutcome(failed=1, passed=2)\n", "type": "function"}, {"name": "test_plain_unittest_does_not_support_async", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.copy_example", "pytester.runpytest_subprocess", "hasattr", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1334, "end_line": 1354}, "code_snippet": "def test_plain_unittest_does_not_support_async(pytester: Pytester) -> None:\n    \"\"\"Async functions in plain unittest.TestCase subclasses are not supported without plugins.\n\n    This test exists here to avoid introducing this support by accident, leading users\n    to expect that it works, rather than doing so intentionally as a feature.\n\n    See https://github.com/pytest-dev/pytest-asyncio/issues/180 for more context.\n    \"\"\"\n    pytester.copy_example(\"unittest/test_unittest_plain_async.py\")\n    result = pytester.runpytest_subprocess()\n    if hasattr(sys, \"pypy_version_info\"):\n        # in PyPy we can't reliable get the warning about the coroutine not being awaited,\n        # because it depends on the coroutine being garbage collected; given that\n        # we are running in a subprocess, that's difficult to enforce\n        expected_lines = [\"*1 passed*\"]\n    else:\n        expected_lines = [\n            \"*RuntimeWarning: coroutine * was never awaited\",\n            \"*1 passed*\",\n        ]\n    result.stdout.fnmatch_lines(expected_lines)\n", "type": "function"}, {"name": "runtest", "is_method": true, "class_name": "TestCaseFunction", "parameters": ["self"], "calls": ["maybe_wrap_pytest_function_for_tracing", "is_async_function", "testcase", "isinstance", "setattr", "_is_skipped", "_is_skipped", "self.config.getoption", "setattr", "testcase", "delattr"], "code_location": {"file": "unittest.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 322, "end_line": 353}, "code_snippet": "    def runtest(self) -> None:\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        testcase = self.instance\n        assert testcase is not None\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # Let the unittest framework handle async functions.\n        if is_async_function(self.obj):\n            testcase(result=self)\n        else:\n            # When --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug.\n            # Arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed.\n            # We need to consider if the test itself is skipped, or the whole class.\n            assert isinstance(self.parent, UnitTestCase)\n            skipped = _is_skipped(self.obj) or _is_skipped(self.parent.obj)\n            if self.config.getoption(\"usepdb\") and not skipped:\n                self._explicit_tearDown = testcase.tearDown\n                setattr(testcase, \"tearDown\", lambda *args: None)\n\n            # We need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n            setattr(testcase, self.name, self.obj)\n            try:\n                testcase(result=self)\n            finally:\n                delattr(testcase, self.name)\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 161, "end_line": 163}, "code_snippet": "def pytester(pytester: Pytester, monkeypatch: MonkeyPatch) -> Pytester:\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return pytester\n", "type": "function"}, {"name": "test_pytester_subprocess_via_runpytest_arg", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_inprocess"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 418, "end_line": 436}, "code_snippet": "def test_pytester_subprocess_via_runpytest_arg(pytester: Pytester) -> None:\n    testfile = pytester.makepyfile(\n        \"\"\"\n        def test_pytester_subprocess(pytester):\n            import os\n            testfile = pytester.makepyfile(\n                \\\"\"\"\n                import os\n                def test_one():\n                    assert {} != os.getpid()\n                \\\"\"\".format(os.getpid())\n            )\n            assert pytester.runpytest(testfile).ret == 0\n        \"\"\"\n    )\n    result = pytester.runpytest_inprocess(\n        \"-p\", \"pytester\", \"--runpytest\", \"subprocess\", testfile\n    )\n    assert result.ret == 0\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7701315879821777}
{"question": "How does Pytest integrate with Django for testing web applications?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest integrates with Django for testing web applications through the pytest-django plugin, which is a third-party plugin that provides seamless integration. The integration includes: 1) Installation of pytest-django plugin that extends pytest's functionality for Django applications, 2) Configuration through Django settings using --ds command-line option to specify Django settings module, 3) Automatic Django setup and teardown for test sessions including database configuration and management, 4) Integration with Django's test client for making HTTP requests and testing views, 5) Support for Django fixtures and model testing with automatic database transaction management, 6) Integration with Django's ORM for database operations during testing, 7) Support for Django's middleware and authentication systems in test environment, 8) Configuration options in pytest.ini or pyproject.toml for Django-specific settings, 9) Integration with Django's test discovery and test runner compatibility, 10) Support for Django's static files and media handling during tests, 11) Integration with Django's cache and session management for testing, 12) Plugin architecture that allows pytest-django to hook into pytest's test execution lifecycle.", "score": null, "retrieved_content": [{"name": "test_djangolike_testcase", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_unittest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 676, "end_line": 731}, "code_snippet": "def test_djangolike_testcase(pytester: Pytester) -> None:\n    # contributed from Morten Breekevold\n    pytester.makepyfile(\n        \"\"\"\n        from unittest import TestCase, main\n\n        class DjangoLikeTestCase(TestCase):\n\n            def setUp(self):\n                print(\"setUp()\")\n\n            def test_presetup_has_been_run(self):\n                print(\"test_thing()\")\n                self.assertTrue(hasattr(self, 'was_presetup'))\n\n            def tearDown(self):\n                print(\"tearDown()\")\n\n            def __call__(self, result=None):\n                try:\n                    self._pre_setup()\n                except (KeyboardInterrupt, SystemExit):\n                    raise\n                except Exception:\n                    import sys\n                    result.addError(self, sys.exc_info())\n                    return\n                super(DjangoLikeTestCase, self).__call__(result)\n                try:\n                    self._post_teardown()\n                except (KeyboardInterrupt, SystemExit):\n                    raise\n                except Exception:\n                    import sys\n                    result.addError(self, sys.exc_info())\n                    return\n\n            def _pre_setup(self):\n                print(\"_pre_setup()\")\n                self.was_presetup = True\n\n            def _post_teardown(self):\n                print(\"_post_teardown()\")\n    \"\"\"\n    )\n    result = pytester.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*_pre_setup()*\",\n            \"*setUp()*\",\n            \"*test_thing()*\",\n            \"*tearDown()*\",\n            \"*_post_teardown()*\",\n        ]\n    )\n", "type": "function"}, {"name": "test_python_pytest_package", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.run", "res.stdout.fnmatch_lines", "str"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 635, "end_line": 639}, "code_snippet": "    def test_python_pytest_package(self, pytester: Pytester) -> None:\n        p1 = pytester.makepyfile(\"def test_pass(): pass\")\n        res = pytester.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_PYTEST_DEBUG", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv", "pytester.runpytest_subprocess", "result.stderr.fnmatch_lines"], "code_location": {"file": "test_helpconfig.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 123, "end_line": 129}, "code_snippet": "def test_PYTEST_DEBUG(pytester: Pytester, monkeypatch) -> None:\n    monkeypatch.setenv(\"PYTEST_DEBUG\", \"1\")\n    result = pytester.runpytest_subprocess()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n    result.stderr.fnmatch_lines(\n        [\"*pytest_plugin_registered*\", \"*manager*PluginManager*\"]\n    )\n", "type": "function"}, {"name": "TestPytestPluginManagerBootstrapping", "docstring": "", "methods": ["test_preparse_args", "test_plugin_prevent_register", "test_plugin_prevent_register_unregistered_already_registered", "test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "test_blocked_plugin_can_be_used"], "attributes": [], "code_location": {"file": "test_pluginmanager.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 424, "end_line": 483}, "type": "class"}, {"name": "test_pytest_exit", "is_method": false, "class_name": null, "parameters": [], "calls": ["excinfo.errisinstance", "pytest.raises", "pytest.exit"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 615, "end_line": 618}, "code_snippet": "def test_pytest_exit() -> None:\n    with pytest.raises(pytest.exit.Exception) as excinfo:\n        pytest.exit(\"hello\")\n    assert excinfo.errisinstance(pytest.exit.Exception)\n", "type": "function"}, {"name": "pytester", "is_method": false, "class_name": null, "parameters": ["pytester", "monkeypatch"], "calls": ["monkeypatch.setenv"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 161, "end_line": 163}, "code_snippet": "def pytester(pytester: Pytester, monkeypatch: MonkeyPatch) -> Pytester:\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return pytester\n", "type": "function"}, {"name": "test_pytester_runs_with_plugin", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.assert_outcomes"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 83, "end_line": 92}, "code_snippet": "def test_pytester_runs_with_plugin(pytester: Pytester) -> None:\n    pytester.makepyfile(\n        \"\"\"\n        pytest_plugins = \"pytester\"\n        def test_hello(pytester):\n            assert 1\n    \"\"\"\n    )\n    result = pytester.runpytest()\n    result.assert_outcomes(passed=1)\n", "type": "function"}, {"name": "test_pytester_subprocess_via_runpytest_arg", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest_inprocess"], "code_location": {"file": "test_pytester.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 418, "end_line": 436}, "code_snippet": "def test_pytester_subprocess_via_runpytest_arg(pytester: Pytester) -> None:\n    testfile = pytester.makepyfile(\n        \"\"\"\n        def test_pytester_subprocess(pytester):\n            import os\n            testfile = pytester.makepyfile(\n                \\\"\"\"\n                import os\n                def test_one():\n                    assert {} != os.getpid()\n                \\\"\"\".format(os.getpid())\n            )\n            assert pytester.runpytest(testfile).ret == 0\n        \"\"\"\n    )\n    result = pytester.runpytest_inprocess(\n        \"-p\", \"pytester\", \"--runpytest\", \"subprocess\", testfile\n    )\n    assert result.ret == 0\n", "type": "function"}, {"name": "test_pytest_assertrepr_compare_integration", "is_method": true, "class_name": "TestSetAssertions", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 1636, "end_line": 1655}, "code_snippet": "    def test_pytest_assertrepr_compare_integration(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            def test_hello():\n                x = set(range(100))\n                y = x.copy()\n                y.remove(50)\n                assert x == y\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*def test_hello():*\",\n                \"*assert x == y*\",\n                \"*E*Extra items*left*\",\n                \"*E*50*\",\n                \"*= 1 failed in*\",\n            ]\n        )\n", "type": "function"}, {"name": "test_installed_plugin_rewrite", "is_method": true, "class_name": "TestImportHookInstallation", "parameters": ["self", "pytester", "mode", "monkeypatch", "disable_plugin_autoload", "explicit_specify"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytester.mkdir", "pytester.makepyfile", "pytester.run", "monkeypatch.setenv", "monkeypatch.setenv", "result.assert_outcomes", "result.stdout.fnmatch_lines", "result.assert_outcomes", "result.stdout.fnmatch_lines", "monkeypatch.delenv", "args.append", "monkeypatch.delenv", "args.append", "args.append"], "code_location": {"file": "test_assertion.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 223, "end_line": 326}, "code_snippet": "    def test_installed_plugin_rewrite(\n        self,\n        pytester: Pytester,\n        mode: str,\n        monkeypatch: pytest.MonkeyPatch,\n        disable_plugin_autoload: str,\n        explicit_specify: str,\n    ) -> None:\n        args = [\"mainwrapper.py\", \"-s\", f\"--assert={mode}\"]\n        if disable_plugin_autoload == \"env_var\":\n            monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n        elif disable_plugin_autoload == \"cli\":\n            monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n            args.append(\"--disable-plugin-autoload\")\n        else:\n            assert disable_plugin_autoload == \"\"\n            monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n        name = \"spamplugin\"\n\n        if explicit_specify == \"env_var\":\n            monkeypatch.setenv(\"PYTEST_PLUGINS\", name)\n        elif explicit_specify == \"cli\":\n            args.append(\"-p\")\n            args.append(name)\n        else:\n            assert explicit_specify == \"\"\n\n        # Make sure the hook is installed early enough so that plugins\n        # installed via distribution package are rewritten.\n        pytester.mkdir(\"hampkg\")\n        contents = {\n            \"hampkg/__init__.py\": \"\"\"\\\n                import pytest\n\n                @pytest.fixture\n                def check_first2():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"spamplugin.py\": \"\"\"\\\n            import pytest\n            from hampkg import check_first2\n\n            @pytest.fixture\n            def check_first():\n                def check(values, value):\n                    assert values.pop(0) == value\n                return check\n            \"\"\",\n            \"mainwrapper.py\": \"\"\"\\\n            import importlib.metadata\n            import pytest\n\n            class DummyEntryPoint(object):\n                name = 'spamplugin'\n                module_name = 'spam.py'\n                group = 'pytest11'\n\n                def load(self):\n                    import spamplugin\n                    return spamplugin\n\n            class DummyDistInfo(object):\n                version = '1.0'\n                files = ('spamplugin.py', 'hampkg/__init__.py')\n                entry_points = (DummyEntryPoint(),)\n                metadata = {'name': 'foo'}\n\n            def distributions():\n                return (DummyDistInfo(),)\n\n            importlib.metadata.distributions = distributions\n            pytest.main()\n            \"\"\",\n            \"test_foo.py\": \"\"\"\\\n            def test(check_first):\n                check_first([10, 30], 30)\n\n            def test2(check_first2):\n                check_first2([10, 30], 30)\n            \"\"\",\n        }\n        pytester.makepyfile(**contents)\n        result = pytester.run(sys.executable, *args)\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n\n        if not disable_plugin_autoload or explicit_specify:\n            result.assert_outcomes(failed=2)\n            result.stdout.fnmatch_lines([expected, expected])\n        else:\n            result.assert_outcomes(errors=2)\n            result.stdout.fnmatch_lines(\n                [\n                    \"E       fixture 'check_first' not found\",\n                    \"E       fixture 'check_first2' not found\",\n                ]\n            )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7426400184631348}
{"question": "How does Pytest facilitate testing RESTful APIs with the requests library?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest facilitates testing RESTful APIs with the requests library through several built-in mechanisms: 1) The monkeypatch fixture that allows mocking of requests.get, requests.post, and other HTTP methods to return controlled test responses, 2) MockResponse class pattern for creating custom response objects that simulate requests.Response behavior with methods like json() and properties like status_code, 3) Automatic cleanup of monkeypatched requests methods after each test to prevent test pollution, 4) Fixture-based mocking where requests methods can be mocked globally using autouse fixtures in conftest.py, 5) Context-based patching using monkeypatch.context() for scoped mocking of requests functionality, 6) Integration with pytest's assertion system for validating API response data, status codes, and headers, 7) Support for testing different HTTP methods (GET, POST, PUT, DELETE) through targeted mocking, 8) Error handling testing by mocking requests to raise exceptions like ConnectionError or HTTPError, 9) Parameterized testing support for testing multiple API endpoints with different request parameters, 10) Integration with pytest's test discovery and execution for organizing API tests, 11) Support for testing authentication and headers through mock response configuration, 12) Global request prevention using monkeypatch.delattr() to block all HTTP requests during testing.", "score": null, "retrieved_content": [{"name": "test_request_getmodulepath", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.getmodulecol", "pytester.genitems", "isinstance", "TopRequest"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1004, "end_line": 1009}, "code_snippet": "    def test_request_getmodulepath(self, pytester: Pytester) -> None:\n        modcol = pytester.getmodulecol(\"def test_somefunc(): pass\")\n        (item,) = pytester.genitems([modcol])\n        assert isinstance(item, Function)\n        req = TopRequest(item, _ispytest=True)\n        assert req.path == modcol.path\n", "type": "function"}, {"name": "test_request_attributes", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.getitem", "isinstance", "TopRequest", "hasattr", "find", "repr"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 680, "end_line": 698}, "code_snippet": "    def test_request_attributes(self, pytester: Pytester) -> None:\n        item = pytester.getitem(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def something(request): pass\n            def test_func(something): pass\n        \"\"\"\n        )\n        assert isinstance(item, Function)\n        req = TopRequest(item, _ispytest=True)\n        assert req.function == item.obj\n        assert req.keywords == item.keywords\n        assert hasattr(req.module, \"test_func\")\n        assert req.cls is None\n        assert req.function.__name__ == \"test_func\"\n        assert req.config == item.config\n        assert repr(req).find(req.function.__name__) != -1\n", "type": "function"}, {"name": "test_newstyle_with_request", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1103, "end_line": 1115}, "code_snippet": "    def test_newstyle_with_request(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def arg(request):\n                pass\n            def test_1(arg):\n                pass\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=1)\n", "type": "function"}, {"name": "test_fixture_named_request", "is_method": false, "class_name": null, "parameters": ["pytester"], "calls": ["pytester.copy_example", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 4656, "end_line": 4664}, "code_snippet": "def test_fixture_named_request(pytester: Pytester) -> None:\n    pytester.copy_example(\"fixtures/test_fixture_named_request.py\")\n    result = pytester.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*'request' is a reserved word for fixtures, use another name:\",\n            \"  *test_fixture_named_request.py:8\",\n        ]\n    )\n", "type": "function"}, {"name": "test_pytest_exit", "is_method": false, "class_name": null, "parameters": [], "calls": ["excinfo.errisinstance", "pytest.raises", "pytest.exit"], "code_location": {"file": "test_runner.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 615, "end_line": 618}, "code_snippet": "def test_pytest_exit() -> None:\n    with pytest.raises(pytest.exit.Exception) as excinfo:\n        pytest.exit(\"hello\")\n    assert excinfo.errisinstance(pytest.exit.Exception)\n", "type": "function"}, {"name": "test_python_pytest_package", "is_method": true, "class_name": "TestInvocationVariants", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.run", "res.stdout.fnmatch_lines", "str"], "code_location": {"file": "acceptance_test.py", "path": "/data3/pwh/swebench-repos/pytest/testing", "start_line": 635, "end_line": 639}, "code_snippet": "    def test_python_pytest_package(self, pytester: Pytester) -> None:\n        p1 = pytester.makepyfile(\"def test_pass(): pass\")\n        res = pytester.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n", "type": "function"}, {"name": "test_request_instance_issue203", "is_method": true, "class_name": "TestFixtureUsages", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1508, "end_line": 1523}, "code_snippet": "    def test_request_instance_issue203(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            class TestClass(object):\n                @pytest.fixture\n                def setup1(self, request):\n                    assert self == request.instance\n                    self.arg1 = 1\n                def test_hello(self, setup1):\n                    assert self.arg1 == 1\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=1)\n", "type": "function"}, {"name": "test_request_attributes_method", "is_method": true, "class_name": "TestRequestBasic", "parameters": ["self", "pytester"], "calls": ["pytester.getitems", "isinstance"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 700, "end_line": 716}, "code_snippet": "    def test_request_attributes_method(self, pytester: Pytester) -> None:\n        (item,) = pytester.getitems(\n            \"\"\"\n            import pytest\n            class TestB(object):\n\n                @pytest.fixture\n                def something(self, request):\n                    return 1\n                def test_func(self, something):\n                    pass\n        \"\"\"\n        )\n        assert isinstance(item, Function)\n        req = item._request\n        assert req.cls.__name__ == \"TestB\"\n        assert req.instance.__class__ == req.cls\n", "type": "function"}, {"name": "arg2", "is_method": false, "class_name": null, "parameters": ["request"], "calls": ["pytest.raises"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2", "start_line": 8, "end_line": 9}, "code_snippet": "def arg2(request):\n    pytest.raises(Exception, request.getfixturevalue, \"arg1\")\n", "type": "function"}, {"name": "arg1", "is_method": false, "class_name": null, "parameters": ["request"], "calls": ["pytest.raises", "request.getfixturevalue"], "code_location": {"file": "conftest.py", "path": "/data3/pwh/swebench-repos/pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1", "start_line": 8, "end_line": 10}, "code_snippet": "def arg1(request):\n    with pytest.raises(pytest.FixtureLookupError):\n        request.getfixturevalue(\"arg2\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7146198749542236}
{"question": "How does Pytest support parameterized testing for different API endpoints?", "answer": null, "relative_code_list": null, "ground_truth": "Pytest supports parameterized testing for different API endpoints through multiple mechanisms: 1) @pytest.mark.parametrize decorator that allows defining multiple sets of arguments for test functions, enabling testing of different endpoints with various parameters, 2) Metafunc.parametrize() method that can be called within pytest_generate_tests hook for dynamic parametrization based on configuration or external data, 3) Support for multiple parametrize decorators that can be stacked to test combinations of different HTTP methods, endpoints, and parameters, 4) Custom ID generation through the ids parameter to provide meaningful test names for different API endpoint combinations, 5) Integration with pytest's test discovery and execution system for organizing API endpoint tests, 6) Support for indirect parametrization where endpoint URLs or parameters can be passed as fixtures for more complex setup, 7) Command-line driven parametrization through pytest_addoption and pytest_generate_tests hooks for dynamic endpoint selection, 8) Scenario-based testing where different API endpoint scenarios can be defined and tested systematically, 9) Integration with monkeypatch fixture for mocking different API responses based on parametrized endpoints, 10) Support for testing different HTTP status codes, response formats, and error conditions across multiple endpoints, 11) Class-level parametrization where all test methods in a class can be parametrized for different API endpoints, 12) Module-level parametrization using pytestmark for applying endpoint parameters to all tests in a module.", "score": null, "retrieved_content": [{"name": "test_pytest_make_parametrize_id_with_argname", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2078, "end_line": 2101}, "code_snippet": "    def test_pytest_make_parametrize_id_with_argname(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val, argname):\n                return str(val * 2 if argname == 'x' else val * 10)\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func_a(x):\n                    pass\n\n                @pytest.mark.parametrize(\"y\", [1])\n                def test_func_b(y):\n                    pass\n                \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_func_a*0*PASS*\", \"*test_func_a*2*PASS*\", \"*test_func_b*10*PASS*\"]\n        )\n", "type": "function"}, {"name": "pytest_generate_tests", "is_method": false, "class_name": null, "parameters": ["metafunc"], "calls": ["metafunc.definition.iter_markers", "metafunc.parametrize"], "code_location": {"file": "python.py", "path": "/data3/pwh/swebench-repos/pytest/src/_pytest", "start_line": 112, "end_line": 114}, "code_snippet": "def pytest_generate_tests(metafunc: Metafunc) -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)\n", "type": "function"}, {"name": "test_parametrize_auto_scope", "is_method": true, "class_name": "TestMetafuncFunctionalAuto", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1690, "end_line": 1710}, "code_snippet": "    def test_parametrize_auto_scope(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session', autouse=True)\n            def fixture():\n                return 1\n\n            @pytest.mark.parametrize('animal', [\"dog\", \"cat\"])\n            def test_1(animal):\n                assert animal in ('dog', 'cat')\n\n            @pytest.mark.parametrize('animal', ['fish'])\n            def test_2(animal):\n                assert animal == 'fish'\n\n        \"\"\"\n        )\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])\n", "type": "function"}, {"name": "test_params_and_ids", "is_method": true, "class_name": "TestFixtureMarker", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "res.stdout.fnmatch_lines"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 3351, "end_line": 3366}, "code_snippet": "    def test_params_and_ids(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[object(), object()],\n                            ids=['alpha', 'beta'])\n            def fix(request):\n                return request.param\n\n            def test_foo(fix):\n                assert 1\n        \"\"\"\n        )\n        res = pytester.runpytest(\"-v\")\n        res.stdout.fnmatch_lines([\"*test_foo*alpha*\", \"*test_foo*beta*\"])\n", "type": "function"}, {"name": "test_pytest_make_parametrize_id", "is_method": true, "class_name": "TestMarkersWithParametrization", "parameters": ["self", "pytester"], "calls": ["pytester.makeconftest", "pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2059, "end_line": 2076}, "code_snippet": "    def test_pytest_make_parametrize_id(self, pytester: Pytester) -> None:\n        pytester.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val):\n                return str(val * 2)\n        \"\"\"\n        )\n        pytester.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func(x):\n                    pass\n                \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_func*0*PASS*\", \"*test_func*2*PASS*\"])\n", "type": "function"}, {"name": "test_parametrize_class_scenarios", "is_method": true, "class_name": "TestMetafunc", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 1084, "end_line": 1124}, "code_snippet": "    def test_parametrize_class_scenarios(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n        # same as doc/en/example/parametrize scenario example\n        def pytest_generate_tests(metafunc):\n            idlist = []\n            argvalues = []\n            for scenario in metafunc.cls.scenarios:\n                idlist.append(scenario[0])\n                items = scenario[1].items()\n                argnames = [x[0] for x in items]\n                argvalues.append(([x[1] for x in items]))\n            metafunc.parametrize(argnames, argvalues, ids=idlist, scope=\"class\")\n\n        class Test(object):\n               scenarios = [['1', {'arg': {1: 2}, \"arg2\": \"value2\"}],\n                            ['2', {'arg':'value2', \"arg2\": \"value2\"}]]\n\n               def test_1(self, arg, arg2):\n                  pass\n\n               def test_2(self, arg2, arg):\n                  pass\n\n               def test_3(self, arg, arg2):\n                  pass\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *test_1*1*\n            *test_2*1*\n            *test_3*1*\n            *test_1*2*\n            *test_2*2*\n            *test_3*2*\n            *6 passed*\n        \"\"\"\n        )\n", "type": "function"}, {"name": "pytest_generate_tests", "is_method": false, "class_name": null, "parameters": ["metafunc"], "calls": ["metafunc.parametrize", "metafunc.parametrize"], "code_location": {"file": "issue_519.py", "path": "/data3/pwh/swebench-repos/pytest/testing/example_scripts", "start_line": 9, "end_line": 14}, "code_snippet": "def pytest_generate_tests(metafunc):\n    if \"arg1\" in metafunc.fixturenames:\n        metafunc.parametrize(\"arg1\", [\"arg1v1\", \"arg1v2\"], scope=\"module\")\n\n    if \"arg2\" in metafunc.fixturenames:\n        metafunc.parametrize(\"arg2\", [\"arg2v1\", \"arg2v2\"], scope=\"function\")\n", "type": "function"}, {"name": "test_parametrize_functional", "is_method": true, "class_name": "TestMetafunc", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.runpytest", "result.stdout.fnmatch_lines"], "code_location": {"file": "metafunc.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 974, "end_line": 993}, "code_snippet": "    def test_parametrize_functional(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('x', [1,2], indirect=True)\n                metafunc.parametrize('y', [2])\n            @pytest.fixture\n            def x(request):\n                return request.param * 10\n\n            def test_simple(x,y):\n                assert x in (10,20)\n                assert y == 2\n        \"\"\"\n        )\n        result = pytester.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_simple*1-2*\", \"*test_simple*2-2*\", \"*2 passed*\"]\n        )\n", "type": "function"}, {"name": "test_parametrize", "is_method": true, "class_name": "TestFixtureMarker", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2376, "end_line": 2391}, "code_snippet": "    def test_parametrize(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(params=[\"a\", \"b\", \"c\"])\n            def arg(request):\n                return request.param\n            values = []\n            def test_param(arg):\n                values.append(arg)\n            def test_result():\n                assert values == list(\"abc\")\n        \"\"\"\n        )\n        reprec = pytester.inline_run()\n        reprec.assertoutcome(passed=4)\n", "type": "function"}, {"name": "test_uses_parametrized_resource", "is_method": true, "class_name": "TestAutouseManagement", "parameters": ["self", "pytester"], "calls": ["pytester.makepyfile", "pytester.inline_run", "reprec.assertoutcome"], "code_location": {"file": "fixtures.py", "path": "/data3/pwh/swebench-repos/pytest/testing/python", "start_line": 2160, "end_line": 2184}, "code_snippet": "    def test_uses_parametrized_resource(self, pytester: Pytester) -> None:\n        pytester.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(params=[1,2])\n            def arg(request):\n                return request.param\n\n            @pytest.fixture(autouse=True)\n            def something(arg):\n                values.append(arg)\n\n            def test_hello():\n                if len(values) == 1:\n                    assert values == [1]\n                elif len(values) == 2:\n                    assert values == [1, 2]\n                else:\n                    0/0\n\n        \"\"\"\n        )\n        reprec = pytester.inline_run(\"-s\")\n        reprec.assertoutcome(passed=2)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7006022930145264}
