{"question": "What are Requests' built-in authentication handlers?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' built-in authentication handlers (src/requests/auth.py) include: 1) HTTPBasicAuth - handles HTTP Basic Authentication by encoding username/password in base64 and adding Authorization header; 2) HTTPDigestAuth - implements HTTP Digest Authentication with support for MD5, SHA, SHA-256, and SHA-512 algorithms, handling challenge-response flow and nonce management; 3) HTTPProxyAuth - handles proxy authentication by adding Proxy-Authorization header; 4) AuthBase - abstract base class that all authentication handlers inherit from, defining the interface for auth implementations. These handlers are callable objects that modify Request objects by adding appropriate authentication headers. The DigestAuth handler includes thread-local state management for nonce counting and challenge handling, and implements automatic retry logic for 401 responses.", "score": null, "retrieved_content": [{"name": "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 529, "end_line": 542}, "code_snippet": "    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n", "type": "function"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "test_DIGEST_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "print", "requests.session", "HTTPDigestAuth", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 738, "end_line": 753}, "code_snippet": "    def test_DIGEST_HTTP_200_OK_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers[\"WWW-Authenticate\"])\n\n            s = requests.session()\n            s.auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = s.get(url)\n            assert r.status_code == 200\n", "type": "function"}, {"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_DIGESTAUTH_WRONG_HTTP_401_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 784, "end_line": 798}, "code_snippet": "    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"wrongpass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n", "type": "function"}, {"name": "test_DIGEST_AUTH_RETURNS_COOKIE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.get", "requests.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 755, "end_line": 763}, "code_snippet": "    def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = requests.get(url)\n            assert r.cookies[\"fake\"] == \"fake_value\"\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.974421977996826}
{"question": "Why does Requests use a prepared request pattern instead of sending raw HTTP requests directly?", "answer": null, "relative_code_list": null, "ground_truth": "Requests uses a prepared request pattern for several architectural and practical reasons: 1) Separation of concerns - Separates request preparation (encoding, header generation, authentication) from request transmission, enabling better code organization and testing; 2) Immutability - PreparedRequest objects represent the final, immutable state of a request, preventing accidental modifications during transmission; 3) Reusability - Prepared requests can be reused, modified, or copied for different purposes (e.g., retries, redirects, debugging); 4) Complex preparation logic - HTTP request preparation involves multiple steps (URL encoding, cookie processing, authentication, body encoding) that benefit from being isolated and testable; 5) Session integration - Allows session-level settings to be merged with request-specific settings in a controlled manner; 6) Hook system - Enables request hooks to be applied during preparation, allowing for request modification and logging; 7) Error handling - Preparation errors can be caught and handled before network transmission begins; 8) Debugging support - Prepared requests provide a clear representation of what will be sent, aiding in debugging and logging; 9) Redirect handling - Prepared requests can be easily copied and modified for redirect chains; 10) Transport abstraction - Prepared requests provide a clean interface for different transport adapters to consume.", "score": null, "retrieved_content": [{"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "test_cannot_send_unprepared_requests", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "pytest.raises", "send", "httpbin", "requests.Session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1570, "end_line": 1573}, "code_snippet": "    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n", "type": "function"}, {"name": "test_non_prepared_request_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "requests.Request", "pytest.raises", "s.send", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1136, "end_line": 1142}, "code_snippet": "    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n", "type": "function"}, {"name": "send", "is_method": true, "class_name": "Session", "parameters": ["self", "request"], "calls": ["kwargs.setdefault", "kwargs.setdefault", "kwargs.setdefault", "isinstance", "kwargs.pop", "kwargs.get", "self.get_adapter", "preferred_clock", "adapter.send", "timedelta", "dispatch_hook", "extract_cookies_to_jar", "resolve_proxies", "ValueError", "preferred_clock", "self.resolve_redirects", "history.insert", "history.pop", "extract_cookies_to_jar", "next", "self.resolve_redirects"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 673, "end_line": 748}, "code_snippet": "    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n\n        :rtype: requests.Response\n        \"\"\"\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault(\"stream\", self.stream)\n        kwargs.setdefault(\"verify\", self.verify)\n        kwargs.setdefault(\"cert\", self.cert)\n        if \"proxies\" not in kwargs:\n            kwargs[\"proxies\"] = resolve_proxies(request, self.proxies, self.trust_env)\n\n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if isinstance(request, Request):\n            raise ValueError(\"You can only send PreparedRequests.\")\n\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop(\"allow_redirects\", True)\n        stream = kwargs.get(\"stream\")\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n        # Response manipulation hooks\n        r = dispatch_hook(\"response\", hooks, r, **kwargs)\n\n        # Persist cookies\n        if r.history:\n            # If the hooks create history then we want those cookies too\n            for resp in r.history:\n                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n\n        extract_cookies_to_jar(self.cookies, request, r.raw)\n\n        # Resolve redirects if allowed.\n        if allow_redirects:\n            # Redirect resolving generator.\n            gen = self.resolve_redirects(r, request, **kwargs)\n            history = [resp for resp in gen]\n        else:\n            history = []\n\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n            r.history = history\n\n        # If redirects aren't being followed, store the response on the Request for Response.next().\n        if not allow_redirects:\n            try:\n                r._next = next(\n                    self.resolve_redirects(r, request, yield_requests=True, **kwargs)\n                )\n            except StopIteration:\n                pass\n\n        if not stream:\n            r.content\n\n        return r\n", "type": "function"}, {"name": "request", "is_method": true, "class_name": "Session", "parameters": ["self", "method", "url", "params", "data", "headers", "cookies", "files", "auth", "timeout", "allow_redirects", "proxies", "hooks", "stream", "verify", "cert", "json"], "calls": ["Request", "self.prepare_request", "self.merge_environment_settings", "send_kwargs.update", "self.send", "method.upper"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 500, "end_line": 591}, "code_snippet": "    def request(\n        self,\n        method,\n        url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None,\n    ):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param hooks: (optional) Dictionary mapping hook name to one event or\n            list of events, event must be callable.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False``\n            may be useful during local development or testing.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            \"timeout\": timeout,\n            \"allow_redirects\": allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "__repr__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 379, "end_line": 380}, "code_snippet": "    def __repr__(self):\n        return f\"<PreparedRequest [{self.method}]>\"\n", "type": "function"}, {"name": "test_basic_building", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Request", "req.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 113, "end_line": 120}, "code_snippet": "    def test_basic_building(self):\n        req = requests.Request()\n        req.url = \"http://kennethreitz.org/\"\n        req.data = {\"life\": \"42\"}\n\n        pr = req.prepare()\n        assert pr.url == req.url\n        assert pr.body == \"life=42\"\n", "type": "function"}, {"name": "test_respect_proxy_env_on_send_self_prepared_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "requests.Request", "session.send", "httpbin", "request.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 607, "end_line": 612}, "code_snippet": "    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request(\"GET\", httpbin())\n                session.send(request.prepare())\n", "type": "function"}], "retrieved_count": 10, "cost_time": 3.9553771018981934}
{"question": "What is the relationship between Requests' authentication handlers and the session management system?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between authentication handlers and session management (src/requests/auth.py, src/requests/sessions.py) provides persistent authentication: 1) Session-level auth - Sessions can store default authentication credentials (self.auth) that are applied to all requests unless overridden; 2) Request preparation - During request preparation, Session.prepare_request() merges session auth with request-specific auth; 3) Auth handler application - Authentication handlers are applied during PreparedRequest preparation, adding appropriate headers (Authorization, Proxy-Authorization); 4) Persistent credentials - Session maintains authentication state across multiple requests, avoiding repeated credential specification; 5) Environment integration - Sessions can automatically detect and use authentication from environment variables (netrc, etc.) when trust_env is enabled; 6) Auth method flexibility - Sessions support both simple tuples (username, password) and complex auth handler objects; 7) Redirect handling - Authentication handlers can respond to 401 challenges and maintain state across redirects; 8) Cookie integration - Authentication and cookie handling work together, with auth headers and cookies both being session-persistent; 9) Thread safety - Authentication handlers like HTTPDigestAuth use thread-local storage for state management; 10) Cleanup - Sessions properly clean up authentication resources when closed. This integration enables seamless authentication across multiple requests while maintaining security and state consistency.", "score": null, "retrieved_content": [{"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.Session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 765, "end_line": 771}, "code_snippet": "    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_should_strip_auth_host_change", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.should_strip_auth"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1901, "end_line": 1905}, "code_snippet": "    def test_should_strip_auth_host_change(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\n            \"http://example.com/foo\", \"http://another.example.com/\"\n        )\n", "type": "function"}, {"name": "test_should_strip_auth_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.should_strip_auth"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1907, "end_line": 1909}, "code_snippet": "    def test_should_strip_auth_http_downgrade(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\"https://example.com/foo\", \"http://example.com/bar\")\n", "type": "function"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_should_strip_auth_port_change", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.should_strip_auth"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1930, "end_line": 1934}, "code_snippet": "    def test_should_strip_auth_port_change(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\n            \"http://example.com:1234/foo\", \"https://example.com:4321/bar\"\n        )\n", "type": "function"}, {"name": "test_DIGEST_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "print", "requests.session", "HTTPDigestAuth", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 738, "end_line": 753}, "code_snippet": "    def test_DIGEST_HTTP_200_OK_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers[\"WWW-Authenticate\"])\n\n            s = requests.session()\n            s.auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = s.get(url)\n            assert r.status_code == 200\n", "type": "function"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.018164396286011}
{"question": "Why does Requests use an adapter pattern for transport abstraction instead of direct HTTP library integration?", "answer": null, "relative_code_list": null, "ground_truth": "Requests uses the adapter pattern for transport abstraction to achieve several important architectural goals: 1) Decoupling - Separates HTTP client logic from transport implementation details, making the codebase more maintainable and testable; 2) Flexibility - Allows different transport implementations (urllib3, custom libraries) to be used without changing the core Requests API; 3) Protocol support - Enables support for different protocols (HTTP, HTTPS, FTP, custom protocols) through different adapter implementations; 4) Configuration isolation - Each adapter can have its own configuration (pool sizes, retry policies, timeouts) independent of the main Requests interface; 5) Error handling consistency - Provides a unified error handling interface regardless of the underlying transport mechanism; 6) Testing - Enables easy mocking and testing of transport behavior without requiring actual network connections; 7) Extensibility - Users can implement custom adapters for specialized transport needs (e.g., custom protocols, proxy handling); 8) Performance optimization - Different adapters can be optimized for specific use cases or protocols; 9) Dependency management - Reduces tight coupling to specific transport libraries, making dependency management easier; 10) Future-proofing - Allows Requests to adapt to new transport technologies or requirements without major architectural changes.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "test_HTTP_200_OK_GET_ALTERNATIVE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "getproxies", "s.send", "httpbin", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 203, "end_line": 210}, "code_snippet": "    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}], "retrieved_count": 10, "cost_time": 4.0829596519470215}
{"question": "Why does Requests provide built-in authentication handlers for common authentication schemes?", "answer": null, "relative_code_list": null, "ground_truth": "Requests provides built-in authentication handlers to address common real-world authentication requirements: 1) Usability - Eliminates the need for users to implement common authentication schemes from scratch, reducing development time and errors; 2) Security - Provides secure, well-tested implementations of authentication protocols that follow security best practices; 3) Standards compliance - Implements authentication schemes according to HTTP standards (RFC 2617 for Basic/Digest, RFC 7235 for authentication framework); 4) Common use cases - Covers the most widely used authentication methods (Basic, Digest, Proxy) that users encounter in practice; 5) Integration - Authentication handlers integrate seamlessly with Sessions and the request preparation system; 6) Extensibility - Provides a base class (AuthBase) that users can extend for custom authentication schemes; 7) Error handling - Built-in handlers include proper error handling and retry logic for authentication challenges; 8) Thread safety - Handlers like HTTPDigestAuth implement thread-safe state management for concurrent usage; 9) Performance - Optimized implementations avoid unnecessary overhead and provide efficient authentication processing; 10) Documentation and examples - Built-in handlers serve as examples and documentation for implementing custom authentication.", "score": null, "retrieved_content": [{"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 529, "end_line": 542}, "code_snippet": "    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n", "type": "function"}, {"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_DIGEST_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "print", "requests.session", "HTTPDigestAuth", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 738, "end_line": 753}, "code_snippet": "    def test_DIGEST_HTTP_200_OK_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers[\"WWW-Authenticate\"])\n\n            s = requests.session()\n            s.auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = s.get(url)\n            assert r.status_code == 200\n", "type": "function"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "test_DIGESTAUTH_WRONG_HTTP_401_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 784, "end_line": 798}, "code_snippet": "    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"wrongpass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.142292737960815}
{"question": "What is the exact meaning of Requests' \"adapter\" concept and its abstraction of underlying transport mechanisms?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' adapter concept (src/requests/adapters.py) is a design pattern that provides a transport abstraction layer, separating HTTP client logic from the underlying transport implementation. The adapter system consists of: 1) BaseAdapter - an abstract interface defining the contract for transport adapters with send() and close() methods; 2) HTTPAdapter - the concrete implementation that wraps urllib3's PoolManager, providing connection pooling, retry logic, and proxy support for HTTP/HTTPS connections; 3) Transport abstraction - adapters abstract away the complexity of connection management, SSL/TLS handling, and protocol-specific details, allowing Requests to work with different underlying transport libraries; 4) Adapter mounting - Sessions can mount different adapters for different URL schemes (http://, https://, ftp://, etc.), enabling protocol-specific customization; 5) Connection pooling - HTTPAdapter manages connection pools through urllib3, handling connection reuse, limits, and lifecycle management; 6) Error handling - adapters translate transport-specific exceptions into Requests exceptions, providing a consistent error interface; 7) Configuration flexibility - adapters can be configured with different pool sizes, retry policies, and connection parameters; 8) Extensibility - custom adapters can be implemented by subclassing BaseAdapter for specialized transport needs. This abstraction enables Requests to maintain a clean, high-level API while delegating transport complexity to specialized adapter implementations.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_with_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1697, "end_line": 1708}, "code_snippet": "    def test_session_get_adapter_prefix_with_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com/\"  # trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_not_matching_prefix = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_not_matching_prefix) is not adapter\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_without_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1710, "end_line": 1721}, "code_snippet": "    def test_session_get_adapter_prefix_without_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com\"  # no trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_extended_hostname = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_extended_hostname) is adapter\n", "type": "function"}, {"name": "get_adapter", "is_method": true, "class_name": "Session", "parameters": ["self", "url"], "calls": ["self.adapters.items", "InvalidSchema", "startswith", "prefix.lower", "url.lower"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 781, "end_line": 792}, "code_snippet": "    def get_adapter(self, url):\n        \"\"\"\n        Returns the appropriate connection adapter for the given URL.\n\n        :rtype: requests.adapters.BaseAdapter\n        \"\"\"\n        for prefix, adapter in self.adapters.items():\n            if url.lower().startswith(prefix.lower()):\n                return adapter\n\n        # Nothing matches :-/\n        raise InvalidSchema(f\"No connection adapters were found for {url!r}\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.2330827713012695}
{"question": "Why does Requests implement automatic redirect handling instead of manual redirect management?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements automatic redirect handling to provide a seamless user experience and handle complex redirect scenarios: 1) User convenience - Eliminates the need for users to manually handle redirects, which is a common and tedious requirement in HTTP clients; 2) Standards compliance - Implements redirect handling according to HTTP standards (RFC 7231) including proper method rewriting and status code handling; 3) Complex logic - Redirect handling involves multiple considerations (method changes, authentication stripping, URL resolution) that are error-prone to implement manually; 4) Security - Automatic handling includes security considerations like authentication stripping when redirecting to different hosts; 5) Performance - Proper redirect handling includes connection management and resource cleanup to prevent resource leaks; 6) History tracking - Maintains a complete history of redirects for debugging and analysis purposes; 7) Configurability - Provides allow_redirects parameter to disable automatic handling when needed; 8) Error prevention - Handles edge cases like infinite redirects, malformed Location headers, and redirect limits; 9) Fragment preservation - Correctly handles URL fragments across redirects as specified in HTTP standards; 10) Integration - Seamlessly integrates with other Requests features like cookies, authentication, and connection pooling.", "score": null, "retrieved_content": [{"name": "test_manual_redirect_with_partial_body_read", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "s.get", "s.resolve_redirects", "r1.iter_content", "next", "r2.iter_content", "next", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1949, "end_line": 1966}, "code_snippet": "    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin(\"redirect/2\"), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n        # read only the first eight bytes of the response body,\n        # then follow the redirect\n        r1.iter_content(8)\n        r2 = next(rg)\n        assert r2.is_redirect\n\n        # read all of the response via iter_content,\n        # then follow the redirect\n        for _ in r2.iter_content():\n            pass\n        r3 = next(rg)\n        assert not r3.is_redirect\n", "type": "function"}, {"name": "test_HTTP_302_ALLOW_REDIRECT_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 212, "end_line": 216}, "code_snippet": "    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin(\"redirect\", \"1\"))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_HTTP_302_TOO_MANY_REDIRECTS", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pytest.fail", "httpbin", "httpbin", "len"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 241, "end_line": 250}, "code_snippet": "    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin(\"relative-redirect\", \"50\"))\n        except TooManyRedirects as e:\n            url = httpbin(\"relative-redirect\", \"20\")\n            assert e.request.url == url\n            assert e.response.url == url\n            assert len(e.response.history) == 30\n        else:\n            pytest.fail(\"Expected redirect to raise TooManyRedirects but it did not\")\n", "type": "function"}, {"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}, {"name": "test_requests_history_is_saved", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2099, "end_line": 2105}, "code_snippet": "    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin(\"redirect/5\"))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n            assert item.history == total[0:i]\n            i += 1\n", "type": "function"}, {"name": "test_http_302_changes_post_to_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.post", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 282, "end_line": 287}, "code_snippet": "    def test_http_302_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"302\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_http_301_changes_post_to_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.post", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 267, "end_line": 272}, "code_snippet": "    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"301\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 301\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "RedirectSession", "parameters": ["self", "order_of_redirects"], "calls": [], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2556, "end_line": 2561}, "code_snippet": "    def __init__(self, order_of_redirects):\n        self.redirects = order_of_redirects\n        self.calls = []\n        self.max_redirects = 30\n        self.cookies = {}\n        self.trust_env = False\n", "type": "function"}, {"name": "test_cookie_sent_on_redirect", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "s.get", "httpbin", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 380, "end_line": 384}, "code_snippet": "    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies/set?foo=bar\"))\n        r = s.get(httpbin(\"redirect/1\"))  # redirects to httpbin('get')\n        assert \"Cookie\" in r.json()[\"headers\"]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.242805480957031}
{"question": "Why does Requests implement a session-based connection pooling instead of creating new connections for each request?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements session-based connection pooling for several critical performance and resource management reasons: 1) Performance optimization - Reusing TCP connections eliminates the overhead of connection establishment (TCP handshake, SSL/TLS negotiation), significantly reducing latency for multiple requests to the same host; 2) Resource efficiency - Connection pooling reduces the number of open file descriptors and system resources required, preventing resource exhaustion in high-concurrency scenarios; 3) HTTP/1.1 compliance - Enables proper HTTP/1.1 keep-alive behavior, allowing multiple requests over a single connection as specified in RFC 2616; 4) Reduced server load - Fewer connection establishments reduce server-side resource consumption and improve overall system performance; 5) Network efficiency - Minimizes network overhead by avoiding repeated DNS lookups and connection setup for the same host; 6) Scalability - Connection pools can be configured with appropriate limits to handle concurrent requests efficiently; 7) Connection lifecycle management - Proper connection reuse, timeout handling, and cleanup prevents connection leaks and ensures reliable resource management; 8) Thread safety - Connection pools are thread-safe, enabling efficient concurrent access across multiple threads; 9) Automatic connection management - Handles connection failures, timeouts, and cleanup automatically without user intervention; 10) Backward compatibility - Maintains compatibility with HTTP/1.0 servers while optimizing for HTTP/1.1 capabilities.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_True", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2874, "end_line": 2903}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_True(self):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Cannot verify self-signed certificate\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url)\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.302962779998779}
{"question": "Why does Requests implement a unified interface for different HTTP methods instead of separate classes?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements a unified interface for HTTP methods for several design and usability reasons: 1) API simplicity - Provides a consistent, easy-to-learn interface where all HTTP methods follow the same pattern (requests.get(), requests.post(), etc.); 2) Code reuse - Common functionality (authentication, cookies, headers, error handling) is shared across all HTTP methods, reducing code duplication; 3) Session compatibility - All methods work seamlessly with Session objects, maintaining consistent behavior and state management; 4) Parameter consistency - All methods accept the same parameter set (headers, cookies, auth, timeout, etc.), providing a predictable interface; 5) Flexibility - Users can easily switch between HTTP methods without learning different APIs or patterns; 6) Maintainability - Changes to common functionality (e.g., error handling, authentication) only need to be implemented once; 7) Testing - Unified interface simplifies testing and mocking across different HTTP methods; 8) Documentation - Single interface reduces documentation complexity and improves user experience; 9) Extensibility - New HTTP methods can be added easily by following the established pattern; 10) Backward compatibility - Changes to the interface affect all methods consistently, reducing compatibility issues.", "score": null, "retrieved_content": [{"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "request", "is_method": false, "class_name": null, "parameters": ["method", "url"], "calls": ["sessions.Session", "session.request"], "code_location": {"file": "api.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 14, "end_line": 59}, "code_snippet": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n        to add for the file.\n    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) How many seconds to wait for the server to send data\n        before giving up, as a float, or a :ref:`(connect timeout, read\n        timeout) <timeouts>` tuple.\n    :type timeout: float or tuple\n    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n    :type allow_redirects: bool\n    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n    :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n    :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n\n    # By using the 'with' statement we are sure the session is closed, thus we\n    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n", "type": "function"}, {"name": "request", "is_method": true, "class_name": "Session", "parameters": ["self", "method", "url", "params", "data", "headers", "cookies", "files", "auth", "timeout", "allow_redirects", "proxies", "hooks", "stream", "verify", "cert", "json"], "calls": ["Request", "self.prepare_request", "self.merge_environment_settings", "send_kwargs.update", "self.send", "method.upper"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 500, "end_line": 591}, "code_snippet": "    def request(\n        self,\n        method,\n        url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None,\n    ):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param hooks: (optional) Dictionary mapping hook name to one event or\n            list of events, event must be callable.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False``\n            may be useful during local development or testing.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            \"timeout\": timeout,\n            \"allow_redirects\": allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n", "type": "function"}, {"name": "test_HTTP_200_OK_GET_ALTERNATIVE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "getproxies", "s.send", "httpbin", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 203, "end_line": 210}, "code_snippet": "    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Request", "parameters": ["self", "method", "url", "headers", "files", "data", "params", "auth", "cookies", "hooks", "json"], "calls": ["default_hooks", "list", "hooks.items", "self.register_hook"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 258, "end_line": 290}, "code_snippet": "    def __init__(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n        # Default empty dicts for dict params.\n        data = [] if data is None else data\n        files = [] if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n        hooks = {} if hooks is None else hooks\n\n        self.hooks = default_hooks()\n        for k, v in list(hooks.items()):\n            self.register_hook(event=k, hook=v)\n\n        self.method = method\n        self.url = url\n        self.headers = headers\n        self.files = files\n        self.data = data\n        self.json = json\n        self.params = params\n        self.auth = auth\n        self.cookies = cookies\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_unicode_method_name_with_request_object", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "isinstance", "s.send", "open", "requests.Request", "s.prepare_request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1124, "end_line": 1134}, "code_snippet": "    def test_unicode_method_name_with_request_object(self, httpbin):\n        s = requests.Session()\n        with open(__file__, \"rb\") as f:\n            files = {\"file\": f}\n            req = requests.Request(\"POST\", httpbin(\"post\"), files=files)\n            prep = s.prepare_request(req)\n        assert isinstance(prep.method, builtin_str)\n        assert prep.method == \"POST\"\n\n        resp = s.send(prep)\n        assert resp.status_code == 200\n", "type": "function"}, {"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}], "retrieved_count": 10, "cost_time": 4.351011514663696}
{"question": "What dependencies exist between Requests' adapter system and the underlying transport libraries?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' adapter system (src/requests/adapters.py) has specific dependencies on underlying transport libraries: 1) urllib3 dependency - HTTPAdapter depends heavily on urllib3 for connection pooling, SSL/TLS handling, and HTTP protocol implementation; 2) PoolManager integration - HTTPAdapter uses urllib3.PoolManager for connection pooling, retry logic, and connection lifecycle management; 3) Exception mapping - Adapters translate urllib3 exceptions (ConnectTimeoutError, ReadTimeoutError, SSLError, etc.) into Requests exceptions; 4) SSL/TLS handling - Adapters delegate SSL certificate verification, client certificate handling, and TLS configuration to urllib3; 5) Proxy support - HTTPAdapter uses urllib3's proxy_from_url and SOCKSProxyManager for proxy handling; 6) Retry mechanism - Adapters integrate with urllib3's Retry class for configurable retry policies and backoff strategies; 7) Connection pooling - Adapters rely on urllib3's connection pool implementation for connection reuse and management; 8) Content encoding - Adapters use urllib3's content encoding and decoding capabilities; 9) Header handling - Adapters depend on urllib3's header parsing and validation; 10) URL processing - Adapters use urllib3's URL parsing and validation utilities. The adapter system provides an abstraction layer that shields Requests from urllib3 implementation details while leveraging its robust transport capabilities.", "score": null, "retrieved_content": [{"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "check_compatibility", "is_method": false, "class_name": null, "parameters": ["urllib3_version", "chardet_version", "charset_normalizer_version"], "calls": ["urllib3_version.split", "len", "urllib3_version.append", "int", "int", "int", "chardet_version.split", "int", "int", "int", "warnings.warn", "charset_normalizer_version.split", "int", "int", "int"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 58, "end_line": 90}, "code_snippet": "def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):\n    urllib3_version = urllib3_version.split(\".\")\n    assert urllib3_version != [\"dev\"]  # Verify urllib3 isn't installed from git.\n\n    # Sometimes, urllib3 only reports its version as 16.1.\n    if len(urllib3_version) == 2:\n        urllib3_version.append(\"0\")\n\n    # Check urllib3 for compatibility.\n    major, minor, patch = urllib3_version  # noqa: F811\n    major, minor, patch = int(major), int(minor), int(patch)\n    # urllib3 >= 1.21.1\n    assert major >= 1\n    if major == 1:\n        assert minor >= 21\n\n    # Check charset_normalizer for compatibility.\n    if chardet_version:\n        major, minor, patch = chardet_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # chardet_version >= 3.0.2, < 6.0.0\n        assert (3, 0, 2) <= (major, minor, patch) < (6, 0, 0)\n    elif charset_normalizer_version:\n        major, minor, patch = charset_normalizer_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # charset_normalizer >= 2.0.0 < 4.0.0\n        assert (2, 0, 0) <= (major, minor, patch) < (4, 0, 0)\n    else:\n        warnings.warn(\n            \"Unable to find acceptable character detection dependency \"\n            \"(chardet or charset_normalizer).\",\n            RequestsDependencyWarning,\n        )\n", "type": "function"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "RequestsDependencyWarning", "docstring": "An imported dependency doesn't match the expected version range.", "methods": [], "attributes": [], "code_location": {"file": "exceptions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 150, "end_line": 151}, "type": "class"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.423152446746826}
{"question": "What is the purpose of the PreparedRequest class in Requests' request preparation system?", "answer": null, "relative_code_list": null, "ground_truth": "The PreparedRequest class (src/requests/models.py) serves as the final, fully-prepared representation of an HTTP request that is ready for transmission. Its purpose includes: 1) Request finalization - transforms user-friendly Request objects into transport-ready requests with all encoding, headers, and body preparation completed; 2) Immutable state - once prepared, the request contains the exact bytes and headers that will be sent to the server, preventing modification during transmission; 3) Encoding and formatting - handles URL encoding, parameter encoding, cookie header generation, authentication header preparation, and body encoding (form data, JSON, files); 4) Header management - prepares and validates all HTTP headers including Content-Type, Content-Length, and custom headers; 5) Cookie processing - generates Cookie headers from CookieJar objects using cookielib compatibility; 6) Authentication preparation - applies authentication handlers to add appropriate Authorization headers; 7) Body preparation - handles different body types (data, files, JSON) and encodes them appropriately; 8) URL processing - handles URL encoding, parameter appending, and IDNA hostname encoding; 9) Hook registration - sets up request hooks for pre-send processing; 10) Copy support - provides copy() method for creating duplicates, essential for redirect handling. PreparedRequest objects are created by calling Request.prepare() or Session.prepare_request() and are consumed by adapter.send() methods.", "score": null, "retrieved_content": [{"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "__repr__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 379, "end_line": 380}, "code_snippet": "    def __repr__(self):\n        return f\"<PreparedRequest [{self.method}]>\"\n", "type": "function"}, {"name": "test_prepared_copy", "is_method": false, "class_name": null, "parameters": ["kwargs"], "calls": ["pytest.mark.parametrize", "PreparedRequest", "p.copy", "p.prepare", "getattr", "getattr", "default_hooks", "default_hooks"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2677, "end_line": 2683}, "code_snippet": "def test_prepared_copy(kwargs):\n    p = PreparedRequest()\n    if kwargs:\n        p.prepare(**kwargs)\n    copy = p.copy()\n    for attr in (\"method\", \"url\", \"headers\", \"_cookies\", \"body\", \"hooks\"):\n        assert getattr(p, attr) == getattr(copy, attr)\n", "type": "function"}, {"name": "send", "is_method": true, "class_name": "Session", "parameters": ["self", "request"], "calls": ["kwargs.setdefault", "kwargs.setdefault", "kwargs.setdefault", "isinstance", "kwargs.pop", "kwargs.get", "self.get_adapter", "preferred_clock", "adapter.send", "timedelta", "dispatch_hook", "extract_cookies_to_jar", "resolve_proxies", "ValueError", "preferred_clock", "self.resolve_redirects", "history.insert", "history.pop", "extract_cookies_to_jar", "next", "self.resolve_redirects"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 673, "end_line": 748}, "code_snippet": "    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n\n        :rtype: requests.Response\n        \"\"\"\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault(\"stream\", self.stream)\n        kwargs.setdefault(\"verify\", self.verify)\n        kwargs.setdefault(\"cert\", self.cert)\n        if \"proxies\" not in kwargs:\n            kwargs[\"proxies\"] = resolve_proxies(request, self.proxies, self.trust_env)\n\n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if isinstance(request, Request):\n            raise ValueError(\"You can only send PreparedRequests.\")\n\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop(\"allow_redirects\", True)\n        stream = kwargs.get(\"stream\")\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n        # Response manipulation hooks\n        r = dispatch_hook(\"response\", hooks, r, **kwargs)\n\n        # Persist cookies\n        if r.history:\n            # If the hooks create history then we want those cookies too\n            for resp in r.history:\n                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n\n        extract_cookies_to_jar(self.cookies, request, r.raw)\n\n        # Resolve redirects if allowed.\n        if allow_redirects:\n            # Redirect resolving generator.\n            gen = self.resolve_redirects(r, request, **kwargs)\n            history = [resp for resp in gen]\n        else:\n            history = []\n\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n            r.history = history\n\n        # If redirects aren't being followed, store the response on the Request for Response.next().\n        if not allow_redirects:\n            try:\n                r._next = next(\n                    self.resolve_redirects(r, request, yield_requests=True, **kwargs)\n                )\n            except StopIteration:\n                pass\n\n        if not stream:\n            r.content\n\n        return r\n", "type": "function"}, {"name": "prepare_request", "is_method": true, "class_name": "Session", "parameters": ["self", "request"], "calls": ["merge_cookies", "PreparedRequest", "p.prepare", "isinstance", "cookiejar_from_dict", "merge_cookies", "get_netrc_auth", "RequestsCookieJar", "request.method.upper", "merge_setting", "merge_setting", "merge_setting", "merge_hooks"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 457, "end_line": 498}, "code_snippet": "    def prepare_request(self, request):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n        transmission and returns it. The :class:`PreparedRequest` has settings\n        merged from the :class:`Request <Request>` instance and those of the\n        :class:`Session`.\n\n        :param request: :class:`Request` instance to prepare with this\n            session's settings.\n        :rtype: requests.PreparedRequest\n        \"\"\"\n        cookies = request.cookies or {}\n\n        # Bootstrap CookieJar.\n        if not isinstance(cookies, cookielib.CookieJar):\n            cookies = cookiejar_from_dict(cookies)\n\n        # Merge with session cookies\n        merged_cookies = merge_cookies(\n            merge_cookies(RequestsCookieJar(), self.cookies), cookies\n        )\n\n        # Set environment's basic authentication if not explicitly set.\n        auth = request.auth\n        if self.trust_env and not auth and not self.auth:\n            auth = get_netrc_auth(request.url)\n\n        p = PreparedRequest()\n        p.prepare(\n            method=request.method.upper(),\n            url=request.url,\n            files=request.files,\n            data=request.data,\n            json=request.json,\n            headers=merge_setting(\n                request.headers, self.headers, dict_class=CaseInsensitiveDict\n            ),\n            params=merge_setting(request.params, self.params),\n            auth=merge_setting(auth, self.auth),\n            cookies=merged_cookies,\n            hooks=merge_hooks(request.hooks, self.hooks),\n        )\n        return p\n", "type": "function"}, {"name": "prepare", "is_method": true, "class_name": "Request", "parameters": ["self"], "calls": ["PreparedRequest", "p.prepare"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 295, "end_line": 310}, "code_snippet": "    def prepare(self):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n        p = PreparedRequest()\n        p.prepare(\n            method=self.method,\n            url=self.url,\n            headers=self.headers,\n            files=self.files,\n            data=self.data,\n            json=self.json,\n            params=self.params,\n            auth=self.auth,\n            cookies=self.cookies,\n            hooks=self.hooks,\n        )\n        return p\n", "type": "function"}, {"name": "copy", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": ["PreparedRequest", "_copy_cookie_jar", "self.headers.copy"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 382, "end_line": 391}, "code_snippet": "    def copy(self):\n        p = PreparedRequest()\n        p.method = self.method\n        p.url = self.url\n        p.headers = self.headers.copy() if self.headers is not None else None\n        p._cookies = _copy_cookie_jar(self._cookies)\n        p.body = self.body\n        p.hooks = self.hooks\n        p._body_position = self._body_position\n        return p\n", "type": "function"}, {"name": "test_basic_building", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Request", "req.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 113, "end_line": 120}, "code_snippet": "    def test_basic_building(self):\n        req = requests.Request()\n        req.url = \"http://kennethreitz.org/\"\n        req.data = {\"life\": \"42\"}\n\n        pr = req.prepare()\n        assert pr.url == req.url\n        assert pr.body == \"life=42\"\n", "type": "function"}, {"name": "test_non_prepared_request_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "requests.Request", "pytest.raises", "s.send", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1136, "end_line": 1142}, "code_snippet": "    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.506434440612793}
{"question": "What is the role of the Response class in Requests' HTTP response handling?", "answer": null, "relative_code_list": null, "ground_truth": "The Response class (src/requests/models.py) serves as the primary interface for handling HTTP responses in Requests. Its role includes: 1) Response encapsulation - wraps the raw HTTP response from the transport layer with a user-friendly interface; 2) Content access - provides multiple ways to access response content (content, text, json properties) with automatic encoding detection and decoding; 3) Header management - offers case-insensitive header access through the headers attribute; 4) Status handling - provides status_code, reason, and ok properties for response status evaluation; 5) Cookie extraction - automatically extracts and stores cookies from Set-Cookie headers in the cookies attribute; 6) Redirect support - tracks redirect history and provides is_redirect, is_permanent_redirect properties; 7) Streaming support - enables content streaming through iter_content() and raw file-like access; 8) Context management - implements context manager protocol for automatic resource cleanup; 9) Error checking - provides raise_for_status() method for automatic HTTP error detection; 10) Request reference - maintains reference to the original PreparedRequest for debugging and analysis. The Response class acts as the bridge between the low-level transport layer and the high-level user interface, providing a consistent API regardless of the underlying transport mechanism.", "score": null, "retrieved_content": [{"name": "Response", "docstring": "The :class:`Response <Response>` object, which contains a\nserver's response to an HTTP request.", "methods": ["__init__", "__enter__", "__exit__", "__getstate__", "__setstate__", "__repr__", "__bool__", "__nonzero__", "__iter__", "ok", "is_redirect", "is_permanent_redirect", "next", "apparent_encoding", "iter_content", "iter_lines", "content", "text", "json", "links", "raise_for_status", "close"], "attributes": ["__attrs__"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 640, "end_line": 1039}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cookiejar_from_dict", "datetime.timedelta"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 658, "end_line": 703}, "code_snippet": "    def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None\n", "type": "function"}, {"name": "test_empty_response_has_content_none", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1417, "end_line": 1419}, "code_snippet": "    def test_empty_response_has_content_none(self):\n        r = requests.Response()\n        assert r.content is None\n", "type": "function"}, {"name": "MockResponse", "docstring": "Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n\n...what? Basically, expose the parsed HTTP headers from the server response\nthe way `http.cookiejar` expects to see them.", "methods": ["__init__", "info", "getheaders"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 103, "end_line": 121}, "type": "class"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "resolve_redirects", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp", "req", "stream", "timeout", "verify", "cert", "proxies", "yield_requests"], "calls": ["self.get_redirect_target", "urlparse", "req.copy", "hist.append", "resp.close", "url.startswith", "urlparse", "parsed.geturl", "to_native_string", "self.rebuild_method", "headers.pop", "extract_cookies_to_jar", "merge_cookies", "prepared_request.prepare_cookies", "self.rebuild_proxies", "self.rebuild_auth", "len", "TooManyRedirects", "urlparse", "join", "parsed._replace", "urljoin", "requote_uri", "rewind_body", "self.send", "extract_cookies_to_jar", "self.get_redirect_target", "resp.raw.read", "requote_uri", "prepared_request.headers.pop", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 159, "end_line": 280}, "code_snippet": "    def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_response_is_iterable", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response", "StringIO.StringIO", "setattr", "next", "io.close", "read_", "iter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1421, "end_line": 1432}, "code_snippet": "    def test_response_is_iterable(self):\n        r = requests.Response()\n        io = StringIO.StringIO(\"abc\")\n        read_ = io.read\n\n        def read_mock(amt, decode_content=None):\n            return read_(amt)\n\n        setattr(io, \"read\", read_mock)\n        r.raw = io\n        assert next(iter(r))\n        io.close()\n", "type": "function"}, {"name": "build_response", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "req", "resp"], "calls": ["Response", "getattr", "CaseInsensitiveDict", "get_encoding_from_headers", "isinstance", "extract_cookies_to_jar", "getattr", "req.url.decode"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 336, "end_line": 371}, "code_snippet": "    def build_response(self, req, resp):\n        \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3\n        response. This should not be called from user code, and is only exposed\n        for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n        :param resp: The urllib3 response object.\n        :rtype: requests.Response\n        \"\"\"\n        response = Response()\n\n        # Fallback to None if there's no status_code, for whatever reason.\n        response.status_code = getattr(resp, \"status\", None)\n\n        # Make headers case-insensitive.\n        response.headers = CaseInsensitiveDict(getattr(resp, \"headers\", {}))\n\n        # Set encoding.\n        response.encoding = get_encoding_from_headers(response.headers)\n        response.raw = resp\n        response.reason = response.raw.reason\n\n        if isinstance(req.url, bytes):\n            response.url = req.url.decode(\"utf-8\")\n        else:\n            response.url = req.url\n\n        # Add new cookies from the server.\n        extract_cookies_to_jar(response.cookies, req, resp)\n\n        # Give the Response some context.\n        response.request = req\n        response.connection = self\n\n        return response\n", "type": "function"}, {"name": "build_response", "is_method": true, "class_name": "RedirectSession", "parameters": ["self"], "calls": ["requests.Response", "CaseInsensitiveDict", "self._build_raw", "int", "self.redirects.pop"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2567, "end_line": 2579}, "code_snippet": "    def build_response(self):\n        request = self.calls[-1].args[0]\n        r = requests.Response()\n\n        try:\n            r.status_code = int(self.redirects.pop(0))\n        except IndexError:\n            r.status_code = 200\n\n        r.headers = CaseInsensitiveDict({\"Location\": \"/\"})\n        r.raw = self._build_raw()\n        r.request = request\n        return r\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.589380502700806}
{"question": "What is the precise definition of Requests' \"Session\" concept in terms of connection reuse and state management?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' Session concept (src/requests/sessions.py) is defined as a stateful object that manages persistent settings and connection reuse across multiple HTTP requests. Key aspects include: 1) Connection pooling - Sessions use urllib3's connection pooling through HTTPAdapter, maintaining TCP connections to hosts for reuse, significantly improving performance by avoiding connection establishment overhead; 2) State persistence - Sessions maintain persistent state including cookies (RequestsCookieJar), authentication credentials, default headers, proxy settings, and request parameters across all requests; 3) Adapter management - Sessions mount HTTPAdapter instances for different URL schemes (http://, https://), enabling connection pooling and transport customization per protocol; 4) Configuration merging - Session-level settings (headers, auth, proxies, etc.) are merged with request-specific settings, with request settings taking precedence; 5) Cookie persistence - Cookies received in responses are automatically stored and sent in subsequent requests to the same domain; 6) Connection lifecycle - Sessions properly manage connection acquisition, usage, and return to the pool, ensuring efficient resource utilization; 7) Context management - Sessions implement context manager protocol for automatic cleanup and connection release; 8) Thread safety - Connection pools are thread-safe, allowing Sessions to be used across multiple threads. The Session provides a unified interface for making requests while maintaining state and optimizing performance through connection reuse.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.Session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 765, "end_line": 771}, "code_snippet": "    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n", "type": "function"}, {"name": "RedirectSession", "docstring": "", "methods": ["__init__", "send", "build_response", "_build_raw"], "attributes": [], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2555, "end_line": 2584}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.65015721321106}
{"question": "Where in the Requests codebase does the HTTP request flow begin from the Session object through the adapter layer to the underlying transport?", "answer": null, "relative_code_list": null, "ground_truth": "The HTTP request flow begins in src/requests/sessions.py with Session.request() method, which creates a Request object and calls Session.prepare_request() to create a PreparedRequest. The flow then moves to Session.send() which selects the appropriate adapter based on URL scheme and calls adapter.send(). The adapter layer is implemented in src/requests/adapters.py where HTTPAdapter.send() handles the actual transport through urllib3's PoolManager. The flow proceeds through adapter.build_response() to create a Response object, and then back through Session.resolve_redirects() for redirect handling. The complete flow is: Session.request()  Session.prepare_request()  Session.send()  HTTPAdapter.send()  urllib3.PoolManager.urlopen()  adapter.build_response()  Session.resolve_redirects()  Response object returned to user.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_with_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1697, "end_line": 1708}, "code_snippet": "    def test_session_get_adapter_prefix_with_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com/\"  # trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_not_matching_prefix = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_not_matching_prefix) is not adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_without_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1710, "end_line": 1721}, "code_snippet": "    def test_session_get_adapter_prefix_without_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com\"  # no trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_extended_hostname = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_extended_hostname) is adapter\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.671936273574829}
{"question": "Why does Requests' session management system optimize memory usage and performance in high-concurrency scenarios?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' session management system optimizes memory usage and performance in high-concurrency scenarios through several key mechanisms: 1) Connection pooling - Reuses connections across multiple requests, reducing memory overhead from connection establishment and maintenance; 2) Shared state - Sessions share common resources (cookies, headers, authentication) across requests, avoiding duplication; 3) Resource lifecycle management - Proper connection cleanup and resource release prevents memory leaks in long-running applications; 4) Thread-safe pools - Connection pools are thread-safe, enabling efficient concurrent access without additional synchronization overhead; 5) Configurable limits - Pool sizes and connection limits can be tuned to match application requirements and resource constraints; 6) Lazy initialization - Resources are created on-demand rather than pre-allocated, reducing initial memory footprint; 7) Efficient data structures - Uses optimized data structures for headers, cookies, and other session state; 8) Connection health management - Automatically removes stale or failed connections from pools, maintaining optimal performance; 9) Memory-efficient streaming - Supports streaming responses to avoid loading large responses into memory; 10) Context management - Proper cleanup through context managers ensures resources are released even in error scenarios.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "session", "is_method": false, "class_name": null, "parameters": [], "calls": ["Session"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 819, "end_line": 831}, "code_snippet": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n\n    .. deprecated:: 1.0.0\n\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n    return Session()\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_session_close_proxy_clear", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "mock.Mock", "mock.Mock", "mock.patch.dict", "session.close", "clear.assert_called_once_with", "clear.assert_called_once_with"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2155, "end_line": 2164}, "code_snippet": "    def test_session_close_proxy_clear(self):\n        proxies = {\n            \"one\": mock.Mock(),\n            \"two\": mock.Mock(),\n        }\n        session = requests.Session()\n        with mock.patch.dict(session.adapters[\"http://\"].proxy_manager, proxies):\n            session.close()\n            proxies[\"one\"].clear.assert_called_once_with()\n            proxies[\"two\"].clear.assert_called_once_with()\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_request_cookie_overrides_session_cookie", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 407, "end_line": 413}, "code_snippet": "    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        assert r.json()[\"cookies\"][\"foo\"] == \"baz\"\n        # Session cookie should not be modified\n        assert s.cookies[\"foo\"] == \"bar\"\n", "type": "function"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}], "retrieved_count": 10, "cost_time": 4.708416938781738}
{"question": "Why does Requests' connection pooling mechanism improve performance compared to creating new connections for each request?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' connection pooling mechanism significantly improves performance through several key optimizations: 1) Connection reuse - Eliminates the overhead of TCP connection establishment (3-way handshake) for subsequent requests to the same host; 2) SSL/TLS optimization - Avoids expensive SSL/TLS handshake and certificate verification for reused connections; 3) DNS caching - Reduces DNS lookup overhead by reusing connections to the same hostname; 4) HTTP/1.1 keep-alive - Leverages HTTP/1.1 persistent connections to send multiple requests over a single TCP connection; 5) Reduced latency - Connection reuse dramatically reduces request latency, especially for multiple requests to the same server; 6) Resource efficiency - Reduces the number of open file descriptors and system resources required for concurrent requests; 7) Connection lifecycle management - Properly manages connection timeouts, cleanup, and health checks to maintain optimal performance; 8) Concurrent request handling - Connection pools enable efficient handling of concurrent requests to the same host; 9) Automatic connection management - Handles connection failures, timeouts, and retries transparently; 10) Scalability - Configurable pool sizes allow applications to scale efficiently based on their specific needs and resource constraints.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_True", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2874, "end_line": 2903}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_True(self):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Cannot verify self-signed certificate\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url)\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_request_and_response_are_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pickle.loads", "pickle.loads", "httpbin", "pickle.dumps", "pickle.dumps"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1512, "end_line": 1522}, "code_snippet": "    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n", "type": "function"}, {"name": "test_different_connection_pool_for_mtls_settings", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "sock.getpeercert", "consume_socket_content", "sock.send", "s.get", "close_server.set", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2970, "end_line": 3007}, "code_snippet": "    def test_different_connection_pool_for_mtls_settings(self):\n        client_cert = None\n\n        def response_handler(sock):\n            nonlocal client_cert\n            client_cert = sock.getpeercert()\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=2,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n            mutual_tls=True,\n            cacert=\"tests/certs/expired/ca/ca.crt\",\n        )\n\n        cert = (\n            \"tests/certs/mtls/client/client.pem\",\n            \"tests/certs/mtls/client/client.key\",\n        )\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False, cert=cert)\n            assert r1.status_code == 200\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, cert=cert)\n            close_server.set()\n\n        assert client_cert is not None\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.754801511764526}
{"question": "Why does Requests implement connection reuse for performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements connection reuse for performance optimization to address fundamental network efficiency challenges: 1) Connection establishment overhead - TCP connection setup involves multiple round trips (SYN, SYN-ACK, ACK) that add significant latency; 2) SSL/TLS handshake cost - SSL/TLS negotiation involves expensive cryptographic operations that are avoided through connection reuse; 3) DNS resolution - DNS lookups are eliminated for subsequent requests to the same host; 4) HTTP/1.1 compliance - Leverages HTTP/1.1 keep-alive feature to send multiple requests over a single connection; 5) Reduced server load - Fewer connection establishments reduce server-side resource consumption; 6) Network efficiency - Minimizes network overhead and reduces bandwidth usage from connection setup; 7) Improved throughput - Connection reuse enables higher request throughput, especially for applications making many requests to the same servers; 8) Resource conservation - Reduces the number of open file descriptors and system resources required; 9) Latency reduction - Eliminates connection setup time for subsequent requests, dramatically improving response times; 10) Scalability - Enables applications to handle higher request volumes without proportional increases in resource usage.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}, {"name": "test_request_and_response_are_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pickle.loads", "pickle.loads", "httpbin", "pickle.dumps", "pickle.dumps"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1512, "end_line": 1522}, "code_snippet": "    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n", "type": "function"}, {"name": "test_HTTP_200_OK_GET_ALTERNATIVE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "getproxies", "s.send", "httpbin", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 203, "end_line": 210}, "code_snippet": "    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.790374755859375}
{"question": "Why does Requests implement a session-based architecture instead of stateless individual requests?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements a session-based architecture to provide essential stateful features that are crucial for real-world HTTP client usage: 1) Connection pooling - Sessions maintain persistent connections to hosts, significantly improving performance for multiple requests to the same server; 2) Cookie persistence - Sessions automatically maintain cookies across requests, essential for web applications and API authentication; 3) Authentication persistence - Sessions can store and reuse authentication credentials, avoiding repeated authentication for each request; 4) Configuration management - Sessions provide a way to set default headers, proxies, and other settings that apply to all requests; 5) Resource management - Sessions properly manage connection lifecycle, preventing resource leaks and ensuring efficient resource utilization; 6) State consistency - Sessions ensure consistent behavior across multiple requests (e.g., same headers, same authentication); 7) Performance optimization - Connection reuse and other optimizations are only possible with session-based state management; 8) Real-world compatibility - Most web applications and APIs require session-based features like cookie handling and connection reuse; 9) Thread safety - Sessions provide thread-safe state management for concurrent applications; 10) Cleanup and resource management - Sessions implement proper cleanup protocols to ensure resources are released appropriately.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "test_cookie_persists_via_api", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 401, "end_line": 405}, "code_snippet": "    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPDigestAuth", "parameters": ["self", "username", "password"], "calls": ["threading.local"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 110, "end_line": 114}, "code_snippet": "    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.Session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 765, "end_line": 771}, "code_snippet": "    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_request_cookie_overrides_session_cookie", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 407, "end_line": 413}, "code_snippet": "    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        assert r.json()[\"cookies\"][\"foo\"] == \"baz\"\n        # Session cookie should not be modified\n        assert s.cookies[\"foo\"] == \"bar\"\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.8423991203308105}
{"question": "Where in Requests is the session management system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The session management system is implemented in src/requests/sessions.py through the Session class and SessionRedirectMixin. Key components include: 1) Session class - main session implementation with connection pooling, cookie persistence, and configuration management; 2) SessionRedirectMixin - handles redirect logic and URL processing; 3) Session initialization in __init__() method sets up default headers, cookies, auth, proxies, and adapters; 4) prepare_request() method merges session settings with request-specific settings; 5) send() method coordinates request execution through adapters; 6) resolve_redirects() method handles redirect chains; 7) mount() method registers adapters for different URL schemes; 8) close() method manages resource cleanup. The session system integrates with other components: cookies from src/requests/cookies.py, authentication from src/requests/auth.py, adapters from src/requests/adapters.py, and request/response objects from src/requests/models.py. Sessions provide the primary interface for making HTTP requests with persistent state and connection pooling.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_cookie_persists_via_api", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 401, "end_line": 405}, "code_snippet": "    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "RedirectSession", "docstring": "", "methods": ["__init__", "send", "build_response", "_build_raw"], "attributes": [], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2555, "end_line": 2584}, "type": "class"}, {"name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.Session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 765, "end_line": 771}, "code_snippet": "    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}, {"name": "test_request_cookie_overrides_session_cookie", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 407, "end_line": 413}, "code_snippet": "    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        assert r.json()[\"cookies\"][\"foo\"] == \"baz\"\n        # Session cookie should not be modified\n        assert s.cookies[\"foo\"] == \"bar\"\n", "type": "function"}, {"name": "test_cookie_sent_on_redirect", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "s.get", "httpbin", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 380, "end_line": 384}, "code_snippet": "    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies/set?foo=bar\"))\n        r = s.get(httpbin(\"redirect/1\"))  # redirects to httpbin('get')\n        assert \"Cookie\" in r.json()[\"headers\"]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.834075450897217}
{"question": "Where in the Requests codebase does the response flow from the transport layer through the response object back to the user application?", "answer": null, "relative_code_list": null, "ground_truth": "The response flow from transport layer to user application occurs in src/requests/adapters.py through HTTPAdapter.build_response() method, which creates a Response object from the urllib3 response. The flow then returns through Session.send() in src/requests/sessions.py, which processes the response through redirect handling (Session.resolve_redirects()) and cookie extraction (extract_cookies_to_jar()). The Response object is then returned to the user application. The complete response flow is: urllib3.HTTPResponse  HTTPAdapter.build_response()  Response object creation  Session.send()  redirect processing  cookie extraction  Response object returned to user. The Response class itself is defined in src/requests/models.py and provides the user interface for accessing response data, headers, status codes, and content.", "score": null, "retrieved_content": [{"name": "Response", "docstring": "The :class:`Response <Response>` object, which contains a\nserver's response to an HTTP request.", "methods": ["__init__", "__enter__", "__exit__", "__getstate__", "__setstate__", "__repr__", "__bool__", "__nonzero__", "__iter__", "ok", "is_redirect", "is_permanent_redirect", "next", "apparent_encoding", "iter_content", "iter_lines", "content", "text", "json", "links", "raise_for_status", "close"], "attributes": ["__attrs__"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 640, "end_line": 1039}, "type": "class"}, {"name": "build_response", "is_method": true, "class_name": "RedirectSession", "parameters": ["self"], "calls": ["requests.Response", "CaseInsensitiveDict", "self._build_raw", "int", "self.redirects.pop"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2567, "end_line": 2579}, "code_snippet": "    def build_response(self):\n        request = self.calls[-1].args[0]\n        r = requests.Response()\n\n        try:\n            r.status_code = int(self.redirects.pop(0))\n        except IndexError:\n            r.status_code = 200\n\n        r.headers = CaseInsensitiveDict({\"Location\": \"/\"})\n        r.raw = self._build_raw()\n        r.request = request\n        return r\n", "type": "function"}, {"name": "resolve_redirects", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp", "req", "stream", "timeout", "verify", "cert", "proxies", "yield_requests"], "calls": ["self.get_redirect_target", "urlparse", "req.copy", "hist.append", "resp.close", "url.startswith", "urlparse", "parsed.geturl", "to_native_string", "self.rebuild_method", "headers.pop", "extract_cookies_to_jar", "merge_cookies", "prepared_request.prepare_cookies", "self.rebuild_proxies", "self.rebuild_auth", "len", "TooManyRedirects", "urlparse", "join", "parsed._replace", "urljoin", "requote_uri", "rewind_body", "self.send", "extract_cookies_to_jar", "self.get_redirect_target", "resp.raw.read", "requote_uri", "prepared_request.headers.pop", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 159, "end_line": 280}, "code_snippet": "    def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_empty_response_has_content_none", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1417, "end_line": 1419}, "code_snippet": "    def test_empty_response_has_content_none(self):\n        r = requests.Response()\n        assert r.content is None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cookiejar_from_dict", "datetime.timedelta"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 658, "end_line": 703}, "code_snippet": "    def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None\n", "type": "function"}, {"name": "test_response_is_iterable", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response", "StringIO.StringIO", "setattr", "next", "io.close", "read_", "iter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1421, "end_line": 1432}, "code_snippet": "    def test_response_is_iterable(self):\n        r = requests.Response()\n        io = StringIO.StringIO(\"abc\")\n        read_ = io.read\n\n        def read_mock(amt, decode_content=None):\n            return read_(amt)\n\n        setattr(io, \"read\", read_mock)\n        r.raw = io\n        assert next(iter(r))\n        io.close()\n", "type": "function"}, {"name": "test_hook_receives_request_arguments", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "requests.Request", "s.prepare_request", "s.send", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1156, "end_line": 1164}, "code_snippet": "    def test_hook_receives_request_arguments(self, httpbin):\n        def hook(resp, **kwargs):\n            assert resp is not None\n            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request(\"GET\", httpbin(), hooks={\"response\": hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n", "type": "function"}, {"name": "test_request_and_response_are_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pickle.loads", "pickle.loads", "httpbin", "pickle.dumps", "pickle.dumps"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1512, "end_line": 1522}, "code_snippet": "    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n", "type": "function"}, {"name": "test_response_iter_lines", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "r.iter_lines", "next", "httpbin", "len", "list"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2123, "end_line": 2129}, "code_snippet": "    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin(\"stream/4\"), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n        next(it)\n        assert len(list(it)) == 3\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.88241720199585}
{"question": "Where does the authentication flow from handler selection through credential application to request execution?", "answer": null, "relative_code_list": null, "ground_truth": "The authentication flow occurs in multiple locations: 1) Authentication handler selection happens in src/requests/sessions.py during Session.prepare_request() where session auth and request auth are merged; 2) Credential application occurs in src/requests/models.py in PreparedRequest.prepare_auth() method, which calls the authentication handler to add Authorization headers; 3) Authentication handlers are defined in src/requests/auth.py (HTTPBasicAuth, HTTPDigestAuth, etc.) and implement the __call__() method to modify request headers; 4) Request execution with authentication occurs in src/requests/adapters.py through HTTPAdapter.send() which sends the prepared request with authentication headers; 5) Authentication challenge handling (for 401 responses) is implemented in HTTPDigestAuth.handle_401() method in src/requests/auth.py. The complete flow is: Session.prepare_request()  PreparedRequest.prepare_auth()  AuthHandler.__call__()  HTTPAdapter.send()  Response processing  AuthHandler.handle_401() (if needed).", "score": null, "retrieved_content": [{"name": "__call__", "is_method": true, "class_name": "HTTPDigestAuth", "parameters": ["self", "r"], "calls": ["self.init_per_thread_state", "r.register_hook", "r.register_hook", "self.build_digest_header", "r.body.tell"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 285, "end_line": 303}, "code_snippet": "    def __call__(self, r):\n        # Initialize per-thread state, if needed\n        self.init_per_thread_state()\n        # If we have a saved nonce, skip the 401\n        if self._thread_local.last_nonce:\n            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)\n        try:\n            self._thread_local.pos = r.body.tell()\n        except AttributeError:\n            # In the case of HTTPDigestAuth being reused and the body of\n            # the previous request was a file-like object, pos has the\n            # file position of the previous body. Ensure it's set to\n            # None.\n            self._thread_local.pos = None\n        r.register_hook(\"response\", self.handle_401)\n        r.register_hook(\"response\", self.handle_redirect)\n        self._thread_local.num_401_calls = 1\n\n        return r\n", "type": "function"}, {"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "HTTPBasicAuth", "parameters": ["self", "r"], "calls": ["_basic_auth_str"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 94, "end_line": 96}, "code_snippet": "    def __call__(self, r):\n        r.headers[\"Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\n", "type": "function"}, {"name": "__call__", "is_method": true, "class_name": "HTTPProxyAuth", "parameters": ["self", "r"], "calls": ["_basic_auth_str"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 102, "end_line": 104}, "code_snippet": "    def __call__(self, r):\n        r.headers[\"Proxy-Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\n", "type": "function"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}, {"name": "__call__", "is_method": true, "class_name": "AuthBase", "parameters": ["self", "r"], "calls": ["NotImplementedError"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 72, "end_line": 73}, "code_snippet": "    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.914199590682983}
{"question": "Where does Requests store its authentication handlers?", "answer": null, "relative_code_list": null, "ground_truth": "Requests stores its authentication handlers in src/requests/auth.py. This file contains: 1) HTTPBasicAuth class for Basic Authentication; 2) HTTPDigestAuth class for Digest Authentication with support for MD5, SHA, SHA-256, and SHA-512 algorithms; 3) HTTPProxyAuth class for proxy authentication; 4) AuthBase abstract base class that defines the interface for all authentication handlers; 5) Helper functions like _basic_auth_str() for encoding authentication credentials. The authentication handlers are callable objects that implement the __call__() method to modify Request objects by adding appropriate Authorization or Proxy-Authorization headers. These handlers are applied during request preparation in PreparedRequest.prepare_auth() method in src/requests/models.py, and they integrate with the session management system in src/requests/sessions.py for persistent authentication across multiple requests.", "score": null, "retrieved_content": [{"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "test_should_strip_auth_host_change", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.should_strip_auth"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1901, "end_line": 1905}, "code_snippet": "    def test_should_strip_auth_host_change(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\n            \"http://example.com/foo\", \"http://another.example.com/\"\n        )\n", "type": "function"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}, {"name": "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 529, "end_line": 542}, "code_snippet": "    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.9432830810546875}
{"question": "Where are Requests' built-in adapters defined?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' built-in adapters are defined in src/requests/adapters.py. The main adapter implementations include: 1) BaseAdapter - abstract base class defining the adapter interface with send() and close() methods; 2) HTTPAdapter - the primary implementation that wraps urllib3's PoolManager for HTTP/HTTPS connections, providing connection pooling, retry logic, proxy support, and SSL/TLS handling; 3) Adapter mounting system - Sessions mount adapters for different URL schemes (http://, https://) in Session.__init__() method in src/requests/sessions.py; 4) HTTPAdapter configuration includes pool_connections, pool_maxsize, max_retries, and pool_block parameters; 5) HTTPAdapter methods include send(), build_response(), cert_verify(), and connection pool management methods. The adapters provide the transport abstraction layer between Requests' high-level API and urllib3's low-level transport implementation. Custom adapters can be implemented by subclassing BaseAdapter and mounted to Sessions for specialized transport needs.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "get_adapter", "is_method": true, "class_name": "Session", "parameters": ["self", "url"], "calls": ["self.adapters.items", "InvalidSchema", "startswith", "prefix.lower", "url.lower"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 781, "end_line": 792}, "code_snippet": "    def get_adapter(self, url):\n        \"\"\"\n        Returns the appropriate connection adapter for the given URL.\n\n        :rtype: requests.adapters.BaseAdapter\n        \"\"\"\n        for prefix, adapter in self.adapters.items():\n            if url.lower().startswith(prefix.lower()):\n                return adapter\n\n        # Nothing matches :-/\n        raise InvalidSchema(f\"No connection adapters were found for {url!r}\")\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_with_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1697, "end_line": 1708}, "code_snippet": "    def test_session_get_adapter_prefix_with_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com/\"  # trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_not_matching_prefix = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_not_matching_prefix) is not adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_without_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1710, "end_line": 1721}, "code_snippet": "    def test_session_get_adapter_prefix_without_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com\"  # no trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_extended_hostname = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_extended_hostname) is adapter\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}], "retrieved_count": 10, "cost_time": 4.973539113998413}
{"question": "Where in the Requests codebase is the core HTTP client implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The core HTTP client is implemented across multiple files in the src/requests/ directory: 1) Main API functions (get, post, etc.) are defined in src/requests/api.py and use Session objects internally; 2) Session management and request coordination is implemented in src/requests/sessions.py through the Session class; 3) Request and Response objects are defined in src/requests/models.py; 4) Transport abstraction and connection pooling is handled in src/requests/adapters.py through HTTPAdapter; 5) Authentication is implemented in src/requests/auth.py; 6) Cookie handling is in src/requests/cookies.py; 7) Exception classes are defined in src/requests/exceptions.py; 8) Utility functions are in src/requests/utils.py. The main entry point is src/requests/__init__.py which imports and exposes the public API. The core client architecture follows a layered approach: API layer (api.py)  Session layer (sessions.py)  Request/Response layer (models.py)  Adapter layer (adapters.py)  Transport layer (urllib3).", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_requests_history_is_saved", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2099, "end_line": 2105}, "code_snippet": "    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin(\"redirect/5\"))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n            assert item.history == total[0:i]\n            i += 1\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": ["default_hooks"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 334, "end_line": 349}, "code_snippet": "    def __init__(self):\n        #: HTTP verb to send to the server.\n        self.method = None\n        #: HTTP URL to send the request to.\n        self.url = None\n        #: dictionary of HTTP headers.\n        self.headers = None\n        # The `CookieJar` used to create the Cookie header will be stored here\n        # after prepare_cookies is called\n        self._cookies = None\n        #: request body to send to the server.\n        self.body = None\n        #: dictionary of callback hooks, for internal usage.\n        self.hooks = default_hooks()\n        #: integer denoting starting position of a readable file-like body.\n        self._body_position = None\n", "type": "function"}, {"name": "test_http_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.exceptions.HTTPError", "requests.Response", "requests.exceptions.HTTPError", "requests.exceptions.HTTPError", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1575, "end_line": 1583}, "code_snippet": "    def test_http_error(self):\n        error = requests.exceptions.HTTPError()\n        assert not error.response\n        response = requests.Response()\n        error = requests.exceptions.HTTPError(response=response)\n        assert error.response == response\n        error = requests.exceptions.HTTPError(\"message\", response=response)\n        assert str(error) == \"message\"\n        assert error.response == response\n", "type": "function"}, {"name": "test_http_302_doesnt_change_head_to_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.head", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 289, "end_line": 294}, "code_snippet": "    def test_http_302_doesnt_change_head_to_get(self, httpbin):\n        r = requests.head(httpbin(\"status\", \"302\"), allow_redirects=True)\n        assert r.status_code == 200\n        assert r.request.method == \"HEAD\"\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_HTTP_200_OK_HEAD", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.head", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 521, "end_line": 523}, "code_snippet": "    def test_HTTP_200_OK_HEAD(self, httpbin):\n        r = requests.head(httpbin(\"get\"))\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_http_301_doesnt_change_head_to_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.head", "print", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 274, "end_line": 280}, "code_snippet": "    def test_http_301_doesnt_change_head_to_get(self, httpbin):\n        r = requests.head(httpbin(\"status\", \"301\"), allow_redirects=True)\n        print(r.content)\n        assert r.status_code == 200\n        assert r.request.method == \"HEAD\"\n        assert r.history[0].status_code == 301\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}], "retrieved_count": 10, "cost_time": 5.000791311264038}
{"question": "Why does Requests implement request/response streaming for memory efficiency in large data transfers?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements request/response streaming for memory efficiency to handle large data transfers without loading the entire response into memory at once. Key mechanisms include: 1) Stream parameter - When stream=True is set on requests, the response content is not automatically loaded into memory; 2) iter_content() method - Provides chunked iteration over response data with configurable chunk sizes, avoiding memory exhaustion for large responses; 3) Raw response access - The raw attribute provides file-like access to the response stream when streaming is enabled; 4) Lazy content loading - Response content is only loaded when explicitly accessed (via .content property), not during initial response creation; 5) Chunked processing - Data can be processed in small chunks (default 1 byte, configurable) rather than loading the entire response; 6) Memory conservation - Streaming prevents memory exhaustion when downloading large files or processing large API responses; 7) Connection reuse - Streaming works with connection pooling to maintain efficiency; 8) Error handling - Streaming includes proper error handling for chunked encoding, content decoding, and connection issues; 9) Unicode support - Streaming supports both binary and Unicode content with decode_unicode parameter; 10) Resource management - Proper cleanup of streaming resources through context managers and close() methods.", "score": null, "retrieved_content": [{"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_response_iter_lines", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "r.iter_lines", "next", "httpbin", "len", "list"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2123, "end_line": 2129}, "code_snippet": "    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin(\"stream/4\"), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n        next(it)\n        assert len(list(it)) == 3\n", "type": "function"}, {"name": "test_stream_timeout", "is_method": true, "class_name": "TestTimeout", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2484, "end_line": 2488}, "code_snippet": "    def test_stream_timeout(self, httpbin):\n        try:\n            requests.get(httpbin(\"delay/10\"), timeout=2.0)\n        except requests.exceptions.Timeout as e:\n            assert \"Read timed out\" in e.args[0].args[0]\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_DIGEST_STREAM", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "r.raw.read", "r.raw.read"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 773, "end_line": 782}, "code_snippet": "    def test_DIGEST_STREAM(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b\"\"\n\n            r = requests.get(url, auth=auth, stream=False)\n            assert r.raw.read() == b\"\"\n", "type": "function"}, {"name": "test_response_is_iterable", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response", "StringIO.StringIO", "setattr", "next", "io.close", "read_", "iter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1421, "end_line": 1432}, "code_snippet": "    def test_response_is_iterable(self):\n        r = requests.Response()\n        io = StringIO.StringIO(\"abc\")\n        read_ = io.read\n\n        def read_mock(amt, decode_content=None):\n            return read_(amt)\n\n        setattr(io, \"read\", read_mock)\n        r.raw = io\n        assert next(iter(r))\n        io.close()\n", "type": "function"}, {"name": "test_chunked_upload_does_not_set_content_length_header", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.Request", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2221, "end_line": 2230}, "code_snippet": "    def test_chunked_upload_does_not_set_content_length_header(self, httpbin):\n        \"\"\"Ensure that requests with a generator body stream using\n        Transfer-Encoding: chunked, not a Content-Length header.\n        \"\"\"\n        data = (i for i in [b\"a\", b\"b\", b\"c\"])\n        url = httpbin(\"post\")\n        r = requests.Request(\"POST\", url, data=data)\n        prepared_request = r.prepare()\n        assert \"Transfer-Encoding\" in prepared_request.headers\n        assert \"Content-Length\" not in prepared_request.headers\n", "type": "function"}, {"name": "test_prepare_body_position_non_stream", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["prepare", "requests.Request"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1968, "end_line": 1971}, "code_snippet": "    def test_prepare_body_position_non_stream(self):\n        data = b\"the data\"\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position is None\n", "type": "function"}, {"name": "test_manual_redirect_with_partial_body_read", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "s.get", "s.resolve_redirects", "r1.iter_content", "next", "r2.iter_content", "next", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1949, "end_line": 1966}, "code_snippet": "    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin(\"redirect/2\"), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n        # read only the first eight bytes of the response body,\n        # then follow the redirect\n        r1.iter_content(8)\n        r2 = next(rg)\n        assert r2.is_redirect\n\n        # read all of the response via iter_content,\n        # then follow the redirect\n        for _ in r2.iter_content():\n            pass\n        r3 = next(rg)\n        assert not r3.is_redirect\n", "type": "function"}, {"name": "resolve_redirects", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp", "req", "stream", "timeout", "verify", "cert", "proxies", "yield_requests"], "calls": ["self.get_redirect_target", "urlparse", "req.copy", "hist.append", "resp.close", "url.startswith", "urlparse", "parsed.geturl", "to_native_string", "self.rebuild_method", "headers.pop", "extract_cookies_to_jar", "merge_cookies", "prepared_request.prepare_cookies", "self.rebuild_proxies", "self.rebuild_auth", "len", "TooManyRedirects", "urlparse", "join", "parsed._replace", "urljoin", "requote_uri", "rewind_body", "self.send", "extract_cookies_to_jar", "self.get_redirect_target", "resp.raw.read", "requote_uri", "prepared_request.headers.pop", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 159, "end_line": 280}, "code_snippet": "    def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp\n", "type": "function"}], "retrieved_count": 10, "cost_time": 5.046611547470093}
{"question": "Why does Requests use connection pooling for concurrent request handling?", "answer": null, "relative_code_list": null, "ground_truth": "Requests uses connection pooling for concurrent request handling to efficiently manage multiple simultaneous connections: 1) Concurrent access - Connection pools enable multiple threads or processes to safely share connections to the same hosts; 2) Resource management - Pools limit the number of concurrent connections to prevent resource exhaustion and server overload; 3) Thread safety - Pool implementations are thread-safe, eliminating the need for external synchronization; 4) Connection lifecycle - Pools manage connection creation, reuse, and cleanup automatically; 5) Load balancing - Pools distribute requests across available connections, improving overall throughput; 6) Failure handling - Pools can handle connection failures and automatically create new connections as needed; 7) Performance optimization - Reusing connections within the pool eliminates connection establishment overhead; 8) Configurable limits - Pool sizes can be tuned based on application needs and server capabilities; 9) Health monitoring - Pools can monitor connection health and remove stale connections; 10) Scalability - Connection pooling enables applications to scale efficiently without proportional increases in resource usage.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_different_connection_pool_for_mtls_settings", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "sock.getpeercert", "consume_socket_content", "sock.send", "s.get", "close_server.set", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2970, "end_line": 3007}, "code_snippet": "    def test_different_connection_pool_for_mtls_settings(self):\n        client_cert = None\n\n        def response_handler(sock):\n            nonlocal client_cert\n            client_cert = sock.getpeercert()\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=2,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n            mutual_tls=True,\n            cacert=\"tests/certs/expired/ca/ca.crt\",\n        )\n\n        cert = (\n            \"tests/certs/mtls/client/client.pem\",\n            \"tests/certs/mtls/client/client.key\",\n        )\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False, cert=cert)\n            assert r1.status_code == 200\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, cert=cert)\n            close_server.set()\n\n        assert client_cert is not None\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_True", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2874, "end_line": 2903}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_True(self):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Cannot verify self-signed certificate\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url)\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_bundle_expired_cert", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2905, "end_line": 2936}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_bundle_expired_cert(\n        self,\n    ):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Has right trust bundle, but certificate expired\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, verify=\"tests/certs/expired/ca/ca.crt\")\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_bundle_unexpired_cert", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "s.get", "close_server.set", "len"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2938, "end_line": 2968}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_bundle_unexpired_cert(\n        self,\n    ):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/valid/server/server.pem\",\n            keyfile=\"tests/certs/valid/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            r2 = s.get(url, verify=\"tests/certs/valid/ca/ca.crt\")\n            assert r2.status_code == 200\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 5.06889796257019}
{"question": "Where does the redirect handling flow from response analysis through location extraction to new request creation?", "answer": null, "relative_code_list": null, "ground_truth": "The redirect handling flow is implemented in src/requests/sessions.py through SessionRedirectMixin class: 1) Response analysis occurs in SessionRedirectMixin.get_redirect_target() which checks if response.is_redirect and extracts the Location header; 2) Location extraction and URL processing happens in SessionRedirectMixin.resolve_redirects() which handles relative URLs, scheme-less URLs, and fragment preservation; 3) New request creation occurs in SessionRedirectMixin.resolve_redirects() where prepared_request = req.copy() creates a copy of the original request; 4) Method rewriting is handled by SessionRedirectMixin.rebuild_method() which changes HTTP methods according to redirect status codes; 5) Authentication stripping is managed by SessionRedirectMixin.should_strip_auth() when redirecting to different hosts. The complete flow is: Response received  get_redirect_target()  resolve_redirects()  req.copy()  rebuild_method()  should_strip_auth()  new PreparedRequest  adapter.send()  recursive redirect handling.", "score": null, "retrieved_content": [{"name": "test_redirect_rfc1808_to_non_ascii_location", "is_method": false, "class_name": null, "parameters": [], "calls": ["threading.Event", "Server", "consume_socket_content", "sock.send", "redirect_request.append", "sock.send", "requests.get", "startswith", "close_server.set", "consume_socket_content", "len", "format", "location.encode", "expected_path.decode"], "code_location": {"file": "test_lowlevel.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 308, "end_line": 339}, "code_snippet": "def test_redirect_rfc1808_to_non_ascii_location():\n    path = ''\n    expected_path = b'%C5%A1'\n    redirect_request = []  # stores the second request to the server\n\n    def redirect_resp_handler(sock):\n        consume_socket_content(sock, timeout=0.5)\n        location = f'//{host}:{port}/{path}'\n        sock.send(\n            (\n                b'HTTP/1.1 301 Moved Permanently\\r\\n'\n                b'Content-Length: 0\\r\\n'\n                b'Location: %s\\r\\n'\n                b'\\r\\n'\n            ) % location.encode('utf8')\n        )\n        redirect_request.append(consume_socket_content(sock, timeout=0.5))\n        sock.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n\n    close_server = threading.Event()\n    server = Server(redirect_resp_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}'\n        r = requests.get(url=url, allow_redirects=True)\n        assert r.status_code == 200\n        assert len(r.history) == 1\n        assert r.history[0].status_code == 301\n        assert redirect_request[0].startswith(b'GET /' + expected_path + b' HTTP/1.1')\n        assert r.url == '{}/{}'.format(url, expected_path.decode('ascii'))\n\n        close_server.set()\n", "type": "function"}, {"name": "test_HTTP_302_ALLOW_REDIRECT_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 212, "end_line": 216}, "code_snippet": "    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin(\"redirect\", \"1\"))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "is_redirect", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 770, "end_line": 774}, "code_snippet": "    def is_redirect(self):\n        \"\"\"True if this Response is a well-formed HTTP redirect that could have\n        been processed automatically (by :meth:`Session.resolve_redirects`).\n        \"\"\"\n        return \"location\" in self.headers and self.status_code in REDIRECT_STATI\n", "type": "function"}, {"name": "test_manual_redirect_with_partial_body_read", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "s.get", "s.resolve_redirects", "r1.iter_content", "next", "r2.iter_content", "next", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1949, "end_line": 1966}, "code_snippet": "    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin(\"redirect/2\"), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n        # read only the first eight bytes of the response body,\n        # then follow the redirect\n        r1.iter_content(8)\n        r2 = next(rg)\n        assert r2.is_redirect\n\n        # read all of the response via iter_content,\n        # then follow the redirect\n        for _ in r2.iter_content():\n            pass\n        r3 = next(rg)\n        assert not r3.is_redirect\n", "type": "function"}, {"name": "test_header_and_body_removal_on_redirect", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "requests.Request", "ses.prepare_request", "ses.send", "next", "httpbin", "ses.resolve_redirects"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 310, "end_line": 325}, "code_snippet": "    def test_header_and_body_removal_on_redirect(self, httpbin):\n        purged_headers = (\"Content-Length\", \"Content-Type\")\n        ses = requests.Session()\n        req = requests.Request(\"POST\", httpbin(\"post\"), data={\"test\": \"data\"})\n        prep = ses.prepare_request(req)\n        resp = ses.send(prep)\n\n        # Mimic a redirect response\n        resp.status_code = 302\n        resp.headers[\"location\"] = \"get\"\n\n        # Run request through resolve_redirects\n        next_resp = next(ses.resolve_redirects(resp, prep))\n        assert next_resp.request.body is None\n        for header in purged_headers:\n            assert header not in next_resp.request.headers\n", "type": "function"}, {"name": "test_transfer_enc_removal_on_redirect", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "requests.Request", "ses.prepare_request", "requests.Response", "io.BytesIO", "setattr", "httpbin", "next", "httpbin", "ses.resolve_redirects", "range"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 327, "end_line": 348}, "code_snippet": "    def test_transfer_enc_removal_on_redirect(self, httpbin):\n        purged_headers = (\"Transfer-Encoding\", \"Content-Type\")\n        ses = requests.Session()\n        req = requests.Request(\"POST\", httpbin(\"post\"), data=(b\"x\" for x in range(1)))\n        prep = ses.prepare_request(req)\n        assert \"Transfer-Encoding\" in prep.headers\n\n        # Create Response to avoid https://github.com/kevin1024/pytest-httpbin/issues/33\n        resp = requests.Response()\n        resp.raw = io.BytesIO(b\"the content\")\n        resp.request = prep\n        setattr(resp.raw, \"release_conn\", lambda *args: args)\n\n        # Mimic a redirect response\n        resp.status_code = 302\n        resp.headers[\"location\"] = httpbin(\"get\")\n\n        # Run request through resolve_redirect\n        next_resp = next(ses.resolve_redirects(resp, prep))\n        assert next_resp.request.body is None\n        for header in purged_headers:\n            assert header not in next_resp.request.headers\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "RedirectSession", "parameters": ["self", "order_of_redirects"], "calls": [], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2556, "end_line": 2561}, "code_snippet": "    def __init__(self, order_of_redirects):\n        self.redirects = order_of_redirects\n        self.calls = []\n        self.max_redirects = 30\n        self.cookies = {}\n        self.trust_env = False\n", "type": "function"}, {"name": "get_redirect_target", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp"], "calls": ["location.encode", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 125}, "code_snippet": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None\n", "type": "function"}, {"name": "test_http_301_changes_post_to_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.post", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 267, "end_line": 272}, "code_snippet": "    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"301\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 301\n        assert r.history[0].is_redirect\n", "type": "function"}, {"name": "test_HTTP_307_ALLOW_REDIRECT_POST", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.post", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 218, "end_line": 227}, "code_snippet": "    def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):\n        r = requests.post(\n            httpbin(\"redirect-to\"),\n            data=\"test\",\n            params={\"url\": \"post\", \"status_code\": 307},\n        )\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n        assert r.json()[\"data\"] == \"test\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 5.097299575805664}
{"question": "Where is the \"send\" method defined in the adapter hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "The \"send\" method is defined in the adapter hierarchy in src/requests/adapters.py: 1) BaseAdapter.send() - abstract method defined in the BaseAdapter class that serves as the interface contract for all adapters; 2) HTTPAdapter.send() - concrete implementation in the HTTPAdapter class that handles HTTP/HTTPS requests through urllib3's PoolManager. The send() method signature is: send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None) where request is a PreparedRequest object. The HTTPAdapter.send() method handles connection pooling, retry logic, proxy support, SSL/TLS configuration, and response building. It delegates the actual transport to urllib3's PoolManager.urlopen() method and then builds a Response object through HTTPAdapter.build_response(). The send() method is called by Session.send() in src/requests/sessions.py after selecting the appropriate adapter based on the URL scheme.", "score": null, "retrieved_content": [{"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "send", "is_method": true, "class_name": "RedirectSession", "parameters": ["self"], "calls": ["self.calls.append", "self.build_response", "SendCall"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2563, "end_line": 2565}, "code_snippet": "    def send(self, *args, **kwargs):\n        self.calls.append(SendCall(args, kwargs))\n        return self.build_response()\n", "type": "function"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "send", "is_method": true, "class_name": "BaseAdapter", "parameters": ["self", "request", "stream", "timeout", "verify", "cert", "proxies"], "calls": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 119, "end_line": 136}, "code_snippet": "    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        \"\"\"\n        raise NotImplementedError\n", "type": "function"}, {"name": "test_respect_proxy_env_on_send_with_redirects", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "httpbin", "print", "requests.Request", "session.send", "request.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 622, "end_line": 629}, "code_snippet": "    def test_respect_proxy_env_on_send_with_redirects(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                url = httpbin(\"redirect/1\")\n                print(url)\n                request = requests.Request(\"GET\", url)\n                session.send(request.prepare())\n", "type": "function"}, {"name": "test_respect_proxy_env_on_send_self_prepared_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "requests.Request", "session.send", "httpbin", "request.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 607, "end_line": 612}, "code_snippet": "    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request(\"GET\", httpbin())\n                session.send(request.prepare())\n", "type": "function"}, {"name": "test_cannot_send_unprepared_requests", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "pytest.raises", "send", "httpbin", "requests.Session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1570, "end_line": 1573}, "code_snippet": "    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_non_prepared_request_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "requests.Request", "pytest.raises", "s.send", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1136, "end_line": 1142}, "code_snippet": "    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2282516956329346}
{"question": "Where in Requests' codebase is the \"get\" method defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"get\" method is defined in multiple locations depending on the context: 1) Module-level get() function is defined in src/requests/api.py as a convenience function that calls requests.request('GET', url, **kwargs); 2) Session.get() method is defined in src/requests/sessions.py in the Session class, which calls self.request('GET', url, **kwargs) with allow_redirects=True by default; 3) The actual request processing is handled by Session.request() method which creates Request objects and processes them through the adapter layer. The module-level get() function creates a temporary Session object and delegates to Session.get(), while Session.get() provides persistent session features like connection pooling, cookie persistence, and configuration management. Both implementations ultimately use the same underlying request processing pipeline through Session.request()  Session.prepare_request()  Session.send()  HTTPAdapter.send().", "score": null, "retrieved_content": [{"name": "get", "is_method": false, "class_name": null, "parameters": ["url", "params"], "calls": ["request"], "code_location": {"file": "api.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 62, "end_line": 73}, "code_snippet": "def get(url, params=None, **kwargs):\n    r\"\"\"Sends a GET request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"get\", url, params=params, **kwargs)\n", "type": "function"}, {"name": "get", "is_method": true, "class_name": "Session", "parameters": ["self", "url"], "calls": ["kwargs.setdefault", "self.request"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 593, "end_line": 602}, "code_snippet": "    def get(self, url, **kwargs):\n        r\"\"\"Sends a GET request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", True)\n        return self.request(\"GET\", url, **kwargs)\n", "type": "function"}, {"name": "TestRequests", "docstring": "", "methods": ["test_entry_points", "test_invalid_url", "test_basic_building", "test_no_content_length", "test_no_body_content_length", "test_empty_content_length", "test_override_content_length", "test_path_is_not_double_encoded", "test_params_are_added_before_fragment", "test_params_original_order_is_preserved_by_default", "test_params_bytes_are_encoded", "test_binary_put", "test_whitespaces_are_removed_from_url", "test_mixed_case_scheme_acceptable", "test_HTTP_200_OK_GET_ALTERNATIVE", "test_HTTP_302_ALLOW_REDIRECT_GET", "test_HTTP_307_ALLOW_REDIRECT_POST", "test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE", "test_HTTP_302_TOO_MANY_REDIRECTS", "test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS", "test_http_301_changes_post_to_get", "test_http_301_doesnt_change_head_to_get", "test_http_302_changes_post_to_get", "test_http_302_doesnt_change_head_to_get", "test_http_303_changes_post_to_get", "test_http_303_doesnt_change_head_to_get", "test_header_and_body_removal_on_redirect", "test_transfer_enc_removal_on_redirect", "test_fragment_maintained_on_redirect", "test_HTTP_200_OK_GET_WITH_PARAMS", "test_HTTP_200_OK_GET_WITH_MIXED_PARAMS", "test_set_cookie_on_301", "test_cookie_sent_on_redirect", "test_cookie_removed_on_expire", "test_cookie_quote_wrapped", "test_cookie_persists_via_api", "test_request_cookie_overrides_session_cookie", "test_request_cookies_not_persisted", "test_generic_cookiejar_works", "test_param_cookiejar_works", "test_cookielib_cookiejar_on_redirect", "test_requests_in_history_are_not_overridden", "test_history_is_always_a_list", "test_headers_on_session_with_None_are_not_sent", "test_headers_preserve_order", "test_user_agent_transfers", "test_HTTP_200_OK_HEAD", "test_HTTP_200_OK_PUT", "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "test_set_basicauth", "test_basicauth_encodes_byte_strings", "test_errors", "test_proxy_error", "test_proxy_error_on_bad_url", "test_respect_proxy_env_on_send_self_prepared_request", "test_respect_proxy_env_on_send_session_prepared_request", "test_respect_proxy_env_on_send_with_redirects", "test_respect_proxy_env_on_get", "test_respect_proxy_env_on_request", "test_proxy_authorization_preserved_on_request", "test_proxy_authorization_not_appended_to_https_request", "test_basicauth_with_netrc", "test_basicauth_with_netrc_leak", "test_DIGEST_HTTP_200_OK_GET", "test_DIGEST_AUTH_RETURNS_COOKIE", "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "test_DIGEST_STREAM", "test_DIGESTAUTH_WRONG_HTTP_401_GET", "test_DIGESTAUTH_QUOTES_QOP_VALUE", "test_POSTBIN_GET_POST_FILES", "test_invalid_files_input", "test_POSTBIN_SEEKED_OBJECT_WITH_NO_ITER", "test_POSTBIN_GET_POST_FILES_WITH_DATA", "test_post_with_custom_mapping", "test_conflicting_post_params", "test_request_ok_set", "test_status_raising", "test_decompress_gzip", "test_unicode_get", "test_unicode_header_name", "test_pyopenssl_redirect", "test_invalid_ca_certificate_path", "test_invalid_ssl_certificate_files", "test_env_cert_bundles", "test_http_with_certificate", "test_https_warnings", "test_certificate_failure", "test_urlencoded_get_query_multivalued_param", "test_form_encoded_post_query_multivalued_element", "test_different_encodings_dont_break_post", "test_unicode_multipart_post", "test_unicode_multipart_post_fieldnames", "test_unicode_method_name", "test_unicode_method_name_with_request_object", "test_non_prepared_request_error", "test_custom_content_type", "test_hook_receives_request_arguments", "test_session_hooks_are_used_with_no_request_hooks", "test_session_hooks_are_overridden_by_request_hooks", "test_prepared_request_hook", "test_prepared_from_session", "test_prepare_request_with_bytestring_url", "test_request_with_bytestring_host", "test_links", "test_cookie_parameters", "test_cookie_as_dict_keeps_len", "test_cookie_as_dict_keeps_items", "test_cookie_as_dict_keys", "test_cookie_as_dict_values", "test_cookie_as_dict_items", "test_cookie_duplicate_names_different_domains", "test_cookie_duplicate_names_raises_cookie_conflict_error", "test_cookie_policy_copy", "test_time_elapsed_blank", "test_empty_response_has_content_none", "test_response_is_iterable", "test_response_decode_unicode", "test_response_reason_unicode", "test_response_reason_unicode_fallback", "test_response_chunk_size_type", "test_iter_content_wraps_exceptions", "test_request_and_response_are_pickleable", "test_prepared_request_is_pickleable", "test_prepared_request_with_file_is_pickleable", "test_prepared_request_with_hook_is_pickleable", "test_cannot_send_unprepared_requests", "test_http_error", "test_session_pickling", "test_fixes_1329", "test_uppercase_scheme_redirect", "test_transport_adapter_ordering", "test_session_get_adapter_prefix_matching", "test_session_get_adapter_prefix_matching_mixed_case", "test_session_get_adapter_prefix_matching_is_case_insensitive", "test_session_get_adapter_prefix_with_trailing_slash", "test_session_get_adapter_prefix_without_trailing_slash", "test_header_remove_is_case_insensitive", "test_params_are_merged_case_sensitive", "test_long_authinfo_in_url", "test_header_keys_are_native", "test_header_validation", "test_header_value_not_str", "test_header_no_return_chars", "test_header_no_leading_space", "test_header_with_subclass_types", "test_can_send_objects_with_files", "test_can_send_file_object_with_non_string_filename", "test_autoset_header_values_are_native", "test_nonhttp_schemes_dont_check_URLs", "test_auth_is_stripped_on_http_downgrade", "test_auth_is_retained_for_redirect_on_host", "test_should_strip_auth_host_change", "test_should_strip_auth_http_downgrade", "test_should_strip_auth_https_upgrade", "test_should_strip_auth_port_change", "test_should_strip_auth_default_port", "test_manual_redirect_with_partial_body_read", "test_prepare_body_position_non_stream", "test_rewind_body", "test_rewind_partially_read_body", "test_rewind_body_no_seek", "test_rewind_body_failed_seek", "test_rewind_body_failed_tell", "_patch_adapter_gzipped_redirect", "test_redirect_with_wrong_gzipped_header", "test_basic_auth_str_is_always_native", "test_requests_history_is_saved", "test_json_param_post_content_type_works", "test_json_param_post_should_not_override_data_param", "test_response_iter_lines", "test_response_context_manager", "test_unconsumed_session_response_closes_connection", "test_response_iter_lines_reentrant", "test_session_close_proxy_clear", "test_proxy_auth", "test_proxy_auth_empty_pass", "test_response_json_when_content_is_None", "test_response_without_release_conn", "test_empty_stream_with_auth_does_not_set_content_length_header", "test_stream_with_auth_does_not_set_transfer_encoding_header", "test_chunked_upload_does_not_set_content_length_header", "test_custom_redirect_mixin"], "attributes": ["digest_auth_algo"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 82, "end_line": 2274}, "type": "class"}, {"name": "test_HTTP_200_OK_HEAD", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.head", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 521, "end_line": 523}, "code_snippet": "    def test_HTTP_200_OK_HEAD(self, httpbin):\n        r = requests.head(httpbin(\"get\"))\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_HTTP_200_OK_GET_ALTERNATIVE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "getproxies", "s.send", "httpbin", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 203, "end_line": 210}, "code_snippet": "    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_get", "is_method": true, "class_name": "TestCaseInsensitiveDict", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cid.get", "cid.get", "cid.get", "cid.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2334, "end_line": 2341}, "code_snippet": "    def test_get(self):\n        cid = CaseInsensitiveDict()\n        cid[\"spam\"] = \"oneval\"\n        cid[\"SPAM\"] = \"blueval\"\n        assert cid.get(\"spam\") == \"blueval\"\n        assert cid.get(\"SPAM\") == \"blueval\"\n        assert cid.get(\"sPam\") == \"blueval\"\n        assert cid.get(\"notspam\", \"default\") == \"default\"\n", "type": "function"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "test_unicode_get", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "url", "params"], "calls": ["pytest.mark.parametrize", "requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 946, "end_line": 947}, "code_snippet": "    def test_unicode_get(self, httpbin, url, params):\n        requests.get(httpbin(url), params=params)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.230982780456543}
{"question": "Where in Requests' codebase is the \"Session\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"Session\" class is defined in src/requests/sessions.py. The Session class inherits from SessionRedirectMixin and provides the main session management functionality. Key aspects of the Session class definition include: 1) Class definition: class Session(SessionRedirectMixin): with comprehensive docstring and usage examples; 2) __attrs__ list defining the attributes that are preserved during serialization/deserialization; 3) __init__() method that initializes session state including headers, cookies, auth, proxies, hooks, params, verify, cert, adapters, stream, trust_env, and max_redirects; 4) Context manager methods __enter__() and __exit__() for automatic resource cleanup; 5) Core methods like request(), prepare_request(), send(), get(), post(), etc. for making HTTP requests; 6) Configuration methods like mount() for adapter registration and merge_environment_settings() for environment integration; 7) Resource management methods like close() for cleanup. The Session class serves as the primary interface for making HTTP requests with persistent state, connection pooling, and configuration management.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "RedirectSession", "docstring": "", "methods": ["__init__", "send", "build_response", "_build_raw"], "attributes": [], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2555, "end_line": 2584}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "TestRequests", "docstring": "", "methods": ["test_entry_points", "test_invalid_url", "test_basic_building", "test_no_content_length", "test_no_body_content_length", "test_empty_content_length", "test_override_content_length", "test_path_is_not_double_encoded", "test_params_are_added_before_fragment", "test_params_original_order_is_preserved_by_default", "test_params_bytes_are_encoded", "test_binary_put", "test_whitespaces_are_removed_from_url", "test_mixed_case_scheme_acceptable", "test_HTTP_200_OK_GET_ALTERNATIVE", "test_HTTP_302_ALLOW_REDIRECT_GET", "test_HTTP_307_ALLOW_REDIRECT_POST", "test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE", "test_HTTP_302_TOO_MANY_REDIRECTS", "test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS", "test_http_301_changes_post_to_get", "test_http_301_doesnt_change_head_to_get", "test_http_302_changes_post_to_get", "test_http_302_doesnt_change_head_to_get", "test_http_303_changes_post_to_get", "test_http_303_doesnt_change_head_to_get", "test_header_and_body_removal_on_redirect", "test_transfer_enc_removal_on_redirect", "test_fragment_maintained_on_redirect", "test_HTTP_200_OK_GET_WITH_PARAMS", "test_HTTP_200_OK_GET_WITH_MIXED_PARAMS", "test_set_cookie_on_301", "test_cookie_sent_on_redirect", "test_cookie_removed_on_expire", "test_cookie_quote_wrapped", "test_cookie_persists_via_api", "test_request_cookie_overrides_session_cookie", "test_request_cookies_not_persisted", "test_generic_cookiejar_works", "test_param_cookiejar_works", "test_cookielib_cookiejar_on_redirect", "test_requests_in_history_are_not_overridden", "test_history_is_always_a_list", "test_headers_on_session_with_None_are_not_sent", "test_headers_preserve_order", "test_user_agent_transfers", "test_HTTP_200_OK_HEAD", "test_HTTP_200_OK_PUT", "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "test_set_basicauth", "test_basicauth_encodes_byte_strings", "test_errors", "test_proxy_error", "test_proxy_error_on_bad_url", "test_respect_proxy_env_on_send_self_prepared_request", "test_respect_proxy_env_on_send_session_prepared_request", "test_respect_proxy_env_on_send_with_redirects", "test_respect_proxy_env_on_get", "test_respect_proxy_env_on_request", "test_proxy_authorization_preserved_on_request", "test_proxy_authorization_not_appended_to_https_request", "test_basicauth_with_netrc", "test_basicauth_with_netrc_leak", "test_DIGEST_HTTP_200_OK_GET", "test_DIGEST_AUTH_RETURNS_COOKIE", "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "test_DIGEST_STREAM", "test_DIGESTAUTH_WRONG_HTTP_401_GET", "test_DIGESTAUTH_QUOTES_QOP_VALUE", "test_POSTBIN_GET_POST_FILES", "test_invalid_files_input", "test_POSTBIN_SEEKED_OBJECT_WITH_NO_ITER", "test_POSTBIN_GET_POST_FILES_WITH_DATA", "test_post_with_custom_mapping", "test_conflicting_post_params", "test_request_ok_set", "test_status_raising", "test_decompress_gzip", "test_unicode_get", "test_unicode_header_name", "test_pyopenssl_redirect", "test_invalid_ca_certificate_path", "test_invalid_ssl_certificate_files", "test_env_cert_bundles", "test_http_with_certificate", "test_https_warnings", "test_certificate_failure", "test_urlencoded_get_query_multivalued_param", "test_form_encoded_post_query_multivalued_element", "test_different_encodings_dont_break_post", "test_unicode_multipart_post", "test_unicode_multipart_post_fieldnames", "test_unicode_method_name", "test_unicode_method_name_with_request_object", "test_non_prepared_request_error", "test_custom_content_type", "test_hook_receives_request_arguments", "test_session_hooks_are_used_with_no_request_hooks", "test_session_hooks_are_overridden_by_request_hooks", "test_prepared_request_hook", "test_prepared_from_session", "test_prepare_request_with_bytestring_url", "test_request_with_bytestring_host", "test_links", "test_cookie_parameters", "test_cookie_as_dict_keeps_len", "test_cookie_as_dict_keeps_items", "test_cookie_as_dict_keys", "test_cookie_as_dict_values", "test_cookie_as_dict_items", "test_cookie_duplicate_names_different_domains", "test_cookie_duplicate_names_raises_cookie_conflict_error", "test_cookie_policy_copy", "test_time_elapsed_blank", "test_empty_response_has_content_none", "test_response_is_iterable", "test_response_decode_unicode", "test_response_reason_unicode", "test_response_reason_unicode_fallback", "test_response_chunk_size_type", "test_iter_content_wraps_exceptions", "test_request_and_response_are_pickleable", "test_prepared_request_is_pickleable", "test_prepared_request_with_file_is_pickleable", "test_prepared_request_with_hook_is_pickleable", "test_cannot_send_unprepared_requests", "test_http_error", "test_session_pickling", "test_fixes_1329", "test_uppercase_scheme_redirect", "test_transport_adapter_ordering", "test_session_get_adapter_prefix_matching", "test_session_get_adapter_prefix_matching_mixed_case", "test_session_get_adapter_prefix_matching_is_case_insensitive", "test_session_get_adapter_prefix_with_trailing_slash", "test_session_get_adapter_prefix_without_trailing_slash", "test_header_remove_is_case_insensitive", "test_params_are_merged_case_sensitive", "test_long_authinfo_in_url", "test_header_keys_are_native", "test_header_validation", "test_header_value_not_str", "test_header_no_return_chars", "test_header_no_leading_space", "test_header_with_subclass_types", "test_can_send_objects_with_files", "test_can_send_file_object_with_non_string_filename", "test_autoset_header_values_are_native", "test_nonhttp_schemes_dont_check_URLs", "test_auth_is_stripped_on_http_downgrade", "test_auth_is_retained_for_redirect_on_host", "test_should_strip_auth_host_change", "test_should_strip_auth_http_downgrade", "test_should_strip_auth_https_upgrade", "test_should_strip_auth_port_change", "test_should_strip_auth_default_port", "test_manual_redirect_with_partial_body_read", "test_prepare_body_position_non_stream", "test_rewind_body", "test_rewind_partially_read_body", "test_rewind_body_no_seek", "test_rewind_body_failed_seek", "test_rewind_body_failed_tell", "_patch_adapter_gzipped_redirect", "test_redirect_with_wrong_gzipped_header", "test_basic_auth_str_is_always_native", "test_requests_history_is_saved", "test_json_param_post_content_type_works", "test_json_param_post_should_not_override_data_param", "test_response_iter_lines", "test_response_context_manager", "test_unconsumed_session_response_closes_connection", "test_response_iter_lines_reentrant", "test_session_close_proxy_clear", "test_proxy_auth", "test_proxy_auth_empty_pass", "test_response_json_when_content_is_None", "test_response_without_release_conn", "test_empty_stream_with_auth_does_not_set_content_length_header", "test_stream_with_auth_does_not_set_transfer_encoding_header", "test_chunked_upload_does_not_set_content_length_header", "test_custom_redirect_mixin"], "attributes": ["digest_auth_algo"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 82, "end_line": 2274}, "type": "class"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "SessionRedirectMixin", "docstring": "", "methods": ["get_redirect_target", "should_strip_auth", "resolve_redirects", "rebuild_auth", "rebuild_proxies", "rebuild_method"], "attributes": [], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 106, "end_line": 353}, "type": "class"}, {"name": "RequestsWarning", "docstring": "Base warning for Requests.", "methods": [], "attributes": [], "code_location": {"file": "exceptions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 142, "end_line": 143}, "type": "class"}, {"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.194770336151123}
{"question": "Where are Requests' built-in adapter implementations located?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' built-in adapter implementations are located in src/requests/adapters.py. The main adapter implementations include: 1) BaseAdapter class - abstract base class defining the adapter interface with send() and close() methods; 2) HTTPAdapter class - the primary concrete implementation that wraps urllib3's PoolManager for HTTP/HTTPS connections; 3) HTTPAdapter methods include __init__(), send(), build_response(), cert_verify(), init_poolmanager(), proxy_manager_for(), and connection pool management methods; 4) Helper functions like _urllib3_request_context() for preparing request context for urllib3; 5) Default configuration constants like DEFAULT_POOLSIZE, DEFAULT_RETRIES, DEFAULT_POOLBLOCK; 6) Exception handling and mapping from urllib3 exceptions to Requests exceptions. The adapters are mounted to Session objects in src/requests/sessions.py during Session.__init__() where HTTPAdapter instances are created and mounted for 'http://' and 'https://' URL schemes. Custom adapters can also be implemented by subclassing BaseAdapter and mounted to Sessions for specialized transport needs.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "get_adapter", "is_method": true, "class_name": "Session", "parameters": ["self", "url"], "calls": ["self.adapters.items", "InvalidSchema", "startswith", "prefix.lower", "url.lower"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 781, "end_line": 792}, "code_snippet": "    def get_adapter(self, url):\n        \"\"\"\n        Returns the appropriate connection adapter for the given URL.\n\n        :rtype: requests.adapters.BaseAdapter\n        \"\"\"\n        for prefix, adapter in self.adapters.items():\n            if url.lower().startswith(prefix.lower()):\n                return adapter\n\n        # Nothing matches :-/\n        raise InvalidSchema(f\"No connection adapters were found for {url!r}\")\n", "type": "function"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_with_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1697, "end_line": 1708}, "code_snippet": "    def test_session_get_adapter_prefix_with_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com/\"  # trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_not_matching_prefix = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_not_matching_prefix) is not adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_without_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1710, "end_line": 1721}, "code_snippet": "    def test_session_get_adapter_prefix_without_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com\"  # no trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_extended_hostname = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_extended_hostname) is adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1554360389709473}
{"question": "How does Requests implement its session management system for connection pooling?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements session management for connection pooling through several key mechanisms in src/requests/sessions.py and src/requests/adapters.py: 1) Session initialization - Session.__init__() creates HTTPAdapter instances and mounts them for 'http://' and 'https://' schemes using self.mount(); 2) Adapter delegation - Session.send() selects the appropriate adapter based on URL scheme and delegates to adapter.send(); 3) Connection pooling - HTTPAdapter uses urllib3's PoolManager for connection pooling with configurable pool sizes (pool_connections, pool_maxsize); 4) Connection lifecycle - HTTPAdapter.init_poolmanager() creates connection pools and manages their lifecycle; 5) Connection reuse - HTTPAdapter.send() uses urllib3's urlopen() which automatically reuses connections from the pool; 6) Thread safety - urllib3's connection pools are thread-safe, enabling concurrent access; 7) Connection limits - Pool sizes can be configured to prevent resource exhaustion; 8) Connection health - Pools automatically handle connection failures and create new connections as needed; 9) Resource cleanup - Session.close() and HTTPAdapter.close() properly clean up connection pools; 10) Configuration flexibility - Connection pooling parameters can be customized per adapter and per session.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_session_close_proxy_clear", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "mock.Mock", "mock.Mock", "mock.patch.dict", "session.close", "clear.assert_called_once_with", "clear.assert_called_once_with"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2155, "end_line": 2164}, "code_snippet": "    def test_session_close_proxy_clear(self):\n        proxies = {\n            \"one\": mock.Mock(),\n            \"two\": mock.Mock(),\n        }\n        session = requests.Session()\n        with mock.patch.dict(session.adapters[\"http://\"].proxy_manager, proxies):\n            session.close()\n            proxies[\"one\"].clear.assert_called_once_with()\n            proxies[\"two\"].clear.assert_called_once_with()\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "session", "is_method": false, "class_name": null, "parameters": [], "calls": ["Session"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 819, "end_line": 831}, "code_snippet": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n\n    .. deprecated:: 1.0.0\n\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n    return Session()\n", "type": "function"}, {"name": "test_cookie_persists_via_api", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 401, "end_line": 405}, "code_snippet": "    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1167497634887695}
{"question": "How does Requests ensure backward compatibility when introducing new features?", "answer": null, "relative_code_list": null, "ground_truth": "Requests ensures backward compatibility through several strategies: 1) Deprecation warnings - Uses Python's warnings module to notify users of deprecated features before removal; 2) Gradual deprecation - Features are marked as deprecated in one version and removed in a later major version; 3) Parameter defaults - New parameters are added with sensible defaults that maintain existing behavior; 4) Method signatures - Existing method signatures are preserved, with new functionality added through optional parameters; 5) Import compatibility - Public APIs remain stable, with internal refactoring hidden from users; 6) Documentation - Clear migration guides and deprecation notices in documentation; 7) Testing - Comprehensive test suite ensures existing functionality continues to work; 8) Version management - Semantic versioning (semver) clearly indicates breaking vs. non-breaking changes; 9) Legacy support - Critical deprecated features may be maintained longer for enterprise users; 10) Community feedback - Deprecation decisions are discussed with the community before implementation.", "score": null, "retrieved_content": [{"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}, {"name": "test_json_decode_compatibility", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "isinstance", "httpbin", "pytest.raises", "r.json", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2845, "end_line": 2851}, "code_snippet": "    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin(\"bytes/20\"))\n        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n            r.json()\n        assert isinstance(excinfo.value, RequestException)\n        assert isinstance(excinfo.value, JSONDecodeError)\n        assert r.text not in str(excinfo.value)\n", "type": "function"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}, {"name": "test_can_access_urllib3_attribute", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_packages.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 4, "end_line": 5}, "code_snippet": "def test_can_access_urllib3_attribute():\n    requests.packages.urllib3\n", "type": "function"}, {"name": "test_cannot_send_unprepared_requests", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "pytest.raises", "send", "httpbin", "requests.Session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1570, "end_line": 1573}, "code_snippet": "    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n", "type": "function"}, {"name": "test_unicode_header_name", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.put", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 949, "end_line": 954}, "code_snippet": "    def test_unicode_header_name(self, httpbin):\n        requests.put(\n            httpbin(\"put\"),\n            headers={\"Content-Type\": \"application/octet-stream\"},\n            data=\"\\xff\",\n        )  # compat.str is unicode.\n", "type": "function"}, {"name": "test_requests_history_is_saved", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2099, "end_line": 2105}, "code_snippet": "    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin(\"redirect/5\"))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n            assert item.history == total[0:i]\n            i += 1\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0787396430969238}
{"question": "How does Requests' design facilitate integration with other HTTP libraries?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' design facilitates integration with other HTTP libraries through several architectural features: 1) Adapter pattern - The adapter system allows custom transport implementations to be plugged in without changing the core API; 2) BaseAdapter interface - Custom adapters can be implemented by subclassing BaseAdapter and implementing send() and close() methods; 3) Session mounting - Custom adapters can be mounted to Sessions for specific URL schemes or protocols; 4) Request/Response objects - Standardized Request and Response objects provide a consistent interface regardless of underlying transport; 5) Hook system - Request and response hooks allow integration with external libraries for logging, monitoring, or modification; 6) Exception mapping - Custom adapters can map their exceptions to Requests exceptions for consistent error handling; 7) Configuration flexibility - Adapters can have their own configuration parameters while maintaining the Requests interface; 8) Protocol support - Different adapters can support different protocols (HTTP, HTTPS, FTP, custom protocols); 9) Testing support - The adapter pattern enables easy mocking and testing of transport behavior; 10) Extensibility - The design allows for gradual migration from other libraries by implementing adapters that wrap existing functionality.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_can_access_urllib3_attribute", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_packages.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 4, "end_line": 5}, "code_snippet": "def test_can_access_urllib3_attribute():\n    requests.packages.urllib3\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}, {"name": "test_HTTP_200_OK_GET_ALTERNATIVE", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "getproxies", "s.send", "httpbin", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 203, "end_line": 210}, "code_snippet": "    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n", "type": "function"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_request_and_response_are_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pickle.loads", "pickle.loads", "httpbin", "pickle.dumps", "pickle.dumps"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1512, "end_line": 1522}, "code_snippet": "    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n", "type": "function"}, {"name": "test_http_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.exceptions.HTTPError", "requests.Response", "requests.exceptions.HTTPError", "requests.exceptions.HTTPError", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1575, "end_line": 1583}, "code_snippet": "    def test_http_error(self):\n        error = requests.exceptions.HTTPError()\n        assert not error.response\n        response = requests.Response()\n        error = requests.exceptions.HTTPError(response=response)\n        assert error.response == response\n        error = requests.exceptions.HTTPError(\"message\", response=response)\n        assert str(error) == \"message\"\n        assert error.response == response\n", "type": "function"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0565180778503418}
{"question": "How does Requests implement its session management system?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements session management through the Session class in src/requests/sessions.py: 1) State persistence - Sessions maintain persistent state including cookies, headers, auth, proxies, and configuration across requests; 2) Connection pooling - Sessions use HTTPAdapter instances for connection pooling and reuse; 3) Configuration merging - Session.prepare_request() merges session settings with request-specific settings; 4) Cookie management - Sessions maintain RequestsCookieJar for automatic cookie persistence; 5) Authentication persistence - Sessions store default authentication credentials applied to all requests; 6) Adapter mounting - Sessions mount different adapters for different URL schemes; 7) Resource management - Sessions implement context manager protocol for automatic cleanup; 8) Thread safety - Connection pools and session state are thread-safe for concurrent usage; 9) Request coordination - Sessions coordinate the complete request lifecycle from preparation to response processing; 10) Error handling - Sessions provide consistent error handling and exception translation across all requests.", "score": null, "retrieved_content": [{"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "test_cookie_persists_via_api", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 401, "end_line": 405}, "code_snippet": "    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n", "type": "function"}, {"name": "test_request_cookies_not_persisted", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 415, "end_line": 419}, "code_snippet": "    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n", "type": "function"}, {"name": "test_session_pickling", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "pickle.loads", "getproxies", "s.send", "httpbin", "pickle.dumps", "r.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1585, "end_line": 1593}, "code_snippet": "    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "HTTPDigestAuth", "requests.Session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 765, "end_line": 771}, "code_snippet": "    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n", "type": "function"}, {"name": "RequestsCookieJar", "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).", "methods": ["get", "set", "iterkeys", "keys", "itervalues", "values", "iteritems", "items", "list_domains", "list_paths", "multiple_domains", "get_dict", "__contains__", "__getitem__", "__setitem__", "__delitem__", "set_cookie", "update", "_find", "_find_no_duplicates", "__getstate__", "__setstate__", "copy", "get_policy"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 176, "end_line": 437}, "type": "class"}, {"name": "test_cookie_sent_on_redirect", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "s.get", "httpbin", "httpbin", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 380, "end_line": 384}, "code_snippet": "    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies/set?foo=bar\"))\n        r = s.get(httpbin(\"redirect/1\"))  # redirects to httpbin('get')\n        assert \"Cookie\" in r.json()[\"headers\"]\n", "type": "function"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.9745180606842041}
{"question": "How does Requests handle connection pooling and reuse?", "answer": null, "relative_code_list": null, "ground_truth": "Requests handles connection pooling and reuse through HTTPAdapter in src/requests/adapters.py: 1) Pool creation - HTTPAdapter.init_poolmanager() creates urllib3 PoolManager instances for connection pooling; 2) Connection limits - Pools are configured with pool_connections (number of pools) and pool_maxsize (connections per pool); 3) Connection reuse - HTTPAdapter.send() uses urllib3's urlopen() which automatically reuses connections from the pool; 4) Host-based pooling - Connections are pooled per host, allowing reuse across multiple requests to the same server; 5) Connection lifecycle - Pools manage connection creation, reuse, and cleanup automatically; 6) Thread safety - urllib3 pools are thread-safe, enabling concurrent access; 7) Connection health - Pools automatically handle failed connections and create new ones as needed; 8) Timeout management - Connection timeouts are handled at the pool level; 9) Resource cleanup - HTTPAdapter.close() properly closes and cleans up connection pools; 10) Configuration flexibility - Pool parameters can be customized per adapter for different use cases.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_urllib3_pool_connection_closed", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "s.get", "httpbin", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2696, "end_line": 2703}, "code_snippet": "def test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_unconsumed_session_response_closes_connection", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "contextlib.closing", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2137, "end_line": 2144}, "code_snippet": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_True", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2874, "end_line": 2903}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_True(self):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Cannot verify self-signed certificate\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url)\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_different_connection_pool_for_mtls_settings", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "sock.getpeercert", "consume_socket_content", "sock.send", "s.get", "close_server.set", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2970, "end_line": 3007}, "code_snippet": "    def test_different_connection_pool_for_mtls_settings(self):\n        client_cert = None\n\n        def response_handler(sock):\n            nonlocal client_cert\n            client_cert = sock.getpeercert()\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=2,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n            mutual_tls=True,\n            cacert=\"tests/certs/expired/ca/ca.crt\",\n        )\n\n        cert = (\n            \"tests/certs/mtls/client/client.pem\",\n            \"tests/certs/mtls/client/client.key\",\n        )\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False, cert=cert)\n            assert r1.status_code == 200\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, cert=cert)\n            close_server.set()\n\n        assert client_cert is not None\n", "type": "function"}, {"name": "test_different_connection_pool_for_tls_settings_verify_bundle_expired_cert", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self"], "calls": ["requests.Session", "threading.Event", "TLSServer", "consume_socket_content", "sock.send", "s.get", "close_server.set", "len", "pytest.raises", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2905, "end_line": 2936}, "code_snippet": "    def test_different_connection_pool_for_tls_settings_verify_bundle_expired_cert(\n        self,\n    ):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Has right trust bundle, but certificate expired\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, verify=\"tests/certs/expired/ca/ca.crt\")\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.9440915584564209}
{"question": "How does Requests implement its retry mechanism?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements retry mechanism through HTTPAdapter in src/requests/adapters.py: 1) Retry configuration - HTTPAdapter.__init__() configures max_retries parameter which creates a urllib3.Retry object; 2) urllib3 integration - HTTPAdapter.send() uses urllib3's urlopen() with the configured retry policy; 3) Retry conditions - urllib3.Retry handles retries for connection errors, timeouts, and specific HTTP status codes; 4) Backoff strategies - Retry policies can include exponential backoff and jitter for retry delays; 5) Status code filtering - status_forcelist parameter allows retrying specific HTTP status codes (e.g., 502, 503, 504); 6) Method filtering - allowed_methods parameter controls which HTTP methods can be retried; 7) Exception handling - HTTPAdapter.send() catches MaxRetryError and other transport exceptions; 8) Custom retry policies - Users can pass urllib3.Retry objects for advanced retry configuration; 9) Retry limits - total parameter controls maximum number of retry attempts; 10) Retry logging - Retry attempts can be logged and monitored for debugging purposes.", "score": null, "retrieved_content": [{"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_HTTP_302_TOO_MANY_REDIRECTS", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pytest.fail", "httpbin", "httpbin", "len"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 241, "end_line": 250}, "code_snippet": "    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin(\"relative-redirect\", \"50\"))\n        except TooManyRedirects as e:\n            url = httpbin(\"relative-redirect\", \"20\")\n            assert e.request.url == url\n            assert e.response.url == url\n            assert len(e.response.history) == 30\n        else:\n            pytest.fail(\"Expected redirect to raise TooManyRedirects but it did not\")\n", "type": "function"}, {"name": "RetryError", "docstring": "Custom retries logic failed", "methods": [], "attributes": [], "code_location": {"file": "exceptions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 131, "end_line": 132}, "type": "class"}, {"name": "test_requests_history_is_saved", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2099, "end_line": 2105}, "code_snippet": "    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin(\"redirect/5\"))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n            assert item.history == total[0:i]\n            i += 1\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}, {"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "pytest.fail", "httpbin", "httpbin", "len"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 252, "end_line": 265}, "code_snippet": "    def test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS(self, httpbin):\n        s = requests.session()\n        s.max_redirects = 5\n        try:\n            s.get(httpbin(\"relative-redirect\", \"50\"))\n        except TooManyRedirects as e:\n            url = httpbin(\"relative-redirect\", \"45\")\n            assert e.request.url == url\n            assert e.response.url == url\n            assert len(e.response.history) == 5\n        else:\n            pytest.fail(\n                \"Expected custom max number of redirects to be respected but was not\"\n            )\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.807058572769165}
{"question": "How does Requests facilitate integration with popular web frameworks like Flask or Django?", "answer": null, "relative_code_list": null, "ground_truth": "Requests facilitates integration with web frameworks through several design features: 1) Session compatibility - Sessions can be used within web application contexts for making HTTP requests; 2) Thread safety - Connection pools and Sessions are thread-safe, suitable for web application environments; 3) Configuration integration - Sessions can integrate with web framework configuration systems for proxies, timeouts, and certificates; 4) Error handling - Requests exceptions integrate well with web framework error handling and logging systems; 5) Async compatibility - While Requests is synchronous, it can be used with async frameworks through thread pools or async wrappers; 6) Middleware integration - Requests can be integrated into web framework middleware for HTTP client functionality; 7) Testing support - Requests' adapter system enables easy mocking for web application testing; 8) Logging integration - Requests can integrate with web framework logging systems for request/response logging; 9) Environment variables - Requests respects environment variables that web frameworks commonly set for proxies and certificates; 10) Resource management - Sessions implement context manager protocol compatible with web framework lifecycle management.", "score": null, "retrieved_content": [{"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "test_json_decode_compatibility", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "isinstance", "httpbin", "pytest.raises", "r.json", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2845, "end_line": 2851}, "code_snippet": "    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin(\"bytes/20\"))\n        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n            r.json()\n        assert isinstance(excinfo.value, RequestException)\n        assert isinstance(excinfo.value, JSONDecodeError)\n        assert r.text not in str(excinfo.value)\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "test_request_and_response_are_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "pickle.loads", "pickle.loads", "httpbin", "pickle.dumps", "pickle.dumps"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1512, "end_line": 1522}, "code_snippet": "    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n", "type": "function"}, {"name": "test_http_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.exceptions.HTTPError", "requests.Response", "requests.exceptions.HTTPError", "requests.exceptions.HTTPError", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1575, "end_line": 1583}, "code_snippet": "    def test_http_error(self):\n        error = requests.exceptions.HTTPError()\n        assert not error.response\n        response = requests.Response()\n        error = requests.exceptions.HTTPError(response=response)\n        assert error.response == response\n        error = requests.exceptions.HTTPError(\"message\", response=response)\n        assert str(error) == \"message\"\n        assert error.response == response\n", "type": "function"}, {"name": "test_hook_receives_request_arguments", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "requests.Request", "s.prepare_request", "s.send", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1156, "end_line": 1164}, "code_snippet": "    def test_hook_receives_request_arguments(self, httpbin):\n        def hook(resp, **kwargs):\n            assert resp is not None\n            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request(\"GET\", httpbin(), hooks={\"response\": hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n", "type": "function"}, {"name": "test_respect_proxy_env_on_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "session.request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 637, "end_line": 641}, "code_snippet": "    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method=\"GET\", url=httpbin())\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}, {"name": "test_prepared_request_hook", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "req.prepare", "requests.Session", "getproxies", "s.send", "hasattr", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1191, "end_line": 1203}, "code_snippet": "    def test_prepared_request_hook(self, httpbin):\n        def hook(resp, **kwargs):\n            resp.hook_working = True\n            return resp\n\n        req = requests.Request(\"GET\", httpbin(), hooks={\"response\": hook})\n        prep = req.prepare()\n\n        s = requests.Session()\n        s.proxies = getproxies()\n        resp = s.send(prep)\n\n        assert hasattr(resp, \"hook_working\")\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7739825248718262}
{"question": "How does Requests handle HTTP authentication?", "answer": null, "relative_code_list": null, "ground_truth": "Requests handles HTTP authentication through multiple components: 1) Authentication handlers - Defined in src/requests/auth.py (HTTPBasicAuth, HTTPDigestAuth, HTTPProxyAuth) that implement the __call__() method; 2) Request preparation - PreparedRequest.prepare_auth() in src/requests/models.py applies authentication handlers to add Authorization headers; 3) Session integration - Sessions can store default authentication credentials applied to all requests; 4) Challenge handling - HTTPDigestAuth.handle_401() implements automatic retry logic for 401 challenges; 5) Header generation - Authentication handlers generate appropriate Authorization or Proxy-Authorization headers; 6) Credential encoding - _basic_auth_str() function encodes username/password in base64 for Basic Auth; 7) Digest calculation - HTTPDigestAuth implements MD5, SHA, SHA-256, SHA-512 digest algorithms; 8) Thread safety - HTTPDigestAuth uses thread-local storage for nonce management; 9) Redirect handling - Authentication handlers can respond to authentication challenges during redirects; 10) Environment integration - Sessions can automatically detect authentication from environment variables when trust_env is enabled.", "score": null, "retrieved_content": [{"name": "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 529, "end_line": 542}, "code_snippet": "    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}, {"name": "test_DIGEST_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "print", "requests.session", "HTTPDigestAuth", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 738, "end_line": 753}, "code_snippet": "    def test_DIGEST_HTTP_200_OK_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers[\"WWW-Authenticate\"])\n\n            s = requests.session()\n            s.auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = s.get(url)\n            assert r.status_code == 200\n", "type": "function"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_DIGESTAUTH_WRONG_HTTP_401_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["HTTPDigestAuth", "httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 784, "end_line": 798}, "code_snippet": "    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"wrongpass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n", "type": "function"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.9628825187683105}
{"question": "How does Requests implement its configuration management system?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements configuration management through a hierarchical system in src/requests/sessions.py: 1) Session-level defaults - Session.__init__() sets default values for headers, cookies, auth, proxies, verify, cert, etc.; 2) Configuration merging - merge_setting() function combines session-level and request-level settings with request settings taking precedence; 3) Environment integration - merge_environment_settings() integrates environment variables (proxies, certificates) when trust_env is enabled; 4) Adapter configuration - HTTPAdapter can be configured with pool sizes, retry policies, and connection parameters; 5) Per-request overrides - Individual requests can override session defaults through method parameters; 6) Persistent state - Session objects maintain configuration across multiple requests; 7) Context management - Sessions can be used as context managers for automatic cleanup; 8) Serialization support - Session configuration can be serialized/deserialized through __getstate__() and __setstate__(); 9) Hook configuration - Request and response hooks can be configured at session or request level; 10) Validation - Configuration parameters are validated and sanitized before use.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": ["default_hooks"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 334, "end_line": 349}, "code_snippet": "    def __init__(self):\n        #: HTTP verb to send to the server.\n        self.method = None\n        #: HTTP URL to send the request to.\n        self.url = None\n        #: dictionary of HTTP headers.\n        self.headers = None\n        # The `CookieJar` used to create the Cookie header will be stored here\n        # after prepare_cookies is called\n        self._cookies = None\n        #: request body to send to the server.\n        self.body = None\n        #: dictionary of callback hooks, for internal usage.\n        self.hooks = default_hooks()\n        #: integer denoting starting position of a readable file-like body.\n        self._body_position = None\n", "type": "function"}, {"name": "test_respect_proxy_env_on_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "session.request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 637, "end_line": 641}, "code_snippet": "    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method=\"GET\", url=httpbin())\n", "type": "function"}, {"name": "test_basic_building", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Request", "req.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 113, "end_line": 120}, "code_snippet": "    def test_basic_building(self):\n        req = requests.Request()\n        req.url = \"http://kennethreitz.org/\"\n        req.data = {\"life\": \"42\"}\n\n        pr = req.prepare()\n        assert pr.url == req.url\n        assert pr.body == \"life=42\"\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "HTTPAdapter", "parameters": ["self", "pool_connections", "pool_maxsize", "max_retries", "pool_block"], "calls": ["__init__", "self.init_poolmanager", "Retry", "Retry.from_int", "super"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 178, "end_line": 198}, "code_snippet": "    def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.145740270614624}
{"question": "How does Requests support authentication mechanisms commonly used in APIs, such as OAuth or JWT?", "answer": null, "relative_code_list": null, "ground_truth": "Requests supports API authentication mechanisms through its extensible authentication system: 1) AuthBase extension - Custom authentication handlers can be implemented by subclassing AuthBase for OAuth, JWT, or other schemes; 2) Header-based auth - Auth handlers can add custom headers (Authorization, X-API-Key, etc.) for API authentication; 3) Token management - Custom handlers can manage token refresh, expiration, and storage for OAuth flows; 4) Session integration - API authentication can be set at session level for persistent authentication across requests; 5) Request-level auth - Individual requests can use custom authentication handlers for specific API calls; 6) Hook system - Response hooks can handle authentication challenges and token refresh automatically; 7) State management - Auth handlers can maintain state across requests for token caching and management; 8) Challenge handling - Custom handlers can implement handle_401() method for authentication challenge responses; 9) Header manipulation - Auth handlers can modify any request headers needed for API authentication; 10) Flexibility - The system supports any authentication scheme that can be implemented through HTTP headers or request modification.", "score": null, "retrieved_content": [{"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 529, "end_line": 542}, "code_snippet": "    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n", "type": "function"}, {"name": "test_auth_is_retained_for_redirect_on_host", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1894, "end_line": 1899}, "code_snippet": "    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n", "type": "function"}, {"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "test_proxy_authorization_preserved_on_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Session", "session.headers.update", "session.request", "get", "sent_headers.get", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 643, "end_line": 650}, "code_snippet": "    def test_proxy_authorization_preserved_on_request(self, httpbin):\n        proxy_auth_value = \"Bearer XXX\"\n        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method=\"GET\", url=httpbin(\"get\"))\n        sent_headers = resp.json().get(\"headers\", {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7688040733337402}
{"question": "How does Requests handle API versioning and compatibility when interacting with evolving web services?", "answer": null, "relative_code_list": null, "ground_truth": "Requests handles API versioning and compatibility through several mechanisms: 1) Header customization - Custom headers can be set for API versioning (Accept, X-API-Version, etc.) at session or request level; 2) URL versioning - Different API versions can be handled by using different base URLs or URL patterns; 3) Session configuration - Sessions can be configured with version-specific headers, authentication, or base URLs; 4) Adapter customization - Custom adapters can be implemented for version-specific transport requirements; 5) Response handling - Response objects provide access to headers and status codes for version negotiation; 6) Error handling - Requests exceptions can be used to handle version-specific error responses; 7) Content negotiation - Accept headers can be customized for different API versions and content types; 8) Backward compatibility - Requests' stable API allows applications to handle multiple API versions simultaneously; 9) Configuration management - Session-level configuration enables easy switching between API versions; 10) Testing support - The adapter system enables mocking of different API versions for testing and development.", "score": null, "retrieved_content": [{"name": "test_json_decode_compatibility", "is_method": true, "class_name": "TestPreparingURLs", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "isinstance", "httpbin", "pytest.raises", "r.json", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2845, "end_line": 2851}, "code_snippet": "    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin(\"bytes/20\"))\n        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n            r.json()\n        assert isinstance(excinfo.value, RequestException)\n        assert isinstance(excinfo.value, JSONDecodeError)\n        assert r.text not in str(excinfo.value)\n", "type": "function"}, {"name": "test_requests_in_history_are_not_overridden", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 472, "end_line": 476}, "code_snippet": "    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n", "type": "function"}, {"name": "test_requests_are_updated_each_time", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["RedirectSession", "prepare", "session.send", "session.resolve_redirects", "SendCall", "SendCall", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2595, "end_line": 2613}, "code_snippet": "def test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n", "type": "function"}, {"name": "test_auth_is_stripped_on_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "httpbin_secure", "httpbin_ca_bundle"], "calls": ["requests.get", "httpbin_secure", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1882, "end_line": 1892}, "code_snippet": "    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n", "type": "function"}, {"name": "test_should_strip_auth_http_downgrade", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.should_strip_auth"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1907, "end_line": 1909}, "code_snippet": "    def test_should_strip_auth_http_downgrade(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\"https://example.com/foo\", \"http://example.com/bar\")\n", "type": "function"}, {"name": "test_cookie_persists_via_api", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.session", "s.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 401, "end_line": 405}, "code_snippet": "    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n", "type": "function"}, {"name": "check_compatibility", "is_method": false, "class_name": null, "parameters": ["urllib3_version", "chardet_version", "charset_normalizer_version"], "calls": ["urllib3_version.split", "len", "urllib3_version.append", "int", "int", "int", "chardet_version.split", "int", "int", "int", "warnings.warn", "charset_normalizer_version.split", "int", "int", "int"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 58, "end_line": 90}, "code_snippet": "def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):\n    urllib3_version = urllib3_version.split(\".\")\n    assert urllib3_version != [\"dev\"]  # Verify urllib3 isn't installed from git.\n\n    # Sometimes, urllib3 only reports its version as 16.1.\n    if len(urllib3_version) == 2:\n        urllib3_version.append(\"0\")\n\n    # Check urllib3 for compatibility.\n    major, minor, patch = urllib3_version  # noqa: F811\n    major, minor, patch = int(major), int(minor), int(patch)\n    # urllib3 >= 1.21.1\n    assert major >= 1\n    if major == 1:\n        assert minor >= 21\n\n    # Check charset_normalizer for compatibility.\n    if chardet_version:\n        major, minor, patch = chardet_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # chardet_version >= 3.0.2, < 6.0.0\n        assert (3, 0, 2) <= (major, minor, patch) < (6, 0, 0)\n    elif charset_normalizer_version:\n        major, minor, patch = charset_normalizer_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # charset_normalizer >= 2.0.0 < 4.0.0\n        assert (2, 0, 0) <= (major, minor, patch) < (4, 0, 0)\n    else:\n        warnings.warn(\n            \"Unable to find acceptable character detection dependency \"\n            \"(chardet or charset_normalizer).\",\n            RequestsDependencyWarning,\n        )\n", "type": "function"}, {"name": "test_cannot_send_unprepared_requests", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "pytest.raises", "send", "httpbin", "requests.Session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1570, "end_line": 1573}, "code_snippet": "    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_non_prepared_request_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "requests.Request", "pytest.raises", "s.send", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1136, "end_line": 1142}, "code_snippet": "    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7500002384185791}
{"question": "How does Requests implement its extension API for custom authentication handlers?", "answer": null, "relative_code_list": null, "ground_truth": "Requests implements extension API for custom authentication through the AuthBase class in src/requests/auth.py: 1) AuthBase abstract class - Defines the interface that all authentication handlers must implement; 2) __call__() method - Custom auth handlers must implement __call__(self, r) method that modifies Request objects; 3) Header modification - Auth handlers add appropriate headers (Authorization, Proxy-Authorization) to requests; 4) Integration points - Auth handlers are applied during PreparedRequest.prepare_auth() in request preparation; 5) Session integration - Custom auth handlers can be set as session.auth or passed to individual requests; 6) Challenge handling - Custom handlers can implement handle_401() method for authentication challenge responses; 7) State management - Handlers can maintain state across requests (like HTTPDigestAuth's thread-local storage); 8) Hook integration - Auth handlers can register response hooks for automatic challenge handling; 9) Flexibility - Handlers can implement any authentication scheme (OAuth, JWT, custom protocols); 10) Documentation - AuthBase serves as both interface and documentation for implementing custom authentication.", "score": null, "retrieved_content": [{"name": "HTTPProxyAuth", "docstring": "Attaches HTTP Proxy Authentication to a given Request object.", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 99, "end_line": 104}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "AuthBase", "parameters": ["self", "r"], "calls": ["NotImplementedError"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 72, "end_line": 73}, "code_snippet": "    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\n", "type": "function"}, {"name": "HTTPDigestAuth", "docstring": "Attaches HTTP Digest Authentication to the given Request object.", "methods": ["__init__", "init_per_thread_state", "build_digest_header", "handle_redirect", "handle_401", "__call__", "__eq__", "__ne__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 107, "end_line": 314}, "type": "class"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "HTTPBasicAuth", "docstring": "Attaches HTTP Basic Authentication to the given Request object.", "methods": ["__init__", "__eq__", "__ne__", "__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 76, "end_line": 96}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "HTTPDigestAuth", "parameters": ["self", "r"], "calls": ["self.init_per_thread_state", "r.register_hook", "r.register_hook", "self.build_digest_header", "r.body.tell"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 285, "end_line": 303}, "code_snippet": "    def __call__(self, r):\n        # Initialize per-thread state, if needed\n        self.init_per_thread_state()\n        # If we have a saved nonce, skip the 401\n        if self._thread_local.last_nonce:\n            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)\n        try:\n            self._thread_local.pos = r.body.tell()\n        except AttributeError:\n            # In the case of HTTPDigestAuth being reused and the body of\n            # the previous request was a file-like object, pos has the\n            # file position of the previous body. Ensure it's set to\n            # None.\n            self._thread_local.pos = None\n        r.register_hook(\"response\", self.handle_401)\n        r.register_hook(\"response\", self.handle_redirect)\n        self._thread_local.num_401_calls = 1\n\n        return r\n", "type": "function"}, {"name": "AuthBase", "docstring": "Base class that all auth implementations derive from", "methods": ["__call__"], "attributes": [], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 69, "end_line": 73}, "type": "class"}, {"name": "test_basicauth_with_netrc", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["httpbin", "requests.get", "requests.get", "requests.session", "s.get", "s.get"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 673, "end_line": 706}, "code_snippet": "    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n", "type": "function"}, {"name": "__call__", "is_method": true, "class_name": "HTTPBasicAuth", "parameters": ["self", "r"], "calls": ["_basic_auth_str"], "code_location": {"file": "auth.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 94, "end_line": 96}, "code_snippet": "    def __call__(self, r):\n        r.headers[\"Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r\n", "type": "function"}, {"name": "test_set_basicauth", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin", "username", "password"], "calls": ["pytest.mark.parametrize", "httpbin", "requests.Request", "r.prepare", "_basic_auth_str", "encode", "encode"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 553, "end_line": 560}, "code_snippet": "    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.7217469215393066}
{"question": "What is Requests' adapter system?", "answer": null, "relative_code_list": null, "ground_truth": "Requests' adapter system (src/requests/adapters.py) provides a transport abstraction layer that separates HTTP client logic from the underlying transport mechanism. The system consists of: 1) BaseAdapter - an abstract base class defining the interface for transport adapters with send() and close() methods; 2) HTTPAdapter - the main implementation that wraps urllib3's PoolManager for HTTP/HTTPS connections, providing connection pooling, retry logic, and proxy support; 3) Adapter mounting - Sessions can mount different adapters for different URL schemes (http://, https://, etc.) allowing customization of transport behavior per protocol. The adapter system enables Requests to abstract away the complexity of connection management, pooling, and retries while allowing users to customize transport behavior by implementing custom adapters or configuring the built-in HTTPAdapter with different pool sizes, retry policies, and connection parameters.", "score": null, "retrieved_content": [{"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "test_transport_adapter_ordering", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "s.mount", "requests.Session", "s2.mount", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter", "HTTPAdapter", "list", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1613, "end_line": 1649}, "code_snippet": "    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "HTTPAdapter", "s.mount", "s.mount", "s.get_adapter", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1651, "end_line": 1673}, "code_snippet": "    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_is_case_insensitive", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1685, "end_line": 1695}, "code_snippet": "    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_matching_mixed_case", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1675, "end_line": 1683}, "code_snippet": "    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "BaseAdapter", "docstring": "The Base Transport Adapter", "methods": ["__init__", "send", "close"], "attributes": [], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 113, "end_line": 140}, "type": "class"}, {"name": "test_urllib3_retries", "is_method": false, "class_name": null, "parameters": ["httpbin"], "calls": ["requests.Session", "s.mount", "HTTPAdapter", "pytest.raises", "s.get", "httpbin", "Retry"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2686, "end_line": 2693}, "code_snippet": "def test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_with_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1697, "end_line": 1708}, "code_snippet": "    def test_session_get_adapter_prefix_with_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com/\"  # trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_not_matching_prefix = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_not_matching_prefix) is not adapter\n", "type": "function"}, {"name": "test_session_get_adapter_prefix_without_trailing_slash", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "HTTPAdapter", "s.mount", "s.get_adapter", "s.get_adapter"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1710, "end_line": 1721}, "code_snippet": "    def test_session_get_adapter_prefix_without_trailing_slash(self):\n        # from issue #6935\n        prefix = \"https://example.com\"  # no trailing slash\n        url_matching_prefix = \"https://example.com/some/path\"\n        url_extended_hostname = \"https://example.com.other.com/some/path\"\n\n        s = requests.Session()\n        adapter = HTTPAdapter()\n        s.mount(prefix, adapter)\n\n        assert s.get_adapter(url_matching_prefix) is adapter\n        assert s.get_adapter(url_extended_hostname) is adapter\n", "type": "function"}], "retrieved_count": 10, "cost_time": 6.311614036560059}
{"question": "What are the core components of Requests' HTTP client?", "answer": null, "relative_code_list": null, "ground_truth": "The core components of Requests' HTTP client include: 1) Session class (src/requests/sessions.py) - manages connection pooling, cookies, and configuration; 2) Request and PreparedRequest classes (src/requests/models.py) - handle request preparation and encoding; 3) Response class (src/requests/models.py) - represents HTTP responses; 4) HTTPAdapter and BaseAdapter (src/requests/adapters.py) - provide transport abstraction and connection pooling; 5) Authentication handlers (src/requests/auth.py) - handle various authentication schemes; 6) Cookie handling (src/requests/cookies.py) - manage cookie persistence; 7) Exception classes (src/requests/exceptions.py) - handle various error conditions; 8) Utility functions (src/requests/utils.py) - provide encoding, URL parsing, and other utilities. The main API functions (get, post, etc.) are defined in src/requests/api.py and use the Session class internally.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "Session", "parameters": ["self"], "calls": ["default_headers", "default_hooks", "cookiejar_from_dict", "OrderedDict", "self.mount", "self.mount", "HTTPAdapter", "HTTPAdapter"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 390, "end_line": 449}, "code_snippet": "    def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())\n", "type": "function"}, {"name": "HTTPAdapter", "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)", "methods": ["__init__", "__getstate__", "__setstate__", "init_poolmanager", "proxy_manager_for", "cert_verify", "build_response", "build_connection_pool_key_attributes", "get_connection_with_tls_context", "get_connection", "close", "request_url", "add_headers", "proxy_headers", "send"], "attributes": ["__attrs__"], "code_location": {"file": "adapters.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 143, "end_line": 696}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": ["default_hooks"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 334, "end_line": 349}, "code_snippet": "    def __init__(self):\n        #: HTTP verb to send to the server.\n        self.method = None\n        #: HTTP URL to send the request to.\n        self.url = None\n        #: dictionary of HTTP headers.\n        self.headers = None\n        # The `CookieJar` used to create the Cookie header will be stored here\n        # after prepare_cookies is called\n        self._cookies = None\n        #: request body to send to the server.\n        self.body = None\n        #: dictionary of callback hooks, for internal usage.\n        self.hooks = default_hooks()\n        #: integer denoting starting position of a readable file-like body.\n        self._body_position = None\n", "type": "function"}, {"name": "Session", "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>", "methods": ["__init__", "__enter__", "__exit__", "prepare_request", "request", "get", "options", "head", "post", "put", "patch", "delete", "send", "merge_environment_settings", "get_adapter", "close", "mount", "__getstate__", "__setstate__"], "attributes": ["__attrs__"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 356, "end_line": 816}, "type": "class"}, {"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "test_basic_building", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Request", "req.prepare"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 113, "end_line": 120}, "code_snippet": "    def test_basic_building(self):\n        req = requests.Request()\n        req.url = \"http://kennethreitz.org/\"\n        req.data = {\"life\": \"42\"}\n\n        pr = req.prepare()\n        assert pr.url == req.url\n        assert pr.body == \"life=42\"\n", "type": "function"}, {"name": "test_entry_points", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.session", "requests.session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 85, "end_line": 95}, "code_snippet": "    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n", "type": "function"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cookiejar_from_dict", "datetime.timedelta"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 658, "end_line": 703}, "code_snippet": "    def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Request", "parameters": ["self", "method", "url", "headers", "files", "data", "params", "auth", "cookies", "hooks", "json"], "calls": ["default_hooks", "list", "hooks.items", "self.register_hook"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 258, "end_line": 290}, "code_snippet": "    def __init__(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n        # Default empty dicts for dict params.\n        data = [] if data is None else data\n        files = [] if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n        hooks = {} if hooks is None else hooks\n\n        self.hooks = default_hooks()\n        for k, v in list(hooks.items()):\n            self.register_hook(event=k, hook=v)\n\n        self.method = method\n        self.url = url\n        self.headers = headers\n        self.files = files\n        self.data = data\n        self.json = json\n        self.params = params\n        self.auth = auth\n        self.cookies = cookies\n", "type": "function"}], "retrieved_count": 10, "cost_time": 6.328228235244751}
{"question": "What is the structure of Requests' response object?", "answer": null, "relative_code_list": null, "ground_truth": "The Response object (src/requests/models.py) has the following structure: Core attributes include status_code (HTTP status code), headers (case-insensitive dictionary of response headers), url (final URL after redirects), encoding (character encoding), reason (textual status reason), cookies (CookieJar of server cookies), elapsed (timedelta of request duration), and request (reference to the PreparedRequest). Content-related attributes include _content (raw response content), _content_consumed (flag for content consumption), raw (file-like object for streaming), and history (list of redirect responses). The object implements context manager protocol (__enter__/__exit__), iteration protocol (__iter__), and boolean evaluation (__bool__ returns True if status_code < 400). Key properties include ok (boolean status check), is_redirect (checks for redirect status), is_permanent_redirect (checks for permanent redirects), next (PreparedRequest for redirect chain), and apparent_encoding (detected character encoding). The object supports content iteration, JSON parsing, and automatic status code checking with raise_for_status().", "score": null, "retrieved_content": [{"name": "Response", "docstring": "The :class:`Response <Response>` object, which contains a\nserver's response to an HTTP request.", "methods": ["__init__", "__enter__", "__exit__", "__getstate__", "__setstate__", "__repr__", "__bool__", "__nonzero__", "__iter__", "ok", "is_redirect", "is_permanent_redirect", "next", "apparent_encoding", "iter_content", "iter_lines", "content", "text", "json", "links", "raise_for_status", "close"], "attributes": ["__attrs__"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 640, "end_line": 1039}, "type": "class"}, {"name": "test_empty_response_has_content_none", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1417, "end_line": 1419}, "code_snippet": "    def test_empty_response_has_content_none(self):\n        r = requests.Response()\n        assert r.content is None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cookiejar_from_dict", "datetime.timedelta"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 658, "end_line": 703}, "code_snippet": "    def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None\n", "type": "function"}, {"name": "TestRequests", "docstring": "", "methods": ["test_entry_points", "test_invalid_url", "test_basic_building", "test_no_content_length", "test_no_body_content_length", "test_empty_content_length", "test_override_content_length", "test_path_is_not_double_encoded", "test_params_are_added_before_fragment", "test_params_original_order_is_preserved_by_default", "test_params_bytes_are_encoded", "test_binary_put", "test_whitespaces_are_removed_from_url", "test_mixed_case_scheme_acceptable", "test_HTTP_200_OK_GET_ALTERNATIVE", "test_HTTP_302_ALLOW_REDIRECT_GET", "test_HTTP_307_ALLOW_REDIRECT_POST", "test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE", "test_HTTP_302_TOO_MANY_REDIRECTS", "test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS", "test_http_301_changes_post_to_get", "test_http_301_doesnt_change_head_to_get", "test_http_302_changes_post_to_get", "test_http_302_doesnt_change_head_to_get", "test_http_303_changes_post_to_get", "test_http_303_doesnt_change_head_to_get", "test_header_and_body_removal_on_redirect", "test_transfer_enc_removal_on_redirect", "test_fragment_maintained_on_redirect", "test_HTTP_200_OK_GET_WITH_PARAMS", "test_HTTP_200_OK_GET_WITH_MIXED_PARAMS", "test_set_cookie_on_301", "test_cookie_sent_on_redirect", "test_cookie_removed_on_expire", "test_cookie_quote_wrapped", "test_cookie_persists_via_api", "test_request_cookie_overrides_session_cookie", "test_request_cookies_not_persisted", "test_generic_cookiejar_works", "test_param_cookiejar_works", "test_cookielib_cookiejar_on_redirect", "test_requests_in_history_are_not_overridden", "test_history_is_always_a_list", "test_headers_on_session_with_None_are_not_sent", "test_headers_preserve_order", "test_user_agent_transfers", "test_HTTP_200_OK_HEAD", "test_HTTP_200_OK_PUT", "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "test_set_basicauth", "test_basicauth_encodes_byte_strings", "test_errors", "test_proxy_error", "test_proxy_error_on_bad_url", "test_respect_proxy_env_on_send_self_prepared_request", "test_respect_proxy_env_on_send_session_prepared_request", "test_respect_proxy_env_on_send_with_redirects", "test_respect_proxy_env_on_get", "test_respect_proxy_env_on_request", "test_proxy_authorization_preserved_on_request", "test_proxy_authorization_not_appended_to_https_request", "test_basicauth_with_netrc", "test_basicauth_with_netrc_leak", "test_DIGEST_HTTP_200_OK_GET", "test_DIGEST_AUTH_RETURNS_COOKIE", "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "test_DIGEST_STREAM", "test_DIGESTAUTH_WRONG_HTTP_401_GET", "test_DIGESTAUTH_QUOTES_QOP_VALUE", "test_POSTBIN_GET_POST_FILES", "test_invalid_files_input", "test_POSTBIN_SEEKED_OBJECT_WITH_NO_ITER", "test_POSTBIN_GET_POST_FILES_WITH_DATA", "test_post_with_custom_mapping", "test_conflicting_post_params", "test_request_ok_set", "test_status_raising", "test_decompress_gzip", "test_unicode_get", "test_unicode_header_name", "test_pyopenssl_redirect", "test_invalid_ca_certificate_path", "test_invalid_ssl_certificate_files", "test_env_cert_bundles", "test_http_with_certificate", "test_https_warnings", "test_certificate_failure", "test_urlencoded_get_query_multivalued_param", "test_form_encoded_post_query_multivalued_element", "test_different_encodings_dont_break_post", "test_unicode_multipart_post", "test_unicode_multipart_post_fieldnames", "test_unicode_method_name", "test_unicode_method_name_with_request_object", "test_non_prepared_request_error", "test_custom_content_type", "test_hook_receives_request_arguments", "test_session_hooks_are_used_with_no_request_hooks", "test_session_hooks_are_overridden_by_request_hooks", "test_prepared_request_hook", "test_prepared_from_session", "test_prepare_request_with_bytestring_url", "test_request_with_bytestring_host", "test_links", "test_cookie_parameters", "test_cookie_as_dict_keeps_len", "test_cookie_as_dict_keeps_items", "test_cookie_as_dict_keys", "test_cookie_as_dict_values", "test_cookie_as_dict_items", "test_cookie_duplicate_names_different_domains", "test_cookie_duplicate_names_raises_cookie_conflict_error", "test_cookie_policy_copy", "test_time_elapsed_blank", "test_empty_response_has_content_none", "test_response_is_iterable", "test_response_decode_unicode", "test_response_reason_unicode", "test_response_reason_unicode_fallback", "test_response_chunk_size_type", "test_iter_content_wraps_exceptions", "test_request_and_response_are_pickleable", "test_prepared_request_is_pickleable", "test_prepared_request_with_file_is_pickleable", "test_prepared_request_with_hook_is_pickleable", "test_cannot_send_unprepared_requests", "test_http_error", "test_session_pickling", "test_fixes_1329", "test_uppercase_scheme_redirect", "test_transport_adapter_ordering", "test_session_get_adapter_prefix_matching", "test_session_get_adapter_prefix_matching_mixed_case", "test_session_get_adapter_prefix_matching_is_case_insensitive", "test_session_get_adapter_prefix_with_trailing_slash", "test_session_get_adapter_prefix_without_trailing_slash", "test_header_remove_is_case_insensitive", "test_params_are_merged_case_sensitive", "test_long_authinfo_in_url", "test_header_keys_are_native", "test_header_validation", "test_header_value_not_str", "test_header_no_return_chars", "test_header_no_leading_space", "test_header_with_subclass_types", "test_can_send_objects_with_files", "test_can_send_file_object_with_non_string_filename", "test_autoset_header_values_are_native", "test_nonhttp_schemes_dont_check_URLs", "test_auth_is_stripped_on_http_downgrade", "test_auth_is_retained_for_redirect_on_host", "test_should_strip_auth_host_change", "test_should_strip_auth_http_downgrade", "test_should_strip_auth_https_upgrade", "test_should_strip_auth_port_change", "test_should_strip_auth_default_port", "test_manual_redirect_with_partial_body_read", "test_prepare_body_position_non_stream", "test_rewind_body", "test_rewind_partially_read_body", "test_rewind_body_no_seek", "test_rewind_body_failed_seek", "test_rewind_body_failed_tell", "_patch_adapter_gzipped_redirect", "test_redirect_with_wrong_gzipped_header", "test_basic_auth_str_is_always_native", "test_requests_history_is_saved", "test_json_param_post_content_type_works", "test_json_param_post_should_not_override_data_param", "test_response_iter_lines", "test_response_context_manager", "test_unconsumed_session_response_closes_connection", "test_response_iter_lines_reentrant", "test_session_close_proxy_clear", "test_proxy_auth", "test_proxy_auth_empty_pass", "test_response_json_when_content_is_None", "test_response_without_release_conn", "test_empty_stream_with_auth_does_not_set_content_length_header", "test_stream_with_auth_does_not_set_transfer_encoding_header", "test_chunked_upload_does_not_set_content_length_header", "test_custom_redirect_mixin"], "attributes": ["digest_auth_algo"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 82, "end_line": 2274}, "type": "class"}, {"name": "build_response", "is_method": true, "class_name": "RedirectSession", "parameters": ["self"], "calls": ["requests.Response", "CaseInsensitiveDict", "self._build_raw", "int", "self.redirects.pop"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2567, "end_line": 2579}, "code_snippet": "    def build_response(self):\n        request = self.calls[-1].args[0]\n        r = requests.Response()\n\n        try:\n            r.status_code = int(self.redirects.pop(0))\n        except IndexError:\n            r.status_code = 200\n\n        r.headers = CaseInsensitiveDict({\"Location\": \"/\"})\n        r.raw = self._build_raw()\n        r.request = request\n        return r\n", "type": "function"}, {"name": "test_request_ok_set", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 920, "end_line": 922}, "code_snippet": "    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin(\"status\", \"404\"))\n        assert not r.ok\n", "type": "function"}, {"name": "resolve_redirects", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp", "req", "stream", "timeout", "verify", "cert", "proxies", "yield_requests"], "calls": ["self.get_redirect_target", "urlparse", "req.copy", "hist.append", "resp.close", "url.startswith", "urlparse", "parsed.geturl", "to_native_string", "self.rebuild_method", "headers.pop", "extract_cookies_to_jar", "merge_cookies", "prepared_request.prepare_cookies", "self.rebuild_proxies", "self.rebuild_auth", "len", "TooManyRedirects", "urlparse", "join", "parsed._replace", "urljoin", "requote_uri", "rewind_body", "self.send", "extract_cookies_to_jar", "self.get_redirect_target", "resp.raw.read", "requote_uri", "prepared_request.headers.pop", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 159, "end_line": 280}, "code_snippet": "    def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp\n", "type": "function"}, {"name": "__repr__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 727, "end_line": 728}, "code_snippet": "    def __repr__(self):\n        return f\"<Response [{self.status_code}]>\"\n", "type": "function"}, {"name": "test_response_json_when_content_is_None", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "httpbin", "pytest.raises", "r.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2176, "end_line": 2185}, "code_snippet": "    def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin(\"/status/204\"))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n        r._content_consumed = False\n\n        assert r.content is None\n        with pytest.raises(ValueError):\n            r.json()\n", "type": "function"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}], "retrieved_count": 10, "cost_time": 6.338575124740601}
{"question": "What is the relationship between Requests' Response class and the Request class in establishing outgoing requests and incoming responses?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between Response and Request classes (src/requests/models.py) creates a request-response cycle: 1) Request reference - Response.request attribute holds a reference to the PreparedRequest that generated the response, enabling debugging and analysis; 2) Bidirectional linking - Response objects maintain links to their originating request, while Request objects can be prepared to generate responses; 3) Context preservation - Response preserves the context of the original request including method, URL, headers, and parameters; 4) History tracking - Response.history contains previous Response objects from redirect chains, each with their own request references; 5) Cookie flow - Cookies from Request are sent to server, and cookies from Response are extracted and can be used in subsequent requests; 6) Authentication flow - Authentication credentials from Request are processed, and authentication challenges in Response can trigger retry logic; 7) Header correlation - Response headers can be analyzed in context of Request headers for debugging and optimization; 8) Content relationship - Request body and Response content can be compared for debugging and validation; 9) Error context - When errors occur, both Request and Response information is available for debugging; 10) Redirect handling - During redirects, new Request objects are created based on Response headers, maintaining the chain. This relationship enables comprehensive request-response analysis and debugging capabilities.", "score": null, "retrieved_content": [{"name": "Response", "docstring": "The :class:`Response <Response>` object, which contains a\nserver's response to an HTTP request.", "methods": ["__init__", "__enter__", "__exit__", "__getstate__", "__setstate__", "__repr__", "__bool__", "__nonzero__", "__iter__", "ok", "is_redirect", "is_permanent_redirect", "next", "apparent_encoding", "iter_content", "iter_lines", "content", "text", "json", "links", "raise_for_status", "close"], "attributes": ["__attrs__"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 640, "end_line": 1039}, "type": "class"}, {"name": "resolve_redirects", "is_method": true, "class_name": "SessionRedirectMixin", "parameters": ["self", "resp", "req", "stream", "timeout", "verify", "cert", "proxies", "yield_requests"], "calls": ["self.get_redirect_target", "urlparse", "req.copy", "hist.append", "resp.close", "url.startswith", "urlparse", "parsed.geturl", "to_native_string", "self.rebuild_method", "headers.pop", "extract_cookies_to_jar", "merge_cookies", "prepared_request.prepare_cookies", "self.rebuild_proxies", "self.rebuild_auth", "len", "TooManyRedirects", "urlparse", "join", "parsed._replace", "urljoin", "requote_uri", "rewind_body", "self.send", "extract_cookies_to_jar", "self.get_redirect_target", "resp.raw.read", "requote_uri", "prepared_request.headers.pop", "to_native_string"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 159, "end_line": 280}, "code_snippet": "    def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp\n", "type": "function"}, {"name": "TestRequests", "docstring": "", "methods": ["test_entry_points", "test_invalid_url", "test_basic_building", "test_no_content_length", "test_no_body_content_length", "test_empty_content_length", "test_override_content_length", "test_path_is_not_double_encoded", "test_params_are_added_before_fragment", "test_params_original_order_is_preserved_by_default", "test_params_bytes_are_encoded", "test_binary_put", "test_whitespaces_are_removed_from_url", "test_mixed_case_scheme_acceptable", "test_HTTP_200_OK_GET_ALTERNATIVE", "test_HTTP_302_ALLOW_REDIRECT_GET", "test_HTTP_307_ALLOW_REDIRECT_POST", "test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE", "test_HTTP_302_TOO_MANY_REDIRECTS", "test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS", "test_http_301_changes_post_to_get", "test_http_301_doesnt_change_head_to_get", "test_http_302_changes_post_to_get", "test_http_302_doesnt_change_head_to_get", "test_http_303_changes_post_to_get", "test_http_303_doesnt_change_head_to_get", "test_header_and_body_removal_on_redirect", "test_transfer_enc_removal_on_redirect", "test_fragment_maintained_on_redirect", "test_HTTP_200_OK_GET_WITH_PARAMS", "test_HTTP_200_OK_GET_WITH_MIXED_PARAMS", "test_set_cookie_on_301", "test_cookie_sent_on_redirect", "test_cookie_removed_on_expire", "test_cookie_quote_wrapped", "test_cookie_persists_via_api", "test_request_cookie_overrides_session_cookie", "test_request_cookies_not_persisted", "test_generic_cookiejar_works", "test_param_cookiejar_works", "test_cookielib_cookiejar_on_redirect", "test_requests_in_history_are_not_overridden", "test_history_is_always_a_list", "test_headers_on_session_with_None_are_not_sent", "test_headers_preserve_order", "test_user_agent_transfers", "test_HTTP_200_OK_HEAD", "test_HTTP_200_OK_PUT", "test_BASICAUTH_TUPLE_HTTP_200_OK_GET", "test_set_basicauth", "test_basicauth_encodes_byte_strings", "test_errors", "test_proxy_error", "test_proxy_error_on_bad_url", "test_respect_proxy_env_on_send_self_prepared_request", "test_respect_proxy_env_on_send_session_prepared_request", "test_respect_proxy_env_on_send_with_redirects", "test_respect_proxy_env_on_get", "test_respect_proxy_env_on_request", "test_proxy_authorization_preserved_on_request", "test_proxy_authorization_not_appended_to_https_request", "test_basicauth_with_netrc", "test_basicauth_with_netrc_leak", "test_DIGEST_HTTP_200_OK_GET", "test_DIGEST_AUTH_RETURNS_COOKIE", "test_DIGEST_AUTH_SETS_SESSION_COOKIES", "test_DIGEST_STREAM", "test_DIGESTAUTH_WRONG_HTTP_401_GET", "test_DIGESTAUTH_QUOTES_QOP_VALUE", "test_POSTBIN_GET_POST_FILES", "test_invalid_files_input", "test_POSTBIN_SEEKED_OBJECT_WITH_NO_ITER", "test_POSTBIN_GET_POST_FILES_WITH_DATA", "test_post_with_custom_mapping", "test_conflicting_post_params", "test_request_ok_set", "test_status_raising", "test_decompress_gzip", "test_unicode_get", "test_unicode_header_name", "test_pyopenssl_redirect", "test_invalid_ca_certificate_path", "test_invalid_ssl_certificate_files", "test_env_cert_bundles", "test_http_with_certificate", "test_https_warnings", "test_certificate_failure", "test_urlencoded_get_query_multivalued_param", "test_form_encoded_post_query_multivalued_element", "test_different_encodings_dont_break_post", "test_unicode_multipart_post", "test_unicode_multipart_post_fieldnames", "test_unicode_method_name", "test_unicode_method_name_with_request_object", "test_non_prepared_request_error", "test_custom_content_type", "test_hook_receives_request_arguments", "test_session_hooks_are_used_with_no_request_hooks", "test_session_hooks_are_overridden_by_request_hooks", "test_prepared_request_hook", "test_prepared_from_session", "test_prepare_request_with_bytestring_url", "test_request_with_bytestring_host", "test_links", "test_cookie_parameters", "test_cookie_as_dict_keeps_len", "test_cookie_as_dict_keeps_items", "test_cookie_as_dict_keys", "test_cookie_as_dict_values", "test_cookie_as_dict_items", "test_cookie_duplicate_names_different_domains", "test_cookie_duplicate_names_raises_cookie_conflict_error", "test_cookie_policy_copy", "test_time_elapsed_blank", "test_empty_response_has_content_none", "test_response_is_iterable", "test_response_decode_unicode", "test_response_reason_unicode", "test_response_reason_unicode_fallback", "test_response_chunk_size_type", "test_iter_content_wraps_exceptions", "test_request_and_response_are_pickleable", "test_prepared_request_is_pickleable", "test_prepared_request_with_file_is_pickleable", "test_prepared_request_with_hook_is_pickleable", "test_cannot_send_unprepared_requests", "test_http_error", "test_session_pickling", "test_fixes_1329", "test_uppercase_scheme_redirect", "test_transport_adapter_ordering", "test_session_get_adapter_prefix_matching", "test_session_get_adapter_prefix_matching_mixed_case", "test_session_get_adapter_prefix_matching_is_case_insensitive", "test_session_get_adapter_prefix_with_trailing_slash", "test_session_get_adapter_prefix_without_trailing_slash", "test_header_remove_is_case_insensitive", "test_params_are_merged_case_sensitive", "test_long_authinfo_in_url", "test_header_keys_are_native", "test_header_validation", "test_header_value_not_str", "test_header_no_return_chars", "test_header_no_leading_space", "test_header_with_subclass_types", "test_can_send_objects_with_files", "test_can_send_file_object_with_non_string_filename", "test_autoset_header_values_are_native", "test_nonhttp_schemes_dont_check_URLs", "test_auth_is_stripped_on_http_downgrade", "test_auth_is_retained_for_redirect_on_host", "test_should_strip_auth_host_change", "test_should_strip_auth_http_downgrade", "test_should_strip_auth_https_upgrade", "test_should_strip_auth_port_change", "test_should_strip_auth_default_port", "test_manual_redirect_with_partial_body_read", "test_prepare_body_position_non_stream", "test_rewind_body", "test_rewind_partially_read_body", "test_rewind_body_no_seek", "test_rewind_body_failed_seek", "test_rewind_body_failed_tell", "_patch_adapter_gzipped_redirect", "test_redirect_with_wrong_gzipped_header", "test_basic_auth_str_is_always_native", "test_requests_history_is_saved", "test_json_param_post_content_type_works", "test_json_param_post_should_not_override_data_param", "test_response_iter_lines", "test_response_context_manager", "test_unconsumed_session_response_closes_connection", "test_response_iter_lines_reentrant", "test_session_close_proxy_clear", "test_proxy_auth", "test_proxy_auth_empty_pass", "test_response_json_when_content_is_None", "test_response_without_release_conn", "test_empty_stream_with_auth_does_not_set_content_length_header", "test_stream_with_auth_does_not_set_transfer_encoding_header", "test_chunked_upload_does_not_set_content_length_header", "test_custom_redirect_mixin"], "attributes": ["digest_auth_algo"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 82, "end_line": 2274}, "type": "class"}, {"name": "RequestHooksMixin", "docstring": "", "methods": ["register_hook", "deregister_hook"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 206, "end_line": 227}, "type": "class"}, {"name": "build_response", "is_method": true, "class_name": "RedirectSession", "parameters": ["self"], "calls": ["requests.Response", "CaseInsensitiveDict", "self._build_raw", "int", "self.redirects.pop"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2567, "end_line": 2579}, "code_snippet": "    def build_response(self):\n        request = self.calls[-1].args[0]\n        r = requests.Response()\n\n        try:\n            r.status_code = int(self.redirects.pop(0))\n        except IndexError:\n            r.status_code = 200\n\n        r.headers = CaseInsensitiveDict({\"Location\": \"/\"})\n        r.raw = self._build_raw()\n        r.request = request\n        return r\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Response", "parameters": ["self"], "calls": ["CaseInsensitiveDict", "cookiejar_from_dict", "datetime.timedelta"], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 658, "end_line": 703}, "code_snippet": "    def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None\n", "type": "function"}, {"name": "MockRequest", "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.", "methods": ["__init__", "get_type", "get_host", "get_origin_req_host", "get_full_url", "is_unverifiable", "has_header", "get_header", "add_header", "add_unredirected_header", "get_new_headers", "unverifiable", "origin_req_host", "host"], "attributes": [], "code_location": {"file": "cookies.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 23, "end_line": 100}, "type": "class"}, {"name": "test_response_context_manager", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.get", "isinstance", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 2131, "end_line": 2135}, "code_snippet": "    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n", "type": "function"}, {"name": "test_empty_response_has_content_none", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Response"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1417, "end_line": 1419}, "code_snippet": "    def test_empty_response_has_content_none(self):\n        r = requests.Response()\n        assert r.content is None\n", "type": "function"}, {"name": "request", "is_method": true, "class_name": "Session", "parameters": ["self", "method", "url", "params", "data", "headers", "cookies", "files", "auth", "timeout", "allow_redirects", "proxies", "hooks", "stream", "verify", "cert", "json"], "calls": ["Request", "self.prepare_request", "self.merge_environment_settings", "send_kwargs.update", "self.send", "method.upper"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 500, "end_line": 591}, "code_snippet": "    def request(\n        self,\n        method,\n        url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None,\n    ):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param hooks: (optional) Dictionary mapping hook name to one event or\n            list of events, event must be callable.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False``\n            may be useful during local development or testing.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            \"timeout\": timeout,\n            \"allow_redirects\": allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n", "type": "function"}], "retrieved_count": 10, "cost_time": 6.375091791152954}
{"question": "What is the relationship between Requests' Session class and the PreparedRequest class in establishing request preparation and execution?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between Session and PreparedRequest (src/requests/sessions.py, src/requests/models.py) follows a preparation-execution pattern: 1) Request preparation - Session.prepare_request() takes a Request object and creates a PreparedRequest by merging session-level settings (headers, cookies, auth, proxies) with request-specific settings; 2) Configuration merging - Session merges its persistent state (cookies, headers, auth, etc.) with the request parameters, with request settings taking precedence; 3) Cookie handling - Session merges its cookie jar with request cookies and prepares the final Cookie header; 4) Authentication - Session applies its default authentication or environment-based auth if not specified in the request; 5) Adapter selection - Session selects the appropriate adapter based on the URL scheme for the prepared request; 6) Request execution - Session.send() takes the PreparedRequest and sends it through the selected adapter; 7) Response processing - Session handles redirects, cookie extraction, and response building after adapter execution; 8) State updates - Session updates its internal state (cookies, etc.) based on the response; 9) Connection management - Session manages connection pooling and lifecycle through adapters; 10) Error handling - Session provides consistent error handling and exception translation. This relationship enables Sessions to maintain state while providing a clean interface for request execution.", "score": null, "retrieved_content": [{"name": "PreparedRequest", "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>", "methods": ["__init__", "prepare", "__repr__", "copy", "prepare_method", "_get_idna_encoded_host", "prepare_url", "prepare_headers", "prepare_body", "prepare_content_length", "prepare_auth", "prepare_cookies", "prepare_hooks"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 313, "end_line": 637}, "type": "class"}, {"name": "test_non_prepared_request_error", "is_method": true, "class_name": "TestRequests", "parameters": ["self"], "calls": ["requests.Session", "requests.Request", "pytest.raises", "s.send", "str"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1136, "end_line": 1142}, "code_snippet": "    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n", "type": "function"}, {"name": "test_prepared_from_session", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "requests.Session", "DummyAuth", "s.prepare_request", "s.send", "httpbin", "resp.json"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1205, "end_line": 1220}, "code_snippet": "    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n", "type": "function"}, {"name": "test_cannot_send_unprepared_requests", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["requests.Request", "pytest.raises", "send", "httpbin", "requests.Session"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1570, "end_line": 1573}, "code_snippet": "    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n", "type": "function"}, {"name": "send", "is_method": true, "class_name": "Session", "parameters": ["self", "request"], "calls": ["kwargs.setdefault", "kwargs.setdefault", "kwargs.setdefault", "isinstance", "kwargs.pop", "kwargs.get", "self.get_adapter", "preferred_clock", "adapter.send", "timedelta", "dispatch_hook", "extract_cookies_to_jar", "resolve_proxies", "ValueError", "preferred_clock", "self.resolve_redirects", "history.insert", "history.pop", "extract_cookies_to_jar", "next", "self.resolve_redirects"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 673, "end_line": 748}, "code_snippet": "    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n\n        :rtype: requests.Response\n        \"\"\"\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault(\"stream\", self.stream)\n        kwargs.setdefault(\"verify\", self.verify)\n        kwargs.setdefault(\"cert\", self.cert)\n        if \"proxies\" not in kwargs:\n            kwargs[\"proxies\"] = resolve_proxies(request, self.proxies, self.trust_env)\n\n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if isinstance(request, Request):\n            raise ValueError(\"You can only send PreparedRequests.\")\n\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop(\"allow_redirects\", True)\n        stream = kwargs.get(\"stream\")\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n        # Response manipulation hooks\n        r = dispatch_hook(\"response\", hooks, r, **kwargs)\n\n        # Persist cookies\n        if r.history:\n            # If the hooks create history then we want those cookies too\n            for resp in r.history:\n                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n\n        extract_cookies_to_jar(self.cookies, request, r.raw)\n\n        # Resolve redirects if allowed.\n        if allow_redirects:\n            # Redirect resolving generator.\n            gen = self.resolve_redirects(r, request, **kwargs)\n            history = [resp for resp in gen]\n        else:\n            history = []\n\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n            r.history = history\n\n        # If redirects aren't being followed, store the response on the Request for Response.next().\n        if not allow_redirects:\n            try:\n                r._next = next(\n                    self.resolve_redirects(r, request, yield_requests=True, **kwargs)\n                )\n            except StopIteration:\n                pass\n\n        if not stream:\n            r.content\n\n        return r\n", "type": "function"}, {"name": "Request", "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>", "methods": ["__init__", "__repr__", "prepare"], "attributes": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 230, "end_line": 310}, "type": "class"}, {"name": "test_respect_proxy_env_on_send_session_prepared_request", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["override_environ", "pytest.raises", "requests.Session", "requests.Request", "session.prepare_request", "session.send", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 614, "end_line": 620}, "code_snippet": "    def test_respect_proxy_env_on_send_session_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request(\"GET\", httpbin())\n                prepared = session.prepare_request(request)\n                session.send(prepared)\n", "type": "function"}, {"name": "test_prepared_request_is_pickleable", "is_method": true, "class_name": "TestRequests", "parameters": ["self", "httpbin"], "calls": ["prepare", "pickle.loads", "requests.Session", "s.send", "pickle.dumps", "requests.Request", "httpbin"], "code_location": {"file": "test_requests.py", "path": "/data3/pwh/swebench-repos/requests/tests", "start_line": 1524, "end_line": 1536}, "code_snippet": "    def test_prepared_request_is_pickleable(self, httpbin):\n        p = requests.Request(\"GET\", httpbin(\"get\")).prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n        assert r.url == p.url\n        assert r.headers == p.headers\n        assert r.body == p.body\n\n        # Verify unpickled PreparedRequest sends properly\n        s = requests.Session()\n        resp = s.send(r)\n        assert resp.status_code == 200\n", "type": "function"}, {"name": "prepare_request", "is_method": true, "class_name": "Session", "parameters": ["self", "request"], "calls": ["merge_cookies", "PreparedRequest", "p.prepare", "isinstance", "cookiejar_from_dict", "merge_cookies", "get_netrc_auth", "RequestsCookieJar", "request.method.upper", "merge_setting", "merge_setting", "merge_setting", "merge_hooks"], "code_location": {"file": "sessions.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 457, "end_line": 498}, "code_snippet": "    def prepare_request(self, request):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n        transmission and returns it. The :class:`PreparedRequest` has settings\n        merged from the :class:`Request <Request>` instance and those of the\n        :class:`Session`.\n\n        :param request: :class:`Request` instance to prepare with this\n            session's settings.\n        :rtype: requests.PreparedRequest\n        \"\"\"\n        cookies = request.cookies or {}\n\n        # Bootstrap CookieJar.\n        if not isinstance(cookies, cookielib.CookieJar):\n            cookies = cookiejar_from_dict(cookies)\n\n        # Merge with session cookies\n        merged_cookies = merge_cookies(\n            merge_cookies(RequestsCookieJar(), self.cookies), cookies\n        )\n\n        # Set environment's basic authentication if not explicitly set.\n        auth = request.auth\n        if self.trust_env and not auth and not self.auth:\n            auth = get_netrc_auth(request.url)\n\n        p = PreparedRequest()\n        p.prepare(\n            method=request.method.upper(),\n            url=request.url,\n            files=request.files,\n            data=request.data,\n            json=request.json,\n            headers=merge_setting(\n                request.headers, self.headers, dict_class=CaseInsensitiveDict\n            ),\n            params=merge_setting(request.params, self.params),\n            auth=merge_setting(auth, self.auth),\n            cookies=merged_cookies,\n            hooks=merge_hooks(request.hooks, self.hooks),\n        )\n        return p\n", "type": "function"}, {"name": "__repr__", "is_method": true, "class_name": "PreparedRequest", "parameters": ["self"], "calls": [], "code_location": {"file": "models.py", "path": "/data3/pwh/swebench-repos/requests/src/requests", "start_line": 379, "end_line": 380}, "code_snippet": "    def __repr__(self):\n        return f\"<PreparedRequest [{self.method}]>\"\n", "type": "function"}], "retrieved_count": 10, "cost_time": 6.64952278137207}
