{"question": "What is Matplotlib's event handling system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event handling system provides a GUI-neutral interface for responding to user interactions like mouse clicks, key presses, and mouse movements. The system is built around the FigureCanvasBase class which manages event connections through methods like mpl_connect() and mpl_disconnect(). Events include LocationEvent (with x, y pixel coordinates and xdata, ydata data coordinates), MouseEvent (with button and key information), KeyEvent, and PickEvent. The system allows callbacks to be connected to specific events, enabling interactive features like panning, zooming, and custom interactive behaviors. Events are processed through an event loop that can be integrated with various GUI toolkits (Qt, Tk, Wx, GTK, macOS) while maintaining a consistent API. The event system also supports object picking for selecting specific artists and provides coordinate transformations between pixel and data coordinates automatically.", "score": null, "retrieved_content": [{"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "button_press_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 131, "end_line": 136}, "code_snippet": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "MouseEvent", "docstring": "A mouse event ('button_press_event', 'button_release_event', 'scroll_event', 'motion_notify_event').\n\nA MouseEvent has a number of special attributes in addition to those\ndefined by the parent `Event` and `LocationEvent` classes.\n\nAttributes\n----------\nbutton : None or `MouseButton` or {'up', 'down'}\n    The button pressed. 'up' and 'down' are used for scroll events.\n\n    Note that LEFT and RIGHT actually refer to the \"primary\" and\n    \"secondary\" buttons, i.e. if the user inverts their left and right\n    buttons (\"left-handed setting\") then the LEFT button will be the one\n    physically on the right.\n\n    If this is unset, *name* is \"scroll_event\", and *step* is nonzero, then\n    this will be set to \"up\" or \"down\" depending on the sign of *step*.\n\nbuttons : None or frozenset\n    For 'motion_notify_event', the mouse buttons currently being pressed\n    (a set of zero or more MouseButtons);\n    for other events, None.\n\n    .. note::\n       For 'motion_notify_event', this attribute is more accurate than\n       the ``button`` (singular) attribute, which is obtained from the last\n       'button_press_event' or 'button_release_event' that occurred within\n       the canvas (and thus 1. be wrong if the last change in mouse state\n       occurred when the canvas did not have focus, and 2. cannot report\n       when multiple buttons are pressed).\n\n       This attribute is not set for 'button_press_event' and\n       'button_release_event' because GUI toolkits are inconsistent as to\n       whether they report the button state *before* or *after* the\n       press/release occurred.\n\n    .. warning::\n       On macOS, the Tk backends only report a single button even if\n       multiple buttons are pressed.\n\nkey : None or str\n    The key pressed when the mouse event triggered, e.g. 'shift'.\n    See `KeyEvent`.\n\n    .. warning::\n       This key is currently obtained from the last 'key_press_event' or\n       'key_release_event' that occurred within the canvas.  Thus, if the\n       last change of keyboard state occurred while the canvas did not have\n       focus, this attribute will be wrong.  On the other hand, the\n       ``modifiers`` attribute should always be correct, but it can only\n       report on modifier keys.\n\nstep : float\n    The number of scroll steps (positive for 'up', negative for 'down').\n    This applies only to 'scroll_event' and defaults to 0 otherwise.\n\ndblclick : bool\n    Whether the event is a double-click. This applies only to\n    'button_press_event' and is False otherwise. In particular, it's\n    not used in 'button_release_event'.\n\nExamples\n--------\n::\n\n    def on_press(event):\n        print('you pressed', event.button, event.xdata, event.ydata)\n\n    cid = fig.canvas.mpl_connect('button_press_event', on_press)", "methods": ["__init__", "_from_ax_coords", "__str__"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1315, "end_line": 1437}, "type": "class"}, {"name": "ToolManager", "docstring": "Manager for actions triggered by user interactions (key press, toolbar\nclicks, ...) on a Figure.\n\nAttributes\n----------\nfigure : `.Figure`\nkeypresslock : `~matplotlib.widgets.LockDraw`\n    `.LockDraw` object to know if the `canvas` key_press_event is locked.\nmessagelock : `~matplotlib.widgets.LockDraw`\n    `.LockDraw` object to know if the message is available to write.", "methods": ["__init__", "canvas", "figure", "figure", "set_figure", "toolmanager_connect", "toolmanager_disconnect", "message_event", "active_toggle", "get_tool_keymap", "_remove_keys", "update_keymap", "remove_tool", "add_tool", "_handle_toggle", "trigger_tool", "_key_press", "tools", "get_tool"], "attributes": [], "code_location": {"file": "backend_managers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 32, "end_line": 387}, "type": "class"}, {"name": "_contour_labeler_event_handler", "is_method": false, "class_name": null, "parameters": ["cs", "inline", "inline_spacing", "event"], "calls": ["cs.axes.get_figure", "canvas.stop_event_loop", "cs.pop_label", "canvas.draw", "cs.axes.contains", "cs.add_label_near", "canvas.draw"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 30, "end_line": 56}, "code_snippet": "def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n    canvas = cs.axes.get_figure(root=True).canvas\n    is_button = event.name == \"button_press_event\"\n    is_key = event.name == \"key_press_event\"\n    # Quit (even if not in infinite mode; this is consistent with\n    # MATLAB and sometimes quite useful, but will require the user to\n    # test how many points were actually returned before using data).\n    if (is_button and event.button == MouseButton.MIDDLE\n            or is_key and event.key in [\"escape\", \"enter\"]):\n        canvas.stop_event_loop()\n    # Pop last click.\n    elif (is_button and event.button == MouseButton.RIGHT\n          or is_key and event.key in [\"backspace\", \"delete\"]):\n        # Unfortunately, if one is doing inline labels, then there is currently\n        # no way to fix the broken contour - once humpty-dumpty is broken, he\n        # can't be put back together.  In inline mode, this does nothing.\n        if not inline:\n            cs.pop_label()\n            canvas.draw()\n    # Add new click.\n    elif (is_button and event.button == MouseButton.LEFT\n          # On macOS/gtk, some keys return None.\n          or is_key and event.key is not None):\n        if cs.axes.contains(event)[0]:\n            cs.add_label_near(event.x, event.y, transform=False,\n                              inline=inline, inline_spacing=inline_spacing)\n            canvas.draw()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "LocationEvent", "docstring": "An event that has a screen location.\n\nA LocationEvent has a number of special attributes in addition to those\ndefined by the parent `Event` class.\n\nAttributes\n----------\nx, y : int or None\n    Event location in pixels from bottom left of canvas.\ninaxes : `~matplotlib.axes.Axes` or None\n    The `~.axes.Axes` instance over which the mouse is, if any.\nxdata, ydata : float or None\n    Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n    is not over an Axes.\nmodifiers : frozenset\n    The keyboard modifiers currently being pressed (except for KeyEvent).", "methods": ["__init__", "_set_inaxes"], "attributes": ["_last_axes_ref"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1249, "end_line": 1304}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "EventHandler", "parameters": ["self"], "calls": ["fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect"], "code_location": {"file": "looking_glass.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 37, "end_line": 42}, "code_snippet": "    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AxesWidget", "parameters": ["self", "ax"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 116, "end_line": 118}, "code_snippet": "    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0326547622680664}
{"question": "What is Matplotlib's backend system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend system is the rendering layer that converts abstract plot descriptions into actual output formats. It consists of two main types: 1) Interactive backends for displaying plots on screen (QtAgg, GTK3Agg, wxAgg, TkAgg, macosx) that work with GUI toolkits, and 2) Non-interactive backends for generating file output (PNG, SVG, PDF, PS) using renderers like Agg (Anti-Grain Geometry), PDF, PS, SVG, and PGF. The backend system separates the plotting logic from the output mechanism, allowing the same plotting code to work across different display environments and file formats. Each backend implements a FigureCanvas class that handles the specific rendering requirements, and the system can be configured through rcParams, environment variables, or the matplotlib.use() function.", "score": null, "retrieved_content": [{"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "_BackendQTAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_qtagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 85, "end_line": 86}, "type": "class"}, {"name": "_BackendWxAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_wxagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 44, "end_line": 45}, "type": "class"}, {"name": "_BackendQT", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager", "mainloop"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1084, "end_line": 1088}, "type": "class"}, {"name": "_BackendSVG", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1380, "end_line": 1382}, "type": "class"}, {"name": "_BackendTkAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_tkagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 19, "end_line": 20}, "type": "class"}, {"name": "switch_backend", "is_method": false, "class_name": null, "parameters": ["newbackend"], "calls": ["rcParams._get", "backend_registry.load_backend_module", "getattr", "getattr", "getattr", "inspect.getattr_static", "inspect.getattr_static", "_log.debug", "cbook._get_running_interactive_framework", "cbook._get_running_interactive_framework", "update", "inspect.signature", "install_repl_displayhook", "switch_backend", "ImportError", "vars", "canvas_class.new_manager", "FigureClass", "new_figure_manager_given_figure", "matplotlib.is_interactive", "ValueError", "cast", "im.version", "getattr", "_log.warning", "backend_registry.backend_for_gui_framework", "switch_backend", "format", "locals", "_pylab_helpers.Gcf.get_active", "_parse_to_version_info", "globals", "manager.canvas.draw_idle"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 387, "end_line": 541}, "code_snippet": "def switch_backend(newbackend: str) -> None:\n    \"\"\"\n    Set the pyplot backend.\n\n    Switching to an interactive backend is possible only if no event loop for\n    another interactive backend has started.  Switching to and from\n    non-interactive backends is always possible.\n\n    If the new backend is different than the current backend then all open\n    Figures will be closed via ``plt.close('all')``.\n\n    Parameters\n    ----------\n    newbackend : str\n        The case-insensitive name of the backend to use.\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n\n        if (current_framework and\n                (backend := backend_registry.backend_for_gui_framework(\n                    current_framework))):\n            candidates = [backend]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n    old_backend = rcParams._get('backend')  # get without triggering backend resolution\n\n    module = backend_registry.load_backend_module(newbackend)\n    canvas_class = module.FigureCanvas\n\n    required_framework = canvas_class.required_interactive_framework\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new_figure_manager() and show() functions from the backend.\n\n    # Classically, backends can directly export these functions.  This should\n    # keep working for backcompat.\n    new_figure_manager = getattr(module, \"new_figure_manager\", None)\n    show = getattr(module, \"show\", None)\n\n    # In that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive() -> None:\n            if matplotlib.is_interactive():\n                manager = _pylab_helpers.Gcf.get_active()\n                if manager:\n                    manager.canvas.draw_idle()\n\n        backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n            new_figure_manager_given_figure)\n        backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n            new_figure_manager)\n        backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n            draw_if_interactive)\n\n    # If the manager explicitly overrides pyplot_show, use it even if a global\n    # show is already present, as the latter may be here for backcompat.\n    manager_class = getattr(canvas_class, \"manager_class\", None)\n    # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n    # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n    # thus always different (being bound to different classes).  We also have to use\n    # getattr_static instead of vars as manager_class could have no __dict__.\n    manager_pyplot_show = inspect.getattr_static(manager_class, \"pyplot_show\", None)\n    base_pyplot_show = inspect.getattr_static(FigureManagerBase, \"pyplot_show\", None)\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactive.\n    try:\n        install_repl_displayhook()\n    except NotImplementedError as err:\n        _log.warning(\"Fallback to a different backend\")\n        raise ImportError from err\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0444190502166748}
{"question": "What are the core components of Matplotlib's plotting system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's core plotting system consists of several key components: 1) Figure - the top-level container that holds all plot elements, 2) Axes - individual plotting areas within a figure that contain the actual data visualization, 3) Artist - the base class for all visual elements (lines, text, patches, etc.), 4) Backend - the rendering system that converts abstract plot descriptions to actual output (GUI, files, etc.), 5) pyplot interface - the MATLAB-like procedural interface for plotting, and 6) Object-oriented API - the explicit interface using Figure and Axes objects directly. The system follows a hierarchical structure where Figure contains Axes, which contain various Artist objects that represent the visual elements of the plot.", "score": null, "retrieved_content": [{"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "Axes", "docstring": "An Axes object encapsulates all the elements of an individual (sub-)plot in\na figure.\n\nIt contains most of the (sub-)plot elements: `~.axis.Axis`,\n`~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,\nand sets the coordinate system.\n\nLike all visible elements in a figure, Axes is an `.Artist` subclass.\n\nThe `Axes` instance supports callbacks through a callbacks attribute which\nis a `~.cbook.CallbackRegistry` instance.  The events you can connect to\nare 'xlim_changed' and 'ylim_changed' and the callback will be called with\nfunc(*ax*) where *ax* is the `Axes` instance.\n\n.. note::\n\n    As a user, you do not instantiate Axes directly, but use Axes creation\n    methods instead; e.g. from `.pyplot` or `.Figure`:\n    `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.", "methods": [], "attributes": [], "code_location": {"file": "_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 85, "end_line": 9190}, "type": "class"}, {"name": "create_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "np.linspace", "plt.plot", "plt.plot", "plt.fill_between", "plt.fill", "plt.plot", "plt.text", "plt.ylabel", "plt.text", "plt.xlim", "plt.ylim"], "code_location": {"file": "test_backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 50, "end_line": 75}, "code_snippet": "def create_figure():\n    plt.figure()\n    x = np.linspace(0, 1, 15)\n\n    # line plot\n    plt.plot(x, x ** 2, \"b-\")\n\n    # marker\n    plt.plot(x, 1 - x**2, \"g>\")\n\n    # filled paths and patterns\n    plt.fill_between([0., .4], [.4, 0.], hatch='//', facecolor=\"lightgray\",\n                     edgecolor=\"red\")\n    plt.fill([3, 3, .8, .8, 3], [2, -2, -2, 0, 2], \"b\")\n\n    # text and typesetting\n    plt.plot([0.9], [0.5], \"ro\", markersize=3)\n    plt.text(0.9, 0.5, 'unicode (ü, °, \\N{Section Sign}) and math ($\\\\mu_i = x_i^2$)',\n             ha='right', fontsize=20)\n    plt.ylabel('sans-serif, blue, $\\\\frac{\\\\sqrt{x}}{y^2}$..',\n               family='sans-serif', color='blue')\n    plt.text(1, 1, 'should be clipped as default clip_box is Axes bbox',\n             fontsize=20, clip_on=True)\n\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "_AxesStack", "parameters": ["self"], "calls": ["itertools.count"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 79, "end_line": 81}, "code_snippet": "    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n", "type": "function"}, {"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "StemContainer", "docstring": "Container for the artists created in a :meth:`.Axes.stem` plot.\n\nThe container can be treated like a namedtuple ``(markerline, stemlines,\nbaseline)``.\n\nAttributes\n----------\nmarkerline : `~matplotlib.lines.Line2D`\n    The artist of the markers at the stem heads.\n\nstemlines : `~matplotlib.collections.LineCollection`\n    The artists of the vertical lines for all stems.\n\nbaseline : `~matplotlib.lines.Line2D`\n    The artist of the horizontal baseline.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "container.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 109, "end_line": 141}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["__init__", "self.set", "cbook.Grouper", "cbook.Grouper", "cbook.Grouper", "super"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 123, "end_line": 154}, "code_snippet": "    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n        self.set(**kwargs)\n", "type": "function"}, {"name": "Axis", "docstring": "Base class for `.XAxis` and `.YAxis`.\n\nAttributes\n----------\nisDefault_label : bool\n\naxes : `~matplotlib.axes.Axes`\n    The `~.axes.Axes` to which the Axis belongs.\nmajor : `~matplotlib.axis.Ticker`\n    Determines the major tick positions and their label format.\nminor : `~matplotlib.axis.Ticker`\n    Determines the minor tick positions and their label format.\ncallbacks : `~matplotlib.cbook.CallbackRegistry`\n\nlabel : `~matplotlib.text.Text`\n    The axis label.\nlabelpad : float\n    The distance between the axis label and the tick labels.\n    Defaults to :rc:`axes.labelpad`.\noffsetText : `~matplotlib.text.Text`\n    A `.Text` object containing the data offset of the ticks (if any).\npickradius : float\n    The acceptance radius for containment tests. See also `.Axis.contains`.\nmajorTicks : list of `.Tick`\n    The major ticks.\n\n    .. warning::\n\n        Ticks are not guaranteed to be persistent. Various operations\n        can create, delete and modify the Tick instances. There is an\n        imminent risk that changes to individual ticks will not\n        survive if you work on the figure further (including also\n        panning/zooming on a displayed figure).\n\n        Working on the individual ticks is a method of last resort.\n        Use `.set_tick_params` instead if possible.\n\nminorTicks : list of `.Tick`\n    The minor ticks.", "methods": [], "attributes": [], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 561, "end_line": 2345}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasBase", "parameters": ["self", "figure"], "calls": ["self._fix_ipython_backend2gui", "figure.set_canvas", "widgets.LockDraw", "__init__", "Figure", "super"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1749, "end_line": 1768}, "code_snippet": "    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0455467700958252}
{"question": "Why does Matplotlib implement a backend system for different output formats instead of a single rendering engine?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements a backend system instead of a single rendering engine to support diverse use cases and output requirements. Different use cases require different capabilities: 1) Interactive backends (Qt, Tk, GTK, Wx, macOS) need GUI integration and event handling for real-time user interaction, 2) File output backends (PNG, PDF, SVG, PS) need specific format optimizations and vector/raster rendering capabilities, 3) Different output formats have fundamentally different requirements - vector formats (PDF, SVG) need scalable graphics while raster formats (PNG) need pixel-perfect rendering, 4) The backend system allows separation of concerns between plotting logic and output mechanism, enabling the same plotting code to work across different environments, 5) Different GUI toolkits have different event loops and integration requirements that require specialized backend implementations, 6) The backend system provides flexibility for users to choose the most appropriate output method for their specific needs (interactive exploration vs. publication-quality output), 7) It allows for backend-specific optimizations and features while maintaining a consistent high-level API. This modular approach enables Matplotlib to support a wide range of use cases from interactive data exploration to batch image generation.", "score": null, "retrieved_content": [{"name": "test_savefig_backend", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "fig.savefig", "pytest.raises", "fig.savefig"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 600, "end_line": 607}, "code_snippet": "def test_savefig_backend():\n    fig = plt.figure()\n    # Intentionally use an invalid module name.\n    with pytest.raises(ModuleNotFoundError, match=\"No module named '@absent'\"):\n        fig.savefig(\"test\", backend=\"module://@absent\")\n    with pytest.raises(ValueError,\n                       match=\"The 'pdf' backend does not support png output\"):\n        fig.savefig(\"test.png\", backend=\"pdf\")\n", "type": "function"}, {"name": "use", "is_method": false, "class_name": null, "parameters": ["backend"], "calls": ["rcsetup.validate_backend", "rcParams._get_backend_or_none", "sys.modules.get", "plt.switch_backend"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1189, "end_line": 1259}, "code_snippet": "def use(backend, *, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    If pyplot is already imported, `~matplotlib.pyplot.switch_backend` is used\n    and if the new backend is different than the current backend, all Figures\n    will be closed.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg, notebook, QtAgg,\n          QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo, Qt5Agg, Qt5Cairo\n\n        - non-interactive backends:\n          agg, cairo, pdf, pgf, ps, svg, template\n\n        or a string of the form: ``module://my.module.name``.\n\n        notebook is a synonym for nbAgg.\n\n        Switching to an interactive backend is not possible if an unrelated\n        event loop has already been started (e.g., switching to GTK3Agg if a\n        TkAgg window has already been opened).  Switching to a non-interactive\n        backend is always possible.\n\n    force : bool, default: True\n        If True (the default), raise an `ImportError` if the backend cannot be\n        set up (either because it fails to import, or because an incompatible\n        GUI interactive framework is already running); if False, silently\n        ignore the failure.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    matplotlib.pyplot.switch_backend\n\n    \"\"\"\n    name = rcsetup.validate_backend(backend)\n    # don't (prematurely) resolve the \"auto\" backend setting\n    if rcParams._get_backend_or_none() == name:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # if pyplot is not already imported, do not import it.  Doing\n        # so may trigger a `plt.switch_backend` to the _default_ backend\n        # before we get a chance to change to the one the user just requested\n        plt = sys.modules.get('matplotlib.pyplot')\n        # if pyplot is imported, then try to change backends\n        if plt is not None:\n            try:\n                # we need this import check here to re-raise if the\n                # user does not have the libraries to support their\n                # chosen backend installed.\n                plt.switch_backend(name)\n            except ImportError:\n                if force:\n                    raise\n        # if we have not imported pyplot, then we can set the rcParam\n        # value which will be respected when the user finally imports\n        # pyplot\n        else:\n            rcParams['backend'] = backend\n    # if the user has asked for a given backend, do not helpfully\n    # fallback\n    rcParams['backend_fallback'] = False\n", "type": "function"}, {"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "MathTextParser", "parameters": ["self", "output"], "calls": ["_api.check_getitem", "output.lower"], "code_location": {"file": "mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 48, "end_line": 60}, "code_snippet": "    def __init__(self, output):\n        \"\"\"\n        Create a MathTextParser for the given backend *output*.\n\n        Parameters\n        ----------\n        output : {\"path\", \"agg\"}\n            Whether to return a `VectorParse` (\"path\") or a\n            `RasterParse` (\"agg\", or its synonym \"macosx\").\n        \"\"\"\n        self._output_type = _api.check_getitem(\n            {\"path\": \"vector\", \"agg\": \"raster\", \"macosx\": \"raster\"},\n            output=output.lower())\n", "type": "function"}, {"name": "_save_figure", "is_method": false, "class_name": null, "parameters": ["objects", "fmt", "usetex"], "calls": ["mpl.use", "mpl.rcParams.update", "plt.figure", "iter", "fig.subplots_adjust", "range", "add_subplot", "ax.plot", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "getattr", "fig.savefig", "fig.add_subplot", "range", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "fig.add_subplot", "ax2.set_xticks", "zip", "fig.subplots", "imshow", "imshow", "imshow", "fig.subfigures", "add_subplot", "px.imshow", "pimg.set_clip_path", "add_subplot", "plt.imread", "TextPath", "PathClippedImagePatch", "AuxTransformBox", "offsetbox.add_artist", "AnchoredOffsetbox", "ax.add_artist", "deepcopy", "deepcopy", "Path.make_compound_path", "deepcopy", "subplots", "len", "plot_markers", "plot_hatch", "plot_image", "plot_paths", "ax2.bar", "ax2.bar", "bar.set_hatch", "Circle", "get_sample_data", "IdentityTransform", "PathCollection", "collection.set_clip_path", "ax1.add_collection", "PathPatch", "patch.set_clip_path", "ax2.add_patch", "ax1.set_xlim", "ax1.set_ylim", "fig.subfigures", "next", "next", "next", "next", "next", "range", "range", "range", "__init__", "BboxImage", "self.bbox_image.set_data", "set_facecolor", "self.bbox_image.set_clip_path", "self.bbox_image.draw", "draw", "Path.unit_rectangle", "Path.unit_circle", "Path.unit_regular_star", "dict", "range", "self.get_transform", "super", "super", "super"], "code_location": {"file": "test_determinism.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 25, "end_line": 154}, "code_snippet": "def _save_figure(objects='mhip', fmt=\"pdf\", usetex=False):\n    mpl.use(fmt)\n    mpl.rcParams.update({'svg.hashsalt': 'asdf', 'text.usetex': usetex})\n\n    def plot_markers(fig):\n        # use different markers...\n        ax = fig.add_subplot()\n        x = range(10)\n        ax.plot(x, [1] * 10, marker='D')\n        ax.plot(x, [2] * 10, marker='x')\n        ax.plot(x, [3] * 10, marker='^')\n        ax.plot(x, [4] * 10, marker='H')\n        ax.plot(x, [5] * 10, marker='v')\n\n    def plot_hatch(fig):\n        # also use different hatch patterns\n        ax2 = fig.add_subplot()\n        bars = (ax2.bar(range(1, 5), range(1, 5)) +\n                ax2.bar(range(1, 5), [6] * 4, bottom=range(1, 5)))\n        ax2.set_xticks([1.5, 2.5, 3.5, 4.5])\n\n        patterns = ('-', '+', 'x', '\\\\', '*', 'o', 'O', '.')\n        for bar, pattern in zip(bars, patterns):\n            bar.set_hatch(pattern)\n\n    def plot_image(fig):\n        axs = fig.subplots(1, 3, sharex=True, sharey=True)\n        # also use different images\n        A = [[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n        axs[0].imshow(A, interpolation='nearest')\n        A = [[1, 3, 2], [1, 2, 3], [3, 1, 2]]\n        axs[1].imshow(A, interpolation='bilinear')\n        A = [[2, 3, 1], [1, 2, 3], [2, 1, 3]]\n        axs[2].imshow(A, interpolation='bicubic')\n\n    def plot_paths(fig):\n        # clipping support class, copied from demo_text_path.py gallery example\n        class PathClippedImagePatch(PathPatch):\n            \"\"\"\n            The given image is used to draw the face of the patch. Internally,\n            it uses BboxImage whose clippath set to the path of the patch.\n\n            FIXME : The result is currently dpi dependent.\n            \"\"\"\n\n            def __init__(self, path, bbox_image, **kwargs):\n                super().__init__(path, **kwargs)\n                self.bbox_image = BboxImage(\n                    self.get_window_extent, norm=None, origin=None)\n                self.bbox_image.set_data(bbox_image)\n\n            def set_facecolor(self, color):\n                \"\"\"Simply ignore facecolor.\"\"\"\n                super().set_facecolor(\"none\")\n\n            def draw(self, renderer=None):\n                # the clip path must be updated every draw. any solution? -JJ\n                self.bbox_image.set_clip_path(self._path, self.get_transform())\n                self.bbox_image.draw(renderer)\n                super().draw(renderer)\n\n        subfigs = fig.subfigures(1, 3)\n\n        # add a polar projection\n        px = subfigs[0].add_subplot(projection=\"polar\")\n        pimg = px.imshow([[2]])\n        pimg.set_clip_path(Circle((0, 1), radius=0.3333))\n\n        # add a text-based clipping path (origin: demo_text_path.py)\n        ax = subfigs[1].add_subplot()\n        arr = plt.imread(get_sample_data(\"grace_hopper.jpg\"))\n        text_path = TextPath((0, 0), \"!?\", size=150)\n        p = PathClippedImagePatch(text_path, arr, ec=\"k\")\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(p)\n        ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,\n                               borderpad=0.2)\n        ax.add_artist(ao)\n\n        # add a 2x2 grid of path-clipped axes (origin: test_artist.py)\n        exterior = Path.unit_rectangle().deepcopy()\n        exterior.vertices *= 4\n        exterior.vertices -= 2\n        interior = Path.unit_circle().deepcopy()\n        interior.vertices = interior.vertices[::-1]\n        clip_path = Path.make_compound_path(exterior, interior)\n\n        star = Path.unit_regular_star(6).deepcopy()\n        star.vertices *= 2.6\n\n        (row1, row2) = subfigs[2].subplots(2, 2, sharex=True, sharey=True,\n                                           gridspec_kw=dict(hspace=0, wspace=0))\n        for row in (row1, row2):\n            ax1, ax2 = row\n            collection = PathCollection([star], lw=5, edgecolor='blue',\n                                        facecolor='red', alpha=0.7, hatch='*')\n            collection.set_clip_path(clip_path, ax1.transData)\n            ax1.add_collection(collection)\n\n            patch = PathPatch(star, lw=5, edgecolor='blue', facecolor='red',\n                              alpha=0.7, hatch='*')\n            patch.set_clip_path(clip_path, ax2.transData)\n            ax2.add_patch(patch)\n\n            ax1.set_xlim([-3, 3])\n            ax1.set_ylim([-3, 3])\n\n    nfigs = len(objects) + 1\n    fig = plt.figure(figsize=(7, 3 * nfigs))\n    subfigs = iter(fig.subfigures(nfigs, squeeze=False).flat)\n    fig.subplots_adjust(bottom=0.15)\n\n    if 'm' in objects:\n        plot_markers(next(subfigs))\n    if 'h' in objects:\n        plot_hatch(next(subfigs))\n    if 'i' in objects:\n        plot_image(next(subfigs))\n    if 'p' in objects:\n        plot_paths(next(subfigs))\n\n    x = range(5)\n    ax = next(subfigs).add_subplot()\n    ax.plot(x, x)\n    ax.set_title('A string $1+2+\\\\sigma$')\n    ax.set_xlabel('A string $1+2+\\\\sigma$')\n    ax.set_ylabel('A string $1+2+\\\\sigma$')\n\n    stdout = getattr(sys.stdout, 'buffer', sys.stdout)\n    fig.savefig(stdout, format=fmt)\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "_test_interactive_impl", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.rcParams.update", "mpl.rcParams.update", "lower", "mpl.use", "plt.subplots", "ax.plot", "fig.canvas.new_timer", "timer.add_callback", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "io.BytesIO", "fig.savefig", "plt.show", "plt.pause", "io.BytesIO", "fig.savefig", "json.loads", "backend.endswith", "plt.figure", "plt.close", "importlib.util.find_spec", "check_alt_backend", "fig.canvas.manager.get_window_title", "_test_toolbar_button_la_mode_icon", "fig.canvas.toolbar.draw_rubberband", "result.getvalue", "result_after.getvalue", "backend.startswith", "mpl.use", "plt.figure", "plt.close", "check_alt_backend", "type", "KeyEvent", "timer.start", "pytest.raises", "mpl.use", "type"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 156, "end_line": 236}, "code_snippet": "def _test_interactive_impl():\n    import importlib.util\n    import io\n    import json\n    import sys\n\n    import pytest\n\n    import matplotlib as mpl\n    from matplotlib import pyplot as plt\n    from matplotlib.backend_bases import KeyEvent\n    mpl.rcParams.update({\n        \"webagg.open_in_browser\": False,\n        \"webagg.port_retries\": 1,\n    })\n\n    mpl.rcParams.update(json.loads(sys.argv[1]))\n    backend = plt.rcParams[\"backend\"].lower()\n\n    if backend.endswith(\"agg\") and not backend.startswith((\"gtk\", \"web\")):\n        # Force interactive framework setup.\n        fig = plt.figure()\n        plt.close(fig)\n\n        # Check that we cannot switch to a backend using another interactive\n        # framework, but can switch to a backend using cairo instead of agg,\n        # or a non-interactive backend.  In the first case, we use tkagg as\n        # the \"other\" interactive backend as it is (essentially) guaranteed\n        # to be present.  Moreover, don't test switching away from gtk3 (as\n        # Gtk.main_level() is not set up at this point yet) and webagg (which\n        # uses no interactive framework).\n\n        if backend != \"tkagg\":\n            with pytest.raises(ImportError):\n                mpl.use(\"tkagg\", force=True)\n\n        def check_alt_backend(alt_backend):\n            mpl.use(alt_backend, force=True)\n            fig = plt.figure()\n            assert (type(fig.canvas).__module__ ==\n                    f\"matplotlib.backends.backend_{alt_backend}\")\n            plt.close(\"all\")\n\n        if importlib.util.find_spec(\"cairocffi\"):\n            check_alt_backend(backend[:-3] + \"cairo\")\n        check_alt_backend(\"svg\")\n    mpl.use(backend, force=True)\n\n    fig, ax = plt.subplots()\n    assert type(fig.canvas).__module__ == f\"matplotlib.backends.backend_{backend}\"\n\n    assert fig.canvas.manager.get_window_title() == \"Figure 1\"\n\n    if mpl.rcParams[\"toolbar\"] == \"toolmanager\":\n        # test toolbar button icon LA mode see GH issue 25174\n        _test_toolbar_button_la_mode_icon(fig)\n\n    ax.plot([0, 1], [2, 3])\n    if fig.canvas.toolbar:  # i.e toolbar2.\n        fig.canvas.toolbar.draw_rubberband(None, 1., 1, 2., 2)\n\n    timer = fig.canvas.new_timer(1.)  # Test that floats are cast to int.\n    timer.add_callback(KeyEvent(\"key_press_event\", fig.canvas, \"q\")._process)\n    # Trigger quitting upon draw.\n    fig.canvas.mpl_connect(\"draw_event\", lambda event: timer.start())\n    fig.canvas.mpl_connect(\"close_event\", print)\n\n    result = io.BytesIO()\n    fig.savefig(result, format='png')\n\n    plt.show()\n\n    # Ensure that the window is really closed.\n    plt.pause(0.5)\n\n    # Test that saving works after interactive window is closed, but the figure\n    # is not deleted.\n    result_after = io.BytesIO()\n    fig.savefig(result_after, format='png')\n\n    assert result.getvalue() == result_after.getvalue()\n", "type": "function"}, {"name": "get_renderer", "is_method": true, "class_name": "FigureCanvasPgf", "parameters": ["self"], "calls": ["RendererPgf"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 869, "end_line": 870}, "code_snippet": "    def get_renderer(self):\n        return RendererPgf(self.figure, None)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "test_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["RendererAgg", "pickle.dump", "BytesIO"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 195, "end_line": 198}, "code_snippet": "def test_renderer():\n    from matplotlib.backends.backend_agg import RendererAgg\n    renderer = RendererAgg(10, 20, 30)\n    pickle.dump(renderer, BytesIO())\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0231568813323975}
{"question": "What is the structure of Matplotlib's figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's figure and axes hierarchy follows a parent-child relationship: 1) Figure is the top-level container that holds all plot elements and serves as the root Artist, 2) SubFigure objects can be nested within a Figure to create logical groupings, 3) Axes objects are the primary plotting areas within Figures or SubFigures, containing the actual data visualization, 4) Each Axes contains XAxis and YAxis objects that handle tick marks, labels, and coordinate systems, 5) Individual Artist objects (lines, text, patches, etc.) are contained within Axes. The hierarchy is managed through methods like Figure.add_axes(), Figure.subplots(), and Figure.add_subfigure(), with the Figure maintaining lists of its child Axes and other Artists. This structure allows for complex layouts with multiple subplots, nested figures, and precise control over the positioning and organization of plot elements.", "score": null, "retrieved_content": [{"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "test_get_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "sfig1.subfigures", "sfig2.subplots", "mlines.Line2D", "fig.get_figure", "fig.get_figure", "ax.get_figure", "ax.get_figure", "ax.get_figure", "sfig2.get_figure", "sfig2.get_figure", "pytest.warns", "sfig1.get_figure", "ln.get_figure", "ln.get_figure", "sfig2.get_figure"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 598}, "code_snippet": "def test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["__init__", "self.set", "cbook.Grouper", "cbook.Grouper", "cbook.Grouper", "super"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 123, "end_line": 154}, "code_snippet": "    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n        self.set(**kwargs)\n", "type": "function"}, {"name": "Axes", "docstring": "An Axes object encapsulates all the elements of an individual (sub-)plot in\na figure.\n\nIt contains most of the (sub-)plot elements: `~.axis.Axis`,\n`~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,\nand sets the coordinate system.\n\nLike all visible elements in a figure, Axes is an `.Artist` subclass.\n\nThe `Axes` instance supports callbacks through a callbacks attribute which\nis a `~.cbook.CallbackRegistry` instance.  The events you can connect to\nare 'xlim_changed' and 'ylim_changed' and the callback will be called with\nfunc(*ax*) where *ax* is the `Axes` instance.\n\n.. note::\n\n    As a user, you do not instantiate Axes directly, but use Axes creation\n    methods instead; e.g. from `.pyplot` or `.Figure`:\n    `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.", "methods": [], "attributes": [], "code_location": {"file": "_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 85, "end_line": 9190}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "_AxesStack", "parameters": ["self"], "calls": ["itertools.count"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 79, "end_line": 81}, "code_snippet": "    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n", "type": "function"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "test_figure_clear", "is_method": false, "class_name": null, "parameters": ["clear_meth"], "calls": ["pytest.mark.parametrize", "plt.figure", "fig.clear", "fig.add_subplot", "fig.add_gridspec", "fig.add_subfigure", "subfig.add_subplot", "fig.add_subfigure", "subfig.add_subplot", "fig.add_subplot", "mainaxes.remove", "fig.add_subplot", "subaxes.remove", "subfig.add_subplot", "subfig.add_subplot", "all", "all", "all", "all", "getattr", "fig.add_subplot", "getattr", "getattr", "getattr", "getattr", "fig.add_subfigure", "sfig.add_subplot", "getattr", "getattr", "fig.add_subfigure", "sfig.add_subplot", "getattr", "range"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 863, "end_line": 941}, "code_snippet": "def test_figure_clear(clear_meth):\n    # we test the following figure clearing scenarios:\n    fig = plt.figure()\n\n    # a) an empty figure\n    fig.clear()\n    assert fig.axes == []\n\n    # b) a figure with a single unnested axes\n    ax = fig.add_subplot(111)\n    getattr(fig, clear_meth)()\n    assert fig.axes == []\n\n    # c) a figure multiple unnested axes\n    axes = [fig.add_subplot(2, 1, i+1) for i in range(2)]\n    getattr(fig, clear_meth)()\n    assert fig.axes == []\n\n    # d) a figure with a subfigure\n    gs = fig.add_gridspec(ncols=2, nrows=1)\n    subfig = fig.add_subfigure(gs[0])\n    subaxes = subfig.add_subplot(111)\n    getattr(fig, clear_meth)()\n    assert subfig not in fig.subfigs\n    assert fig.axes == []\n\n    # e) a figure with a subfigure and a subplot\n    subfig = fig.add_subfigure(gs[0])\n    subaxes = subfig.add_subplot(111)\n    mainaxes = fig.add_subplot(gs[1])\n\n    # e.1) removing just the axes leaves the subplot\n    mainaxes.remove()\n    assert fig.axes == [subaxes]\n\n    # e.2) removing just the subaxes leaves the subplot\n    # and subfigure\n    mainaxes = fig.add_subplot(gs[1])\n    subaxes.remove()\n    assert fig.axes == [mainaxes]\n    assert subfig in fig.subfigs\n\n    # e.3) clearing the subfigure leaves the subplot\n    subaxes = subfig.add_subplot(111)\n    assert mainaxes in fig.axes\n    assert subaxes in fig.axes\n    getattr(subfig, clear_meth)()\n    assert subfig in fig.subfigs\n    assert subaxes not in subfig.axes\n    assert subaxes not in fig.axes\n    assert mainaxes in fig.axes\n\n    # e.4) clearing the whole thing\n    subaxes = subfig.add_subplot(111)\n    getattr(fig, clear_meth)()\n    assert fig.axes == []\n    assert fig.subfigs == []\n\n    # f) multiple subfigures\n    subfigs = [fig.add_subfigure(gs[i]) for i in [0, 1]]\n    subaxes = [sfig.add_subplot(111) for sfig in subfigs]\n    assert all(ax in fig.axes for ax in subaxes)\n    assert all(sfig in fig.subfigs for sfig in subfigs)\n\n    # f.1) clearing only one subfigure\n    getattr(subfigs[0], clear_meth)()\n    assert subaxes[0] not in fig.axes\n    assert subaxes[1] in fig.axes\n    assert subfigs[1] in fig.subfigs\n\n    # f.2) clearing the whole thing\n    getattr(subfigs[1], clear_meth)()\n    subfigs = [fig.add_subfigure(gs[i]) for i in [0, 1]]\n    subaxes = [sfig.add_subplot(111) for sfig in subfigs]\n    assert all(ax in fig.axes for ax in subaxes)\n    assert all(sfig in fig.subfigs for sfig in subfigs)\n    getattr(fig, clear_meth)()\n    assert fig.subfigs == []\n    assert fig.axes == []\n", "type": "function"}, {"name": "_AxesStack", "docstring": "Helper class to track Axes in a figure.\n\nAxes are tracked both in the order in which they have been added\n(``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n(which is the index to which they map in the ``self._axes`` dict).", "methods": ["__init__", "as_list", "remove", "bubble", "add", "current", "__getstate__", "__setstate__"], "attributes": [], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 70, "end_line": 115}, "type": "class"}, {"name": "test_figure_repr", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "repr"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 674, "end_line": 676}, "code_snippet": "def test_figure_repr():\n    fig = plt.figure(figsize=(10, 20), dpi=10)\n    assert repr(fig) == \"<Figure size 100x200 with 0 Axes>\"\n", "type": "function"}, {"name": "SubFigure", "docstring": "Logical figure that can be placed inside a figure.\n\nSee :ref:`figure-api-subfigure` for an index of methods on this class.\nTypically instantiated using `.Figure.add_subfigure` or\n`.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has\nthe same methods as a figure except for those particularly tied to the size\nor dpi of the figure, and is confined to a prescribed region of the figure.\nFor example the following puts two subfigures side-by-side::\n\n    fig = plt.figure()\n    sfigs = fig.subfigures(1, 2)\n    axsL = sfigs[0].subplots(1, 2)\n    axsR = sfigs[1].subplots(2, 1)\n\nSee :doc:`/gallery/subplots_axes_and_figures/subfigures`", "methods": ["__init__", "canvas", "dpi", "dpi", "get_dpi", "set_dpi", "_get_renderer", "_redo_transform_rel_fig", "get_constrained_layout", "get_constrained_layout_pads", "get_layout_engine", "axes", "draw"], "attributes": ["get_axes"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2216, "end_line": 2420}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0512959957122803}
{"question": "What is the relationship between Matplotlib's Figure class and Axes class in the plotting hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "The Figure class and Axes class have a parent-child relationship in Matplotlib's plotting hierarchy. The Figure serves as the top-level container that holds all plot elements, while Axes objects are the primary plotting areas within a Figure. A Figure can contain multiple Axes objects, and each Axes represents a single plotting region with its own coordinate system. The Figure manages the overall layout, size, and background, while Axes handle the actual data visualization, coordinate transformations, and individual plot elements. The Figure provides methods like add_axes(), subplots(), and add_subplot() to create and manage Axes objects. Each Axes is tied to its parent Figure through the figure attribute, and the Figure maintains lists of its child Axes through the axes property. This hierarchical structure allows for complex layouts with multiple subplots while maintaining clear separation of concerns between figure-level and axes-level functionality.", "score": null, "retrieved_content": [{"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "Axes", "docstring": "An Axes object encapsulates all the elements of an individual (sub-)plot in\na figure.\n\nIt contains most of the (sub-)plot elements: `~.axis.Axis`,\n`~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,\nand sets the coordinate system.\n\nLike all visible elements in a figure, Axes is an `.Artist` subclass.\n\nThe `Axes` instance supports callbacks through a callbacks attribute which\nis a `~.cbook.CallbackRegistry` instance.  The events you can connect to\nare 'xlim_changed' and 'ylim_changed' and the callback will be called with\nfunc(*ax*) where *ax* is the `Axes` instance.\n\n.. note::\n\n    As a user, you do not instantiate Axes directly, but use Axes creation\n    methods instead; e.g. from `.pyplot` or `.Figure`:\n    `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.", "methods": [], "attributes": [], "code_location": {"file": "_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 85, "end_line": 9190}, "type": "class"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["__init__", "self.set", "cbook.Grouper", "cbook.Grouper", "cbook.Grouper", "super"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 123, "end_line": 154}, "code_snippet": "    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n        self.set(**kwargs)\n", "type": "function"}, {"name": "Axes", "docstring": "", "methods": ["axis", "clear", "__init__", "toggle_axisline", "axis", "clear", "get_grid_helper", "grid", "get_children", "new_fixed_axis", "new_floating_axis", "get_title", "set_title", "get_legend_handles_labels", "legend", "_remove_legend", "inset_axes", "indicate_inset", "indicate_inset_zoom", "secondary_xaxis", "secondary_yaxis", "text", "annotate", "axhline", "axvline", "_check_no_units", "axline", "axhspan", "axvspan", "hlines", "vlines", "eventplot", "plot", "loglog", "semilogx", "semilogy", "acorr", "xcorr", "step", "_convert_dx", "_parse_bar_color_args", "bar", "barh", "bar_label", "broken_barh", "grouped_bar", "stem", "pie", "_errorevery_to_mask", "errorbar", "boxplot", "bxp", "_parse_scatter_color_args", "scatter", "hexbin", "arrow", "quiverkey", "_quiver_units", "quiver", "barbs", "fill", "_fill_between_x_or_y", "_fill_between_process_units", "fill_between", "fill_betweenx", "imshow", "_pcolorargs", "pcolor", "pcolormesh", "_update_pcolor_lims", "pcolorfast", "contour", "contourf", "clabel", "hist", "stairs", "hist2d", "ecdf", "psd", "csd", "magnitude_spectrum", "angle_spectrum", "phase_spectrum", "cohere", "specgram", "spy", "matshow", "violinplot", "violin", "_get_aspect_ratio"], "attributes": ["fill_between", "fill_betweenx", "table", "stackplot", "streamplot", "tricontour", "tricontourf", "tripcolor", "triplot"], "code_location": {"file": "mpl_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 19, "end_line": 56}, "type": "class"}, {"name": "Axes", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 366, "end_line": 454}, "type": "class"}, {"name": "_AxesStack", "docstring": "Helper class to track Axes in a figure.\n\nAxes are tracked both in the order in which they have been added\n(``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n(which is the index to which they map in the ``self._axes`` dict).", "methods": ["__init__", "as_list", "remove", "bubble", "add", "current", "__getstate__", "__setstate__"], "attributes": [], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 70, "end_line": 115}, "type": "class"}, {"name": "SubclassAxes", "docstring": "", "methods": ["__init__"], "attributes": [], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 7828, "end_line": 7831}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "_AxesStack", "parameters": ["self"], "calls": ["itertools.count"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 79, "end_line": 81}, "code_snippet": "    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n", "type": "function"}, {"name": "_AxesBase", "docstring": "", "methods": ["__str__", "__init__", "__init_subclass__", "__getstate__", "__setstate__", "__repr__", "get_subplotspec", "set_subplotspec", "get_gridspec", "get_window_extent", "_init_axis", "set_figure", "_unstale_viewLim", "viewLim", "_request_autoscale_view", "_set_lim_and_transforms", "get_xaxis_transform", "get_xaxis_text1_transform", "get_xaxis_text2_transform", "get_yaxis_transform", "get_yaxis_text1_transform", "get_yaxis_text2_transform", "_update_transScale", "get_position", "set_position", "_set_position", "reset_position", "set_axes_locator", "get_axes_locator", "_set_artist_props", "_gen_axes_patch", "_gen_axes_spines", "sharex", "sharey", "__clear", "clear", "cla", "artists", "collections", "images", "lines", "patches", "tables", "texts", "get_facecolor", "set_facecolor", "_set_title_offset_trans", "set_prop_cycle", "get_aspect", "set_aspect", "get_adjustable", "set_adjustable", "get_box_aspect", "set_box_aspect", "get_anchor", "set_anchor", "get_data_ratio", "apply_aspect", "axis", "get_legend", "get_images", "get_lines", "get_xaxis", "get_yaxis", "_sci", "_gci", "has_data", "add_artist", "add_child_axes", "add_collection", "add_image", "_update_image_limits", "add_line", "_add_text", "_update_line_limits", "add_patch", "_update_patch_limits", "add_table", "add_container", "_unit_change_handler", "relim", "update_datalim", "_process_unit_info", "in_axes", "get_autoscale_on", "set_autoscale_on", "use_sticky_edges", "use_sticky_edges", "get_xmargin", "get_ymargin", "set_xmargin", "set_ymargin", "margins", "set_rasterization_zorder", "get_rasterization_zorder", "autoscale", "autoscale_view", "_update_title_position", "draw", "draw_artist", "redraw_in_frame", "get_frame_on", "set_frame_on", "get_axisbelow", "set_axisbelow", "grid", "ticklabel_format", "locator_params", "tick_params", "set_axis_off", "set_axis_on", "get_xlabel", "set_xlabel", "invert_xaxis", "get_xbound", "set_xbound", "get_xlim", "_validate_converted_limits", "set_xlim", "get_ylabel", "set_ylabel", "invert_yaxis", "get_ybound", "set_ybound", "get_ylim", "set_ylim", "format_xdata", "format_ydata", "format_coord", "minorticks_on", "minorticks_off", "can_zoom", "can_pan", "get_navigate", "set_navigate", "get_navigate_mode", "set_navigate_mode", "_get_view", "_set_view", "_prepare_view_from_bbox", "_set_view_from_bbox", "start_pan", "end_pan", "_get_pan_points", "drag_pan", "get_children", "contains", "contains_point", "get_default_bbox_extra_artists", "get_tightbbox", "_make_twin_axes", "twinx", "twiny", "get_shared_x_axes", "get_shared_y_axes", "label_outer", "_get_subplotspec_with_optional_colorbar", "_label_outer_xaxis", "_label_outer_yaxis", "set_forward_navigation_events", "get_forward_navigation_events"], "attributes": ["name", "_axis_names", "_shared_axes", "_twinned_axes", "_subclass_uses_cla", "get_xgridlines", "get_xticklines", "get_ygridlines", "get_yticklines", "get_autoscalex_on", "get_autoscaley_on", "set_autoscalex_on", "set_autoscaley_on", "set_xinverted", "get_xinverted", "xaxis_inverted", "get_xscale", "set_xscale", "get_xticks", "set_xticks", "get_xmajorticklabels", "get_xminorticklabels", "get_xticklabels", "set_xticklabels", "set_yinverted", "get_yinverted", "yaxis_inverted", "get_yscale", "set_yscale", "get_yticks", "set_yticks", "get_ymajorticklabels", "get_yminorticklabels", "get_yticklabels", "set_yticklabels", "xaxis_date", "yaxis_date"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 542, "end_line": 4873}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.048081636428833}
{"question": "What dependencies exist between Matplotlib's Artist system and the backend rendering pipeline?", "answer": null, "relative_code_list": null, "ground_truth": "The Artist system and backend rendering pipeline have several key dependencies: 1) The Artist class defines a draw() method that takes a renderer parameter, creating a direct dependency where Artists must work with backend-specific renderers to produce output, 2) Artists depend on the backend's coordinate transformation system to convert between data coordinates and display coordinates, 3) The backend provides the rendering context (canvas, graphics context) that Artists use to draw themselves, 4) Artists rely on backend-specific features like rasterization support, alpha blending, and clipping capabilities, 5) The backend determines what rendering operations are available (vector vs raster, file formats supported), which constrains what Artists can do, 6) Artists use backend-provided transforms and bounding boxes for layout and positioning, 7) The backend's event handling system integrates with Artists for interactive features like picking and mouse events. This dependency structure allows the same Artist objects to work across different backends while leveraging backend-specific optimizations and capabilities.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Axis", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1276, "end_line": 1279}, "code_snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "test_add_artist", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_test.subplots", "plt.Line2D", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "l2.remove", "fig_ref.subplots", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "fig_test.add_artist", "ax2.add_artist"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 774, "end_line": 799}, "code_snippet": "def test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], transform=fig_ref.transFigure,\n                    gid='l1', zorder=21)\n    r1 = plt.Circle((20, 20), 100, transform=None, clip_on=False, zorder=20,\n                    gid='C1')\n    r2 = plt.Circle((.7, .5), .05, transform=fig_ref.transFigure, gid='C2',\n                    zorder=20)\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_ref.dpi_scale_trans,\n                    facecolor='crimson', clip_on=False, zorder=20, gid='C3')\n    for a in [l1, r1, r2, r3]:\n        ax2.add_artist(a)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FancyArrowPatch", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._get_path_in_displaycoord", "transforms.IdentityTransform", "self._draw_paths_with_artist_properties", "self.get_visible", "np.iterable", "zip"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 4519, "end_line": 4538}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        # FIXME: dpi_cor is for the dpi-dependency of the linewidth.  There\n        # could be room for improvement.  Maybe _get_path_in_displaycoord could\n        # take a renderer argument, but get_path should be adapted too.\n        self._dpi_cor = renderer.points_to_pixels(1.)\n        path, fillable = self._get_path_in_displaycoord()\n\n        if not np.iterable(fillable):\n            path = [path]\n            fillable = [fillable]\n\n        affine = transforms.IdentityTransform()\n\n        self._draw_paths_with_artist_properties(\n            renderer,\n            [(p, affine, self._facecolor if f and self._facecolor[3] else None)\n             for p, f in zip(path, fillable)])\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "_blit_draw", "is_method": true, "class_name": "Animation", "parameters": ["self", "artists"], "calls": ["ax._get_view", "self._blit_cache.get", "a.axes.draw_artist", "ax.figure.canvas.blit", "object", "ax.figure.canvas.copy_from_bbox"], "code_location": {"file": "animation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1184, "end_line": 1204}, "code_snippet": "    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared Axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0479986667633057}
{"question": "Why does Matplotlib separate the pyplot interface from the object-oriented API?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib separates the pyplot interface from the object-oriented API to serve different use cases and provide appropriate levels of abstraction. The separation addresses several key design goals: 1) The pyplot interface provides a MATLAB-like, state-based interface that's convenient for interactive work and simple scripts, while the object-oriented API offers explicit control for complex plots and programmatic use, 2) The pyplot interface maintains global state (current Figure and Axes) which simplifies common operations but can become unwieldy for complex plots with multiple subplots, 3) The object-oriented API provides explicit references to Figure and Axes objects, enabling precise control over plot elements and better code organization for complex visualizations, 4) The separation allows users to choose the appropriate interface for their needs - pyplot for quick exploration and simple plots, object-oriented API for production code and complex customizations, 5) The pyplot interface serves as a convenience layer that reduces boilerplate code for common operations, while the object-oriented API exposes the full power and flexibility of the underlying system, 6) This design supports different programming styles and skill levels, from beginners who prefer the simplicity of pyplot to advanced users who need fine-grained control, 7) The separation enables better code maintainability and allows the core object-oriented system to evolve independently of the convenience interface.", "score": null, "retrieved_content": [{"name": "test_figure_label", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.close", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.close", "plt.close", "plt.close", "plt.close", "plt.figure", "plt.get_fignums", "plt.get_figlabels", "plt.get_fignums", "plt.get_figlabels", "plt.gcf", "pytest.raises", "plt.figure", "Figure"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 130, "end_line": 151}, "code_snippet": "def test_figure_label():\n    # pyplot figure creation, selection, and closing with label/number/instance\n    plt.close('all')\n    fig_today = plt.figure('today')\n    plt.figure(3)\n    plt.figure('tomorrow')\n    plt.figure()\n    plt.figure(0)\n    plt.figure(1)\n    plt.figure(3)\n    assert plt.get_fignums() == [0, 1, 3, 4, 5]\n    assert plt.get_figlabels() == ['', 'today', '', 'tomorrow', '']\n    plt.close(10)\n    plt.close()\n    plt.close(5)\n    plt.close('tomorrow')\n    assert plt.get_fignums() == [0, 1]\n    assert plt.get_figlabels() == ['', 'today']\n    plt.figure(fig_today)\n    assert plt.gcf() == fig_today\n    with pytest.raises(ValueError):\n        plt.figure(Figure())\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "test_no_pyplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["mfigure.Figure", "FigureCanvasPdf", "fig.add_subplot", "ax.plot", "pickle.dump", "BytesIO"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 185, "end_line": 192}, "code_snippet": "def test_no_pyplot():\n    # tests pickle-ability of a figure not created with pyplot\n    from matplotlib.backends.backend_pdf import FigureCanvasPdf\n    fig = mfigure.Figure()\n    _ = FigureCanvasPdf(fig)\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1, 2, 3], [1, 2, 3])\n    pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n", "type": "function"}, {"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "FigureManagerBase", "docstring": "A backend-independent abstraction of a figure container and controller.\n\nThe figure manager is used by pyplot to interact with the window in a\nbackend-independent way. It's an adapter for the real (GUI) framework that\nrepresents the visual figure on screen.\n\nThe figure manager is connected to a specific canvas instance, which in turn\nis connected to a specific figure instance. To access a figure manager for\na given figure in user code, you typically use ``fig.canvas.manager``.\n\nGUI backends derive from this class to translate common operations such\nas *show* or *resize* to the GUI-specific code. Non-GUI backends do not\nsupport these operations and can just use the base class.\n\nThis following basic operations are accessible:\n\n**Window operations**\n\n- `~.FigureManagerBase.show`\n- `~.FigureManagerBase.destroy`\n- `~.FigureManagerBase.full_screen_toggle`\n- `~.FigureManagerBase.resize`\n- `~.FigureManagerBase.get_window_title`\n- `~.FigureManagerBase.set_window_title`\n\n**Key and mouse button press handling**\n\nThe figure manager sets up default key and mouse button press handling by\nhooking up the `.key_press_handler` to the matplotlib event system. This\nensures the same shortcuts and mouse actions across backends.\n\n**Other operations**\n\nSubclasses will have additional attributes and functions to access\nadditional functionality. This is of course backend-specific. For example,\nmost GUI backends have ``window`` and ``toolbar`` attributes that give\naccess to the native GUI widgets of the respective framework.\n\nAttributes\n----------\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance.\n\nnum : int or str\n    The figure number.\n\nkey_press_handler_id : int\n    The default key handler cid, when using the toolmanager.\n    To disable the default key press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.key_press_handler_id)\n\nbutton_press_handler_id : int\n    The default mouse button handler cid, when using the toolmanager.\n    To disable the default button press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.button_press_handler_id)", "methods": ["__init__", "create_with_canvas", "start_main_loop", "pyplot_show", "show", "destroy", "full_screen_toggle", "resize", "get_window_title", "set_window_title"], "attributes": ["_toolbar2_class", "_toolmanager_toolbar_class"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2582, "end_line": 2787}, "type": "class"}, {"name": "test_figure_no_label", "is_method": false, "class_name": null, "parameters": [], "calls": ["Figure", "pytest.raises", "pytest.warns", "plt.fignum_exists"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 163, "end_line": 174}, "code_snippet": "def test_figure_no_label():\n    # standalone figures do not have a figure attribute\n    fig = Figure()\n    with pytest.raises(AttributeError):\n        fig.number\n    # but one can set one\n    with pytest.warns(mpl.MatplotlibDeprecationWarning,\n                      match=\"Changing 'Figure.number' is deprecated\"):\n        fig.number = 5\n    assert fig.number == 5\n    # even though it's not known by pyplot\n    assert not plt.fignum_exists(fig.number)\n", "type": "function"}, {"name": "Gcf", "docstring": "Singleton to maintain the relation between figures and their managers, and\nkeep track of and \"active\" figure and manager.\n\nThe canvas of a figure created through pyplot is associated with a figure\nmanager, which handles the interaction between the figure and the backend.\npyplot keeps track of figure managers using an identifier, the \"figure\nnumber\" or \"manager number\" (which can actually be any hashable value);\nthis number is available as the :attr:`number` attribute of the manager.\n\nThis class is never instantiated; it consists of an `OrderedDict` mapping\nfigure/manager numbers to managers, and a set of class methods that\nmanipulate this `OrderedDict`.\n\nAttributes\n----------\nfigs : OrderedDict\n    `OrderedDict` mapping numbers to managers; the active manager is at the\n    end.", "methods": ["get_fig_manager", "destroy", "destroy_fig", "destroy_all", "has_fignum", "get_all_fig_managers", "get_num_fig_managers", "get_active", "_set_new_active_manager", "set_active", "draw_all"], "attributes": ["figs"], "code_location": {"file": "_pylab_helpers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 9, "end_line": 131}, "type": "class"}, {"name": "test_pyplot_axes", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.subplots", "plt.sca", "plt.close", "plt.close", "plt.gca", "plt.gcf"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3283, "end_line": 3291}, "code_snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)\n", "type": "function"}, {"name": "test_old_subplot_compat", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "isinstance", "fig.add_subplot", "isinstance", "pytest.raises", "Axes", "fig.add_axes"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 288, "end_line": 293}, "code_snippet": "def test_old_subplot_compat():\n    fig = plt.figure()\n    assert isinstance(fig.add_subplot(), SubplotBase)\n    assert not isinstance(fig.add_axes(rect=[0, 0, 1, 1]), SubplotBase)\n    with pytest.raises(TypeError):\n        Axes(fig, [0, 0, 1, 1], rect=[0, 0, 1, 1])\n", "type": "function"}, {"name": "pyplot_show", "is_method": true, "class_name": "FigureManagerWebAgg", "parameters": ["cls"], "calls": ["WebAggApplication.initialize", "format", "WebAggApplication.start", "print", "webbrowser.open", "print"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 48, "end_line": 63}, "code_snippet": "    def pyplot_show(cls, *, block=None):\n        WebAggApplication.initialize()\n\n        url = \"http://{address}:{port}{prefix}\".format(\n            address=WebAggApplication.address,\n            port=WebAggApplication.port,\n            prefix=WebAggApplication.url_prefix)\n\n        if mpl.rcParams['webagg.open_in_browser']:\n            import webbrowser\n            if not webbrowser.open(url):\n                print(f\"To view figure, visit {url}\")\n        else:\n            print(f\"To view figure, visit {url}\")\n\n        WebAggApplication.start()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0667030811309814}
{"question": "What is the exact meaning of Matplotlib's \"Axes\" concept and its difference from a subplot?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Axes is the fundamental plotting area that contains the actual data visualization, coordinate systems, and plotting elements. An Axes is an Artist object that represents a single plotting region with its own coordinate system, typically containing XAxis and YAxis objects that define the data coordinate space. The term 'subplot' refers specifically to an Axes that is positioned within a grid of other Axes on a Figure - essentially, a subplot is an Axes that is part of a regular grid layout. While all subplots are Axes, not all Axes are subplots; an Axes can be positioned anywhere on a Figure using methods like Figure.add_axes() with custom coordinates, while subplots are created using methods like Figure.subplots() or pyplot.subplot() that automatically arrange them in a grid. The Axes class provides the main interface for plotting data, setting labels, titles, legends, and configuring the appearance of the plot.", "score": null, "retrieved_content": [{"name": "subplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["object", "kwargs.get", "kwargs.pop", "gcf", "SubplotSpec._from_subplot_args", "fig.sca", "len", "isinstance", "_api.warn_external", "TypeError", "fig.add_subplot", "ValueError", "len", "ax.get_subplotspec", "fig._process_projection_requirements"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1455, "end_line": 1632}, "code_snippet": "def subplot(*args, **kwargs) -> Axes:\n    \"\"\"\n    Add an Axes to the current figure or retrieve an existing Axes.\n\n    This is a wrapper of `.Figure.add_subplot` which provides additional\n    behavior when working with the implicit API (see the notes section).\n\n    Call signatures::\n\n       subplot(nrows, ncols, index, **kwargs)\n       subplot(pos, **kwargs)\n       subplot(**kwargs)\n\n    Parameters\n    ----------\n    *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n        The position of the subplot described by one of\n\n        - Three integers (*nrows*, *ncols*, *index*). The subplot will take the\n          *index* position on a grid with *nrows* rows and *ncols* columns.\n          *index* starts at 1 in the upper left corner and increases to the\n          right. *index* can also be a two-tuple specifying the (*first*,\n          *last*) indices (1-based, and including *last*) of the subplot, e.g.,\n          ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the\n          upper 2/3 of the figure.\n        - A 3-digit integer. The digits are interpreted as if given separately\n          as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the\n          same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n          if there are no more than 9 subplots.\n        - A `.SubplotSpec`.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n        The projection type of the subplot (`~.axes.Axes`). *str* is the name\n        of a custom projection, see `~matplotlib.projections`. The default\n        None results in a 'rectilinear' projection.\n\n    polar : bool, default: False\n        If True, equivalent to projection='polar'.\n\n    sharex, sharey : `~matplotlib.axes.Axes`, optional\n        Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n        axis will have the same limits, ticks, and scale as the axis of the\n        shared Axes.\n\n    label : str\n        A label for the returned Axes.\n\n    Returns\n    -------\n    `~.axes.Axes`\n\n        The Axes of the subplot. The returned Axes can actually be an instance\n        of a subclass, such as `.projections.polar.PolarAxes` for polar\n        projections.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for the returned Axes\n        base class; except for the *figure* argument. The keyword arguments\n        for the rectilinear base class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used.\n\n        %(Axes:kwdoc)s\n\n    Notes\n    -----\n    .. versionchanged:: 3.8\n        In versions prior to 3.8, any preexisting Axes that overlap with the new Axes\n        beyond sharing a boundary was deleted. Deletion does not happen in more\n        recent versions anymore. Use `.Axes.remove` explicitly if needed.\n\n    If you do not want this behavior, use the `.Figure.add_subplot` method\n    or the `.pyplot.axes` function instead.\n\n    If no *kwargs* are passed and there exists an Axes in the location\n    specified by *args* then that Axes will be returned rather than a new\n    Axes being created.\n\n    If *kwargs* are passed and there exists an Axes in the location\n    specified by *args*, the projection type is the same, and the\n    *kwargs* match with the existing Axes, then the existing Axes is\n    returned.  Otherwise a new Axes is created with the specified\n    parameters.  We save a reference to the *kwargs* which we use\n    for this comparison.  If any of the values in *kwargs* are\n    mutable we will not detect the case where they are mutated.\n    In these cases we suggest using `.Figure.add_subplot` and the\n    explicit Axes API rather than the implicit pyplot API.\n\n    See Also\n    --------\n    .Figure.add_subplot\n    .pyplot.subplots\n    .pyplot.axes\n    .Figure.subplots\n\n    Examples\n    --------\n    ::\n\n        plt.subplot(221)\n\n        # equivalent but more general\n        ax1 = plt.subplot(2, 2, 1)\n\n        # add a subplot with no frame\n        ax2 = plt.subplot(222, frameon=False)\n\n        # add a polar subplot\n        plt.subplot(223, projection='polar')\n\n        # add a red subplot that shares the x-axis with ax1\n        plt.subplot(224, sharex=ax1, facecolor='red')\n\n        # delete ax2 from the figure\n        plt.delaxes(ax2)\n\n        # add ax2 to the figure again\n        plt.subplot(ax2)\n\n        # make the first Axes \"current\" again\n        plt.subplot(221)\n\n    \"\"\"\n    # Here we will only normalize `polar=True` vs `projection='polar'` and let\n    # downstream code deal with the rest.\n    unset = object()\n    projection = kwargs.get('projection', unset)\n    polar = kwargs.pop('polar', unset)\n    if polar is not unset and polar:\n        # if we got mixed messages from the user, raise\n        if projection is not unset and projection != 'polar':\n            raise ValueError(\n                f\"polar={polar}, yet projection={projection!r}. \"\n                \"Only one of these arguments should be supplied.\"\n            )\n        kwargs['projection'] = projection = 'polar'\n\n    # if subplot called without arguments, create subplot(1, 1, 1)\n    if len(args) == 0:\n        args = (1, 1, 1)\n\n    # This check was added because it is very easy to type subplot(1, 2, False)\n    # when subplots(1, 2, False) was intended (sharex=False, that is). In most\n    # cases, no error will ever occur, but mysterious behavior can result\n    # because what was intended to be the sharex argument is instead treated as\n    # a subplot index for subplot()\n    if len(args) >= 3 and isinstance(args[2], bool):\n        _api.warn_external(\"The subplot index argument to subplot() appears \"\n                           \"to be a boolean. Did you intend to use \"\n                           \"subplots()?\")\n    # Check for nrows and ncols, which are not valid subplot args:\n    if 'nrows' in kwargs or 'ncols' in kwargs:\n        raise TypeError(\"subplot() got an unexpected keyword argument 'ncols' \"\n                        \"and/or 'nrows'.  Did you intend to call subplots()?\")\n\n    fig = gcf()\n\n    # First, search for an existing subplot with a matching spec.\n    key = SubplotSpec._from_subplot_args(fig, args)\n\n    for ax in fig.axes:\n        # If we found an Axes at the position, we can reuse it if the user passed no\n        # kwargs or if the Axes class and kwargs are identical.\n        if (ax.get_subplotspec() == key\n            and (kwargs == {}\n                 or (ax._projection_init\n                     == fig._process_projection_requirements(**kwargs)))):\n            break\n    else:\n        # we have exhausted the known Axes and none match, make a new one!\n        ax = fig.add_subplot(*args, **kwargs)\n\n    fig.sca(ax)\n\n    return ax\n", "type": "function"}, {"name": "test_add_subplot_kwargs", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_subplot", "fig.add_subplot", "plt.close", "plt.figure", "fig.add_subplot", "fig.add_subplot", "plt.close", "plt.figure", "fig.add_subplot", "fig.add_subplot", "plt.close"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1558, "end_line": 1580}, "code_snippet": "def test_add_subplot_kwargs():\n    # fig.add_subplot() always creates new axes, even if axes kwargs differ.\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax1 = fig.add_subplot(1, 1, 1)\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1, projection='polar')\n    ax1 = fig.add_subplot(1, 1, 1, projection='polar')\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1, projection='polar')\n    ax1 = fig.add_subplot(1, 1, 1)\n    assert ax is not None\n    assert ax1.name == 'rectilinear'\n    assert ax1 is not ax\n    plt.close()\n", "type": "function"}, {"name": "axes", "is_method": false, "class_name": null, "parameters": ["arg"], "calls": ["gcf", "kwargs.pop", "fig.add_axes", "fig.add_subplot", "fig.add_axes"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1324, "end_line": 1410}, "code_snippet": "def axes(\n    arg: None | tuple[float, float, float, float] = None,\n    **kwargs\n) -> matplotlib.axes.Axes:\n    \"\"\"\n    Add an Axes to the current figure and make it the current Axes.\n\n    Call signatures::\n\n        plt.axes()\n        plt.axes(rect, projection=None, polar=False, **kwargs)\n        plt.axes(ax)\n\n    Parameters\n    ----------\n    arg : None or 4-tuple\n        The exact behavior of this function depends on the type:\n\n        - *None*: A new full window Axes is added using\n          ``subplot(**kwargs)``.\n        - 4-tuple of floats *rect* = ``(left, bottom, width, height)``.\n          A new Axes is added with dimensions *rect* in normalized\n          (0, 1) units using `~.Figure.add_axes` on the current figure.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n        The projection type of the `~.axes.Axes`. *str* is the name of\n        a custom projection, see `~matplotlib.projections`. The default\n        None results in a 'rectilinear' projection.\n\n    polar : bool, default: False\n        If True, equivalent to projection='polar'.\n\n    sharex, sharey : `~matplotlib.axes.Axes`, optional\n        Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n        The axis will have the same limits, ticks, and scale as the axis\n        of the shared Axes.\n\n    label : str\n        A label for the returned Axes.\n\n    Returns\n    -------\n    `~.axes.Axes`, or a subclass of `~.axes.Axes`\n        The returned Axes class depends on the projection used. It is\n        `~.axes.Axes` if rectilinear projection is used and\n        `.projections.polar.PolarAxes` if polar projection is used.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for\n        the returned Axes class. The keyword arguments for the\n        rectilinear Axes class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used, see the actual Axes\n        class.\n\n        %(Axes:kwdoc)s\n\n    See Also\n    --------\n    .Figure.add_axes\n    .pyplot.subplot\n    .Figure.add_subplot\n    .Figure.subplots\n    .pyplot.subplots\n\n    Examples\n    --------\n    ::\n\n        # Creating a new full window Axes\n        plt.axes()\n\n        # Creating a new Axes with specified dimensions and a grey background\n        plt.axes((left, bottom, width, height), facecolor='grey')\n    \"\"\"\n    fig = gcf()\n    pos = kwargs.pop('position', None)\n    if arg is None:\n        if pos is None:\n            return fig.add_subplot(**kwargs)\n        else:\n            return fig.add_axes(pos, **kwargs)\n    else:\n        return fig.add_axes(arg, **kwargs)\n", "type": "function"}, {"name": "test_axes_kwargs", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "plt.axes", "plt.axes", "plt.close", "plt.figure", "plt.axes", "plt.axes", "plt.close", "plt.figure", "plt.axes", "plt.axes", "plt.close"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 182, "end_line": 204}, "code_snippet": "def test_axes_kwargs():\n    # plt.axes() always creates new axes, even if axes kwargs differ.\n    plt.figure()\n    ax = plt.axes()\n    ax1 = plt.axes()\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    plt.figure()\n    ax = plt.axes(projection='polar')\n    ax1 = plt.axes(projection='polar')\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    plt.figure()\n    ax = plt.axes(projection='polar')\n    ax1 = plt.axes()\n    assert ax is not None\n    assert ax1.name == 'rectilinear'\n    assert ax1 is not ax\n    plt.close()\n", "type": "function"}, {"name": "test_subplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "Subplot", "fig.add_subplot"], "code_location": {"file": "test_floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist/tests", "start_line": 16, "end_line": 19}, "code_snippet": "def test_subplot():\n    fig = plt.figure(figsize=(5, 5))\n    ax = Subplot(fig, 111)\n    fig.add_subplot(ax)\n", "type": "function"}, {"name": "test_old_subplot_compat", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "isinstance", "fig.add_subplot", "isinstance", "pytest.raises", "Axes", "fig.add_axes"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 288, "end_line": 293}, "code_snippet": "def test_old_subplot_compat():\n    fig = plt.figure()\n    assert isinstance(fig.add_subplot(), SubplotBase)\n    assert not isinstance(fig.add_axes(rect=[0, 0, 1, 1]), SubplotBase)\n    with pytest.raises(TypeError):\n        Axes(fig, [0, 0, 1, 1], rect=[0, 0, 1, 1])\n", "type": "function"}, {"name": "add_subplot", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["self._add_axes_internal", "_api.kwarg_error", "isinstance", "get_subplotspec", "self._process_projection_requirements", "projection_class", "len", "ax.get_figure", "ValueError", "isinstance", "tuple", "len", "map", "str"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 645, "end_line": 770}, "code_snippet": "    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n\n        Call signatures::\n\n           add_subplot(nrows, ncols, index, **kwargs)\n           add_subplot(pos, **kwargs)\n           add_subplot(ax)\n           add_subplot()\n\n        Parameters\n        ----------\n        *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n            The position of the subplot described by one of\n\n            - Three integers (*nrows*, *ncols*, *index*). The subplot will\n              take the *index* position on a grid with *nrows* rows and\n              *ncols* columns. *index* starts at 1 in the upper left corner\n              and increases to the right.  *index* can also be a two-tuple\n              specifying the (*first*, *last*) indices (1-based, and including\n              *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``\n              makes a subplot that spans the upper 2/3 of the figure.\n            - A 3-digit integer. The digits are interpreted as if given\n              separately as three single-digit integers, i.e.\n              ``fig.add_subplot(235)`` is the same as\n              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n              if there are no more than 9 subplots.\n            - A `.SubplotSpec`.\n\n            In rare circumstances, `.add_subplot` may be called with a single\n            argument, a subplot Axes instance already created in the\n            present figure but not in the figure's list of Axes.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the subplot (`~.axes.Axes`). *str* is the\n            name of a custom projection, see `~matplotlib.projections`. The\n            default None results in a 'rectilinear' projection.\n\n        polar : bool, default: False\n            If True, equivalent to projection='polar'.\n\n        axes_class : subclass type of `~.axes.Axes`, optional\n            The `.axes.Axes` subclass that is instantiated.  This parameter\n            is incompatible with *projection* and *polar*.  See\n            :ref:`axisartist_users-guide-index` for examples.\n\n        sharex, sharey : `~matplotlib.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared Axes.\n\n        label : str\n            A label for the returned Axes.\n\n        Returns\n        -------\n        `~.axes.Axes`\n\n            The Axes of the subplot. The returned Axes can actually be an\n            instance of a subclass, such as `.projections.polar.PolarAxes` for\n            polar projections.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for the returned Axes\n            base class; except for the *figure* argument. The keyword arguments\n            for the rectilinear base class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used.\n\n            %(Axes:kwdoc)s\n\n        See Also\n        --------\n        .Figure.add_axes\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        ::\n\n            fig = plt.figure()\n\n            fig.add_subplot(231)\n            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general\n\n            fig.add_subplot(232, frameon=False)  # subplot with no frame\n            fig.add_subplot(233, projection='polar')  # polar subplot\n            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1\n            fig.add_subplot(235, facecolor=\"red\")  # red subplot\n\n            ax1.remove()  # delete ax1 from the figure\n            fig.add_subplot(ax1)  # add ax1 back to the figure\n        \"\"\"\n        if 'figure' in kwargs:\n            # Axes itself allows for a 'figure' kwarg, but since we want to\n            # bind the created Axes to self, it is not allowed here.\n            raise _api.kwarg_error(\"add_subplot\", \"figure\")\n\n        if (len(args) == 1\n                and isinstance(args[0], mpl.axes._base._AxesBase)\n                and args[0].get_subplotspec()):\n            ax = args[0]\n            key = ax._projection_init\n            if ax.get_figure(root=False) is not self:\n                raise ValueError(\"The Axes must have been created in \"\n                                 \"the present figure\")\n        else:\n            if not args:\n                args = (1, 1, 1)\n            # Normalize correct ijk values to (i, j, k) here so that\n            # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will\n            # trigger errors later (via SubplotSpec._from_subplot_args).\n            if (len(args) == 1 and isinstance(args[0], Integral)\n                    and 100 <= args[0] <= 999):\n                args = tuple(map(int, str(args[0])))\n            projection_class, pkw = self._process_projection_requirements(**kwargs)\n            ax = projection_class(self, *args, **pkw)\n            key = (projection_class, pkw)\n        return self._add_axes_internal(ax, key)\n", "type": "function"}, {"name": "test_Subplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "Subplot", "fig.add_subplot", "np.arange", "ax.plot", "ax.set_ylabel", "major_ticks.set_tick_out", "major_ticks.set_tick_out", "set_label", "np.sin"], "code_location": {"file": "test_axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist/tests", "start_line": 32, "end_line": 48}, "code_snippet": "def test_Subplot():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['text.kerning_factor'] = 6\n\n    fig = plt.figure()\n\n    ax = Subplot(fig, 1, 1, 1)\n    fig.add_subplot(ax)\n\n    xx = np.arange(0, 2 * np.pi, 0.01)\n    ax.plot(xx, np.sin(xx))\n    ax.set_ylabel(\"Test\")\n\n    ax.axis[\"top\"].major_ticks.set_tick_out(True)\n    ax.axis[\"bottom\"].major_ticks.set_tick_out(True)\n\n    ax.axis[\"bottom\"].set_label(\"Tk0\")\n", "type": "function"}, {"name": "test_add_axes_kwargs", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_axes", "fig.add_axes", "plt.close", "plt.figure", "fig.add_axes", "fig.add_axes", "plt.close", "plt.figure", "fig.add_axes", "fig.add_axes", "plt.close"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1583, "end_line": 1605}, "code_snippet": "def test_add_axes_kwargs():\n    # fig.add_axes() always creates new axes, even if axes kwargs differ.\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax1 = fig.add_axes((0, 0, 1, 1))\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1), projection='polar')\n    ax1 = fig.add_axes((0, 0, 1, 1), projection='polar')\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1), projection='polar')\n    ax1 = fig.add_axes((0, 0, 1, 1))\n    assert ax is not None\n    assert ax1.name == 'rectilinear'\n    assert ax1 is not ax\n    plt.close()\n", "type": "function"}, {"name": "test_Axes", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "Axes", "fig.add_axes", "ax.plot", "ax.set_xscale", "fig.canvas.draw"], "code_location": {"file": "test_axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist/tests", "start_line": 51, "end_line": 57}, "code_snippet": "def test_Axes():\n    fig = plt.figure()\n    ax = Axes(fig, [0.15, 0.1, 0.65, 0.8])\n    fig.add_axes(ax)\n    ax.plot([1, 2, 3], [0, 1, 2])\n    ax.set_xscale('log')\n    fig.canvas.draw()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.090545415878296}
{"question": "Why does Matplotlib implement an event-driven system for interactive plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements an event-driven system for interactive plotting to enable responsive user interactions and support real-time data exploration. The event-driven architecture serves several key purposes: 1) It provides a GUI-neutral interface that works across different GUI toolkits (Qt, Tk, GTK, Wx, macOS) while maintaining consistent behavior, 2) The system converts low-level GUI events (mouse clicks, key presses) into Matplotlib-specific events with data coordinates, enabling precise interaction with plot elements, 3) It supports built-in interactive features like panning, zooming, and data point selection that enhance data exploration capabilities, 4) The event system allows users to create custom interactive behaviors by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), 5) It enables responsive figure updates during long-running computations by periodically processing events through flush_events(), 6) The event-driven approach supports integration with command-line interfaces through input hook mechanisms, allowing both interactive plotting and command-line usage, 7) It provides a foundation for advanced interactive features like picking, selection, and custom data exploration tools. This design enables Matplotlib to support both static plotting and dynamic, interactive visualizations that respond to user input in real-time.", "score": null, "retrieved_content": [{"name": "Event", "docstring": "A Matplotlib event.\n\nThe following attributes are defined and shown with their default values.\nSubclasses may define additional attributes.\n\nAttributes\n----------\nname : str\n    The event name.\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance generating the event.\nguiEvent\n    The GUI event that triggered the Matplotlib event.", "methods": ["__init__", "_process"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1170, "end_line": 1195}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "AxesWidget", "parameters": ["self", "ax"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 116, "end_line": 118}, "code_snippet": "    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "_contour_labeler_event_handler", "is_method": false, "class_name": null, "parameters": ["cs", "inline", "inline_spacing", "event"], "calls": ["cs.axes.get_figure", "canvas.stop_event_loop", "cs.pop_label", "canvas.draw", "cs.axes.contains", "cs.add_label_near", "canvas.draw"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 30, "end_line": 56}, "code_snippet": "def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n    canvas = cs.axes.get_figure(root=True).canvas\n    is_button = event.name == \"button_press_event\"\n    is_key = event.name == \"key_press_event\"\n    # Quit (even if not in infinite mode; this is consistent with\n    # MATLAB and sometimes quite useful, but will require the user to\n    # test how many points were actually returned before using data).\n    if (is_button and event.button == MouseButton.MIDDLE\n            or is_key and event.key in [\"escape\", \"enter\"]):\n        canvas.stop_event_loop()\n    # Pop last click.\n    elif (is_button and event.button == MouseButton.RIGHT\n          or is_key and event.key in [\"backspace\", \"delete\"]):\n        # Unfortunately, if one is doing inline labels, then there is currently\n        # no way to fix the broken contour - once humpty-dumpty is broken, he\n        # can't be put back together.  In inline mode, this does nothing.\n        if not inline:\n            cs.pop_label()\n            canvas.draw()\n    # Add new click.\n    elif (is_button and event.button == MouseButton.LEFT\n          # On macOS/gtk, some keys return None.\n          or is_key and event.key is not None):\n        if cs.axes.contains(event)[0]:\n            cs.add_label_near(event.x, event.y, transform=False,\n                              inline=inline, inline_spacing=inline_spacing)\n            canvas.draw()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "EventHandler", "parameters": ["self"], "calls": ["fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect"], "code_location": {"file": "looking_glass.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 37, "end_line": 42}, "code_snippet": "    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n", "type": "function"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasTk", "parameters": ["self", "figure", "master"], "calls": ["__init__", "self.get_width_height", "tk.Canvas", "tk.PhotoImage", "self._tkcanvas.create_image", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.winfo_toplevel", "weakref.ref", "weakref.ref", "root.bind", "root.bind", "self._tkcanvas.focus_set", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "self._tkcanvas.bind", "weakself", "self.scroll_event_windows", "weakself", "super", "weakroot", "weakroot", "_process", "root.unbind", "root.unbind", "CloseEvent"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 166, "end_line": 233}, "code_snippet": "    def __init__(self, figure=None, master=None):\n        super().__init__(figure)\n        self._idle_draw_id = None\n        self._event_loop_id = None\n        w, h = self.get_width_height(physical=True)\n        self._tkcanvas = tk.Canvas(\n            master=master, background=\"white\",\n            width=w, height=h, borderwidth=0, highlightthickness=0)\n        self._tkphoto = tk.PhotoImage(\n            master=self._tkcanvas, width=w, height=h)\n        self._tkcanvas_image_region = self._tkcanvas.create_image(\n            w//2, h//2, image=self._tkphoto)\n        self._tkcanvas.bind(\"<Configure>\", self.resize)\n        self._tkcanvas.bind(\"<Map>\", self._update_device_pixel_ratio)\n        self._tkcanvas.bind(\"<Key>\", self.key_press)\n        self._tkcanvas.bind(\"<Motion>\", self.motion_notify_event)\n        self._tkcanvas.bind(\"<Enter>\", self.enter_notify_event)\n        self._tkcanvas.bind(\"<Leave>\", self.leave_notify_event)\n        self._tkcanvas.bind(\"<KeyRelease>\", self.key_release)\n        for name in [\"<Button-1>\", \"<Button-2>\", \"<Button-3>\"]:\n            self._tkcanvas.bind(name, self.button_press_event)\n        for name in [\n                \"<Double-Button-1>\", \"<Double-Button-2>\", \"<Double-Button-3>\"]:\n            self._tkcanvas.bind(name, self.button_dblclick_event)\n        for name in [\n                \"<ButtonRelease-1>\", \"<ButtonRelease-2>\", \"<ButtonRelease-3>\"]:\n            self._tkcanvas.bind(name, self.button_release_event)\n\n        # Mouse wheel on Linux generates button 4/5 events\n        for name in \"<Button-4>\", \"<Button-5>\":\n            self._tkcanvas.bind(name, self.scroll_event)\n        # Mouse wheel for windows goes to the window with the focus.\n        # Since the canvas won't usually have the focus, bind the\n        # event to the window containing the canvas instead.\n        # See https://wiki.tcl-lang.org/3893 (mousewheel) for details\n        root = self._tkcanvas.winfo_toplevel()\n\n        # Prevent long-lived references via tkinter callback structure GH-24820\n        weakself = weakref.ref(self)\n        weakroot = weakref.ref(root)\n\n        def scroll_event_windows(event):\n            self = weakself()\n            if self is None:\n                root = weakroot()\n                if root is not None:\n                    root.unbind(\"<MouseWheel>\", scroll_event_windows_id)\n                return\n            return self.scroll_event_windows(event)\n        scroll_event_windows_id = root.bind(\"<MouseWheel>\", scroll_event_windows, \"+\")\n\n        # Can't get destroy events by binding to _tkcanvas. Therefore, bind\n        # to the window and filter.\n        def filter_destroy(event):\n            self = weakself()\n            if self is None:\n                root = weakroot()\n                if root is not None:\n                    root.unbind(\"<Destroy>\", filter_destroy_id)\n                return\n            if event.widget is self._tkcanvas:\n                CloseEvent(\"close_event\", self)._process()\n        filter_destroy_id = root.bind(\"<Destroy>\", filter_destroy, \"+\")\n\n        self._tkcanvas.focus_set()\n\n        self._rubberband_rect_black = None\n        self._rubberband_rect_white = None\n", "type": "function"}, {"name": "on_click", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "plt.disconnect"], "code_location": {"file": "coords_demo.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 35, "end_line": 38}, "code_snippet": "def on_click(event):\n    if event.button is MouseButton.LEFT:\n        print('disconnecting callback')\n        plt.disconnect(binding_id)\n", "type": "function"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureManagerBase", "parameters": ["self", "canvas", "num"], "calls": ["self.set_window_title", "self.canvas.mpl_connect", "self.canvas.mpl_connect", "ToolManager", "self._toolbar2_class", "tools.add_tools_to_manager", "self._toolmanager_toolbar_class", "tools.add_tools_to_container", "self.toolbar.update"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2648, "end_line": 2683}, "code_snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n        self.set_window_title(f\"Figure {num:d}\")\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event', key_press_handler)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event', button_press_handler)\n\n        self.toolmanager = (ToolManager(canvas.figure)\n                            if mpl.rcParams['toolbar'] == 'toolmanager'\n                            else None)\n        if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n                and self._toolbar2_class):\n            self.toolbar = self._toolbar2_class(self.canvas)\n        elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n                and self._toolmanager_toolbar_class):\n            self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n        else:\n            self.toolbar = None\n\n        if self.toolmanager:\n            tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                tools.add_tools_to_container(self.toolbar)\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current Axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0722341537475586}
{"question": "What is the relationship between Matplotlib's event system and the interactive plotting features?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event system is the foundation that enables all interactive plotting features. The relationship works as follows: 1) The event system provides the infrastructure for capturing user interactions (mouse clicks, key presses, mouse movements) and converting them into Matplotlib-specific events with data coordinates, 2) Interactive features like panning, zooming, and data point selection are built on top of the event system by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), 3) The event system enables the NavigationToolbar2 class to provide built-in interactive tools by responding to mouse and keyboard events, 4) Custom interactive behaviors can be implemented by connecting user-defined callback functions to events, allowing for personalized data exploration tools, 5) The event system supports object picking, which allows interactive features to determine which Artist was clicked and respond accordingly, 6) Interactive features rely on the event system's coordinate transformation capabilities to convert between pixel coordinates and data coordinates, enabling precise interaction with plot elements, 7) The event system provides the GUI-neutral interface that allows the same interactive code to work across different GUI toolkits (Qt, Tk, GTK, Wx, macOS), 8) Interactive features use the event system's stale state mechanism to trigger redraws when plot elements are modified through user interaction, 9) The event system enables responsive figure updates during long-running computations by periodically processing events through flush_events(), maintaining interactivity even during intensive calculations. Without the event system, Matplotlib would only support static plotting; the event system is what transforms it into an interactive visualization tool.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "AxesWidget", "parameters": ["self", "ax"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 116, "end_line": 118}, "code_snippet": "    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "EventHandler", "parameters": ["self"], "calls": ["fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect"], "code_location": {"file": "looking_glass.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 37, "end_line": 42}, "code_snippet": "    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n", "type": "function"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "ToolManager", "docstring": "Manager for actions triggered by user interactions (key press, toolbar\nclicks, ...) on a Figure.\n\nAttributes\n----------\nfigure : `.Figure`\nkeypresslock : `~matplotlib.widgets.LockDraw`\n    `.LockDraw` object to know if the `canvas` key_press_event is locked.\nmessagelock : `~matplotlib.widgets.LockDraw`\n    `.LockDraw` object to know if the message is available to write.", "methods": ["__init__", "canvas", "figure", "figure", "set_figure", "toolmanager_connect", "toolmanager_disconnect", "message_event", "active_toggle", "get_tool_keymap", "_remove_keys", "update_keymap", "remove_tool", "add_tool", "_handle_toggle", "trigger_tool", "_key_press", "tools", "get_tool"], "attributes": [], "code_location": {"file": "backend_managers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 32, "end_line": 387}, "type": "class"}, {"name": "_click", "is_method": true, "class_name": "Button", "parameters": ["self", "event"], "calls": ["self.ignore", "event.canvas.grab_mouse", "self.ax.contains"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 218, "end_line": 222}, "code_snippet": "    def _click(self, event):\n        if not self.eventson or self.ignore(event) or not self.ax.contains(event)[0]:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n", "type": "function"}, {"name": "LocationEvent", "docstring": "An event that has a screen location.\n\nA LocationEvent has a number of special attributes in addition to those\ndefined by the parent `Event` class.\n\nAttributes\n----------\nx, y : int or None\n    Event location in pixels from bottom left of canvas.\ninaxes : `~matplotlib.axes.Axes` or None\n    The `~.axes.Axes` instance over which the mouse is, if any.\nxdata, ydata : float or None\n    Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n    is not over an Axes.\nmodifiers : frozenset\n    The keyboard modifiers currently being pressed (except for KeyEvent).", "methods": ["__init__", "_set_inaxes"], "attributes": ["_last_axes_ref"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1249, "end_line": 1304}, "type": "class"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolSetCursor", "parameters": ["self"], "calls": ["__init__", "self.toolmanager.toolmanager_connect", "self.toolmanager.tools.values", "self._add_tool_cbk", "super", "mpl.backend_managers.ToolEvent"], "code_location": {"file": "backend_tools.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 256, "end_line": 266}, "code_snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._id_drag = None\n        self._current_tool = None\n        self._default_cursor = cursors.POINTER\n        self._last_cursor = self._default_cursor\n        self.toolmanager.toolmanager_connect('tool_added_event',\n                                             self._add_tool_cbk)\n        for tool in self.toolmanager.tools.values():  # process current tools\n            self._add_tool_cbk(mpl.backend_managers.ToolEvent(\n                'tool_added_event', self.toolmanager, tool))\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureManagerBase", "parameters": ["self", "canvas", "num"], "calls": ["self.set_window_title", "self.canvas.mpl_connect", "self.canvas.mpl_connect", "ToolManager", "self._toolbar2_class", "tools.add_tools_to_manager", "self._toolmanager_toolbar_class", "tools.add_tools_to_container", "self.toolbar.update"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2648, "end_line": 2683}, "code_snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n        self.set_window_title(f\"Figure {num:d}\")\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event', key_press_handler)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event', button_press_handler)\n\n        self.toolmanager = (ToolManager(canvas.figure)\n                            if mpl.rcParams['toolbar'] == 'toolmanager'\n                            else None)\n        if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n                and self._toolbar2_class):\n            self.toolbar = self._toolbar2_class(self.canvas)\n        elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n                and self._toolmanager_toolbar_class):\n            self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n        else:\n            self.toolbar = None\n\n        if self.toolmanager:\n            tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                tools.add_tools_to_container(self.toolbar)\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current Axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0841271877288818}
{"question": "What dependencies exist between Matplotlib's pyplot interface and the object-oriented API?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's pyplot interface is built on top of the object-oriented API and has several key dependencies: 1) The pyplot module maintains global state (current Figure and Axes) and provides convenience functions that internally create and manipulate Figure and Axes objects, 2) Most pyplot functions are wrappers around Axes methods - for example, plt.plot() calls ax.plot() on the current Axes, 3) Pyplot functions like plt.figure(), plt.subplots(), and plt.subplot() create Figure and Axes objects and manage them in the global state, 4) The pyplot interface depends on the object-oriented API for all actual plotting operations, coordinate transformations, and rendering, 5) Pyplot provides MATLAB-like convenience but ultimately delegates to the explicit object-oriented interface for implementation, 6) Functions like plt.gcf() and plt.gca() return references to the current Figure and Axes objects from the object-oriented API, 7) The pyplot interface is primarily intended for interactive use and simple scripts, while complex customization requires direct use of the object-oriented API. This dependency structure allows pyplot to provide a simpler interface while leveraging the full power and flexibility of the underlying object-oriented system.", "score": null, "retrieved_content": [{"name": "test_figure_label", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.close", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.close", "plt.close", "plt.close", "plt.close", "plt.figure", "plt.get_fignums", "plt.get_figlabels", "plt.get_fignums", "plt.get_figlabels", "plt.gcf", "pytest.raises", "plt.figure", "Figure"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 130, "end_line": 151}, "code_snippet": "def test_figure_label():\n    # pyplot figure creation, selection, and closing with label/number/instance\n    plt.close('all')\n    fig_today = plt.figure('today')\n    plt.figure(3)\n    plt.figure('tomorrow')\n    plt.figure()\n    plt.figure(0)\n    plt.figure(1)\n    plt.figure(3)\n    assert plt.get_fignums() == [0, 1, 3, 4, 5]\n    assert plt.get_figlabels() == ['', 'today', '', 'tomorrow', '']\n    plt.close(10)\n    plt.close()\n    plt.close(5)\n    plt.close('tomorrow')\n    assert plt.get_fignums() == [0, 1]\n    assert plt.get_figlabels() == ['', 'today']\n    plt.figure(fig_today)\n    assert plt.gcf() == fig_today\n    with pytest.raises(ValueError):\n        plt.figure(Figure())\n", "type": "function"}, {"name": "test_pyplot_axes", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.subplots", "plt.sca", "plt.close", "plt.close", "plt.gca", "plt.gcf"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3283, "end_line": 3291}, "code_snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "test_pyplot_up_to_date", "is_method": false, "class_name": null, "parameters": ["tmp_path"], "calls": ["pytest.importorskip", "read_text", "plt_file.write_text", "subprocess_run_for_testing", "plt_file.read_text", "gen_script.exists", "pytest.skip", "join", "pytest.fail", "Path", "str", "str", "difflib.unified_diff", "Path", "orig_contents.split", "new_contents.split"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 43}, "code_snippet": "def test_pyplot_up_to_date(tmp_path):\n    pytest.importorskip(\"black\")\n\n    gen_script = Path(mpl.__file__).parents[2] / \"tools/boilerplate.py\"\n    if not gen_script.exists():\n        pytest.skip(\"boilerplate.py not found\")\n    orig_contents = Path(plt.__file__).read_text()\n    plt_file = tmp_path / 'pyplot.py'\n    plt_file.write_text(orig_contents, 'utf-8')\n\n    subprocess_run_for_testing(\n        [sys.executable, str(gen_script), str(plt_file)],\n        check=True)\n    new_contents = plt_file.read_text('utf-8')\n\n    if orig_contents != new_contents:\n        diff_msg = '\\n'.join(\n            difflib.unified_diff(\n                orig_contents.split('\\n'), new_contents.split('\\n'),\n                fromfile='found pyplot.py',\n                tofile='expected pyplot.py',\n                n=0, lineterm=''))\n        pytest.fail(\n            \"pyplot.py is not up-to-date. Please run \"\n            \"'python tools/boilerplate.py' to update pyplot.py. \"\n            \"This needs to be done from an environment where your \"\n            \"current working copy is installed (e.g. 'pip install -e'd). \"\n            \"Here is a diff of unexpected differences:\\n%s\" % diff_msg\n        )\n", "type": "function"}, {"name": "test_never_update", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.flaky", "_isolated_tk_test", "plt.figure", "plt.show", "plt.draw", "fig.canvas.toolbar.configure_subplots", "after", "plt.show", "fig.canvas.toolbar.configure_subplots", "fig.canvas.get_tk_widget"], "code_location": {"file": "test_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 161, "end_line": 179}, "code_snippet": "def test_never_update():\n    import tkinter\n    del tkinter.Misc.update\n    del tkinter.Misc.update_idletasks\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    plt.show(block=False)\n\n    plt.draw()  # Test FigureCanvasTkAgg.\n    tool = fig.canvas.toolbar.configure_subplots()  # Test NavigationToolbar2Tk.\n    assert tool is not None\n    assert tool == fig.canvas.toolbar.configure_subplots()  # Tool is reused internally.\n    # Test FigureCanvasTk filter_destroy callback\n    fig.canvas.get_tk_widget().after(100, plt.close, fig)\n\n    # Check for update() or update_idletasks() in the event queue, functionally\n    # equivalent to tkinter.Misc.update.\n    plt.show(block=True)\n", "type": "function"}, {"name": "test_get_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "sfig1.subfigures", "sfig2.subplots", "mlines.Line2D", "fig.get_figure", "fig.get_figure", "ax.get_figure", "ax.get_figure", "ax.get_figure", "sfig2.get_figure", "sfig2.get_figure", "pytest.warns", "sfig1.get_figure", "ln.get_figure", "ln.get_figure", "sfig2.get_figure"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 598}, "code_snippet": "def test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n", "type": "function"}, {"name": "test_no_pyplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["mfigure.Figure", "FigureCanvasPdf", "fig.add_subplot", "ax.plot", "pickle.dump", "BytesIO"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 185, "end_line": 192}, "code_snippet": "def test_no_pyplot():\n    # tests pickle-ability of a figure not created with pyplot\n    from matplotlib.backends.backend_pdf import FigureCanvasPdf\n    fig = mfigure.Figure()\n    _ = FigureCanvasPdf(fig)\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1, 2, 3], [1, 2, 3])\n    pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n", "type": "function"}, {"name": "_implcore", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 376, "end_line": 382}, "code_snippet": "def _implcore():\n    import matplotlib.backends.backend_qt5  # noqa\n    import sys\n\n    assert 'PyQt6' not in sys.modules\n    assert 'pyside6' not in sys.modules\n    assert 'PyQt5' in sys.modules or 'pyside2' in sys.modules\n", "type": "function"}, {"name": "test_old_subplot_compat", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "isinstance", "fig.add_subplot", "isinstance", "pytest.raises", "Axes", "fig.add_axes"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 288, "end_line": 293}, "code_snippet": "def test_old_subplot_compat():\n    fig = plt.figure()\n    assert isinstance(fig.add_subplot(), SubplotBase)\n    assert not isinstance(fig.add_axes(rect=[0, 0, 1, 1]), SubplotBase)\n    with pytest.raises(TypeError):\n        Axes(fig, [0, 0, 1, 1], rect=[0, 0, 1, 1])\n", "type": "function"}, {"name": "test_pyplot_box", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.box", "plt.box", "ax.get_frame_on", "plt.box", "plt.box", "ax.get_frame_on", "ax.get_frame_on", "ax.get_frame_on"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 67, "end_line": 76}, "code_snippet": "def test_pyplot_box():\n    fig, ax = plt.subplots()\n    plt.box(False)\n    assert not ax.get_frame_on()\n    plt.box(True)\n    assert ax.get_frame_on()\n    plt.box()\n    assert not ax.get_frame_on()\n    plt.box()\n    assert ax.get_frame_on()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0827617645263672}
{"question": "What is the precise definition of Matplotlib's \"Figure\" concept and its relationship to the overall plotting canvas?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Figure is the top-level Artist container that holds all plot elements and serves as the root of the plotting hierarchy. It is defined as the complete graphical output that contains one or more Axes, along with figure-level elements like titles, legends, and colorbars. The Figure has a direct relationship with the FigureCanvas through the canvas attribute - the Figure is rendered onto the FigureCanvas, which is the backend-specific drawing area that handles the actual output to screen or file. The Figure manages its size (figsize), resolution (dpi), background (facecolor), and layout of its child elements. It also maintains lists of all its contained Artists (axes, lines, patches, texts, images, legends) and provides methods for adding, removing, and managing these elements. The Figure acts as the bridge between the high-level plotting API and the low-level rendering system, coordinating the drawing of all its contained elements onto the canvas.", "score": null, "retrieved_content": [{"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "figure", "is_method": true, "class_name": "ToolManager", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_managers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 70, "end_line": 72}, "code_snippet": "    def figure(self):\n        \"\"\"Figure that holds the canvas.\"\"\"\n        return self._figure\n", "type": "function"}, {"name": "SubFigure", "docstring": "Logical figure that can be placed inside a figure.\n\nSee :ref:`figure-api-subfigure` for an index of methods on this class.\nTypically instantiated using `.Figure.add_subfigure` or\n`.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has\nthe same methods as a figure except for those particularly tied to the size\nor dpi of the figure, and is confined to a prescribed region of the figure.\nFor example the following puts two subfigures side-by-side::\n\n    fig = plt.figure()\n    sfigs = fig.subfigures(1, 2)\n    axsL = sfigs[0].subplots(1, 2)\n    axsR = sfigs[1].subplots(2, 1)\n\nSee :doc:`/gallery/subplots_axes_and_figures/subfigures`", "methods": ["__init__", "canvas", "dpi", "dpi", "get_dpi", "set_dpi", "_get_renderer", "_redo_transform_rel_fig", "get_constrained_layout", "get_constrained_layout_pads", "get_layout_engine", "axes", "draw"], "attributes": ["get_axes"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2216, "end_line": 2420}, "type": "class"}, {"name": "Gcf", "docstring": "Singleton to maintain the relation between figures and their managers, and\nkeep track of and \"active\" figure and manager.\n\nThe canvas of a figure created through pyplot is associated with a figure\nmanager, which handles the interaction between the figure and the backend.\npyplot keeps track of figure managers using an identifier, the \"figure\nnumber\" or \"manager number\" (which can actually be any hashable value);\nthis number is available as the :attr:`number` attribute of the manager.\n\nThis class is never instantiated; it consists of an `OrderedDict` mapping\nfigure/manager numbers to managers, and a set of class methods that\nmanipulate this `OrderedDict`.\n\nAttributes\n----------\nfigs : OrderedDict\n    `OrderedDict` mapping numbers to managers; the active manager is at the\n    end.", "methods": ["get_fig_manager", "destroy", "destroy_fig", "destroy_all", "has_fignum", "get_all_fig_managers", "get_num_fig_managers", "get_active", "_set_new_active_manager", "set_active", "draw_all"], "attributes": ["figs"], "code_location": {"file": "_pylab_helpers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 9, "end_line": 131}, "type": "class"}, {"name": "test_canvas_ctor", "is_method": false, "class_name": null, "parameters": [], "calls": ["isinstance", "FigureCanvasBase"], "code_location": {"file": "test_backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 62, "end_line": 63}, "code_snippet": "def test_canvas_ctor():\n    assert isinstance(FigureCanvasBase().figure, Figure)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["__init__", "self.set", "cbook.Grouper", "cbook.Grouper", "cbook.Grouper", "super"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 123, "end_line": 154}, "code_snippet": "    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n        self.set(**kwargs)\n", "type": "function"}, {"name": "test_get_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "sfig1.subfigures", "sfig2.subplots", "mlines.Line2D", "fig.get_figure", "fig.get_figure", "ax.get_figure", "ax.get_figure", "ax.get_figure", "sfig2.get_figure", "sfig2.get_figure", "pytest.warns", "sfig1.get_figure", "ln.get_figure", "ln.get_figure", "sfig2.get_figure"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 598}, "code_snippet": "def test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n", "type": "function"}, {"name": "FigureManagerBase", "docstring": "A backend-independent abstraction of a figure container and controller.\n\nThe figure manager is used by pyplot to interact with the window in a\nbackend-independent way. It's an adapter for the real (GUI) framework that\nrepresents the visual figure on screen.\n\nThe figure manager is connected to a specific canvas instance, which in turn\nis connected to a specific figure instance. To access a figure manager for\na given figure in user code, you typically use ``fig.canvas.manager``.\n\nGUI backends derive from this class to translate common operations such\nas *show* or *resize* to the GUI-specific code. Non-GUI backends do not\nsupport these operations and can just use the base class.\n\nThis following basic operations are accessible:\n\n**Window operations**\n\n- `~.FigureManagerBase.show`\n- `~.FigureManagerBase.destroy`\n- `~.FigureManagerBase.full_screen_toggle`\n- `~.FigureManagerBase.resize`\n- `~.FigureManagerBase.get_window_title`\n- `~.FigureManagerBase.set_window_title`\n\n**Key and mouse button press handling**\n\nThe figure manager sets up default key and mouse button press handling by\nhooking up the `.key_press_handler` to the matplotlib event system. This\nensures the same shortcuts and mouse actions across backends.\n\n**Other operations**\n\nSubclasses will have additional attributes and functions to access\nadditional functionality. This is of course backend-specific. For example,\nmost GUI backends have ``window`` and ``toolbar`` attributes that give\naccess to the native GUI widgets of the respective framework.\n\nAttributes\n----------\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance.\n\nnum : int or str\n    The figure number.\n\nkey_press_handler_id : int\n    The default key handler cid, when using the toolmanager.\n    To disable the default key press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.key_press_handler_id)\n\nbutton_press_handler_id : int\n    The default mouse button handler cid, when using the toolmanager.\n    To disable the default button press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.button_press_handler_id)", "methods": ["__init__", "create_with_canvas", "start_main_loop", "pyplot_show", "show", "destroy", "full_screen_toggle", "resize", "get_window_title", "set_window_title"], "attributes": ["_toolbar2_class", "_toolmanager_toolbar_class"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2582, "end_line": 2787}, "type": "class"}, {"name": "FigureManagerTk", "docstring": "Attributes\n----------\ncanvas : `FigureCanvas`\n    The FigureCanvas instance\nnum : int or str\n    The Figure number\ntoolbar : tk.Toolbar\n    The tk.Toolbar\nwindow : tk.Window\n    The tk.Window", "methods": ["__init__", "create_with_canvas", "start_main_loop", "_update_window_dpi", "resize", "show", "destroy", "get_window_title", "set_window_title", "full_screen_toggle"], "attributes": ["_owns_mainloop"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 463, "end_line": 618}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1153595447540283}
{"question": "Why does Matplotlib implement an Artist hierarchy for flexible plotting components?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements an Artist hierarchy for flexible plotting components to provide a structured and extensible architecture for managing complex visualizations. The hierarchy serves several key purposes: 1) It provides a natural parent-child relationship where Figure contains Axes, which contain individual Artists, enabling logical organization and efficient rendering through the hierarchy, 2) The hierarchy supports different types of Artists - primitives (Line2D, Rectangle, Text) that represent actual visual elements and containers (Figure, Axes, Axis) that organize and manage other Artists, 3) It enables efficient rendering by allowing parent containers to manage their children and coordinate drawing operations, 4) The hierarchy supports automatic layout and positioning where parent containers can arrange their child Artists according to layout algorithms, 5) It provides a consistent API where all Artists share common properties and methods through inheritance from the base Artist class, 6) The hierarchy enables advanced features like coordinate transformations, clipping, and event handling that can be applied at different levels, 7) It supports flexible composition where complex plots can be built by combining simple Artists in a hierarchical structure. This design enables Matplotlib to support both simple plots and complex, multi-layered visualizations while maintaining a clean and extensible architecture.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "ToolHandles", "parameters": ["self"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3016, "end_line": 3017}, "code_snippet": "    def artists(self):\n        return (self._markers, )\n", "type": "function"}, {"name": "test_add_artist", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_test.subplots", "plt.Line2D", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "l2.remove", "fig_ref.subplots", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "fig_test.add_artist", "ax2.add_artist"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 774, "end_line": 799}, "code_snippet": "def test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], transform=fig_ref.transFigure,\n                    gid='l1', zorder=21)\n    r1 = plt.Circle((20, 20), 100, transform=None, clip_on=False, zorder=20,\n                    gid='C1')\n    r2 = plt.Circle((.7, .5), .05, transform=fig_ref.transFigure, gid='C2',\n                    zorder=20)\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_ref.dpi_scale_trans,\n                    facecolor='crimson', clip_on=False, zorder=20, gid='C3')\n    for a in [l1, r1, r2, r3]:\n        ax2.add_artist(a)\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Axis", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1276, "end_line": 1279}, "code_snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}, {"name": "ArtistInspector", "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.", "methods": ["__init__", "get_aliases", "get_valid_values", "_replace_path", "get_setters", "number_of_parameters", "is_alias", "aliased_name", "aliased_name_rest", "pprint_setters", "pprint_setters_rest", "properties", "pprint_getters"], "attributes": ["_get_valid_values_regex", "_NOT_LINKABLE"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1421, "end_line": 1720}, "type": "class"}, {"name": "OffsetBox", "docstring": "A simple container artist.\n\nThe child artists are meant to be drawn at a relative position to its\nparent.\n\nBeing an artist itself, all keyword arguments are passed on to `.Artist`.", "methods": ["__init__", "set_figure", "axes", "contains", "set_offset", "get_offset", "set_width", "set_height", "get_visible_children", "get_children", "_get_bbox_and_child_offsets", "get_bbox", "get_window_extent", "draw"], "attributes": [], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 202, "end_line": 385}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0871975421905518}
{"question": "Why does Matplotlib use an Artist-based rendering system instead of direct drawing commands?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib uses an Artist-based rendering system instead of direct drawing commands for several key architectural benefits: 1) The Artist system provides a high-level abstraction that separates plotting logic from low-level rendering details, allowing the same plotting code to work across different backends (GUI, file formats), 2) Artists encapsulate both data and visual properties, making it easier to modify plot elements after creation and maintain consistency between data and representation, 3) The hierarchical Artist structure (Figure → Axes → individual Artists) provides a natural organization for complex plots and enables efficient rendering by managing parent-child relationships, 4) Artists support interactive features like picking, selection, and event handling that would be difficult to implement with direct drawing commands, 5) The Artist system enables advanced features like automatic layout, coordinate transformations, and clipping that are handled transparently, 6) Artists can be easily serialized, saved, and restored, supporting features like figure pickling and state management, 7) The system provides a consistent API for all visual elements while allowing backend-specific optimizations through the renderer interface. This design enables Matplotlib to support both simple plotting and complex, interactive visualizations with a unified architecture.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "RendererAgg", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles", "methods": ["__init__", "__getstate__", "__setstate__", "_update_methods", "draw_path", "draw_mathtext", "draw_text", "get_text_width_height_descent", "draw_tex", "get_canvas_width_height", "_prepare_font", "points_to_pixels", "buffer_rgba", "tostring_argb", "clear", "option_image_nocomposite", "option_scale_image", "restore_region", "start_filter", "stop_filter"], "attributes": [], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 58, "end_line": 360}, "type": "class"}, {"name": "_blit_draw", "is_method": true, "class_name": "Animation", "parameters": ["self", "artists"], "calls": ["ax._get_view", "self._blit_cache.get", "a.axes.draw_artist", "ax.figure.canvas.blit", "object", "ax.figure.canvas.copy_from_bbox"], "code_location": {"file": "animation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1184, "end_line": 1204}, "code_snippet": "    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared Axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "renderer"], "calls": ["self._unstale_viewLim", "renderer.open_group", "self.get_axes_locator", "self.apply_aspect", "self.get_children", "artists.remove", "self._update_title_position", "sorted", "mimage._draw_list_compositing_images", "renderer.close_group", "RuntimeError", "self.get_visible", "self.spines.values", "self._axis_map.values", "canvas.is_saving", "np.searchsorted", "_draw_rasterized", "self.get_gid", "locator", "artists.remove", "artists.remove", "attrgetter", "self.get_figure", "self.get_figure", "self.get_figure", "isinstance", "a.get_animated"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 3168, "end_line": 3236}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n", "type": "function"}, {"name": "test_add_artist", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_test.subplots", "plt.Line2D", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "l2.remove", "fig_ref.subplots", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "fig_test.add_artist", "ax2.add_artist"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 774, "end_line": 799}, "code_snippet": "def test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], transform=fig_ref.transFigure,\n                    gid='l1', zorder=21)\n    r1 = plt.Circle((20, 20), 100, transform=None, clip_on=False, zorder=20,\n                    gid='C1')\n    r2 = plt.Circle((.7, .5), .05, transform=fig_ref.transFigure, gid='C2',\n                    zorder=20)\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_ref.dpi_scale_trans,\n                    facecolor='crimson', clip_on=False, zorder=20, gid='C3')\n    for a in [l1, r1, r2, r3]:\n        ax2.add_artist(a)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Artist", "parameters": ["self", "renderer"], "calls": ["self.get_visible"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1008, "end_line": 1025}, "code_snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `~matplotlib.backend_bases.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.097360372543335}
{"question": "What is the purpose of Matplotlib's \"Artist\" class in the rendering system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist class serves as the abstract base class for all objects that render into a FigureCanvas. It provides the fundamental interface between the high-level plotting API and the low-level rendering system. The Artist class defines the common properties and methods that all visual elements share, including visibility, alpha transparency, z-order, clipping, transforms, and the core draw() method. It acts as the bridge between the plotting logic and the backend renderers, allowing the same Artist objects to work across different output formats (GUI, files, etc.). Artists are organized into two categories: primitives (like Line2D, Rectangle, Text) that represent actual visual elements, and containers (like Figure, Axes, Axis) that organize and manage other Artists. The Artist class handles coordinate transformations, property management, event handling (picking), and provides a consistent interface for customizing the appearance of all plot elements.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "ArtistInspector", "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.", "methods": ["__init__", "get_aliases", "get_valid_values", "_replace_path", "get_setters", "number_of_parameters", "is_alias", "aliased_name", "aliased_name_rest", "pprint_setters", "pprint_setters_rest", "properties", "pprint_getters"], "attributes": ["_get_valid_values_regex", "_NOT_LINKABLE"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1421, "end_line": 1720}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Axis", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1276, "end_line": 1279}, "code_snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "RendererAgg", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles", "methods": ["__init__", "__getstate__", "__setstate__", "_update_methods", "draw_path", "draw_mathtext", "draw_text", "get_text_width_height_descent", "draw_tex", "get_canvas_width_height", "_prepare_font", "points_to_pixels", "buffer_rgba", "tostring_argb", "clear", "option_image_nocomposite", "option_scale_image", "restore_region", "start_filter", "stop_filter"], "attributes": [], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 58, "end_line": 360}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "Artist", "parameters": ["self", "renderer"], "calls": ["self.get_visible"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1008, "end_line": 1025}, "code_snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `~matplotlib.backend_bases.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1193325519561768}
{"question": "What is the role of Matplotlib's \"Backend\" class in the output system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Backend class (specifically FigureCanvasBase and its subclasses) serves as the abstraction layer that handles the conversion of abstract plot descriptions into actual output formats. It provides the interface between the high-level plotting API and the specific rendering engines or GUI toolkits. The Backend class manages the canvas where figures are drawn, handles file output operations, coordinates with GUI event loops, and provides the rendering context for all plot elements. It separates the plotting logic from the output mechanism, allowing the same plotting code to work across different display environments (Qt, Tk, GTK, etc.) and file formats (PNG, PDF, SVG, etc.). The Backend class also manages the relationship between Figures and their display contexts, handles coordinate transformations, and provides methods for saving figures to files with appropriate format-specific options.", "score": null, "retrieved_content": [{"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "MathTextParser", "parameters": ["self", "output"], "calls": ["_api.check_getitem", "output.lower"], "code_location": {"file": "mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 48, "end_line": 60}, "code_snippet": "    def __init__(self, output):\n        \"\"\"\n        Create a MathTextParser for the given backend *output*.\n\n        Parameters\n        ----------\n        output : {\"path\", \"agg\"}\n            Whether to return a `VectorParse` (\"path\") or a\n            `RasterParse` (\"agg\", or its synonym \"macosx\").\n        \"\"\"\n        self._output_type = _api.check_getitem(\n            {\"path\": \"vector\", \"agg\": \"raster\", \"macosx\": \"raster\"},\n            output=output.lower())\n", "type": "function"}, {"name": "_BackendPgf", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 881, "end_line": 882}, "type": "class"}, {"name": "_BackendSVG", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1380, "end_line": 1382}, "type": "class"}, {"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "_BackendNbAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_nbagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 241, "end_line": 243}, "type": "class"}, {"name": "_BackendPdf", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 2838, "end_line": 2839}, "type": "class"}, {"name": "_BackendQT", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager", "mainloop"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1084, "end_line": 1088}, "type": "class"}, {"name": "_BackendWebAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 326, "end_line": 328}, "type": "class"}, {"name": "_BackendCairo", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 526, "end_line": 529}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1258282661437988}
{"question": "Why does Matplotlib's caching mechanism optimize repeated plotting operations?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's caching mechanism optimizes repeated plotting operations by storing and reusing expensive computational results, reducing redundant work and improving performance. The caching system operates at multiple levels: 1) Artist state caching - Artists track their 'stale' state to avoid unnecessary redraws, only updating when properties have actually changed, 2) Background caching for blitting - the animation system caches static background elements (axes, labels, grid) and only redraws changing artists, dramatically improving animation performance, 3) Font and text caching - the TexManager caches compiled TeX output to avoid recompiling identical text strings, storing results in a hierarchical cache directory structure, 4) Path simplification caching - line segments are simplified and cached to reduce rendering complexity for repeated draws, 5) Renderer caching - backend renderers cache expensive operations like coordinate transformations and clipping regions, 6) Figure canvas caching - the canvas caches pixel buffers and only updates regions that have changed, 7) Style and configuration caching - rcParams and style settings are cached to avoid repeated lookups. These caching mechanisms work together to minimize redundant computations, reduce memory allocations, and improve rendering speed, especially for interactive plots and animations where the same elements are drawn repeatedly with only small changes.", "score": null, "retrieved_content": [{"name": "recache", "is_method": true, "class_name": "Line2D", "parameters": ["self", "always"], "calls": ["astype", "Path", "self.convert_xunits", "ravel", "self.convert_yunits", "ravel", "_path.is_sorted_and_has_non_nan", "self.get_clip_on", "np.isnan", "nanmask.any", "np.column_stack", "len", "self.axes.get_xscale", "self.get_transform", "self._x.copy", "np.arange", "np.interp", "np.asarray", "_to_unmasked_float_array", "_to_unmasked_float_array", "np.broadcast_arrays", "len"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 674, "end_line": 717}, "code_snippet": "    def recache(self, always=False):\n        if always or self._invalidx:\n            xconv = self.convert_xunits(self._xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes\n                and len(x) > self._subslice_optim_min_size\n                and _path.is_sorted_and_has_non_nan(x)\n                and self.axes.name == 'rectilinear'\n                and self.axes.get_xscale() == 'linear'\n                and self._markevery is None\n                and self.get_clip_on()\n                and self.get_transform() == self.axes.transData):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(\n                    indices[nanmask], indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False\n", "type": "function"}, {"name": "test_window_extent_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "ax.legend", "fig.legend", "fig.canvas.draw", "leg.get_window_extent", "leg2.get_window_extent", "range"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 724, "end_line": 732}, "code_snippet": "def test_window_extent_cached_renderer():\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    leg2 = fig.legend()\n    fig.canvas.draw()\n    # check that get_window_extent will use the cached renderer\n    leg.get_window_extent()\n    leg2.get_window_extent()\n", "type": "function"}, {"name": "_test_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.canvas.draw", "plt.figure", "fig.draw_without_rendering", "fig.canvas.get_renderer", "fig.canvas.get_renderer"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 24}, "code_snippet": "def _test_cached_renderer():\n    # Make sure that figures have an associated renderer after\n    # a fig.canvas.draw() call\n    fig = plt.figure(1)\n    fig.canvas.draw()\n    assert fig.canvas.get_renderer()._renderer is not None\n\n    fig = plt.figure(2)\n    fig.draw_without_rendering()\n    assert fig.canvas.get_renderer()._renderer is not None\n", "type": "function"}, {"name": "_recache", "is_method": true, "class_name": "MarkerStyle", "parameters": ["self"], "calls": ["IdentityTransform", "self._marker_function"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 250, "end_line": 264}, "code_snippet": "    def _recache(self):\n        if self._marker_function is None:\n            return\n        self._path = _empty_path\n        self._transform = IdentityTransform()\n        self._alt_path = None\n        self._alt_transform = None\n        self._snap_threshold = None\n        self._joinstyle = JoinStyle.round\n        self._capstyle = self._user_capstyle or CapStyle.butt\n        # Initial guess: Assume the marker is filled unless the fillstyle is\n        # set to 'none'. The marker function will override this for unfilled\n        # markers.\n        self._filled = self._fillstyle != 'none'\n        self._marker_function()\n", "type": "function"}, {"name": "_renderer", "is_method": true, "class_name": "FigureCanvasCairo", "parameters": ["self"], "calls": ["hasattr", "RendererCairo"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 404, "end_line": 411}, "code_snippet": "    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n", "type": "function"}, {"name": "get_renderer", "is_method": true, "class_name": "FigureCanvasAgg", "parameters": ["self"], "calls": ["RendererAgg"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 388, "end_line": 395}, "code_snippet": "    def get_renderer(self):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        return self.renderer\n", "type": "function"}, {"name": "_test_number_of_draws_script", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "plt.show", "plt.pause", "fig.canvas.mpl_connect", "fig.canvas.copy_from_bbox", "ax.draw_artist", "fig.canvas.blit", "range", "plt.pause", "fig.canvas.restore_region", "ax.plot", "ax.draw_artist", "fig.canvas.blit", "fig.canvas.flush_events"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 554, "end_line": 592}, "code_snippet": "def _test_number_of_draws_script():\n    import matplotlib.pyplot as plt\n\n    fig, ax = plt.subplots()\n\n    # animated=True tells matplotlib to only draw the artist when we\n    # explicitly request it\n    ln, = ax.plot([0, 1], [1, 2], animated=True)\n\n    # make sure the window is raised, but the script keeps going\n    plt.show(block=False)\n    plt.pause(0.3)\n    # Connect to draw_event to count the occurrences\n    fig.canvas.mpl_connect('draw_event', print)\n\n    # get copy of entire figure (everything inside fig.bbox)\n    # sans animated artist\n    bg = fig.canvas.copy_from_bbox(fig.bbox)\n    # draw the animated artist, this uses a cached renderer\n    ax.draw_artist(ln)\n    # show the result to the screen\n    fig.canvas.blit(fig.bbox)\n\n    for j in range(10):\n        # reset the background back in the canvas state, screen unchanged\n        fig.canvas.restore_region(bg)\n        # Create a **new** artist here, this is poor usage of blitting\n        # but good for testing to make sure that this doesn't create\n        # excessive draws\n        ln, = ax.plot([0, 1], [1, 2])\n        # render the artist, updating the canvas state, but not the screen\n        ax.draw_artist(ln)\n        # copy the image to the GUI state, but screen might not changed yet\n        fig.canvas.blit(fig.bbox)\n        # flush any pending GUI events, re-painting the screen if needed\n        fig.canvas.flush_events()\n\n    # Let the event loop process everything before leaving\n    plt.pause(0.1)\n", "type": "function"}, {"name": "test_quadcontourset_reuse", "is_method": false, "class_name": null, "parameters": [], "calls": ["np.meshgrid", "plt.subplots", "ax.contourf", "ax.contour", "ax.contour"], "code_location": {"file": "test_contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 507, "end_line": 517}, "code_snippet": "def test_quadcontourset_reuse():\n    # If QuadContourSet returned from one contour(f) call is passed as first\n    # argument to another the underlying C++ contour generator will be reused.\n    x, y = np.meshgrid([0.0, 1.0], [0.0, 1.0])\n    z = x + y\n    fig, ax = plt.subplots()\n    qcs1 = ax.contourf(x, y, z)\n    qcs2 = ax.contour(x, y, z)\n    assert qcs2._contour_generator != qcs1._contour_generator\n    qcs3 = ax.contour(qcs1, z)\n    assert qcs3._contour_generator == qcs1._contour_generator\n", "type": "function"}, {"name": "_blit_draw", "is_method": true, "class_name": "Animation", "parameters": ["self", "artists"], "calls": ["ax._get_view", "self._blit_cache.get", "a.axes.draw_artist", "ax.figure.canvas.blit", "object", "ax.figure.canvas.copy_from_bbox"], "code_location": {"file": "animation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1184, "end_line": 1204}, "code_snippet": "    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared Axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n", "type": "function"}, {"name": "TransformedPath", "docstring": "A `TransformedPath` caches a non-affine transformed copy of the\n`~.path.Path`.  This cached copy is automatically updated when the\nnon-affine part of the transform changes.\n\n.. note::\n\n    Paths are considered immutable by this class. Any update to the\n    path's vertices/codes will not trigger a transform recomputation.", "methods": ["__init__", "_revalidate", "get_transformed_points_and_affine", "get_transformed_path_and_affine", "get_fully_transformed_path", "get_affine"], "attributes": [], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2742, "end_line": 2810}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.0845317840576172}
{"question": "Why does Matplotlib's backend system impact rendering performance for different output formats?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend system impacts rendering performance for different output formats due to the fundamental differences in how each format is processed and optimized. The performance impact stems from several key factors: 1) Different output formats require different rendering engines - raster formats (PNG, JPEG) use pixel-based rendering through the Agg backend, while vector formats (PDF, SVG, PS) use command-based rendering that generates scalable graphics, 2) Raster backends like Agg must process every pixel and perform anti-aliasing calculations, making them computationally intensive for high-resolution outputs, while vector backends generate mathematical descriptions that are more efficient for complex geometric shapes, 3) Each backend has different optimization strategies - Agg uses the Anti-Grain Geometry library for high-quality raster rendering, PDF uses specialized vector graphics commands, and SVG generates XML markup, 4) Memory usage varies significantly between backends - raster backends require large pixel buffers proportional to image size and DPI, while vector backends use memory proportional to the number of drawing commands, 5) File size and compression also affect performance - raster formats require compression algorithms (PNG, JPEG) while vector formats use different encoding schemes, 6) Backend-specific features like font handling, color management, and clipping operations have different computational costs, 7) The choice of backend affects both rendering speed and output quality, requiring users to balance performance needs with format requirements for their specific use case.", "score": null, "retrieved_content": [{"name": "test_savefig_backend", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "fig.savefig", "pytest.raises", "fig.savefig"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 600, "end_line": 607}, "code_snippet": "def test_savefig_backend():\n    fig = plt.figure()\n    # Intentionally use an invalid module name.\n    with pytest.raises(ModuleNotFoundError, match=\"No module named '@absent'\"):\n        fig.savefig(\"test\", backend=\"module://@absent\")\n    with pytest.raises(ValueError,\n                       match=\"The 'pdf' backend does not support png output\"):\n        fig.savefig(\"test.png\", backend=\"pdf\")\n", "type": "function"}, {"name": "test_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "subprocess_run_helper"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 28, "end_line": 30}, "code_snippet": "def test_cached_renderer():\n    subprocess_run_helper(_test_cached_renderer, timeout=_test_timeout,\n                          extra_env={\"MPLBACKEND\": \"macosx\"})\n", "type": "function"}, {"name": "_save_figure", "is_method": false, "class_name": null, "parameters": ["objects", "fmt", "usetex"], "calls": ["mpl.use", "mpl.rcParams.update", "plt.figure", "iter", "fig.subplots_adjust", "range", "add_subplot", "ax.plot", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "getattr", "fig.savefig", "fig.add_subplot", "range", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "fig.add_subplot", "ax2.set_xticks", "zip", "fig.subplots", "imshow", "imshow", "imshow", "fig.subfigures", "add_subplot", "px.imshow", "pimg.set_clip_path", "add_subplot", "plt.imread", "TextPath", "PathClippedImagePatch", "AuxTransformBox", "offsetbox.add_artist", "AnchoredOffsetbox", "ax.add_artist", "deepcopy", "deepcopy", "Path.make_compound_path", "deepcopy", "subplots", "len", "plot_markers", "plot_hatch", "plot_image", "plot_paths", "ax2.bar", "ax2.bar", "bar.set_hatch", "Circle", "get_sample_data", "IdentityTransform", "PathCollection", "collection.set_clip_path", "ax1.add_collection", "PathPatch", "patch.set_clip_path", "ax2.add_patch", "ax1.set_xlim", "ax1.set_ylim", "fig.subfigures", "next", "next", "next", "next", "next", "range", "range", "range", "__init__", "BboxImage", "self.bbox_image.set_data", "set_facecolor", "self.bbox_image.set_clip_path", "self.bbox_image.draw", "draw", "Path.unit_rectangle", "Path.unit_circle", "Path.unit_regular_star", "dict", "range", "self.get_transform", "super", "super", "super"], "code_location": {"file": "test_determinism.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 25, "end_line": 154}, "code_snippet": "def _save_figure(objects='mhip', fmt=\"pdf\", usetex=False):\n    mpl.use(fmt)\n    mpl.rcParams.update({'svg.hashsalt': 'asdf', 'text.usetex': usetex})\n\n    def plot_markers(fig):\n        # use different markers...\n        ax = fig.add_subplot()\n        x = range(10)\n        ax.plot(x, [1] * 10, marker='D')\n        ax.plot(x, [2] * 10, marker='x')\n        ax.plot(x, [3] * 10, marker='^')\n        ax.plot(x, [4] * 10, marker='H')\n        ax.plot(x, [5] * 10, marker='v')\n\n    def plot_hatch(fig):\n        # also use different hatch patterns\n        ax2 = fig.add_subplot()\n        bars = (ax2.bar(range(1, 5), range(1, 5)) +\n                ax2.bar(range(1, 5), [6] * 4, bottom=range(1, 5)))\n        ax2.set_xticks([1.5, 2.5, 3.5, 4.5])\n\n        patterns = ('-', '+', 'x', '\\\\', '*', 'o', 'O', '.')\n        for bar, pattern in zip(bars, patterns):\n            bar.set_hatch(pattern)\n\n    def plot_image(fig):\n        axs = fig.subplots(1, 3, sharex=True, sharey=True)\n        # also use different images\n        A = [[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n        axs[0].imshow(A, interpolation='nearest')\n        A = [[1, 3, 2], [1, 2, 3], [3, 1, 2]]\n        axs[1].imshow(A, interpolation='bilinear')\n        A = [[2, 3, 1], [1, 2, 3], [2, 1, 3]]\n        axs[2].imshow(A, interpolation='bicubic')\n\n    def plot_paths(fig):\n        # clipping support class, copied from demo_text_path.py gallery example\n        class PathClippedImagePatch(PathPatch):\n            \"\"\"\n            The given image is used to draw the face of the patch. Internally,\n            it uses BboxImage whose clippath set to the path of the patch.\n\n            FIXME : The result is currently dpi dependent.\n            \"\"\"\n\n            def __init__(self, path, bbox_image, **kwargs):\n                super().__init__(path, **kwargs)\n                self.bbox_image = BboxImage(\n                    self.get_window_extent, norm=None, origin=None)\n                self.bbox_image.set_data(bbox_image)\n\n            def set_facecolor(self, color):\n                \"\"\"Simply ignore facecolor.\"\"\"\n                super().set_facecolor(\"none\")\n\n            def draw(self, renderer=None):\n                # the clip path must be updated every draw. any solution? -JJ\n                self.bbox_image.set_clip_path(self._path, self.get_transform())\n                self.bbox_image.draw(renderer)\n                super().draw(renderer)\n\n        subfigs = fig.subfigures(1, 3)\n\n        # add a polar projection\n        px = subfigs[0].add_subplot(projection=\"polar\")\n        pimg = px.imshow([[2]])\n        pimg.set_clip_path(Circle((0, 1), radius=0.3333))\n\n        # add a text-based clipping path (origin: demo_text_path.py)\n        ax = subfigs[1].add_subplot()\n        arr = plt.imread(get_sample_data(\"grace_hopper.jpg\"))\n        text_path = TextPath((0, 0), \"!?\", size=150)\n        p = PathClippedImagePatch(text_path, arr, ec=\"k\")\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(p)\n        ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,\n                               borderpad=0.2)\n        ax.add_artist(ao)\n\n        # add a 2x2 grid of path-clipped axes (origin: test_artist.py)\n        exterior = Path.unit_rectangle().deepcopy()\n        exterior.vertices *= 4\n        exterior.vertices -= 2\n        interior = Path.unit_circle().deepcopy()\n        interior.vertices = interior.vertices[::-1]\n        clip_path = Path.make_compound_path(exterior, interior)\n\n        star = Path.unit_regular_star(6).deepcopy()\n        star.vertices *= 2.6\n\n        (row1, row2) = subfigs[2].subplots(2, 2, sharex=True, sharey=True,\n                                           gridspec_kw=dict(hspace=0, wspace=0))\n        for row in (row1, row2):\n            ax1, ax2 = row\n            collection = PathCollection([star], lw=5, edgecolor='blue',\n                                        facecolor='red', alpha=0.7, hatch='*')\n            collection.set_clip_path(clip_path, ax1.transData)\n            ax1.add_collection(collection)\n\n            patch = PathPatch(star, lw=5, edgecolor='blue', facecolor='red',\n                              alpha=0.7, hatch='*')\n            patch.set_clip_path(clip_path, ax2.transData)\n            ax2.add_patch(patch)\n\n            ax1.set_xlim([-3, 3])\n            ax1.set_ylim([-3, 3])\n\n    nfigs = len(objects) + 1\n    fig = plt.figure(figsize=(7, 3 * nfigs))\n    subfigs = iter(fig.subfigures(nfigs, squeeze=False).flat)\n    fig.subplots_adjust(bottom=0.15)\n\n    if 'm' in objects:\n        plot_markers(next(subfigs))\n    if 'h' in objects:\n        plot_hatch(next(subfigs))\n    if 'i' in objects:\n        plot_image(next(subfigs))\n    if 'p' in objects:\n        plot_paths(next(subfigs))\n\n    x = range(5)\n    ax = next(subfigs).add_subplot()\n    ax.plot(x, x)\n    ax.set_title('A string $1+2+\\\\sigma$')\n    ax.set_xlabel('A string $1+2+\\\\sigma$')\n    ax.set_ylabel('A string $1+2+\\\\sigma$')\n\n    stdout = getattr(sys.stdout, 'buffer', sys.stdout)\n    fig.savefig(stdout, format=fmt)\n", "type": "function"}, {"name": "test_hinting_factor_backends", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.text", "fig.savefig", "fig.savefig", "np.testing.assert_allclose", "io.BytesIO", "t.get_window_extent", "io.BytesIO", "t.get_window_extent"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 579, "end_line": 590}, "code_snippet": "def test_hinting_factor_backends():\n    plt.rcParams['text.hinting_factor'] = 1\n    fig = plt.figure()\n    t = fig.text(0.5, 0.5, 'some text')\n\n    fig.savefig(io.BytesIO(), format='svg')\n    expected = t.get_window_extent().intervalx\n\n    fig.savefig(io.BytesIO(), format='png')\n    # Backends should apply hinting_factor consistently (within 10%).\n    np.testing.assert_allclose(t.get_window_extent().intervalx, expected,\n                               rtol=0.1)\n", "type": "function"}, {"name": "use", "is_method": false, "class_name": null, "parameters": ["backend"], "calls": ["rcsetup.validate_backend", "rcParams._get_backend_or_none", "sys.modules.get", "plt.switch_backend"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1189, "end_line": 1259}, "code_snippet": "def use(backend, *, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    If pyplot is already imported, `~matplotlib.pyplot.switch_backend` is used\n    and if the new backend is different than the current backend, all Figures\n    will be closed.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg, notebook, QtAgg,\n          QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo, Qt5Agg, Qt5Cairo\n\n        - non-interactive backends:\n          agg, cairo, pdf, pgf, ps, svg, template\n\n        or a string of the form: ``module://my.module.name``.\n\n        notebook is a synonym for nbAgg.\n\n        Switching to an interactive backend is not possible if an unrelated\n        event loop has already been started (e.g., switching to GTK3Agg if a\n        TkAgg window has already been opened).  Switching to a non-interactive\n        backend is always possible.\n\n    force : bool, default: True\n        If True (the default), raise an `ImportError` if the backend cannot be\n        set up (either because it fails to import, or because an incompatible\n        GUI interactive framework is already running); if False, silently\n        ignore the failure.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    matplotlib.pyplot.switch_backend\n\n    \"\"\"\n    name = rcsetup.validate_backend(backend)\n    # don't (prematurely) resolve the \"auto\" backend setting\n    if rcParams._get_backend_or_none() == name:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # if pyplot is not already imported, do not import it.  Doing\n        # so may trigger a `plt.switch_backend` to the _default_ backend\n        # before we get a chance to change to the one the user just requested\n        plt = sys.modules.get('matplotlib.pyplot')\n        # if pyplot is imported, then try to change backends\n        if plt is not None:\n            try:\n                # we need this import check here to re-raise if the\n                # user does not have the libraries to support their\n                # chosen backend installed.\n                plt.switch_backend(name)\n            except ImportError:\n                if force:\n                    raise\n        # if we have not imported pyplot, then we can set the rcParam\n        # value which will be respected when the user finally imports\n        # pyplot\n        else:\n            rcParams['backend'] = backend\n    # if the user has asked for a given backend, do not helpfully\n    # fallback\n    rcParams['backend_fallback'] = False\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "test_non_agg_renderer", "is_method": false, "class_name": null, "parameters": ["monkeypatch", "recwarn"], "calls": ["pytest.mark.backend", "monkeypatch.setattr", "plt.subplots", "fig.tight_layout", "isinstance", "unpatched_init"], "code_location": {"file": "test_tightlayout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 358, "end_line": 369}, "code_snippet": "def test_non_agg_renderer(monkeypatch, recwarn):\n    unpatched_init = mpl.backend_bases.RendererBase.__init__\n\n    def __init__(self, *args, **kwargs):\n        # Check that we don't instantiate any other renderer than a pdf\n        # renderer to perform pdf tight layout.\n        assert isinstance(self, mpl.backends.backend_pdf.RendererPdf)\n        unpatched_init(self, *args, **kwargs)\n\n    monkeypatch.setattr(mpl.backend_bases.RendererBase, \"__init__\", __init__)\n    fig, ax = plt.subplots()\n    fig.tight_layout()\n", "type": "function"}, {"name": "test_save_figure_return", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "subprocess_run_helper"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 84, "end_line": 86}, "code_snippet": "def test_save_figure_return():\n    subprocess_run_helper(_test_save_figure_return, timeout=_test_timeout,\n                          extra_env={\"MPLBACKEND\": \"macosx\"})\n", "type": "function"}, {"name": "test_rasterize_dpi", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "np.asarray", "plt.subplots", "imshow", "plot", "set", "plot", "set", "ax.set_xticks", "ax.set_yticks", "set_visible"], "code_location": {"file": "test_image.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 607, "end_line": 633}, "code_snippet": "def test_rasterize_dpi():\n    # This test should check rasterized rendering with high output resolution.\n    # It plots a rasterized line and a normal image with imshow.  So it will\n    # catch when images end up in the wrong place in case of non-standard dpi\n    # setting.  Instead of high-res rasterization I use low-res.  Therefore\n    # the fact that the resolution is non-standard is easily checked by\n    # image_comparison.\n    img = np.asarray([[1, 2], [3, 4]])\n\n    fig, axs = plt.subplots(1, 3, figsize=(3, 1))\n\n    axs[0].imshow(img)\n\n    axs[1].plot([0, 1], [0, 1], linewidth=20., rasterized=True)\n    axs[1].set(xlim=(0, 1), ylim=(-1, 2))\n\n    axs[2].plot([0, 1], [0, 1], linewidth=20.)\n    axs[2].set(xlim=(0, 1), ylim=(-1, 2))\n\n    # Low-dpi PDF rasterization errors prevent proper image comparison tests.\n    # Hide detailed structures like the axes spines.\n    for ax in axs:\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.spines[:].set_visible(False)\n\n    rcParams['savefig.dpi'] = 10\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "MathTextParser", "parameters": ["self", "output"], "calls": ["_api.check_getitem", "output.lower"], "code_location": {"file": "mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 48, "end_line": 60}, "code_snippet": "    def __init__(self, output):\n        \"\"\"\n        Create a MathTextParser for the given backend *output*.\n\n        Parameters\n        ----------\n        output : {\"path\", \"agg\"}\n            Whether to return a `VectorParse` (\"path\") or a\n            `RasterParse` (\"agg\", or its synonym \"macosx\").\n        \"\"\"\n        self._output_type = _api.check_getitem(\n            {\"path\": \"vector\", \"agg\": \"raster\", \"macosx\": \"raster\"},\n            output=output.lower())\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1002886295318604}
{"question": "Why does Matplotlib include an event system for interactive plotting capabilities?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib includes an event system for interactive plotting capabilities to enable responsive user interactions and enhance data exploration. The event system serves several key purposes: 1) It provides a GUI-neutral interface that works across different GUI toolkits (Qt, Tk, GTK, Wx, macOS) while maintaining consistent behavior, allowing the same interactive code to work regardless of the underlying GUI framework, 2) The system converts low-level GUI events (mouse clicks, key presses, mouse movements) into Matplotlib-specific events with data coordinates, enabling precise interaction with plot elements, 3) It supports built-in interactive features like panning, zooming, and data point selection that enhance data exploration capabilities, 4) The event system allows users to create custom interactive behaviors by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), enabling personalized data exploration tools, 5) It enables responsive figure updates during long-running computations by periodically processing events through flush_events(), maintaining interactivity even during intensive calculations, 6) The event-driven approach supports integration with command-line interfaces through input hook mechanisms, allowing both interactive plotting and command-line usage, 7) It provides a foundation for advanced interactive features like picking, selection, and custom data exploration tools. This design enables Matplotlib to support both static plotting and dynamic, interactive visualizations that respond to user input in real-time.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "LocationEvent", "docstring": "An event that has a screen location.\n\nA LocationEvent has a number of special attributes in addition to those\ndefined by the parent `Event` class.\n\nAttributes\n----------\nx, y : int or None\n    Event location in pixels from bottom left of canvas.\ninaxes : `~matplotlib.axes.Axes` or None\n    The `~.axes.Axes` instance over which the mouse is, if any.\nxdata, ydata : float or None\n    Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n    is not over an Axes.\nmodifiers : frozenset\n    The keyboard modifiers currently being pressed (except for KeyEvent).", "methods": ["__init__", "_set_inaxes"], "attributes": ["_last_axes_ref"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1249, "end_line": 1304}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "EventHandler", "parameters": ["self"], "calls": ["fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect"], "code_location": {"file": "looking_glass.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 37, "end_line": 42}, "code_snippet": "    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AxesWidget", "parameters": ["self", "ax"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 116, "end_line": 118}, "code_snippet": "    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n", "type": "function"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "MouseEvent", "docstring": "A mouse event ('button_press_event', 'button_release_event', 'scroll_event', 'motion_notify_event').\n\nA MouseEvent has a number of special attributes in addition to those\ndefined by the parent `Event` and `LocationEvent` classes.\n\nAttributes\n----------\nbutton : None or `MouseButton` or {'up', 'down'}\n    The button pressed. 'up' and 'down' are used for scroll events.\n\n    Note that LEFT and RIGHT actually refer to the \"primary\" and\n    \"secondary\" buttons, i.e. if the user inverts their left and right\n    buttons (\"left-handed setting\") then the LEFT button will be the one\n    physically on the right.\n\n    If this is unset, *name* is \"scroll_event\", and *step* is nonzero, then\n    this will be set to \"up\" or \"down\" depending on the sign of *step*.\n\nbuttons : None or frozenset\n    For 'motion_notify_event', the mouse buttons currently being pressed\n    (a set of zero or more MouseButtons);\n    for other events, None.\n\n    .. note::\n       For 'motion_notify_event', this attribute is more accurate than\n       the ``button`` (singular) attribute, which is obtained from the last\n       'button_press_event' or 'button_release_event' that occurred within\n       the canvas (and thus 1. be wrong if the last change in mouse state\n       occurred when the canvas did not have focus, and 2. cannot report\n       when multiple buttons are pressed).\n\n       This attribute is not set for 'button_press_event' and\n       'button_release_event' because GUI toolkits are inconsistent as to\n       whether they report the button state *before* or *after* the\n       press/release occurred.\n\n    .. warning::\n       On macOS, the Tk backends only report a single button even if\n       multiple buttons are pressed.\n\nkey : None or str\n    The key pressed when the mouse event triggered, e.g. 'shift'.\n    See `KeyEvent`.\n\n    .. warning::\n       This key is currently obtained from the last 'key_press_event' or\n       'key_release_event' that occurred within the canvas.  Thus, if the\n       last change of keyboard state occurred while the canvas did not have\n       focus, this attribute will be wrong.  On the other hand, the\n       ``modifiers`` attribute should always be correct, but it can only\n       report on modifier keys.\n\nstep : float\n    The number of scroll steps (positive for 'up', negative for 'down').\n    This applies only to 'scroll_event' and defaults to 0 otherwise.\n\ndblclick : bool\n    Whether the event is a double-click. This applies only to\n    'button_press_event' and is False otherwise. In particular, it's\n    not used in 'button_release_event'.\n\nExamples\n--------\n::\n\n    def on_press(event):\n        print('you pressed', event.button, event.xdata, event.ydata)\n\n    cid = fig.canvas.mpl_connect('button_press_event', on_press)", "methods": ["__init__", "_from_ax_coords", "__str__"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1315, "end_line": 1437}, "type": "class"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "_contour_labeler_event_handler", "is_method": false, "class_name": null, "parameters": ["cs", "inline", "inline_spacing", "event"], "calls": ["cs.axes.get_figure", "canvas.stop_event_loop", "cs.pop_label", "canvas.draw", "cs.axes.contains", "cs.add_label_near", "canvas.draw"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 30, "end_line": 56}, "code_snippet": "def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n    canvas = cs.axes.get_figure(root=True).canvas\n    is_button = event.name == \"button_press_event\"\n    is_key = event.name == \"key_press_event\"\n    # Quit (even if not in infinite mode; this is consistent with\n    # MATLAB and sometimes quite useful, but will require the user to\n    # test how many points were actually returned before using data).\n    if (is_button and event.button == MouseButton.MIDDLE\n            or is_key and event.key in [\"escape\", \"enter\"]):\n        canvas.stop_event_loop()\n    # Pop last click.\n    elif (is_button and event.button == MouseButton.RIGHT\n          or is_key and event.key in [\"backspace\", \"delete\"]):\n        # Unfortunately, if one is doing inline labels, then there is currently\n        # no way to fix the broken contour - once humpty-dumpty is broken, he\n        # can't be put back together.  In inline mode, this does nothing.\n        if not inline:\n            cs.pop_label()\n            canvas.draw()\n    # Add new click.\n    elif (is_button and event.button == MouseButton.LEFT\n          # On macOS/gtk, some keys return None.\n          or is_key and event.key is not None):\n        if cs.axes.contains(event)[0]:\n            cs.add_label_near(event.x, event.y, transform=False,\n                              inline=inline, inline_spacing=inline_spacing)\n            canvas.draw()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK4", "parameters": ["self", "figure"], "calls": ["__init__", "self.set_hexpand", "self.set_vexpand", "self.set_draw_func", "self.connect", "Gtk.GestureClick", "click.set_button", "click.connect", "click.connect", "self.add_controller", "Gtk.EventControllerKey", "key.connect", "key.connect", "self.add_controller", "Gtk.EventControllerMotion", "motion.connect", "motion.connect", "motion.connect", "self.add_controller", "Gtk.EventControllerScroll.new", "scroll.connect", "self.add_controller", "self.set_focusable", "Gtk.CssProvider", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "self.connect", "self.connect", "Gtk.check_version", "css.load_from_data", "css.load_from_data", "super", "style.encode"], "code_location": {"file": "backend_gtk4.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 41, "end_line": 89}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self.set_hexpand(True)\n        self.set_vexpand(True)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.set_draw_func(self._draw_func)\n        self.connect('resize', self.resize_event)\n        if _GTK_GE_4_12:\n            self.connect('realize', self._realize_event)\n        else:\n            self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n\n        click = Gtk.GestureClick()\n        click.set_button(0)  # All buttons.\n        click.connect('pressed', self.button_press_event)\n        click.connect('released', self.button_release_event)\n        self.add_controller(click)\n\n        key = Gtk.EventControllerKey()\n        key.connect('key-pressed', self.key_press_event)\n        key.connect('key-released', self.key_release_event)\n        self.add_controller(key)\n\n        motion = Gtk.EventControllerMotion()\n        motion.connect('motion', self.motion_notify_event)\n        motion.connect('enter', self.enter_notify_event)\n        motion.connect('leave', self.leave_notify_event)\n        self.add_controller(motion)\n\n        scroll = Gtk.EventControllerScroll.new(\n            Gtk.EventControllerScrollFlags.VERTICAL)\n        scroll.connect('scroll', self.scroll_event)\n        self.add_controller(scroll)\n\n        self.set_focusable(True)\n\n        css = Gtk.CssProvider()\n        style = '.matplotlib-canvas { background-color: white; }'\n        if Gtk.check_version(4, 9, 3) is None:\n            css.load_from_data(style, -1)\n        else:\n            css.load_from_data(style.encode('utf-8'))\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolSetCursor", "parameters": ["self"], "calls": ["__init__", "self.toolmanager.toolmanager_connect", "self.toolmanager.tools.values", "self._add_tool_cbk", "super", "mpl.backend_managers.ToolEvent"], "code_location": {"file": "backend_tools.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 256, "end_line": 266}, "code_snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._id_drag = None\n        self._current_tool = None\n        self._default_cursor = cursors.POINTER\n        self._last_cursor = self._default_cursor\n        self.toolmanager.toolmanager_connect('tool_added_event',\n                                             self._add_tool_cbk)\n        for tool in self.toolmanager.tools.values():  # process current tools\n            self._add_tool_cbk(mpl.backend_managers.ToolEvent(\n                'tool_added_event', self.toolmanager, tool))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.119321584701538}
{"question": "Why does Matplotlib's event system influence interactive plotting responsiveness?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event system influences interactive plotting responsiveness through several key mechanisms that determine how quickly and efficiently user interactions are processed. The event system's impact on responsiveness stems from several factors: 1) Event loop integration - the system must coordinate between GUI toolkit events (Qt, Tk, GTK, Wx, macOS) and Matplotlib's internal event processing, with proper integration ensuring responsive figures while maintaining compatibility with different GUI frameworks, 2) Event processing frequency - methods like FigureCanvasBase.flush_events() process pending UI events, and the frequency of these calls directly affects responsiveness (20-30ms intervals feel responsive while 100ms intervals feel laggy), 3) Event coordinate conversion - the system converts low-level GUI events into Matplotlib-specific events with both pixel coordinates and data coordinates, which requires computational overhead but enables precise interaction, 4) Callback execution - event callbacks must execute quickly to maintain responsiveness, with complex callbacks potentially blocking the event loop and reducing interactivity, 5) Drawing coordination - the event system coordinates with drawing operations through methods like draw_idle() which schedules rendering without blocking the event loop, 6) Stale artist management - the system tracks which artists have changed (stale state) and only redraws when necessary, avoiding unnecessary rendering that could impact responsiveness, 7) Threading considerations - since GUI frameworks require updates on the main thread, the event system must handle thread coordination properly to maintain responsiveness while allowing background computations. These factors make the event system a critical component in determining the overall responsiveness of interactive matplotlib plots.", "score": null, "retrieved_content": [{"name": "draw_if_interactive", "is_method": true, "class_name": "_Backend", "parameters": ["cls"], "calls": ["is_interactive", "Gcf.get_active", "manager.canvas.draw_idle"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3559, "end_line": 3568}, "code_snippet": "    def draw_if_interactive(cls):\n        manager_class = cls.FigureCanvas.manager_class\n        # Interactive backends reimplement start_main_loop or pyplot_show.\n        backend_is_interactive = (\n            manager_class.start_main_loop != FigureManagerBase.start_main_loop\n            or manager_class.pyplot_show != FigureManagerBase.pyplot_show)\n        if backend_is_interactive and is_interactive():\n            manager = Gcf.get_active()\n            if manager:\n                manager.canvas.draw_idle()\n", "type": "function"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "test_waitforbuttonpress", "is_method": false, "class_name": null, "parameters": ["recwarn"], "calls": ["warnings.filterwarnings", "plt.figure", "start", "start", "fig.waitforbuttonpress", "fig.waitforbuttonpress", "fig.waitforbuttonpress", "Timer", "Timer", "KeyEvent", "MouseEvent"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1630, "end_line": 1637}, "code_snippet": "def test_waitforbuttonpress(recwarn):  # recwarn undoes warn filters at exit.\n    warnings.filterwarnings(\"ignore\", \"cannot show the figure\")\n    fig = plt.figure()\n    assert fig.waitforbuttonpress(timeout=.1) is None\n    Timer(.1, KeyEvent(\"key_press_event\", fig.canvas, \"z\")._process).start()\n    assert fig.waitforbuttonpress() is True\n    Timer(.1, MouseEvent(\"button_press_event\", fig.canvas, 0, 0, 1)._process).start()\n    assert fig.waitforbuttonpress() is False\n", "type": "function"}, {"name": "_impl_test_interactive_timers", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "plt.pause", "fig.canvas.new_timer", "Mock", "timer.add_callback", "timer.start", "plt.pause", "timer.stop", "timer.start", "plt.pause", "timer.start", "plt.pause", "plt.close"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 648, "end_line": 677}, "code_snippet": "def _impl_test_interactive_timers():\n    # A timer with <1 millisecond gets converted to int and therefore 0\n    # milliseconds, which the mac framework interprets as singleshot.\n    # We only want singleshot if we specify that ourselves, otherwise we want\n    # a repeating timer\n    from unittest.mock import Mock\n    import matplotlib.pyplot as plt\n    pause_time = 0.5\n    fig = plt.figure()\n    plt.pause(pause_time)\n    timer = fig.canvas.new_timer(0.1)\n    mock = Mock()\n    timer.add_callback(mock)\n    timer.start()\n    plt.pause(pause_time)\n    timer.stop()\n    assert mock.call_count > 1\n\n    # Now turn it into a single shot timer and verify only one gets triggered\n    mock.call_count = 0\n    timer.single_shot = True\n    timer.start()\n    plt.pause(pause_time)\n    assert mock.call_count == 1\n\n    # Make sure we can start the timer a second time\n    timer.start()\n    plt.pause(pause_time)\n    assert mock.call_count == 2\n    plt.close(\"all\")\n", "type": "function"}, {"name": "_contour_labeler_event_handler", "is_method": false, "class_name": null, "parameters": ["cs", "inline", "inline_spacing", "event"], "calls": ["cs.axes.get_figure", "canvas.stop_event_loop", "cs.pop_label", "canvas.draw", "cs.axes.contains", "cs.add_label_near", "canvas.draw"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 30, "end_line": 56}, "code_snippet": "def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n    canvas = cs.axes.get_figure(root=True).canvas\n    is_button = event.name == \"button_press_event\"\n    is_key = event.name == \"key_press_event\"\n    # Quit (even if not in infinite mode; this is consistent with\n    # MATLAB and sometimes quite useful, but will require the user to\n    # test how many points were actually returned before using data).\n    if (is_button and event.button == MouseButton.MIDDLE\n            or is_key and event.key in [\"escape\", \"enter\"]):\n        canvas.stop_event_loop()\n    # Pop last click.\n    elif (is_button and event.button == MouseButton.RIGHT\n          or is_key and event.key in [\"backspace\", \"delete\"]):\n        # Unfortunately, if one is doing inline labels, then there is currently\n        # no way to fix the broken contour - once humpty-dumpty is broken, he\n        # can't be put back together.  In inline mode, this does nothing.\n        if not inline:\n            cs.pop_label()\n            canvas.draw()\n    # Add new click.\n    elif (is_button and event.button == MouseButton.LEFT\n          # On macOS/gtk, some keys return None.\n          or is_key and event.key is not None):\n        if cs.axes.contains(event)[0]:\n            cs.add_label_near(event.x, event.y, transform=False,\n                              inline=inline, inline_spacing=inline_spacing)\n            canvas.draw()\n", "type": "function"}, {"name": "test_picking_does_not_stale", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.style.context", "plt.subplots", "ax.scatter", "fig.canvas.draw", "SimpleNamespace", "fig.pick"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 951, "end_line": 961}, "code_snippet": "def test_picking_does_not_stale():\n    fig, ax = plt.subplots()\n    ax.scatter([0], [0], [1000], picker=True)\n    fig.canvas.draw()\n    assert not fig.stale\n\n    mouse_event = SimpleNamespace(x=ax.bbox.x0 + ax.bbox.width / 2,\n                                  y=ax.bbox.y0 + ax.bbox.height / 2,\n                                  inaxes=ax, guiEvent=None)\n    fig.pick(mouse_event)\n    assert not fig.stale\n", "type": "function"}, {"name": "_click", "is_method": true, "class_name": "Button", "parameters": ["self", "event"], "calls": ["self.ignore", "event.canvas.grab_mouse", "self.ax.contains"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 218, "end_line": 222}, "code_snippet": "    def _click(self, event):\n        if not self.eventson or self.ignore(event) or not self.ax.contains(event)[0]:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "_draw_all_if_interactive", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.is_interactive", "draw_all"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 291, "end_line": 293}, "code_snippet": "def _draw_all_if_interactive() -> None:\n    if matplotlib.is_interactive():\n        draw_all()\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 157, "end_line": 162}, "code_snippet": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1120853424072266}
{"question": "Why does Matplotlib's Artist hierarchy affect memory usage and rendering speed?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist hierarchy affects memory usage and rendering speed through several key mechanisms in its design. The hierarchical structure impacts performance in several ways: 1) Memory usage scales with the number of Artist objects - each Figure, Axes, and individual Artist (lines, text, patches) consumes memory for storing properties, transforms, and data, with complex plots containing hundreds or thousands of Artist objects, 2) The parent-child relationships in the hierarchy enable efficient rendering by allowing parent containers to manage their children and coordinate drawing operations, reducing redundant calculations, 3) The hierarchy supports optimization features like line segment simplification (path.simplify) and marker subsampling (markevery) that can significantly reduce rendering time for large datasets, 4) Memory allocation patterns are affected by the hierarchy - raster backends like Agg require large pixel buffers proportional to image size and DPI, while the Artist hierarchy determines how these buffers are managed, 5) The hierarchy enables efficient clipping and coordinate transformations by applying them at appropriate levels (Figure, Axes, or individual Artist), avoiding unnecessary calculations, 6) Rendering speed is impacted by the traversal order of the hierarchy - Artists are drawn in z-order, and the hierarchy determines the efficiency of this traversal, 7) The hierarchy supports features like chunking (agg.path.chunksize) that can split large lines into smaller pieces, improving memory usage and rendering performance for complex plots. These effects make the Artist hierarchy a critical factor in both memory efficiency and rendering performance.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "renderer"], "calls": ["self._unstale_viewLim", "renderer.open_group", "self.get_axes_locator", "self.apply_aspect", "self.get_children", "artists.remove", "self._update_title_position", "sorted", "mimage._draw_list_compositing_images", "renderer.close_group", "RuntimeError", "self.get_visible", "self.spines.values", "self._axis_map.values", "canvas.is_saving", "np.searchsorted", "_draw_rasterized", "self.get_gid", "locator", "artists.remove", "artists.remove", "attrgetter", "self.get_figure", "self.get_figure", "self.get_figure", "isinstance", "a.get_animated"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 3168, "end_line": 3236}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "test_add_artist", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_test.subplots", "plt.Line2D", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "l2.remove", "fig_ref.subplots", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "fig_test.add_artist", "ax2.add_artist"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 774, "end_line": 799}, "code_snippet": "def test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], transform=fig_ref.transFigure,\n                    gid='l1', zorder=21)\n    r1 = plt.Circle((20, 20), 100, transform=None, clip_on=False, zorder=20,\n                    gid='C1')\n    r2 = plt.Circle((.7, .5), .05, transform=fig_ref.transFigure, gid='C2',\n                    zorder=20)\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_ref.dpi_scale_trans,\n                    facecolor='crimson', clip_on=False, zorder=20, gid='C3')\n    for a in [l1, r1, r2, r3]:\n        ax2.add_artist(a)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Path3DCollection", "parameters": ["self", "renderer"], "calls": ["self._use_zordered_offset", "cbook._setattr_cm", "draw", "super"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 903, "end_line": 906}, "code_snippet": "    def draw(self, renderer):\n        with self._use_zordered_offset():\n            with cbook._setattr_cm(self, _in_draw=True):\n                super().draw(renderer)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Collection", "parameters": ["self", "renderer"], "calls": ["renderer.open_group", "self.update_scalarmappable", "self._prepare_points", "renderer.new_gc", "self._set_gc_clip", "gc.set_snap", "self.get_path_effects", "self.get_transforms", "self.get_facecolor", "self.get_edgecolor", "gc.restore", "renderer.close_group", "self.get_visible", "self.get_gid", "self.get_snap", "gc.set_hatch", "gc.set_hatch_linewidth", "self.get_sketch_params", "gc.set_sketch_params", "PathEffectRenderer", "all", "len", "get_extents", "gc.set_joinstyle", "gc.set_capstyle", "gc.set_foreground", "gc.set_linewidth", "gc.set_dashes", "gc.set_antialiased", "gc.set_url", "renderer.draw_markers", "self.get_path_effects", "len", "len", "len", "len", "len", "len", "len", "self.get_hatch", "tuple", "combined_transform.frozen", "mpath.Path", "tuple", "renderer.draw_path_collection", "self._get_inverse_paths_linestyles", "self.get_facecolor", "self.get_edgecolor", "renderer.draw_path_collection", "self.get_sketch_params", "transforms.Affine2D", "transform.frozen", "self.get_transforms", "self.get_facecolor", "self.get_edgecolor", "self.get_hatch", "renderer.draw_path_collection", "transform.frozen", "self.get_transforms", "renderer.draw_path_collection", "renderer._iter_collection_raw_paths", "renderer._iter_collection", "self.get_hatchcolor", "mcolors.to_rgba", "transform.frozen", "self.get_transforms", "renderer.draw_path_collection", "renderer._iter_collection_raw_paths", "renderer._iter_collection", "self.get_hatchcolor", "transform.frozen", "self.get_transforms", "transform.frozen", "self.get_transforms", "list", "renderer.draw_path", "self.get_figure", "self.get_figure", "self.get_hatchcolor", "transform.frozen", "self.get_transforms", "transform.frozen", "self.get_transforms", "list", "renderer.draw_path", "self.get_hatchcolor", "transform.frozen", "transform.translate", "self.get_hatchcolor", "transform.frozen", "transform.translate"], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 358, "end_line": 506}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        renderer.open_group(self.__class__.__name__, self.get_gid())\n\n        self.update_scalarmappable()\n\n        transform, offset_trf, offsets, paths = self._prepare_points()\n\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_snap(self.get_snap())\n\n        if self._hatch:\n            gc.set_hatch(self._hatch)\n            gc.set_hatch_linewidth(self._hatch_linewidth)\n\n        if self.get_sketch_params() is not None:\n            gc.set_sketch_params(*self.get_sketch_params())\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        # If the collection is made up of a single shape/color/stroke,\n        # it can be rendered once and blitted multiple times, using\n        # `draw_markers` rather than `draw_path_collection`.  This is\n        # *much* faster for Agg, and results in smaller file sizes in\n        # PDF/SVG/PS.\n\n        trans = self.get_transforms()\n        facecolors = self.get_facecolor()\n        edgecolors = self.get_edgecolor()\n        do_single_path_optimization = False\n        if (len(paths) == 1 and len(trans) <= 1 and\n                len(facecolors) == 1 and len(edgecolors) == 1 and\n                len(self._linewidths) == 1 and\n                all(ls[1] is None for ls in self._linestyles) and\n                len(self._antialiaseds) == 1 and len(self._urls) == 1 and\n                self.get_hatch() is None):\n            if len(trans):\n                combined_transform = transforms.Affine2D(trans[0]) + transform\n            else:\n                combined_transform = transform\n            extents = paths[0].get_extents(combined_transform)\n            if (extents.width < self.get_figure(root=True).bbox.width\n                    and extents.height < self.get_figure(root=True).bbox.height):\n                do_single_path_optimization = True\n\n        if self._joinstyle:\n            gc.set_joinstyle(self._joinstyle)\n\n        if self._capstyle:\n            gc.set_capstyle(self._capstyle)\n\n        if do_single_path_optimization:\n            gc.set_foreground(tuple(edgecolors[0]))\n            gc.set_linewidth(self._linewidths[0])\n            gc.set_dashes(*self._linestyles[0])\n            gc.set_antialiased(self._antialiaseds[0])\n            gc.set_url(self._urls[0])\n            renderer.draw_markers(\n                gc, paths[0], combined_transform.frozen(),\n                mpath.Path(offsets), offset_trf, tuple(facecolors[0]))\n        else:\n            # The current new API of draw_path_collection() is provisional\n            # and will be changed in a future PR.\n\n            # Find whether renderer.draw_path_collection() takes hatchcolor parameter.\n            # Since third-party implementations of draw_path_collection() may not be\n            # introspectable, e.g. with inspect.signature, the only way is to try and\n            # call this with the hatchcolors parameter.\n            hatchcolors_arg_supported = True\n            try:\n                renderer.draw_path_collection(\n                    gc, transform.frozen(), [],\n                    self.get_transforms(), offsets, offset_trf,\n                    self.get_facecolor(), self.get_edgecolor(),\n                    self._linewidths, self._linestyles,\n                    self._antialiaseds, self._urls,\n                    \"screen\", hatchcolors=self.get_hatchcolor()\n                )\n            except TypeError:\n                # If the renderer does not support the hatchcolors argument,\n                # it will raise a TypeError. In this case, we will\n                # iterate over all paths and draw them one by one.\n                hatchcolors_arg_supported = False\n\n            # If the hatchcolors argument is not needed or not passed\n            # then we can skip the iteration over paths in case the\n            # argument is not supported by the renderer.\n            hatchcolors_not_needed = (self.get_hatch() is None or\n                                      self._original_hatchcolor is None)\n\n            if self._gapcolor is not None:\n                # First draw paths within the gaps.\n                ipaths, ilinestyles = self._get_inverse_paths_linestyles()\n                args = [offsets, offset_trf, [mcolors.to_rgba(\"none\")], self._gapcolor,\n                        self._linewidths, ilinestyles, self._antialiaseds, self._urls,\n                        \"screen\"]\n\n                if hatchcolors_arg_supported:\n                    renderer.draw_path_collection(gc, transform.frozen(), ipaths,\n                                                  self.get_transforms(), *args,\n                                                  hatchcolors=self.get_hatchcolor())\n                else:\n                    if hatchcolors_not_needed:\n                        renderer.draw_path_collection(gc, transform.frozen(), ipaths,\n                                                      self.get_transforms(), *args)\n                    else:\n                        path_ids = renderer._iter_collection_raw_paths(\n                            transform.frozen(), ipaths, self.get_transforms())\n                        for xo, yo, path_id, gc0, rgbFace in renderer._iter_collection(\n                            gc, list(path_ids), *args,\n                            hatchcolors=self.get_hatchcolor(),\n                        ):\n                            path, transform = path_id\n                            if xo != 0 or yo != 0:\n                                transform = transform.frozen()\n                                transform.translate(xo, yo)\n                            renderer.draw_path(gc0, path, transform, rgbFace)\n\n            args = [offsets, offset_trf, self.get_facecolor(), self.get_edgecolor(),\n                    self._linewidths, self._linestyles, self._antialiaseds, self._urls,\n                    \"screen\"]\n\n            if hatchcolors_arg_supported:\n                renderer.draw_path_collection(gc, transform.frozen(), paths,\n                                              self.get_transforms(), *args,\n                                              hatchcolors=self.get_hatchcolor())\n            else:\n                if hatchcolors_not_needed:\n                    renderer.draw_path_collection(gc, transform.frozen(), paths,\n                                                  self.get_transforms(), *args)\n                else:\n                    path_ids = renderer._iter_collection_raw_paths(\n                        transform.frozen(), paths, self.get_transforms())\n                    for xo, yo, path_id, gc0, rgbFace in renderer._iter_collection(\n                        gc, list(path_ids), *args, hatchcolors=self.get_hatchcolor(),\n                    ):\n                        path, transform = path_id\n                        if xo != 0 or yo != 0:\n                            transform = transform.frozen()\n                            transform.translate(xo, yo)\n                        renderer.draw_path(gc0, path, transform, rgbFace)\n\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1202549934387207}
{"question": "Why does Matplotlib provide a backend system for different output formats (GUI, file, web)?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib provides a backend system for different output formats to support diverse use cases and deployment environments. The backend system addresses several key requirements: 1) Different use cases need different output capabilities - interactive exploration requires GUI backends (Qt, Tk, GTK, Wx, macOS), while publication requires file formats (PNG, PDF, SVG, PS), and web applications need web-compatible outputs, 2) Each output format has specific technical requirements - vector formats (PDF, SVG) need scalable graphics, raster formats (PNG) need pixel-perfect rendering, and GUI backends need event handling and real-time interaction, 3) The backend system enables the same plotting code to work across different environments without modification, supporting portability from development to production, 4) Different GUI toolkits have different event loops and integration requirements that require specialized backend implementations, 5) The system allows users to choose the most appropriate output method for their specific needs - interactive exploration vs. publication-quality output vs. web deployment, 6) Backend-specific optimizations can be implemented while maintaining a consistent high-level API, 7) The modular design enables easy addition of new output formats and GUI toolkits without modifying the core plotting code. This flexibility enables Matplotlib to serve users across different domains from scientific computing to web development to desktop applications.", "score": null, "retrieved_content": [{"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "test_savefig_backend", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "fig.savefig", "pytest.raises", "fig.savefig"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 600, "end_line": 607}, "code_snippet": "def test_savefig_backend():\n    fig = plt.figure()\n    # Intentionally use an invalid module name.\n    with pytest.raises(ModuleNotFoundError, match=\"No module named '@absent'\"):\n        fig.savefig(\"test\", backend=\"module://@absent\")\n    with pytest.raises(ValueError,\n                       match=\"The 'pdf' backend does not support png output\"):\n        fig.savefig(\"test.png\", backend=\"pdf\")\n", "type": "function"}, {"name": "_test_interactive_impl", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.rcParams.update", "mpl.rcParams.update", "lower", "mpl.use", "plt.subplots", "ax.plot", "fig.canvas.new_timer", "timer.add_callback", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "io.BytesIO", "fig.savefig", "plt.show", "plt.pause", "io.BytesIO", "fig.savefig", "json.loads", "backend.endswith", "plt.figure", "plt.close", "importlib.util.find_spec", "check_alt_backend", "fig.canvas.manager.get_window_title", "_test_toolbar_button_la_mode_icon", "fig.canvas.toolbar.draw_rubberband", "result.getvalue", "result_after.getvalue", "backend.startswith", "mpl.use", "plt.figure", "plt.close", "check_alt_backend", "type", "KeyEvent", "timer.start", "pytest.raises", "mpl.use", "type"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 156, "end_line": 236}, "code_snippet": "def _test_interactive_impl():\n    import importlib.util\n    import io\n    import json\n    import sys\n\n    import pytest\n\n    import matplotlib as mpl\n    from matplotlib import pyplot as plt\n    from matplotlib.backend_bases import KeyEvent\n    mpl.rcParams.update({\n        \"webagg.open_in_browser\": False,\n        \"webagg.port_retries\": 1,\n    })\n\n    mpl.rcParams.update(json.loads(sys.argv[1]))\n    backend = plt.rcParams[\"backend\"].lower()\n\n    if backend.endswith(\"agg\") and not backend.startswith((\"gtk\", \"web\")):\n        # Force interactive framework setup.\n        fig = plt.figure()\n        plt.close(fig)\n\n        # Check that we cannot switch to a backend using another interactive\n        # framework, but can switch to a backend using cairo instead of agg,\n        # or a non-interactive backend.  In the first case, we use tkagg as\n        # the \"other\" interactive backend as it is (essentially) guaranteed\n        # to be present.  Moreover, don't test switching away from gtk3 (as\n        # Gtk.main_level() is not set up at this point yet) and webagg (which\n        # uses no interactive framework).\n\n        if backend != \"tkagg\":\n            with pytest.raises(ImportError):\n                mpl.use(\"tkagg\", force=True)\n\n        def check_alt_backend(alt_backend):\n            mpl.use(alt_backend, force=True)\n            fig = plt.figure()\n            assert (type(fig.canvas).__module__ ==\n                    f\"matplotlib.backends.backend_{alt_backend}\")\n            plt.close(\"all\")\n\n        if importlib.util.find_spec(\"cairocffi\"):\n            check_alt_backend(backend[:-3] + \"cairo\")\n        check_alt_backend(\"svg\")\n    mpl.use(backend, force=True)\n\n    fig, ax = plt.subplots()\n    assert type(fig.canvas).__module__ == f\"matplotlib.backends.backend_{backend}\"\n\n    assert fig.canvas.manager.get_window_title() == \"Figure 1\"\n\n    if mpl.rcParams[\"toolbar\"] == \"toolmanager\":\n        # test toolbar button icon LA mode see GH issue 25174\n        _test_toolbar_button_la_mode_icon(fig)\n\n    ax.plot([0, 1], [2, 3])\n    if fig.canvas.toolbar:  # i.e toolbar2.\n        fig.canvas.toolbar.draw_rubberband(None, 1., 1, 2., 2)\n\n    timer = fig.canvas.new_timer(1.)  # Test that floats are cast to int.\n    timer.add_callback(KeyEvent(\"key_press_event\", fig.canvas, \"q\")._process)\n    # Trigger quitting upon draw.\n    fig.canvas.mpl_connect(\"draw_event\", lambda event: timer.start())\n    fig.canvas.mpl_connect(\"close_event\", print)\n\n    result = io.BytesIO()\n    fig.savefig(result, format='png')\n\n    plt.show()\n\n    # Ensure that the window is really closed.\n    plt.pause(0.5)\n\n    # Test that saving works after interactive window is closed, but the figure\n    # is not deleted.\n    result_after = io.BytesIO()\n    fig.savefig(result_after, format='png')\n\n    assert result.getvalue() == result_after.getvalue()\n", "type": "function"}, {"name": "_BackendWebAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 326, "end_line": 328}, "type": "class"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "use", "is_method": false, "class_name": null, "parameters": ["backend"], "calls": ["rcsetup.validate_backend", "rcParams._get_backend_or_none", "sys.modules.get", "plt.switch_backend"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1189, "end_line": 1259}, "code_snippet": "def use(backend, *, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    If pyplot is already imported, `~matplotlib.pyplot.switch_backend` is used\n    and if the new backend is different than the current backend, all Figures\n    will be closed.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg, notebook, QtAgg,\n          QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo, Qt5Agg, Qt5Cairo\n\n        - non-interactive backends:\n          agg, cairo, pdf, pgf, ps, svg, template\n\n        or a string of the form: ``module://my.module.name``.\n\n        notebook is a synonym for nbAgg.\n\n        Switching to an interactive backend is not possible if an unrelated\n        event loop has already been started (e.g., switching to GTK3Agg if a\n        TkAgg window has already been opened).  Switching to a non-interactive\n        backend is always possible.\n\n    force : bool, default: True\n        If True (the default), raise an `ImportError` if the backend cannot be\n        set up (either because it fails to import, or because an incompatible\n        GUI interactive framework is already running); if False, silently\n        ignore the failure.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    matplotlib.pyplot.switch_backend\n\n    \"\"\"\n    name = rcsetup.validate_backend(backend)\n    # don't (prematurely) resolve the \"auto\" backend setting\n    if rcParams._get_backend_or_none() == name:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # if pyplot is not already imported, do not import it.  Doing\n        # so may trigger a `plt.switch_backend` to the _default_ backend\n        # before we get a chance to change to the one the user just requested\n        plt = sys.modules.get('matplotlib.pyplot')\n        # if pyplot is imported, then try to change backends\n        if plt is not None:\n            try:\n                # we need this import check here to re-raise if the\n                # user does not have the libraries to support their\n                # chosen backend installed.\n                plt.switch_backend(name)\n            except ImportError:\n                if force:\n                    raise\n        # if we have not imported pyplot, then we can set the rcParam\n        # value which will be respected when the user finally imports\n        # pyplot\n        else:\n            rcParams['backend'] = backend\n    # if the user has asked for a given backend, do not helpfully\n    # fallback\n    rcParams['backend_fallback'] = False\n", "type": "function"}, {"name": "FigureManagerBase", "docstring": "A backend-independent abstraction of a figure container and controller.\n\nThe figure manager is used by pyplot to interact with the window in a\nbackend-independent way. It's an adapter for the real (GUI) framework that\nrepresents the visual figure on screen.\n\nThe figure manager is connected to a specific canvas instance, which in turn\nis connected to a specific figure instance. To access a figure manager for\na given figure in user code, you typically use ``fig.canvas.manager``.\n\nGUI backends derive from this class to translate common operations such\nas *show* or *resize* to the GUI-specific code. Non-GUI backends do not\nsupport these operations and can just use the base class.\n\nThis following basic operations are accessible:\n\n**Window operations**\n\n- `~.FigureManagerBase.show`\n- `~.FigureManagerBase.destroy`\n- `~.FigureManagerBase.full_screen_toggle`\n- `~.FigureManagerBase.resize`\n- `~.FigureManagerBase.get_window_title`\n- `~.FigureManagerBase.set_window_title`\n\n**Key and mouse button press handling**\n\nThe figure manager sets up default key and mouse button press handling by\nhooking up the `.key_press_handler` to the matplotlib event system. This\nensures the same shortcuts and mouse actions across backends.\n\n**Other operations**\n\nSubclasses will have additional attributes and functions to access\nadditional functionality. This is of course backend-specific. For example,\nmost GUI backends have ``window`` and ``toolbar`` attributes that give\naccess to the native GUI widgets of the respective framework.\n\nAttributes\n----------\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance.\n\nnum : int or str\n    The figure number.\n\nkey_press_handler_id : int\n    The default key handler cid, when using the toolmanager.\n    To disable the default key press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.key_press_handler_id)\n\nbutton_press_handler_id : int\n    The default mouse button handler cid, when using the toolmanager.\n    To disable the default button press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.button_press_handler_id)", "methods": ["__init__", "create_with_canvas", "start_main_loop", "pyplot_show", "show", "destroy", "full_screen_toggle", "resize", "get_window_title", "set_window_title"], "attributes": ["_toolbar2_class", "_toolmanager_toolbar_class"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2582, "end_line": 2787}, "type": "class"}, {"name": "_BackendWebAggCoreAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_webagg_core.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 523, "end_line": 525}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1813888549804688}
{"question": "Why does Matplotlib provide both pyplot and object-oriented interfaces?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib provides both pyplot and object-oriented interfaces to serve different use cases and accommodate different programming styles. The dual interface design addresses several key requirements: 1) The pyplot interface provides a MATLAB-like, state-based interface that's convenient for interactive work and simple scripts, while the object-oriented API offers explicit control for complex plots and programmatic use, 2) The pyplot interface maintains global state (current Figure and Axes) which simplifies common operations but can become unwieldy for complex plots with multiple subplots, 3) The object-oriented API provides explicit references to Figure and Axes objects, enabling precise control over plot elements and better code organization for complex visualizations, 4) The separation allows users to choose the appropriate interface for their needs - pyplot for quick exploration and simple plots, object-oriented API for production code and complex customizations, 5) The pyplot interface serves as a convenience layer that reduces boilerplate code for common operations, while the object-oriented API exposes the full power and flexibility of the underlying system, 6) This design supports different programming styles and skill levels, from beginners who prefer the simplicity of pyplot to advanced users who need fine-grained control, 7) The separation enables better code maintainability and allows the core object-oriented system to evolve independently of the convenience interface. This dual approach enables Matplotlib to serve a wide range of users from casual data exploration to complex scientific visualization.", "score": null, "retrieved_content": [{"name": "test_figure_label", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.close", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.figure", "plt.close", "plt.close", "plt.close", "plt.close", "plt.figure", "plt.get_fignums", "plt.get_figlabels", "plt.get_fignums", "plt.get_figlabels", "plt.gcf", "pytest.raises", "plt.figure", "Figure"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 130, "end_line": 151}, "code_snippet": "def test_figure_label():\n    # pyplot figure creation, selection, and closing with label/number/instance\n    plt.close('all')\n    fig_today = plt.figure('today')\n    plt.figure(3)\n    plt.figure('tomorrow')\n    plt.figure()\n    plt.figure(0)\n    plt.figure(1)\n    plt.figure(3)\n    assert plt.get_fignums() == [0, 1, 3, 4, 5]\n    assert plt.get_figlabels() == ['', 'today', '', 'tomorrow', '']\n    plt.close(10)\n    plt.close()\n    plt.close(5)\n    plt.close('tomorrow')\n    assert plt.get_fignums() == [0, 1]\n    assert plt.get_figlabels() == ['', 'today']\n    plt.figure(fig_today)\n    assert plt.gcf() == fig_today\n    with pytest.raises(ValueError):\n        plt.figure(Figure())\n", "type": "function"}, {"name": "test_no_pyplot", "is_method": false, "class_name": null, "parameters": [], "calls": ["mfigure.Figure", "FigureCanvasPdf", "fig.add_subplot", "ax.plot", "pickle.dump", "BytesIO"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 185, "end_line": 192}, "code_snippet": "def test_no_pyplot():\n    # tests pickle-ability of a figure not created with pyplot\n    from matplotlib.backends.backend_pdf import FigureCanvasPdf\n    fig = mfigure.Figure()\n    _ = FigureCanvasPdf(fig)\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1, 2, 3], [1, 2, 3])\n    pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "_save_figure", "is_method": false, "class_name": null, "parameters": ["objects", "fmt", "usetex"], "calls": ["mpl.use", "mpl.rcParams.update", "plt.figure", "iter", "fig.subplots_adjust", "range", "add_subplot", "ax.plot", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "getattr", "fig.savefig", "fig.add_subplot", "range", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "fig.add_subplot", "ax2.set_xticks", "zip", "fig.subplots", "imshow", "imshow", "imshow", "fig.subfigures", "add_subplot", "px.imshow", "pimg.set_clip_path", "add_subplot", "plt.imread", "TextPath", "PathClippedImagePatch", "AuxTransformBox", "offsetbox.add_artist", "AnchoredOffsetbox", "ax.add_artist", "deepcopy", "deepcopy", "Path.make_compound_path", "deepcopy", "subplots", "len", "plot_markers", "plot_hatch", "plot_image", "plot_paths", "ax2.bar", "ax2.bar", "bar.set_hatch", "Circle", "get_sample_data", "IdentityTransform", "PathCollection", "collection.set_clip_path", "ax1.add_collection", "PathPatch", "patch.set_clip_path", "ax2.add_patch", "ax1.set_xlim", "ax1.set_ylim", "fig.subfigures", "next", "next", "next", "next", "next", "range", "range", "range", "__init__", "BboxImage", "self.bbox_image.set_data", "set_facecolor", "self.bbox_image.set_clip_path", "self.bbox_image.draw", "draw", "Path.unit_rectangle", "Path.unit_circle", "Path.unit_regular_star", "dict", "range", "self.get_transform", "super", "super", "super"], "code_location": {"file": "test_determinism.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 25, "end_line": 154}, "code_snippet": "def _save_figure(objects='mhip', fmt=\"pdf\", usetex=False):\n    mpl.use(fmt)\n    mpl.rcParams.update({'svg.hashsalt': 'asdf', 'text.usetex': usetex})\n\n    def plot_markers(fig):\n        # use different markers...\n        ax = fig.add_subplot()\n        x = range(10)\n        ax.plot(x, [1] * 10, marker='D')\n        ax.plot(x, [2] * 10, marker='x')\n        ax.plot(x, [3] * 10, marker='^')\n        ax.plot(x, [4] * 10, marker='H')\n        ax.plot(x, [5] * 10, marker='v')\n\n    def plot_hatch(fig):\n        # also use different hatch patterns\n        ax2 = fig.add_subplot()\n        bars = (ax2.bar(range(1, 5), range(1, 5)) +\n                ax2.bar(range(1, 5), [6] * 4, bottom=range(1, 5)))\n        ax2.set_xticks([1.5, 2.5, 3.5, 4.5])\n\n        patterns = ('-', '+', 'x', '\\\\', '*', 'o', 'O', '.')\n        for bar, pattern in zip(bars, patterns):\n            bar.set_hatch(pattern)\n\n    def plot_image(fig):\n        axs = fig.subplots(1, 3, sharex=True, sharey=True)\n        # also use different images\n        A = [[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n        axs[0].imshow(A, interpolation='nearest')\n        A = [[1, 3, 2], [1, 2, 3], [3, 1, 2]]\n        axs[1].imshow(A, interpolation='bilinear')\n        A = [[2, 3, 1], [1, 2, 3], [2, 1, 3]]\n        axs[2].imshow(A, interpolation='bicubic')\n\n    def plot_paths(fig):\n        # clipping support class, copied from demo_text_path.py gallery example\n        class PathClippedImagePatch(PathPatch):\n            \"\"\"\n            The given image is used to draw the face of the patch. Internally,\n            it uses BboxImage whose clippath set to the path of the patch.\n\n            FIXME : The result is currently dpi dependent.\n            \"\"\"\n\n            def __init__(self, path, bbox_image, **kwargs):\n                super().__init__(path, **kwargs)\n                self.bbox_image = BboxImage(\n                    self.get_window_extent, norm=None, origin=None)\n                self.bbox_image.set_data(bbox_image)\n\n            def set_facecolor(self, color):\n                \"\"\"Simply ignore facecolor.\"\"\"\n                super().set_facecolor(\"none\")\n\n            def draw(self, renderer=None):\n                # the clip path must be updated every draw. any solution? -JJ\n                self.bbox_image.set_clip_path(self._path, self.get_transform())\n                self.bbox_image.draw(renderer)\n                super().draw(renderer)\n\n        subfigs = fig.subfigures(1, 3)\n\n        # add a polar projection\n        px = subfigs[0].add_subplot(projection=\"polar\")\n        pimg = px.imshow([[2]])\n        pimg.set_clip_path(Circle((0, 1), radius=0.3333))\n\n        # add a text-based clipping path (origin: demo_text_path.py)\n        ax = subfigs[1].add_subplot()\n        arr = plt.imread(get_sample_data(\"grace_hopper.jpg\"))\n        text_path = TextPath((0, 0), \"!?\", size=150)\n        p = PathClippedImagePatch(text_path, arr, ec=\"k\")\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(p)\n        ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,\n                               borderpad=0.2)\n        ax.add_artist(ao)\n\n        # add a 2x2 grid of path-clipped axes (origin: test_artist.py)\n        exterior = Path.unit_rectangle().deepcopy()\n        exterior.vertices *= 4\n        exterior.vertices -= 2\n        interior = Path.unit_circle().deepcopy()\n        interior.vertices = interior.vertices[::-1]\n        clip_path = Path.make_compound_path(exterior, interior)\n\n        star = Path.unit_regular_star(6).deepcopy()\n        star.vertices *= 2.6\n\n        (row1, row2) = subfigs[2].subplots(2, 2, sharex=True, sharey=True,\n                                           gridspec_kw=dict(hspace=0, wspace=0))\n        for row in (row1, row2):\n            ax1, ax2 = row\n            collection = PathCollection([star], lw=5, edgecolor='blue',\n                                        facecolor='red', alpha=0.7, hatch='*')\n            collection.set_clip_path(clip_path, ax1.transData)\n            ax1.add_collection(collection)\n\n            patch = PathPatch(star, lw=5, edgecolor='blue', facecolor='red',\n                              alpha=0.7, hatch='*')\n            patch.set_clip_path(clip_path, ax2.transData)\n            ax2.add_patch(patch)\n\n            ax1.set_xlim([-3, 3])\n            ax1.set_ylim([-3, 3])\n\n    nfigs = len(objects) + 1\n    fig = plt.figure(figsize=(7, 3 * nfigs))\n    subfigs = iter(fig.subfigures(nfigs, squeeze=False).flat)\n    fig.subplots_adjust(bottom=0.15)\n\n    if 'm' in objects:\n        plot_markers(next(subfigs))\n    if 'h' in objects:\n        plot_hatch(next(subfigs))\n    if 'i' in objects:\n        plot_image(next(subfigs))\n    if 'p' in objects:\n        plot_paths(next(subfigs))\n\n    x = range(5)\n    ax = next(subfigs).add_subplot()\n    ax.plot(x, x)\n    ax.set_title('A string $1+2+\\\\sigma$')\n    ax.set_xlabel('A string $1+2+\\\\sigma$')\n    ax.set_ylabel('A string $1+2+\\\\sigma$')\n\n    stdout = getattr(sys.stdout, 'buffer', sys.stdout)\n    fig.savefig(stdout, format=fmt)\n", "type": "function"}, {"name": "test_savefig", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "fig.savefig"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 586, "end_line": 590}, "code_snippet": "def test_savefig():\n    fig = plt.figure()\n    msg = r\"savefig\\(\\) takes 2 positional arguments but 3 were given\"\n    with pytest.raises(TypeError, match=msg):\n        fig.savefig(\"fname1.png\", \"fname2.png\")\n", "type": "function"}, {"name": "pyplot_show", "is_method": true, "class_name": "FigureManagerWebAgg", "parameters": ["cls"], "calls": ["WebAggApplication.initialize", "format", "WebAggApplication.start", "print", "webbrowser.open", "print"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 48, "end_line": 63}, "code_snippet": "    def pyplot_show(cls, *, block=None):\n        WebAggApplication.initialize()\n\n        url = \"http://{address}:{port}{prefix}\".format(\n            address=WebAggApplication.address,\n            port=WebAggApplication.port,\n            prefix=WebAggApplication.url_prefix)\n\n        if mpl.rcParams['webagg.open_in_browser']:\n            import webbrowser\n            if not webbrowser.open(url):\n                print(f\"To view figure, visit {url}\")\n        else:\n            print(f\"To view figure, visit {url}\")\n\n        WebAggApplication.start()\n", "type": "function"}, {"name": "main", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "np.arange", "zip", "ax.set_xlim", "ax.set_ylim", "np.zeros", "ax.imshow", "plt.show", "Bbox.from_extents", "TransformedBbox", "ax.add_artist", "ax.annotate", "RibbonBoxImage", "str"], "code_location": {"file": "demo_ribbon_box.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 63, "end_line": 91}, "code_snippet": "def main():\n    fig, ax = plt.subplots()\n\n    years = np.arange(2004, 2009)\n    heights = [7900, 8100, 7900, 6900, 2800]\n    box_colors = [\n        (0.8, 0.2, 0.2),\n        (0.2, 0.8, 0.2),\n        (0.2, 0.2, 0.8),\n        (0.7, 0.5, 0.8),\n        (0.3, 0.8, 0.7),\n    ]\n\n    for year, h, bc in zip(years, heights, box_colors):\n        bbox0 = Bbox.from_extents(year - 0.4, 0., year + 0.4, h)\n        bbox = TransformedBbox(bbox0, ax.transData)\n        ax.add_artist(RibbonBoxImage(ax, bbox, bc, interpolation=\"bicubic\"))\n        ax.annotate(str(h), (year, h), va=\"bottom\", ha=\"center\")\n\n    ax.set_xlim(years[0] - 0.5, years[-1] + 0.5)\n    ax.set_ylim(0, 10000)\n\n    background_gradient = np.zeros((2, 2, 4))\n    background_gradient[:, :, :3] = [1, 1, 0]\n    background_gradient[:, :, 3] = [[0.1, 0.3], [0.3, 0.5]]  # alpha channel\n    ax.imshow(background_gradient, interpolation=\"bicubic\", zorder=0.1,\n              extent=(0, 1, 0, 1), transform=ax.transAxes)\n\n    plt.show()\n", "type": "function"}, {"name": "test_old_subplot_compat", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "isinstance", "fig.add_subplot", "isinstance", "pytest.raises", "Axes", "fig.add_axes"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 288, "end_line": 293}, "code_snippet": "def test_old_subplot_compat():\n    fig = plt.figure()\n    assert isinstance(fig.add_subplot(), SubplotBase)\n    assert not isinstance(fig.add_axes(rect=[0, 0, 1, 1]), SubplotBase)\n    with pytest.raises(TypeError):\n        Axes(fig, [0, 0, 1, 1], rect=[0, 0, 1, 1])\n", "type": "function"}, {"name": "test_pyplot_box", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.box", "plt.box", "ax.get_frame_on", "plt.box", "plt.box", "ax.get_frame_on", "ax.get_frame_on", "ax.get_frame_on"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 67, "end_line": 76}, "code_snippet": "def test_pyplot_box():\n    fig, ax = plt.subplots()\n    plt.box(False)\n    assert not ax.get_frame_on()\n    plt.box(True)\n    assert ax.get_frame_on()\n    plt.box()\n    assert not ax.get_frame_on()\n    plt.box()\n    assert ax.get_frame_on()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2037239074707031}
{"question": "Where in Matplotlib is the event handling system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event handling system is implemented across several key locations in the codebase. The main components are: 1) The core event system is defined in lib/matplotlib/backend_bases.py, which contains the abstract base classes Event, LocationEvent, MouseEvent, KeyEvent, and other event types, along with the callback management system, 2) The FigureCanvasBase class in backend_bases.py provides the mpl_connect() and mpl_disconnect() methods that manage event connections and the callback registry, 3) Backend-specific event handling implementations are located in the respective backend modules - for example, the macOS backend implementation is in src/_macosx.m, which contains Objective-C code for handling mouse clicks, key presses, and other GUI events, 4) The event processing pipeline is implemented in backend_bases.py with functions like _mouse_handler() and _key_handler() that process raw events and convert them into Matplotlib-specific event objects, 5) Event coordinate transformation and axes detection is handled in the LocationEvent class, which converts pixel coordinates to data coordinates and determines which Axes the event occurred in, 6) The interactive features like panning and zooming are implemented in lib/matplotlib/backend_bases.py through the NavigationToolbar2 class and related navigation classes, 7) Event loop integration for different GUI toolkits is handled in the respective backend implementations (Qt, Tk, GTK, Wx, macOS), each providing the necessary glue code to connect GUI toolkit events to Matplotlib's event system, 8) The event system documentation and examples are provided in galleries/users_explain/figure/event_handling.rst and galleries/examples/event_handling/. This architecture provides a GUI-neutral event interface while allowing backend-specific optimizations and integrations.", "score": null, "retrieved_content": [{"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "Event", "docstring": "A Matplotlib event.\n\nThe following attributes are defined and shown with their default values.\nSubclasses may define additional attributes.\n\nAttributes\n----------\nname : str\n    The event name.\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance generating the event.\nguiEvent\n    The GUI event that triggered the Matplotlib event.", "methods": ["__init__", "_process"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1170, "end_line": 1195}, "type": "class"}, {"name": "enter_notify_event", "is_method": true, "class_name": "FigureCanvasTk", "parameters": ["self", "event"], "calls": ["_process", "LocationEvent", "self._event_mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 303, "end_line": 307}, "code_snippet": "    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n", "type": "function"}, {"name": "LocationEvent", "docstring": "An event that has a screen location.\n\nA LocationEvent has a number of special attributes in addition to those\ndefined by the parent `Event` class.\n\nAttributes\n----------\nx, y : int or None\n    Event location in pixels from bottom left of canvas.\ninaxes : `~matplotlib.axes.Axes` or None\n    The `~.axes.Axes` instance over which the mouse is, if any.\nxdata, ydata : float or None\n    Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n    is not over an Axes.\nmodifiers : frozenset\n    The keyboard modifiers currently being pressed (except for KeyEvent).", "methods": ["__init__", "_set_inaxes"], "attributes": ["_last_axes_ref"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1249, "end_line": 1304}, "type": "class"}, {"name": "button_press_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 131, "end_line": 136}, "code_snippet": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 157, "end_line": 162}, "code_snippet": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "enter_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["get_modifier_state", "_process", "Gdk.Keymap.get_for_display", "LocationEvent", "self.get_display", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 164, "end_line": 169}, "code_snippet": "    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasTk", "parameters": ["self", "event"], "calls": ["_process", "MouseEvent", "self._event_mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 296, "end_line": 301}, "code_snippet": "    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolSetCursor", "parameters": ["self"], "calls": ["__init__", "self.toolmanager.toolmanager_connect", "self.toolmanager.tools.values", "self._add_tool_cbk", "super", "mpl.backend_managers.ToolEvent"], "code_location": {"file": "backend_tools.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 256, "end_line": 266}, "code_snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._id_drag = None\n        self._current_tool = None\n        self._default_cursor = cursors.POINTER\n        self._last_cursor = self._default_cursor\n        self.toolmanager.toolmanager_connect('tool_added_event',\n                                             self._add_tool_cbk)\n        for tool in self.toolmanager.tools.values():  # process current tools\n            self._add_tool_cbk(mpl.backend_managers.ToolEvent(\n                'tool_added_event', self.toolmanager, tool))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.188624382019043}
{"question": "Where does the control flow when Matplotlib manages the figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib manages the figure and axes hierarchy, the control flow follows a structured parent-child relationship system. The control flow operates as follows: 1) The Figure class serves as the top-level container and manages the overall hierarchy through its _axstack attribute, which tracks all Axes objects in insertion order, 2) When Axes are created (via add_subplot(), add_axes(), or subplots()), they are automatically added to the Figure's _axstack and their parent reference is set to the Figure, 3) The Figure's gca() method returns the current active Axes from the stack, and sca() method sets the current Axes, managing the active state, 4) Each Axes object maintains its own hierarchy of child Artists (lines, text, patches, etc.) and manages their lifecycle through methods like add_line(), add_patch(), etc., 5) The control flow for rendering follows the hierarchy: Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 6) When Artists are modified, the 'stale' state propagates up the hierarchy - if an Artist becomes stale, its parent Axes becomes stale, and if an Axes becomes stale, the parent Figure becomes stale, 7) The Figure manages layout through methods like subplots_adjust() and constrained_layout, which control the positioning and sizing of child Axes, 8) For complex layouts, the Figure can contain SubFigure objects, which themselves can contain Axes, creating a nested hierarchy, 9) The control flow ensures that changes to child objects properly notify their parents, enabling efficient rendering by only redrawing what has changed. This hierarchical management system provides a clean separation of concerns while maintaining the relationships necessary for proper rendering and interaction.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "FigureManagerBase", "parameters": ["self", "canvas", "num"], "calls": ["self.set_window_title", "self.canvas.mpl_connect", "self.canvas.mpl_connect", "ToolManager", "self._toolbar2_class", "tools.add_tools_to_manager", "self._toolmanager_toolbar_class", "tools.add_tools_to_container", "self.toolbar.update"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2648, "end_line": 2683}, "code_snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n        self.set_window_title(f\"Figure {num:d}\")\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event', key_press_handler)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event', button_press_handler)\n\n        self.toolmanager = (ToolManager(canvas.figure)\n                            if mpl.rcParams['toolbar'] == 'toolmanager'\n                            else None)\n        if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n                and self._toolbar2_class):\n            self.toolbar = self._toolbar2_class(self.canvas)\n        elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n                and self._toolmanager_toolbar_class):\n            self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n        else:\n            self.toolbar = None\n\n        if self.toolmanager:\n            tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                tools.add_tools_to_container(self.toolbar)\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current Axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()\n", "type": "function"}, {"name": "Gcf", "docstring": "Singleton to maintain the relation between figures and their managers, and\nkeep track of and \"active\" figure and manager.\n\nThe canvas of a figure created through pyplot is associated with a figure\nmanager, which handles the interaction between the figure and the backend.\npyplot keeps track of figure managers using an identifier, the \"figure\nnumber\" or \"manager number\" (which can actually be any hashable value);\nthis number is available as the :attr:`number` attribute of the manager.\n\nThis class is never instantiated; it consists of an `OrderedDict` mapping\nfigure/manager numbers to managers, and a set of class methods that\nmanipulate this `OrderedDict`.\n\nAttributes\n----------\nfigs : OrderedDict\n    `OrderedDict` mapping numbers to managers; the active manager is at the\n    end.", "methods": ["get_fig_manager", "destroy", "destroy_fig", "destroy_all", "has_fignum", "get_all_fig_managers", "get_num_fig_managers", "get_active", "_set_new_active_manager", "set_active", "draw_all"], "attributes": ["figs"], "code_location": {"file": "_pylab_helpers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 9, "end_line": 131}, "type": "class"}, {"name": "FigureManagerBase", "docstring": "A backend-independent abstraction of a figure container and controller.\n\nThe figure manager is used by pyplot to interact with the window in a\nbackend-independent way. It's an adapter for the real (GUI) framework that\nrepresents the visual figure on screen.\n\nThe figure manager is connected to a specific canvas instance, which in turn\nis connected to a specific figure instance. To access a figure manager for\na given figure in user code, you typically use ``fig.canvas.manager``.\n\nGUI backends derive from this class to translate common operations such\nas *show* or *resize* to the GUI-specific code. Non-GUI backends do not\nsupport these operations and can just use the base class.\n\nThis following basic operations are accessible:\n\n**Window operations**\n\n- `~.FigureManagerBase.show`\n- `~.FigureManagerBase.destroy`\n- `~.FigureManagerBase.full_screen_toggle`\n- `~.FigureManagerBase.resize`\n- `~.FigureManagerBase.get_window_title`\n- `~.FigureManagerBase.set_window_title`\n\n**Key and mouse button press handling**\n\nThe figure manager sets up default key and mouse button press handling by\nhooking up the `.key_press_handler` to the matplotlib event system. This\nensures the same shortcuts and mouse actions across backends.\n\n**Other operations**\n\nSubclasses will have additional attributes and functions to access\nadditional functionality. This is of course backend-specific. For example,\nmost GUI backends have ``window`` and ``toolbar`` attributes that give\naccess to the native GUI widgets of the respective framework.\n\nAttributes\n----------\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance.\n\nnum : int or str\n    The figure number.\n\nkey_press_handler_id : int\n    The default key handler cid, when using the toolmanager.\n    To disable the default key press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.key_press_handler_id)\n\nbutton_press_handler_id : int\n    The default mouse button handler cid, when using the toolmanager.\n    To disable the default button press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.button_press_handler_id)", "methods": ["__init__", "create_with_canvas", "start_main_loop", "pyplot_show", "show", "destroy", "full_screen_toggle", "resize", "get_window_title", "set_window_title"], "attributes": ["_toolbar2_class", "_toolmanager_toolbar_class"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2582, "end_line": 2787}, "type": "class"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "test_pyplot_axes", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.subplots", "plt.sca", "plt.close", "plt.close", "plt.gca", "plt.gcf"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3283, "end_line": 3291}, "code_snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)\n", "type": "function"}, {"name": "test_get_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "sfig1.subfigures", "sfig2.subplots", "mlines.Line2D", "fig.get_figure", "fig.get_figure", "ax.get_figure", "ax.get_figure", "ax.get_figure", "sfig2.get_figure", "sfig2.get_figure", "pytest.warns", "sfig1.get_figure", "ln.get_figure", "ln.get_figure", "sfig2.get_figure"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 598}, "code_snippet": "def test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3Agg", "parameters": ["self", "figure"], "calls": ["__init__", "super"], "code_location": {"file": "backend_gtk3agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 12, "end_line": 14}, "code_snippet": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasMac", "parameters": ["self", "figure"], "calls": ["__init__", "set", "super"], "code_location": {"file": "backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 42, "end_line": 47}, "code_snippet": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._draw_pending = False\n        self._is_drawing = False\n        # Keep track of the timers that are alive\n        self._timers = set()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasBase", "parameters": ["self", "figure"], "calls": ["self._fix_ipython_backend2gui", "figure.set_canvas", "widgets.LockDraw", "__init__", "Figure", "super"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1749, "end_line": 1768}, "code_snippet": "    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.2084908485412598}
{"question": "Where does Matplotlib store its backend implementations?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib stores its backend implementations in several organized locations within the codebase. The main storage locations are: 1) The lib/matplotlib/backends/ directory contains most of the Python-based backend implementations, organized by type - interactive backends (like qt5agg.py, tkagg.py, gtk3agg.py) and non-interactive backends (like pdf.py, svg.py, ps.py), 2) The src/ directory contains C++ implementations for performance-critical backends, particularly the Agg backend in src/_backend_agg.h and src/_backend_agg.cpp, which is the primary raster renderer, 3) The lib/matplotlib/backends/backend_bases.py file contains the abstract base classes (RendererBase, FigureCanvasBase, etc.) that define the interface all backends must implement, 4) Backend-specific wrapper code and bindings are stored in src/_backend_agg_wrapper.cpp for the Agg backend, and similar wrapper files for other C++ backends, 5) The lib/matplotlib/backends/backend_template.py provides a template for creating new backends, serving as documentation and a starting point for custom backend development, 6) Configuration and registration of available backends is handled in lib/matplotlib/backends/__init__.py, which maintains the mapping between backend names and their implementation classes, 7) Some specialized backends like the web backend are stored in lib/matplotlib/backends/web_backend/ with their associated JavaScript and HTML files. This organization separates the abstract interface definitions from the concrete implementations, allowing for easy addition of new backends while maintaining a consistent API across all output formats and GUI toolkits.", "score": null, "retrieved_content": [{"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "_implcore", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 376, "end_line": 382}, "code_snippet": "def _implcore():\n    import matplotlib.backends.backend_qt5  # noqa\n    import sys\n\n    assert 'PyQt6' not in sys.modules\n    assert 'pyside6' not in sys.modules\n    assert 'PyQt5' in sys.modules or 'pyside2' in sys.modules\n", "type": "function"}, {"name": "_implqt5agg", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 358, "end_line": 364}, "code_snippet": "def _implqt5agg():\n    import matplotlib.backends.backend_qt5agg  # noqa\n    import sys\n\n    assert 'PyQt6' not in sys.modules\n    assert 'pyside6' not in sys.modules\n    assert 'PyQt5' in sys.modules or 'pyside2' in sys.modules\n", "type": "function"}, {"name": "_implcairo", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 367, "end_line": 373}, "code_snippet": "def _implcairo():\n    import matplotlib.backends.backend_qt5cairo  # noqa\n    import sys\n\n    assert 'PyQt6' not in sys.modules\n    assert 'pyside6' not in sys.modules\n    assert 'PyQt5' in sys.modules or 'pyside2' in sys.modules\n", "type": "function"}, {"name": "_read_entry_points", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": ["im.entry_points", "backward_compatible_entry_points", "backward_compatible_entry_points", "im.version", "_parse_to_version_info", "entries.append"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 128, "end_line": 163}, "code_snippet": "    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entry.name, entry.value) for entry in entry_points]\n\n        # For backward compatibility, if matplotlib-inline and/or ipympl are installed\n        # but too old to include entry points, create them. Do not import ipympl\n        # directly as this calls matplotlib.use() whilst in this function.\n        def backward_compatible_entry_points(\n                entries, module_name, threshold_version, names, target):\n            from matplotlib import _parse_to_version_info\n            try:\n                module_version = im.version(module_name)\n                if _parse_to_version_info(module_version) < threshold_version:\n                    for name in names:\n                        entries.append((name, target))\n            except im.PackageNotFoundError:\n                pass\n\n        names = [entry[0] for entry in entries]\n        if \"inline\" not in names:\n            backward_compatible_entry_points(\n                entries, \"matplotlib_inline\", (0, 1, 7), [\"inline\"],\n                \"matplotlib_inline.backend_inline\")\n        if \"ipympl\" not in names:\n            backward_compatible_entry_points(\n                entries, \"ipympl\", (0, 9, 4), [\"ipympl\", \"widget\"],\n                \"ipympl.backend_nbagg\")\n\n        return entries\n", "type": "function"}, {"name": "test_entry_points_ipympl", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.importorskip", "backend_registry.list_all"], "code_location": {"file": "test_backend_registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 103, "end_line": 107}, "code_snippet": "def test_entry_points_ipympl():\n    pytest.importorskip('ipympl')\n    backends = backend_registry.list_all()\n    assert 'ipympl' in backends\n    assert 'widget' in backends\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "BackendFilter", "docstring": "Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n.. versionadded:: 3.9", "methods": [], "attributes": ["INTERACTIVE", "NON_INTERACTIVE"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 5, "end_line": 12}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.2111666202545166}
{"question": "Where does Matplotlib implement its Artist hierarchy management?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its Artist hierarchy management across several key locations in the codebase. The main components are: 1) The core Artist class in lib/matplotlib/artist.py defines the base class for all visual elements and provides the fundamental hierarchy management through methods like get_children(), set_figure(), and get_figure(), 2) The Figure class in lib/matplotlib/figure.py manages the top-level hierarchy through its _axstack attribute (implemented by the _AxesStack class) which tracks all Axes objects and manages the current active Axes, 3) The FigureBase class in figure.py provides the base functionality for both Figure and SubFigure classes, including methods for adding and managing child Artists, 4) The Axes class in lib/matplotlib/axes/_axes.py manages its own hierarchy of child Artists (lines, text, patches, etc.) through lists like self.lines, self.texts, self.patches, and methods like add_line(), add_patch(), etc., 5) The parent-child relationships are maintained through the _parent_figure attribute in Artist objects and the axes attribute that links Artists to their containing Axes, 6) The stale state propagation system is implemented in artist.py through the stale_callback mechanism, which automatically propagates changes up the hierarchy when Artists are modified, 7) The rendering hierarchy is managed through the draw() method chain, where Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 8) The Artist API documentation and type hints are provided in lib/matplotlib/artist.pyi, which defines the interface for the hierarchy management methods. This hierarchical system provides a clean separation of concerns while maintaining the relationships necessary for proper rendering, event handling, and state management.", "score": null, "retrieved_content": [{"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Axis", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1276, "end_line": 1279}, "code_snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}, {"name": "axes", "is_method": true, "class_name": "OffsetBox", "parameters": ["self", "ax"], "calls": ["martist.Artist.axes.fset", "self.get_children"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 234, "end_line": 239}, "code_snippet": "    def axes(self, ax):\n        # TODO deal with this better\n        martist.Artist.axes.fset(self, ax)\n        for c in self.get_children():\n            if c is not None:\n                c.axes = ax\n", "type": "function"}, {"name": "ArtistInspector", "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.", "methods": ["__init__", "get_aliases", "get_valid_values", "_replace_path", "get_setters", "number_of_parameters", "is_alias", "aliased_name", "aliased_name_rest", "pprint_setters", "pprint_setters_rest", "properties", "pprint_getters"], "attributes": ["_get_valid_values_regex", "_NOT_LINKABLE"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1421, "end_line": 1720}, "type": "class"}, {"name": "OffsetBox", "docstring": "A simple container artist.\n\nThe child artists are meant to be drawn at a relative position to its\nparent.\n\nBeing an artist itself, all keyword arguments are passed on to `.Artist`.", "methods": ["__init__", "set_figure", "axes", "contains", "set_offset", "get_offset", "set_width", "set_height", "get_visible_children", "get_children", "_get_bbox_and_child_offsets", "get_bbox", "get_window_extent", "draw"], "attributes": [], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 202, "end_line": 385}, "type": "class"}, {"name": "test_add_artist", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_test.subplots", "plt.Line2D", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "l2.remove", "fig_ref.subplots", "plt.Line2D", "plt.Circle", "plt.Circle", "plt.Circle", "fig_test.add_artist", "ax2.add_artist"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 774, "end_line": 799}, "code_snippet": "def test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], transform=fig_ref.transFigure,\n                    gid='l1', zorder=21)\n    r1 = plt.Circle((20, 20), 100, transform=None, clip_on=False, zorder=20,\n                    gid='C1')\n    r2 = plt.Circle((.7, .5), .05, transform=fig_ref.transFigure, gid='C2',\n                    zorder=20)\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_ref.dpi_scale_trans,\n                    facecolor='crimson', clip_on=False, zorder=20, gid='C3')\n    for a in [l1, r1, r2, r3]:\n        ax2.add_artist(a)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.203369140625}
{"question": "Where does the data flow when Matplotlib renders a plot from Artist objects to the backend?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib renders a plot, data flows from Artist objects to the backend through a well-defined pipeline. The data flow follows this sequence: 1) Artist objects (Figure, Axes, Line2D, Text, etc.) contain the data and visual properties (coordinates, colors, styles) that define what should be drawn, 2) When rendering is triggered (by draw() or draw_idle()), the Artist hierarchy is traversed starting from the Figure, which calls draw() on its child Axes, 3) Each Artist's draw() method is called with a renderer parameter, passing the Artist's data and properties to the renderer, 4) The renderer (RendererBase subclass like RendererAgg) receives the drawing commands and data from Artists, including path data, colors, transforms, and clipping information, 5) The renderer processes the data through various transformations - coordinate transformations (data coordinates to display coordinates), path simplification, clipping, and anti-aliasing, 6) For raster backends like Agg, the renderer converts the processed data into pixel operations, filling pixel buffers with the appropriate colors and alpha values, 7) The FigureCanvas (backend-specific) receives the rendered pixel data and displays it on screen or saves it to a file, 8) The data flow is unidirectional - Artists provide data and properties to the renderer, which processes and outputs the final visual representation. This architecture separates data representation (Artists) from rendering logic (backends), allowing the same plotting code to work across different output formats.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "_blit_draw", "is_method": true, "class_name": "Animation", "parameters": ["self", "artists"], "calls": ["ax._get_view", "self._blit_cache.get", "a.axes.draw_artist", "ax.figure.canvas.blit", "object", "ax.figure.canvas.copy_from_bbox"], "code_location": {"file": "animation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1184, "end_line": 1204}, "code_snippet": "    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared Axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FancyArrowPatch", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._get_path_in_displaycoord", "transforms.IdentityTransform", "self._draw_paths_with_artist_properties", "self.get_visible", "np.iterable", "zip"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 4519, "end_line": 4538}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        # FIXME: dpi_cor is for the dpi-dependency of the linewidth.  There\n        # could be room for improvement.  Maybe _get_path_in_displaycoord could\n        # take a renderer argument, but get_path should be adapted too.\n        self._dpi_cor = renderer.points_to_pixels(1.)\n        path, fillable = self._get_path_in_displaycoord()\n\n        if not np.iterable(fillable):\n            path = [path]\n            fillable = [fillable]\n\n        affine = transforms.IdentityTransform()\n\n        self._draw_paths_with_artist_properties(\n            renderer,\n            [(p, affine, self._facecolor if f and self._facecolor[3] else None)\n             for p, f in zip(path, fillable)])\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FigureCanvasBase", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1906, "end_line": 1914}, "code_snippet": "    def draw(self, *args, **kwargs):\n        \"\"\"\n        Render the `.Figure`.\n\n        This method must walk the artist tree, even if no output is produced,\n        because it triggers deferred work that users may want to access\n        before saving output to disk. For example computing limits,\n        auto-limits, and tick values.\n        \"\"\"\n", "type": "function"}, {"name": "RendererBase", "docstring": "An abstract base class to handle drawing/rendering operations.\n\nThe following methods must be implemented in the backend for full\nfunctionality (though just implementing `draw_path` alone would give a\nhighly capable backend):\n\n* `draw_path`\n* `draw_image`\n* `draw_gouraud_triangles`\n\nThe following methods *should* be implemented in the backend for\noptimization reasons:\n\n* `draw_text`\n* `draw_markers`\n* `draw_path_collection`\n* `draw_quad_mesh`", "methods": ["__init__", "open_group", "close_group", "draw_path", "draw_markers", "draw_path_collection", "draw_quad_mesh", "draw_gouraud_triangles", "_iter_collection_raw_paths", "_iter_collection_uses_per_path", "_iter_collection", "get_image_magnification", "draw_image", "option_image_nocomposite", "option_scale_image", "draw_tex", "draw_text", "_draw_text_as_path", "get_text_width_height_descent", "flipy", "get_canvas_width_height", "get_texmanager", "new_gc", "points_to_pixels", "start_rasterizing", "stop_rasterizing", "start_filter", "stop_filter", "_draw_disabled"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 134, "end_line": 690}, "type": "class"}, {"name": "RendererAgg", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles", "methods": ["__init__", "__getstate__", "__setstate__", "_update_methods", "draw_path", "draw_mathtext", "draw_text", "get_text_width_height_descent", "draw_tex", "get_canvas_width_height", "_prepare_font", "points_to_pixels", "buffer_rgba", "tostring_argb", "clear", "option_image_nocomposite", "option_scale_image", "restore_region", "start_filter", "stop_filter"], "attributes": [], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 58, "end_line": 360}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "renderer"], "calls": ["self._unstale_viewLim", "renderer.open_group", "self.get_axes_locator", "self.apply_aspect", "self.get_children", "artists.remove", "self._update_title_position", "sorted", "mimage._draw_list_compositing_images", "renderer.close_group", "RuntimeError", "self.get_visible", "self.spines.values", "self._axis_map.values", "canvas.is_saving", "np.searchsorted", "_draw_rasterized", "self.get_gid", "locator", "artists.remove", "artists.remove", "attrgetter", "self.get_figure", "self.get_figure", "self.get_figure", "isinstance", "a.get_animated"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 3168, "end_line": 3236}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2296924591064453}
{"question": "Where in Matplotlib's codebase is the core rendering system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's core rendering system is implemented across several key locations in the codebase. The main components are: 1) The abstract base class RendererBase in lib/matplotlib/backend_bases.py defines the interface that all renderers must implement, including methods like draw_path(), draw_image(), draw_text(), and draw_markers(), 2) The Agg backend implementation, which is the primary raster renderer, is located in src/_backend_agg.h and src/_backend_agg.cpp, containing the RendererAgg class that implements the actual pixel-level drawing operations using the Anti-Grain Geometry library, 3) The backend wrapper code in src/_backend_agg_wrapper.cpp provides Python bindings for the C++ renderer implementation, 4) Path processing and optimization is implemented in src/path_converters.h, which contains classes like PathNanRemover, PathClipper, PathSnapper, and PathSimplifier that process geometric paths before rendering, 5) Image resampling and transformation is handled in src/_image_resample.h, which implements high-quality image scaling and transformation algorithms, 6) The Artist class in lib/matplotlib/artist.py provides the draw() method interface that connects the high-level plotting objects to the low-level renderers, 7) Backend-specific implementations for different output formats (PDF, SVG, PS) are located in lib/matplotlib/backends/ directory, each implementing the RendererBase interface for their specific format. The core rendering pipeline flows from Artist objects through the renderer interface to the specific backend implementations, with the Agg backend serving as the reference implementation for raster graphics.", "score": null, "retrieved_content": [{"name": "RendererAgg", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles", "methods": ["__init__", "__getstate__", "__setstate__", "_update_methods", "draw_path", "draw_mathtext", "draw_text", "get_text_width_height_descent", "draw_tex", "get_canvas_width_height", "_prepare_font", "points_to_pixels", "buffer_rgba", "tostring_argb", "clear", "option_image_nocomposite", "option_scale_image", "restore_region", "start_filter", "stop_filter"], "attributes": [], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 58, "end_line": 360}, "type": "class"}, {"name": "RendererBase", "docstring": "An abstract base class to handle drawing/rendering operations.\n\nThe following methods must be implemented in the backend for full\nfunctionality (though just implementing `draw_path` alone would give a\nhighly capable backend):\n\n* `draw_path`\n* `draw_image`\n* `draw_gouraud_triangles`\n\nThe following methods *should* be implemented in the backend for\noptimization reasons:\n\n* `draw_text`\n* `draw_markers`\n* `draw_path_collection`\n* `draw_quad_mesh`", "methods": ["__init__", "open_group", "close_group", "draw_path", "draw_markers", "draw_path_collection", "draw_quad_mesh", "draw_gouraud_triangles", "_iter_collection_raw_paths", "_iter_collection_uses_per_path", "_iter_collection", "get_image_magnification", "draw_image", "option_image_nocomposite", "option_scale_image", "draw_tex", "draw_text", "_draw_text_as_path", "get_text_width_height_descent", "flipy", "get_canvas_width_height", "get_texmanager", "new_gc", "points_to_pixels", "start_rasterizing", "stop_rasterizing", "start_filter", "stop_filter", "_draw_disabled"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 134, "end_line": 690}, "type": "class"}, {"name": "FigureCanvasBase", "docstring": "The canvas the figure renders into.\n\nAttributes\n----------\nfigure : `~matplotlib.figure.Figure`\n    A high-level figure instance.", "methods": ["supports_blit", "__init__", "_fix_ipython_backend2gui", "new_manager", "_idle_draw_cntx", "is_saving", "blit", "inaxes", "grab_mouse", "release_mouse", "set_cursor", "draw", "draw_idle", "device_pixel_ratio", "_set_device_pixel_ratio", "get_width_height", "get_supported_filetypes", "get_supported_filetypes_grouped", "_switch_canvas_and_return_print_method", "print_figure", "get_default_filetype", "get_default_filename", "mpl_connect", "mpl_disconnect", "new_timer", "flush_events", "start_event_loop", "stop_event_loop"], "attributes": ["required_interactive_framework", "manager_class", "events", "fixed_dpi", "filetypes", "callbacks", "button_pick_id", "scroll_pick_id", "_timer_cls"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1701, "end_line": 2414}, "type": "class"}, {"name": "RendererTemplate", "docstring": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.", "methods": ["__init__", "draw_path", "draw_image", "draw_text", "flipy", "get_canvas_width_height", "get_text_width_height_descent", "new_gc", "points_to_pixels"], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 39, "end_line": 102}, "type": "class"}, {"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "_get_renderer", "is_method": true, "class_name": "Figure", "parameters": ["self"], "calls": ["hasattr", "self.canvas.get_renderer", "_get_renderer"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2849, "end_line": 2853}, "code_snippet": "    def _get_renderer(self):\n        if hasattr(self.canvas, 'get_renderer'):\n            return self.canvas.get_renderer()\n        else:\n            return _get_renderer(self)\n", "type": "function"}, {"name": "RendererPS", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.", "methods": ["__init__", "_is_transparent", "set_color", "set_linewidth", "_linejoin_cmd", "set_linejoin", "_linecap_cmd", "set_linecap", "set_linedash", "set_font", "create_hatch", "get_image_magnification", "_convert_path", "_get_clip_cmd", "draw_image", "draw_path", "draw_markers", "draw_path_collection", "draw_tex", "draw_text", "draw_mathtext", "draw_gouraud_triangles", "_draw_ps"], "attributes": ["_afm_font_dir", "_use_afm_rc_name"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 397, "end_line": 942}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "RendererAgg", "parameters": ["self", "width", "height", "dpi"], "calls": ["__init__", "_RendererAgg", "self._update_methods", "MathTextParser", "Bbox.from_bounds", "int", "int", "super"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 64, "end_line": 76}, "code_snippet": "    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FancyArrowPatch", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._get_path_in_displaycoord", "transforms.IdentityTransform", "self._draw_paths_with_artist_properties", "self.get_visible", "np.iterable", "zip"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 4519, "end_line": 4538}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        # FIXME: dpi_cor is for the dpi-dependency of the linewidth.  There\n        # could be room for improvement.  Maybe _get_path_in_displaycoord could\n        # take a renderer argument, but get_path should be adapted too.\n        self._dpi_cor = renderer.points_to_pixels(1.)\n        path, fillable = self._get_path_in_displaycoord()\n\n        if not np.iterable(fillable):\n            path = [path]\n            fillable = [fillable]\n\n        affine = transforms.IdentityTransform()\n\n        self._draw_paths_with_artist_properties(\n            renderer,\n            [(p, affine, self._facecolor if f and self._facecolor[3] else None)\n             for p, f in zip(path, fillable)])\n", "type": "function"}, {"name": "_renderer", "is_method": true, "class_name": "FigureCanvasCairo", "parameters": ["self"], "calls": ["hasattr", "RendererCairo"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 404, "end_line": 411}, "code_snippet": "    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2256686687469482}
{"question": "Where does the control flow when Matplotlib handles user interactions through the event system?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib handles user interactions through the event system, the control flow follows a specific sequence through multiple layers. The control flow proceeds as follows: 1) User interaction (mouse click, key press) is captured by the GUI toolkit (Qt, Tk, GTK, Wx, macOS) and converted into a low-level GUI event, 2) The backend-specific FigureCanvas receives the GUI event and converts it into a Matplotlib-specific event object (MouseEvent, KeyEvent, etc.) with both pixel coordinates and data coordinates, 3) The FigureCanvasBase.mpl_connect() method manages registered callbacks, and when an event occurs, it looks up the appropriate callback functions for that event type, 4) The event object is passed to each registered callback function, which can modify Artist properties, trigger redraws, or perform other actions, 5) If the callback modifies Artists, the 'stale' state is propagated up the Artist hierarchy, marking parent containers as needing redraw, 6) The event system coordinates with the drawing system - if Artists were modified, draw_idle() may be called to schedule a redraw, 7) The control flow returns to the GUI event loop, which continues waiting for the next user interaction, 8) For interactive features like panning and zooming, the event callbacks modify Axes limits and trigger automatic redraws through the stale state mechanism. This event-driven architecture allows Matplotlib to respond to user interactions while maintaining separation between the GUI toolkit layer and the plotting logic, enabling the same interactive code to work across different GUI frameworks.", "score": null, "retrieved_content": [{"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "enter_notify_event", "is_method": true, "class_name": "FigureCanvasTk", "parameters": ["self", "event"], "calls": ["_process", "LocationEvent", "self._event_mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 303, "end_line": 307}, "code_snippet": "    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n", "type": "function"}, {"name": "_click", "is_method": true, "class_name": "Button", "parameters": ["self", "event"], "calls": ["self.ignore", "event.canvas.grab_mouse", "self.ax.contains"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 218, "end_line": 222}, "code_snippet": "    def _click(self, event):\n        if not self.eventson or self.ignore(event) or not self.ax.contains(event)[0]:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n", "type": "function"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 157, "end_line": 162}, "code_snippet": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "button_press_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 131, "end_line": 136}, "code_snippet": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasTk", "parameters": ["self", "event"], "calls": ["_process", "MouseEvent", "self._event_mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 296, "end_line": 301}, "code_snippet": "    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n", "type": "function"}, {"name": "on_enter_axes", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.inaxes.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 20, "end_line": 23}, "code_snippet": "def on_enter_axes(event):\n    print('enter_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('yellow')\n    event.canvas.draw()\n", "type": "function"}, {"name": "enter_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["get_modifier_state", "_process", "Gdk.Keymap.get_for_display", "LocationEvent", "self.get_display", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 164, "end_line": 169}, "code_snippet": "    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n", "type": "function"}, {"name": "mouseMoveEvent", "is_method": true, "class_name": "FigureCanvasQT", "parameters": ["self", "event"], "calls": ["_process", "MouseEvent", "self.mouseEventCoords", "self._mpl_buttons", "self._mpl_modifiers", "event.buttons"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 343, "end_line": 350}, "code_snippet": "    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2359330654144287}
{"question": "Where does the data flow when Matplotlib processes plotting commands through the pyplot interface?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib processes plotting commands through the pyplot interface, the data flows through a state-based system that manages global references to the current Figure and Axes. The data flow follows this sequence: 1) The pyplot module maintains global state variables that track the current Figure and Axes objects, accessible through gcf() and gca() functions, 2) When a pyplot function like plt.plot() is called, it first checks if there's a current Figure and Axes, creating them if necessary using the global state, 3) The pyplot function then delegates the actual plotting operation to the corresponding method on the current Axes object - for example, plt.plot() calls ax.plot() on the current Axes, 4) The data (coordinates, colors, styles) flows from the pyplot function parameters to the Axes method, which creates the appropriate Artist objects (Line2D, Text, etc.), 5) The Artist objects are added to the Axes, which maintains lists of its child Artists, 6) The pyplot interface also manages Figure creation through functions like plt.figure(), plt.subplots(), and plt.subplot(), which update the global state, 7) For complex plots with multiple subplots, pyplot functions like plt.subplot() switch the current Axes in the global state, directing subsequent plotting commands to the appropriate subplot, 8) The data flow is essentially a wrapper around the object-oriented API - pyplot functions are convenience wrappers that manage the global state and delegate to the underlying Figure and Axes objects. This design allows users to write simple plotting code without explicitly managing Figure and Axes references, while still providing access to the full power of the object-oriented API when needed.", "score": null, "retrieved_content": [{"name": "__call__", "is_method": true, "class_name": "_process_plot_var_args", "parameters": ["self", "axes"], "calls": ["axes._process_unit_info", "ValueError", "_api.kwarg_error", "cbook.sanitize_sequence", "mpl._replacer", "len", "kwargs.get", "mpl._label_from_arg", "len", "len", "cbook.is_scalar_or_string", "isinstance", "self._plot_args", "len", "kwargs.get", "_process_plot_format", "len", "ValueError", "inspect.stack", "_api.warn_external"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 226, "end_line": 299}, "code_snippet": "    def __call__(self, axes, *args, data=None, return_kwargs=False, **kwargs):\n        axes._process_unit_info(kwargs=kwargs)\n\n        for pos_only in \"xy\":\n            if pos_only in kwargs:\n                raise _api.kwarg_error(inspect.stack()[1].function, pos_only)\n\n        if not args:\n            return\n\n        if data is None:  # Process dict views\n            args = [cbook.sanitize_sequence(a) for a in args]\n        else:  # Process the 'data' kwarg.\n            replaced = [mpl._replacer(data, arg) for arg in args]\n            if len(args) == 1:\n                label_namer_idx = 0\n            elif len(args) == 2:  # Can be x, y or y, c.\n                # Figure out what the second argument is.\n                # 1) If the second argument cannot be a format shorthand, the\n                #    second argument is the label_namer.\n                # 2) Otherwise (it could have been a format shorthand),\n                #    a) if we did perform a substitution, emit a warning, and\n                #       use it as label_namer.\n                #    b) otherwise, it is indeed a format shorthand; use the\n                #       first argument as label_namer.\n                try:\n                    _process_plot_format(args[1])\n                except ValueError:  # case 1)\n                    label_namer_idx = 1\n                else:\n                    if replaced[1] is not args[1]:  # case 2a)\n                        _api.warn_external(\n                            f\"Second argument {args[1]!r} is ambiguous: could \"\n                            f\"be a format string but is in 'data'; using as \"\n                            f\"data.  If it was intended as data, set the \"\n                            f\"format string to an empty string to suppress \"\n                            f\"this warning.  If it was intended as a format \"\n                            f\"string, explicitly pass the x-values as well.  \"\n                            f\"Alternatively, rename the entry in 'data'.\",\n                            RuntimeWarning)\n                        label_namer_idx = 1\n                    else:  # case 2b)\n                        label_namer_idx = 0\n            elif len(args) == 3:\n                label_namer_idx = 1\n            else:\n                raise ValueError(\n                    \"Using arbitrary long args with data is not supported due \"\n                    \"to ambiguity of arguments; use multiple plotting calls \"\n                    \"instead\")\n            if kwargs.get(\"label\") is None:\n                kwargs[\"label\"] = mpl._label_from_arg(\n                    replaced[label_namer_idx], args[label_namer_idx])\n            args = replaced\n        ambiguous_fmt_datakey = data is not None and len(args) == 2\n\n        if len(args) >= 4 and not cbook.is_scalar_or_string(\n                kwargs.get(\"label\")):\n            raise ValueError(\"plot() with multiple groups of data (i.e., \"\n                             \"pairs of x and y) does not support multiple \"\n                             \"labels\")\n\n        # Repeatedly grab (x, y) or (x, y, format) from the front of args and\n        # massage them into arguments to plot() or fill().\n\n        while args:\n            this, args = args[:2], args[2:]\n            if args and isinstance(args[0], str):\n                this += args[0],\n                args = args[1:]\n            yield from self._plot_args(\n                axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey,\n                return_kwargs=return_kwargs\n            )\n", "type": "function"}, {"name": "boilerplate_gen", "is_method": false, "class_name": null, "parameters": [], "calls": ["spec.split", "generate_function", "spec.split", "generate_function", "CMAP_TEMPLATE.format", "cmappable.get"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 195, "end_line": 368}, "code_snippet": "def boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n        'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n        'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        template = (AXES_CMAPPABLE_METHOD_TEMPLATE if name in cmappable else\n                    AXES_METHOD_TEMPLATE)\n        yield generate_function(name, f'Axes.{called_name}', template,\n                                sci_command=cmappable.get(name))\n\n    cmaps = (\n        'autumn',\n        'bone',\n        'cool',\n        'copper',\n        'flag',\n        'gray',\n        'hot',\n        'hsv',\n        'jet',\n        'pink',\n        'prism',\n        'spring',\n        'summer',\n        'winter',\n        'magma',\n        'inferno',\n        'plasma',\n        'viridis',\n        \"nipy_spectral\"\n    )\n    # add all the colormaps (autumn, hsv, ....)\n    for name in cmaps:\n        yield AUTOGEN_MSG\n        yield CMAP_TEMPLATE.format(name=name)\n", "type": "function"}, {"name": "build_pyplot", "is_method": false, "class_name": null, "parameters": ["pyplot_path"], "calls": ["splitlines", "subprocess.run", "pyplot_path.open", "pyplot.writelines", "pyplot.writelines", "pyplot_path.read_text", "ValueError", "boilerplate_gen", "pyplot_orig.index"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 371, "end_line": 387}, "code_snippet": "def build_pyplot(pyplot_path):\n    pyplot_orig = pyplot_path.read_text().splitlines(keepends=True)\n    try:\n        pyplot_orig = pyplot_orig[:pyplot_orig.index(PYPLOT_MAGIC_HEADER) + 1]\n    except IndexError as err:\n        raise ValueError('The pyplot.py file *must* have the exact line: %s'\n                         % PYPLOT_MAGIC_HEADER) from err\n\n    with pyplot_path.open('w') as pyplot:\n        pyplot.writelines(pyplot_orig)\n        pyplot.writelines(boilerplate_gen())\n\n    # Run black to autoformat pyplot\n    subprocess.run(\n        [sys.executable, \"-m\", \"black\", \"--line-length=88\", pyplot_path],\n        check=True\n    )\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "plot", "is_method": false, "class_name": null, "parameters": [], "calls": ["_copy_docstring_and_deprecators", "plot", "gca"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3965, "end_line": 3978}, "code_snippet": "def plot(\n    *args: float | ArrayLike | str,\n    scalex: bool = True,\n    scaley: bool = True,\n    data=None,\n    **kwargs,\n) -> list[Line2D]:\n    return gca().plot(\n        *args,\n        scalex=scalex,\n        scaley=scaley,\n        **({\"data\": data} if data is not None else {}),\n        **kwargs,\n    )\n", "type": "function"}, {"name": "Gcf", "docstring": "Singleton to maintain the relation between figures and their managers, and\nkeep track of and \"active\" figure and manager.\n\nThe canvas of a figure created through pyplot is associated with a figure\nmanager, which handles the interaction between the figure and the backend.\npyplot keeps track of figure managers using an identifier, the \"figure\nnumber\" or \"manager number\" (which can actually be any hashable value);\nthis number is available as the :attr:`number` attribute of the manager.\n\nThis class is never instantiated; it consists of an `OrderedDict` mapping\nfigure/manager numbers to managers, and a set of class methods that\nmanipulate this `OrderedDict`.\n\nAttributes\n----------\nfigs : OrderedDict\n    `OrderedDict` mapping numbers to managers; the active manager is at the\n    end.", "methods": ["get_fig_manager", "destroy", "destroy_fig", "destroy_all", "has_fignum", "get_all_fig_managers", "get_num_fig_managers", "get_active", "_set_new_active_manager", "set_active", "draw_all"], "attributes": ["figs"], "code_location": {"file": "_pylab_helpers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 9, "end_line": 131}, "type": "class"}, {"name": "pyplot_show", "is_method": true, "class_name": "FigureManagerWebAgg", "parameters": ["cls"], "calls": ["WebAggApplication.initialize", "format", "WebAggApplication.start", "print", "webbrowser.open", "print"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 48, "end_line": 63}, "code_snippet": "    def pyplot_show(cls, *, block=None):\n        WebAggApplication.initialize()\n\n        url = \"http://{address}:{port}{prefix}\".format(\n            address=WebAggApplication.address,\n            port=WebAggApplication.port,\n            prefix=WebAggApplication.url_prefix)\n\n        if mpl.rcParams['webagg.open_in_browser']:\n            import webbrowser\n            if not webbrowser.open(url):\n                print(f\"To view figure, visit {url}\")\n        else:\n            print(f\"To view figure, visit {url}\")\n\n        WebAggApplication.start()\n", "type": "function"}, {"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "create_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "np.linspace", "plt.plot", "plt.plot", "plt.fill_between", "plt.fill", "plt.plot", "plt.text", "plt.ylabel", "plt.text", "plt.xlim", "plt.ylim"], "code_location": {"file": "test_backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 50, "end_line": 75}, "code_snippet": "def create_figure():\n    plt.figure()\n    x = np.linspace(0, 1, 15)\n\n    # line plot\n    plt.plot(x, x ** 2, \"b-\")\n\n    # marker\n    plt.plot(x, 1 - x**2, \"g>\")\n\n    # filled paths and patterns\n    plt.fill_between([0., .4], [.4, 0.], hatch='//', facecolor=\"lightgray\",\n                     edgecolor=\"red\")\n    plt.fill([3, 3, .8, .8, 3], [2, -2, -2, 0, 2], \"b\")\n\n    # text and typesetting\n    plt.plot([0.9], [0.5], \"ro\", markersize=3)\n    plt.text(0.9, 0.5, 'unicode (ü, °, \\N{Section Sign}) and math ($\\\\mu_i = x_i^2$)',\n             ha='right', fontsize=20)\n    plt.ylabel('sans-serif, blue, $\\\\frac{\\\\sqrt{x}}{y^2}$..',\n               family='sans-serif', color='blue')\n    plt.text(1, 1, 'should be clipped as default clip_box is Axes bbox',\n             fontsize=20, clip_on=True)\n\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3Agg", "parameters": ["self", "figure"], "calls": ["__init__", "super"], "code_location": {"file": "backend_gtk3agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 12, "end_line": 14}, "code_snippet": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2354905605316162}
{"question": "Where in Matplotlib's codebase is the \"Artist\" base class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The Artist base class is defined in lib/matplotlib/artist.py. Specifically, it is defined starting at line 110 as the abstract base class for all objects that render into a FigureCanvas. The Artist class serves as the foundation for Matplotlib's rendering system, providing the common interface and properties that all visual elements share. The class definition includes the constructor (__init__ method) and all the fundamental methods and properties that Artists need, such as draw(), get_children(), set_visible(), get_visible(), set_alpha(), get_alpha(), and many others. The file also contains the type hints for the Artist class in lib/matplotlib/artist.pyi, which defines the interface for all Artist methods and properties. The Artist class is the root of Matplotlib's object hierarchy, with Figure, Axes, Line2D, Text, and all other visual elements inheriting from it. This central location in artist.py makes it the primary reference point for understanding how all Matplotlib visual elements work and interact with the rendering system.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "ArtistInspector", "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.", "methods": ["__init__", "get_aliases", "get_valid_values", "_replace_path", "get_setters", "number_of_parameters", "is_alias", "aliased_name", "aliased_name_rest", "pprint_setters", "pprint_setters_rest", "properties", "pprint_getters"], "attributes": ["_get_valid_values_regex", "_NOT_LINKABLE"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1421, "end_line": 1720}, "type": "class"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "OffsetBox", "docstring": "A simple container artist.\n\nThe child artists are meant to be drawn at a relative position to its\nparent.\n\nBeing an artist itself, all keyword arguments are passed on to `.Artist`.", "methods": ["__init__", "set_figure", "axes", "contains", "set_offset", "get_offset", "set_width", "set_height", "get_visible_children", "get_children", "_get_bbox_and_child_offsets", "get_bbox", "get_window_extent", "draw"], "attributes": [], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 202, "end_line": 385}, "type": "class"}, {"name": "_FloatingAxisArtistHelperBase", "docstring": "", "methods": ["__init__", "get_line"], "attributes": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 162, "end_line": 168}, "type": "class"}, {"name": "Container", "docstring": "Base class for containers.\n\nContainers are classes that collect semantically related Artists such as\nthe bars of a bar plot.", "methods": ["__repr__", "__new__", "__init__", "remove", "get_children"], "attributes": ["get_label", "set_label", "add_callback", "remove_callback", "pchanged"], "code_location": {"file": "container.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 5, "end_line": 39}, "type": "class"}, {"name": "_FixedAxisArtistHelperBase", "docstring": "Helper class for a fixed (in the axes coordinate) axis.", "methods": ["__init__", "get_line", "get_line_transform", "get_axislabel_transform", "get_axislabel_pos_angle", "get_tick_transform"], "attributes": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 120, "end_line": 159}, "type": "class"}, {"name": "AxisArtist", "docstring": "An artist which draws axis (a line along which the n-th axes coord\nis constant) line, ticks, tick labels, and axis label.", "methods": ["LABELPAD", "LABELPAD", "__init__", "set_axis_direction", "set_ticklabel_direction", "invert_ticklabel_direction", "set_axislabel_direction", "get_transform", "get_helper", "set_axisline_style", "get_axisline_style", "_init_line", "_draw_line", "_init_ticks", "_get_tick_info", "_update_ticks", "_draw_ticks", "_init_offsetText", "_update_offsetText", "_draw_offsetText", "_init_label", "_update_label", "_draw_label", "set_label", "get_tightbbox", "draw", "toggle"], "attributes": ["zorder", "_offsetText_pos"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 655, "end_line": 1116}, "type": "class"}, {"name": "FixedAxisArtistHelper", "docstring": "", "methods": ["__init__", "update_lim", "get_tick_iterators", "get_line", "__init__", "update_lim", "get_tick_transform", "get_tick_iterators"], "attributes": [], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 28, "end_line": 105}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.3268301486968994}
{"question": "Where in Matplotlib's codebase is the \"Figure\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The Figure class is defined in lib/matplotlib/figure.py. Specifically, it is defined as a subclass of FigureBase starting at line 2424 in the file. The Figure class inherits from FigureBase, which itself inherits from Artist, and provides the top-level container for all plot elements. The Figure class definition includes its constructor (__init__ method) and all the methods specific to managing figures, such as add_subplot(), subplots(), savefig(), and other figure-level operations. The file also contains the FigureBase class (starting at line 118) which provides the base functionality shared between Figure and SubFigure classes, including methods for adding and managing child Artists. The Figure class is the main entry point for creating plots in Matplotlib and serves as the root of the Artist hierarchy, containing all Axes objects and other plot elements.", "score": null, "retrieved_content": [{"name": "FigureCanvasBase", "docstring": "The canvas the figure renders into.\n\nAttributes\n----------\nfigure : `~matplotlib.figure.Figure`\n    A high-level figure instance.", "methods": ["supports_blit", "__init__", "_fix_ipython_backend2gui", "new_manager", "_idle_draw_cntx", "is_saving", "blit", "inaxes", "grab_mouse", "release_mouse", "set_cursor", "draw", "draw_idle", "device_pixel_ratio", "_set_device_pixel_ratio", "get_width_height", "get_supported_filetypes", "get_supported_filetypes_grouped", "_switch_canvas_and_return_print_method", "print_figure", "get_default_filetype", "get_default_filename", "mpl_connect", "mpl_disconnect", "new_timer", "flush_events", "start_event_loop", "stop_event_loop"], "attributes": ["required_interactive_framework", "manager_class", "events", "fixed_dpi", "filetypes", "callbacks", "button_pick_id", "scroll_pick_id", "_timer_cls"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1701, "end_line": 2414}, "type": "class"}, {"name": "Figure", "docstring": "The top level container for all the plot elements.\n\nSee `matplotlib.figure` for an index of class methods.\n\nAttributes\n----------\npatch\n    The `.Rectangle` instance representing the figure background patch.\n\nsuppressComposite\n    For multiple images, the figure will make composite images\n    depending on the renderer option_image_nocomposite function.  If\n    *suppressComposite* is a boolean, this will override the renderer.", "methods": ["__str__", "__repr__", "__init__", "pick", "_check_layout_engines_compat", "set_layout_engine", "get_layout_engine", "_repr_html_", "show", "axes", "number", "number", "_get_renderer", "_get_dpi", "_set_dpi", "get_tight_layout", "set_tight_layout", "get_constrained_layout", "set_constrained_layout", "set_constrained_layout_pads", "get_constrained_layout_pads", "set_canvas", "figimage", "set_size_inches", "get_size_inches", "get_figwidth", "get_figheight", "get_dpi", "set_dpi", "set_figwidth", "set_figheight", "clear", "draw", "draw_without_rendering", "draw_artist", "__getstate__", "__setstate__", "add_axobserver", "savefig", "ginput", "waitforbuttonpress", "tight_layout"], "attributes": ["_render_lock", "get_axes", "dpi"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2424, "end_line": 3644}, "type": "class"}, {"name": "FigureBase", "docstring": "Base class for `.Figure` and `.SubFigure` containing the methods that add\nartists to the figure or subfigure, create Axes, etc.", "methods": ["__init__", "_get_draw_artists", "autofmt_xdate", "get_children", "get_figure", "set_figure", "contains", "get_window_extent", "_suplabels", "suptitle", "get_suptitle", "supxlabel", "get_supxlabel", "supylabel", "get_supylabel", "get_edgecolor", "get_facecolor", "get_frameon", "set_linewidth", "get_linewidth", "set_edgecolor", "set_facecolor", "set_frameon", "add_artist", "add_axes", "add_subplot", "_add_axes_internal", "subplots", "delaxes", "_remove_axes", "clear", "clf", "legend", "text", "colorbar", "subplots_adjust", "align_xlabels", "align_ylabels", "align_titles", "align_labels", "add_gridspec", "subfigures", "add_subfigure", "sca", "gca", "_gci", "_process_projection_requirements", "get_default_bbox_extra_artists", "get_tightbbox", "_norm_per_subplot_kw", "_normalize_grid_string", "subplot_mosaic", "_set_artist_props"], "attributes": ["figure", "frameon"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 118, "end_line": 2212}, "type": "class"}, {"name": "FigureManagerNbAgg", "docstring": "", "methods": ["__init__", "create_with_canvas", "display_js", "show", "reshow", "connected", "get_javascript", "_create_comm", "destroy", "clearup_closed", "remove_comm"], "attributes": ["_toolbar2_class", "ToolbarCls"], "code_location": {"file": "backend_nbagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 64, "end_line": 156}, "type": "class"}, {"name": "FigureFrameWx", "docstring": "", "methods": ["__init__", "_on_close"], "attributes": [], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 913, "end_line": 959}, "type": "class"}, {"name": "FigureCanvasAgg", "docstring": "", "methods": ["copy_from_bbox", "restore_region", "draw", "get_renderer", "tostring_argb", "buffer_rgba", "print_raw", "_print_pil", "print_png", "print_to_buffer", "print_gif", "print_jpg", "print_tif", "print_webp", "print_avif"], "attributes": ["_lastKey", "print_rgba", "print_jpeg", "print_tiff"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 363, "end_line": 540}, "type": "class"}, {"name": "FigureCanvasQTAgg", "docstring": "", "methods": ["paintEvent", "print_figure"], "attributes": [], "code_location": {"file": "backend_qtagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 16, "end_line": 81}, "type": "class"}, {"name": "FigureCanvasTk", "docstring": "", "methods": ["__init__", "_update_device_pixel_ratio", "resize", "draw_idle", "get_tk_widget", "_event_mpl_coords", "motion_notify_event", "enter_notify_event", "leave_notify_event", "button_press_event", "button_dblclick_event", "button_release_event", "scroll_event", "scroll_event_windows", "_mpl_buttons", "_mpl_modifiers", "_get_key", "key_press", "key_release", "new_timer", "flush_events", "start_event_loop", "stop_event_loop", "set_cursor"], "attributes": ["required_interactive_framework", "manager_class"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 162, "end_line": 460}, "type": "class"}, {"name": "FigureCanvasNbAgg", "docstring": "", "methods": [], "attributes": ["manager_class"], "code_location": {"file": "backend_nbagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 159, "end_line": 160}, "type": "class"}, {"name": "FigureCanvasTkAgg", "docstring": "", "methods": ["draw", "blit"], "attributes": [], "code_location": {"file": "backend_tkagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 8, "end_line": 15}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.3420603275299072}
{"question": "Where are Matplotlib's backend class definitions located?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend class definitions are located across several organized locations in the codebase. The main locations are: 1) The abstract base classes are defined in lib/matplotlib/backend_bases.py, which contains RendererBase, FigureCanvasBase, GraphicsContextBase, Event classes, and other fundamental backend interfaces, 2) The lib/matplotlib/backends/ directory contains most of the Python-based backend implementations, organized by type - interactive backends (like qt5agg.py, tkagg.py, gtk3agg.py) and non-interactive backends (like pdf.py, svg.py, ps.py), 3) The src/ directory contains C++ implementations for performance-critical backends, particularly the Agg backend in src/_backend_agg.h and src/_backend_agg.cpp, which defines the RendererAgg class and related C++ backend components, 4) The src/_backend_agg_wrapper.cpp file provides Python bindings for the C++ renderer implementation, 5) The lib/matplotlib/backends/backend_bases.pyi file contains type hints for the backend base classes, 6) Each backend module typically defines its own FigureCanvas, FigureManager, and Renderer classes that inherit from the base classes in backend_bases.py, 7) The backend registration system is managed through the _Backend class in backend_bases.py, which provides the @_Backend.export decorator for registering new backends, 8) Backend-specific event handling implementations are located in their respective backend modules, with the core event system defined in backend_bases.py. This organization allows for clean separation between the abstract backend interface and specific implementations while maintaining consistency across different output formats and GUI toolkits.", "score": null, "retrieved_content": [{"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "_BackendQT", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager", "mainloop"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1084, "end_line": 1088}, "type": "class"}, {"name": "_BackendQTAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_qtagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 85, "end_line": 86}, "type": "class"}, {"name": "_BackendNbAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_nbagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 241, "end_line": 243}, "type": "class"}, {"name": "_BackendWxAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_wxagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 44, "end_line": 45}, "type": "class"}, {"name": "_BackendQT5Agg", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "backend_qt5agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 13, "end_line": 14}, "type": "class"}, {"name": "_BackendTkAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_tkagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 19, "end_line": 20}, "type": "class"}, {"name": "_BackendSVG", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1380, "end_line": 1382}, "type": "class"}, {"name": "_BackendWebAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 326, "end_line": 328}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.33878135681152344}
{"question": "How does Matplotlib's Artist hierarchy work for rendering plotting components?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist hierarchy works for rendering plotting components through a structured parent-child relationship system that organizes visual elements and manages the rendering process. The hierarchy operates as follows: 1) The Figure serves as the top-level container that holds all plot elements and manages the overall rendering process through its draw() method, 2) Each Figure contains multiple Axes objects, which are the primary plotting areas that contain the actual data visualization and coordinate systems, 3) Each Axes contains individual Artist objects (lines, text, patches, images, etc.) that represent the visual elements of the plot, 4) The rendering process follows the hierarchy: Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 5) The Artist class provides the fundamental interface through its draw() method, which takes a renderer parameter and delegates the actual drawing to backend-specific renderers, 6) The hierarchy supports efficient rendering through features like z-order management (artists are sorted by zorder before drawing), stale state tracking (only redrawing when necessary), and parent-child relationship management, 7) Container Artists (Figure, Axes) manage their child Artists through methods like get_children() and maintain lists of different Artist types (lines, patches, texts, images), 8) The hierarchy enables coordinate transformations, clipping, and other rendering optimizations by allowing parent containers to manage their children's rendering context, 9) The Artist hierarchy also supports interactive features like picking and event handling by maintaining the parent-child relationships that determine which Artists are affected by user interactions.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Axis", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1276, "end_line": 1279}, "code_snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "ToolHandles", "parameters": ["self"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3016, "end_line": 3017}, "code_snippet": "    def artists(self):\n        return (self._markers, )\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "renderer"], "calls": ["self._unstale_viewLim", "renderer.open_group", "self.get_axes_locator", "self.apply_aspect", "self.get_children", "artists.remove", "self._update_title_position", "sorted", "mimage._draw_list_compositing_images", "renderer.close_group", "RuntimeError", "self.get_visible", "self.spines.values", "self._axis_map.values", "canvas.is_saving", "np.searchsorted", "_draw_rasterized", "self.get_gid", "locator", "artists.remove", "artists.remove", "attrgetter", "self.get_figure", "self.get_figure", "self.get_figure", "isinstance", "a.get_animated"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 3168, "end_line": 3236}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Artist", "parameters": ["self"], "calls": ["cbook.CallbackRegistry", "_XYPair", "type"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 173, "end_line": 207}, "code_snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Tick", "parameters": ["self", "renderer"], "calls": ["renderer.open_group", "renderer.close_group", "self.get_visible", "artist.draw", "self.get_gid"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 272, "end_line": 281}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__, gid=self.get_gid())\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "AuxTransformBox", "parameters": ["self", "renderer"], "calls": ["_bbox_artist", "c.draw", "dict"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 899, "end_line": 904}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        for c in self._children:\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n", "type": "function"}, {"name": "_set_artist_props", "is_method": true, "class_name": "FigureBase", "parameters": ["self", "a"], "calls": ["a.set_transform", "a.set_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2208, "end_line": 2212}, "code_snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transSubfigure)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3256840705871582}
{"question": "How does Matplotlib implement its backend system for different output formats?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its backend system for different output formats through a modular architecture that separates rendering logic from output mechanisms. The system works as follows: 1) Abstract base classes in lib/matplotlib/backend_bases.py define the interface that all backends must implement, including RendererBase, FigureCanvasBase, and GraphicsContextBase, 2) The backend registration system in backend_bases.py maps file formats to specific backend modules through the _default_backends dictionary, which associates formats like 'png', 'pdf', 'svg' with their corresponding backend modules, 3) Each backend implements the abstract interface by providing concrete classes that inherit from the base classes - for example, the Agg backend provides RendererAgg for raster output, while PDF and SVG backends provide vector-based renderers, 4) The Figure.savefig() method uses the backend system by calling the appropriate print_* method on the canvas, which automatically selects the correct backend based on the file extension or format parameter, 5) Backends are organized into interactive backends (for GUI display) and non-interactive backends (for file output), with the system supporting both raster formats (PNG, JPEG) through Agg and vector formats (PDF, SVG, PS) through specialized renderers, 6) The backend selection can be configured through rcParams, environment variables, or explicit backend specification in savefig(), allowing users to choose the most appropriate output format for their needs, 7) Each backend implements format-specific optimizations and features while maintaining a consistent interface, enabling the same plotting code to work across different output formats without modification.", "score": null, "retrieved_content": [{"name": "BackendRegistry", "docstring": "Registry of backends available within Matplotlib.\n\nThis is the single source of truth for available backends.\n\nAll use of ``BackendRegistry`` should be via the singleton instance\n``backend_registry`` which can be imported from ``matplotlib.backends``.\n\nEach backend has a name, a module name containing the backend code, and an\noptional GUI framework that must be running if the backend is interactive.\nThere are three sources of backends: built-in (source code is within the\nMatplotlib repository), explicit ``module://some.backend`` syntax (backend is\nobtained by loading the module), or via an entry point (self-registering\nbackend in an external package).\n\n.. versionadded:: 3.9", "methods": ["__init__", "_backend_module_name", "_clear", "_ensure_entry_points_loaded", "_get_gui_framework_by_loading", "_read_entry_points", "_validate_and_store_entry_points", "backend_for_gui_framework", "is_valid_backend", "list_all", "list_builtin", "list_gui_frameworks", "load_backend_module", "resolve_backend", "resolve_gui_or_backend"], "attributes": ["_BUILTIN_BACKEND_TO_GUI_FRAMEWORK", "_GUI_FRAMEWORK_TO_BACKEND"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 15, "end_line": 410}, "type": "class"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "get_registered_canvas_class", "is_method": false, "class_name": null, "parameters": ["format"], "calls": ["isinstance", "importlib.import_module"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 120, "end_line": 131}, "code_snippet": "def get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "test_savefig_backend", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "fig.savefig", "pytest.raises", "fig.savefig"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 600, "end_line": 607}, "code_snippet": "def test_savefig_backend():\n    fig = plt.figure()\n    # Intentionally use an invalid module name.\n    with pytest.raises(ModuleNotFoundError, match=\"No module named '@absent'\"):\n        fig.savefig(\"test\", backend=\"module://@absent\")\n    with pytest.raises(ValueError,\n                       match=\"The 'pdf' backend does not support png output\"):\n        fig.savefig(\"test.png\", backend=\"pdf\")\n", "type": "function"}, {"name": "_BackendSVG", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1380, "end_line": 1382}, "type": "class"}, {"name": "BackendFilter", "docstring": "Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n.. versionadded:: 3.9", "methods": [], "attributes": ["INTERACTIVE", "NON_INTERACTIVE"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 5, "end_line": 12}, "type": "class"}, {"name": "register_backend", "is_method": false, "class_name": null, "parameters": ["format", "backend", "description"], "calls": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 101, "end_line": 117}, "code_snippet": "def register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "_BackendPgf", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 881, "end_line": 882}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.34503841400146484}
{"question": "How does Matplotlib implement its event system for interactive plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its event system for interactive plotting through a GUI-neutral architecture that abstracts user interactions across different GUI toolkits. The system works as follows: 1) The core event system is defined in lib/matplotlib/backend_bases.py, which contains abstract base classes like Event, LocationEvent, MouseEvent, and KeyEvent that provide a consistent interface regardless of the underlying GUI framework, 2) The FigureCanvasBase class provides the mpl_connect() and mpl_disconnect() methods that manage event connections and maintain a registry of callback functions for different event types, 3) Backend-specific implementations (Qt, Tk, GTK, Wx, macOS) capture low-level GUI events and convert them into Matplotlib-specific event objects with both pixel coordinates and data coordinates, 4) The event system supports various event types including mouse clicks, key presses, mouse movements, and custom events, with each event containing information about the location (both pixel and data coordinates), the Axes the event occurred in, and any modifiers pressed, 5) Users can connect callback functions to specific events using FigureCanvasBase.mpl_connect(), which returns a connection ID that can be used to disconnect the callback later, 6) The event system integrates with the Artist hierarchy, allowing events to be associated with specific visual elements and enabling features like picking (determining which Artist was clicked), 7) Built-in interactive features like panning and zooming are implemented using this event system, with the backend handling the conversion between GUI toolkit events and Matplotlib's coordinate systems, 8) The event system supports both blocking and non-blocking event loops, allowing for different integration patterns with command-line interfaces and GUI applications, 9) The system provides a framework-independent interface that enables the same interactive code to work across different GUI toolkits while maintaining consistent behavior.", "score": null, "retrieved_content": [{"name": "Event", "docstring": "A Matplotlib event.\n\nThe following attributes are defined and shown with their default values.\nSubclasses may define additional attributes.\n\nAttributes\n----------\nname : str\n    The event name.\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance generating the event.\nguiEvent\n    The GUI event that triggered the Matplotlib event.", "methods": ["__init__", "_process"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1170, "end_line": 1195}, "type": "class"}, {"name": "on_enter_figure", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["print", "event.canvas.figure.patch.set_facecolor", "event.canvas.draw"], "code_location": {"file": "figure_axes_enter_leave.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "def on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n", "type": "function"}, {"name": "_mouse_handler", "is_method": false, "class_name": null, "parameters": ["event"], "calls": ["last_ref", "weakref.ref", "event.canvas.callbacks.process", "LocationEvent", "leave_event._set_inaxes", "canvas.callbacks.process", "last_axes.get_figure"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1552, "end_line": 1586}, "code_snippet": "def _mouse_handler(event):\n    # Dead-reckoning of button and key.\n    if event.name == \"button_press_event\":\n        event.canvas._button = event.button\n    elif event.name == \"button_release_event\":\n        event.canvas._button = None\n    elif event.name == \"motion_notify_event\" and event.button is None:\n        event.button = event.canvas._button\n    if event.key is None:\n        event.key = event.canvas._key\n    # Emit axes_enter/axes_leave.\n    if event.name == \"motion_notify_event\":\n        last_ref = LocationEvent._last_axes_ref\n        last_axes = last_ref() if last_ref else None\n        if last_axes != event.inaxes:\n            if last_axes is not None:\n                # Create a synthetic LocationEvent for the axes_leave_event.\n                # Its inaxes attribute needs to be manually set (because the\n                # cursor is actually *out* of that Axes at that point); this is\n                # done with the internal _set_inaxes method which ensures that\n                # the xdata and ydata attributes are also correct.\n                try:\n                    canvas = last_axes.get_figure(root=True).canvas\n                    leave_event = LocationEvent(\n                        \"axes_leave_event\", canvas,\n                        event.x, event.y, event.guiEvent,\n                        modifiers=event.modifiers)\n                    leave_event._set_inaxes(last_axes)\n                    canvas.callbacks.process(\"axes_leave_event\", leave_event)\n                except Exception:\n                    pass  # The last canvas may already have been torn down.\n            if event.inaxes is not None:\n                event.canvas.callbacks.process(\"axes_enter_event\", event)\n        LocationEvent._last_axes_ref = (\n            weakref.ref(event.inaxes) if event.inaxes else None)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AxesWidget", "parameters": ["self", "ax"], "calls": [], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 116, "end_line": 118}, "code_snippet": "    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "EventHandler", "parameters": ["self"], "calls": ["fig.canvas.mpl_connect", "fig.canvas.mpl_connect", "fig.canvas.mpl_connect"], "code_location": {"file": "looking_glass.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 37, "end_line": 42}, "code_snippet": "    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "figure"], "calls": ["__init__", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.connect", "self.set_events", "self.set_can_focus", "Gtk.CssProvider", "css.load_from_data", "self.get_style_context", "style_ctx.add_provider", "style_ctx.add_class", "super"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 59, "end_line": 88}, "code_snippet": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n", "type": "function"}, {"name": "button_press_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 131, "end_line": 136}, "code_snippet": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "_click", "is_method": true, "class_name": "Button", "parameters": ["self", "event"], "calls": ["self.ignore", "event.canvas.grab_mouse", "self.ax.contains"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 218, "end_line": 222}, "code_snippet": "    def _click(self, event):\n        if not self.eventson or self.ignore(event) or not self.ax.contains(event)[0]:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n", "type": "function"}, {"name": "motion_notify_event", "is_method": true, "class_name": "FigureCanvasGTK3", "parameters": ["self", "widget", "event"], "calls": ["_process", "MouseEvent", "self._mpl_coords", "self._mpl_buttons", "self._mpl_modifiers"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 157, "end_line": 162}, "code_snippet": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n", "type": "function"}, {"name": "_contour_labeler_event_handler", "is_method": false, "class_name": null, "parameters": ["cs", "inline", "inline_spacing", "event"], "calls": ["cs.axes.get_figure", "canvas.stop_event_loop", "cs.pop_label", "canvas.draw", "cs.axes.contains", "cs.add_label_near", "canvas.draw"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 30, "end_line": 56}, "code_snippet": "def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n    canvas = cs.axes.get_figure(root=True).canvas\n    is_button = event.name == \"button_press_event\"\n    is_key = event.name == \"key_press_event\"\n    # Quit (even if not in infinite mode; this is consistent with\n    # MATLAB and sometimes quite useful, but will require the user to\n    # test how many points were actually returned before using data).\n    if (is_button and event.button == MouseButton.MIDDLE\n            or is_key and event.key in [\"escape\", \"enter\"]):\n        canvas.stop_event_loop()\n    # Pop last click.\n    elif (is_button and event.button == MouseButton.RIGHT\n          or is_key and event.key in [\"backspace\", \"delete\"]):\n        # Unfortunately, if one is doing inline labels, then there is currently\n        # no way to fix the broken contour - once humpty-dumpty is broken, he\n        # can't be put back together.  In inline mode, this does nothing.\n        if not inline:\n            cs.pop_label()\n            canvas.draw()\n    # Add new click.\n    elif (is_button and event.button == MouseButton.LEFT\n          # On macOS/gtk, some keys return None.\n          or is_key and event.key is not None):\n        if cs.axes.contains(event)[0]:\n            cs.add_label_near(event.x, event.y, transform=False,\n                              inline=inline, inline_spacing=inline_spacing)\n            canvas.draw()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3493974208831787}
{"question": "How does Matplotlib manage the figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib manages the figure and axes hierarchy through a structured parent-child relationship system implemented in the Figure and Axes classes. The hierarchy management works as follows: 1) The Figure class serves as the top-level container that manages all Axes objects through its _axstack attribute, which is an instance of the _AxesStack helper class that tracks Axes in insertion order and maintains the current active Axes, 2) The Figure class provides methods like add_axes(), add_subplot(), subplots(), and delaxes() to create and manage Axes objects, with each method automatically adding the new Axes to the _axstack and setting up the parent-child relationship, 3) The _AxesStack class maintains a dictionary mapping Axes to their insertion order and provides methods like current() to get the active Axes, bubble() to move an Axes to the top, and add() to add new Axes, 4) Each Axes object maintains a reference to its parent Figure through the _parent_figure attribute, and the Figure maintains lists of all its child Axes through the _localaxes attribute, 5) The Figure's gca() method returns the current active Axes from the stack, and sca() method sets the current Axes, managing the active state, 6) The hierarchy supports SubFigure objects that can be nested within Figures, creating a multi-level hierarchy where SubFigures can contain their own Axes, 7) The Figure class also manages figure-level Artists (lines, patches, texts, images, legends) that are not associated with any specific Axes, 8) The hierarchy enables efficient rendering by allowing the Figure to coordinate the drawing of all its child Axes and Artists, 9) The system supports automatic layout management through layout engines that can adjust the positions of Axes based on their content and the overall figure size.", "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "_AxesStack", "parameters": ["self"], "calls": ["itertools.count"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 79, "end_line": 81}, "code_snippet": "    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n", "type": "function"}, {"name": "Gcf", "docstring": "Singleton to maintain the relation between figures and their managers, and\nkeep track of and \"active\" figure and manager.\n\nThe canvas of a figure created through pyplot is associated with a figure\nmanager, which handles the interaction between the figure and the backend.\npyplot keeps track of figure managers using an identifier, the \"figure\nnumber\" or \"manager number\" (which can actually be any hashable value);\nthis number is available as the :attr:`number` attribute of the manager.\n\nThis class is never instantiated; it consists of an `OrderedDict` mapping\nfigure/manager numbers to managers, and a set of class methods that\nmanipulate this `OrderedDict`.\n\nAttributes\n----------\nfigs : OrderedDict\n    `OrderedDict` mapping numbers to managers; the active manager is at the\n    end.", "methods": ["get_fig_manager", "destroy", "destroy_fig", "destroy_all", "has_fignum", "get_all_fig_managers", "get_num_fig_managers", "get_active", "_set_new_active_manager", "set_active", "draw_all"], "attributes": ["figs"], "code_location": {"file": "_pylab_helpers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 9, "end_line": 131}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "FigureBase", "parameters": ["self"], "calls": ["__init__", "self.set", "cbook.Grouper", "cbook.Grouper", "cbook.Grouper", "super"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 123, "end_line": 154}, "code_snippet": "    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n        self.set(**kwargs)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureManagerBase", "parameters": ["self", "canvas", "num"], "calls": ["self.set_window_title", "self.canvas.mpl_connect", "self.canvas.mpl_connect", "ToolManager", "self._toolbar2_class", "tools.add_tools_to_manager", "self._toolmanager_toolbar_class", "tools.add_tools_to_container", "self.toolbar.update"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2648, "end_line": 2683}, "code_snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n        self.set_window_title(f\"Figure {num:d}\")\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event', key_press_handler)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event', button_press_handler)\n\n        self.toolmanager = (ToolManager(canvas.figure)\n                            if mpl.rcParams['toolbar'] == 'toolmanager'\n                            else None)\n        if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n                and self._toolbar2_class):\n            self.toolbar = self._toolbar2_class(self.canvas)\n        elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n                and self._toolmanager_toolbar_class):\n            self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n        else:\n            self.toolbar = None\n\n        if self.toolmanager:\n            tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                tools.add_tools_to_container(self.toolbar)\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current Axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()\n", "type": "function"}, {"name": "test_get_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "sfig1.subfigures", "sfig2.subplots", "mlines.Line2D", "fig.get_figure", "fig.get_figure", "ax.get_figure", "ax.get_figure", "ax.get_figure", "sfig2.get_figure", "sfig2.get_figure", "pytest.warns", "sfig1.get_figure", "ln.get_figure", "ln.get_figure", "sfig2.get_figure"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 598}, "code_snippet": "def test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n", "type": "function"}, {"name": "test_gca", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_axes", "fig.add_subplot", "fig.add_axes", "fig.sca", "fig.add_subplot", "fig.gca", "fig.gca", "fig.gca", "fig.gca"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 240, "end_line": 265}, "code_snippet": "def test_gca():\n    fig = plt.figure()\n\n    # test that gca() picks up Axes created via add_axes()\n    ax0 = fig.add_axes((0, 0, 1, 1))\n    assert fig.gca() is ax0\n\n    # test that gca() picks up Axes created via add_subplot()\n    ax1 = fig.add_subplot(111)\n    assert fig.gca() is ax1\n\n    # add_axes on an existing Axes should not change stored order, but will\n    # make it current.\n    fig.add_axes(ax0)\n    assert fig.axes == [ax0, ax1]\n    assert fig.gca() is ax0\n\n    # sca() should not change stored order of Axes, which is order added.\n    fig.sca(ax0)\n    assert fig.axes == [ax0, ax1]\n\n    # add_subplot on an existing Axes should not change stored order, but will\n    # make it current.\n    fig.add_subplot(ax1)\n    assert fig.axes == [ax0, ax1]\n    assert fig.gca() is ax1\n", "type": "function"}, {"name": "FigureManagerBase", "docstring": "A backend-independent abstraction of a figure container and controller.\n\nThe figure manager is used by pyplot to interact with the window in a\nbackend-independent way. It's an adapter for the real (GUI) framework that\nrepresents the visual figure on screen.\n\nThe figure manager is connected to a specific canvas instance, which in turn\nis connected to a specific figure instance. To access a figure manager for\na given figure in user code, you typically use ``fig.canvas.manager``.\n\nGUI backends derive from this class to translate common operations such\nas *show* or *resize* to the GUI-specific code. Non-GUI backends do not\nsupport these operations and can just use the base class.\n\nThis following basic operations are accessible:\n\n**Window operations**\n\n- `~.FigureManagerBase.show`\n- `~.FigureManagerBase.destroy`\n- `~.FigureManagerBase.full_screen_toggle`\n- `~.FigureManagerBase.resize`\n- `~.FigureManagerBase.get_window_title`\n- `~.FigureManagerBase.set_window_title`\n\n**Key and mouse button press handling**\n\nThe figure manager sets up default key and mouse button press handling by\nhooking up the `.key_press_handler` to the matplotlib event system. This\nensures the same shortcuts and mouse actions across backends.\n\n**Other operations**\n\nSubclasses will have additional attributes and functions to access\nadditional functionality. This is of course backend-specific. For example,\nmost GUI backends have ``window`` and ``toolbar`` attributes that give\naccess to the native GUI widgets of the respective framework.\n\nAttributes\n----------\ncanvas : `FigureCanvasBase`\n    The backend-specific canvas instance.\n\nnum : int or str\n    The figure number.\n\nkey_press_handler_id : int\n    The default key handler cid, when using the toolmanager.\n    To disable the default key press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.key_press_handler_id)\n\nbutton_press_handler_id : int\n    The default mouse button handler cid, when using the toolmanager.\n    To disable the default button press handling use::\n\n        figure.canvas.mpl_disconnect(\n            figure.canvas.manager.button_press_handler_id)", "methods": ["__init__", "create_with_canvas", "start_main_loop", "pyplot_show", "show", "destroy", "full_screen_toggle", "resize", "get_window_title", "set_window_title"], "attributes": ["_toolbar2_class", "_toolmanager_toolbar_class"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2582, "end_line": 2787}, "type": "class"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "test_pyplot_axes", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.subplots", "plt.sca", "plt.close", "plt.close", "plt.gca", "plt.gcf"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3283, "end_line": 3291}, "code_snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)\n", "type": "function"}, {"name": "test_cla_clears_children_axes_and_fig", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "ax.imshow", "ax.clear", "art.get_figure", "art.get_figure"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 9376, "end_line": 9386}, "code_snippet": "def test_cla_clears_children_axes_and_fig():\n    fig, ax = plt.subplots()\n    lines = ax.plot([], [], [], [])\n    img = ax.imshow([[1]])\n    for art in lines + [img]:\n        assert art.axes is ax\n        assert art.get_figure() is fig\n    ax.clear()\n    for art in lines + [img]:\n        assert art.axes is None\n        assert art.get_figure() is None\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3368523120880127}
{"question": "Where is the \"plot\" function defined in Matplotlib's pyplot interface?", "answer": null, "relative_code_list": null, "ground_truth": "The \"plot\" function in Matplotlib's pyplot interface is not defined in a single location but is automatically generated as a wrapper around the Axes.plot() method. The implementation works as follows: 1) The pyplot.plot() function is generated automatically by the boilerplate.py script in lib/matplotlib/boilerplate.py, which creates wrapper functions for all Axes methods, 2) The generated plot() function is located in lib/matplotlib/pyplot.py, where it serves as a convenience wrapper that calls gca().plot() on the current Axes, 3) The actual plotting logic is implemented in the Axes.plot() method, which is defined in lib/matplotlib/axes/_axes.py, 4) The pyplot.plot() function maintains the same signature and parameters as Axes.plot(), but manages the global state (current Figure and Axes) automatically, 5) When plt.plot() is called, it first ensures there's a current Figure and Axes (creating them if necessary), then delegates to the current Axes' plot() method, 6) The pyplot interface provides this wrapper pattern for all major plotting functions (scatter, bar, hist, etc.), making them accessible through the simple plt.function_name() syntax, 7) The boilerplate generation system ensures that pyplot functions stay synchronized with the underlying Axes methods, automatically updating when new parameters or features are added to the Axes methods. This design allows users to use the simple pyplot interface while the actual implementation remains in the object-oriented Axes class.", "score": null, "retrieved_content": [{"name": "plot", "is_method": false, "class_name": null, "parameters": [], "calls": ["_copy_docstring_and_deprecators", "plot", "gca"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3965, "end_line": 3978}, "code_snippet": "def plot(\n    *args: float | ArrayLike | str,\n    scalex: bool = True,\n    scaley: bool = True,\n    data=None,\n    **kwargs,\n) -> list[Line2D]:\n    return gca().plot(\n        *args,\n        scalex=scalex,\n        scaley=scaley,\n        **({\"data\": data} if data is not None else {}),\n        **kwargs,\n    )\n", "type": "function"}, {"name": "Plot", "docstring": "", "methods": ["__init__"], "attributes": [], "code_location": {"file": "embedding_in_wx5_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 18, "end_line": 29}, "type": "class"}, {"name": "plot", "is_method": true, "class_name": "Axes", "parameters": ["self"], "calls": ["cbook.normalize_kwargs", "self.add_line", "self._request_autoscale_view", "self._request_autoscale_view", "self._get_lines"], "code_location": {"file": "_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1545, "end_line": 1796}, "code_snippet": "    def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers.\n\n        Call signatures::\n\n            plot([x], y, [fmt], *, data=None, **kwargs)\n            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        The coordinates of the points or line nodes are given by *x*, *y*.\n\n        The optional parameter *fmt* is a convenient way for defining basic\n        formatting like color, marker and linestyle. It's a shortcut string\n        notation described in the *Notes* section below.\n\n        >>> plot(x, y)        # plot x and y using default line style and color\n        >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n        >>> plot(y)           # plot y using x as index array 0..N-1\n        >>> plot(y, 'r+')     # ditto, but with red plusses\n\n        You can use `.Line2D` properties as keyword arguments for more\n        control on the appearance. Line properties and *fmt* can be mixed.\n        The following two calls yield identical results:\n\n        >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n        >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n        ...      linewidth=2, markersize=12)\n\n        When conflicting with *fmt*, keyword arguments take precedence.\n\n\n        **Plotting labelled data**\n\n        There's a convenient way for plotting objects with labelled data (i.e.\n        data that can be accessed by index ``obj['y']``). Instead of giving\n        the data in *x* and *y*, you can provide the object in the *data*\n        parameter and just give the labels for *x* and *y*::\n\n        >>> plot('xlabel', 'ylabel', data=obj)\n\n        All indexable objects are supported. This could e.g. be a `dict`, a\n        `pandas.DataFrame` or a structured numpy array.\n\n\n        **Plotting multiple sets of data**\n\n        There are various ways to plot multiple sets of data.\n\n        - The most straight forward way is just to call `plot` multiple times.\n          Example:\n\n          >>> plot(x1, y1, 'bo')\n          >>> plot(x2, y2, 'go')\n\n        - If *x* and/or *y* are 2D arrays, a separate data set will be drawn\n          for every column. If both *x* and *y* are 2D, they must have the\n          same shape. If only one of them is 2D with shape (N, m) the other\n          must have length N and will be used for every data set m.\n\n          Example:\n\n          >>> x = [1, 2, 3]\n          >>> y = np.array([[1, 2], [3, 4], [5, 6]])\n          >>> plot(x, y)\n\n          is equivalent to:\n\n          >>> for col in range(y.shape[1]):\n          ...     plot(x, y[:, col])\n\n        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n          groups::\n\n          >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n\n          In this case, any additional keyword argument applies to all\n          datasets. Also, this syntax cannot be combined with the *data*\n          parameter.\n\n        By default, each line is assigned a different style specified by a\n        'style cycle'. The *fmt* and line property parameters are only\n        necessary if you want explicit deviations from these defaults.\n        Alternatively, you can also change the style cycle using\n        :rc:`axes.prop_cycle`.\n\n\n        Parameters\n        ----------\n        x, y : array-like or float\n            The horizontal / vertical coordinates of the data points.\n            *x* values are optional and default to ``range(len(y))``.\n\n            Commonly, these parameters are 1D arrays.\n\n            They can also be scalars, or two-dimensional (in that case, the\n            columns represent separate data sets).\n\n            These arguments cannot be passed as keywords.\n\n        fmt : str, optional\n            A format string, e.g. 'ro' for red circles. See the *Notes*\n            section for a full description of the format strings.\n\n            Format strings are just an abbreviation for quickly setting\n            basic line properties. All of these and more can also be\n            controlled by keyword arguments.\n\n            This argument cannot be passed as keyword.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n            .. note::\n                Technically there's a slight ambiguity in calls where the\n                second label is a valid *fmt*. ``plot('n', 'o', data=obj)``\n                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                ``plot('n', 'o', '', data=obj)``.\n\n        Returns\n        -------\n        list of `.Line2D`\n            A list of lines representing the plotted data.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, default: True\n            These parameters determine if the view limits are adapted to the\n            data limits. The values are passed on to\n            `~.axes.Axes.autoscale_view`.\n\n        **kwargs : `~matplotlib.lines.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you specify multiple lines with one plot call, the kwargs apply\n            to all those lines. In case the label object is iterable, each\n            element is used as labels for each set of data.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(Line2D:kwdoc)s\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n        Other combinations such as ``[color][marker][line]`` are also\n        supported, but note that their parsing may be ambiguous.\n\n        **Markers**\n\n        =============   ===============================\n        character       description\n        =============   ===============================\n        ``'.'``         point marker\n        ``','``         pixel marker\n        ``'o'``         circle marker\n        ``'v'``         triangle_down marker\n        ``'^'``         triangle_up marker\n        ``'<'``         triangle_left marker\n        ``'>'``         triangle_right marker\n        ``'1'``         tri_down marker\n        ``'2'``         tri_up marker\n        ``'3'``         tri_left marker\n        ``'4'``         tri_right marker\n        ``'8'``         octagon marker\n        ``'s'``         square marker\n        ``'p'``         pentagon marker\n        ``'P'``         plus (filled) marker\n        ``'*'``         star marker\n        ``'h'``         hexagon1 marker\n        ``'H'``         hexagon2 marker\n        ``'+'``         plus marker\n        ``'x'``         x marker\n        ``'X'``         x (filled) marker\n        ``'D'``         diamond marker\n        ``'d'``         thin_diamond marker\n        ``'|'``         vline marker\n        ``'_'``         hline marker\n        =============   ===============================\n\n        **Line Styles**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'-'``          solid line style\n        ``'--'``         dashed line style\n        ``'-.'``         dash-dot line style\n        ``':'``          dotted line style\n        =============    ===============================\n\n        Example format strings::\n\n            'b'    # blue markers with default shape\n            'or'   # red circles\n            '-g'   # green solid line\n            '--'   # dashed line with default color\n            '^k:'  # black triangle_up markers connected by a dotted line\n\n        **Colors**\n\n        The supported color abbreviations are the single letter codes\n\n        =============    ===============================\n        character        color\n        =============    ===============================\n        ``'b'``          blue\n        ``'g'``          green\n        ``'r'``          red\n        ``'c'``          cyan\n        ``'m'``          magenta\n        ``'y'``          yellow\n        ``'k'``          black\n        ``'w'``          white\n        =============    ===============================\n\n        and the ``'CN'`` colors that index into the default property cycle.\n\n        If the color is the only part of the format string, you can\n        additionally use any  `matplotlib.colors` spec, e.g. full names\n        (``'green'``) or hex strings (``'#008000'``).\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        lines = [*self._get_lines(self, *args, data=data, **kwargs)]\n        for line in lines:\n            self.add_line(line)\n        if scalex:\n            self._request_autoscale_view(\"x\")\n        if scaley:\n            self._request_autoscale_view(\"y\")\n        return lines\n", "type": "function"}, {"name": "plotting_function", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.rc_context", "plt.plot"], "code_location": {"file": "customizing.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/users_explain", "start_line": 78, "end_line": 79}, "code_snippet": "def plotting_function():\n    plt.plot(data)\n", "type": "function"}, {"name": "PlotError", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "plot_directive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/sphinxext", "start_line": 542, "end_line": 543}, "type": "class"}, {"name": "boilerplate_gen", "is_method": false, "class_name": null, "parameters": [], "calls": ["spec.split", "generate_function", "spec.split", "generate_function", "CMAP_TEMPLATE.format", "cmappable.get"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 195, "end_line": 368}, "code_snippet": "def boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n        'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n        'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        template = (AXES_CMAPPABLE_METHOD_TEMPLATE if name in cmappable else\n                    AXES_METHOD_TEMPLATE)\n        yield generate_function(name, f'Axes.{called_name}', template,\n                                sci_command=cmappable.get(name))\n\n    cmaps = (\n        'autumn',\n        'bone',\n        'cool',\n        'copper',\n        'flag',\n        'gray',\n        'hot',\n        'hsv',\n        'jet',\n        'pink',\n        'prism',\n        'spring',\n        'summer',\n        'winter',\n        'magma',\n        'inferno',\n        'plasma',\n        'viridis',\n        \"nipy_spectral\"\n    )\n    # add all the colormaps (autumn, hsv, ....)\n    for name in cmaps:\n        yield AUTOGEN_MSG\n        yield CMAP_TEMPLATE.format(name=name)\n", "type": "function"}, {"name": "plot", "is_method": true, "class_name": "DataDisplayDownsampler", "parameters": ["self", "ax"], "calls": ["self._downsample", "ax.plot", "ax.fill_between", "self.origXData.min", "self.origXData.max"], "code_location": {"file": "resample.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 32, "end_line": 35}, "code_snippet": "    def plot(self, ax):\n        x, y1, y2 = self._downsample(self.origXData.min(), self.origXData.max())\n        (self.line,) = ax.plot(x, y1, 'o-')\n        self.poly_collection = ax.fill_between(x, y1, y2, step=\"pre\", color=\"r\")\n", "type": "function"}, {"name": "TestPlotNumlike", "docstring": "", "methods": ["test_plot_numlike"], "attributes": ["numlike_cases"], "code_location": {"file": "test_category.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 187, "end_line": 200}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "_process_plot_var_args", "parameters": ["self", "axes"], "calls": ["axes._process_unit_info", "ValueError", "_api.kwarg_error", "cbook.sanitize_sequence", "mpl._replacer", "len", "kwargs.get", "mpl._label_from_arg", "len", "len", "cbook.is_scalar_or_string", "isinstance", "self._plot_args", "len", "kwargs.get", "_process_plot_format", "len", "ValueError", "inspect.stack", "_api.warn_external"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 226, "end_line": 299}, "code_snippet": "    def __call__(self, axes, *args, data=None, return_kwargs=False, **kwargs):\n        axes._process_unit_info(kwargs=kwargs)\n\n        for pos_only in \"xy\":\n            if pos_only in kwargs:\n                raise _api.kwarg_error(inspect.stack()[1].function, pos_only)\n\n        if not args:\n            return\n\n        if data is None:  # Process dict views\n            args = [cbook.sanitize_sequence(a) for a in args]\n        else:  # Process the 'data' kwarg.\n            replaced = [mpl._replacer(data, arg) for arg in args]\n            if len(args) == 1:\n                label_namer_idx = 0\n            elif len(args) == 2:  # Can be x, y or y, c.\n                # Figure out what the second argument is.\n                # 1) If the second argument cannot be a format shorthand, the\n                #    second argument is the label_namer.\n                # 2) Otherwise (it could have been a format shorthand),\n                #    a) if we did perform a substitution, emit a warning, and\n                #       use it as label_namer.\n                #    b) otherwise, it is indeed a format shorthand; use the\n                #       first argument as label_namer.\n                try:\n                    _process_plot_format(args[1])\n                except ValueError:  # case 1)\n                    label_namer_idx = 1\n                else:\n                    if replaced[1] is not args[1]:  # case 2a)\n                        _api.warn_external(\n                            f\"Second argument {args[1]!r} is ambiguous: could \"\n                            f\"be a format string but is in 'data'; using as \"\n                            f\"data.  If it was intended as data, set the \"\n                            f\"format string to an empty string to suppress \"\n                            f\"this warning.  If it was intended as a format \"\n                            f\"string, explicitly pass the x-values as well.  \"\n                            f\"Alternatively, rename the entry in 'data'.\",\n                            RuntimeWarning)\n                        label_namer_idx = 1\n                    else:  # case 2b)\n                        label_namer_idx = 0\n            elif len(args) == 3:\n                label_namer_idx = 1\n            else:\n                raise ValueError(\n                    \"Using arbitrary long args with data is not supported due \"\n                    \"to ambiguity of arguments; use multiple plotting calls \"\n                    \"instead\")\n            if kwargs.get(\"label\") is None:\n                kwargs[\"label\"] = mpl._label_from_arg(\n                    replaced[label_namer_idx], args[label_namer_idx])\n            args = replaced\n        ambiguous_fmt_datakey = data is not None and len(args) == 2\n\n        if len(args) >= 4 and not cbook.is_scalar_or_string(\n                kwargs.get(\"label\")):\n            raise ValueError(\"plot() with multiple groups of data (i.e., \"\n                             \"pairs of x and y) does not support multiple \"\n                             \"labels\")\n\n        # Repeatedly grab (x, y) or (x, y, format) from the front of args and\n        # massage them into arguments to plot() or fill().\n\n        while args:\n            this, args = args[:2], args[2:]\n            if args and isinstance(args[0], str):\n                this += args[0],\n                args = args[1:]\n            yield from self._plot_args(\n                axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey,\n                return_kwargs=return_kwargs\n            )\n", "type": "function"}, {"name": "_process_plot_var_args", "docstring": "Process variable length arguments to `~.Axes.plot`, to support ::\n\n  plot(t, s)\n  plot(t1, s1, t2, s2)\n  plot(t1, s1, 'ko', t2, s2)\n  plot(t1, s1, 'ko', t2, s2, 'r--', t3, e3)\n\nan arbitrary number of *x*, *y*, *fmt* are allowed", "methods": ["__init__", "set_prop_cycle", "__call__", "get_next_color", "_getdefaults", "_setdefaults", "_make_line", "_make_coordinates", "_make_polygon", "_plot_args"], "attributes": [], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 205, "end_line": 538}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.3886568546295166}
{"question": "How does Matplotlib handle coordinate transformations between data and display coordinates?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles coordinate transformations between data and display coordinates through a sophisticated transformation system implemented in the transforms module. The system works as follows: 1) The core transformation system is built around the Transform class hierarchy, with CompositeGenericTransform being the most commonly used type that combines multiple transformations, 2) Each Axes object maintains several key transformation objects: transData (data to display), transAxes (axes coordinates to display), and transFigure (figure coordinates to display), 3) The transData transformation is a composite that combines the data scaling transformation (handling log/linear scales), the axes bounding box transformation, and the figure transformation, 4) Transformations can be inverted using the inverted() method, allowing conversion from display coordinates back to data coordinates, which is essential for event handling and interactive features, 5) The system supports multiple coordinate systems including data coordinates (the actual data values), axes coordinates (0-1 within the axes), figure coordinates (0-1 within the figure), and display coordinates (pixels or points), 6) Transformations are automatically updated when the figure size, DPI, axes limits, or scales change, ensuring that coordinate conversions remain accurate, 7) The transformation system handles both affine transformations (scaling, translation, rotation) and non-affine transformations (log scales, projections), with the latter being decomposed into non-affine and affine components for efficiency, 8) Artists use these transformations through their transform property, with the default being transData for most plotting elements, 9) The system provides utility functions like blended_transform_factory for creating mixed coordinate systems (e.g., data coordinates in x, axes coordinates in y) and supports custom transformations for specialized plotting needs.", "score": null, "retrieved_content": [{"name": "_set_transform", "is_method": true, "class_name": "QuiverKey", "parameters": ["self"], "calls": ["self.Q.axes.get_figure", "self.set_transform", "_api.check_getitem"], "code_location": {"file": "quiver.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 407, "end_line": 414}, "code_snippet": "    def _set_transform(self):\n        fig = self.Q.axes.get_figure(root=False)\n        self.set_transform(_api.check_getitem({\n            \"data\": self.Q.axes.transData,\n            \"axes\": self.Q.axes.transAxes,\n            \"figure\": fig.transFigure,\n            \"inches\": fig.dpi_scale_trans,\n        }, coordinates=self.coord))\n", "type": "function"}, {"name": "_set_lim_and_transforms", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "self._get_affine_transform", "BboxTransformTo", "translate", "translate", "scale", "translate", "translate", "translate", "translate", "scale", "scale", "scale", "scale", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D"], "code_location": {"file": "custom_projection.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 75, "end_line": 171}, "code_snippet": "    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n\n        # There are three important coordinate spaces going on here:\n        #\n        # 1. Data space: The space of the data itself\n        #\n        # 2. Axes space: The unit rectangle (0, 0) to (1, 1)\n        #    covering the entire plot area.\n        #\n        # 3. Display space: The coordinates of the resulting image,\n        #    often in pixels or dpi/inch.\n\n        # This function makes heavy use of the Transform classes in\n        # ``lib/matplotlib/transforms.py.`` For more information, see\n        # the inline documentation there.\n\n        # The goal of the first two transformations is to get from the\n        # data space (in this case longitude and latitude) to Axes\n        # space.  It is separated into a non-affine and affine part so\n        # that the non-affine part does not have to be recomputed when\n        # a simple affine change to the figure has been made (such as\n        # resizing the window or changing the dpi).\n\n        # 1) The core transformation from data space into\n        # rectilinear space defined in the HammerTransform class.\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        # 2) The above has an output range that is not in the unit\n        # rectangle, so scale and translate it so it fits correctly\n        # within the Axes.  The peculiar calculations of xscale and\n        # yscale are specific to an Aitoff-Hammer projection, so don't\n        # worry about them too much.\n        self.transAffine = self._get_affine_transform()\n\n        # 3) This is the transformation from Axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the '+' operator, these\n        # transforms will be applied \"in order\".  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and Axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the equator.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, 4.0)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, -4.0)\n\n        # Now set up the transforms for the latitude ticks.  The input to\n        # these transforms are in Axes space in x and display space in\n        # y.  Therefore, the input values will be in range (0, -ymin),\n        # (1, ymax).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the edge of the Axes ellipse.\n        yaxis_stretch = Affine2D().scale(np.pi*2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1.0, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8.0, 0.0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8.0, 0.0)\n", "type": "function"}, {"name": "_set_lim_and_transforms", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "self._get_affine_transform", "BboxTransformTo", "translate", "translate", "scale", "translate", "translate", "translate", "translate", "scale", "scale", "scale", "scale", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D", "Affine2D"], "code_location": {"file": "geo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 57, "end_line": 106}, "code_snippet": "    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        self.transAffine = self._get_affine_transform()\n\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # This is the transform for longitude ticks.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1, self._longitude_cap * 2) \\\n            .translate(0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, 4)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, -4)\n\n        # This is the transform for latitude ticks.\n        yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8, 0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8, 0)\n", "type": "function"}, {"name": "_set_lim_and_transforms", "is_method": true, "class_name": "ParasiteAxesBase", "parameters": ["self"], "calls": ["mtransforms.blended_transform_factory", "mtransforms.blended_transform_factory", "_set_lim_and_transforms", "super"], "code_location": {"file": "parasite_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 45, "end_line": 54}, "code_snippet": "    def _set_lim_and_transforms(self):\n        if self.transAux is not None:\n            self.transAxes = self._parent_axes.transAxes\n            self.transData = self.transAux + self._parent_axes.transData\n            self._xaxis_transform = mtransforms.blended_transform_factory(\n                self.transData, self.transAxes)\n            self._yaxis_transform = mtransforms.blended_transform_factory(\n                self.transAxes, self.transData)\n        else:\n            super()._set_lim_and_transforms()\n", "type": "function"}, {"name": "get_line_transform", "is_method": true, "class_name": "FloatingAxisArtistHelper", "parameters": ["self", "axes"], "calls": [], "code_location": {"file": "grid_helper_curvelinear.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 268, "end_line": 269}, "code_snippet": "    def get_line_transform(self, axes):\n        return axes.transData\n", "type": "function"}, {"name": "_get_xy_transform", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "coords"], "calls": ["isinstance", "tr.translate", "self._get_xy_transform", "self._get_xy_transform", "blended_transform_factory", "callable", "coords.split", "scale", "coords", "isinstance", "isinstance", "ValueError", "self.get_figure", "self._get_position_xy", "ValueError", "Affine2D", "BboxTransformTo", "isinstance", "coords.get_window_extent", "BboxTransformTo", "isinstance", "PolarAxes.PolarTransform", "self.get_figure", "Affine2D", "scale", "TypeError", "BboxTransformTo", "isinstance", "self.get_figure", "scale", "ValueError", "Affine2D", "isinstance", "TypeError", "self.get_size", "Affine2D", "self.get_figure", "type", "type"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1522, "end_line": 1594}, "code_snippet": "    def _get_xy_transform(self, renderer, coords):\n\n        if isinstance(coords, tuple):\n            xcoord, ycoord = coords\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, xcoord)\n            tr2 = self._get_xy_transform(renderer, ycoord)\n            return blended_transform_factory(tr1, tr2)\n        elif callable(coords):\n            tr = coords(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise TypeError(\n                    f\"xycoords callable must return a BboxBase or Transform, not a \"\n                    f\"{type(tr).__name__}\")\n        elif isinstance(coords, Artist):\n            bbox = coords.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(coords, BboxBase):\n            return BboxTransformTo(coords)\n        elif isinstance(coords, Transform):\n            return coords\n        elif not isinstance(coords, str):\n            raise TypeError(\n                f\"'xycoords' must be an instance of str, tuple[str, str], Artist, \"\n                f\"Transform, or Callable, not a {type(coords).__name__}\")\n\n        if coords == 'data':\n            return self.axes.transData\n        elif coords == 'polar':\n            from matplotlib.projections import PolarAxes\n            return PolarAxes.PolarTransform() + self.axes.transData\n\n        try:\n            bbox_name, unit = coords.split()\n        except ValueError:  # i.e. len(coords.split()) != 2.\n            raise ValueError(f\"{coords!r} is not a valid coordinate\") from None\n\n        bbox0, xy0 = None, None\n\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.get_figure(root=False).figbbox\n        elif bbox_name == \"subfigure\":\n            bbox0 = self.get_figure(root=False).bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n\n        # reference x, y in display coordinate\n        if bbox0 is not None:\n            xy0 = bbox0.p0\n        elif bbox_name == \"offset\":\n            xy0 = self._get_position_xy(renderer)\n        else:\n            raise ValueError(f\"{coords!r} is not a valid coordinate\")\n\n        if unit == \"points\":\n            tr = Affine2D().scale(\n                self.get_figure(root=True).dpi / 72)  # dpi/72 dots per point\n        elif unit == \"pixels\":\n            tr = Affine2D()\n        elif unit == \"fontsize\":\n            tr = Affine2D().scale(\n                self.get_size() * self.get_figure(root=True).dpi / 72)\n        elif unit == \"fraction\":\n            tr = Affine2D().scale(*bbox0.size)\n        else:\n            raise ValueError(f\"{unit!r} is not a recognized unit\")\n\n        return tr.translate(*xy0)\n", "type": "function"}, {"name": "get_transform", "is_method": true, "class_name": "AxLine", "parameters": ["self"], "calls": ["ax.transScale.transform", "points_transform.transform", "points_transform.transform", "np.isinf", "sorted", "BboxTransformTo", "ValueError", "Bbox"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1499, "end_line": 1538}, "code_snippet": "    def get_transform(self):\n        ax = self.axes\n        points_transform = self._transform - ax.transData + ax.transScale\n\n        if self._xy2 is not None:\n            # two points were given\n            (x1, y1), (x2, y2) = \\\n                points_transform.transform([self._xy1, self._xy2])\n            dx = x2 - x1\n            dy = y2 - y1\n            if dx == 0:\n                if dy == 0:\n                    raise ValueError(\n                        f\"Cannot draw a line through two identical points \"\n                        f\"(x={(x1, x2)}, y={(y1, y2)})\")\n                slope = np.inf\n            else:\n                slope = dy / dx\n        else:\n            # one point and a slope were given\n            x1, y1 = points_transform.transform(self._xy1)\n            slope = self._slope\n        (vxlo, vylo), (vxhi, vyhi) = ax.transScale.transform(ax.viewLim)\n        # General case: find intersections with view limits in either\n        # direction, and draw between the middle two points.\n        if slope == 0:\n            start = vxlo, y1\n            stop = vxhi, y1\n        elif np.isinf(slope):\n            start = x1, vylo\n            stop = x1, vyhi\n        else:\n            _, start, stop, _ = sorted([\n                (vxlo, y1 + (vxlo - x1) * slope),\n                (vxhi, y1 + (vxhi - x1) * slope),\n                (x1 + (vylo - y1) / slope, vylo),\n                (x1 + (vyhi - y1) / slope, vyhi),\n            ])\n        return (BboxTransformTo(Bbox([start, stop]))\n                + ax.transLimits + ax.transAxes)\n", "type": "function"}, {"name": "_get_xy", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "xy", "coords"], "calls": ["transform", "isinstance", "float", "float", "self.convert_xunits", "self.convert_yunits", "self._get_xy_transform"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1513, "end_line": 1520}, "code_snippet": "    def _get_xy(self, renderer, xy, coords):\n        x, y = xy\n        xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n        if xcoord == 'data':\n            x = float(self.convert_xunits(x))\n        if ycoord == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, coords).transform((x, y))\n", "type": "function"}, {"name": "get_data_transform", "is_method": true, "class_name": "Patch", "parameters": ["self"], "calls": ["artist.Artist.get_transform"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 313, "end_line": 318}, "code_snippet": "    def get_data_transform(self):\n        \"\"\"\n        Return the `~.transforms.Transform` mapping data coordinates to\n        physical coordinates.\n        \"\"\"\n        return artist.Artist.get_transform(self)\n", "type": "function"}, {"name": "test_line_extents_affine", "is_method": true, "class_name": "TestTransformPlotInterface", "parameters": ["self"], "calls": ["plt.axes", "translate", "plt.plot", "assert_array_almost_equal", "np.arange", "np.array", "ax.dataLim.get_points", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 786, "end_line": 791}, "code_snippet": "    def test_line_extents_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        plt.plot(np.arange(10), transform=offset + ax.transData)\n        expected_data_lim = np.array([[0., 0.], [9.,  9.]]) + 10\n        assert_array_almost_equal(ax.dataLim.get_points(), expected_data_lim)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34067392349243164}
{"question": "How does Matplotlib implement its rendering pipeline from Artist objects to backend output?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its rendering pipeline from Artist objects to backend output through a multi-layered architecture that separates high-level plotting logic from low-level rendering. The pipeline works as follows: 1) The rendering process starts when Figure.draw() is called, which initiates the top-level rendering pipeline that coordinates all drawing operations, 2) The Figure's draw() method calls _get_draw_artists() to collect all visible Artists, sorts them by z-order, and then calls draw() on each Artist in sequence, 3) Each Artist's draw() method takes a renderer parameter and delegates the actual drawing to backend-specific renderers through the RendererBase interface, 4) The renderer (like RendererAgg for the Agg backend) receives drawing commands from Artists and converts them into low-level graphics operations, 5) For the Agg backend, the RendererAgg class in src/_backend_agg.cpp implements the actual pixel-level drawing using the Anti-Grain Geometry library, handling operations like draw_path(), draw_markers(), draw_image(), and draw_text_image(), 6) The rendering pipeline supports various drawing primitives including paths, markers, images, text, and collections, with each primitive being processed through specialized rendering methods, 7) The pipeline handles coordinate transformations, clipping, anti-aliasing, and other rendering optimizations automatically, 8) The renderer maintains internal state like the current graphics context (colors, line styles, etc.) and manages the pixel buffer or vector output, 9) The final output is either written to a file (for non-interactive backends) or displayed on screen (for interactive backends), with the backend handling the specific output format requirements (PNG, PDF, SVG, etc.).", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "FilteredArtistList", "parameters": ["self", "renderer"], "calls": ["renderer.start_rasterizing", "renderer.start_filter", "renderer.stop_filter", "renderer.stop_rasterizing", "a.draw"], "code_location": {"file": "demo_agg_filter.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 158, "end_line": 164}, "code_snippet": "    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "FigureCanvasBase", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1906, "end_line": 1914}, "code_snippet": "    def draw(self, *args, **kwargs):\n        \"\"\"\n        Render the `.Figure`.\n\n        This method must walk the artist tree, even if no output is produced,\n        because it triggers deferred work that users may want to access\n        before saving output to disk. For example computing limits,\n        auto-limits, and tick values.\n        \"\"\"\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "renderer"], "calls": ["self._unstale_viewLim", "renderer.open_group", "self.get_axes_locator", "self.apply_aspect", "self.get_children", "artists.remove", "self._update_title_position", "sorted", "mimage._draw_list_compositing_images", "renderer.close_group", "RuntimeError", "self.get_visible", "self.spines.values", "self._axis_map.values", "canvas.is_saving", "np.searchsorted", "_draw_rasterized", "self.get_gid", "locator", "artists.remove", "artists.remove", "attrgetter", "self.get_figure", "self.get_figure", "self.get_figure", "isinstance", "a.get_animated"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 3168, "end_line": 3236}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n", "type": "function"}, {"name": "_blit_draw", "is_method": true, "class_name": "Animation", "parameters": ["self", "artists"], "calls": ["ax._get_view", "self._blit_cache.get", "a.axes.draw_artist", "ax.figure.canvas.blit", "object", "ax.figure.canvas.copy_from_bbox"], "code_location": {"file": "animation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1184, "end_line": 1204}, "code_snippet": "    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared Axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n", "type": "function"}, {"name": "RendererBase", "docstring": "An abstract base class to handle drawing/rendering operations.\n\nThe following methods must be implemented in the backend for full\nfunctionality (though just implementing `draw_path` alone would give a\nhighly capable backend):\n\n* `draw_path`\n* `draw_image`\n* `draw_gouraud_triangles`\n\nThe following methods *should* be implemented in the backend for\noptimization reasons:\n\n* `draw_text`\n* `draw_markers`\n* `draw_path_collection`\n* `draw_quad_mesh`", "methods": ["__init__", "open_group", "close_group", "draw_path", "draw_markers", "draw_path_collection", "draw_quad_mesh", "draw_gouraud_triangles", "_iter_collection_raw_paths", "_iter_collection_uses_per_path", "_iter_collection", "get_image_magnification", "draw_image", "option_image_nocomposite", "option_scale_image", "draw_tex", "draw_text", "_draw_text_as_path", "get_text_width_height_descent", "flipy", "get_canvas_width_height", "get_texmanager", "new_gc", "points_to_pixels", "start_rasterizing", "stop_rasterizing", "start_filter", "stop_filter", "_draw_disabled"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 134, "end_line": 690}, "type": "class"}, {"name": "RendererAgg", "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles", "methods": ["__init__", "__getstate__", "__setstate__", "_update_methods", "draw_path", "draw_mathtext", "draw_text", "get_text_width_height_descent", "draw_tex", "get_canvas_width_height", "_prepare_font", "points_to_pixels", "buffer_rgba", "tostring_argb", "clear", "option_image_nocomposite", "option_scale_image", "restore_region", "start_filter", "stop_filter"], "attributes": [], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 58, "end_line": 360}, "type": "class"}, {"name": "draw", "is_method": true, "class_name": "FancyArrowPatch", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._get_path_in_displaycoord", "transforms.IdentityTransform", "self._draw_paths_with_artist_properties", "self.get_visible", "np.iterable", "zip"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 4519, "end_line": 4538}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        # FIXME: dpi_cor is for the dpi-dependency of the linewidth.  There\n        # could be room for improvement.  Maybe _get_path_in_displaycoord could\n        # take a renderer argument, but get_path should be adapted too.\n        self._dpi_cor = renderer.points_to_pixels(1.)\n        path, fillable = self._get_path_in_displaycoord()\n\n        if not np.iterable(fillable):\n            path = [path]\n            fillable = [fillable]\n\n        affine = transforms.IdentityTransform()\n\n        self._draw_paths_with_artist_properties(\n            renderer,\n            [(p, affine, self._facecolor if f and self._facecolor[3] else None)\n             for p, f in zip(path, fillable)])\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Figure", "parameters": ["self", "renderer"], "calls": ["self.get_visible", "self._get_draw_artists", "_process", "renderer.open_group", "self.patch.draw", "mimage._draw_list_compositing_images", "renderer.close_group", "DrawEvent", "self.get_gid", "self.get_layout_engine", "execute", "self.get_layout_engine"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3238, "end_line": 3263}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n\n        with self._render_lock:\n\n            artists = self._get_draw_artists(renderer)\n            try:\n                renderer.open_group('figure', gid=self.get_gid())\n                if self.axes and self.get_layout_engine() is not None:\n                    try:\n                        self.get_layout_engine().execute(self)\n                    except ValueError:\n                        pass\n                        # ValueError can occur when resizing a window.\n\n                self.patch.draw(renderer)\n                mimage._draw_list_compositing_images(\n                    renderer, self, artists, self.suppressComposite)\n\n                renderer.close_group('figure')\n            finally:\n                self.stale = False\n\n            DrawEvent(\"draw_event\", self.canvas, renderer)._process()\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "SubFigure", "parameters": ["self", "renderer"], "calls": ["self._get_draw_artists", "self.get_visible", "renderer.open_group", "self.patch.draw", "mimage._draw_list_compositing_images", "renderer.close_group", "self.get_gid", "self.get_figure"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2403, "end_line": 2420}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n\n        artists = self._get_draw_artists(renderer)\n\n        try:\n            renderer.open_group('subfigure', gid=self.get_gid())\n            self.patch.draw(renderer)\n            mimage._draw_list_compositing_images(\n                renderer, self, artists, self.get_figure(root=True).suppressComposite)\n            renderer.close_group('subfigure')\n\n        finally:\n            self.stale = False\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3403041362762451}
{"question": "How does Matplotlib handle different data types and formats for plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles different data types and formats for plotting through a flexible and extensible data processing system. The system works as follows: 1) Numeric data - Matplotlib accepts numpy arrays, Python lists, and scalars that can be converted to arrays of floating point numbers using numpy.asarray(), with all sequences being converted to numpy arrays internally, 2) Categorical data - Strings and lists of strings are automatically converted to categorical variables using the StrCategoryConverter in lib/matplotlib/category.py, which maps unique string values to integer identifiers, 3) Date/time data - Datetime objects and numpy.datetime64 arrays are handled by built-in date converters that convert dates to floats and add appropriate tick locators and formatters, 4) Structured data - Matplotlib supports pandas DataFrames, structured numpy arrays, and dictionaries through the 'data' keyword argument, allowing users to reference data columns by string names, 5) Multi-dimensional arrays - 2D arrays are supported where columns represent separate datasets, with automatic handling of broadcasting and shape matching, 6) Mixed data types - The system supports combinations of different data types through the unit conversion system in matplotlib.units, which dispatches to appropriate converters based on data type, 7) Color data - Matplotlib accepts various color formats including RGB/RGBA tuples, hex strings, color names, and shorthand notation, with automatic conversion between formats, 8) Unit conversion - The system provides a framework for custom unit converters, allowing downstream libraries to add support for their specific data types, 9) Data validation - The system includes validation to ensure data types are compatible and provides helpful error messages for incompatible data, 10) Performance optimization - The system is designed to handle large datasets efficiently through vectorized operations and optimized data structures. This comprehensive data handling system enables Matplotlib to work with a wide variety of data sources and formats while maintaining performance and providing a consistent API.", "score": null, "retrieved_content": [{"name": "test_plot_format", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "plt.subplots", "ax.plot", "plt.subplots", "ax.plot", "fig.canvas.draw", "plt.subplots", "ax.plot", "fig.canvas.draw", "plt.subplots", "ax.plot", "plt.subplots", "ax.plot", "get_color", "get_marker", "get_marker", "get_color", "get_text", "get_marker", "get_text", "get_marker", "get_color", "get_marker", "get_color", "mcolors.to_rgba", "get_linestyle", "ax.get_yticklabels", "ax.get_yticklabels"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 9150, "end_line": 9176}, "code_snippet": "def test_plot_format():\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1.0')\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert line[0].get_marker() == 'None'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1')\n    assert line[0].get_marker() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1.0', \"1\")\n    fig.canvas.draw()\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert ax.get_yticklabels()[0].get_text() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1', \"1.0\")\n    fig.canvas.draw()\n    assert line[0].get_marker() == '1'\n    assert ax.get_yticklabels()[0].get_text() == '1.0'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], 'k3')\n    assert line[0].get_marker() == '3'\n    assert line[0].get_color() == 'k'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '.C12:')\n    assert line[0].get_marker() == '.'\n    assert line[0].get_color() == mcolors.to_rgba('C12')\n    assert line[0].get_linestyle() == ':'\n", "type": "function"}, {"name": "test_structured_data", "is_method": false, "class_name": null, "parameters": [], "calls": ["np.array", "subplots", "plot", "plot", "plt.figure"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 909, "end_line": 916}, "code_snippet": "def test_structured_data():\n    # support for structured data\n    pts = np.array([(1, 1), (2, 2)], dtype=[(\"ones\", float), (\"twos\", float)])\n\n    # this should not read second name as a format and raise ValueError\n    axs = plt.figure().subplots(2)\n    axs[0].plot(\"ones\", \"twos\", data=pts)\n    axs[1].plot(\"ones\", \"twos\", \"r\", data=pts)\n", "type": "function"}, {"name": "_process_plot_var_args", "docstring": "Process variable length arguments to `~.Axes.plot`, to support ::\n\n  plot(t, s)\n  plot(t1, s1, t2, s2)\n  plot(t1, s1, 'ko', t2, s2)\n  plot(t1, s1, 'ko', t2, s2, 'r--', t3, e3)\n\nan arbitrary number of *x*, *y*, *fmt* are allowed", "methods": ["__init__", "set_prop_cycle", "__call__", "get_next_color", "_getdefaults", "_setdefaults", "_make_line", "_make_coordinates", "_make_polygon", "_plot_args"], "attributes": [], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 205, "end_line": 538}, "type": "class"}, {"name": "__call__", "is_method": true, "class_name": "_process_plot_var_args", "parameters": ["self", "axes"], "calls": ["axes._process_unit_info", "ValueError", "_api.kwarg_error", "cbook.sanitize_sequence", "mpl._replacer", "len", "kwargs.get", "mpl._label_from_arg", "len", "len", "cbook.is_scalar_or_string", "isinstance", "self._plot_args", "len", "kwargs.get", "_process_plot_format", "len", "ValueError", "inspect.stack", "_api.warn_external"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 226, "end_line": 299}, "code_snippet": "    def __call__(self, axes, *args, data=None, return_kwargs=False, **kwargs):\n        axes._process_unit_info(kwargs=kwargs)\n\n        for pos_only in \"xy\":\n            if pos_only in kwargs:\n                raise _api.kwarg_error(inspect.stack()[1].function, pos_only)\n\n        if not args:\n            return\n\n        if data is None:  # Process dict views\n            args = [cbook.sanitize_sequence(a) for a in args]\n        else:  # Process the 'data' kwarg.\n            replaced = [mpl._replacer(data, arg) for arg in args]\n            if len(args) == 1:\n                label_namer_idx = 0\n            elif len(args) == 2:  # Can be x, y or y, c.\n                # Figure out what the second argument is.\n                # 1) If the second argument cannot be a format shorthand, the\n                #    second argument is the label_namer.\n                # 2) Otherwise (it could have been a format shorthand),\n                #    a) if we did perform a substitution, emit a warning, and\n                #       use it as label_namer.\n                #    b) otherwise, it is indeed a format shorthand; use the\n                #       first argument as label_namer.\n                try:\n                    _process_plot_format(args[1])\n                except ValueError:  # case 1)\n                    label_namer_idx = 1\n                else:\n                    if replaced[1] is not args[1]:  # case 2a)\n                        _api.warn_external(\n                            f\"Second argument {args[1]!r} is ambiguous: could \"\n                            f\"be a format string but is in 'data'; using as \"\n                            f\"data.  If it was intended as data, set the \"\n                            f\"format string to an empty string to suppress \"\n                            f\"this warning.  If it was intended as a format \"\n                            f\"string, explicitly pass the x-values as well.  \"\n                            f\"Alternatively, rename the entry in 'data'.\",\n                            RuntimeWarning)\n                        label_namer_idx = 1\n                    else:  # case 2b)\n                        label_namer_idx = 0\n            elif len(args) == 3:\n                label_namer_idx = 1\n            else:\n                raise ValueError(\n                    \"Using arbitrary long args with data is not supported due \"\n                    \"to ambiguity of arguments; use multiple plotting calls \"\n                    \"instead\")\n            if kwargs.get(\"label\") is None:\n                kwargs[\"label\"] = mpl._label_from_arg(\n                    replaced[label_namer_idx], args[label_namer_idx])\n            args = replaced\n        ambiguous_fmt_datakey = data is not None and len(args) == 2\n\n        if len(args) >= 4 and not cbook.is_scalar_or_string(\n                kwargs.get(\"label\")):\n            raise ValueError(\"plot() with multiple groups of data (i.e., \"\n                             \"pairs of x and y) does not support multiple \"\n                             \"labels\")\n\n        # Repeatedly grab (x, y) or (x, y, format) from the front of args and\n        # massage them into arguments to plot() or fill().\n\n        while args:\n            this, args = args[:2], args[2:]\n            if args and isinstance(args[0], str):\n                this += args[0],\n                args = args[1:]\n            yield from self._plot_args(\n                axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey,\n                return_kwargs=return_kwargs\n            )\n", "type": "function"}, {"name": "test_plot_format_errors", "is_method": false, "class_name": null, "parameters": ["fmt", "match", "data"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "plt.subplots", "match.replace", "pytest.raises", "ax.plot", "range"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 9142, "end_line": 9147}, "code_snippet": "def test_plot_format_errors(fmt, match, data):\n    fig, ax = plt.subplots()\n    if data is not None:\n        match = match.replace(\"not\", \"neither a data key nor\")\n    with pytest.raises(ValueError, match=r\"\\A\" + match + r\"\\Z\"):\n        ax.plot(\"string\", fmt, data=data)\n", "type": "function"}, {"name": "test_format_cursor_data", "is_method": false, "class_name": null, "parameters": ["data", "text"], "calls": ["pytest.mark.parametrize", "plt.subplots", "ax.imshow", "ax.transData.transform", "MouseEvent", "im.format_cursor_data", "im.get_cursor_data"], "code_location": {"file": "test_image.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 445, "end_line": 453}, "code_snippet": "def test_format_cursor_data(data, text):\n    from matplotlib.backend_bases import MouseEvent\n\n    fig, ax = plt.subplots()\n    im = ax.imshow(data)\n\n    xdisp, ydisp = ax.transData.transform([0, 0])\n    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp)\n    assert im.format_cursor_data(im.get_cursor_data(event)) == text\n", "type": "function"}, {"name": "test_mixed_type_exception", "is_method": true, "class_name": "TestPlotTypes", "parameters": ["self", "plotter", "xdata"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "subplots", "pytest.raises", "plotter", "plt.figure"], "code_location": {"file": "test_category.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 269, "end_line": 272}, "code_snippet": "    def test_mixed_type_exception(self, plotter, xdata):\n        ax = plt.figure().subplots()\n        with pytest.raises(TypeError):\n            plotter(ax, xdata, [1, 2])\n", "type": "function"}, {"name": "test_mixed_type_update_exception", "is_method": true, "class_name": "TestPlotTypes", "parameters": ["self", "plotter", "xdata"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "subplots", "pytest.raises", "plotter", "plotter", "plt.figure"], "code_location": {"file": "test_category.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 276, "end_line": 280}, "code_snippet": "    def test_mixed_type_update_exception(self, plotter, xdata):\n        ax = plt.figure().subplots()\n        with pytest.raises(TypeError):\n            plotter(ax, [0, 3], [1, 3])\n            plotter(ax, xdata, [1, 2])\n", "type": "function"}, {"name": "plot", "is_method": true, "class_name": "Axes", "parameters": ["self"], "calls": ["cbook.normalize_kwargs", "self.add_line", "self._request_autoscale_view", "self._request_autoscale_view", "self._get_lines"], "code_location": {"file": "_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1545, "end_line": 1796}, "code_snippet": "    def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers.\n\n        Call signatures::\n\n            plot([x], y, [fmt], *, data=None, **kwargs)\n            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        The coordinates of the points or line nodes are given by *x*, *y*.\n\n        The optional parameter *fmt* is a convenient way for defining basic\n        formatting like color, marker and linestyle. It's a shortcut string\n        notation described in the *Notes* section below.\n\n        >>> plot(x, y)        # plot x and y using default line style and color\n        >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n        >>> plot(y)           # plot y using x as index array 0..N-1\n        >>> plot(y, 'r+')     # ditto, but with red plusses\n\n        You can use `.Line2D` properties as keyword arguments for more\n        control on the appearance. Line properties and *fmt* can be mixed.\n        The following two calls yield identical results:\n\n        >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n        >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n        ...      linewidth=2, markersize=12)\n\n        When conflicting with *fmt*, keyword arguments take precedence.\n\n\n        **Plotting labelled data**\n\n        There's a convenient way for plotting objects with labelled data (i.e.\n        data that can be accessed by index ``obj['y']``). Instead of giving\n        the data in *x* and *y*, you can provide the object in the *data*\n        parameter and just give the labels for *x* and *y*::\n\n        >>> plot('xlabel', 'ylabel', data=obj)\n\n        All indexable objects are supported. This could e.g. be a `dict`, a\n        `pandas.DataFrame` or a structured numpy array.\n\n\n        **Plotting multiple sets of data**\n\n        There are various ways to plot multiple sets of data.\n\n        - The most straight forward way is just to call `plot` multiple times.\n          Example:\n\n          >>> plot(x1, y1, 'bo')\n          >>> plot(x2, y2, 'go')\n\n        - If *x* and/or *y* are 2D arrays, a separate data set will be drawn\n          for every column. If both *x* and *y* are 2D, they must have the\n          same shape. If only one of them is 2D with shape (N, m) the other\n          must have length N and will be used for every data set m.\n\n          Example:\n\n          >>> x = [1, 2, 3]\n          >>> y = np.array([[1, 2], [3, 4], [5, 6]])\n          >>> plot(x, y)\n\n          is equivalent to:\n\n          >>> for col in range(y.shape[1]):\n          ...     plot(x, y[:, col])\n\n        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n          groups::\n\n          >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n\n          In this case, any additional keyword argument applies to all\n          datasets. Also, this syntax cannot be combined with the *data*\n          parameter.\n\n        By default, each line is assigned a different style specified by a\n        'style cycle'. The *fmt* and line property parameters are only\n        necessary if you want explicit deviations from these defaults.\n        Alternatively, you can also change the style cycle using\n        :rc:`axes.prop_cycle`.\n\n\n        Parameters\n        ----------\n        x, y : array-like or float\n            The horizontal / vertical coordinates of the data points.\n            *x* values are optional and default to ``range(len(y))``.\n\n            Commonly, these parameters are 1D arrays.\n\n            They can also be scalars, or two-dimensional (in that case, the\n            columns represent separate data sets).\n\n            These arguments cannot be passed as keywords.\n\n        fmt : str, optional\n            A format string, e.g. 'ro' for red circles. See the *Notes*\n            section for a full description of the format strings.\n\n            Format strings are just an abbreviation for quickly setting\n            basic line properties. All of these and more can also be\n            controlled by keyword arguments.\n\n            This argument cannot be passed as keyword.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n            .. note::\n                Technically there's a slight ambiguity in calls where the\n                second label is a valid *fmt*. ``plot('n', 'o', data=obj)``\n                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                ``plot('n', 'o', '', data=obj)``.\n\n        Returns\n        -------\n        list of `.Line2D`\n            A list of lines representing the plotted data.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, default: True\n            These parameters determine if the view limits are adapted to the\n            data limits. The values are passed on to\n            `~.axes.Axes.autoscale_view`.\n\n        **kwargs : `~matplotlib.lines.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you specify multiple lines with one plot call, the kwargs apply\n            to all those lines. In case the label object is iterable, each\n            element is used as labels for each set of data.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(Line2D:kwdoc)s\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n        Other combinations such as ``[color][marker][line]`` are also\n        supported, but note that their parsing may be ambiguous.\n\n        **Markers**\n\n        =============   ===============================\n        character       description\n        =============   ===============================\n        ``'.'``         point marker\n        ``','``         pixel marker\n        ``'o'``         circle marker\n        ``'v'``         triangle_down marker\n        ``'^'``         triangle_up marker\n        ``'<'``         triangle_left marker\n        ``'>'``         triangle_right marker\n        ``'1'``         tri_down marker\n        ``'2'``         tri_up marker\n        ``'3'``         tri_left marker\n        ``'4'``         tri_right marker\n        ``'8'``         octagon marker\n        ``'s'``         square marker\n        ``'p'``         pentagon marker\n        ``'P'``         plus (filled) marker\n        ``'*'``         star marker\n        ``'h'``         hexagon1 marker\n        ``'H'``         hexagon2 marker\n        ``'+'``         plus marker\n        ``'x'``         x marker\n        ``'X'``         x (filled) marker\n        ``'D'``         diamond marker\n        ``'d'``         thin_diamond marker\n        ``'|'``         vline marker\n        ``'_'``         hline marker\n        =============   ===============================\n\n        **Line Styles**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'-'``          solid line style\n        ``'--'``         dashed line style\n        ``'-.'``         dash-dot line style\n        ``':'``          dotted line style\n        =============    ===============================\n\n        Example format strings::\n\n            'b'    # blue markers with default shape\n            'or'   # red circles\n            '-g'   # green solid line\n            '--'   # dashed line with default color\n            '^k:'  # black triangle_up markers connected by a dotted line\n\n        **Colors**\n\n        The supported color abbreviations are the single letter codes\n\n        =============    ===============================\n        character        color\n        =============    ===============================\n        ``'b'``          blue\n        ``'g'``          green\n        ``'r'``          red\n        ``'c'``          cyan\n        ``'m'``          magenta\n        ``'y'``          yellow\n        ``'k'``          black\n        ``'w'``          white\n        =============    ===============================\n\n        and the ``'CN'`` colors that index into the default property cycle.\n\n        If the color is the only part of the format string, you can\n        additionally use any  `matplotlib.colors` spec, e.g. full names\n        (``'green'``) or hex strings (``'#008000'``).\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        lines = [*self._get_lines(self, *args, data=data, **kwargs)]\n        for line in lines:\n            self.add_line(line)\n        if scalex:\n            self._request_autoscale_view(\"x\")\n        if scaley:\n            self._request_autoscale_view(\"y\")\n        return lines\n", "type": "function"}, {"name": "test_streamplot_inputs", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.streamplot", "plt.streamplot", "np.arange", "np.arange", "np.full", "np.full", "range", "range", "np.random.rand", "np.random.rand", "np.random.rand"], "code_location": {"file": "test_streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 235, "end_line": 242}, "code_snippet": "def test_streamplot_inputs():  # test no exception occurs.\n    # fully-masked\n    plt.streamplot(np.arange(3), np.arange(3),\n                   np.full((3, 3), np.nan), np.full((3, 3), np.nan),\n                   color=np.random.rand(3, 3))\n    # array-likes\n    plt.streamplot(range(3), range(3),\n                   np.random.rand(3, 3), np.random.rand(3, 3))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34652113914489746}
{"question": "How does Matplotlib implement its caching system for performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its caching system for performance optimization through multiple layers of caching mechanisms that store and reuse expensive computational results. The caching system operates as follows: 1) Artist state caching - Artists track their 'stale' state to avoid unnecessary redraws, only updating when properties have actually changed, 2) Background caching for blitting - the animation system caches static background elements (axes, labels, grid) and only redraws changing artists, dramatically improving animation performance, 3) Font and text caching - the TexManager caches compiled TeX output to avoid recompiling identical text strings, storing results in a hierarchical cache directory structure, 4) Path simplification caching - line segments are simplified and cached to reduce rendering complexity for repeated draws, 5) Renderer caching - backend renderers cache expensive operations like coordinate transformations and clipping regions, 6) Figure canvas caching - the canvas caches pixel buffers and only updates regions that have changed, 7) Style and configuration caching - rcParams and style settings are cached to avoid repeated lookups, 8) Font cache management - the Agg backend uses font_cache_manager to cache glyph data and avoid repeated font rendering operations, 9) Memory management - the caching system includes automatic cache cleanup to prevent memory bloat, with cache size limits and LRU eviction policies. These caching mechanisms work together to minimize redundant computations, reduce memory allocations, and improve rendering speed, especially for interactive plots and animations where the same elements are drawn repeatedly with only small changes.", "score": null, "retrieved_content": [{"name": "_parse_cached", "is_method": true, "class_name": "MathTextParser", "parameters": ["self", "s", "dpi", "prop", "antialiased", "load_glyph_flags"], "calls": ["functools.lru_cache", "_api.check_getitem", "fontset_class", "prop.get_size_in_points", "self._parser.parse", "_mathtext.ship", "FontProperties", "_mathtext.Parser", "output.to_vector", "prop.get_math_fontfamily", "output.to_raster"], "code_location": {"file": "mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 89, "end_line": 105}, "code_snippet": "    def _parse_cached(self, s, dpi, prop, antialiased, load_glyph_flags):\n        if prop is None:\n            prop = FontProperties()\n        fontset_class = _api.check_getitem(\n            self._font_type_mapping, fontset=prop.get_math_fontfamily())\n        fontset = fontset_class(prop, load_glyph_flags)\n        fontsize = prop.get_size_in_points()\n\n        if self._parser is None:  # Cache the parser globally.\n            self.__class__._parser = _mathtext.Parser()\n\n        box = self._parser.parse(s, fontset, fontsize, dpi)\n        output = _mathtext.ship(box)\n        if self._output_type == \"vector\":\n            return output.to_vector()\n        elif self._output_type == \"raster\":\n            return output.to_raster(antialiased=antialiased)\n", "type": "function"}, {"name": "_get_cache_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["Path", "cache_dir.mkdir", "mpl.get_cachedir"], "code_location": {"file": "compare.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/testing", "start_line": 38, "end_line": 41}, "code_snippet": "def _get_cache_path():\n    cache_dir = Path(mpl.get_cachedir(), 'test_cache')\n    cache_dir.mkdir(parents=True, exist_ok=True)\n    return cache_dir\n", "type": "function"}, {"name": "_recache", "is_method": true, "class_name": "MarkerStyle", "parameters": ["self"], "calls": ["IdentityTransform", "self._marker_function"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 250, "end_line": 264}, "code_snippet": "    def _recache(self):\n        if self._marker_function is None:\n            return\n        self._path = _empty_path\n        self._transform = IdentityTransform()\n        self._alt_path = None\n        self._alt_transform = None\n        self._snap_threshold = None\n        self._joinstyle = JoinStyle.round\n        self._capstyle = self._user_capstyle or CapStyle.butt\n        # Initial guess: Assume the marker is filled unless the fillstyle is\n        # set to 'none'. The marker function will override this for unfilled\n        # markers.\n        self._filled = self._fillstyle != 'none'\n        self._marker_function()\n", "type": "function"}, {"name": "recache", "is_method": true, "class_name": "Line2D", "parameters": ["self", "always"], "calls": ["astype", "Path", "self.convert_xunits", "ravel", "self.convert_yunits", "ravel", "_path.is_sorted_and_has_non_nan", "self.get_clip_on", "np.isnan", "nanmask.any", "np.column_stack", "len", "self.axes.get_xscale", "self.get_transform", "self._x.copy", "np.arange", "np.interp", "np.asarray", "_to_unmasked_float_array", "_to_unmasked_float_array", "np.broadcast_arrays", "len"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 674, "end_line": 717}, "code_snippet": "    def recache(self, always=False):\n        if always or self._invalidx:\n            xconv = self.convert_xunits(self._xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes\n                and len(x) > self._subslice_optim_min_size\n                and _path.is_sorted_and_has_non_nan(x)\n                and self.axes.name == 'rectilinear'\n                and self.axes.get_xscale() == 'linear'\n                and self._markevery is None\n                and self.get_clip_on()\n                and self.get_transform() == self.axes.transData):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(\n                    indices[nanmask], indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False\n", "type": "function"}, {"name": "_load_fontmanager", "is_method": false, "class_name": null, "parameters": [], "calls": ["Path", "FontManager", "json_dump", "_log.info", "mpl.get_cachedir", "json_load", "getattr", "_log.debug", "object"], "code_location": {"file": "font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1647, "end_line": 1662}, "code_snippet": "def _load_fontmanager(*, try_read_cache=True):\n    fm_path = Path(\n        mpl.get_cachedir(), f\"fontlist-v{FontManager.__version__}.json\")\n    if try_read_cache:\n        try:\n            fm = json_load(fm_path)\n        except Exception:\n            pass\n        else:\n            if getattr(fm, \"_version\", object()) == FontManager.__version__:\n                _log.debug(\"Using fontManager instance from %s\", fm_path)\n                return fm\n    fm = FontManager()\n    json_dump(fm, fm_path)\n    _log.info(\"generated new fontManager\")\n    return fm\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TruetypeFonts", "parameters": ["self", "default_font_prop", "load_glyph_flags"], "calls": ["__init__", "functools.cache", "findfont", "get_font", "super"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 335, "end_line": 345}, "code_snippet": "    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        super().__init__(default_font_prop, load_glyph_flags)\n        # Per-instance cache.\n        self._get_info = functools.cache(self._get_info)  # type: ignore[method-assign]\n        self._fonts = {}\n        self.fontmap: dict[str | int, str] = {}\n\n        filename = findfont(self.default_font_prop)\n        default_font = get_font(filename)\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font\n", "type": "function"}, {"name": "_test_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.canvas.draw", "plt.figure", "fig.draw_without_rendering", "fig.canvas.get_renderer", "fig.canvas.get_renderer"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 24}, "code_snippet": "def _test_cached_renderer():\n    # Make sure that figures have an associated renderer after\n    # a fig.canvas.draw() call\n    fig = plt.figure(1)\n    fig.canvas.draw()\n    assert fig.canvas.get_renderer()._renderer is not None\n\n    fig = plt.figure(2)\n    fig.draw_without_rendering()\n    assert fig.canvas.get_renderer()._renderer is not None\n", "type": "function"}, {"name": "_renderer", "is_method": true, "class_name": "FigureCanvasCairo", "parameters": ["self"], "calls": ["hasattr", "RendererCairo"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 404, "end_line": 411}, "code_snippet": "    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n", "type": "function"}, {"name": "_findfont_cached", "is_method": true, "class_name": "FontManager", "parameters": ["self", "prop", "fontext", "directory", "fallback_to_default", "rebuild_if_missing", "rc_params"], "calls": ["lru_cache", "FontProperties._from_any", "prop.get_file", "_log.debug", "_cached_realpath", "_log.debug", "_log.warning", "_log.debug", "os.path.isfile", "self.score_size", "_normalize_weight", "_normalize_weight", "prop.get_weight", "_log.warning", "map", "prop.copy", "default_prop.set_family", "self.findfont", "cbook._ExceptionInfo", "_log.info", "_load_fontmanager", "update", "self.findfont", "cbook._ExceptionInfo", "Path", "self.score_stretch", "prop.get_size", "prop.get_weight", "prop.get_family", "prop.get_family", "vars", "Path", "self.score_weight", "prop.get_stretch", "_log.warning", "vars", "self.score_variant", "prop.get_weight", "join", "self.score_style", "prop.get_variant", "self._expand_aliases", "self.score_family", "prop.get_style", "prop.get_family"], "code_location": {"file": "font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1452, "end_line": 1539}, "code_snippet": "    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        prop = FontProperties._from_any(prop)\n\n        fname = prop.get_file()\n        if fname is not None:\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        _log.debug('findfont: Matching %s.', prop)\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            # Matching family should have top priority, so multiply it by 10.\n            score = (self.score_family(prop.get_family(), font.name) * 10\n                     + self.score_style(prop.get_style(), font.style)\n                     + self.score_variant(prop.get_variant(), font.variant)\n                     + self.score_weight(prop.get_weight(), font.weight)\n                     + self.score_stretch(prop.get_stretch(), font.stretch)\n                     + self.score_size(prop.get_size(), font.size))\n            _log.debug('findfont: score(%s) = %s', font, score)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n        if best_font is not None and (_normalize_weight(prop.get_weight()) !=\n                                      _normalize_weight(best_font.weight)):\n            _log.warning('findfont: Failed to find font weight %s, now using %s.',\n                         prop.get_weight(), best_font.weight)\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                _log.warning(\n                    'findfont: Font family %s not found. Falling back to %s.',\n                    prop.get_family(), self.defaultFamily[fontext])\n                for family in map(str.lower, prop.get_family()):\n                    if family in font_family_aliases:\n                        _log.warning(\n                            \"findfont: Generic family %r not found because \"\n                            \"none of the following families were found: %s\",\n                            family, \", \".join(self._expand_aliases(family)))\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory,\n                                     fallback_to_default=False)\n            else:\n                # This return instead of raise is intentional, as we wish to\n                # cache that it was not found, which will not occur if it was\n                # actually raised.\n                return cbook._ExceptionInfo(\n                    ValueError,\n                    f\"Failed to find font {prop}, and fallback to the default font was \"\n                    f\"disabled\"\n                )\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                new_fm = _load_fontmanager(try_read_cache=False)\n                # Replace self by the new fontmanager, because users may have\n                # a reference to this specific instance.\n                # TODO: _load_fontmanager should really be (used by) a method\n                # modifying the instance in place.\n                vars(self).update(vars(new_fm))\n                return self.findfont(\n                    prop, fontext, directory, rebuild_if_missing=False)\n            else:\n                # This return instead of raise is intentional, as we wish to\n                # cache that it was not found, which will not occur if it was\n                # actually raised.\n                return cbook._ExceptionInfo(ValueError, \"No valid font could be found\")\n\n        return _cached_realpath(result)\n", "type": "function"}, {"name": "test_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "subprocess_run_helper"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 28, "end_line": 30}, "code_snippet": "def test_cached_renderer():\n    subprocess_run_helper(_test_cached_renderer, timeout=_test_timeout,\n                          extra_env={\"MPLBACKEND\": \"macosx\"})\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3487532138824463}
{"question": "How does Matplotlib support custom Artist classes for specialized plotting needs?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib supports custom Artist classes for specialized plotting needs through its extensible Artist hierarchy system. The support works as follows: 1) All custom Artists must inherit from the base Artist class in lib/matplotlib/artist.py, which provides the fundamental interface and properties that all visual elements share, 2) Custom Artists can be created by subclassing existing Artist types (like Line2D, Rectangle, Text) or by creating completely new Artist classes that implement the required interface, 3) The Artist class provides a comprehensive set of base methods and properties including draw(), get_children(), set_visible(), get_visible(), set_alpha(), get_alpha(), and many others that custom Artists inherit, 4) Custom Artists can be added to Axes using methods like add_artist(), add_line(), add_patch(), or by creating custom helper methods on Axes, 5) The Artist system supports automatic property management through the set() method, which allows custom Artists to define their own properties and have them automatically handled, 6) Custom Artists can implement specialized drawing logic by overriding the draw() method, which receives a renderer parameter for backend-specific rendering, 7) The Artist hierarchy supports parent-child relationships, allowing custom Artists to contain other Artists and manage their lifecycle, 8) Custom Artists can integrate with Matplotlib's event system by implementing methods like contains() for picking and event handling, 9) The system provides hooks for coordinate transformations, clipping, and other rendering features that custom Artists can leverage, 10) Custom Artists can be serialized and saved with figures, supporting features like figure pickling and state management. This extensible architecture enables users to create specialized plotting elements while maintaining compatibility with Matplotlib's rendering system and interactive features.", "score": null, "retrieved_content": [{"name": "Artist", "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.", "methods": ["__init_subclass__", "_update_set_signature_and_docstring", "__init__", "__getstate__", "remove", "have_units", "convert_xunits", "convert_yunits", "axes", "axes", "stale", "stale", "get_window_extent", "get_tightbbox", "add_callback", "remove_callback", "pchanged", "is_transform_set", "set_transform", "get_transform", "get_children", "_different_canvas", "contains", "pickable", "pick", "set_picker", "get_picker", "get_url", "set_url", "get_gid", "set_gid", "get_snap", "set_snap", "get_sketch_params", "set_sketch_params", "set_path_effects", "get_path_effects", "get_figure", "set_figure", "set_clip_box", "set_clip_path", "get_alpha", "get_visible", "get_animated", "get_in_layout", "_fully_clipped_to_axes", "get_clip_on", "get_clip_box", "get_clip_path", "get_transformed_clip_path_and_affine", "set_clip_on", "_set_gc_clip", "get_rasterized", "set_rasterized", "get_agg_filter", "set_agg_filter", "draw", "set_alpha", "_set_alpha_for_array", "set_visible", "set_animated", "set_in_layout", "get_label", "set_label", "get_zorder", "set_zorder", "sticky_edges", "update_from", "properties", "_update_props", "update", "_internal_update", "set", "_cm_set", "findobj", "get_cursor_data", "format_cursor_data", "get_mouseover", "set_mouseover"], "attributes": ["zorder", "_PROPERTIES_EXCLUDED_FROM_SET", "figure", "mouseover"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 110, "end_line": 1406}, "type": "class"}, {"name": "ColorizingArtist", "docstring": "Base class for artists that make map data to color using a `.colorizer.Colorizer`.\n\nThe `.colorizer.Colorizer` applies data normalization before\nreturning RGBA colors from a `~matplotlib.colors.Colormap`.", "methods": ["__init__", "colorizer", "colorizer", "_set_colorizer_check_keywords"], "attributes": [], "code_location": {"file": "colorizer.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 642, "end_line": 675}, "type": "class"}, {"name": "FixedAxisArtistHelper", "docstring": "", "methods": ["__init__", "update_lim", "get_tick_iterators", "get_line", "__init__", "update_lim", "get_tick_transform", "get_tick_iterators"], "attributes": [], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 28, "end_line": 105}, "type": "class"}, {"name": "SimpleAxisArtist", "docstring": "", "methods": ["__init__", "major_ticks", "major_ticklabels", "label", "set_visible", "set_label", "toggle"], "attributes": [], "code_location": {"file": "mpl_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 59, "end_line": 128}, "type": "class"}, {"name": "AxislineStyle", "docstring": "A container class which defines style classes for AxisArtists.\n\nAn instance of any axisline style class is a callable object,\nwhose call signature is ::\n\n   __call__(self, axis_artist, path, transform)\n\nWhen called, this should return an `.Artist` with the following methods::\n\n  def set_path(self, path):\n      # set the path for axisline.\n\n  def set_line_mutation_scale(self, scale):\n      # set the scale\n\n  def draw(self, renderer):\n      # draw", "methods": [], "attributes": ["_style_list"], "code_location": {"file": "axisline_style.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 93, "end_line": 192}, "type": "class"}, {"name": "ArtistInspector", "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.", "methods": ["__init__", "get_aliases", "get_valid_values", "_replace_path", "get_setters", "number_of_parameters", "is_alias", "aliased_name", "aliased_name_rest", "pprint_setters", "pprint_setters_rest", "properties", "pprint_getters"], "attributes": ["_get_valid_values_regex", "_NOT_LINKABLE"], "code_location": {"file": "artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1421, "end_line": 1720}, "type": "class"}, {"name": "AxLine", "docstring": "A helper class that implements `~.Axes.axline`, by recomputing the artist\ntransform at draw time.", "methods": ["__init__", "get_transform", "draw", "get_xy1", "get_xy2", "get_slope", "set_xy1", "set_xy2", "set_slope"], "attributes": [], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1469, "end_line": 1627}, "type": "class"}, {"name": "AxisArtist", "docstring": "An artist which draws axis (a line along which the n-th axes coord\nis constant) line, ticks, tick labels, and axis label.", "methods": ["LABELPAD", "LABELPAD", "__init__", "set_axis_direction", "set_ticklabel_direction", "invert_ticklabel_direction", "set_axislabel_direction", "get_transform", "get_helper", "set_axisline_style", "get_axisline_style", "_init_line", "_draw_line", "_init_ticks", "_get_tick_info", "_update_ticks", "_draw_ticks", "_init_offsetText", "_update_offsetText", "_draw_offsetText", "_init_label", "_update_label", "_draw_label", "set_label", "get_tightbbox", "draw", "toggle"], "attributes": ["zorder", "_offsetText_pos"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 655, "end_line": 1116}, "type": "class"}, {"name": "_set_artist_props", "is_method": true, "class_name": "Tick", "parameters": ["self", "a"], "calls": ["a.set_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 296, "end_line": 297}, "code_snippet": "    def _set_artist_props(self, a):\n        a.set_figure(self.get_figure(root=False))\n", "type": "function"}, {"name": "artists", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.ArtistList"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1520, "end_line": 1523}, "code_snippet": "    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3348960876464844}
{"question": "How does Matplotlib implement its pyplot interface for simple plotting commands?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its pyplot interface for simple plotting commands through a state-based system that provides a MATLAB-like, implicit interface. The pyplot interface works as follows: 1) The pyplot module maintains global state variables that track the current Figure and Axes objects, accessible through gcf() and gca() functions, 2) Most pyplot functions are automatically generated wrappers around Axes methods using the boilerplate.py script, which creates functions like plt.plot() that internally call gca().plot() on the current Axes, 3) The pyplot interface provides convenience functions for creating figures and axes (plt.figure(), plt.subplots(), plt.subplot()) that manage the global state and return the created objects, 4) When a pyplot function like plt.plot() is called, it first checks if there's a current Figure and Axes, creating them if necessary using the global state, 5) The pyplot functions delegate the actual plotting operations to the corresponding methods on the current Axes object, maintaining the same function signatures and parameters, 6) The interface supports both simple plotting commands (plt.plot(x, y)) and more complex operations (plt.subplot(2, 2, 1)) while hiding the underlying object management, 7) The pyplot module also provides functions for figure management (plt.show(), plt.savefig()) and global configuration (plt.rcParams), 8) The interface is designed for interactive use and simple scripts, providing a convenient way to create plots without explicitly managing Figure and Axes references, 9) The pyplot interface is built on top of the object-oriented API, serving as a convenience layer that reduces boilerplate code while still providing access to the full power of the underlying system when needed.", "score": null, "retrieved_content": [{"name": "boilerplate_gen", "is_method": false, "class_name": null, "parameters": [], "calls": ["spec.split", "generate_function", "spec.split", "generate_function", "CMAP_TEMPLATE.format", "cmappable.get"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 195, "end_line": 368}, "code_snippet": "def boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n        'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n        'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        template = (AXES_CMAPPABLE_METHOD_TEMPLATE if name in cmappable else\n                    AXES_METHOD_TEMPLATE)\n        yield generate_function(name, f'Axes.{called_name}', template,\n                                sci_command=cmappable.get(name))\n\n    cmaps = (\n        'autumn',\n        'bone',\n        'cool',\n        'copper',\n        'flag',\n        'gray',\n        'hot',\n        'hsv',\n        'jet',\n        'pink',\n        'prism',\n        'spring',\n        'summer',\n        'winter',\n        'magma',\n        'inferno',\n        'plasma',\n        'viridis',\n        \"nipy_spectral\"\n    )\n    # add all the colormaps (autumn, hsv, ....)\n    for name in cmaps:\n        yield AUTOGEN_MSG\n        yield CMAP_TEMPLATE.format(name=name)\n", "type": "function"}, {"name": "build_pyplot", "is_method": false, "class_name": null, "parameters": ["pyplot_path"], "calls": ["splitlines", "subprocess.run", "pyplot_path.open", "pyplot.writelines", "pyplot.writelines", "pyplot_path.read_text", "ValueError", "boilerplate_gen", "pyplot_orig.index"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 371, "end_line": 387}, "code_snippet": "def build_pyplot(pyplot_path):\n    pyplot_orig = pyplot_path.read_text().splitlines(keepends=True)\n    try:\n        pyplot_orig = pyplot_orig[:pyplot_orig.index(PYPLOT_MAGIC_HEADER) + 1]\n    except IndexError as err:\n        raise ValueError('The pyplot.py file *must* have the exact line: %s'\n                         % PYPLOT_MAGIC_HEADER) from err\n\n    with pyplot_path.open('w') as pyplot:\n        pyplot.writelines(pyplot_orig)\n        pyplot.writelines(boilerplate_gen())\n\n    # Run black to autoformat pyplot\n    subprocess.run(\n        [sys.executable, \"-m\", \"black\", \"--line-length=88\", pyplot_path],\n        check=True\n    )\n", "type": "function"}, {"name": "pyplot_show", "is_method": true, "class_name": "FigureManagerWebAgg", "parameters": ["cls"], "calls": ["WebAggApplication.initialize", "format", "WebAggApplication.start", "print", "webbrowser.open", "print"], "code_location": {"file": "backend_webagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 48, "end_line": 63}, "code_snippet": "    def pyplot_show(cls, *, block=None):\n        WebAggApplication.initialize()\n\n        url = \"http://{address}:{port}{prefix}\".format(\n            address=WebAggApplication.address,\n            port=WebAggApplication.port,\n            prefix=WebAggApplication.url_prefix)\n\n        if mpl.rcParams['webagg.open_in_browser']:\n            import webbrowser\n            if not webbrowser.open(url):\n                print(f\"To view figure, visit {url}\")\n        else:\n            print(f\"To view figure, visit {url}\")\n\n        WebAggApplication.start()\n", "type": "function"}, {"name": "FigureManagerTemplate", "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.  For\ninteractive backends, see the documentation of the `.FigureManagerBase`\nclass for the list of methods that can/should be overridden.", "methods": [], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 139, "end_line": 146}, "type": "class"}, {"name": "test_pylab_integration", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.importorskip", "mpl.testing.subprocess_run_helper", "join"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 352, "end_line": 363}, "code_snippet": "def test_pylab_integration():\n    IPython = pytest.importorskip(\"IPython\")\n    mpl.testing.subprocess_run_helper(\n        IPython.start_ipython,\n        \"--pylab\",\n        \"-c\",\n        \";\".join((\n            \"import matplotlib.pyplot as plt\",\n            \"assert plt._REPL_DISPLAYHOOK == plt._ReplDisplayHook.IPYTHON\",\n        )),\n        timeout=60,\n    )\n", "type": "function"}, {"name": "test_show", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["SimpleNamespace", "MagicMock", "monkeypatch.setattr", "monkeypatch.setitem", "mpl.use", "plt.show", "mock_show.assert_called_with", "vars"], "code_location": {"file": "test_backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 33, "end_line": 41}, "code_snippet": "def test_show(monkeypatch):\n    mpl_test_backend = SimpleNamespace(**vars(backend_template))\n    mock_show = MagicMock()\n    monkeypatch.setattr(\n        mpl_test_backend.FigureManagerTemplate, \"pyplot_show\", mock_show)\n    monkeypatch.setitem(sys.modules, \"mpl_test_backend\", mpl_test_backend)\n    mpl.use(\"module://mpl_test_backend\")\n    plt.show()\n    mock_show.assert_called_with()\n", "type": "function"}, {"name": "test_pyplot_up_to_date", "is_method": false, "class_name": null, "parameters": ["tmp_path"], "calls": ["pytest.importorskip", "read_text", "plt_file.write_text", "subprocess_run_for_testing", "plt_file.read_text", "gen_script.exists", "pytest.skip", "join", "pytest.fail", "Path", "str", "str", "difflib.unified_diff", "Path", "orig_contents.split", "new_contents.split"], "code_location": {"file": "test_pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 43}, "code_snippet": "def test_pyplot_up_to_date(tmp_path):\n    pytest.importorskip(\"black\")\n\n    gen_script = Path(mpl.__file__).parents[2] / \"tools/boilerplate.py\"\n    if not gen_script.exists():\n        pytest.skip(\"boilerplate.py not found\")\n    orig_contents = Path(plt.__file__).read_text()\n    plt_file = tmp_path / 'pyplot.py'\n    plt_file.write_text(orig_contents, 'utf-8')\n\n    subprocess_run_for_testing(\n        [sys.executable, str(gen_script), str(plt_file)],\n        check=True)\n    new_contents = plt_file.read_text('utf-8')\n\n    if orig_contents != new_contents:\n        diff_msg = '\\n'.join(\n            difflib.unified_diff(\n                orig_contents.split('\\n'), new_contents.split('\\n'),\n                fromfile='found pyplot.py',\n                tofile='expected pyplot.py',\n                n=0, lineterm=''))\n        pytest.fail(\n            \"pyplot.py is not up-to-date. Please run \"\n            \"'python tools/boilerplate.py' to update pyplot.py. \"\n            \"This needs to be done from an environment where your \"\n            \"current working copy is installed (e.g. 'pip install -e'd). \"\n            \"Here is a diff of unexpected differences:\\n%s\" % diff_msg\n        )\n", "type": "function"}, {"name": "value_formatter", "docstring": "Format function default values as needed for inspect.formatargspec.\nThe interesting part is a hard-coded list of functions used\nas defaults in pyplot methods.", "methods": ["__init__", "__repr__"], "attributes": [], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 75, "end_line": 98}, "type": "class"}, {"name": "test_canonical", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.subplots", "ax.plot", "platform.machine"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1754, "end_line": 1756}, "code_snippet": "def test_canonical():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3])\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3420267105102539}
{"question": "How does Matplotlib implement its backend API for third-party rendering engines?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its backend API for third-party rendering engines through a well-defined abstract interface system that allows external rendering engines to integrate with the plotting framework. The backend API works as follows: 1) The core backend interface is defined in lib/matplotlib/backend_bases.py, which contains abstract base classes like RendererBase, FigureCanvasBase, and GraphicsContextBase that define the contract that all backends must implement, 2) The backend registration system allows third-party backends to register themselves using the register_backend() function, which maps file formats to backend modules through the _default_backends dictionary, 3) Third-party backends can implement the RendererBase interface by providing concrete implementations of methods like draw_path(), draw_image(), draw_text(), and draw_markers(), 4) The backend API supports both interactive backends (for GUI display) and non-interactive backends (for file output), with different requirements for each type, 5) Backends can be registered for specific file formats using register_backend(), allowing users to choose the most appropriate rendering engine for their output needs, 6) The API provides hooks for coordinate transformations, clipping, and other rendering features that third-party engines can leverage, 7) Backends can implement format-specific optimizations and features while maintaining compatibility with the core plotting system, 8) The system supports both raster and vector rendering engines, with different capabilities and performance characteristics, 9) Third-party backends can integrate with Matplotlib's event system and interactive features by implementing the appropriate event handling methods, 10) The backend API enables the same plotting code to work across different rendering engines without modification, providing flexibility for users to choose the most appropriate output method for their specific needs. This modular architecture allows Matplotlib to support a wide range of rendering engines while maintaining a consistent high-level API.", "score": null, "retrieved_content": [{"name": "RendererBase", "docstring": "An abstract base class to handle drawing/rendering operations.\n\nThe following methods must be implemented in the backend for full\nfunctionality (though just implementing `draw_path` alone would give a\nhighly capable backend):\n\n* `draw_path`\n* `draw_image`\n* `draw_gouraud_triangles`\n\nThe following methods *should* be implemented in the backend for\noptimization reasons:\n\n* `draw_text`\n* `draw_markers`\n* `draw_path_collection`\n* `draw_quad_mesh`", "methods": ["__init__", "open_group", "close_group", "draw_path", "draw_markers", "draw_path_collection", "draw_quad_mesh", "draw_gouraud_triangles", "_iter_collection_raw_paths", "_iter_collection_uses_per_path", "_iter_collection", "get_image_magnification", "draw_image", "option_image_nocomposite", "option_scale_image", "draw_tex", "draw_text", "_draw_text_as_path", "get_text_width_height_descent", "flipy", "get_canvas_width_height", "get_texmanager", "new_gc", "points_to_pixels", "start_rasterizing", "stop_rasterizing", "start_filter", "stop_filter", "_draw_disabled"], "attributes": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 134, "end_line": 690}, "type": "class"}, {"name": "_BackendAgg", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 544, "end_line": 547}, "type": "class"}, {"name": "RendererTemplate", "docstring": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.", "methods": ["__init__", "draw_path", "draw_image", "draw_text", "flipy", "get_canvas_width_height", "get_text_width_height_descent", "new_gc", "points_to_pixels"], "attributes": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 39, "end_line": 102}, "type": "class"}, {"name": "_BackendSVG", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1380, "end_line": 1382}, "type": "class"}, {"name": "_BackendCairo", "docstring": "", "methods": [], "attributes": ["backend_version", "FigureCanvas", "FigureManager"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 526, "end_line": 529}, "type": "class"}, {"name": "_BackendPgf", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 881, "end_line": 882}, "type": "class"}, {"name": "_BackendQTCairo", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_qtcairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 45, "end_line": 46}, "type": "class"}, {"name": "_BackendGTK3Agg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_gtk3agg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 73, "end_line": 74}, "type": "class"}, {"name": "_BackendWebAggCoreAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas", "FigureManager"], "code_location": {"file": "backend_webagg_core.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 523, "end_line": 525}, "type": "class"}, {"name": "_BackendWxAgg", "docstring": "", "methods": [], "attributes": ["FigureCanvas"], "code_location": {"file": "backend_wxagg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 44, "end_line": 45}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.36216068267822266}
{"question": "How does Matplotlib handle configuration and customization through its rcParams system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles configuration and customization through its rcParams system, which provides a comprehensive framework for managing default settings and styling. The rcParams system works as follows: 1) The core configuration is managed through the RcParams class in lib/matplotlib/__init__.py, which is a dict-like object that stores all configurable parameters with validation, 2) The global rcParams instance contains all the default settings for Matplotlib, including backend selection, line styles, colors, fonts, axes properties, and many other visual elements, 3) Configuration can be set at multiple levels: runtime through direct modification of rcParams, through style sheets using matplotlib.style.use(), or through matplotlibrc files, with runtime settings taking precedence over style sheets, which take precedence over rc files, 4) The rc() function provides a convenient way to set multiple related parameters at once using group-based access (e.g., rc('lines', linewidth=2, color='red')), 5) The rc_context() context manager allows temporary changes to rcParams that are automatically reverted when the context exits, enabling localized customization without affecting global state, 6) Style sheets provide a way to package related rcParams settings together, allowing users to easily switch between different visual styles (like 'ggplot', 'dark_background', etc.), 7) The system supports validation of parameter values through the rcsetup module, ensuring that only valid values are accepted, 8) Configuration files can be loaded from multiple locations, with user-specific settings in ~/.config/matplotlib/matplotlibrc taking precedence over system defaults, 9) The rcParams system supports aliases for common parameters (like 'lw' for 'linewidth', 'c' for 'color') to reduce typing for interactive use, 10) The system provides functions like rcdefaults() and rc_file_defaults() to restore default settings, and rcParams can be copied and modified for creating custom configurations. This flexible system enables users to customize Matplotlib's appearance and behavior at multiple levels while maintaining consistency and providing sensible defaults.", "score": null, "retrieved_content": [{"name": "RcParams", "docstring": "A dict-like key-value store for config parameters, including validation.\n\nValidating functions are defined and associated with rc parameters in\n:mod:`matplotlib.rcsetup`.\n\nThe list of rcParams is:\n\n%s\n\nSee Also\n--------\n:ref:`customizing-with-matplotlibrc-files`", "methods": ["__init__", "_set", "_get", "_update_raw", "_ensure_has_backend", "__setitem__", "__getitem__", "_get_backend_or_none", "__repr__", "__str__", "__iter__", "__len__", "find_all", "copy"], "attributes": ["validate"], "code_location": {"file": "__init__.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 653, "end_line": 817}, "type": "class"}, {"name": "test_RcParams_class", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.RcParams", "lstrip", "lstrip", "repr", "str", "sorted", "list", "rc.find_all", "rc.find_all"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 74, "end_line": 104}, "code_snippet": "def test_RcParams_class():\n    rc = mpl.RcParams({'font.cursive': ['Apple Chancery',\n                                        'Textile',\n                                        'Zapf Chancery',\n                                        'cursive'],\n                       'font.family': 'sans-serif',\n                       'font.weight': 'normal',\n                       'font.size': 12})\n\n    expected_repr = \"\"\"\nRcParams({'font.cursive': ['Apple Chancery',\n                           'Textile',\n                           'Zapf Chancery',\n                           'cursive'],\n          'font.family': ['sans-serif'],\n          'font.size': 12.0,\n          'font.weight': 'normal'})\"\"\".lstrip()\n\n    assert expected_repr == repr(rc)\n\n    expected_str = \"\"\"\nfont.cursive: ['Apple Chancery', 'Textile', 'Zapf Chancery', 'cursive']\nfont.family: ['sans-serif']\nfont.size: 12.0\nfont.weight: normal\"\"\".lstrip()\n\n    assert expected_str == str(rc)\n\n    # test the find_all functionality\n    assert ['font.cursive', 'font.size'] == sorted(rc.find_all('i[vz]'))\n    assert ['font.family'] == list(rc.find_all('family'))\n", "type": "function"}, {"name": "test_constrained_layout15", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.subplots", "example_plot"], "code_location": {"file": "test_constrainedlayout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 299, "end_line": 304}, "code_snippet": "def test_constrained_layout15():\n    \"\"\"Test that rcparams work.\"\"\"\n    mpl.rcParams['figure.constrained_layout.use'] = True\n    fig, axs = plt.subplots(2, 2)\n    for ax in axs.flat:\n        example_plot(ax, fontsize=12)\n", "type": "function"}, {"name": "test_rcparams", "is_method": false, "class_name": null, "parameters": ["tmp_path"], "calls": ["mpl.rc", "mpl.rc", "rcpath.write_text", "mpl.rc_context", "func", "func", "mpl.rc_file", "mpl.rc_context", "mpl.rc_context", "mpl.rc_context"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 36, "end_line": 71}, "code_snippet": "def test_rcparams(tmp_path):\n    mpl.rc('text', usetex=False)\n    mpl.rc('lines', linewidth=22)\n\n    usetex = mpl.rcParams['text.usetex']\n    linewidth = mpl.rcParams['lines.linewidth']\n\n    rcpath = tmp_path / 'test_rcparams.rc'\n    rcpath.write_text('lines.linewidth: 33', encoding='utf-8')\n\n    # test context given dictionary\n    with mpl.rc_context(rc={'text.usetex': not usetex}):\n        assert mpl.rcParams['text.usetex'] == (not usetex)\n    assert mpl.rcParams['text.usetex'] == usetex\n\n    # test context given filename (mpl.rc sets linewidth to 33)\n    with mpl.rc_context(fname=rcpath):\n        assert mpl.rcParams['lines.linewidth'] == 33\n    assert mpl.rcParams['lines.linewidth'] == linewidth\n\n    # test context given filename and dictionary\n    with mpl.rc_context(fname=rcpath, rc={'lines.linewidth': 44}):\n        assert mpl.rcParams['lines.linewidth'] == 44\n    assert mpl.rcParams['lines.linewidth'] == linewidth\n\n    # test context as decorator (and test reusability, by calling func twice)\n    @mpl.rc_context({'lines.linewidth': 44})\n    def func():\n        assert mpl.rcParams['lines.linewidth'] == 44\n\n    func()\n    func()\n\n    # test rc_file\n    mpl.rc_file(rcpath)\n    assert mpl.rcParams['lines.linewidth'] == 33\n", "type": "function"}, {"name": "test_mfc_rcparams", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.lines.Line2D", "ln.get_markerfacecolor"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 180, "end_line": 183}, "code_snippet": "def test_mfc_rcparams():\n    mpl.rcParams['lines.markerfacecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markerfacecolor() == 'r'\n", "type": "function"}, {"name": "test_mec_rcparams", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.lines.Line2D", "ln.get_markeredgecolor"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 186, "end_line": 189}, "code_snippet": "def test_mec_rcparams():\n    mpl.rcParams['lines.markeredgecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markeredgecolor() == 'r'\n", "type": "function"}, {"name": "test_rc_spines", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "matplotlib.rc_context", "plt.subplots"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 6894, "end_line": 6901}, "code_snippet": "def test_rc_spines():\n    rc_dict = {\n        'axes.spines.left': False,\n        'axes.spines.right': False,\n        'axes.spines.top': False,\n        'axes.spines.bottom': False}\n    with matplotlib.rc_context(rc_dict):\n        plt.subplots()  # create a figure and axes with the spine properties\n", "type": "function"}, {"name": "test_rcparams", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_ref.supxlabel", "fig_ref.supylabel", "fig_ref.suptitle", "mpl.rc_context", "fig_test.supxlabel", "fig_test.supylabel", "fig_test.suptitle"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1649, "end_line": 1659}, "code_snippet": "def test_rcparams(fig_test, fig_ref):\n    fig_ref.supxlabel(\"xlabel\", weight='bold', size=15)\n    fig_ref.supylabel(\"ylabel\", weight='bold', size=15)\n    fig_ref.suptitle(\"Title\", weight='light', size=20)\n    with mpl.rc_context({'figure.labelweight': 'bold',\n                         'figure.labelsize': 15,\n                         'figure.titleweight': 'light',\n                         'figure.titlesize': 20}):\n        fig_test.supxlabel(\"xlabel\")\n        fig_test.supylabel(\"ylabel\")\n        fig_test.suptitle(\"Title\")\n", "type": "function"}, {"name": "test_rc", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "plt.subplot", "ax.scatter", "ax.legend", "plt.figure", "plt.subplot", "ax.scatter", "ax.legend", "np.arange", "np.arange", "np.arange", "np.arange"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 226, "end_line": 239}, "code_snippet": "def test_rc():\n    # using subplot triggers some offsetbox functionality untested elsewhere\n    plt.figure()\n    ax = plt.subplot(121)\n    ax.scatter(np.arange(10), np.arange(10, 0, -1), label='three')\n    ax.legend(loc=\"center left\", bbox_to_anchor=[1.0, 0.5],\n              title=\"My legend\")\n\n    mpl.rcParams['legend.scatterpoints'] = 1\n    plt.figure()\n    ax = plt.subplot(121)\n    ax.scatter(np.arange(10), np.arange(10, 0, -1), label='one')\n    ax.legend(loc=\"center left\", bbox_to_anchor=[1.0, 0.5],\n              title=\"My legend\")\n", "type": "function"}, {"name": "test_parse_math_rcparams", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.xfail", "plt.subplots", "ax.text", "pytest.raises", "fig.canvas.draw", "mpl.rc_context", "plt.subplots", "ax.text", "fig.canvas.draw"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 846, "end_line": 857}, "code_snippet": "def test_parse_math_rcparams():\n    # Default is True\n    fig, ax = plt.subplots()\n    ax.text(0, 0, r\"$ \\wrong{math} $\")\n    with pytest.raises(ValueError, match='Unknown symbol'):\n        fig.canvas.draw()\n\n    # Setting rcParams to False\n    with mpl.rc_context({'text.parse_math': False}):\n        fig, ax = plt.subplots()\n        ax.text(0, 0, r\"$ \\wrong{math} $\")\n        fig.canvas.draw()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.360013484954834}
