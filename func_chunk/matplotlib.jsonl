{"question": "What is the architectural pattern of StreamMask's trajectory recording and rollback mechanism that decouples the concerns of spatial discretization from streamline collision detection, and what architectural implications does this separation have for handling concurrent or adaptive trajectory generation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_start_trajectory", "is_method": true, "class_name": "StreamMask", "parameters": ["self", "xm", "ym", "broken_streamlines"], "calls": ["self._update_trajectory"], "code_location": {"file": "streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 453, "end_line": 456}, "code_snippet": "    def _start_trajectory(self, xm, ym, broken_streamlines=True):\n        \"\"\"Start recording streamline trajectory\"\"\"\n        self._traj = []\n        self._update_trajectory(xm, ym, broken_streamlines)\n", "type": "function"}, {"name": "start_trajectory", "is_method": true, "class_name": "DomainMap", "parameters": ["self", "xg", "yg", "broken_streamlines"], "calls": ["self.grid2mask", "self.mask._start_trajectory"], "code_location": {"file": "streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 351, "end_line": 353}, "code_snippet": "    def start_trajectory(self, xg, yg, broken_streamlines=True):\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._start_trajectory(xm, ym, broken_streamlines)\n", "type": "function"}, {"name": "undo_trajectory", "is_method": true, "class_name": "DomainMap", "parameters": ["self"], "calls": ["self.mask._undo_trajectory"], "code_location": {"file": "streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 365, "end_line": 366}, "code_snippet": "    def undo_trajectory(self):\n        self.mask._undo_trajectory()\n", "type": "function"}, {"name": "update_trajectory", "is_method": true, "class_name": "DomainMap", "parameters": ["self", "xg", "yg", "broken_streamlines"], "calls": ["self.grid2mask", "self.mask._update_trajectory", "self.grid.within_grid"], "code_location": {"file": "streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 359, "end_line": 363}, "code_snippet": "    def update_trajectory(self, xg, yg, broken_streamlines=True):\n        if not self.grid.within_grid(xg, yg):\n            raise InvalidIndexError\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._update_trajectory(xm, ym, broken_streamlines)\n", "type": "function"}, {"name": "_undo_trajectory", "is_method": true, "class_name": "StreamMask", "parameters": ["self"], "calls": [], "code_location": {"file": "streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 458, "end_line": 461}, "code_snippet": "    def _undo_trajectory(self):\n        \"\"\"Remove current trajectory from mask\"\"\"\n        for t in self._traj:\n            self._mask[t] = 0\n", "type": "function"}, {"name": "test_integration_options", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "np.meshgrid", "np.arctan2", "np.sqrt", "np.column_stack", "plt.subplots", "np.linspace", "zip", "fig.tight_layout", "np.linspace", "np.linspace", "ax.inset_axes", "zip", "ax_ins.set_xlim", "ax_ins.set_ylim", "ax_ins.set_yticks", "ax_ins.set_xticks", "ax.set_ylim", "ax.axis", "ax.indicate_inset_zoom", "np.cos", "np.sin", "np.cos", "np.full", "np.linspace", "ax_curr.streamplot", "ax_curr.fill", "ax_curr.set_aspect", "np.sin", "np.cos", "np.sin", "np.cos", "np.sin"], "code_location": {"file": "test_streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 104, "end_line": 160}, "code_snippet": "def test_integration_options():\n    # Linear potential flow over a lifting cylinder\n    n = 50\n    x, y = np.meshgrid(np.linspace(-2, 2, n), np.linspace(-3, 3, n))\n    th = np.arctan2(y, x)\n    r = np.sqrt(x**2 + y**2)\n    vr = -np.cos(th) / r**2\n    vt = -np.sin(th) / r**2 - 1 / r\n    vx = vr * np.cos(th) - vt * np.sin(th) + 1.0\n    vy = vr * np.sin(th) + vt * np.cos(th)\n\n    # Seed points\n    n_seed = 50\n    seed_pts = np.column_stack((np.full(n_seed, -1.75), np.linspace(-2, 2, n_seed)))\n\n    fig, axs = plt.subplots(3, 1, figsize=(6, 14))\n    th_circ = np.linspace(0, 2 * np.pi, 100)\n    for ax, max_val in zip(axs, [0.05, 1, 5]):\n        ax_ins = ax.inset_axes([0.0, 0.7, 0.3, 0.35])\n        for ax_curr, is_inset in zip([ax, ax_ins], [False, True]):\n            ax_curr.streamplot(\n                x,\n                y,\n                vx,\n                vy,\n                start_points=seed_pts,\n                broken_streamlines=False,\n                arrowsize=1e-10,\n                linewidth=2 if is_inset else 0.6,\n                color=\"k\",\n                integration_max_step_scale=max_val,\n                integration_max_error_scale=max_val,\n            )\n\n            # Draw the cylinder\n            ax_curr.fill(\n                np.cos(th_circ),\n                np.sin(th_circ),\n                color=\"w\",\n                ec=\"k\",\n                lw=6 if is_inset else 2,\n            )\n\n            # Set axis properties\n            ax_curr.set_aspect(\"equal\")\n\n        # Set axis limits and show zoomed region\n        ax_ins.set_xlim(-1.2, -0.7)\n        ax_ins.set_ylim(-0.8, -0.4)\n        ax_ins.set_yticks(())\n        ax_ins.set_xticks(())\n\n        ax.set_ylim(-1.5, 1.5)\n        ax.axis(\"off\")\n        ax.indicate_inset_zoom(ax_ins, ec=\"k\")\n\n    fig.tight_layout()\n", "type": "function"}, {"name": "test_masks_and_nans", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "velocity_field", "np.zeros", "np.ma.array", "subplots", "np.errstate", "ax.streamplot", "plt.figure"], "code_location": {"file": "test_streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 59, "end_line": 67}, "code_snippet": "def test_masks_and_nans():\n    X, Y, U, V = velocity_field()\n    mask = np.zeros(U.shape, dtype=bool)\n    mask[40:60, 80:120] = 1\n    U[:20, :40] = np.nan\n    U = np.ma.array(U, mask=mask)\n    ax = plt.figure().subplots()\n    with np.errstate(invalid='ignore'):\n        ax.streamplot(X, Y, U, V, color=U, cmap=\"Blues\")\n", "type": "function"}, {"name": "test_direction", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "swirl_velocity_field", "plt.streamplot"], "code_location": {"file": "test_streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 96, "end_line": 100}, "code_snippet": "def test_direction():\n    x, y, U, V = swirl_velocity_field()\n    plt.streamplot(x, y, U, V, integration_direction='backward',\n                   maxlength=1.5, start_points=[[1.5, 0.]],\n                   linewidth=2, density=2)\n", "type": "function"}, {"name": "test_streamplot", "is_method": true, "class_name": "TestDatetimePlotting", "parameters": ["self"], "calls": ["pytest.mark.xfail", "mpl.style.context", "plt.subplots", "ax.streamplot"], "code_location": {"file": "test_datetime.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 757, "end_line": 759}, "code_snippet": "    def test_streamplot(self):\n        fig, ax = plt.subplots()\n        ax.streamplot(...)\n", "type": "function"}, {"name": "test_maxlength", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "swirl_velocity_field", "subplots", "ax.streamplot", "ax.set", "plt.figure", "ax.get_xlim", "ax.get_ylim"], "code_location": {"file": "test_streamplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 72, "end_line": 79}, "code_snippet": "def test_maxlength():\n    x, y, U, V = swirl_velocity_field()\n    ax = plt.figure().subplots()\n    ax.streamplot(x, y, U, V, maxlength=10., start_points=[[0., 1.5]],\n                  linewidth=2, density=2)\n    assert ax.get_xlim()[-1] == ax.get_ylim()[-1] == 3\n    # Compatibility for old test image\n    ax.set(xlim=(None, 3.2555988021882305), ylim=(None, 3.078326760195413))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0516588687896729}
{"question": "What is the architectural separation enforced by the TestLogLocator test suite between the tick locator's core logarithmic computation logic and its integration with matplotlib's axis scaling system, particularly when handling edge cases like polar projections and shared axes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_radial_locator_wrapping", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "isinstance", "mticker.MaxNLocator", "ax.yaxis.set_major_locator", "isinstance", "ax.clear", "isinstance", "ax.set_rticks", "isinstance", "isinstance", "ax.clear", "ax.set_rgrids", "isinstance", "isinstance", "ax.clear", "ax.set_yscale", "isinstance", "isinstance", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator", "ax.yaxis.get_major_locator"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 553, "end_line": 590}, "code_snippet": "def test_radial_locator_wrapping():\n    # Check that the locator is always wrapped inside a RadialLocator\n    # and that RaidialAxis.isDefault_majloc is set correctly.\n    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n\n    # set an explicit locator\n    locator = mticker.MaxNLocator(3)\n    ax.yaxis.set_major_locator(locator)\n    assert not ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert ax.yaxis.get_major_locator().base is locator\n\n    ax.clear()  # reset to the default locator\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n\n    ax.set_rticks([0, 1, 2, 3])  # implicitly sets a FixedLocator\n    assert not ax.yaxis.isDefault_majloc  # because of the fixed ticks\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.FixedLocator)\n\n    ax.clear()\n\n    ax.set_rgrids([0, 1, 2, 3])  # implicitly sets a FixedLocator\n    assert not ax.yaxis.isDefault_majloc  # because of the fixed ticks\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.FixedLocator)\n\n    ax.clear()\n\n    ax.set_yscale(\"log\")  # implicitly sets a LogLocator\n    # Note that the LogLocator is still considered the default locator\n    # for the log scale\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.LogLocator)\n", "type": "function"}, {"name": "test_small_range_loglocator", "is_method": false, "class_name": null, "parameters": ["numticks", "lims", "ticks"], "calls": ["pytest.mark.parametrize", "mpl.style.context", "mticker.LogLocator", "assert_array_equal", "ll.tick_values"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1936, "end_line": 1938}, "code_snippet": "def test_small_range_loglocator(numticks, lims, ticks):\n    ll = mticker.LogLocator(numticks=numticks)\n    assert_array_equal(ll.tick_values(*lims), ticks)\n", "type": "function"}, {"name": "test_polar_axes", "is_method": true, "class_name": "TestLogLocator", "parameters": ["self"], "calls": ["plt.subplots", "ax.set_yscale", "ax.set_ylim", "assert_array_equal", "ax.get_yticks"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 342, "end_line": 349}, "code_snippet": "    def test_polar_axes(self):\n        \"\"\"\n        Polar Axes have a different ticking logic.\n        \"\"\"\n        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n        ax.set_yscale('log')\n        ax.set_ylim(1, 100)\n        assert_array_equal(ax.get_yticks(), [10, 100, 1000])\n", "type": "function"}, {"name": "test_polar_default_log_lims", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplot", "plt.gca", "ax.set_rscale", "ax.get_rmin"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 303, "end_line": 307}, "code_snippet": "def test_polar_default_log_lims():\n    plt.subplot(projection='polar')\n    ax = plt.gca()\n    ax.set_rscale('log')\n    assert ax.get_rmin() > 0\n", "type": "function"}, {"name": "test_default_thetalocator", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplot_mosaic", "axs.values", "axs.values", "ax.set_thetalim", "tolist", "pytest.approx", "pytest.approx", "np.degrees", "ax.xaxis.get_majorticklocs"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 378, "end_line": 389}, "code_snippet": "def test_default_thetalocator():\n    # Ideally we would check AAAABBC, but the smallest axes currently puts a\n    # single tick at 150° because MaxNLocator doesn't have a way to accept 15°\n    # while rejecting 150°.\n    fig, axs = plt.subplot_mosaic(\n        \"AAAABB.\", subplot_kw={\"projection\": \"polar\"})\n    for ax in axs.values():\n        ax.set_thetalim(0, np.pi)\n    for ax in axs.values():\n        ticklocs = np.degrees(ax.xaxis.get_majorticklocs()).tolist()\n        assert pytest.approx(90) in ticklocs\n        assert pytest.approx(100) not in ticklocs\n", "type": "function"}, {"name": "test_loglocator_properties", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.style.context", "itertools.product", "range", "itertools.combinations", "mticker.LogLocator", "astype", "range", "len", "all", "range", "round", "np.diff", "range", "np.log10", "len", "len", "len", "ll.tick_values"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1942, "end_line": 1964}, "code_snippet": "def test_loglocator_properties():\n    # Test that LogLocator returns ticks satisfying basic desirable properties\n    # for a wide range of inputs.\n    max_numticks = 8\n    pow_end = 20\n    for numticks, (lo, hi) in itertools.product(\n            range(1, max_numticks + 1), itertools.combinations(range(pow_end), 2)):\n        ll = mticker.LogLocator(numticks=numticks)\n        decades = np.log10(ll.tick_values(10**lo, 10**hi)).round().astype(int)\n        # There are no more ticks than the requested number, plus exactly one\n        # tick below and one tick above the limits.\n        assert len(decades) <= numticks + 2\n        assert decades[0] < lo <= decades[1]\n        assert decades[-2] <= hi < decades[-1]\n        stride, = {*np.diff(decades)}  # Extract the (constant) stride.\n        # Either the ticks are on integer multiples of the stride...\n        if not (decades % stride == 0).all():\n            # ... or (for this given stride) no offset would be acceptable,\n            # i.e. they would either result in fewer ticks than the selected\n            # solution, or more than the requested number of ticks.\n            for offset in range(0, stride):\n                alt_decades = range(lo + offset, hi + 1, stride)\n                assert len(alt_decades) < len(decades) or len(alt_decades) > numticks\n", "type": "function"}, {"name": "test_polar_log_rorigin", "is_method": false, "class_name": null, "parameters": ["fig_ref", "fig_test"], "calls": ["check_figures_equal", "fig_ref.add_subplot", "ax_ref.set_rlim", "ax_ref.set_rorigin", "ax_ref.set_rticks", "fig_test.add_subplot", "ax_test.set_rscale", "ax_test.set_rlim", "ax_test.set_rorigin", "ax_test.set_rticks", "np.linspace", "np.logspace", "ax.tick_params"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 488, "end_line": 504}, "code_snippet": "def test_polar_log_rorigin(fig_ref, fig_test):\n    # Test that equivalent linear and log radial settings give the same axes patch\n    # and spines.\n    ax_ref = fig_ref.add_subplot(projection='polar', facecolor='red')\n    ax_ref.set_rlim(0, 2)\n    ax_ref.set_rorigin(-3)\n    ax_ref.set_rticks(np.linspace(0, 2, 5))\n\n    ax_test = fig_test.add_subplot(projection='polar', facecolor='red')\n    ax_test.set_rscale('log')\n    ax_test.set_rlim(1, 100)\n    ax_test.set_rorigin(10**-3)\n    ax_test.set_rticks(np.logspace(0, 2, 5))\n\n    for ax in ax_ref, ax_test:\n        # Radial tick labels should be the only difference, so turn them off.\n        ax.tick_params(labelleft=False)\n", "type": "function"}, {"name": "test_log_locator_levels", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.subplots", "np.linspace", "np.linspace", "np.meshgrid", "np.exp", "np.exp", "ax.contourf", "assert_array_almost_equal", "fig.colorbar", "assert_array_almost_equal", "np.power", "cb.ax.get_yticks", "ticker.LogLocator", "np.arange"], "code_location": {"file": "test_contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 197, "end_line": 214}, "code_snippet": "def test_log_locator_levels():\n\n    fig, ax = plt.subplots()\n\n    N = 100\n    x = np.linspace(-3.0, 3.0, N)\n    y = np.linspace(-2.0, 2.0, N)\n\n    X, Y = np.meshgrid(x, y)\n\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\n    data = Z1 + 50 * Z2\n\n    c = ax.contourf(data, locator=ticker.LogLocator())\n    assert_array_almost_equal(c.levels, np.power(10.0, np.arange(-6, 3)))\n    cb = fig.colorbar(c, ax=ax)\n    assert_array_almost_equal(cb.ax.get_yticks(), c.levels)\n", "type": "function"}, {"name": "test_switch_to_autolocator", "is_method": true, "class_name": "TestLogLocator", "parameters": ["self"], "calls": ["mticker.LogLocator", "assert_array_equal", "mticker.LogLocator", "mticker.LogLocator", "loc.tick_values", "assert_array_equal", "loc.tick_values", "loc.tick_values", "loc.tick_values", "np.arange"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 351, "end_line": 362}, "code_snippet": "    def test_switch_to_autolocator(self):\n        loc = mticker.LogLocator(subs=\"all\")\n        assert_array_equal(loc.tick_values(0.45, 0.55),\n                           [0.44, 0.46, 0.48, 0.5, 0.52, 0.54, 0.56])\n        # check that we *skip* 1.0, and 10, because this is a minor locator\n        loc = mticker.LogLocator(subs=np.arange(2, 10))\n        assert 1.0 not in loc.tick_values(0.9, 20.)\n        assert 10.0 not in loc.tick_values(0.9, 20.)\n        # don't switch if there's already one major and one minor tick (10 & 20)\n        loc = mticker.LogLocator(subs=\"auto\")\n        tv = loc.tick_values(10, 20)\n        assert_array_equal(tv[(10 <= tv) & (tv <= 20)], [20])\n", "type": "function"}, {"name": "test_log_scales_no_data", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set", "ax.xaxis.set_major_locator", "mticker.MultipleLocator", "ax.get_xlim", "ax.get_ylim"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3338, "end_line": 3342}, "code_snippet": "def test_log_scales_no_data():\n    _, ax = plt.subplots()\n    ax.set(xscale=\"log\", yscale=\"log\")\n    ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n    assert ax.get_xlim() == ax.get_ylim() == (1, 10)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0583243370056152}
{"question": "What dependencies does the _Edge_integer class's __init__ method establish with the Locator hierarchy to ensure tick calculation consistency across different axis scaling scenarios?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_Edge_integer", "docstring": "Helper for `.MaxNLocator`, `.MultipleLocator`, etc.\n\nTake floating-point precision limitations into account when calculating\ntick locations as integer multiples of a step.", "methods": ["__init__", "closeto", "le", "ge"], "attributes": [], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1997, "end_line": 2042}, "type": "class"}, {"name": "Locator", "docstring": "Determine tick locations.\n\nNote that the same locator should not be used across multiple\n`~matplotlib.axis.Axis` because the locator stores references to the Axis\ndata and view limits.", "methods": ["tick_values", "set_params", "__call__", "raise_if_exceeds", "nonsingular", "view_limits"], "attributes": ["MAXTICKS"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1654, "end_line": 1741}, "type": "class"}, {"name": "test_init", "is_method": true, "class_name": "TestAsinhLocator", "parameters": ["self"], "calls": ["mticker.AsinhLocator"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 653, "end_line": 657}, "code_snippet": "    def test_init(self):\n        lctr = mticker.AsinhLocator(linear_width=2.718, numticks=19)\n        assert lctr.linear_width == 2.718\n        assert lctr.numticks == 19\n        assert lctr.base == 10\n", "type": "function"}, {"name": "IndexLocator", "docstring": "Place ticks at every nth point plotted.\n\nIndexLocator assumes index plotting; i.e., that the ticks are placed at integer\nvalues in the range between 0 and len(data) inclusive.", "methods": ["__init__", "set_params", "__call__", "tick_values"], "attributes": [], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1744, "end_line": 1771}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "GridHelperCurveLinear", "parameters": ["self", "aux_trans", "extremes", "grid_locator1", "grid_locator2", "tick_formatter1", "tick_formatter2"], "calls": ["__init__", "super", "ExtremeFinderFixed"], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 130, "end_line": 141}, "code_snippet": "    def __init__(self, aux_trans, extremes,\n                 grid_locator1=None,\n                 grid_locator2=None,\n                 tick_formatter1=None,\n                 tick_formatter2=None):\n        # docstring inherited\n        super().__init__(aux_trans,\n                         extreme_finder=ExtremeFinderFixed(extremes),\n                         grid_locator1=grid_locator1,\n                         grid_locator2=grid_locator2,\n                         tick_formatter1=tick_formatter1,\n                         tick_formatter2=tick_formatter2)\n", "type": "function"}, {"name": "LinearLocator", "docstring": "Place ticks at evenly spaced values.\n\nThe first time this function is called, it will try to set the number of\nticks to make a nice tick partitioning.  Thereafter, the number of ticks\nwill be fixed to avoid jumping during interactive navigation.", "methods": ["__init__", "numticks", "numticks", "set_params", "__call__", "tick_values", "view_limits"], "attributes": [], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1836, "end_line": 1913}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "LogFormatter", "parameters": ["self", "base", "labelOnlyBase", "minor_thresholds", "linthresh"], "calls": ["self.set_base", "self.set_label_minor"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 906, "end_line": 919}, "code_snippet": "    def __init__(self, base=10.0, labelOnlyBase=False,\n                 minor_thresholds=None,\n                 linthresh=None):\n\n        self.set_base(base)\n        self.set_label_minor(labelOnlyBase)\n        if minor_thresholds is None:\n            if mpl.rcParams['_internal.classic_mode']:\n                minor_thresholds = (0, 0)\n            else:\n                minor_thresholds = (1, 0.4)\n        self.minor_thresholds = minor_thresholds\n        self._sublabels = None\n        self._linthresh = linthresh\n", "type": "function"}, {"name": "StrCategoryLocator", "docstring": "Tick at every integer mapping of the string data.", "methods": ["__init__", "__call__", "tick_values"], "attributes": [], "code_location": {"file": "category.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 119, "end_line": 136}, "type": "class"}, {"name": "tick_values", "is_method": true, "class_name": "MultipleLocator", "parameters": ["self", "vmin", "vmax"], "calls": ["self.raise_if_exceeds", "self._edge.ge", "np.arange"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1958, "end_line": 1967}, "code_snippet": "    def tick_values(self, vmin, vmax):\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        step = self._edge.step\n        vmin -= self._offset\n        vmax -= self._offset\n        vmin = self._edge.ge(vmin) * step\n        n = (vmax - vmin + 0.001 * step) // step\n        locs = vmin - step + np.arange(n + 3) * step + self._offset\n        return self.raise_if_exceeds(locs)\n", "type": "function"}, {"name": "set_locs", "is_method": true, "class_name": "EngFormatter", "parameters": ["self", "locs"], "calls": ["len", "sorted", "self._set_format", "self.axis.get_view_interval", "self._compute_offset", "math.floor", "round", "math.log"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1442, "end_line": 1460}, "code_snippet": "    def set_locs(self, locs):\n        # docstring inherited\n        self.locs = locs\n        if len(self.locs) > 0:\n            vmin, vmax = sorted(self.axis.get_view_interval())\n            if self._useOffset:\n                self._compute_offset()\n                if self.offset != 0:\n                    # We don't want to use the offset computed by\n                    # self._compute_offset because it rounds the offset unaware\n                    # of our engineering prefixes preference, and this can\n                    # cause ticks with 4+ digits to appear. These ticks are\n                    # slightly less readable, so if offset is justified\n                    # (decided by self._compute_offset) we set it to better\n                    # value:\n                    self.offset = round((vmin + vmax)/2, 3)\n            # Use log1000 to use engineers' oom standards\n            self.orderOfMagnitude = math.floor(math.log(vmax - vmin, 1000))*3\n            self._set_format()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0418100357055664}
{"question": "What is the synchronization mechanism of the _expect method that integrates with the broader LatexManager architecture to maintain process state consistency across asynchronous LaTeX subprocess communication?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_expect", "is_method": true, "class_name": "LatexManager", "parameters": ["self", "s"], "calls": ["list", "join", "self.latex.stdout.read", "chars.append", "self.latex.kill", "LatexError", "join", "len"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 240, "end_line": 252}, "code_snippet": "    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n", "type": "function"}, {"name": "_setup_latex_process", "is_method": true, "class_name": "LatexManager", "parameters": ["self"], "calls": ["weakref.finalize", "self._stdin_writeln", "subprocess.Popen", "latex.kill", "self._build_latex_header", "self._expect", "self._expect_prompt", "RuntimeError", "RuntimeError", "latex.communicate", "latex.wait"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 276, "end_line": 309}, "code_snippet": "    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with or `wait()` on\n        # it.\n        try:\n            self.latex = subprocess.Popen(\n                [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{mpl.rcParams['pgf.texsystem']!r} not found; install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX implementation\"\n            ) from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting {mpl.rcParams['pgf.texsystem']!r}\") from err\n\n        def finalize_latex(latex):\n            latex.kill()\n            try:\n                latex.communicate()\n            except RuntimeError:\n                latex.wait()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        if expect_reply:  # read until 'pgf_backend_query_start' token appears\n            self._expect(\"*pgf_backend_query_start\")\n            self._expect_prompt()\n", "type": "function"}, {"name": "_expect_prompt", "is_method": true, "class_name": "LatexManager", "parameters": ["self"], "calls": ["self._expect"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 254, "end_line": 255}, "code_snippet": "    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n", "type": "function"}, {"name": "_stdin_writeln", "is_method": true, "class_name": "LatexManager", "parameters": ["self", "s"], "calls": ["self.latex.stdin.write", "self.latex.stdin.write", "self.latex.stdin.flush", "self._setup_latex_process"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 233, "end_line": 238}, "code_snippet": "    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n", "type": "function"}, {"name": "_new_proc", "is_method": true, "class_name": "_LuatexKpsewhich", "parameters": ["self"], "calls": ["subprocess.Popen", "str", "cbook._get_data_path"], "code_location": {"file": "dviread.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1095, "end_line": 1099}, "code_snippet": "    def _new_proc(self):\n        return subprocess.Popen(\n            [\"luatex\", \"--luaonly\",\n             str(cbook._get_data_path(\"kpsewhich.lua\"))],\n            stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n", "type": "function"}, {"name": "_run_latex", "is_method": true, "class_name": "PdfPages", "parameters": ["self"], "calls": ["TemporaryDirectory", "pathlib.Path", "tex_source.write_bytes", "cbook._check_and_log_subprocess", "shutil.move", "self._file.getvalue", "tex_source.with_suffix"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 961, "end_line": 970}, "code_snippet": "    def _run_latex(self):\n        texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        with TemporaryDirectory() as tmpdir:\n            tex_source = pathlib.Path(tmpdir, \"pdf_pages.tex\")\n            tex_source.write_bytes(self._file.getvalue())\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 tex_source],\n                _log, cwd=tmpdir)\n            shutil.move(tex_source.with_suffix(\".pdf\"), self._output_name)\n", "type": "function"}, {"name": "_post", "is_method": true, "class_name": "Dvi", "parameters": ["self", "_"], "calls": ["_dispatch"], "code_location": {"file": "dviread.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 545, "end_line": 546}, "code_snippet": "    def _post(self, _):\n        self.state = _dvistate.post_post\n", "type": "function"}, {"name": "LatexManager", "docstring": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.", "methods": ["_build_latex_header", "_get_cached_or_new", "_get_cached_or_new_impl", "_stdin_writeln", "_expect", "_expect_prompt", "__init__", "_setup_latex_process", "get_width_height_descent", "_get_box_metrics"], "attributes": [], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 198, "end_line": 347}, "type": "class"}, {"name": "_get_image_inclusion_command", "is_method": false, "class_name": null, "parameters": [], "calls": ["functools.lru_cache", "LatexManager._get_cached_or_new", "man._stdin_writeln", "man._expect_prompt", "as_posix", "LatexManager._get_cached_or_new_impl.cache_clear", "cbook._get_data_path"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 351, "end_line": 363}, "code_snippet": "def _get_image_inclusion_command():\n    man = LatexManager._get_cached_or_new()\n    man._stdin_writeln(\n        r\"\\includegraphics[interpolate=true]{%s}\"\n        # Don't mess with backslashes on Windows.\n        % cbook._get_data_path(\"images/matplotlib.png\").as_posix())\n    try:\n        man._expect_prompt()\n        return r\"\\includegraphics\"\n    except LatexError:\n        # Discard the broken manager.\n        LatexManager._get_cached_or_new_impl.cache_clear()\n        return r\"\\pgfimage\"\n", "type": "function"}, {"name": "_run_checked_subprocess", "is_method": true, "class_name": "TexManager", "parameters": ["cls", "command", "tex"], "calls": ["_log.debug", "_log.debug", "cbook._pformat_subprocess", "subprocess.check_output", "RuntimeError", "RuntimeError", "format", "cbook._pformat_subprocess", "tex.encode", "exc.output.decode"], "code_location": {"file": "texmanager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 252, "end_line": 275}, "code_snippet": "    def _run_checked_subprocess(cls, command, tex, *, cwd=None):\n        _log.debug(cbook._pformat_subprocess(command))\n        try:\n            report = subprocess.check_output(\n                command, cwd=cwd if cwd is not None else cls._texcache,\n                stderr=subprocess.STDOUT)\n        except FileNotFoundError as exc:\n            raise RuntimeError(\n                f'Failed to process string with tex because {command[0]} '\n                'could not be found') from exc\n        except subprocess.CalledProcessError as exc:\n            raise RuntimeError(\n                '{prog} was not able to process the following string:\\n'\n                '{tex!r}\\n\\n'\n                'Here is the full command invocation and its output:\\n\\n'\n                '{format_command}\\n\\n'\n                '{exc}\\n\\n'.format(\n                    prog=command[0],\n                    format_command=cbook._pformat_subprocess(command),\n                    tex=tex.encode('unicode_escape'),\n                    exc=exc.output.decode('utf-8', 'backslashreplace'))\n                ) from None\n        _log.debug(report)\n        return report\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0780954360961914}
{"question": "What is the coordination mechanism of the LockableBbox class between the invalidation mechanism and the masked array operations that ensures changes to locked points trigger proper cache invalidation in the child bbox dependency chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_points", "is_method": true, "class_name": "LockableBbox", "parameters": ["self"], "calls": ["self._bbox.get_points", "np.where"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1214, "end_line": 1222}, "code_snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._bbox.get_points()\n            self._points = np.where(self._locked_points.mask,\n                                    points,\n                                    self._locked_points)\n            self._invalid = 0\n        return self._points\n", "type": "function"}, {"name": "locked_x0", "is_method": true, "class_name": "LockableBbox", "parameters": ["self", "x0"], "calls": ["self.invalidate"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1243, "end_line": 1246}, "code_snippet": "    def locked_x0(self, x0):\n        self._locked_points.mask[0, 0] = x0 is None\n        self._locked_points.data[0, 0] = x0\n        self.invalidate()\n", "type": "function"}, {"name": "locked_x1", "is_method": true, "class_name": "LockableBbox", "parameters": ["self", "x1"], "calls": ["self.invalidate"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1275, "end_line": 1278}, "code_snippet": "    def locked_x1(self, x1):\n        self._locked_points.mask[1, 0] = x1 is None\n        self._locked_points.data[1, 0] = x1\n        self.invalidate()\n", "type": "function"}, {"name": "get_points", "is_method": true, "class_name": "TransformedBbox", "parameters": ["self"], "calls": ["self._bbox.get_points", "self._transform.transform", "np.ma.filled", "np.array", "min", "max", "min", "max"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1129, "end_line": 1157}, "code_snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n            # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points\n", "type": "function"}, {"name": "locked_y1", "is_method": true, "class_name": "LockableBbox", "parameters": ["self", "y1"], "calls": ["self.invalidate"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1291, "end_line": 1294}, "code_snippet": "    def locked_y1(self, y1):\n        self._locked_points.mask[1, 1] = y1 is None\n        self._locked_points.data[1, 1] = y1\n        self.invalidate()\n", "type": "function"}, {"name": "locked_y0", "is_method": true, "class_name": "LockableBbox", "parameters": ["self", "y0"], "calls": ["self.invalidate"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1259, "end_line": 1262}, "code_snippet": "    def locked_y0(self, y0):\n        self._locked_points.mask[0, 1] = y0 is None\n        self._locked_points.data[0, 1] = y0\n        self.invalidate()\n", "type": "function"}, {"name": "recache", "is_method": true, "class_name": "Line2D", "parameters": ["self", "always"], "calls": ["astype", "Path", "self.convert_xunits", "ravel", "self.convert_yunits", "ravel", "_path.is_sorted_and_has_non_nan", "self.get_clip_on", "np.isnan", "nanmask.any", "np.column_stack", "len", "self.axes.get_xscale", "self.get_transform", "self._x.copy", "np.arange", "np.interp", "np.asarray", "_to_unmasked_float_array", "_to_unmasked_float_array", "np.broadcast_arrays", "len"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 674, "end_line": 717}, "code_snippet": "    def recache(self, always=False):\n        if always or self._invalidx:\n            xconv = self.convert_xunits(self._xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes\n                and len(x) > self._subslice_optim_min_size\n                and _path.is_sorted_and_has_non_nan(x)\n                and self.axes.name == 'rectilinear'\n                and self.axes.get_xscale() == 'linear'\n                and self._markevery is None\n                and self.get_clip_on()\n                and self.get_transform() == self.axes.transData):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(\n                    indices[nanmask], indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False\n", "type": "function"}, {"name": "_invalidate_internal", "is_method": true, "class_name": "CompositeGenericTransform", "parameters": ["self", "level", "invalidating_node"], "calls": ["_invalidate_internal", "super"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2394, "end_line": 2399}, "code_snippet": "    def _invalidate_internal(self, level, invalidating_node):\n        # When the left child is invalidated at AFFINE_ONLY level and the right child is\n        # non-affine, the composite transform is FULLY invalidated.\n        if invalidating_node is self._a and not self._b.is_affine:\n            level = Transform._INVALID_FULL\n        super()._invalidate_internal(level, invalidating_node)\n", "type": "function"}, {"name": "get_points", "is_method": true, "class_name": "_WedgeBbox", "parameters": ["self"], "calls": ["copy", "min", "mpatches.Wedge", "self.update_from_path", "np.array", "wedge.get_path", "max", "max", "self._viewLim.get_points"], "code_location": {"file": "polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 733, "end_line": 764}, "code_snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._viewLim.get_points().copy()\n            # Scale angular limits to work with Wedge.\n            points[:, 0] *= 180 / np.pi\n            if points[0, 0] > points[1, 0]:\n                points[:, 0] = points[::-1, 0]\n\n            # Scale radial limits based on origin radius.\n            points[:, 1] -= self._originLim.y0\n\n            # Scale radial limits to match axes limits.\n            rscale = 0.5 / points[1, 1]\n            points[:, 1] *= rscale\n            width = min(points[1, 1] - points[0, 1], 0.5)\n\n            # Generate bounding box for wedge.\n            wedge = mpatches.Wedge(self._center, points[1, 1],\n                                   points[0, 0], points[1, 0],\n                                   width=width)\n            self.update_from_path(wedge.get_path())\n\n            # Ensure equal aspect ratio.\n            w, h = self._points[1] - self._points[0]\n            deltah = max(w - h, 0) / 2\n            deltaw = max(h - w, 0) / 2\n            self._points += np.array([[-deltaw, -deltah], [deltaw, deltah]])\n\n            self._invalid = 0\n\n        return self._points\n", "type": "function"}, {"name": "set_array", "is_method": true, "class_name": "PolyQuadMesh", "parameters": ["self", "A"], "calls": ["self._get_unmasked_polys", "set_array", "np.array_equal", "self._set_unmasked_verts", "super", "self._get_unmasked_polys"], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2663, "end_line": 2670}, "code_snippet": "    def set_array(self, A):\n        # docstring inherited\n        prev_unmask = self._get_unmasked_polys()\n        super().set_array(A)\n        # If the mask has changed at all we need to update\n        # the set of Polys that we are drawing\n        if not np.array_equal(prev_unmask, self._get_unmasked_polys()):\n            self._set_unmasked_verts()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0613412857055664}
{"question": "How does the blend_mode parameter in shade_rgb implement a plugin-like architecture that allows both predefined blending strategies and custom callable functions, including error handling for invalid modes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "shade_rgb", "is_method": true, "class_name": "LightSource", "parameters": ["self", "rgb", "elevation", "fraction", "blend_mode", "vert_exag", "dx", "dy"], "calls": ["self.hillshade", "np.ma.is_masked", "range", "blend_mode", "ValueError"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3674, "end_line": 3746}, "code_snippet": "    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            (M, N, 3) RGB array of floats (ranging 0 to 1) with an (M, N, 1)\n            hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of '\n                                 f'{lookup.keys}') from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if np.ma.is_masked(intensity):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n", "type": "function"}, {"name": "test_light_source_topo_surface", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "cbook.get_sample_data", "mcolors.LightSource", "plt.subplots", "zip", "np.cos", "zip", "ls.shade", "ax.imshow", "ax.set"], "code_location": {"file": "test_colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 962, "end_line": 981}, "code_snippet": "def test_light_source_topo_surface():\n    \"\"\"Shades a DEM using different v.e.'s and blend modes.\"\"\"\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n    dx, dy = dem['dx'], dem['dy']\n    # Get the true cellsize in meters for accurate vertical exaggeration\n    # Convert from decimal degrees to meters\n    dx = 111320.0 * dx * np.cos(dem['ymin'])\n    dy = 111320.0 * dy\n\n    ls = mcolors.LightSource(315, 45)\n    cmap = cm.gist_earth\n\n    fig, axs = plt.subplots(nrows=3, ncols=3)\n    for row, mode in zip(axs, ['hsv', 'overlay', 'soft']):\n        for ax, ve in zip(row, [0.1, 1, 10]):\n            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,\n                           blend_mode=mode)\n            ax.imshow(rgb)\n            ax.set(xticks=[], yticks=[])\n", "type": "function"}, {"name": "shade", "is_method": true, "class_name": "LightSource", "parameters": ["self", "data", "cmap", "norm", "blend_mode", "vmin", "vmax", "vert_exag", "dx", "dy", "fraction"], "calls": ["cmap", "self.shade_rgb", "data.min", "data.max", "Normalize", "norm"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3598, "end_line": 3672}, "code_snippet": "    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : 2D array-like\n            The height values used to generate a shaded map.\n        cmap : `~matplotlib.colors.Colormap`\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in ``cmap='gist_earth'``, use\n            ``cmap=plt.get_cmap('gist_earth')`` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            \"overlay\".  Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an (M, N, 3) RGB array of floats (ranging 0 to 1) with\n            an (M, N, 1) hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : float or None, optional\n            The minimum value used in colormapping *data*. If *None* the\n            minimum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vmax : float or None, optional\n            The maximum value used in colormapping *data*. If *None* the\n            maximum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (M, N, 4) array of floats ranging between 0-1.\n        \"\"\"\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n", "type": "function"}, {"name": "test_light_source_shading_default", "is_method": false, "class_name": null, "parameters": [], "calls": ["mcolors.LightSource", "ls.shade", "assert_array_almost_equal", "np.cos", "np.array"], "code_location": {"file": "test_colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 984, "end_line": 1035}, "code_snippet": "def test_light_source_shading_default():\n    \"\"\"\n    Array comparison test for the default \"hsv\" blend mode. Ensure the\n    default result doesn't change without warning.\n    \"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.colormaps[\"copper\"]\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.45, 0.90, 0.90, 0.82, 0.62, 0.28, 0.00],\n          [0.45, 0.94, 0.99, 1.00, 1.00, 0.96, 0.65, 0.17],\n          [0.90, 0.99, 1.00, 1.00, 1.00, 1.00, 0.94, 0.35],\n          [0.90, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.49],\n          [0.82, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.41],\n          [0.62, 0.96, 1.00, 1.00, 1.00, 1.00, 0.90, 0.07],\n          [0.28, 0.65, 0.94, 1.00, 1.00, 0.90, 0.35, 0.01],\n          [0.00, 0.17, 0.35, 0.49, 0.41, 0.07, 0.01, 0.00]],\n\n         [[0.00, 0.28, 0.59, 0.72, 0.62, 0.40, 0.18, 0.00],\n          [0.28, 0.78, 0.93, 0.92, 0.83, 0.66, 0.39, 0.11],\n          [0.59, 0.93, 0.99, 1.00, 0.92, 0.75, 0.50, 0.21],\n          [0.72, 0.92, 1.00, 0.99, 0.93, 0.76, 0.51, 0.18],\n          [0.62, 0.83, 0.92, 0.93, 0.87, 0.68, 0.42, 0.08],\n          [0.40, 0.66, 0.75, 0.76, 0.68, 0.52, 0.23, 0.02],\n          [0.18, 0.39, 0.50, 0.51, 0.42, 0.23, 0.00, 0.00],\n          [0.00, 0.11, 0.21, 0.18, 0.08, 0.02, 0.00, 0.00]],\n\n         [[0.00, 0.18, 0.38, 0.46, 0.39, 0.26, 0.11, 0.00],\n          [0.18, 0.50, 0.70, 0.75, 0.64, 0.44, 0.25, 0.07],\n          [0.38, 0.70, 0.91, 0.98, 0.81, 0.51, 0.29, 0.13],\n          [0.46, 0.75, 0.98, 0.96, 0.84, 0.48, 0.22, 0.12],\n          [0.39, 0.64, 0.81, 0.84, 0.71, 0.31, 0.11, 0.05],\n          [0.26, 0.44, 0.51, 0.48, 0.31, 0.10, 0.03, 0.01],\n          [0.11, 0.25, 0.29, 0.22, 0.11, 0.03, 0.00, 0.00],\n          [0.00, 0.07, 0.13, 0.12, 0.05, 0.01, 0.00, 0.00]],\n\n         [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00]]\n         ]).T\n\n    assert_array_almost_equal(rgb, expect, decimal=2)\n", "type": "function"}, {"name": "blend_hsv", "is_method": true, "class_name": "LightSource", "parameters": ["self", "rgb", "intensity", "hsv_max_sat", "hsv_max_val", "hsv_min_val", "hsv_min_sat"], "calls": ["rgb_to_hsv", "np.moveaxis", "np.putmask", "np.putmask", "np.putmask", "np.putmask", "np.clip", "hsv_to_rgb", "np.abs", "np.abs"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3748, "end_line": 3820}, "code_snippet": "    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s, v)\n        values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : `~numpy.ndarray`\n            An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n        intensity : `~numpy.ndarray`\n            An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the output\n            image to. If not provided, use the value provided upon initialization.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the output\n            image to. If not provided, use the value provided upon initialization.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to. If not provided, use the value provided upon\n            initialization.\n        hsv_min_val : number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to. If not provided, use the value provided upon\n            initialization.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (M, N, 3) RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # Convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n        hue, sat, val = np.moveaxis(hsv, -1, 0)\n\n        # Modify hsv values (in place) to simulate illumination.\n        # putmask(A, mask, B) <=> A[mask] = B[mask]\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n                   (1 - intensity) * sat + intensity * hsv_max_sat)\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n                   (1 + intensity) * sat - intensity * hsv_min_sat)\n        np.putmask(val, intensity > 0,\n                   (1 - intensity) * val + intensity * hsv_max_val)\n        np.putmask(val, intensity < 0,\n                   (1 + intensity) * val - intensity * hsv_min_val)\n        np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n\n        # Convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n", "type": "function"}, {"name": "main", "is_method": false, "class_name": null, "parameters": [], "calls": ["cbook.get_sample_data", "compare", "fig.suptitle", "compare", "fig.suptitle", "plt.show", "np.sqrt", "np.sin"], "code_location": {"file": "shading_example.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/images_contours_and_fields", "start_line": 20, "end_line": 34}, "code_snippet": "def main():\n    # Test data\n    x, y = np.mgrid[-5:5:0.05, -5:5:0.05]\n    z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))\n\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n\n    fig = compare(z, plt.colormaps[\"copper\"])\n    fig.suptitle('HSV Blending Looks Best with Smooth Surfaces', y=0.95)\n\n    fig = compare(elev, plt.colormaps[\"gist_earth\"], ve=0.05)\n    fig.suptitle('Overlay Blending Looks Best with Rough Surfaces', y=0.95)\n\n    plt.show()\n", "type": "function"}, {"name": "compare", "is_method": false, "class_name": null, "parameters": ["z", "cmap", "ve"], "calls": ["plt.subplots", "LightSource", "imshow", "set", "imshow", "set", "ls.shade", "imshow", "set", "ls.shade", "imshow", "set", "ax.set", "ls.hillshade"], "code_location": {"file": "shading_example.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/images_contours_and_fields", "start_line": 37, "end_line": 60}, "code_snippet": "def compare(z, cmap, ve=1):\n    # Create subplots and hide ticks\n    fig, axs = plt.subplots(ncols=2, nrows=2)\n    for ax in axs.flat:\n        ax.set(xticks=[], yticks=[])\n\n    # Illuminate the scene from the northwest\n    ls = LightSource(azdeg=315, altdeg=45)\n\n    axs[0, 0].imshow(z, cmap=cmap)\n    axs[0, 0].set(xlabel='Colormapped Data')\n\n    axs[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap='gray')\n    axs[0, 1].set(xlabel='Illumination Intensity')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='hsv')\n    axs[1, 0].imshow(rgb)\n    axs[1, 0].set(xlabel='Blend Mode: \"hsv\" (default)')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='overlay')\n    axs[1, 1].imshow(rgb)\n    axs[1, 1].set(xlabel='Blend Mode: \"overlay\"')\n\n    return fig\n", "type": "function"}, {"name": "blend_soft_light", "is_method": true, "class_name": "LightSource", "parameters": ["self", "rgb", "intensity"], "calls": [], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3822, "end_line": 3839}, "code_snippet": "    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combine an RGB image with an intensity map using \"soft light\" blending,\n        using the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : `~numpy.ndarray`\n            An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n        intensity : `~numpy.ndarray`\n            An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (M, N, 3) RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n", "type": "function"}, {"name": "blend_overlay", "is_method": true, "class_name": "LightSource", "parameters": ["self", "rgb", "intensity"], "calls": ["np.where"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3841, "end_line": 3859}, "code_snippet": "    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combine an RGB image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : `~numpy.ndarray`\n            An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n        intensity : `~numpy.ndarray`\n            An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        ndarray\n            An (M, N, 3) RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n", "type": "function"}, {"name": "test_multivar_bad_mode", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.raises", "mpl.colors.MultivarColormap"], "code_location": {"file": "test_multivariate_colormaps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 194, "end_line": 197}, "code_snippet": "def test_multivar_bad_mode():\n    cmap = mpl.multivar_colormaps['2VarSubA']\n    with pytest.raises(ValueError, match=\"is not a valid value for\"):\n        cmap = mpl.colors.MultivarColormap(cmap[:], 'bad')\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0532341003417969}
{"question": "How does the _Style class leverage __new__ method interception combined with string parsing to implement a factory pattern that defers style instantiation until runtime, and what are the implications of this design choice on error handling for malformed style specifications?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_Style", "docstring": "A base class for the Styles. It is meant to be a container class,\nwhere actual styles are declared as subclass of it, and it\nprovides some helper functions.", "methods": ["__init_subclass__", "__new__", "get_styles", "pprint_styles", "register"], "attributes": [], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2310, "end_line": 2393}, "type": "class"}, {"name": "__new__", "is_method": true, "class_name": "_Style", "parameters": ["cls", "stylename"], "calls": ["split", "lower", "_cls", "stylename.replace", "ValueError", "cs.split", "float", "ValueError"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2336, "end_line": 2352}, "code_snippet": "    def __new__(cls, stylename, **kwargs):\n        \"\"\"Return the instance of the subclass with the given style name.\"\"\"\n        # The \"class\" should have the _style_list attribute, which is a mapping\n        # of style names to style classes.\n        _list = stylename.replace(\" \", \"\").split(\",\")\n        _name = _list[0].lower()\n        try:\n            _cls = cls._style_list[_name]\n        except KeyError as err:\n            raise ValueError(f\"Unknown style: {stylename!r}\") from err\n        try:\n            _args_pair = [cs.split(\"=\") for cs in _list[1:]]\n            _args = {k: float(v) for k, v in _args_pair}\n        except ValueError as err:\n            raise ValueError(\n                f\"Incorrect style argument: {stylename!r}\") from err\n        return _cls(**{**_args, **kwargs})\n", "type": "function"}, {"name": "__init_subclass__", "is_method": true, "class_name": "_Style", "parameters": ["cls"], "calls": ["_docstring.interpd.register", "cls.pprint_styles", "join", "cls.pprint_styles", "map"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2317, "end_line": 2334}, "code_snippet": "    def __init_subclass__(cls):\n        # Automatically perform docstring interpolation on the subclasses:\n        # This allows listing the supported styles via\n        # - %(BoxStyle:table)s\n        # - %(ConnectionStyle:table)s\n        # - %(ArrowStyle:table)s\n        # and additionally adding .. ACCEPTS: blocks via\n        # - %(BoxStyle:table_and_accepts)s\n        # - %(ConnectionStyle:table_and_accepts)s\n        # - %(ArrowStyle:table_and_accepts)s\n        _docstring.interpd.register(**{\n            f\"{cls.__name__}:table\": cls.pprint_styles(),\n            f\"{cls.__name__}:table_and_accepts\": (\n                cls.pprint_styles()\n                + \"\\n\\n    .. ACCEPTS: [\"\n                + \"|\".join(map(\" '{}' \".format, cls._style_list))\n                + \"]\")\n        })\n", "type": "function"}, {"name": "register", "is_method": true, "class_name": "_Style", "parameters": ["cls", "name", "style"], "calls": ["_api.deprecated", "issubclass", "ValueError"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2389, "end_line": 2393}, "code_snippet": "    def register(cls, name, style):\n        \"\"\"Register a new style.\"\"\"\n        if not issubclass(style, cls._Base):\n            raise ValueError(f\"{style} must be a subclass of {cls._Base}\")\n        cls._style_list[name] = style\n", "type": "function"}, {"name": "style_literal", "is_method": true, "class_name": "Parser", "parameters": ["self", "toks"], "calls": ["self._MathStyle", "int"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2636, "end_line": 2637}, "code_snippet": "    def style_literal(self, toks: ParseResults) -> T.Any:\n        return self._MathStyle(int(toks[\"style_literal\"]))\n", "type": "function"}, {"name": "_validate_linestyle_or_None", "is_method": false, "class_name": null, "parameters": ["s"], "calls": ["_validate_linestyle", "cbook._str_equal"], "code_location": {"file": "rcsetup.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 524, "end_line": 528}, "code_snippet": "def _validate_linestyle_or_None(s):\n    if s is None or cbook._str_equal(s, \"None\"):\n        return None\n\n    return _validate_linestyle(s)\n", "type": "function"}, {"name": "MarkerStyle", "docstring": "A class representing marker types.\n\nInstances are immutable. If you need to change anything, create a new\ninstance.\n\nAttributes\n----------\nmarkers : dict\n    All known markers.\nfilled_markers : tuple\n    All known filled markers. This is a subset of *markers*.\nfillstyles : tuple\n    The supported fillstyles.", "methods": ["__init__", "_recache", "__bool__", "is_filled", "get_fillstyle", "_set_fillstyle", "get_joinstyle", "get_capstyle", "get_marker", "_set_marker", "get_path", "get_transform", "get_alt_path", "get_alt_transform", "get_snap_threshold", "get_user_transform", "transformed", "rotated", "scaled", "_set_nothing", "_set_custom_marker", "_set_path_marker", "_set_vertices", "_set_tuple_marker", "_set_mathtext_path", "_half_fill", "_set_circle", "_set_point", "_set_pixel", "_set_triangle", "_set_triangle_up", "_set_triangle_down", "_set_triangle_left", "_set_triangle_right", "_set_square", "_set_diamond", "_set_thin_diamond", "_set_pentagon", "_set_star", "_set_hexagon1", "_set_hexagon2", "_set_octagon", "_set_vline", "_set_hline", "_set_tickleft", "_set_tickright", "_set_tickup", "_set_tickdown", "_set_tri_down", "_set_tri_up", "_set_tri_left", "_set_tri_right", "_set_caretdown", "_set_caretup", "_set_caretleft", "_set_caretright", "_set_caretdownbase", "_set_caretupbase", "_set_caretleftbase", "_set_caretrightbase", "_set_plus", "_set_x", "_set_plus_filled", "_set_x_filled"], "attributes": ["markers", "filled_markers", "fillstyles", "_half_fillstyles", "_triangle_path", "_triangle_path_u", "_triangle_path_d", "_triangle_path_l", "_triangle_path_r", "_line_marker_path", "_tickhoriz_path", "_tickvert_path", "_tri_path", "_caret_path", "_caret_path_base", "_plus_path", "_x_path", "_plus_filled_path", "_plus_filled_path_t", "_x_filled_path", "_x_filled_path_t"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 150, "end_line": 907}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Parser", "parameters": ["self"], "calls": ["types.SimpleNamespace", "Regex", "leave_whitespace", "csnames", "Literal", "one_of", "Forward", "Forward", "Forward", "Forward", "Forward", "Forward", "set_names_and_parse_actions", "cmd", "csnames", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "cmd", "OneOrMore", "QuotedString", "leave_whitespace", "set_names_and_parse_actions", "items", "Regex", "one_of", "one_of", "Regex", "Optional", "csnames", "p.named_placeable", "StringEnd", "p.required_group", "QuotedString", "StringEnd", "isalpha", "format", "p.required_group", "p.required_group", "p.required_group", "p.required_group", "p.required_group", "p.required_group", "p.required_group", "Optional", "p.required_group", "p.optional_group", "p.optional_group", "p.optional_group", "p.optional_group", "nested_expr", "p.named_placeable", "p.delim", "Error", "p.delim", "Error", "Regex", "ZeroOrMore", "vars", "key.startswith", "hasattr", "ends_with_alpha.append", "ends_with_nonalpha.append", "str", "Regex", "ZeroOrMore", "OneOrMore", "p.float_literal", "ZeroOrMore", "ZeroOrMore", "p.required_group", "Regex", "Regex", "val.set_name", "val.set_parse_action", "join", "join", "one_of", "Regex", "ZeroOrMore", "ZeroOrMore", "ZeroOrMore", "getattr", "map", "map", "format", "Group", "ZeroOrMore", "Optional", "OneOrMore", "p.delim", "Error", "join", "Optional", "OneOrMore", "OneOrMore", "suppress", "map", "one_of", "p.float_literal", "NotAny", "Literal", "Optional", "Optional"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1967, "end_line": 2150}, "code_snippet": "    def __init__(self) -> None:\n        p = types.SimpleNamespace()\n\n        def set_names_and_parse_actions() -> None:\n            for key, val in vars(p).items():\n                if not key.startswith('_'):\n                    # Set names on (almost) everything -- very useful for debugging\n                    # token, placeable, and auto_delim are forward references which\n                    # are left without names to ensure useful error messages\n                    if key not in (\"token\", \"placeable\", \"auto_delim\"):\n                        val.set_name(key)\n                    # Set actions\n                    if hasattr(self, key):\n                        val.set_parse_action(getattr(self, key))\n\n        # Root definitions.\n\n        # In TeX parlance, a csname is a control sequence name (a \"\\foo\").\n        def csnames(group: str, names: Iterable[str]) -> Regex:\n            ends_with_alpha = []\n            ends_with_nonalpha = []\n            for name in names:\n                if name[-1].isalpha():\n                    ends_with_alpha.append(name)\n                else:\n                    ends_with_nonalpha.append(name)\n            return Regex(\n                r\"\\\\(?P<{group}>(?:{alpha})(?![A-Za-z]){additional}{nonalpha})\".format(\n                    group=group,\n                    alpha=\"|\".join(map(re.escape, ends_with_alpha)),\n                    additional=\"|\" if ends_with_nonalpha else \"\",\n                    nonalpha=\"|\".join(map(re.escape, ends_with_nonalpha)),\n                )\n            )\n\n        p.float_literal  = Regex(r\"[-+]?([0-9]+\\.?[0-9]*|\\.[0-9]+)\")\n        p.space          = one_of(self._space_widths)(\"space\")\n\n        p.style_literal  = one_of(\n            [str(e.value) for e in self._MathStyle])(\"style_literal\")\n\n        p.symbol         = Regex(\n            r\"[a-zA-Z0-9 +\\-*/<>=:,.;!\\?&'@()\\[\\]|\\U00000080-\\U0001ffff]\"\n            r\"|\\\\[%${}\\[\\]_|]\"\n            + r\"|\\\\(?:{})(?![A-Za-z])\".format(\n                \"|\".join(map(re.escape, tex2uni)))\n        )(\"sym\").leave_whitespace()\n        p.unknown_symbol = Regex(r\"\\\\[A-Za-z]+\")(\"name\")\n\n        p.font           = csnames(\"font\", self._fontnames)\n        p.start_group    = Optional(r\"\\math\" + one_of(self._fontnames)(\"font\")) + \"{\"\n        p.end_group      = Literal(\"}\")\n\n        p.delim          = one_of(self._delims)\n\n        # Mutually recursive definitions.  (Minimizing the number of Forward\n        # elements is important for speed.)\n        p.auto_delim       = Forward()\n        p.placeable        = Forward()\n        p.named_placeable  = Forward()\n        p.required_group   = Forward()\n        p.optional_group   = Forward()\n        p.token            = Forward()\n\n        # Workaround for placable being part of a cycle of definitions\n        # calling `p.placeable(\"name\")` results in a copy, so not guaranteed\n        # to get the definition added after it is used.\n        # ref https://github.com/matplotlib/matplotlib/issues/25204\n        # xref https://github.com/pyparsing/pyparsing/issues/95\n        p.named_placeable <<= p.placeable\n\n        set_names_and_parse_actions()  # for mutually recursive definitions.\n\n        p.optional_group <<= \"{\" + ZeroOrMore(p.token)(\"group\") + \"}\"\n        p.required_group <<= \"{\" + OneOrMore(p.token)(\"group\") + \"}\"\n\n        p.customspace = cmd(r\"\\hspace\", \"{\" + p.float_literal(\"space\") + \"}\")\n\n        p.accent = (\n            csnames(\"accent\", [*self._accent_map, *self._wide_accents])\n            - p.named_placeable(\"sym\"))\n\n        p.function = csnames(\"name\", self._function_names)\n\n        p.group = p.start_group + ZeroOrMore(p.token)(\"group\") + p.end_group\n        p.unclosed_group = (p.start_group + ZeroOrMore(p.token)(\"group\") + StringEnd())\n\n        p.frac  = cmd(r\"\\frac\", p.required_group(\"num\") + p.required_group(\"den\"))\n        p.dfrac = cmd(r\"\\dfrac\", p.required_group(\"num\") + p.required_group(\"den\"))\n        p.binom = cmd(r\"\\binom\", p.required_group(\"num\") + p.required_group(\"den\"))\n\n        p.genfrac = cmd(\n            r\"\\genfrac\",\n            \"{\" + Optional(p.delim)(\"ldelim\") + \"}\"\n            + \"{\" + Optional(p.delim)(\"rdelim\") + \"}\"\n            + \"{\" + p.float_literal(\"rulesize\") + \"}\"\n            + \"{\" + Optional(p.style_literal)(\"style\") + \"}\"\n            + p.required_group(\"num\")\n            + p.required_group(\"den\"))\n\n        p.sqrt = cmd(\n            r\"\\sqrt{value}\",\n            Optional(\"[\" + OneOrMore(NotAny(\"]\") + p.token)(\"root\") + \"]\")\n            + p.required_group(\"value\"))\n\n        p.overline = cmd(r\"\\overline\", p.required_group(\"body\"))\n\n        p.overset  = cmd(\n            r\"\\overset\",\n            p.optional_group(\"annotation\") + p.optional_group(\"body\"))\n        p.underset = cmd(\n            r\"\\underset\",\n            p.optional_group(\"annotation\") + p.optional_group(\"body\"))\n\n        p.text = cmd(r\"\\text\", QuotedString('{', '\\\\', end_quote_char=\"}\"))\n\n        p.substack = cmd(r\"\\substack\",\n                           nested_expr(opener=\"{\", closer=\"}\",\n                                       content=Group(OneOrMore(p.token)) +\n                                       ZeroOrMore(Literal(\"\\\\\\\\\").suppress()))(\"parts\"))\n\n        p.subsuper = (\n            (Optional(p.placeable)(\"nucleus\")\n             + OneOrMore(one_of([\"_\", \"^\"]) - p.placeable)(\"subsuper\")\n             + Regex(\"'*\")(\"apostrophes\"))\n            | Regex(\"'+\")(\"apostrophes\")\n            | (p.named_placeable(\"nucleus\") + Regex(\"'*\")(\"apostrophes\"))\n        )\n\n        p.simple = p.space | p.customspace | p.font | p.subsuper\n\n        p.token <<= (\n            p.simple\n            | p.auto_delim\n            | p.unclosed_group\n            | p.unknown_symbol  # Must be last\n        )\n\n        p.operatorname = cmd(r\"\\operatorname\", \"{\" + ZeroOrMore(p.simple)(\"name\") + \"}\")\n\n        p.boldsymbol = cmd(\n            r\"\\boldsymbol\", \"{\" + ZeroOrMore(p.simple)(\"value\") + \"}\")\n\n        p.placeable     <<= (\n            p.accent     # Must be before symbol as all accents are symbols\n            | p.symbol   # Must be second to catch all named symbols and single\n                         # chars not in a group\n            | p.function\n            | p.operatorname\n            | p.group\n            | p.frac\n            | p.dfrac\n            | p.binom\n            | p.genfrac\n            | p.overset\n            | p.underset\n            | p.sqrt\n            | p.overline\n            | p.text\n            | p.boldsymbol\n            | p.substack\n        )\n\n        mdelim = r\"\\middle\" - (p.delim(\"mdelim\") | Error(\"Expected a delimiter\"))\n        p.auto_delim    <<= (\n            r\"\\left\" - (p.delim(\"left\") | Error(\"Expected a delimiter\"))\n            + ZeroOrMore(p.simple | p.auto_delim | mdelim)(\"mid\")\n            + r\"\\right\" - (p.delim(\"right\") | Error(\"Expected a delimiter\"))\n        )\n\n        # Leaf definitions.\n        p.math          = OneOrMore(p.token)\n        p.math_string   = QuotedString('$', '\\\\', unquote_results=False)\n        p.non_math      = Regex(r\"(?:(?:\\\\[$])|[^$])*\").leave_whitespace()\n        p.main          = (\n            p.non_math + ZeroOrMore(p.math_string + p.non_math) + StringEnd()\n        )\n        set_names_and_parse_actions()  # for leaf definitions.\n\n        self._expression = p.main\n        self._math_expression = p.math\n\n        # To add space to nucleus operators after sub/superscripts\n        self._in_subscript_or_superscript = False\n", "type": "function"}, {"name": "_listify_validator", "is_method": false, "class_name": null, "parameters": ["scalar_validator", "allow_stringlist"], "calls": ["isinstance", "ValueError", "np.iterable", "ValueError", "len", "f.__qualname__.rsplit", "scalar_validator", "isinstance", "scalar_validator", "v.strip", "s.split", "v.strip", "_single_string_color_list", "len", "type", "isinstance"], "code_location": {"file": "rcsetup.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 91, "end_line": 127}, "code_snippet": "def _listify_validator(scalar_validator, allow_stringlist=False, *,\n                       n=None, doc=None):\n    def f(s):\n        if isinstance(s, str):\n            try:\n                val = [scalar_validator(v.strip()) for v in s.split(',')\n                       if v.strip()]\n            except Exception:\n                if allow_stringlist:\n                    # Special handling for colors\n                    val = _single_string_color_list(s, scalar_validator)\n                else:\n                    raise\n        # Allow any ordered sequence type -- generators, np.ndarray, pd.Series\n        # -- but not sets, whose iteration order is non-deterministic.\n        elif np.iterable(s) and not isinstance(s, (set, frozenset)):\n            # The condition on this list comprehension will preserve the\n            # behavior of filtering out any empty strings (behavior was\n            # from the original validate_stringlist()), while allowing\n            # any non-string/text scalar values such as numbers and arrays.\n            val = [scalar_validator(v) for v in s\n                   if not isinstance(v, str) or v]\n        else:\n            raise ValueError(\n                f\"Expected str or other non-set iterable, but got {s}\")\n        if n is not None and len(val) != n:\n            raise ValueError(\n                f\"Expected {n} values, but there are {len(val)} values in {s}\")\n        return val\n\n    try:\n        f.__name__ = f\"{scalar_validator.__name__}list\"\n    except AttributeError:  # class instance.\n        f.__name__ = f\"{type(scalar_validator).__name__}List\"\n    f.__qualname__ = f.__qualname__.rsplit(\".\", 1)[0] + \".\" + f.__name__\n    f.__doc__ = doc if doc is not None else scalar_validator.__doc__\n    return f\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Glue", "parameters": ["self", "glue_type"], "calls": ["__init__", "isinstance", "isinstance", "super", "ValueError"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1452, "end_line": 1463}, "code_snippet": "    def __init__(self,\n                 glue_type: _GlueSpec | T.Literal[\"fil\", \"fill\", \"filll\",\n                                                  \"neg_fil\", \"neg_fill\", \"neg_filll\",\n                                                  \"empty\", \"ss\"]):\n        super().__init__()\n        if isinstance(glue_type, str):\n            glue_spec = _GlueSpec._named[glue_type]  # type: ignore[attr-defined]\n        elif isinstance(glue_type, _GlueSpec):\n            glue_spec = glue_type\n        else:\n            raise ValueError(\"glue_type must be a glue spec name or instance\")\n        self.glue_spec = glue_spec\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0718121528625488}
{"question": "What are the cascading side effects that occur when a LayoutEngine subclass fails to properly initialize the _colorbar_gridspec and _adjust_compatible class attributes before the colorbar_gridspec and adjust_compatible properties are accessed during figure rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_invalid_layouts", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "isinstance", "isinstance", "isinstance", "plt.subplots", "fig.set_layout_engine", "isinstance", "fig.set_layout_engine", "isinstance", "plt.subplots", "ax.pcolormesh", "fig.colorbar", "fig.set_layout_engine", "plt.subplots", "ax.pcolormesh", "fig.colorbar", "fig.set_layout_engine", "isinstance", "pytest.warns", "fig.subplots_adjust", "fig.get_layout_engine", "pytest.warns", "Figure", "fig.get_layout_engine", "pytest.warns", "Figure", "isinstance", "fig.get_layout_engine", "pytest.raises", "Figure", "fig.get_layout_engine", "fig.get_layout_engine", "np.random.randn", "pytest.raises", "fig.set_layout_engine", "pytest.raises", "fig.set_layout_engine", "np.random.randn", "pytest.raises", "fig.set_layout_engine", "fig.get_layout_engine", "pytest.raises", "fig.set_layout_engine", "fig.get_layout_engine"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 693, "end_line": 742}, "code_snippet": "def test_invalid_layouts():\n    fig, ax = plt.subplots(layout=\"constrained\")\n    with pytest.warns(UserWarning):\n        # this should warn,\n        fig.subplots_adjust(top=0.8)\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    # Using layout + (tight|constrained)_layout warns, but the former takes\n    # precedence.\n    wst = \"The Figure parameters 'layout' and 'tight_layout'\"\n    with pytest.warns(UserWarning, match=wst):\n        fig = Figure(layout='tight', tight_layout=False)\n    assert isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    wst = \"The Figure parameters 'layout' and 'constrained_layout'\"\n    with pytest.warns(UserWarning, match=wst):\n        fig = Figure(layout='constrained', constrained_layout=False)\n    assert not isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    with pytest.raises(ValueError,\n                       match=\"Invalid value for 'layout'\"):\n        Figure(layout='foobar')\n\n    # test that layouts can be swapped if no colorbar:\n    fig, ax = plt.subplots(layout=\"constrained\")\n    fig.set_layout_engine(\"tight\")\n    assert isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    fig.set_layout_engine(\"constrained\")\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    # test that layouts cannot be swapped if there is a colorbar:\n    fig, ax = plt.subplots(layout=\"constrained\")\n    pc = ax.pcolormesh(np.random.randn(2, 2))\n    fig.colorbar(pc)\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"tight\")\n    fig.set_layout_engine(\"none\")\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"tight\")\n\n    fig, ax = plt.subplots(layout=\"tight\")\n    pc = ax.pcolormesh(np.random.randn(2, 2))\n    fig.colorbar(pc)\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"constrained\")\n    fig.set_layout_engine(\"none\")\n    assert isinstance(fig.get_layout_engine(), PlaceHolderLayoutEngine)\n\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"constrained\")\n", "type": "function"}, {"name": "test_colorbar_wrong_figure", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "plt.figure", "imshow", "fig_tl.draw_without_rendering", "fig_cl.draw_without_rendering", "pytest.warns", "fig_tl.colorbar", "fig_cl.add_subplot"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1224, "end_line": 1235}, "code_snippet": "def test_colorbar_wrong_figure():\n    # If we decide in the future to disallow calling colorbar() on the \"wrong\" figure,\n    # just delete this test.\n    fig_tl = plt.figure(layout=\"tight\")\n    fig_cl = plt.figure(layout=\"constrained\")\n    im = fig_cl.add_subplot().imshow([[0, 1]])\n    # Make sure this doesn't try to setup a gridspec-controlled colorbar on fig_cl,\n    # which would crash CL.\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        fig_tl.colorbar(im)\n    fig_tl.draw_without_rendering()\n    fig_cl.draw_without_rendering()\n", "type": "function"}, {"name": "get_subplotspec", "is_method": true, "class_name": "_ColorbarAxesLocator", "parameters": ["self"], "calls": ["self._cbar.ax.get_subplotspec", "getattr"], "code_location": {"file": "colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 190, "end_line": 194}, "code_snippet": "    def get_subplotspec(self):\n        # make tight_layout happy..\n        return (\n            self._cbar.ax.get_subplotspec()\n            or getattr(self._orig_locator, \"get_subplotspec\", lambda: None)())\n", "type": "function"}, {"name": "colorbar_gridspec", "is_method": true, "class_name": "LayoutEngine", "parameters": ["self"], "calls": [], "code_location": {"file": "layout_engine.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 78, "end_line": 85}, "code_snippet": "    def colorbar_gridspec(self):\n        \"\"\"\n        Return a boolean if the layout engine creates colorbars using a\n        gridspec.\n        \"\"\"\n        if self._colorbar_gridspec is None:\n            raise NotImplementedError\n        return self._colorbar_gridspec\n", "type": "function"}, {"name": "_check_layout_engines_compat", "is_method": true, "class_name": "Figure", "parameters": ["self", "old", "new"], "calls": ["hasattr"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2659, "end_line": 2676}, "code_snippet": "    def _check_layout_engines_compat(self, old, new):\n        \"\"\"\n        Helper for set_layout engine\n\n        If the figure has used the old engine and added a colorbar then the\n        value of colorbar_gridspec must be the same on the new engine.\n        \"\"\"\n        if old is None or new is None:\n            return True\n        if old.colorbar_gridspec == new.colorbar_gridspec:\n            return True\n        # colorbar layout different, so check if any colorbars are on the\n        # figure...\n        for ax in self.axes:\n            if hasattr(ax, '_colorbar'):\n                # colorbars list themselves as a colorbar.\n                return False\n        return True\n", "type": "function"}, {"name": "test_layout_leak", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_subplot", "fig.draw_without_rendering", "plt.close", "gc.collect", "any", "isinstance", "gc.get_objects"], "code_location": {"file": "test_constrainedlayout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 713, "end_line": 723}, "code_snippet": "def test_layout_leak():\n    # Make sure there aren't any cyclic references when using LayoutGrid\n    # GH #25853\n    fig = plt.figure(constrained_layout=True, figsize=(10, 10))\n    fig.add_subplot()\n    fig.draw_without_rendering()\n    plt.close(\"all\")\n    del fig\n    gc.collect()\n    assert not any(isinstance(obj, mpl._layoutgrid.LayoutGrid)\n                   for obj in gc.get_objects())\n", "type": "function"}, {"name": "_init_locators", "is_method": true, "class_name": "ImageGrid", "parameters": ["self"], "calls": ["enumerate", "enumerate", "range", "self._divider.set_horizontal", "self._divider.set_vertical", "range", "set_axes_locator", "set_visible", "h_ax_pos.append", "h.append", "v_ax_pos.append", "v.append", "self._get_col_row", "self._divider.new_locator", "set_axes_locator", "_cbaraxes_class_factory", "get_figure", "self._divider.get_position", "range", "h.append", "h.append", "self._divider.new_locator", "set_visible", "h.append", "Size.AxesX", "Size.AxesX", "h_cb_pos.append", "h.append", "h.append", "len", "h.append", "h_cb_pos.append", "h.append", "v.append", "Size.AxesY", "Size.AxesY", "v_cb_pos.append", "v.append", "v.append", "len", "v.append", "v_cb_pos.append", "v.append", "set_axes_locator", "h.append", "h.append", "self._divider.new_locator", "range", "set_axes_locator", "set_visible", "range", "Size.AxesX", "Size.from_any", "Size.from_any", "v.append", "v.append", "self._divider.new_locator", "len", "Size.from_any", "Size.from_any", "Size.from_any", "len", "Size.from_any", "len", "Size.from_any", "Size.from_any", "Size.from_any", "len", "Size.from_any", "self._divider.new_locator", "Size.AxesX", "Size.from_any", "Size.from_any", "v.append", "v.append", "self._divider.new_locator", "set_visible", "set_visible", "range", "range", "range", "Size.AxesY", "Size.from_any", "Size.from_any", "self._divider.new_locator", "self._divider.new_locator", "set_axes_locator", "Size.AxesY", "Size.from_any", "Size.from_any", "set_visible", "set_visible", "set_visible", "set_position", "self._divider.new_locator", "set_axes_locator"], "code_location": {"file": "axes_grid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 403, "end_line": 561}, "code_snippet": "    def _init_locators(self):\n        # Slightly abusing this method to inject colorbar creation into init.\n\n        if self._colorbar_pad is None:\n            # horizontal or vertical arrangement?\n            if self._colorbar_location in (\"left\", \"right\"):\n                self._colorbar_pad = self._horiz_pad_size.fixed_size\n            else:\n                self._colorbar_pad = self._vert_pad_size.fixed_size\n        self.cbar_axes = [\n            _cbaraxes_class_factory(self._defaultAxesClass)(\n                self.axes_all[0].get_figure(root=False), self._divider.get_position(),\n                orientation=self._colorbar_location)\n            for _ in range(self.n_axes)]\n\n        cb_mode = self._colorbar_mode\n        cb_location = self._colorbar_location\n\n        h = []\n        v = []\n\n        h_ax_pos = []\n        h_cb_pos = []\n        if cb_mode == \"single\" and cb_location in (\"left\", \"bottom\"):\n            if cb_location == \"left\":\n                sz = self._nrows * Size.AxesX(self.axes_llc)\n                h.append(Size.from_any(self._colorbar_size, sz))\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                locator = self._divider.new_locator(nx=0, ny=0, ny1=-1)\n            elif cb_location == \"bottom\":\n                sz = self._ncols * Size.AxesY(self.axes_llc)\n                v.append(Size.from_any(self._colorbar_size, sz))\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                locator = self._divider.new_locator(nx=0, nx1=-1, ny=0)\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(False)\n            self.cbar_axes[0].set_axes_locator(locator)\n            self.cbar_axes[0].set_visible(True)\n\n        for col, ax in enumerate(self.axes_row[0]):\n            if col != 0:\n                h.append(self._horiz_pad_size)\n\n            if ax:\n                sz = Size.AxesX(ax, aspect=\"axes\", ref_ax=self.axes_all[0])\n            else:\n                sz = Size.AxesX(self.axes_all[0],\n                                aspect=\"axes\", ref_ax=self.axes_all[0])\n\n            if (cb_location == \"left\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and col == 0))):\n                h_cb_pos.append(len(h))\n                h.append(Size.from_any(self._colorbar_size, sz))\n                h.append(Size.from_any(self._colorbar_pad, sz))\n\n            h_ax_pos.append(len(h))\n            h.append(sz)\n\n            if (cb_location == \"right\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and col == self._ncols - 1))):\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                h_cb_pos.append(len(h))\n                h.append(Size.from_any(self._colorbar_size, sz))\n\n        v_ax_pos = []\n        v_cb_pos = []\n        for row, ax in enumerate(self.axes_column[0][::-1]):\n            if row != 0:\n                v.append(self._vert_pad_size)\n\n            if ax:\n                sz = Size.AxesY(ax, aspect=\"axes\", ref_ax=self.axes_all[0])\n            else:\n                sz = Size.AxesY(self.axes_all[0],\n                                aspect=\"axes\", ref_ax=self.axes_all[0])\n\n            if (cb_location == \"bottom\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and row == 0))):\n                v_cb_pos.append(len(v))\n                v.append(Size.from_any(self._colorbar_size, sz))\n                v.append(Size.from_any(self._colorbar_pad, sz))\n\n            v_ax_pos.append(len(v))\n            v.append(sz)\n\n            if (cb_location == \"top\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and row == self._nrows - 1))):\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                v_cb_pos.append(len(v))\n                v.append(Size.from_any(self._colorbar_size, sz))\n\n        for i in range(self.n_axes):\n            col, row = self._get_col_row(i)\n            locator = self._divider.new_locator(nx=h_ax_pos[col],\n                                                ny=v_ax_pos[self._nrows-1-row])\n            self.axes_all[i].set_axes_locator(locator)\n\n            if cb_mode == \"each\":\n                if cb_location in (\"right\", \"left\"):\n                    locator = self._divider.new_locator(\n                        nx=h_cb_pos[col], ny=v_ax_pos[self._nrows - 1 - row])\n\n                elif cb_location in (\"top\", \"bottom\"):\n                    locator = self._divider.new_locator(\n                        nx=h_ax_pos[col], ny=v_cb_pos[self._nrows - 1 - row])\n\n                self.cbar_axes[i].set_axes_locator(locator)\n            elif cb_mode == \"edge\":\n                if (cb_location == \"left\" and col == 0\n                        or cb_location == \"right\" and col == self._ncols - 1):\n                    locator = self._divider.new_locator(\n                        nx=h_cb_pos[0], ny=v_ax_pos[self._nrows - 1 - row])\n                    self.cbar_axes[row].set_axes_locator(locator)\n                elif (cb_location == \"bottom\" and row == self._nrows - 1\n                      or cb_location == \"top\" and row == 0):\n                    locator = self._divider.new_locator(nx=h_ax_pos[col],\n                                                        ny=v_cb_pos[0])\n                    self.cbar_axes[col].set_axes_locator(locator)\n\n        if cb_mode == \"single\":\n            if cb_location == \"right\":\n                sz = self._nrows * Size.AxesX(self.axes_llc)\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                h.append(Size.from_any(self._colorbar_size, sz))\n                locator = self._divider.new_locator(nx=-2, ny=0, ny1=-1)\n            elif cb_location == \"top\":\n                sz = self._ncols * Size.AxesY(self.axes_llc)\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                v.append(Size.from_any(self._colorbar_size, sz))\n                locator = self._divider.new_locator(nx=0, nx1=-1, ny=-2)\n            if cb_location in (\"right\", \"top\"):\n                for i in range(self.n_axes):\n                    self.cbar_axes[i].set_visible(False)\n                self.cbar_axes[0].set_axes_locator(locator)\n                self.cbar_axes[0].set_visible(True)\n        elif cb_mode == \"each\":\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(True)\n        elif cb_mode == \"edge\":\n            if cb_location in (\"right\", \"left\"):\n                count = self._nrows\n            else:\n                count = self._ncols\n            for i in range(count):\n                self.cbar_axes[i].set_visible(True)\n            for j in range(i + 1, self.n_axes):\n                self.cbar_axes[j].set_visible(False)\n        else:\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(False)\n                self.cbar_axes[i].set_position([1., 1., 0.001, 0.001],\n                                               which=\"active\")\n\n        self._divider.set_horizontal(h)\n        self._divider.set_vertical(v)\n", "type": "function"}, {"name": "test_warn_colorbar_mismatch", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "plt.subplots", "ax1.imshow", "fig1.colorbar", "plt.figure", "plt.figure", "fig3.subfigures", "fig3.subfigures", "fig4.subfigures", "subfig3_1.subplots", "subfig3_1.subplots", "subfig4_1.subplots", "ax3_1.imshow", "ax3_2.imshow", "ax4_1.imshow", "fig3.colorbar", "subfig3_1.colorbar", "subfig3_1.colorbar", "pytest.warns", "fig2.colorbar", "pytest.warns", "fig2.colorbar", "pytest.warns", "fig2.colorbar", "pytest.warns", "fig2.colorbar", "pytest.warns", "subfig3_1.colorbar"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1737, "end_line": 1770}, "code_snippet": "def test_warn_colorbar_mismatch():\n    fig1, ax1 = plt.subplots()\n    fig2, (ax2_1, ax2_2) = plt.subplots(2)\n    im = ax1.imshow([[1, 2], [3, 4]])\n\n    fig1.colorbar(im)  # should not warn\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        fig2.colorbar(im)\n    # warn mismatch even when the host figure is not inferred\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        fig2.colorbar(im, ax=ax1)\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        fig2.colorbar(im, ax=ax2_1)\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        fig2.colorbar(im, cax=ax2_2)\n\n    # edge case: only compare top level artist in case of subfigure\n    fig3 = plt.figure()\n    fig4 = plt.figure()\n    subfig3_1 = fig3.subfigures()\n    subfig3_2 = fig3.subfigures()\n    subfig4_1 = fig4.subfigures()\n    ax3_1 = subfig3_1.subplots()\n    ax3_2 = subfig3_1.subplots()\n    ax4_1 = subfig4_1.subplots()\n    im3_1 = ax3_1.imshow([[1, 2], [3, 4]])\n    im3_2 = ax3_2.imshow([[1, 2], [3, 4]])\n    im4_1 = ax4_1.imshow([[1, 2], [3, 4]])\n\n    fig3.colorbar(im3_1)   # should not warn\n    subfig3_1.colorbar(im3_1)   # should not warn\n    subfig3_1.colorbar(im3_2)   # should not warn\n    with pytest.warns(UserWarning, match=\"different Figure\"):\n        subfig3_1.colorbar(im4_1)\n", "type": "function"}, {"name": "test_gridspec_make_colorbar", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "reshape", "plt.subplot", "plt.contourf", "plt.colorbar", "plt.subplot", "plt.contourf", "plt.colorbar", "plt.subplots_adjust", "np.arange"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 251, "end_line": 264}, "code_snippet": "def test_gridspec_make_colorbar():\n    plt.figure()\n    data = np.arange(1200).reshape(30, 40)\n    levels = [0, 200, 400, 600, 800, 1000, 1200]\n\n    plt.subplot(121)\n    plt.contourf(data, levels=levels)\n    plt.colorbar(use_gridspec=True, orientation='vertical')\n\n    plt.subplot(122)\n    plt.contourf(data, levels=levels)\n    plt.colorbar(use_gridspec=True, orientation='horizontal')\n\n    plt.subplots_adjust(top=0.95, right=0.95, bottom=0.2, hspace=0.25)\n", "type": "function"}, {"name": "test_manual_colorbar", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "scatter", "get_position", "fig.add_axes", "fig.colorbar", "pytest.warns", "fig.tight_layout"], "code_location": {"file": "test_tightlayout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 372, "end_line": 382}, "code_snippet": "def test_manual_colorbar():\n    # This should warn, but not raise\n    fig, axes = plt.subplots(1, 2)\n    pts = axes[1].scatter([0, 1], [0, 1], c=[1, 5])\n    ax_rect = axes[1].get_position()\n    cax = fig.add_axes(\n        [ax_rect.x1 + 0.005, ax_rect.y0, 0.015, ax_rect.height]\n    )\n    fig.colorbar(pts, cax=cax)\n    with pytest.warns(UserWarning, match=\"This figure includes Axes\"):\n        fig.tight_layout()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0894935131072998}
{"question": "What is the separation of concerns maintained by the ToolbarGTK4 class between UI state management and event handling through its set_message method within the broader GTK4 backend architecture?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "ToolbarGTK4", "docstring": "", "methods": ["__init__", "add_toolitem", "_find_child_at_position", "_add_button", "_call_tool", "toggle_toolitem", "remove_toolitem", "_add_separator", "set_message"], "attributes": ["_icon_extension"], "code_location": {"file": "backend_gtk4.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 436, "end_line": 529}, "type": "class"}, {"name": "ToolManagerMessageEvent", "docstring": "Event carrying messages from toolmanager.\n\nMessages usually get displayed to the user by the toolbar.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "backend_managers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 20, "end_line": 29}, "type": "class"}, {"name": "set_message", "is_method": true, "class_name": "NavigationToolbar2", "parameters": ["self", "s"], "calls": [], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2877, "end_line": 2878}, "code_snippet": "    def set_message(self, s):\n        \"\"\"Display a message on toolbar or in status bar.\"\"\"\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolbarGTK4", "parameters": ["self", "toolmanager"], "calls": ["ToolContainerBase.__init__", "Gtk.Box.__init__", "self.set_property", "Gtk.Box", "self.append", "Gtk.Label", "label.set_markup", "label.set_hexpand", "self.append", "Gtk.Label", "self._message.set_justify", "self.append"], "code_location": {"file": "backend_gtk4.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 439, "end_line": 462}, "code_snippet": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n", "type": "function"}, {"name": "set_message", "is_method": true, "class_name": "NavigationToolbar2WebAgg", "parameters": ["self", "message"], "calls": ["self.canvas.send_event"], "code_location": {"file": "backend_webagg_core.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 401, "end_line": 404}, "code_snippet": "    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message\n", "type": "function"}, {"name": "set_message", "is_method": true, "class_name": "ToolbarQt", "parameters": ["self", "s"], "calls": ["setText", "self.widgetForAction"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1034, "end_line": 1035}, "code_snippet": "    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolContainerBase", "parameters": ["self", "toolmanager"], "calls": ["toolmanager.toolmanager_connect", "toolmanager.toolmanager_connect", "self.set_message", "self.remove_toolitem"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3334, "end_line": 3341}, "code_snippet": "    def __init__(self, toolmanager):\n        self.toolmanager = toolmanager\n        toolmanager.toolmanager_connect(\n            'tool_message_event',\n            lambda event: self.set_message(event.message))\n        toolmanager.toolmanager_connect(\n            'tool_removed_event',\n            lambda event: self.remove_toolitem(event.tool.name))\n", "type": "function"}, {"name": "ToolbarGTK3", "docstring": "", "methods": ["__init__", "add_toolitem", "_add_button", "_call_tool", "toggle_toolitem", "remove_toolitem", "_add_separator", "set_message"], "attributes": ["_icon_extension"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 402, "end_line": 475}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "ToolbarQt", "parameters": ["self", "toolmanager", "parent"], "calls": ["ToolContainerBase.__init__", "QtWidgets.QToolBar.__init__", "self.setAllowedAreas", "QtWidgets.QLabel", "message_label.setAlignment", "message_label.setSizePolicy", "self.addWidget", "QtCore.Qt.ToolBarArea", "QtCore.Qt.AlignmentFlag", "QtWidgets.QSizePolicy", "_to_int", "_to_int", "_to_int", "_to_int"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 972, "end_line": 988}, "code_snippet": "    def __init__(self, toolmanager, parent=None):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(QtCore.Qt.ToolBarArea.TopToolBarArea) |\n            _to_int(QtCore.Qt.ToolBarArea.BottomToolBarArea)))\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(QtCore.Qt.AlignmentFlag(\n            _to_int(QtCore.Qt.AlignmentFlag.AlignRight) |\n            _to_int(QtCore.Qt.AlignmentFlag.AlignVCenter)))\n        message_label.setSizePolicy(QtWidgets.QSizePolicy(\n            QtWidgets.QSizePolicy.Policy.Expanding,\n            QtWidgets.QSizePolicy.Policy.Ignored,\n        ))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "ToolbarGTK3", "parameters": ["self", "toolmanager"], "calls": ["ToolContainerBase.__init__", "Gtk.Box.__init__", "self.set_property", "Gtk.Label", "self._message.set_justify", "self.pack_end", "self.show_all"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 405, "end_line": 414}, "code_snippet": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0955257415771484}
{"question": "How does the get_offset method compute the final pixel offset by integrating borderpad unpacking, fontsize conversion, and the _get_anchored_bbox algorithm to position the child box relative to its anchor point?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_offset", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self", "bbox", "renderer"], "calls": ["renderer.points_to_pixels", "self.get_bbox_to_anchor", "_get_anchored_bbox", "self.prop.get_size_in_points", "Bbox.from_bounds"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1060, "end_line": 1078}, "code_snippet": "    def get_offset(self, bbox, renderer):\n        # docstring inherited\n        fontsize_in_pixels = renderer.points_to_pixels(self.prop.get_size_in_points())\n        try:\n            borderpad_x, borderpad_y = self.borderpad\n        except TypeError:\n            borderpad_x = self.borderpad\n            borderpad_y = self.borderpad\n        pad_x_pixels = borderpad_x * fontsize_in_pixels\n        pad_y_pixels = borderpad_y * fontsize_in_pixels\n        bbox_to_anchor = self.get_bbox_to_anchor()\n        x0, y0 = _get_anchored_bbox(\n            self.loc,\n            Bbox.from_bounds(0, 0, bbox.width, bbox.height),\n            bbox_to_anchor,\n            pad_x_pixels,\n            pad_y_pixels\n        )\n        return x0 - bbox.x0, y0 - bbox.y0\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "AnchoredSizeLocator", "parameters": ["self", "renderer"], "calls": ["self.get_bbox_to_anchor", "renderer.points_to_pixels", "self.x_size.get_size", "self.y_size.get_size", "renderer.points_to_pixels", "padded", "self.prop.get_size_in_points", "Bbox.from_bounds"], "code_location": {"file": "inset_locator.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 50, "end_line": 62}, "code_snippet": "    def get_bbox(self, renderer):\n        bbox = self.get_bbox_to_anchor()\n        dpi = renderer.points_to_pixels(72.)\n\n        r, a = self.x_size.get_size(renderer)\n        width = bbox.width * r + a * dpi\n        r, a = self.y_size.get_size(renderer)\n        height = bbox.height * r + a * dpi\n\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n\n        return Bbox.from_bounds(0, 0, width, height).padded(pad)\n", "type": "function"}, {"name": "_get_bbox_and_child_offsets", "is_method": true, "class_name": "PaddedBox", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "padded", "get_bbox"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 566, "end_line": 569}, "code_snippet": "    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited.\n        pad = self.pad * renderer.points_to_pixels(1.)\n        return (self._children[0].get_bbox(renderer).padded(pad), [(0, 0)])\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "OffsetBox", "parameters": ["self", "renderer"], "calls": ["self._get_bbox_and_child_offsets"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 358, "end_line": 361}, "code_snippet": "    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "padded", "self.prop.get_size_in_points", "get_bbox", "self.get_child"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1017, "end_line": 1021}, "code_snippet": "    def get_bbox(self, renderer):\n        # docstring inherited\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return self.get_child().get_bbox(renderer).padded(pad)\n", "type": "function"}, {"name": "_get_anchored_bbox", "is_method": false, "class_name": null, "parameters": ["loc", "bbox", "parentbbox", "pad_x", "pad_y"], "calls": ["parentbbox.padded", "bbox.anchored"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1102, "end_line": 1111}, "code_snippet": "def _get_anchored_bbox(loc, bbox, parentbbox, pad_x, pad_y):\n    \"\"\"\n    Return the (x, y) position of the *bbox* anchored at the *parentbbox* with\n    the *loc* code with the *borderpad* and padding *pad_x*, *pad_y*.\n    \"\"\"\n    # This is only called internally and *loc* should already have been\n    # validated.  If 0 (None), we just let ``bbox.anchored`` raise.\n    c = [None, \"NE\", \"NW\", \"SW\", \"SE\", \"E\", \"W\", \"E\", \"S\", \"N\", \"C\"][loc]\n    container = parentbbox.padded(-pad_x, -pad_y)\n    return bbox.anchored(c, container=container).p0\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "AnchoredZoomLocator", "parameters": ["self", "renderer"], "calls": ["self.parent_axes.transData.transform_bbox", "renderer.points_to_pixels", "padded", "self.prop.get_size_in_points", "Bbox.from_bounds", "abs", "abs"], "code_location": {"file": "inset_locator.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 78, "end_line": 85}, "code_snippet": "    def get_bbox(self, renderer):\n        bb = self.parent_axes.transData.transform_bbox(self.axes.viewLim)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return (\n            Bbox.from_bounds(\n                0, 0, abs(bb.width * self.zoom), abs(bb.height * self.zoom))\n            .padded(pad))\n", "type": "function"}, {"name": "_get_bbox_and_child_offsets", "is_method": true, "class_name": "OffsetBox", "parameters": ["self", "renderer"], "calls": ["NotImplementedError"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 340, "end_line": 356}, "code_snippet": "    def _get_bbox_and_child_offsets(self, renderer):\n        \"\"\"\n        Return the bbox of the offsetbox and the child offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n", "type": "function"}, {"name": "_get_bbox_and_child_offsets", "is_method": true, "class_name": "HPacker", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "_get_aligned_offsets", "_get_packed_offsets", "c.get_bbox", "padded", "self.get_visible_children", "padded", "Bbox.from_bounds", "zip", "Bbox.from_bounds"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 487, "end_line": 506}, "code_snippet": "    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        bboxes = [c.get_bbox(renderer) for c in self.get_visible_children()]\n        if not bboxes:\n            return Bbox.from_bounds(0, 0, 0, 0).padded(pad), []\n\n        (y0, y1), yoffsets = _get_aligned_offsets(\n            [bbox.intervaly for bbox in bboxes], self.height, self.align)\n        width, xoffsets = _get_packed_offsets(\n            [bbox.width for bbox in bboxes], self.width, sep, self.mode)\n\n        x0 = bboxes[0].x0\n        xoffsets -= ([bbox.x0 for bbox in bboxes] - x0)\n\n        return (Bbox.from_bounds(x0, y0, width, y1 - y0).padded(pad),\n                [*zip(xoffsets, yoffsets)])\n", "type": "function"}, {"name": "_get_bbox_and_child_offsets", "is_method": true, "class_name": "VPacker", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "_get_aligned_offsets", "_get_packed_offsets", "self.get_visible_children", "c.get_bbox", "padded", "self.get_visible_children", "isinstance", "c.set_width", "Bbox.from_bounds", "zip"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 449, "end_line": 472}, "code_snippet": "    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        if self.width is not None:\n            for c in self.get_visible_children():\n                if isinstance(c, PackerBase) and c.mode == \"expand\":\n                    c.set_width(self.width)\n\n        bboxes = [c.get_bbox(renderer) for c in self.get_visible_children()]\n        (x0, x1), xoffsets = _get_aligned_offsets(\n            [bbox.intervalx for bbox in bboxes], self.width, self.align)\n        height, yoffsets = _get_packed_offsets(\n            [bbox.height for bbox in bboxes], self.height, sep, self.mode)\n\n        yoffsets = height - (yoffsets + [bbox.y1 for bbox in bboxes])\n        ydescent = yoffsets[0]\n        yoffsets = yoffsets - ydescent\n\n        return (\n            Bbox.from_bounds(x0, -ydescent, x1 - x0, height).padded(pad),\n            [*zip(xoffsets, yoffsets)])\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0580954551696777}
{"question": "How does the TextArea.get_text() method's delegation pattern to self._text.get_text() enable framework-agnostic text retrieval while maintaining compatibility with matplotlib's text rendering API?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_text", "is_method": true, "class_name": "AxisLabel", "parameters": ["self"], "calls": ["get_text", "self._axis.label.get_text", "super"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 317, "end_line": 322}, "code_snippet": "    def get_text(self):\n        # docstring inherited\n        t = super().get_text()\n        if t == \"__from_axes__\":\n            return self._axis.label.get_text()\n        return self._text\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Text", "parameters": ["self", "renderer"], "calls": ["renderer.open_group", "gc.restore", "renderer.close_group", "self.get_visible", "self.get_text", "self.get_gid", "self._cm_set", "self._get_layout", "self.get_transform", "np.ma.is_masked", "np.ma.is_masked", "float", "float", "trans.transform", "renderer.get_canvas_width_height", "renderer.new_gc", "gc.set_foreground", "gc.set_alpha", "gc.set_url", "gc.set_antialiased", "self._set_gc_clip", "self.get_rotation", "self.convert_xunits", "self.convert_yunits", "np.isnan", "np.isnan", "_log.warning", "self.update_bbox_position_size", "self._bbox_patch.draw", "self.get_color", "self.get_alpha", "renderer.flipy", "self._preprocess_math", "self.get_path_effects", "self.get_usetex", "self._get_wrapped_text", "np.isfinite", "np.isfinite", "PathEffectRenderer", "textrenderer.draw_tex", "textrenderer.draw_text", "len", "self.get_path_effects"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 755, "end_line": 830}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if self.get_text() == '':\n            return\n\n        renderer.open_group('text', self.get_gid())\n\n        with self._cm_set(text=self._get_wrapped_text()):\n            bbox, info, descent = self._get_layout(renderer)\n            trans = self.get_transform()\n\n            # don't use self.get_position here, which refers to text\n            # position in Text:\n            x, y = self._x, self._y\n            if np.ma.is_masked(x):\n                x = np.nan\n            if np.ma.is_masked(y):\n                y = np.nan\n            posx = float(self.convert_xunits(x))\n            posy = float(self.convert_yunits(y))\n            posx, posy = trans.transform((posx, posy))\n            if np.isnan(posx) or np.isnan(posy):\n                return  # don't throw a warning here\n            if not np.isfinite(posx) or not np.isfinite(posy):\n                _log.warning(\"posx and posy should be finite values\")\n                return\n            canvasw, canvash = renderer.get_canvas_width_height()\n\n            # Update the location and size of the bbox\n            # (`.patches.FancyBboxPatch`), and draw it.\n            if self._bbox_patch:\n                self.update_bbox_position_size(renderer)\n                self._bbox_patch.draw(renderer)\n\n            gc = renderer.new_gc()\n            gc.set_foreground(self.get_color())\n            gc.set_alpha(self.get_alpha())\n            gc.set_url(self._url)\n            gc.set_antialiased(self._antialiased)\n            self._set_gc_clip(gc)\n\n            angle = self.get_rotation()\n\n            for line, wh, x, y in info:\n\n                mtext = self if len(info) == 1 else None\n                x = x + posx\n                y = y + posy\n                if renderer.flipy():\n                    y = canvash - y\n                clean_line, ismath = self._preprocess_math(line)\n\n                if self.get_path_effects():\n                    from matplotlib.patheffects import PathEffectRenderer\n                    textrenderer = PathEffectRenderer(\n                        self.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n\n                if self.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line,\n                                          self._fontproperties, angle,\n                                          mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line,\n                                           self._fontproperties, angle,\n                                           ismath=ismath, mtext=mtext)\n\n        gc.restore()\n        renderer.close_group('text')\n        self.stale = False\n", "type": "function"}, {"name": "test_textarea_set_text", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "fig_ref.add_subplot", "AnchoredText", "ax_ref.add_artist", "fig_test.add_subplot", "AnchoredText", "ax_test.add_artist", "text1.txt.set_text"], "code_location": {"file": "test_offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 416, "end_line": 424}, "code_snippet": "def test_textarea_set_text(fig_test, fig_ref):\n    ax_ref = fig_ref.add_subplot()\n    text0 = AnchoredText(\"Foo\", \"upper left\")\n    ax_ref.add_artist(text0)\n\n    ax_test = fig_test.add_subplot()\n    text1 = AnchoredText(\"Bar\", \"upper left\")\n    ax_test.add_artist(text1)\n    text1.txt.set_text(\"Foo\")\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "TextArea", "parameters": ["self", "renderer"], "calls": ["mtext._get_text_metrics_with_cache", "self._text._get_layout", "self._baseline_transform.clear", "self._text.get_horizontalalignment", "Bbox.from_bounds", "self._baseline_transform.translate", "max", "len", "self._text.get_usetex", "self.get_figure"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 796, "end_line": 818}, "code_snippet": "    def get_bbox(self, renderer):\n        _, h_, d_ = mtext._get_text_metrics_with_cache(\n            renderer, \"lp\", self._text._fontproperties,\n            ismath=\"TeX\" if self._text.get_usetex() else False,\n            dpi=self.get_figure(root=True).dpi)\n\n        bbox, info, yd = self._text._get_layout(renderer)\n        w, h = bbox.size\n\n        self._baseline_transform.clear()\n\n        if len(info) > 1 and self._multilinebaseline:\n            yd_new = 0.5 * h - 0.5 * (h_ - d_)\n            self._baseline_transform.translate(0, yd - yd_new)\n            yd = yd_new\n        else:  # single line\n            h_d = max(h_ - d_, h - yd)\n            h = h_d + yd\n\n        ha = self._text.get_horizontalalignment()\n        x0 = {\"left\": 0, \"center\": -w / 2, \"right\": -w}[ha]\n\n        return Bbox.from_bounds(x0, -yd, w, h)\n", "type": "function"}, {"name": "_get_text2_transform", "is_method": true, "class_name": "XTick", "parameters": ["self"], "calls": ["self.axes.get_xaxis_text2_transform"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 396, "end_line": 397}, "code_snippet": "    def _get_text2_transform(self):\n        return self.axes.get_xaxis_text2_transform(self._pad)\n", "type": "function"}, {"name": "draw_text", "is_method": true, "class_name": "RendererTemplate", "parameters": ["self", "gc", "x", "y", "s", "prop", "angle", "ismath", "mtext"], "calls": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 82, "end_line": 83}, "code_snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass\n", "type": "function"}, {"name": "_get_text2_transform", "is_method": true, "class_name": "YTick", "parameters": ["self"], "calls": ["self.axes.get_yaxis_text2_transform"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 457, "end_line": 458}, "code_snippet": "    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)\n", "type": "function"}, {"name": "_get_text1_transform", "is_method": true, "class_name": "XTick", "parameters": ["self"], "calls": ["self.axes.get_xaxis_text1_transform"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 393, "end_line": 394}, "code_snippet": "    def _get_text1_transform(self):\n        return self.axes.get_xaxis_text1_transform(self._pad)\n", "type": "function"}, {"name": "draw_text", "is_method": true, "class_name": "RendererPgf", "parameters": ["self", "gc", "x", "y", "s", "prop", "angle", "ismath", "mtext"], "calls": ["_escape_and_apply_props", "_writeln", "self._print_pgf_clip", "gc.get_alpha", "_writeln", "_writeln", "_writeln", "_writeln", "_writeln", "_writeln", "_writeln", "tuple", "mtext.get_unitless_position", "transform", "text_args.extend", "text_args.append", "text_args.append", "gc.get_rgb", "mtext.get_verticalalignment", "mtext.get_transform", "join", "mtext.get_rotation_mode", "mtext.get_horizontalalignment", "mtext.get_verticalalignment"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 676, "end_line": 722}, "code_snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = _escape_and_apply_props(s, prop)\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        _writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        _writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n", "type": "function"}, {"name": "get_text_width_height_descent", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "s", "prop", "ismath"], "calls": ["self._text2path.get_text_width_height_descent"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1299, "end_line": 1301}, "code_snippet": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0805158615112305}
{"question": "How does the Ticks class maintain consistency between its marker-based rendering system and the inherited Line2D interface while supporting dynamic attribute delegation through the AttributeCopier pattern?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_apply_tickdir", "is_method": true, "class_name": "YTick", "parameters": ["self", "tickdir"], "calls": ["_apply_tickdir", "self.tick1line.set_marker", "self.tick2line.set_marker", "super"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 460, "end_line": 469}, "code_snippet": "    def _apply_tickdir(self, tickdir):\n        # docstring inherited\n        super()._apply_tickdir(tickdir)\n        mark1, mark2 = {\n            'out': (mlines.TICKLEFT, mlines.TICKRIGHT),\n            'in': (mlines.TICKRIGHT, mlines.TICKLEFT),\n            'inout': ('_', '_'),\n        }[self._tickdir]\n        self.tick1line.set_marker(mark1)\n        self.tick2line.set_marker(mark2)\n", "type": "function"}, {"name": "_apply_tickdir", "is_method": true, "class_name": "XTick", "parameters": ["self", "tickdir"], "calls": ["_apply_tickdir", "self.tick1line.set_marker", "self.tick2line.set_marker", "super"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 399, "end_line": 408}, "code_snippet": "    def _apply_tickdir(self, tickdir):\n        # docstring inherited\n        super()._apply_tickdir(tickdir)\n        mark1, mark2 = {\n            'out': (mlines.TICKDOWN, mlines.TICKUP),\n            'in': (mlines.TICKUP, mlines.TICKDOWN),\n            'inout': ('|', '|'),\n        }[self._tickdir]\n        self.tick1line.set_marker(mark1)\n        self.tick2line.set_marker(mark2)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Ticks", "parameters": ["self", "renderer"], "calls": ["renderer.new_gc", "gc.set_foreground", "gc.set_linewidth", "gc.set_alpha", "self.get_transform", "scale", "self.get_tick_out", "gc.restore", "self.get_visible", "self.get_markeredgecolor", "self.get_markeredgewidth", "renderer.points_to_pixels", "marker_transform.rotate_deg", "path_trans.transform_non_affine", "renderer.draw_markers", "Affine2D", "np.array", "Path", "path_trans.get_affine", "self.axes.viewLim.contains", "rotate_deg", "Affine2D"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 176, "end_line": 200}, "code_snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        gc = renderer.new_gc()\n        gc.set_foreground(self.get_markeredgecolor())\n        gc.set_linewidth(self.get_markeredgewidth())\n        gc.set_alpha(self._alpha)\n\n        path_trans = self.get_transform()\n        marker_transform = (Affine2D()\n                            .scale(renderer.points_to_pixels(self._ticksize)))\n        if self.get_tick_out():\n            marker_transform.rotate_deg(180)\n\n        for loc, angle in self.locs_angles:\n            locs = path_trans.transform_non_affine(np.array([loc]))\n            if self.axes and not self.axes.viewLim.contains(*locs[0]):\n                continue\n            renderer.draw_markers(\n                gc, self._tickvert_path,\n                marker_transform + Affine2D().rotate_deg(angle),\n                Path(locs), path_trans.get_affine())\n\n        gc.restore()\n", "type": "function"}, {"name": "_set_tickup", "is_method": true, "class_name": "MarkerStyle", "parameters": ["self"], "calls": ["scale", "Affine2D"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 769, "end_line": 773}, "code_snippet": "    def _set_tickup(self):\n        self._transform = Affine2D().scale(1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickvert_path\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Line2D", "parameters": ["self", "renderer"], "calls": ["self.get_path_effects", "renderer.open_group", "renderer.close_group", "self.get_visible", "self.recache", "self.axes.get_xbound", "self._x_filled.searchsorted", "self._x_filled.searchsorted", "slice", "self._transform_path", "PathEffectRenderer", "self.get_gid", "get_transformed_path_and_affine", "len", "renderer.new_gc", "self._set_gc_clip", "gc.set_url", "gc.set_linewidth", "gc.set_antialiased", "mcolors.to_rgba", "mcolors.to_rgba", "mcolors.to_rgba", "gc.set_foreground", "len", "gc.restore", "max", "self.get_path_effects", "renderer.new_gc", "self._set_gc_clip", "gc.set_url", "gc.set_antialiased", "gc.set_linewidth", "self.is_dashed", "gc.set_joinstyle", "gc.set_capstyle", "gc.set_snap", "mcolors.to_rgba", "gc.set_foreground", "gc.set_dashes", "renderer.draw_path", "gc.restore", "self.get_url", "self.get_markeredgecolor", "self._get_markerfacecolor", "self._get_markerfacecolor", "cbook._str_equal", "self.get_sketch_params", "self.get_sketch_params", "gc.set_sketch_params", "self.get_drawstyle", "get_transformed_points_and_affine", "self.get_markevery", "marker.get_snap_threshold", "isinstance", "gc.set_snap", "gc.set_joinstyle", "gc.set_capstyle", "marker.get_path", "marker.get_transform", "renderer.points_to_pixels", "cbook._str_equal", "renderer.draw_markers", "marker.get_alt_path", "self._get_transformed_path", "self.get_url", "self.get_snap", "self.get_sketch_params", "gc.set_sketch_params", "self.is_dashed", "mcolors.to_rgba", "gc.set_foreground", "_get_inverse_dash_pattern", "gc.set_dashes", "renderer.draw_path", "affine.frozen", "cbook._str_lower_equal", "cbook._setattr_cm", "self.recache", "self._transform_path", "get_transformed_points_and_affine", "_mark_every_path", "marker.get_joinstyle", "marker.get_capstyle", "marker.get_marker", "gc.set_linewidth", "marker_trans.scale", "affine.frozen", "marker.get_alt_transform", "alt_marker_trans.scale", "renderer.draw_markers", "affine.frozen", "self.get_markerfacecolor", "self._get_transformed_path", "renderer.points_to_pixels", "affine.frozen", "self.get_sketch_params", "self._get_transformed_path"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 747, "end_line": 890}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n\n        if self._invalidy or self._invalidx:\n            self.recache()\n        self.ind_offset = 0  # Needed for contains() method.\n        if self._subslice and self.axes:\n            x0, x1 = self.axes.get_xbound()\n            i0 = self._x_filled.searchsorted(x0, 'left')\n            i1 = self._x_filled.searchsorted(x1, 'right')\n            subslice = slice(max(i0 - 1, 0), i1 + 1)\n            self.ind_offset = subslice.start\n            self._transform_path(subslice)\n        else:\n            subslice = None\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        renderer.open_group('line2d', self.get_gid())\n        if self._lineStyles[self._linestyle] != '_draw_nothing':\n            tpath, affine = (self._get_transformed_path()\n                             .get_transformed_path_and_affine())\n            if len(tpath.vertices):\n                gc = renderer.new_gc()\n                self._set_gc_clip(gc)\n                gc.set_url(self.get_url())\n\n                gc.set_antialiased(self._antialiased)\n                gc.set_linewidth(self._linewidth)\n\n                if self.is_dashed():\n                    cap = self._dashcapstyle\n                    join = self._dashjoinstyle\n                else:\n                    cap = self._solidcapstyle\n                    join = self._solidjoinstyle\n                gc.set_joinstyle(join)\n                gc.set_capstyle(cap)\n                gc.set_snap(self.get_snap())\n                if self.get_sketch_params() is not None:\n                    gc.set_sketch_params(*self.get_sketch_params())\n\n                # We first draw a path within the gaps if needed.\n                if self.is_dashed() and self._gapcolor is not None:\n                    lc_rgba = mcolors.to_rgba(self._gapcolor, self._alpha)\n                    gc.set_foreground(lc_rgba, isRGBA=True)\n\n                    offset_gaps, gaps = _get_inverse_dash_pattern(\n                        *self._dash_pattern)\n\n                    gc.set_dashes(offset_gaps, gaps)\n                    renderer.draw_path(gc, tpath, affine.frozen())\n\n                lc_rgba = mcolors.to_rgba(self._color, self._alpha)\n                gc.set_foreground(lc_rgba, isRGBA=True)\n\n                gc.set_dashes(*self._dash_pattern)\n                renderer.draw_path(gc, tpath, affine.frozen())\n                gc.restore()\n\n        if self._marker and self._markersize > 0:\n            gc = renderer.new_gc()\n            self._set_gc_clip(gc)\n            gc.set_url(self.get_url())\n            gc.set_linewidth(self._markeredgewidth)\n            gc.set_antialiased(self._antialiased)\n\n            ec_rgba = mcolors.to_rgba(\n                self.get_markeredgecolor(), self._alpha)\n            fc_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(), self._alpha)\n            fcalt_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(alt=True), self._alpha)\n            # If the edgecolor is \"auto\", it is set according to the *line*\n            # color but inherits the alpha value of the *face* color, if any.\n            if (cbook._str_equal(self._markeredgecolor, \"auto\")\n                    and not cbook._str_lower_equal(\n                        self.get_markerfacecolor(), \"none\")):\n                ec_rgba = ec_rgba[:3] + (fc_rgba[3],)\n            gc.set_foreground(ec_rgba, isRGBA=True)\n            if self.get_sketch_params() is not None:\n                scale, length, randomness = self.get_sketch_params()\n                gc.set_sketch_params(scale/2, length/2, 2*randomness)\n\n            marker = self._marker\n\n            # Markers *must* be drawn ignoring the drawstyle (but don't pay the\n            # recaching if drawstyle is already \"default\").\n            if self.get_drawstyle() != \"default\":\n                with cbook._setattr_cm(\n                        self, _drawstyle=\"default\", _transformed_path=None):\n                    self.recache()\n                    self._transform_path(subslice)\n                    tpath, affine = (self._get_transformed_path()\n                                     .get_transformed_points_and_affine())\n            else:\n                tpath, affine = (self._get_transformed_path()\n                                 .get_transformed_points_and_affine())\n\n            if len(tpath.vertices):\n                # subsample the markers if markevery is not None\n                markevery = self.get_markevery()\n                if markevery is not None:\n                    subsampled = _mark_every_path(\n                        markevery, tpath, affine, self.axes)\n                else:\n                    subsampled = tpath\n\n                snap = marker.get_snap_threshold()\n                if isinstance(snap, Real):\n                    snap = renderer.points_to_pixels(self._markersize) >= snap\n                gc.set_snap(snap)\n                gc.set_joinstyle(marker.get_joinstyle())\n                gc.set_capstyle(marker.get_capstyle())\n                marker_path = marker.get_path()\n                marker_trans = marker.get_transform()\n                w = renderer.points_to_pixels(self._markersize)\n\n                if cbook._str_equal(marker.get_marker(), \",\"):\n                    gc.set_linewidth(0)\n                else:\n                    # Don't scale for pixels, and don't stroke them\n                    marker_trans = marker_trans.scale(w)\n                renderer.draw_markers(gc, marker_path, marker_trans,\n                                      subsampled, affine.frozen(),\n                                      fc_rgba)\n\n                alt_marker_path = marker.get_alt_path()\n                if alt_marker_path:\n                    alt_marker_trans = marker.get_alt_transform()\n                    alt_marker_trans = alt_marker_trans.scale(w)\n                    renderer.draw_markers(\n                            gc, alt_marker_path, alt_marker_trans, subsampled,\n                            affine.frozen(), fcalt_rgba)\n\n            gc.restore()\n\n        renderer.close_group('line2d')\n        self.stale = False\n", "type": "function"}, {"name": "major_ticks", "is_method": true, "class_name": "SimpleAxisArtist", "parameters": ["self"], "calls": ["SimpleChainedObjects", "getattr", "self._axis.get_major_ticks"], "code_location": {"file": "mpl_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 75, "end_line": 78}, "code_snippet": "    def major_ticks(self):\n        tickline = \"tick%dline\" % self._axisnum\n        return SimpleChainedObjects([getattr(tick, tickline)\n                                     for tick in self._axis.get_major_ticks()])\n", "type": "function"}, {"name": "update_from", "is_method": true, "class_name": "Patch", "parameters": ["self", "other"], "calls": ["update_from", "self.set_linewidth", "self.set_transform", "other.is_transform_set", "other.get_data_transform", "super"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 283, "end_line": 301}, "code_snippet": "    def update_from(self, other):\n        # docstring inherited.\n        super().update_from(other)\n        # For some properties we don't need or don't want to go through the\n        # getters/setters, so we just copy them directly.\n        self._edgecolor = other._edgecolor\n        self._facecolor = other._facecolor\n        self._original_edgecolor = other._original_edgecolor\n        self._original_facecolor = other._original_facecolor\n        self._fill = other._fill\n        self._hatch = other._hatch\n        self._hatch_color = other._hatch_color\n        self._original_hatchcolor = other._original_hatchcolor\n        self._unscaled_dash_pattern = other._unscaled_dash_pattern\n        self.set_linewidth(other._linewidth)  # also sets scaled dashes\n        self.set_transform(other.get_data_transform())\n        # If the transform of other needs further initialization, then it will\n        # be the case for this artist too.\n        self._transformSet = other.is_transform_set()\n", "type": "function"}, {"name": "__get__", "is_method": true, "class_name": "_LazyTickList", "parameters": ["self", "instance", "owner"], "calls": ["instance._get_tick", "instance._get_tick"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 538, "end_line": 558}, "code_snippet": "    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance temporarily\n            # to an empty list. Then create the tick; note that _get_tick()\n            # may call reset_ticks(). Therefore, the final tick list is\n            # created and assigned afterwards.\n            if self._major:\n                instance.majorTicks = []\n                tick = instance._get_tick(major=True)\n                instance.majorTicks = [tick]\n                return instance.majorTicks\n            else:\n                instance.minorTicks = []\n                tick = instance._get_tick(major=False)\n                instance.minorTicks = [tick]\n                return instance.minorTicks\n", "type": "function"}, {"name": "set_clip_path", "is_method": true, "class_name": "Axis", "parameters": ["self", "path", "transform"], "calls": ["set_clip_path", "child.set_clip_path", "super"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1120, "end_line": 1124}, "code_snippet": "    def set_clip_path(self, path, transform=None):\n        super().set_clip_path(path, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(path, transform)\n        self.stale = True\n", "type": "function"}, {"name": "get_major_ticks", "is_method": true, "class_name": "Axis", "parameters": ["self", "numticks"], "calls": ["get_major_ticks", "super", "obj.set_transform"], "code_location": {"file": "axis3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 173, "end_line": 179}, "code_snippet": "    def get_major_ticks(self, numticks=None):\n        ticks = super().get_major_ticks(numticks)\n        for t in ticks:\n            for obj in [\n                    t.tick1line, t.tick2line, t.gridline, t.label1, t.label2]:\n                obj.set_transform(self.axes.transData)\n        return ticks\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.0915718078613281}
{"question": "How does the matplotlib ticker module enforce architectural separation between formatter and locator responsibilities to prevent type mismatches at the API boundary?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "Ticker", "docstring": "A container for the objects defining tick position and format.\n\nAttributes\n----------\nlocator : `~matplotlib.ticker.Locator` subclass\n    Determines the positions of the ticks.\nformatter : `~matplotlib.ticker.Formatter` subclass\n    Determines the format of the tick labels.", "methods": ["__init__", "locator", "locator", "formatter", "formatter"], "attributes": [], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 486, "end_line": 524}, "type": "class"}, {"name": "test_majformatter_type", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pytest.raises", "ax.xaxis.set_major_formatter", "mticker.LogLocator"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1789, "end_line": 1792}, "code_snippet": "def test_majformatter_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.xaxis.set_major_formatter(mticker.LogLocator())\n", "type": "function"}, {"name": "test_majlocator_type", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pytest.raises", "ax.xaxis.set_major_locator", "mticker.LogFormatter"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1801, "end_line": 1804}, "code_snippet": "def test_majlocator_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.xaxis.set_major_locator(mticker.LogFormatter())\n", "type": "function"}, {"name": "test_minlocator_type", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pytest.raises", "ax.xaxis.set_minor_locator", "mticker.LogFormatter"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1807, "end_line": 1810}, "code_snippet": "def test_minlocator_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.xaxis.set_minor_locator(mticker.LogFormatter())\n", "type": "function"}, {"name": "test_minformatter_type", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pytest.raises", "ax.xaxis.set_minor_formatter", "mticker.LogLocator"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1795, "end_line": 1798}, "code_snippet": "def test_minformatter_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.xaxis.set_minor_formatter(mticker.LogLocator())\n", "type": "function"}, {"name": "_set_formatter", "is_method": true, "class_name": "Axis", "parameters": ["self", "formatter", "level"], "calls": ["isinstance", "formatter.set_axis", "mticker.StrMethodFormatter", "isinstance", "_api.warn_external", "callable", "mticker.FuncFormatter", "_api.check_isinstance", "len", "isinstance", "isinstance"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1949, "end_line": 1973}, "code_snippet": "    def _set_formatter(self, formatter, level):\n        if isinstance(formatter, str):\n            formatter = mticker.StrMethodFormatter(formatter)\n        # Don't allow any other TickHelper to avoid easy-to-make errors,\n        # like using a Locator instead of a Formatter.\n        elif (callable(formatter) and\n              not isinstance(formatter, mticker.TickHelper)):\n            formatter = mticker.FuncFormatter(formatter)\n        else:\n            _api.check_isinstance(mticker.Formatter, formatter=formatter)\n\n        if (isinstance(formatter, mticker.FixedFormatter)\n                and len(formatter.seq) > 0\n                and not isinstance(level.locator, mticker.FixedLocator)):\n            _api.warn_external('FixedFormatter should only be used together '\n                               'with FixedLocator')\n\n        if level == self.major:\n            self.isDefault_majfmt = False\n        else:\n            self.isDefault_minfmt = False\n\n        level.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n", "type": "function"}, {"name": "locator", "is_method": true, "class_name": "Ticker", "parameters": ["self", "locator"], "calls": ["isinstance", "TypeError"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 509, "end_line": 513}, "code_snippet": "    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            raise TypeError('locator must be a subclass of '\n                            'matplotlib.ticker.Locator')\n        self._locator = locator\n", "type": "function"}, {"name": "formatter", "is_method": true, "class_name": "Ticker", "parameters": ["self", "formatter"], "calls": ["isinstance", "TypeError"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 520, "end_line": 524}, "code_snippet": "    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            raise TypeError('formatter must be a subclass of '\n                            'matplotlib.ticker.Formatter')\n        self._formatter = formatter\n", "type": "function"}, {"name": "Formatter", "docstring": "Create a string based on a tick value and location.", "methods": ["__call__", "format_ticks", "format_data", "format_data_short", "get_offset", "set_locs", "fix_minus", "_set_locator"], "attributes": ["locs"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 199, "end_line": 260}, "type": "class"}, {"name": "Locator", "docstring": "Determine tick locations.\n\nNote that the same locator should not be used across multiple\n`~matplotlib.axis.Axis` because the locator stores references to the Axis\ndata and view limits.", "methods": ["tick_values", "set_params", "__call__", "raise_if_exceeds", "nonsingular", "view_limits"], "attributes": ["MAXTICKS"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1654, "end_line": 1741}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1084175109863281}
{"question": "What is the coordinate transformation pipeline in get_center_in_pixels that reconciles the semantic difference between data coordinates stored in self._xydata and the pixel coordinate system required for screen-space rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_center_in_pixels", "is_method": true, "class_name": "AngleAnnotation", "parameters": ["self"], "calls": ["self.ax.transData.transform"], "code_location": {"file": "angle_annotation.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/text_labels_and_annotations", "start_line": 148, "end_line": 150}, "code_snippet": "    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n", "type": "function"}, {"name": "_get_xy", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "xy", "coords"], "calls": ["transform", "isinstance", "float", "float", "self.convert_xunits", "self.convert_yunits", "self._get_xy_transform"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1513, "end_line": 1520}, "code_snippet": "    def _get_xy(self, renderer, xy, coords):\n        x, y = xy\n        xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n        if xcoord == 'data':\n            x = float(self.convert_xunits(x))\n        if ycoord == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, coords).transform((x, y))\n", "type": "function"}, {"name": "index_to_coordinate", "is_method": false, "class_name": null, "parameters": ["index", "extent", "origin"], "calls": ["np.sign", "np.sign"], "code_location": {"file": "imshow_extent.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/users_explain/artists", "start_line": 35, "end_line": 52}, "code_snippet": "def index_to_coordinate(index, extent, origin):\n    \"\"\"Return the pixel center of an index.\"\"\"\n    left, right, bottom, top = extent\n\n    hshift = 0.5 * np.sign(right - left)\n    left, right = left + hshift, right - hshift\n    vshift = 0.5 * np.sign(top - bottom)\n    bottom, top = bottom + vshift, top - vshift\n\n    if origin == 'upper':\n        bottom, top = top, bottom\n\n    return {\n        \"[0, 0]\": (left, bottom),\n        \"[M', 0]\": (left, top),\n        \"[0, N']\": (right, bottom),\n        \"[M', N']\": (right, top),\n    }[index]\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "transform.transform", "transform.transform", "translate", "scale", "Affine2D"], "code_location": {"file": "geo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 108, "end_line": 114}, "code_snippet": "    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "transform.transform", "transform.transform", "translate", "scale", "Affine2D"], "code_location": {"file": "custom_projection.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 173, "end_line": 179}, "code_snippet": "    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "_get_xy_display", "is_method": true, "class_name": "Text", "parameters": ["self"], "calls": ["self.get_unitless_position", "transform", "self.get_transform"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 238, "end_line": 243}, "code_snippet": "    def _get_xy_display(self):\n        \"\"\"\n        Get the (possibly unit converted) transformed x, y in display coords.\n        \"\"\"\n        x, y = self.get_unitless_position()\n        return self.get_transform().transform((x, y))\n", "type": "function"}, {"name": "_set_inaxes", "is_method": true, "class_name": "LocationEvent", "parameters": ["self", "inaxes", "xy"], "calls": ["transform", "inaxes.transData.inverted"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1297, "end_line": 1304}, "code_snippet": "    def _set_inaxes(self, inaxes, xy=None):\n        self.inaxes = inaxes\n        if inaxes is not None:\n            try:\n                self.xdata, self.ydata = inaxes.transData.inverted().transform(\n                    xy if xy is not None else (self.x, self.y))\n            except ValueError:\n                pass\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "LambertAxes", "parameters": ["self"], "calls": ["translate", "scale", "Affine2D"], "code_location": {"file": "geo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 508, "end_line": 511}, "code_snippet": "    def _get_affine_transform(self):\n        return Affine2D() \\\n            .scale(0.25) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "_get_rotation_transform", "is_method": true, "class_name": "RectangleSelector", "parameters": ["self"], "calls": ["self.ax._get_aspect_ratio", "translate", "scale", "rotate", "scale", "translate", "Affine2D"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3469, "end_line": 3475}, "code_snippet": "    def _get_rotation_transform(self):\n        aspect_ratio = self.ax._get_aspect_ratio()\n        return Affine2D().translate(-self.center[0], -self.center[1]) \\\n                .scale(1, aspect_ratio) \\\n                .rotate(self._rotation) \\\n                .scale(1, 1 / aspect_ratio) \\\n                .translate(*self.center)\n", "type": "function"}, {"name": "_get_xy_transform", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "coords"], "calls": ["isinstance", "tr.translate", "self._get_xy_transform", "self._get_xy_transform", "blended_transform_factory", "callable", "coords.split", "scale", "coords", "isinstance", "isinstance", "ValueError", "self.get_figure", "self._get_position_xy", "ValueError", "Affine2D", "BboxTransformTo", "isinstance", "coords.get_window_extent", "BboxTransformTo", "isinstance", "PolarAxes.PolarTransform", "self.get_figure", "Affine2D", "scale", "TypeError", "BboxTransformTo", "isinstance", "self.get_figure", "scale", "ValueError", "Affine2D", "isinstance", "TypeError", "self.get_size", "Affine2D", "self.get_figure", "type", "type"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1522, "end_line": 1594}, "code_snippet": "    def _get_xy_transform(self, renderer, coords):\n\n        if isinstance(coords, tuple):\n            xcoord, ycoord = coords\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, xcoord)\n            tr2 = self._get_xy_transform(renderer, ycoord)\n            return blended_transform_factory(tr1, tr2)\n        elif callable(coords):\n            tr = coords(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise TypeError(\n                    f\"xycoords callable must return a BboxBase or Transform, not a \"\n                    f\"{type(tr).__name__}\")\n        elif isinstance(coords, Artist):\n            bbox = coords.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(coords, BboxBase):\n            return BboxTransformTo(coords)\n        elif isinstance(coords, Transform):\n            return coords\n        elif not isinstance(coords, str):\n            raise TypeError(\n                f\"'xycoords' must be an instance of str, tuple[str, str], Artist, \"\n                f\"Transform, or Callable, not a {type(coords).__name__}\")\n\n        if coords == 'data':\n            return self.axes.transData\n        elif coords == 'polar':\n            from matplotlib.projections import PolarAxes\n            return PolarAxes.PolarTransform() + self.axes.transData\n\n        try:\n            bbox_name, unit = coords.split()\n        except ValueError:  # i.e. len(coords.split()) != 2.\n            raise ValueError(f\"{coords!r} is not a valid coordinate\") from None\n\n        bbox0, xy0 = None, None\n\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.get_figure(root=False).figbbox\n        elif bbox_name == \"subfigure\":\n            bbox0 = self.get_figure(root=False).bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n\n        # reference x, y in display coordinate\n        if bbox0 is not None:\n            xy0 = bbox0.p0\n        elif bbox_name == \"offset\":\n            xy0 = self._get_position_xy(renderer)\n        else:\n            raise ValueError(f\"{coords!r} is not a valid coordinate\")\n\n        if unit == \"points\":\n            tr = Affine2D().scale(\n                self.get_figure(root=True).dpi / 72)  # dpi/72 dots per point\n        elif unit == \"pixels\":\n            tr = Affine2D()\n        elif unit == \"fontsize\":\n            tr = Affine2D().scale(\n                self.get_size() * self.get_figure(root=True).dpi / 72)\n        elif unit == \"fraction\":\n            tr = Affine2D().scale(*bbox0.size)\n        else:\n            raise ValueError(f\"{unit!r} is not a recognized unit\")\n\n        return tr.translate(*xy0)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1411285400390625}
{"question": "What is the effect of the conditional branching in AutoLocator's __init__ method based on the '_internal.classic_mode' rcParam on the tick placement algorithm's behavior when transitioning between classic and modern matplotlib rendering modes, and what are the implications for backward compatibility when the steps parameter changes from [1, 2, 5, 10] to [1, 2, 2.5, 5, 10]?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_using_all_default_major_steps", "is_method": true, "class_name": "TestAutoMinorLocator", "parameters": ["self"], "calls": ["mpl.rc_context", "np.testing.assert_allclose", "mticker.AutoLocator"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 208, "end_line": 212}, "code_snippet": "    def test_using_all_default_major_steps(self):\n        with mpl.rc_context({'_internal.classic_mode': False}):\n            majorsteps = [x[0] for x in self.majorstep_minordivisions]\n            np.testing.assert_allclose(majorsteps,\n                                       mticker.AutoLocator()._steps)\n", "type": "function"}, {"name": "AutoLocator", "docstring": "Place evenly spaced ticks, with the step size and maximum number of ticks chosen\nautomatically.\n\nThis is a subclass of `~matplotlib.ticker.MaxNLocator`, with parameters\n*nbins = 'auto'* and *steps = [1, 2, 2.5, 5, 10]*.", "methods": ["__init__"], "attributes": [], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2962, "end_line": 2981}, "type": "class"}, {"name": "test_auto_date_locator_intmult_tz", "is_method": false, "class_name": null, "parameters": [], "calls": ["dateutil.tz.gettz", "datetime.datetime", "mdates.AutoDateLocator", "locator.create_dummy_axis", "locator.axis.set_view_interval", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "rc_context", "_create_auto_date_locator", "list", "mdates.date2num", "map", "mdates.num2date", "locator"], "code_location": {"file": "test_dates.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 886, "end_line": 953}, "code_snippet": "def test_auto_date_locator_intmult_tz():\n    def _create_auto_date_locator(date1, date2, tz):\n        locator = mdates.AutoDateLocator(interval_multiples=True, tz=tz)\n        locator.create_dummy_axis()\n        locator.axis.set_view_interval(*mdates.date2num([date1, date2]))\n        return locator\n\n    results = ([datetime.timedelta(weeks=52*200),\n                ['1980-01-01 00:00:00-08:00', '2000-01-01 00:00:00-08:00',\n                 '2020-01-01 00:00:00-08:00', '2040-01-01 00:00:00-08:00',\n                 '2060-01-01 00:00:00-08:00', '2080-01-01 00:00:00-08:00',\n                 '2100-01-01 00:00:00-08:00', '2120-01-01 00:00:00-08:00',\n                 '2140-01-01 00:00:00-08:00', '2160-01-01 00:00:00-08:00',\n                 '2180-01-01 00:00:00-08:00', '2200-01-01 00:00:00-08:00']\n                ],\n               [datetime.timedelta(weeks=52),\n                ['1997-01-01 00:00:00-08:00', '1997-02-01 00:00:00-08:00',\n                 '1997-03-01 00:00:00-08:00', '1997-04-01 00:00:00-08:00',\n                 '1997-05-01 00:00:00-07:00', '1997-06-01 00:00:00-07:00',\n                 '1997-07-01 00:00:00-07:00', '1997-08-01 00:00:00-07:00',\n                 '1997-09-01 00:00:00-07:00', '1997-10-01 00:00:00-07:00',\n                 '1997-11-01 00:00:00-08:00', '1997-12-01 00:00:00-08:00']\n                ],\n               [datetime.timedelta(days=141),\n                ['1997-01-01 00:00:00-08:00', '1997-01-15 00:00:00-08:00',\n                 '1997-02-01 00:00:00-08:00', '1997-02-15 00:00:00-08:00',\n                 '1997-03-01 00:00:00-08:00', '1997-03-15 00:00:00-08:00',\n                 '1997-04-01 00:00:00-08:00', '1997-04-15 00:00:00-07:00',\n                 '1997-05-01 00:00:00-07:00', '1997-05-15 00:00:00-07:00']\n                ],\n               [datetime.timedelta(days=40),\n                ['1997-01-01 00:00:00-08:00', '1997-01-05 00:00:00-08:00',\n                 '1997-01-09 00:00:00-08:00', '1997-01-13 00:00:00-08:00',\n                 '1997-01-17 00:00:00-08:00', '1997-01-21 00:00:00-08:00',\n                 '1997-01-25 00:00:00-08:00', '1997-01-29 00:00:00-08:00',\n                 '1997-02-01 00:00:00-08:00', '1997-02-05 00:00:00-08:00',\n                 '1997-02-09 00:00:00-08:00']\n                ],\n               [datetime.timedelta(hours=40),\n                ['1997-01-01 00:00:00-08:00', '1997-01-01 04:00:00-08:00',\n                 '1997-01-01 08:00:00-08:00', '1997-01-01 12:00:00-08:00',\n                 '1997-01-01 16:00:00-08:00', '1997-01-01 20:00:00-08:00',\n                 '1997-01-02 00:00:00-08:00', '1997-01-02 04:00:00-08:00',\n                 '1997-01-02 08:00:00-08:00', '1997-01-02 12:00:00-08:00',\n                 '1997-01-02 16:00:00-08:00']\n                ],\n               [datetime.timedelta(minutes=20),\n                ['1997-01-01 00:00:00-08:00', '1997-01-01 00:05:00-08:00',\n                 '1997-01-01 00:10:00-08:00', '1997-01-01 00:15:00-08:00',\n                 '1997-01-01 00:20:00-08:00']\n                ],\n               [datetime.timedelta(seconds=40),\n                ['1997-01-01 00:00:00-08:00', '1997-01-01 00:00:05-08:00',\n                 '1997-01-01 00:00:10-08:00', '1997-01-01 00:00:15-08:00',\n                 '1997-01-01 00:00:20-08:00', '1997-01-01 00:00:25-08:00',\n                 '1997-01-01 00:00:30-08:00', '1997-01-01 00:00:35-08:00',\n                 '1997-01-01 00:00:40-08:00']\n                ]\n               )\n\n    tz = dateutil.tz.gettz('Canada/Pacific')\n    d1 = datetime.datetime(1997, 1, 1, tzinfo=tz)\n    for t_delta, expected in results:\n        with rc_context({'_internal.classic_mode': False}):\n            d2 = d1 + t_delta\n            locator = _create_auto_date_locator(d1, d2, tz)\n            st = list(map(str, mdates.num2date(locator(), tz=tz)))\n            assert st == expected\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AutoLocator", "parameters": ["self"], "calls": ["__init__", "super"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2970, "end_line": 2981}, "code_snippet": "    def __init__(self):\n        \"\"\"\n        To know the values of the non-public parameters, please have a\n        look to the defaults of `~matplotlib.ticker.MaxNLocator`.\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            nbins = 9\n            steps = [1, 2, 5, 10]\n        else:\n            nbins = 'auto'\n            steps = [1, 2, 2.5, 5, 10]\n        super().__init__(nbins=nbins, steps=steps)\n", "type": "function"}, {"name": "tick_values", "is_method": true, "class_name": "LogLocator", "parameters": ["self", "vmin", "vmax"], "calls": ["self._log_b", "math.ceil", "math.floor", "isinstance", "max", "np.arange", "math.ceil", "tick_values", "self.raise_if_exceeds", "np.clip", "self.axis.get_minpos", "ValueError", "np.arange", "math.ceil", "len", "np.concatenate", "np.array", "np.array", "len", "self.axis.get_tick_space", "np.isfinite", "np.array", "np.array", "round", "max", "max", "min", "range", "len", "sum", "AutoLocator", "len", "range"], "code_location": {"file": "ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2414, "end_line": 2533}, "code_snippet": "    def tick_values(self, vmin, vmax):\n        n_request = (\n            self.numticks if self.numticks != \"auto\" else\n            np.clip(self.axis.get_tick_space(), 2, 9) if self.axis is not None else\n            9)\n\n        b = self._base\n        if vmin <= 0.0:\n            if self.axis is not None:\n                vmin = self.axis.get_minpos()\n\n            if vmin <= 0.0 or not np.isfinite(vmin):\n                raise ValueError(\n                    \"Data has no positive values, and therefore cannot be log-scaled.\")\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        # Min and max exponents, float and int versions; e.g., if vmin=10^0.3,\n        # vmax=10^6.9, then efmin=0.3, emin=1, emax=6, efmax=6.9, n_avail=6.\n        efmin, efmax = self._log_b([vmin, vmax])\n        emin = math.ceil(efmin)\n        emax = math.floor(efmax)\n        n_avail = emax - emin + 1  # Total number of decade ticks available.\n\n        if isinstance(self._subs, str):\n            if n_avail >= 10 or b < 3:\n                if self._subs == 'auto':\n                    return np.array([])  # no minor or major ticks\n                else:\n                    subs = np.array([1.0])  # major ticks\n            else:\n                _first = 2.0 if self._subs == 'auto' else 1.0\n                subs = np.arange(_first, b)\n        else:\n            subs = self._subs\n\n        # Get decades between major ticks.  Include an extra tick outside the\n        # lower and the upper limit: QuadContourSet._autolev relies on this.\n        if mpl.rcParams[\"_internal.classic_mode\"]:  # keep historic formulas\n            stride = max(math.ceil((n_avail - 1) / (n_request - 1)), 1)\n            decades = np.arange(emin - stride, emax + stride + 1, stride)\n        else:\n            # *Determine the actual number of ticks*: Find the largest number\n            # of ticks, no more than the requested number, that can actually\n            # be drawn (e.g., with 9 decades ticks, no stride yields 7\n            # ticks).  For a given value of the stride *s*, there are either\n            # floor(n_avail/s) or ceil(n_avail/s) ticks depending on the\n            # offset.  Pick the smallest stride such that floor(n_avail/s) <\n            # n_request, i.e. n_avail/s < n_request+1, then re-set n_request\n            # to ceil(...) if acceptable, else to floor(...) (which must then\n            # equal the original n_request, i.e. n_request is kept unchanged).\n            stride = n_avail // (n_request + 1) + 1\n            nr = math.ceil(n_avail / stride)\n            if nr <= n_request:\n                n_request = nr\n            else:\n                assert nr == n_request + 1\n            if n_request == 0:  # No tick in bounds; two ticks just outside.\n                decades = [emin - 1, emax + 1]\n                stride = decades[1] - decades[0]\n            elif n_request == 1:  # A single tick close to center.\n                mid = round((efmin + efmax) / 2)\n                stride = max(mid - (emin - 1), (emax + 1) - mid)\n                decades = [mid - stride, mid, mid + stride]\n            else:\n                # *Determine the stride*: Pick the largest stride that yields\n                # this actual n_request (e.g., with 15 decades, strides of\n                # 5, 6, or 7 *can* yield 3 ticks; picking a larger stride\n                # minimizes unticked space at the ends).  First try for\n                #     ceil(n_avail/stride) == n_request\n                # i.e.\n                #     n_avail/n_request <= stride < n_avail/(n_request-1)\n                # else fallback to\n                #     floor(n_avail/stride) == n_request\n                # i.e.\n                #     n_avail/(n_request+1) < stride <= n_avail/n_request\n                # One of these cases must have an integer solution (given the\n                # choice of n_request above).\n                stride = (n_avail - 1) // (n_request - 1)\n                if stride < n_avail / n_request:  # fallback to second case\n                    stride = n_avail // n_request\n                # *Determine the offset*: For a given stride *and offset*\n                # (0 <= offset < stride), the actual number of ticks is\n                # ceil((n_avail - offset) / stride), which must be equal to\n                # n_request.  This leads to olo <= offset < ohi, with the\n                # values defined below.\n                olo = max(n_avail - stride * n_request, 0)\n                ohi = min(n_avail - stride * (n_request - 1), stride)\n                # Try to see if we can pick an offset so that ticks are at\n                # integer multiples of the stride while satisfying the bounds\n                # above; if not, fallback to the smallest acceptable offset.\n                offset = (-emin) % stride\n                if not olo <= offset < ohi:\n                    offset = olo\n                decades = range(emin + offset - stride, emax + stride + 1, stride)\n\n        # Guess whether we're a minor locator, based on whether subs include\n        # anything other than 1.\n        is_minor = len(subs) > 1 or (len(subs) == 1 and subs[0] != 1.0)\n        if is_minor:\n            if stride == 1 or n_avail <= 1:\n                # Minor ticks start in the decade preceding the first major tick.\n                ticklocs = np.concatenate([\n                    subs * b**decade for decade in range(emin - 1, emax + 1)])\n            else:\n                ticklocs = np.array([])\n        else:\n            ticklocs = b ** np.array(decades)\n\n        if (len(subs) > 1\n                and stride == 1\n                and (len(decades) - 2  # major\n                     + ((vmin <= ticklocs) & (ticklocs <= vmax)).sum())  # minor\n                     <= 1):\n            # If we're a minor locator *that expects at least two ticks per\n            # decade* and the major locator stride is 1 and there's no more\n            # than one major or minor tick, switch to AutoLocator.\n            return AutoLocator().tick_values(vmin, vmax)\n        else:\n            return self.raise_if_exceeds(ticklocs)\n", "type": "function"}, {"name": "test_colorbar_autoticks", "is_method": false, "class_name": null, "parameters": [], "calls": ["rc_context", "plt.subplots", "np.arange", "np.arange", "np.meshgrid", "pcolormesh", "fig.colorbar", "pcolormesh", "fig.colorbar", "np.testing.assert_almost_equal", "np.testing.assert_almost_equal", "cbar.ax.yaxis.get_ticklocs", "np.arange", "cbar2.ax.yaxis.get_ticklocs", "np.arange"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 453, "end_line": 475}, "code_snippet": "def test_colorbar_autoticks():\n    # Test new autotick modes. Needs to be classic because\n    # non-classic doesn't go this route.\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(2, 1)\n        x = np.arange(-3.0, 4.001)\n        y = np.arange(-4.0, 3.001)\n        X, Y = np.meshgrid(x, y)\n        Z = X * Y\n        Z = Z[:-1, :-1]\n        pcm = ax[0].pcolormesh(X, Y, Z)\n        cbar = fig.colorbar(pcm, ax=ax[0], extend='both',\n                            orientation='vertical')\n\n        pcm = ax[1].pcolormesh(X, Y, Z)\n        cbar2 = fig.colorbar(pcm, ax=ax[1], extend='both',\n                             orientation='vertical', shrink=0.4)\n        # note only -10 to 10 are visible,\n        np.testing.assert_almost_equal(cbar.ax.yaxis.get_ticklocs(),\n                                       np.arange(-15, 16, 5))\n        # note only -10 to 10 are visible\n        np.testing.assert_almost_equal(cbar2.ax.yaxis.get_ticklocs(),\n                                       np.arange(-20, 21, 10))\n", "type": "function"}, {"name": "AutoDateLocator", "docstring": "On autoscale, this class picks the best `DateLocator` to set the view\nlimits and the tick locations.\n\nAttributes\n----------\nintervald : dict\n\n    Mapping of tick frequencies to multiples allowed for that ticking.\n    The default is ::\n\n        self.intervald = {\n            YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,\n                       1000, 2000, 4000, 5000, 10000],\n            MONTHLY : [1, 2, 3, 4, 6],\n            DAILY   : [1, 2, 3, 7, 14, 21],\n            HOURLY  : [1, 2, 3, 4, 6, 12],\n            MINUTELY: [1, 5, 10, 15, 30],\n            SECONDLY: [1, 5, 10, 15, 30],\n            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500,\n                            1000, 2000, 5000, 10000, 20000, 50000,\n                            100000, 200000, 500000, 1000000],\n        }\n\n    where the keys are defined in `dateutil.rrule`.\n\n    The interval is used to specify multiples that are appropriate for\n    the frequency of ticking. For instance, every 7 days is sensible\n    for daily ticks, but for minutes/seconds, 15 or 30 make sense.\n\n    When customizing, you should only modify the values for the existing\n    keys. You should not add or delete entries.\n\n    Example for forcing ticks every 3 hours::\n\n        locator = AutoDateLocator()\n        locator.intervald[HOURLY] = [3]  # only show every 3 hours", "methods": ["__init__", "__call__", "tick_values", "nonsingular", "_get_unit", "get_locator"], "attributes": [], "code_location": {"file": "dates.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1214, "end_line": 1444}, "type": "class"}, {"name": "test_padding", "is_method": true, "class_name": "TestMaxNLocator", "parameters": ["self", "steps", "result"], "calls": ["pytest.mark.parametrize", "mticker.MaxNLocator", "all"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 59, "end_line": 61}, "code_snippet": "    def test_padding(self, steps, result):\n        loc = mticker.MaxNLocator(steps=steps)\n        assert (loc._steps == result).all()\n", "type": "function"}, {"name": "test_colorbar_autotickslog", "is_method": false, "class_name": null, "parameters": [], "calls": ["rc_context", "plt.subplots", "np.arange", "np.arange", "np.meshgrid", "pcolormesh", "fig.colorbar", "pcolormesh", "fig.colorbar", "fig.draw_without_rendering", "np.testing.assert_equal", "np.testing.assert_equal", "np.log10", "np.log10", "LogNorm", "LogNorm", "cbar.ax.yaxis.get_ticklocs", "cbar2.ax.yaxis.get_ticklocs"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 478, "end_line": 500}, "code_snippet": "def test_colorbar_autotickslog():\n    # Test new autotick modes...\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(2, 1)\n        x = np.arange(-3.0, 4.001)\n        y = np.arange(-4.0, 3.001)\n        X, Y = np.meshgrid(x, y)\n        Z = X * Y\n        Z = Z[:-1, :-1]\n        pcm = ax[0].pcolormesh(X, Y, 10**Z, norm=LogNorm())\n        cbar = fig.colorbar(pcm, ax=ax[0], extend='both',\n                            orientation='vertical')\n\n        pcm = ax[1].pcolormesh(X, Y, 10**Z, norm=LogNorm())\n        cbar2 = fig.colorbar(pcm, ax=ax[1], extend='both',\n                             orientation='vertical', shrink=0.4)\n\n        fig.draw_without_rendering()\n        # note only -12 to +12 are visible\n        np.testing.assert_equal(np.log10(cbar.ax.yaxis.get_ticklocs()),\n                                [-18, -12, -6, 0, +6, +12, +18])\n        np.testing.assert_equal(np.log10(cbar2.ax.yaxis.get_ticklocs()),\n                                [-36, -12, 12, +36])\n", "type": "function"}, {"name": "test_tick_values_not_empty", "is_method": true, "class_name": "TestLogLocator", "parameters": ["self"], "calls": ["mticker.LogLocator", "np.array", "assert_almost_equal", "ll.tick_values"], "code_location": {"file": "test_ticker.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 385, "end_line": 393}, "code_snippet": "    def test_tick_values_not_empty(self):\n        mpl.rcParams['_internal.classic_mode'] = False\n        ll = mticker.LogLocator(subs=(1, 2, 5))\n        test_value = np.array([1.e-01, 2.e-01, 5.e-01, 1.e+00, 2.e+00, 5.e+00,\n                               1.e+01, 2.e+01, 5.e+01, 1.e+02, 2.e+02, 5.e+02,\n                               1.e+03, 2.e+03, 5.e+03, 1.e+04, 2.e+04, 5.e+04,\n                               1.e+05, 2.e+05, 5.e+05, 1.e+06, 2.e+06, 5.e+06,\n                               1.e+07, 2.e+07, 5.e+07, 1.e+08, 2.e+08, 5.e+08])\n        assert_almost_equal(ll.tick_values(1, 1e8), test_value)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1563243865966797}
{"question": "What are the cascading effects that would occur in the axis rendering pipeline if modifications to the GridHelperCurveLinear's grid information structure propagate through FixedAxisArtistHelper's tick iteration logic?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_update_grid", "is_method": true, "class_name": "GridHelperCurveLinear", "parameters": ["self", "bbox"], "calls": ["grid_finder.extreme_finder._find_transformed_bbox", "grid_finder.grid_locator1", "np.asarray", "grid_finder.grid_locator2", "np.asarray", "grid_finder._format_ticks", "grid_finder._format_ticks", "grid_finder._get_raw_grid_lines", "grid_finder._get_raw_grid_lines", "dict", "inverted", "grid_finder.get_transform"], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 173, "end_line": 214}, "code_snippet": "    def _update_grid(self, bbox):\n        if self._grid_info is None:\n            self._grid_info = dict()\n\n        grid_info = self._grid_info\n\n        grid_finder = self.grid_finder\n        tbbox = grid_finder.extreme_finder._find_transformed_bbox(\n            grid_finder.get_transform().inverted(), bbox)\n\n        lon_min, lat_min, lon_max, lat_max = tbbox.extents\n        grid_info[\"extremes\"] = tbbox\n\n        lon_levs, lon_n, lon_factor = grid_finder.grid_locator1(lon_min, lon_max)\n        lon_levs = np.asarray(lon_levs)\n        lat_levs, lat_n, lat_factor = grid_finder.grid_locator2(lat_min, lat_max)\n        lat_levs = np.asarray(lat_levs)\n\n        grid_info[\"lon_info\"] = lon_levs, lon_n, lon_factor\n        grid_info[\"lat_info\"] = lat_levs, lat_n, lat_factor\n\n        grid_info[\"lon_labels\"] = grid_finder._format_ticks(\n            1, \"bottom\", lon_factor, lon_levs)\n        grid_info[\"lat_labels\"] = grid_finder._format_ticks(\n            2, \"bottom\", lat_factor, lat_levs)\n\n        lon_values = lon_levs[:lon_n] / lon_factor\n        lat_values = lat_levs[:lat_n] / lat_factor\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            lon_values[(lon_min < lon_values) & (lon_values < lon_max)],\n            lat_values[(lat_min < lat_values) & (lat_values < lat_max)],\n            tbbox)\n\n        grid_info[\"lon_lines\"] = lon_lines\n        grid_info[\"lat_lines\"] = lat_lines\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            tbbox.intervalx, tbbox.intervaly, tbbox)\n\n        grid_info[\"lon_lines0\"] = lon_lines\n        grid_info[\"lat_lines0\"] = lat_lines\n", "type": "function"}, {"name": "GridHelperCurveLinear", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "grid_helper_curvelinear.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 276, "end_line": 352}, "type": "class"}, {"name": "GridHelperCurveLinear", "docstring": "", "methods": ["__init__", "new_fixed_axis", "_update_grid", "get_gridlines", "__init__", "update_grid_finder", "new_fixed_axis", "new_floating_axis", "_update_grid", "get_gridlines"], "attributes": [], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 128, "end_line": 222}, "type": "class"}, {"name": "_update_ticks", "is_method": true, "class_name": "AxisArtist", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._axis_artist_helper.get_tick_iterators", "self._get_tick_info", "self.major_ticks.set_locs_angles", "self.major_ticklabels.set_locs_angles_labels", "self._get_tick_info", "self.minor_ticks.set_locs_angles", "self.minor_ticklabels.set_locs_angles_labels", "_get_renderer", "self.major_ticks.get_visible", "self.major_ticks.get_tick_out", "self.get_figure"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 921, "end_line": 948}, "code_snippet": "    def _update_ticks(self, renderer=None):\n        # set extra pad for major and minor ticklabels: use ticksize of\n        # majorticks even for minor ticks. not clear what is best.\n\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        if self.major_ticks.get_visible() and self.major_ticks.get_tick_out():\n            ticklabel_pad = self.major_ticks._ticksize * dpi_cor\n            self.major_ticklabels._external_pad = ticklabel_pad\n            self.minor_ticklabels._external_pad = ticklabel_pad\n        else:\n            self.major_ticklabels._external_pad = 0\n            self.minor_ticklabels._external_pad = 0\n\n        majortick_iter, minortick_iter = \\\n            self._axis_artist_helper.get_tick_iterators(self.axes)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(majortick_iter)\n        self.major_ticks.set_locs_angles(tick_loc_angle)\n        self.major_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(minortick_iter)\n        self.minor_ticks.set_locs_angles(tick_loc_angle)\n        self.minor_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n", "type": "function"}, {"name": "new_fixed_axis", "is_method": true, "class_name": "GridHelperCurveLinear", "parameters": ["self", "loc", "nth_coord", "axis_direction", "offset", "axes"], "calls": ["FixedAxisArtistHelper", "AxisArtist", "axisline.line.set_clip_on", "axisline.line.set_clip_box"], "code_location": {"file": "floating_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 143, "end_line": 157}, "code_snippet": "    def new_fixed_axis(\n            self, loc, nth_coord=None, axis_direction=None, offset=None, axes=None):\n        if axes is None:\n            axes = self.axes\n        if axis_direction is None:\n            axis_direction = loc\n        # This is not the same as the FixedAxisArtistHelper class used by\n        # grid_helper_curvelinear.GridHelperCurveLinear.new_fixed_axis!\n        helper = FixedAxisArtistHelper(\n            self, loc, nth_coord_ticks=nth_coord)\n        axisline = AxisArtist(axes, helper, axis_direction=axis_direction)\n        # Perhaps should be moved to the base class?\n        axisline.line.set_clip_on(True)\n        axisline.line.set_clip_box(axisline.axes.bbox)\n        return axisline\n", "type": "function"}, {"name": "update_grid_finder", "is_method": true, "class_name": "GridHelperCurveLinear", "parameters": ["self", "aux_trans"], "calls": ["self.grid_finder.update", "self.grid_finder.update_transform"], "code_location": {"file": "grid_helper_curvelinear.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 312, "end_line": 316}, "code_snippet": "    def update_grid_finder(self, aux_trans=None, **kwargs):\n        if aux_trans is not None:\n            self.grid_finder.update_transform(aux_trans)\n        self.grid_finder.update(**kwargs)\n        self._old_limits = None  # Force revalidation.\n", "type": "function"}, {"name": "new_fixed_axis", "is_method": true, "class_name": "GridHelperCurveLinear", "parameters": ["self", "loc"], "calls": ["FixedAxisArtistHelper", "AxisArtist"], "code_location": {"file": "grid_helper_curvelinear.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 318, "end_line": 329}, "code_snippet": "    def new_fixed_axis(\n        self, loc, *, axis_direction=None, offset=None, axes=None, nth_coord=None\n    ):\n        if axes is None:\n            axes = self.axes\n        if axis_direction is None:\n            axis_direction = loc\n        helper = FixedAxisArtistHelper(self, loc, nth_coord_ticks=nth_coord)\n        axisline = AxisArtist(axes, helper, axis_direction=axis_direction)\n        # Why is clip not set on axisline, unlike in new_floating_axis or in\n        # the floating_axig.GridHelperCurveLinear subclass?\n        return axisline\n", "type": "function"}, {"name": "new_fixed_axis", "is_method": true, "class_name": "Axes", "parameters": ["self", "loc", "offset"], "calls": ["new_fixed_axis", "self.get_grid_helper"], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 449, "end_line": 450}, "code_snippet": "    def new_fixed_axis(self, loc, offset=None):\n        return self.get_grid_helper().new_fixed_axis(loc, offset=offset, axes=self)\n", "type": "function"}, {"name": "_apply_params", "is_method": true, "class_name": "Tick", "parameters": ["self"], "calls": ["any", "self.tick1line.set", "self.tick2line.set", "tick_kw.items", "self.label1.set", "self.label2.set", "self.gridline.set", "kwargs.pop", "kwargs.pop", "kwargs.pop", "self._apply_tickdir", "self.label1.set_transform", "self.label2.set_transform", "setattr", "self._set_labelrotation", "self.label1.set", "self.label2.set", "target.set_visible", "kwargs.pop", "line.set_markersize", "line.set_markeredgewidth", "self._get_text1_transform", "self._get_text2_transform", "kwargs.items", "kwargs.pop", "kwargs.items", "kwargs.items", "kwargs.pop"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 305, "end_line": 351}, "code_snippet": "    def _apply_params(self, **kwargs):\n        for name, target in [(\"gridOn\", self.gridline),\n                             (\"tick1On\", self.tick1line),\n                             (\"tick2On\", self.tick2line),\n                             (\"label1On\", self.label1),\n                             (\"label2On\", self.label2)]:\n            if name in kwargs:\n                target.set_visible(kwargs.pop(name))\n        if any(k in kwargs for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kwargs.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kwargs.pop('width', self._width)\n            self._base_pad = kwargs.pop('pad', self._base_pad)\n            # _apply_tickdir uses _size and _base_pad to make _pad, and also\n            # sets the ticklines markers.\n            self._apply_tickdir(kwargs.pop('tickdir', self._tickdir))\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from _apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kwargs.items() if k in ['color', 'zorder']}\n        if 'color' in kwargs:\n            tick_kw['markeredgecolor'] = kwargs['color']\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kwargs:\n            self._set_labelrotation(kwargs.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kwargs.items()\n                    if k in ['labelsize', 'labelcolor', 'labelfontfamily',\n                             'labelrotation_mode']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n\n        grid_kw = {k[5:]: v for k, v in kwargs.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n", "type": "function"}, {"name": "FixedAxisArtistHelperRectilinear", "docstring": "", "methods": ["__init__", "get_tick_iterators"], "attributes": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 171, "end_line": 201}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1378605365753174}
{"question": "What is the semantic contract established by the LaTeX preamble configuration in test_font_bitstream_charter between the text rendering pipeline and the PDF backend's glyph subsetting mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_font_bitstream_charter", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.skipif", "image_comparison", "join", "plt.subplots", "ax.text", "ax.text", "ax.set_xticks", "ax.set_yticks", "_has_tex_package"], "code_location": {"file": "test_backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 470, "end_line": 480}, "code_snippet": "def test_font_bitstream_charter():\n    mpl.rcParams['text.latex.preamble'] = '\\n'.join((\n        r'\\usepackage{charter}',\n        r'\\usepackage[T1]{fontenc}',\n        r'\\usepackage[utf8]{inputenc}'\n    ))\n    fig, ax = plt.subplots()\n    ax.text(0.1, 0.1, r\"åüš ABCDabcd\", usetex=True, fontsize=50)\n    ax.text(0.1, 0.3, r\"fi ffl 1234\", usetex=True, fontsize=50)\n    ax.set_xticks([])\n    ax.set_yticks([])\n", "type": "function"}, {"name": "test_pdf_type1_font_subsetting", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.importorskip", "plt.subplots", "ax.text", "ax.text", "print", "issubset", "length.items", "TemporaryFile", "fig.savefig", "tmpfile.seek", "pikepdf.Pdf.open", "page.Resources.Font.items", "removeprefix", "re.match", "base_font.split", "len", "bytes", "str"], "code_location": {"file": "test_usetex.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 160, "end_line": 210}, "code_snippet": "def test_pdf_type1_font_subsetting():\n    \"\"\"Test that fonts in PDF output are properly subset.\"\"\"\n    pikepdf = pytest.importorskip(\"pikepdf\")\n\n    mpl.rcParams[\"text.usetex\"] = True\n    mpl.rcParams[\"text.latex.preamble\"] = r\"\\usepackage{amssymb}\"\n    fig, ax = plt.subplots()\n    ax.text(0.2, 0.7, r\"$\\int_{-\\infty}^{\\aleph}\\sqrt{\\alpha\\beta\\gamma}\\mathrm{d}x$\")\n    ax.text(0.2, 0.5, r\"$\\mathfrak{x}\\circledcirc\\mathfrak{y}\\in\\mathbb{R}$\")\n\n    with TemporaryFile() as tmpfile:\n        fig.savefig(tmpfile, format=\"pdf\")\n        tmpfile.seek(0)\n        pdf = pikepdf.Pdf.open(tmpfile)\n\n        length = {}\n        page = pdf.pages[0]\n        for font_name, font in page.Resources.Font.items():\n            assert font.Subtype == \"/Type1\", (\n                f\"Font {font_name}={font} is not a Type 1 font\"\n            )\n\n            # Subsetted font names have a 6-character tag followed by a '+'\n            base_font = str(font[\"/BaseFont\"]).removeprefix(\"/\")\n            assert re.match(r\"^[A-Z]{6}\\+\", base_font), (\n                f\"Font {font_name}={base_font} lacks a subset indicator tag\"\n            )\n            assert \"/FontFile\" in font.FontDescriptor, (\n                f\"Type 1 font {font_name}={base_font} is not embedded\"\n            )\n            _, original_name = base_font.split(\"+\", 1)\n            length[original_name] = len(bytes(font[\"/FontDescriptor\"][\"/FontFile\"]))\n\n    print(\"Embedded font stream lengths:\", length)\n    # We should have several fonts, each much smaller than the original.\n    # I get under 10kB on my system for each font, but allow 15kB in case\n    # of differences in the font files.\n    assert {\n        'CMEX10',\n        'CMMI12',\n        'CMR12',\n        'CMSY10',\n        'CMSY8',\n        'EUFM10',\n        'MSAM10',\n        'MSBM10',\n    }.issubset(length), \"Missing expected fonts in the PDF\"\n    for font_name, length in length.items():\n        assert length < 15_000, (\n            f\"Font {font_name}={length} is larger than expected\"\n        )\n", "type": "function"}, {"name": "CharacterTracker", "docstring": "Helper for font subsetting by the pdf and ps backends.\n\nMaintains a mapping of font paths to the set of character codepoints that\nare being used from that font.", "methods": ["__init__", "track", "track_glyph"], "attributes": [], "code_location": {"file": "_backend_pdf_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 98, "end_line": 117}, "type": "class"}, {"name": "test_font_heuristica", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.skipif", "image_comparison", "join", "plt.subplots", "ax.text", "ax.set_xticks", "ax.set_yticks", "_has_tex_package"], "code_location": {"file": "test_backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 436, "end_line": 446}, "code_snippet": "def test_font_heuristica():\n    # Heuristica uses the callothersubr operator for some glyphs\n    mpl.rcParams['text.latex.preamble'] = '\\n'.join((\n        r'\\usepackage{heuristica}',\n        r'\\usepackage[T1]{fontenc}',\n        r'\\usepackage[utf8]{inputenc}'\n    ))\n    fig, ax = plt.subplots()\n    ax.text(0.1, 0.1, r\"BHTem fi ffl 1234\", usetex=True, fontsize=50)\n    ax.set_xticks([])\n    ax.set_yticks([])\n", "type": "function"}, {"name": "test_glyphs_subset", "is_method": false, "class_name": null, "parameters": [], "calls": ["str", "FT2Font", "nosubfont.set_text", "subfont.set_text", "nosubfont.get_charmap", "subfont.get_charmap", "_get_data_path", "get_glyphs_subset", "FT2Font", "len", "len", "subfont.get_num_glyphs", "nosubfont.get_num_glyphs", "font_as_file", "chr"], "code_location": {"file": "test_backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 357, "end_line": 380}, "code_snippet": "def test_glyphs_subset():\n    fpath = str(_get_data_path(\"fonts/ttf/DejaVuSerif.ttf\"))\n    chars = \"these should be subsetted! 1234567890\"\n\n    # non-subsetted FT2Font\n    nosubfont = FT2Font(fpath)\n    nosubfont.set_text(chars)\n\n    # subsetted FT2Font\n    with get_glyphs_subset(fpath, chars) as subset:\n        subfont = FT2Font(font_as_file(subset))\n    subfont.set_text(chars)\n\n    nosubcmap = nosubfont.get_charmap()\n    subcmap = subfont.get_charmap()\n\n    # all unique chars must be available in subsetted font\n    assert {*chars} == {chr(key) for key in subcmap}\n\n    # subsetted font's charmap should have less entries\n    assert len(subcmap) < len(nosubcmap)\n\n    # since both objects are assigned same characters\n    assert subfont.get_num_glyphs() == nosubfont.get_num_glyphs()\n", "type": "function"}, {"name": "test_pdf_chars_beyond_bmp", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "plt.figtext"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 868, "end_line": 872}, "code_snippet": "def test_pdf_chars_beyond_bmp():\n    plt.rcParams['pdf.fonttype'] = 42\n    plt.rcParams['mathtext.fontset'] = 'stixsans'\n    plt.figure()\n    plt.figtext(0.1, 0.5, \"Mass $m$ \\U00010308\", size=30)\n", "type": "function"}, {"name": "_get_subsetted_psname", "is_method": true, "class_name": "PdfFile", "parameters": ["ps_name", "charmap"], "calls": ["PdfFile._get_subset_prefix", "frozenset", "charmap.keys"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 853, "end_line": 854}, "code_snippet": "    def _get_subsetted_psname(ps_name, charmap):\n        return PdfFile._get_subset_prefix(frozenset(charmap.keys())) + ps_name\n", "type": "function"}, {"name": "test_pdf_kerning", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "plt.figtext"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 813, "end_line": 815}, "code_snippet": "def test_pdf_kerning():\n    plt.figure()\n    plt.figtext(0.1, 0.5, \"ATATATATATATATATATA\", size=30)\n", "type": "function"}, {"name": "test_pdf_font42_kerning", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "plt.figtext"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 861, "end_line": 864}, "code_snippet": "def test_pdf_font42_kerning():\n    plt.rcParams['pdf.fonttype'] = 42\n    plt.figure()\n    plt.figtext(0.1, 0.5, \"ATAVATAVATAVATAVATA\", size=30)\n", "type": "function"}, {"name": "test_use14corefonts", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.subplots", "ax.set_title", "ax.text", "ax.axhline"], "code_location": {"file": "test_backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 25, "end_line": 41}, "code_snippet": "def test_use14corefonts():\n    rcParams['pdf.use14corefonts'] = True\n    rcParams['font.family'] = 'sans-serif'\n    rcParams['font.size'] = 8\n    rcParams['font.sans-serif'] = ['Helvetica']\n    rcParams['pdf.compression'] = 0\n\n    text = '''A three-line text positioned just above a blue line\nand containing some French characters and the euro symbol:\n\"Merci pépé pour les 10 €\"'''\n\n    fig, ax = plt.subplots()\n    ax.set_title('Test PDF backend with option use14corefonts=True')\n    ax.text(0.5, 0.5, text, horizontalalignment='center',\n            verticalalignment='bottom',\n            fontsize=14)\n    ax.axhline(0.5, linewidth=0.5)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.129359245300293}
{"question": "Why does the RendererSVG class employ a deferred rendering strategy where clip paths and hatches are written only during finalization rather than immediately when encountered?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_write_hatches", "is_method": true, "class_name": "RendererSVG", "parameters": ["self"], "calls": ["writer.start", "self._hatchd.values", "writer.end", "len", "writer.start", "self._convert_path", "writer.element", "writer.element", "writer.end", "translate", "rgb2hex", "rgb2hex", "rgb2hex", "str", "str", "str", "str", "str", "str", "_generate_css", "scale", "scale", "Affine2D"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 513, "end_line": 555}, "code_snippet": "    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke, lw), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE+1),\n                height=str(HATCH_SIZE+1),\n                fill=fill)\n            hatch_style = {\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': str(lw),\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    }\n            if stroke[3] < 1:\n                hatch_style['stroke-opacity'] = str(stroke[3])\n            writer.element(\n                'path',\n                d=path_data,\n                style=_generate_css(hatch_style)\n                )\n            writer.end('pattern')\n        writer.end('defs')\n", "type": "function"}, {"name": "finalize", "is_method": true, "class_name": "RendererSVG", "parameters": ["self"], "calls": ["self._write_clips", "self._write_hatches", "self.writer.close", "self.writer.flush"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 344, "end_line": 348}, "code_snippet": "    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n", "type": "function"}, {"name": "_write_clips", "is_method": true, "class_name": "RendererSVG", "parameters": ["self"], "calls": ["writer.start", "self._clipd.values", "writer.end", "len", "writer.start", "writer.end", "len", "self._convert_path", "writer.element", "writer.element", "_short_float_fmt", "_short_float_fmt", "_short_float_fmt", "_short_float_fmt"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 628, "end_line": 649}, "code_snippet": "    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n", "type": "function"}, {"name": "writeHatches", "is_method": true, "class_name": "PdfFile", "parameters": ["self"], "calls": ["dict", "self._hatch_patterns.items", "self.writeObject", "self.reserveObject", "self.beginStream", "self.output", "self.output", "self.output", "self.output", "self.output", "self.endStream", "self.output", "Name", "Name", "self.pathOperations", "split", "Path.hatch", "scale", "Affine2D"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1580, "end_line": 1618}, "code_snippet": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self._hatch_patterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, hatch, lw = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_nonstroke)\n\n            self.output(lw, Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(hatch),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)\n", "type": "function"}, {"name": "draw_path_collection", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "gc", "master_transform", "paths", "all_transforms", "offsets", "offset_trans", "facecolors", "edgecolors", "linewidths", "linestyles", "antialiaseds", "urls", "offset_position"], "calls": ["self._iter_collection_uses_per_path", "writer.start", "enumerate", "writer.end", "self._iter_collection", "len", "draw_path_collection", "self._iter_collection_raw_paths", "scale", "self._convert_path", "format", "writer.element", "path_codes.append", "gc0.get_url", "self._get_clip_attrs", "writer.element", "len", "self._make_id", "writer.start", "writer.start", "_short_float_fmt", "_short_float_fmt", "self._get_style", "writer.end", "writer.end", "super", "Affine2D", "transform.get_matrix"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 736, "end_line": 794}, "code_snippet": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position, *, hatchcolors=None):\n        if hatchcolors is None:\n            hatchcolors = []\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position, hatchcolors=hatchcolors)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C{:x}_{:x}_{}'.format(\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position, hatchcolors=hatchcolors):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': f'#{path_id}',\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "width", "height", "svgwriter", "basename", "image_dpi"], "calls": ["XMLWriter", "itertools.count", "__init__", "dict", "_short_float_fmt", "_short_float_fmt", "svgwriter.write", "self.writer.start", "self._write_metadata", "self._write_default_style", "getattr", "isinstance", "super"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 290, "end_line": 328}, "code_snippet": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clip_path_ids = {}\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width=f'{str_width}pt',\n            height=f'{str_height}pt',\n            viewBox=f'0 0 {str_width} {str_height}',\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            id=mpl.rcParams['svg.id'],\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n", "type": "function"}, {"name": "draw_path_collection", "is_method": true, "class_name": "RendererPdf", "parameters": ["self", "gc", "master_transform", "paths", "all_transforms", "offsets", "offset_trans", "facecolors", "edgecolors", "linewidths", "linestyles", "antialiaseds", "urls", "offset_position"], "calls": ["np.asarray", "np.asarray", "self._iter_collection_uses_per_path", "np.max", "enumerate", "output", "self._iter_collection", "output", "len", "np.all", "len", "np.all", "len", "RendererBase.draw_path_collection", "self._iter_collection_raw_paths", "self.file.pathCollectionObject", "path_codes.append", "self.check_gc", "output", "gc.get_hatch", "np.all", "len", "self.gc.push", "self.gc.pop", "np.asarray"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 2056, "end_line": 2127}, "code_snippet": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position, *, hatchcolors=None):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if hatchcolors is None:\n            hatchcolors = []\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position, hatchcolors=hatchcolors)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position, hatchcolors=hatchcolors):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())\n", "type": "function"}, {"name": "_get_clip_attrs", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "gc"], "calls": ["gc.get_clip_rectangle", "gc.get_clip_path", "self._clipd.get", "self._make_flip_transform", "self._make_id", "self._get_clippath_id", "str"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 605, "end_line": 626}, "code_snippet": "    def _get_clip_attrs(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (self._get_clippath_id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return {}\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            _, oid = clip\n        return {'clip-path': f'url(#{oid})'}\n", "type": "function"}, {"name": "test_clip_path_ids_reuse", "is_method": false, "class_name": null, "parameters": [], "calls": ["range", "Circle", "fig.add_subplot", "ax.imshow", "aimg.set_clip_path", "xml.etree.ElementTree.fromstring", "set", "tree.findall", "Figure", "Circle", "fig.add_subplot", "ax.imshow", "aimg.set_clip_path", "BytesIO", "fig.savefig", "fd.getvalue", "clip_path_ids.add", "len"], "code_location": {"file": "test_backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 304, "end_line": 328}, "code_snippet": "def test_clip_path_ids_reuse():\n    fig, circle = Figure(), Circle((0, 0), radius=10)\n    for i in range(5):\n        ax = fig.add_subplot()\n        aimg = ax.imshow([[i]])\n        aimg.set_clip_path(circle)\n\n    inner_circle = Circle((0, 0), radius=1)\n    ax = fig.add_subplot()\n    aimg = ax.imshow([[0]])\n    aimg.set_clip_path(inner_circle)\n\n    with BytesIO() as fd:\n        fig.savefig(fd, format='svg')\n        buf = fd.getvalue()\n\n    tree = xml.etree.ElementTree.fromstring(buf)\n    ns = 'http://www.w3.org/2000/svg'\n\n    clip_path_ids = set()\n    for node in tree.findall(f'.//{{{ns}}}clipPath[@id]'):\n        node_id = node.attrib['id']\n        assert node_id not in clip_path_ids  # assert ID uniqueness\n        clip_path_ids.add(node_id)\n    assert len(clip_path_ids) == 2  # only two clipPaths despite reuse in multiple axes\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "ContourSet", "parameters": ["self", "renderer"], "calls": ["len", "self.get_edgecolors", "range", "all", "draw", "cbook._setattr_cm", "self._cm_set", "draw", "super", "super", "len", "self.get_array", "self.get_linewidths", "self.get_linestyles", "len", "len", "len", "self.get_linewidths", "self.get_linestyles"], "code_location": {"file": "contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1270, "end_line": 1288}, "code_snippet": "    def draw(self, renderer):\n        paths = self._paths\n        n_paths = len(paths)\n        if not self.filled or all(hatch is None for hatch in self.hatches):\n            super().draw(renderer)\n            return\n        # In presence of hatching, draw contours one at a time.\n        edgecolors = self.get_edgecolors()\n        if edgecolors.size == 0:\n            edgecolors = (\"none\",)\n        for idx in range(n_paths):\n            with cbook._setattr_cm(self, _paths=[paths[idx]]), self._cm_set(\n                hatch=self.hatches[idx % len(self.hatches)],\n                array=[self.get_array()[idx]],\n                linewidths=[self.get_linewidths()[idx % len(self.get_linewidths())]],\n                linestyles=[self.get_linestyles()[idx % len(self.get_linestyles())]],\n                edgecolors=edgecolors[idx % len(edgecolors)],\n            ):\n                super().draw(renderer)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.125014305114746}
{"question": "How does TransformWrapper's set() method maintain invalidation state consistency when replacing a child transform, and what is the significance of the double invalidation pattern with _invalid flag reset?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_invalidate_internal", "is_method": true, "class_name": "CompositeGenericTransform", "parameters": ["self", "level", "invalidating_node"], "calls": ["_invalidate_internal", "super"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2394, "end_line": 2399}, "code_snippet": "    def _invalidate_internal(self, level, invalidating_node):\n        # When the left child is invalidated at AFFINE_ONLY level and the right child is\n        # non-affine, the composite transform is FULLY invalidated.\n        if invalidating_node is self._a and not self._b.is_affine:\n            level = Transform._INVALID_FULL\n        super()._invalidate_internal(level, invalidating_node)\n", "type": "function"}, {"name": "set_children", "is_method": true, "class_name": "TransformNode", "parameters": ["self"], "calls": ["id", "weakref.ref", "pop"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 178, "end_line": 195}, "code_snippet": "    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the children won't\n        # keep them alive.\n        id_self = id(self)\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(\n                self, lambda _, pop=child._parents.pop, k=id_self: pop(k))\n            child._parents[id_self] = ref\n", "type": "function"}, {"name": "set_transform", "is_method": true, "class_name": "Line2D", "parameters": ["self", "t"], "calls": ["set_transform", "super"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 740, "end_line": 744}, "code_snippet": "    def set_transform(self, t):\n        # docstring inherited\n        self._invalidx = True\n        self._invalidy = True\n        super().set_transform(t)\n", "type": "function"}, {"name": "set", "is_method": true, "class_name": "TransformWrapper", "parameters": ["self", "child"], "calls": ["hasattr", "self.set_children", "self.invalidate", "self.invalidate", "self._child._parents.pop", "ValueError", "id"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1743, "end_line": 1778}, "code_snippet": "    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        if hasattr(self, \"_child\"):  # Absent during init.\n            self.invalidate()\n            new_dims = (child.input_dims, child.output_dims)\n            old_dims = (self._child.input_dims, self._child.output_dims)\n            if new_dims != old_dims:\n                raise ValueError(\n                    f\"The input and output dims of the new child {new_dims} \"\n                    f\"do not match those of current child {old_dims}\")\n            self._child._parents.pop(id(self), None)\n\n        self._child = child\n        self.set_children(child)\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = child.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix\n        # note we do not wrap other properties here since the transform's\n        # child can be changed with WrappedTransform.set and so checking\n        # is_affine and other such properties may be dangerous.\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "TransformWrapper", "parameters": ["self", "child"], "calls": ["_api.check_isinstance", "__init__", "self.set", "super"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1725, "end_line": 1732}, "code_snippet": "    def __init__(self, child):\n        \"\"\"\n        *child*: A `Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        _api.check_isinstance(Transform, child=child)\n        super().__init__()\n        self.set(child)\n", "type": "function"}, {"name": "test_invalidate", "is_method": true, "class_name": "TestAffineDeltaTransform", "parameters": ["self"], "calls": ["np.array", "np.array", "mtransforms.Affine2D.from_values", "mtransforms.AffineDeltaTransform", "assert_array_equal", "assert_array_equal", "base.invalidate", "assert_array_equal", "t.get_matrix", "base.get_matrix", "t.get_matrix", "t.get_matrix"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 346, "end_line": 367}, "code_snippet": "    def test_invalidate(self):\n        before = np.array([[1.0, 4.0, 0.0],\n                           [5.0, 1.0, 0.0],\n                           [0.0, 0.0, 1.0]])\n        after = np.array([[1.0, 3.0, 0.0],\n                          [5.0, 1.0, 0.0],\n                          [0.0, 0.0, 1.0]])\n\n        # Translation and skew present\n        base = mtransforms.Affine2D.from_values(1, 5, 4, 1, 2, 3)\n        t = mtransforms.AffineDeltaTransform(base)\n        assert_array_equal(t.get_matrix(), before)\n\n        # Mess with the internal structure of `base` without invalidating\n        # This should not affect this transform because it's a passthrough:\n        # it's always invalid\n        base.get_matrix()[0, 1:] = 3\n        assert_array_equal(t.get_matrix(), after)\n\n        # Invalidate the base\n        base.invalidate()\n        assert_array_equal(t.get_matrix(), after)\n", "type": "function"}, {"name": "_revalidate", "is_method": true, "class_name": "TransformedPatchPath", "parameters": ["self"], "calls": ["self._patch.get_path", "_revalidate", "super"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2830, "end_line": 2837}, "code_snippet": "    def _revalidate(self):\n        patch_path = self._patch.get_path()\n        # Force invalidation if the patch path changed; otherwise, let base\n        # class check invalidation.\n        if patch_path != self._path:\n            self._path = patch_path\n            self._transformed_path = None\n        super()._revalidate()\n", "type": "function"}, {"name": "invalidate", "is_method": true, "class_name": "TransformNode", "parameters": ["self"], "calls": ["self._invalidate_internal"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 154, "end_line": 161}, "code_snippet": "    def invalidate(self):\n        \"\"\"\n        Invalidate this `TransformNode` and triggers an invalidation of its\n        ancestors.  Should be called any time the transform changes.\n        \"\"\"\n        return self._invalidate_internal(\n            level=self._INVALID_AFFINE_ONLY if self.is_affine else self._INVALID_FULL,\n            invalidating_node=self)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AffineDeltaTransform", "parameters": ["self", "transform"], "calls": ["__init__", "self.set_children", "super"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2728, "end_line": 2731}, "code_snippet": "    def __init__(self, transform, **kwargs):\n        super().__init__(**kwargs)\n        self._base_transform = transform\n        self.set_children(transform)\n", "type": "function"}, {"name": "set_transform", "is_method": true, "class_name": "Cell", "parameters": ["self", "t"], "calls": ["set_transform", "super"], "code_location": {"file": "table.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 108, "end_line": 111}, "code_snippet": "    def set_transform(self, t):\n        super().set_transform(t)\n        # the text does not get the transform!\n        self.stale = True\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.152994155883789}
{"question": "How does the LightSource class coordinate the transformation of azimuth and elevation angles through the direction property to ensure correct light vector computation across different blend modes that depend on this directional information?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "LightSource", "parameters": ["self", "azdeg", "altdeg", "hsv_min_val", "hsv_max_val", "hsv_min_sat", "hsv_max_sat"], "calls": [], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3443, "end_line": 3484}, "code_snippet": "    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : float, default: 315 degrees (from the northwest)\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source.\n        altdeg : float, default: 45 degrees\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.\n        hsv_min_val : number, default: 0\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_max_val : number, default: 1\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_min_sat : number, default: 1\n            The minimum saturation value that the *intensity* map can shift the output\n            image to.\n        hsv_max_sat : number, default: 0\n            The maximum saturation value that the *intensity* map can shift the output\n            image to.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n        See the documentation for `blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n", "type": "function"}, {"name": "hillshade", "is_method": true, "class_name": "LightSource", "parameters": ["self", "elevation", "vert_exag", "dx", "dy", "fraction"], "calls": ["np.gradient", "view", "_vector_magnitude", "self.shade_normals", "type", "np.empty"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3499, "end_line": 3550}, "code_snippet": "    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculate the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        This computes the normal vectors for the surface, and then passes them\n        on to `shade_normals`\n\n        Parameters\n        ----------\n        elevation : 2D array-like\n            The height values used to generate an illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            A 2D array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        # compute the normal vectors from the partial derivatives\n        e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n\n        # .view is to keep subclasses\n        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n        normal[..., 0] = -e_dx\n        normal[..., 1] = -e_dy\n        normal[..., 2] = 1\n        normal /= _vector_magnitude(normal)\n\n        return self.shade_normals(normal, fraction)\n", "type": "function"}, {"name": "shade_rgb", "is_method": true, "class_name": "LightSource", "parameters": ["self", "rgb", "elevation", "fraction", "blend_mode", "vert_exag", "dx", "dy"], "calls": ["self.hillshade", "np.ma.is_masked", "range", "blend_mode", "ValueError"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3674, "end_line": 3746}, "code_snippet": "    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            (M, N, 3) RGB array of floats (ranging 0 to 1) with an (M, N, 1)\n            hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of '\n                                 f'{lookup.keys}') from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if np.ma.is_masked(intensity):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n", "type": "function"}, {"name": "shade_normals", "is_method": true, "class_name": "LightSource", "parameters": ["self", "normals", "fraction"], "calls": ["normals.dot", "np.clip", "intensity.min", "intensity.max"], "code_location": {"file": "colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3552, "end_line": 3596}, "code_snippet": "    def shade_normals(self, normals, fraction=1.):\n        \"\"\"\n        Calculate the illumination intensity for the normal vectors of a\n        surface using the defined azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            A 2D array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        intensity = normals.dot(self.direction)\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1)\n\n        return intensity\n", "type": "function"}, {"name": "_update_transScale", "is_method": true, "class_name": "_AxesBase", "parameters": ["self"], "calls": ["self.transScale.set", "mtransforms.blended_transform_factory", "self.xaxis.get_transform", "self.yaxis.get_transform"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 1115, "end_line": 1118}, "code_snippet": "    def _update_transScale(self):\n        self.transScale.set(\n            mtransforms.blended_transform_factory(\n                self.xaxis.get_transform(), self.yaxis.get_transform()))\n", "type": "function"}, {"name": "get_patch_transform", "is_method": true, "class_name": "Spine", "parameters": ["self"], "calls": ["self._recompute_transform", "get_patch_transform", "super"], "code_location": {"file": "spines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 135, "end_line": 140}, "code_snippet": "    def get_patch_transform(self):\n        if self._patch_type in ('arc', 'circle'):\n            self._recompute_transform()\n            return self._patch_transform\n        else:\n            return super().get_patch_transform()\n", "type": "function"}, {"name": "_set_lim_and_transforms", "is_method": true, "class_name": "ParasiteAxesBase", "parameters": ["self"], "calls": ["mtransforms.blended_transform_factory", "mtransforms.blended_transform_factory", "_set_lim_and_transforms", "super"], "code_location": {"file": "parasite_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 45, "end_line": 54}, "code_snippet": "    def _set_lim_and_transforms(self):\n        if self.transAux is not None:\n            self.transAxes = self._parent_axes.transAxes\n            self.transData = self.transAux + self._parent_axes.transData\n            self._xaxis_transform = mtransforms.blended_transform_factory(\n                self.transData, self.transAxes)\n            self._yaxis_transform = mtransforms.blended_transform_factory(\n                self.transAxes, self.transData)\n        else:\n            super()._set_lim_and_transforms()\n", "type": "function"}, {"name": "_theta_stretch", "is_method": true, "class_name": "Arc", "parameters": ["self"], "calls": ["self.convert_xunits", "self.convert_yunits", "np.deg2rad", "np.cos", "np.sin", "np.rad2deg", "theta_stretch", "theta_stretch", "np.arctan2"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2243, "end_line": 2271}, "code_snippet": "    def _theta_stretch(self):\n        # If the width and height of ellipse are not equal, take into account\n        # stretching when calculating angles to draw between\n        def theta_stretch(theta, scale):\n            theta = np.deg2rad(theta)\n            x = np.cos(theta)\n            y = np.sin(theta)\n            stheta = np.rad2deg(np.arctan2(scale * y, x))\n            # arctan2 has the range [-pi, pi], we expect [0, 2*pi]\n            return (stheta + 360) % 360\n\n        width = self.convert_xunits(self.width)\n        height = self.convert_yunits(self.height)\n        if (\n            # if we need to stretch the angles because we are distorted\n            width != height\n            # and we are not doing a full circle.\n            #\n            # 0 and 360 do not exactly round-trip through the angle\n            # stretching (due to both float precision limitations and\n            # the difference between the range of arctan2 [-pi, pi] and\n            # this method [0, 360]) so avoid doing it if we don't have to.\n            and not (self.theta1 != self.theta2 and\n                     self.theta1 % 360 == self.theta2 % 360)\n        ):\n            theta1 = theta_stretch(self.theta1, width / height)\n            theta2 = theta_stretch(self.theta2, width / height)\n            return theta1, theta2, width, height\n        return self.theta1, self.theta2, width, height\n", "type": "function"}, {"name": "get_facecolor", "is_method": true, "class_name": "Path3DCollection", "parameters": ["self"], "calls": ["self._maybe_depth_shade_and_sort_colors", "get_facecolor", "super"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 1079, "end_line": 1080}, "code_snippet": "    def get_facecolor(self):\n        return self._maybe_depth_shade_and_sort_colors(super().get_facecolor())\n", "type": "function"}, {"name": "get_facecolor", "is_method": true, "class_name": "Patch3DCollection", "parameters": ["self"], "calls": ["self._maybe_depth_shade_and_sort_colors", "get_facecolor", "super"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 824, "end_line": 825}, "code_snippet": "    def get_facecolor(self):\n        return self._maybe_depth_shade_and_sort_colors(super().get_facecolor())\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1508429050445557}
{"question": "What is the shared axes mechanism in matplotlib that ensures sticky edge settings propagate correctly between leader and follower axes when pcolormesh is called on different axes in the sharing relationship?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_sticky_shared_axes", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "reshape", "fig_test.add_subplot", "fig_test.add_subplot", "ax1.pcolormesh", "fig_ref.add_subplot", "fig_ref.add_subplot", "ax0.pcolormesh", "np.arange"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 671, "end_line": 682}, "code_snippet": "def test_sticky_shared_axes(fig_test, fig_ref):\n    # Check that sticky edges work whether they are set in an Axes that is a\n    # \"leader\" in a share, or an Axes that is a \"follower\".\n    Z = np.arange(15).reshape(3, 5)\n\n    ax0 = fig_test.add_subplot(211)\n    ax1 = fig_test.add_subplot(212, sharex=ax0)\n    ax1.pcolormesh(Z)\n\n    ax0 = fig_ref.add_subplot(212)\n    ax1 = fig_ref.add_subplot(211, sharex=ax0)\n    ax0.pcolormesh(Z)\n", "type": "function"}, {"name": "test_pcolormesh", "is_method": true, "class_name": "TestDatetimePlotting", "parameters": ["self"], "calls": ["pytest.mark.xfail", "mpl.style.context", "plt.subplots", "ax.pcolormesh"], "code_location": {"file": "test_datetime.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 631, "end_line": 633}, "code_snippet": "    def test_pcolormesh(self):\n        fig, ax = plt.subplots()\n        ax.pcolormesh(...)\n", "type": "function"}, {"name": "test_shared_axes_autoscale", "is_method": false, "class_name": null, "parameters": [], "calls": ["np.arange", "np.random.random_sample", "plt.subplots", "ax1.set_xlim", "ax1.set_ylim", "ax1.contour", "ax2.contour", "ax1.get_xlim", "ax2.get_xlim", "ax1.get_ylim", "ax2.get_ylim", "ax1.get_autoscalex_on", "ax2.get_autoscalex_on", "ax1.get_autoscaley_on", "ax2.get_autoscaley_on"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 7273, "end_line": 7287}, "code_snippet": "def test_shared_axes_autoscale():\n    l = np.arange(-80, 90, 40)\n    t = np.random.random_sample((l.size, l.size))\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, sharey=True)\n\n    ax1.set_xlim(-1000, 1000)\n    ax1.set_ylim(-1000, 1000)\n    ax1.contour(l, l, t)\n\n    ax2.contour(l, l, t)\n    assert not ax1.get_autoscalex_on() and not ax2.get_autoscalex_on()\n    assert not ax1.get_autoscaley_on() and not ax2.get_autoscaley_on()\n    assert ax1.get_xlim() == ax2.get_xlim() == (-1000, 1000)\n    assert ax1.get_ylim() == ax2.get_ylim() == (-1000, 1000)\n", "type": "function"}, {"name": "test_shared", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pickle.loads", "set_xlim", "pickle.dumps", "get_xlim"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 261, "end_line": 265}, "code_snippet": "def test_shared():\n    fig, axs = plt.subplots(2, sharex=True)\n    fig = pickle.loads(pickle.dumps(fig))\n    fig.axes[0].set_xlim(10, 20)\n    assert fig.axes[1].get_xlim() == (10, 20)\n", "type": "function"}, {"name": "test_remove_shared_axes_relim", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "get_xlim", "ax.remove", "ax.set_xlim", "assert_array_equal", "get_xlim"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 7264, "end_line": 7270}, "code_snippet": "def test_remove_shared_axes_relim():\n    fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n    ax = ax_lst[0][0]\n    orig_xlim = ax_lst[0][1].get_xlim()\n    ax.remove()\n    ax.set_xlim(0, 5)\n    assert_array_equal(ax_lst[0][1].get_xlim(), orig_xlim)\n", "type": "function"}, {"name": "test_colorbar_no_warning_rcparams_grid_true", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.grid", "ax.pcolormesh", "fig.colorbar"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1104, "end_line": 1113}, "code_snippet": "def test_colorbar_no_warning_rcparams_grid_true():\n    # github issue #21723 - If mpl style has 'axes.grid' = True,\n    # fig.colorbar raises a warning about Auto-removal of grids\n    # by pcolor() and pcolormesh(). This is fixed by PR #22216.\n    plt.rcParams['axes.grid'] = True\n    fig, ax = plt.subplots()\n    ax.grid(False)\n    im = ax.pcolormesh([0, 1], [0, 1], [[1]])\n    # make sure that no warning is raised by fig.colorbar\n    fig.colorbar(im)\n", "type": "function"}, {"name": "test_pcolorauto", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref", "snap"], "calls": ["pytest.mark.parametrize", "check_figures_equal", "fig_test.subplots", "np.arange", "np.arange", "np.random.seed", "np.random.randn", "ax.pcolormesh", "fig_ref.subplots", "ax.pcolormesh", "np.diff", "np.diff"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1735, "end_line": 1749}, "code_snippet": "def test_pcolorauto(fig_test, fig_ref, snap):\n    ax = fig_test.subplots()\n    x = np.arange(0, 10)\n    y = np.arange(0, 4)\n    np.random.seed(19680801)\n    Z = np.random.randn(3, 9)\n    # this is the same as flat; note that auto is default\n    ax.pcolormesh(x, y, Z, snap=snap)\n\n    ax = fig_ref.subplots()\n    # specify the centers\n    x2 = x[:-1] + np.diff(x) / 2\n    y2 = y[:-1] + np.diff(y) / 2\n    # this is same as nearest:\n    ax.pcolormesh(x2, y2, Z, snap=snap)\n", "type": "function"}, {"name": "test_shared_axes_retick", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_subplot", "fig.add_subplot", "ax1.plot", "ax2.plot", "ax1.set_zticks", "ax1.get_zlim", "ax2.get_zlim"], "code_location": {"file": "test_axes3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d/tests", "start_line": 1883, "end_line": 1892}, "code_snippet": "def test_shared_axes_retick():\n    fig = plt.figure()\n    ax1 = fig.add_subplot(211, projection=\"3d\")\n    ax2 = fig.add_subplot(212, projection=\"3d\", sharez=ax1)\n    ax1.plot([0, 1], [0, 1], [0, 2])\n    ax2.plot([0, 1], [0, 1], [0, 2])\n    ax1.set_zticks([-0.5, 0, 2, 2.5])\n    # check that setting ticks on a shared axis is synchronized\n    assert ax1.get_zlim() == (-0.5, 2.5)\n    assert ax2.get_zlim() == (-0.5, 2.5)\n", "type": "function"}, {"name": "test_shared_axes_retick", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "set_xticks", "set_yticks", "ax.plot", "ax.get_xlim", "get_xlim", "ax.get_ylim", "get_ylim"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 8819, "end_line": 8831}, "code_snippet": "def test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n\n    for ax in axs.flat:\n        ax.plot([0, 2], 'o-')\n\n    axs[0, 0].set_xticks([-0.5, 0, 1, 1.5])  # should affect all axes xlims\n    for ax in axs.flat:\n        assert ax.get_xlim() == axs[0, 0].get_xlim()\n\n    axs[0, 0].set_yticks([-0.5, 0, 2, 2.5])  # should affect all axes ylims\n    for ax in axs.flat:\n        assert ax.get_ylim() == axs[0, 0].get_ylim()\n", "type": "function"}, {"name": "test_shared_polar_keeps_ticklabels", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "fig.canvas.draw", "get_visible", "get_visible", "plt.subplot_mosaic", "fig.canvas.draw", "get_visible", "get_visible"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 413, "end_line": 423}, "code_snippet": "def test_shared_polar_keeps_ticklabels():\n    fig, axs = plt.subplots(\n        2, 2, subplot_kw={\"projection\": \"polar\"}, sharex=True, sharey=True)\n    fig.canvas.draw()\n    assert axs[0, 1].xaxis.majorTicks[0].get_visible()\n    assert axs[0, 1].yaxis.majorTicks[0].get_visible()\n    fig, axs = plt.subplot_mosaic(\n        \"ab\\ncd\", subplot_kw={\"projection\": \"polar\"}, sharex=True, sharey=True)\n    fig.canvas.draw()\n    assert axs[\"b\"].xaxis.majorTicks[0].get_visible()\n    assert axs[\"b\"].yaxis.majorTicks[0].get_visible()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1702601909637451}
{"question": "Why does the LayoutGrid class leverage the kiwisolver constraint system to maintain consistent spatial relationships between parent and child grids while allowing dynamic margin adjustments?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "LayoutGrid", "parameters": ["self", "parent", "parent_pos", "parent_inner", "name", "ncols", "nrows", "h_pad", "w_pad", "width_ratios", "height_ratios"], "calls": ["isinstance", "np.atleast_1d", "np.atleast_1d", "np.empty", "np.empty", "self.reset_margins", "self.add_constraints", "seq_id", "np.ones", "np.ones", "isinstance", "kiwi.Solver", "parent.add_child", "np.zeros", "Variable", "Variable", "range", "np.empty", "np.zeros", "Variable", "Variable", "range", "range", "range", "Variable", "sol.addEditVariable", "range", "range", "Variable", "sol.addEditVariable", "range", "range"], "code_location": {"file": "_layoutgrid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 36, "end_line": 103}, "code_snippet": "    def __init__(self, parent=None, parent_pos=(0, 0),\n                 parent_inner=False, name='', ncols=1, nrows=1,\n                 h_pad=None, w_pad=None, width_ratios=None,\n                 height_ratios=None):\n        Variable = kiwi.Variable\n        self.parent_pos = parent_pos\n        self.parent_inner = parent_inner\n        self.name = name + seq_id()\n        if isinstance(parent, LayoutGrid):\n            self.name = f'{parent.name}.{self.name}'\n        self.nrows = nrows\n        self.ncols = ncols\n        self.height_ratios = np.atleast_1d(height_ratios)\n        if height_ratios is None:\n            self.height_ratios = np.ones(nrows)\n        self.width_ratios = np.atleast_1d(width_ratios)\n        if width_ratios is None:\n            self.width_ratios = np.ones(ncols)\n\n        sn = self.name + '_'\n        if not isinstance(parent, LayoutGrid):\n            # parent can be a rect if not a LayoutGrid\n            # allows specifying a rectangle to contain the layout.\n            self.solver = kiwi.Solver()\n        else:\n            parent.add_child(self, *parent_pos)\n            self.solver = parent.solver\n        # keep track of artist associated w/ this layout.  Can be none\n        self.artists = np.empty((nrows, ncols), dtype=object)\n        self.children = np.empty((nrows, ncols), dtype=object)\n\n        self.margins = {}\n        self.margin_vals = {}\n        # all the boxes in each column share the same left/right margins:\n        for todo in ['left', 'right', 'leftcb', 'rightcb']:\n            # track the value so we can change only if a margin is larger\n            # than the current value\n            self.margin_vals[todo] = np.zeros(ncols)\n\n        sol = self.solver\n\n        self.lefts = [Variable(f'{sn}lefts[{i}]') for i in range(ncols)]\n        self.rights = [Variable(f'{sn}rights[{i}]') for i in range(ncols)]\n        for todo in ['left', 'right', 'leftcb', 'rightcb']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(ncols)]\n            for i in range(ncols):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = np.empty((nrows), dtype=object)\n            self.margin_vals[todo] = np.zeros(nrows)\n\n        self.bottoms = [Variable(f'{sn}bottoms[{i}]') for i in range(nrows)]\n        self.tops = [Variable(f'{sn}tops[{i}]') for i in range(nrows)]\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(nrows)]\n            for i in range(nrows):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        # set these margins to zero by default. They will be edited as\n        # children are filled.\n        self.reset_margins()\n        self.add_constraints(parent)\n\n        self.h_pad = h_pad\n        self.w_pad = w_pad\n", "type": "function"}, {"name": "parent_constraints", "is_method": true, "class_name": "LayoutGrid", "parameters": ["self", "parent"], "calls": ["isinstance", "np.atleast_1d", "np.atleast_1d", "self.solver.addConstraint"], "code_location": {"file": "_layoutgrid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 168, "end_line": 206}, "code_snippet": "    def parent_constraints(self, parent):\n        # constraints that are due to the parent...\n        # i.e. the first column's left is equal to the\n        # parent's left, the last column right equal to the\n        # parent's right...\n        if not isinstance(parent, LayoutGrid):\n            # specify a rectangle in figure coordinates\n            hc = [self.lefts[0] == parent[0],\n                  self.rights[-1] == parent[0] + parent[2],\n                  # top and bottom reversed order...\n                  self.tops[0] == parent[1] + parent[3],\n                  self.bottoms[-1] == parent[1]]\n        else:\n            rows, cols = self.parent_pos\n            rows = np.atleast_1d(rows)\n            cols = np.atleast_1d(cols)\n\n            left = parent.lefts[cols[0]]\n            right = parent.rights[cols[-1]]\n            top = parent.tops[rows[0]]\n            bottom = parent.bottoms[rows[-1]]\n            if self.parent_inner:\n                # the layout grid is contained inside the inner\n                # grid of the parent.\n                left += parent.margins['left'][cols[0]]\n                left += parent.margins['leftcb'][cols[0]]\n                right -= parent.margins['right'][cols[-1]]\n                right -= parent.margins['rightcb'][cols[-1]]\n                top -= parent.margins['top'][rows[0]]\n                top -= parent.margins['topcb'][rows[0]]\n                bottom += parent.margins['bottom'][rows[-1]]\n                bottom += parent.margins['bottomcb'][rows[-1]]\n            hc = [self.lefts[0] == left,\n                  self.rights[-1] == right,\n                  # from top to bottom\n                  self.tops[0] == top,\n                  self.bottoms[-1] == bottom]\n        for c in hc:\n            self.solver.addConstraint(c | 'required')\n", "type": "function"}, {"name": "grid_constraints", "is_method": true, "class_name": "LayoutGrid", "parameters": ["self"], "calls": ["range", "range", "self.solver.addConstraint", "self.solver.addConstraint", "self.solver.addConstraint", "self.solver.addConstraint"], "code_location": {"file": "_layoutgrid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 208, "end_line": 245}, "code_snippet": "    def grid_constraints(self):\n        # constrain the ratio of the inner part of the grids\n        # to be the same (relative to width_ratios)\n\n        # constrain widths:\n        w = (self.rights[0] - self.margins['right'][0] -\n             self.margins['rightcb'][0])\n        w = (w - self.lefts[0] - self.margins['left'][0] -\n             self.margins['leftcb'][0])\n        w0 = w / self.width_ratios[0]\n        # from left to right\n        for i in range(1, self.ncols):\n            w = (self.rights[i] - self.margins['right'][i] -\n                 self.margins['rightcb'][i])\n            w = (w - self.lefts[i] - self.margins['left'][i] -\n                 self.margins['leftcb'][i])\n            c = (w == w0 * self.width_ratios[i])\n            self.solver.addConstraint(c | 'strong')\n            # constrain the grid cells to be directly next to each other.\n            c = (self.rights[i - 1] == self.lefts[i])\n            self.solver.addConstraint(c | 'strong')\n\n        # constrain heights:\n        h = self.tops[0] - self.margins['top'][0] - self.margins['topcb'][0]\n        h = (h - self.bottoms[0] - self.margins['bottom'][0] -\n             self.margins['bottomcb'][0])\n        h0 = h / self.height_ratios[0]\n        # from top to bottom:\n        for i in range(1, self.nrows):\n            h = (self.tops[i] - self.margins['top'][i] -\n                 self.margins['topcb'][i])\n            h = (h - self.bottoms[i] - self.margins['bottom'][i] -\n                 self.margins['bottomcb'][i])\n            c = (h == h0 * self.height_ratios[i])\n            self.solver.addConstraint(c | 'strong')\n            # constrain the grid cells to be directly above each other.\n            c = (self.bottoms[i - 1] == self.tops[i])\n            self.solver.addConstraint(c | 'strong')\n", "type": "function"}, {"name": "make_layoutgrids", "is_method": false, "class_name": null, "parameters": ["fig", "layoutgrids", "rect"], "calls": ["dict", "hasattr", "mlayoutgrid.LayoutGrid", "fig._subplotspec.get_gridspec", "make_layoutgrids_gs", "mlayoutgrid.LayoutGrid", "make_layoutgrids", "ax.get_gridspec", "make_layoutgrids_gs"], "code_location": {"file": "_constrained_layout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 156, "end_line": 198}, "code_snippet": "def make_layoutgrids(fig, layoutgrids, rect=(0, 0, 1, 1)):\n    \"\"\"\n    Make the layoutgrid tree.\n\n    (Sub)Figures get a layoutgrid so we can have figure margins.\n\n    Gridspecs that are attached to Axes get a layoutgrid so Axes\n    can have margins.\n    \"\"\"\n\n    if layoutgrids is None:\n        layoutgrids = dict()\n        layoutgrids['hasgrids'] = False\n    if not hasattr(fig, '_parent'):\n        # top figure;  pass rect as parent to allow user-specified\n        # margins\n        layoutgrids[fig] = mlayoutgrid.LayoutGrid(parent=rect, name='figlb')\n    else:\n        # subfigure\n        gs = fig._subplotspec.get_gridspec()\n        # it is possible the gridspec containing this subfigure hasn't\n        # been added to the tree yet:\n        layoutgrids = make_layoutgrids_gs(layoutgrids, gs)\n        # add the layoutgrid for the subfigure:\n        parentlb = layoutgrids[gs]\n        layoutgrids[fig] = mlayoutgrid.LayoutGrid(\n            parent=parentlb,\n            name='panellb',\n            parent_inner=True,\n            nrows=1, ncols=1,\n            parent_pos=(fig._subplotspec.rowspan,\n                        fig._subplotspec.colspan))\n    # recursively do all subfigures in this figure...\n    for sfig in fig.subfigs:\n        layoutgrids = make_layoutgrids(sfig, layoutgrids)\n\n    # for each Axes at the local level add its gridspec:\n    for ax in fig._localaxes:\n        gs = ax.get_gridspec()\n        if gs is not None:\n            layoutgrids = make_layoutgrids_gs(layoutgrids, gs)\n\n    return layoutgrids\n", "type": "function"}, {"name": "LayoutGrid", "docstring": "Analogous to a gridspec, and contained in another LayoutGrid.", "methods": ["__init__", "__repr__", "reset_margins", "add_constraints", "hard_constraints", "add_child", "parent_constraints", "grid_constraints", "edit_margin", "edit_margin_min", "edit_margins", "edit_all_margins_min", "edit_outer_margin_mins", "get_margins", "get_outer_bbox", "get_inner_bbox", "get_bbox_for_cb", "get_left_margin_bbox", "get_bottom_margin_bbox", "get_right_margin_bbox", "get_top_margin_bbox", "update_variables"], "attributes": [], "code_location": {"file": "_layoutgrid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 31, "end_line": 490}, "type": "class"}, {"name": "add_constraints", "is_method": true, "class_name": "LayoutGrid", "parameters": ["self", "parent"], "calls": ["self.hard_constraints", "self.parent_constraints", "self.grid_constraints"], "code_location": {"file": "_layoutgrid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 130, "end_line": 137}, "code_snippet": "    def add_constraints(self, parent):\n        # define self-consistent constraints\n        self.hard_constraints()\n        # define relationship with parent layoutgrid:\n        self.parent_constraints(parent)\n        # define relative widths of the grid cells to each other\n        # and stack horizontally and vertically.\n        self.grid_constraints()\n", "type": "function"}, {"name": "match_submerged_margins", "is_method": false, "class_name": null, "parameters": ["layoutgrids", "fig"], "calls": ["match_submerged_margins", "ax1.get_subplotspec", "fig.get_axes", "ss1.get_gridspec", "axs.remove", "ss1.get_gridspec", "len", "np.max", "np.max", "len", "np.max", "np.max", "a.get_in_layout", "ax2.get_subplotspec", "lg1.edit_margin_min", "lg1.edit_margin_min", "ax2.get_subplotspec", "lg1.edit_margin_min", "lg1.edit_margin_min", "a.get_subplotspec", "ss2.get_gridspec", "np.max", "np.max", "ss2.get_gridspec", "len", "len", "np.max", "np.max", "np.max", "np.max"], "code_location": {"file": "_constrained_layout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 499, "end_line": 597}, "code_snippet": "def match_submerged_margins(layoutgrids, fig):\n    \"\"\"\n    Make the margins that are submerged inside an Axes the same size.\n\n    This allows Axes that span two columns (or rows) that are offset\n    from one another to have the same size.\n\n    This gives the proper layout for something like::\n        fig = plt.figure(constrained_layout=True)\n        axs = fig.subplot_mosaic(\"AAAB\\nCCDD\")\n\n    Without this routine, the Axes D will be wider than C, because the\n    margin width between the two columns in C has no width by default,\n    whereas the margins between the two columns of D are set by the\n    width of the margin between A and B. However, obviously the user would\n    like C and D to be the same size, so we need to add constraints to these\n    \"submerged\" margins.\n\n    This routine makes all the interior margins the same, and the spacing\n    between the three columns in A and the two column in C are all set to the\n    margins between the two columns of D.\n\n    See test_constrained_layout::test_constrained_layout12 for an example.\n    \"\"\"\n\n    axsdone = []\n    for sfig in fig.subfigs:\n        axsdone += match_submerged_margins(layoutgrids, sfig)\n\n    axs = [a for a in fig.get_axes()\n           if (a.get_subplotspec() is not None and a.get_in_layout() and\n               a not in axsdone)]\n\n    for ax1 in axs:\n        ss1 = ax1.get_subplotspec()\n        if ss1.get_gridspec() not in layoutgrids:\n            axs.remove(ax1)\n            continue\n        lg1 = layoutgrids[ss1.get_gridspec()]\n\n        # interior columns:\n        if len(ss1.colspan) > 1:\n            maxsubl = np.max(\n                lg1.margin_vals['left'][ss1.colspan[1:]] +\n                lg1.margin_vals['leftcb'][ss1.colspan[1:]]\n            )\n            maxsubr = np.max(\n                lg1.margin_vals['right'][ss1.colspan[:-1]] +\n                lg1.margin_vals['rightcb'][ss1.colspan[:-1]]\n            )\n            for ax2 in axs:\n                ss2 = ax2.get_subplotspec()\n                lg2 = layoutgrids[ss2.get_gridspec()]\n                if lg2 is not None and len(ss2.colspan) > 1:\n                    maxsubl2 = np.max(\n                        lg2.margin_vals['left'][ss2.colspan[1:]] +\n                        lg2.margin_vals['leftcb'][ss2.colspan[1:]])\n                    if maxsubl2 > maxsubl:\n                        maxsubl = maxsubl2\n                    maxsubr2 = np.max(\n                        lg2.margin_vals['right'][ss2.colspan[:-1]] +\n                        lg2.margin_vals['rightcb'][ss2.colspan[:-1]])\n                    if maxsubr2 > maxsubr:\n                        maxsubr = maxsubr2\n            for i in ss1.colspan[1:]:\n                lg1.edit_margin_min('left', maxsubl, cell=i)\n            for i in ss1.colspan[:-1]:\n                lg1.edit_margin_min('right', maxsubr, cell=i)\n\n        # interior rows:\n        if len(ss1.rowspan) > 1:\n            maxsubt = np.max(\n                lg1.margin_vals['top'][ss1.rowspan[1:]] +\n                lg1.margin_vals['topcb'][ss1.rowspan[1:]]\n            )\n            maxsubb = np.max(\n                lg1.margin_vals['bottom'][ss1.rowspan[:-1]] +\n                lg1.margin_vals['bottomcb'][ss1.rowspan[:-1]]\n            )\n\n            for ax2 in axs:\n                ss2 = ax2.get_subplotspec()\n                lg2 = layoutgrids[ss2.get_gridspec()]\n                if lg2 is not None:\n                    if len(ss2.rowspan) > 1:\n                        maxsubt = np.max([np.max(\n                            lg2.margin_vals['top'][ss2.rowspan[1:]] +\n                            lg2.margin_vals['topcb'][ss2.rowspan[1:]]\n                        ), maxsubt])\n                        maxsubb = np.max([np.max(\n                            lg2.margin_vals['bottom'][ss2.rowspan[:-1]] +\n                            lg2.margin_vals['bottomcb'][ss2.rowspan[:-1]]\n                        ), maxsubb])\n            for i in ss1.rowspan[1:]:\n                lg1.edit_margin_min('top', maxsubt, cell=i)\n            for i in ss1.rowspan[:-1]:\n                lg1.edit_margin_min('bottom', maxsubb, cell=i)\n\n    return axs\n", "type": "function"}, {"name": "do_constrained_layout", "is_method": false, "class_name": null, "parameters": ["fig", "h_pad", "w_pad", "hspace", "wspace", "rect", "compress"], "calls": ["fig._get_renderer", "make_layoutgrids", "range", "_api.warn_external", "make_layout_margins", "make_margin_suptitles", "match_submerged_margins", "update_variables", "check_no_collapsed_axes", "reset_margins", "reposition_axes", "_api.warn_external", "compress_fixed_aspect", "update_variables", "check_no_collapsed_axes", "reposition_axes", "_api.warn_external", "suptitle.get_in_layout", "suptitle.get_position", "suptitle.set_position", "suptitle.set_verticalalignment", "get_inner_bbox"], "code_location": {"file": "_constrained_layout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 63, "end_line": 153}, "code_snippet": "def do_constrained_layout(fig, h_pad, w_pad,\n                          hspace=None, wspace=None, rect=(0, 0, 1, 1),\n                          compress=False):\n    \"\"\"\n    Do the constrained_layout.  Called at draw time in\n     ``figure.constrained_layout()``\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        `.Figure` instance to do the layout in.\n\n    h_pad, w_pad : float\n      Padding around the Axes elements in figure-normalized units.\n\n    hspace, wspace : float\n       Fraction of the figure to dedicate to space between the\n       Axes.  These are evenly spread between the gaps between the Axes.\n       A value of 0.2 for a three-column layout would have a space\n       of 0.1 of the figure width between each column.\n       If h/wspace < h/w_pad, then the pads are used instead.\n\n    rect : tuple of 4 floats\n        Rectangle in figure coordinates to perform constrained layout in\n        [left, bottom, width, height], each from 0-1.\n\n    compress : bool\n        Whether to shift Axes so that white space in between them is\n        removed. This is useful for simple grids of fixed-aspect Axes (e.g.\n        a grid of images).\n\n    Returns\n    -------\n    layoutgrid : private debugging structure\n    \"\"\"\n\n    renderer = fig._get_renderer()\n    # make layoutgrid tree...\n    layoutgrids = make_layoutgrids(fig, None, rect=rect)\n    if not layoutgrids['hasgrids']:\n        _api.warn_external('There are no gridspecs with layoutgrids. '\n                           'Possibly did not call parent GridSpec with the'\n                           ' \"figure\" keyword')\n        return\n\n    for _ in range(2):\n        # do the algorithm twice.  This has to be done because decorations\n        # change size after the first re-position (i.e. x/yticklabels get\n        # larger/smaller).  This second reposition tends to be much milder,\n        # so doing twice makes things work OK.\n\n        # make margins for all the Axes and subfigures in the\n        # figure.  Add margins for colorbars...\n        make_layout_margins(layoutgrids, fig, renderer, h_pad=h_pad,\n                            w_pad=w_pad, hspace=hspace, wspace=wspace)\n        make_margin_suptitles(layoutgrids, fig, renderer, h_pad=h_pad,\n                              w_pad=w_pad)\n\n        # if a layout is such that a columns (or rows) margin has no\n        # constraints, we need to make all such instances in the grid\n        # match in margin size.\n        match_submerged_margins(layoutgrids, fig)\n\n        # update all the variables in the layout.\n        layoutgrids[fig].update_variables()\n\n        warn_collapsed = ('constrained_layout not applied because '\n                          'axes sizes collapsed to zero.  Try making '\n                          'figure larger or Axes decorations smaller.')\n        if check_no_collapsed_axes(layoutgrids, fig):\n            reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                            w_pad=w_pad, hspace=hspace, wspace=wspace)\n            if compress:\n                layoutgrids = compress_fixed_aspect(layoutgrids, fig)\n                layoutgrids[fig].update_variables()\n                if check_no_collapsed_axes(layoutgrids, fig):\n                    reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                                    w_pad=w_pad, hspace=hspace, wspace=wspace)\n                else:\n                    _api.warn_external(warn_collapsed)\n\n                if ((suptitle := fig._suptitle) is not None and\n                        suptitle.get_in_layout() and suptitle._autopos):\n                    x, _ = suptitle.get_position()\n                    suptitle.set_position(\n                        (x, layoutgrids[fig].get_inner_bbox().y1 + h_pad))\n                    suptitle.set_verticalalignment('bottom')\n        else:\n            _api.warn_external(warn_collapsed)\n        reset_margins(layoutgrids, fig)\n    return layoutgrids\n", "type": "function"}, {"name": "make_layoutgrids_gs", "is_method": false, "class_name": null, "parameters": ["layoutgrids", "gs"], "calls": ["hasattr", "mlayoutgrid.LayoutGrid", "subplot_spec.get_gridspec", "mlayoutgrid.LayoutGrid", "make_layoutgrids_gs", "mlayoutgrid.LayoutGrid", "gs.get_width_ratios", "gs.get_height_ratios", "gs.get_width_ratios", "gs.get_height_ratios"], "code_location": {"file": "_constrained_layout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 201, "end_line": 244}, "code_snippet": "def make_layoutgrids_gs(layoutgrids, gs):\n    \"\"\"\n    Make the layoutgrid for a gridspec (and anything nested in the gridspec)\n    \"\"\"\n\n    if gs in layoutgrids or gs.figure is None:\n        return layoutgrids\n    # in order to do constrained_layout there has to be at least *one*\n    # gridspec in the tree:\n    layoutgrids['hasgrids'] = True\n    if not hasattr(gs, '_subplot_spec'):\n        # normal gridspec\n        parent = layoutgrids[gs.figure]\n        layoutgrids[gs] = mlayoutgrid.LayoutGrid(\n                parent=parent,\n                parent_inner=True,\n                name='gridspec',\n                ncols=gs._ncols, nrows=gs._nrows,\n                width_ratios=gs.get_width_ratios(),\n                height_ratios=gs.get_height_ratios())\n    else:\n        # this is a gridspecfromsubplotspec:\n        subplot_spec = gs._subplot_spec\n        parentgs = subplot_spec.get_gridspec()\n        # if a nested gridspec it is possible the parent is not in there yet:\n        if parentgs not in layoutgrids:\n            layoutgrids = make_layoutgrids_gs(layoutgrids, parentgs)\n        subspeclb = layoutgrids[parentgs]\n        # gridspecfromsubplotspec need an outer container:\n        # get a unique representation:\n        rep = (gs, 'top')\n        if rep not in layoutgrids:\n            layoutgrids[rep] = mlayoutgrid.LayoutGrid(\n                parent=subspeclb,\n                name='top',\n                nrows=1, ncols=1,\n                parent_pos=(subplot_spec.rowspan, subplot_spec.colspan))\n        layoutgrids[gs] = mlayoutgrid.LayoutGrid(\n                parent=layoutgrids[rep],\n                name='gridspec',\n                nrows=gs._nrows, ncols=gs._ncols,\n                width_ratios=gs.get_width_ratios(),\n                height_ratios=gs.get_height_ratios())\n    return layoutgrids\n", "type": "function"}, {"name": "ConstrainedLayoutEngine", "docstring": "Implements the ``constrained_layout`` geometry management.  See\n:ref:`constrainedlayout_guide` for details.", "methods": ["__init__", "execute", "set"], "attributes": ["_adjust_compatible", "_colorbar_gridspec"], "code_location": {"file": "layout_engine.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 216, "end_line": 309}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1239712238311768}
{"question": "How should the `contains` method in `OffsetBox` be refactored to decouple the canvas validation logic from the child delegation logic while maintaining testability of each responsibility?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "contains", "is_method": true, "class_name": "OffsetBox", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "self.get_children", "c.contains"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 241, "end_line": 271}, "code_snippet": "    def contains(self, mouseevent):\n        \"\"\"\n        Delegate the mouse event contains-check to the children.\n\n        As a container, the `.OffsetBox` does not respond itself to\n        mouseevents.\n\n        Parameters\n        ----------\n        mouseevent : `~matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n\n        See Also\n        --------\n        .Artist.contains\n        \"\"\"\n        if self._different_canvas(mouseevent):\n            return False, {}\n        for c in self.get_children():\n            a, b = c.contains(mouseevent)\n            if a:\n                return a, b\n        return False, {}\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "AnnotationBbox", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "self.offsetbox.contains", "self._check_xy"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1368, "end_line": 1373}, "code_snippet": "    def contains(self, mouseevent):\n        if self._different_canvas(mouseevent):\n            return False, {}\n        if not self._check_xy(None):\n            return False, {}\n        return self.offsetbox.contains(mouseevent)\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "Pad", "parameters": ["self", "loc"], "calls": ["contains", "self.disp.get_bbox"], "code_location": {"file": "pong_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/event_handling", "start_line": 65, "end_line": 66}, "code_snippet": "    def contains(self, loc):\n        return self.disp.get_bbox().contains(loc.x, loc.y)\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "YAxis", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "self.axes.transAxes.transform", "self.axes.transAxes.inverted", "trans.transform"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2643, "end_line": 2657}, "code_snippet": "    def contains(self, mouseevent):\n        # docstring inherited\n        if self._different_canvas(mouseevent):\n            return False, {}\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform((x, y))\n        except ValueError:\n            return False, {}\n        (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n        inaxis = 0 <= yaxes <= 1 and (\n            l - self._pickradius < x < l or\n            r < x < r + self._pickradius)\n        return inaxis, {}\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "QuiverKey", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "self.text.contains", "self.vector.contains"], "code_location": {"file": "quiver.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 420, "end_line": 428}, "code_snippet": "    def contains(self, mouseevent):\n        if self._different_canvas(mouseevent):\n            return False, {}\n        # Maybe the dictionary should allow one to\n        # distinguish between a text hit and a vector hit.\n        if (self.text.contains(mouseevent)[0] or\n                self.vector.contains(mouseevent)[0]):\n            return True, {}\n        return False, {}\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "_AxesBase", "parameters": ["self", "mouseevent"], "calls": ["self.patch.contains"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 4508, "end_line": 4510}, "code_snippet": "    def contains(self, mouseevent):\n        # docstring inherited.\n        return self.patch.contains(mouseevent)\n", "type": "function"}, {"name": "test_contains", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "plt.axes", "MouseEvent", "np.linspace", "np.linspace", "np.meshgrid", "plt.text", "fig.canvas.draw", "zip", "transAxes.transform", "txt.contains", "ax.viewLim.frozen", "ax.plot", "ax.viewLim.set", "plt.gca"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 212, "end_line": 239}, "code_snippet": "def test_contains():\n    fig = plt.figure()\n    ax = plt.axes()\n\n    mevent = MouseEvent('button_press_event', fig.canvas, 0.5, 0.5, 1, None)\n\n    xs = np.linspace(0.25, 0.75, 30)\n    ys = np.linspace(0.25, 0.75, 30)\n    xs, ys = np.meshgrid(xs, ys)\n\n    txt = plt.text(\n        0.5, 0.4, 'hello world', ha='center', fontsize=30, rotation=30)\n    # uncomment to draw the text's bounding box\n    # txt.set_bbox(dict(edgecolor='black', facecolor='none'))\n\n    # draw the text. This is important, as the contains method can only work\n    # when a renderer exists.\n    fig.canvas.draw()\n\n    for x, y in zip(xs.flat, ys.flat):\n        mevent.x, mevent.y = plt.gca().transAxes.transform([x, y])\n        contains, _ = txt.contains(mevent)\n        color = 'yellow' if contains else 'red'\n\n        # capture the viewLim, plot a point, and reset the viewLim\n        vl = ax.viewLim.frozen()\n        ax.plot(x, y, 'o', color=color)\n        ax.viewLim.set(vl)\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "Legend", "parameters": ["self", "mouseevent"], "calls": ["self.legendPatch.contains"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1186, "end_line": 1187}, "code_snippet": "    def contains(self, mouseevent):\n        return self.legendPatch.contains(mouseevent)\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "Annotation", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "Text.contains", "self.arrow_patch.contains"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1899, "end_line": 1906}, "code_snippet": "    def contains(self, mouseevent):\n        if self._different_canvas(mouseevent):\n            return False, {}\n        contains, tinfo = Text.contains(self, mouseevent)\n        if self.arrow_patch is not None:\n            in_patch, _ = self.arrow_patch.contains(mouseevent)\n            contains = contains or in_patch\n        return contains, tinfo\n", "type": "function"}, {"name": "contains", "is_method": true, "class_name": "Table", "parameters": ["self", "mouseevent"], "calls": ["self._different_canvas", "_get_renderer", "Bbox.union", "self.get_figure", "cell.get_window_extent", "bbox.contains", "self._cells.items"], "code_location": {"file": "table.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 430, "end_line": 444}, "code_snippet": "    def contains(self, mouseevent):\n        # docstring inherited\n        if self._different_canvas(mouseevent):\n            return False, {}\n        # TODO: Return index of the cell containing the cursor so that the user\n        # doesn't have to bind to each one individually.\n        renderer = self.get_figure(root=True)._get_renderer()\n        if renderer is not None:\n            boxes = [cell.get_window_extent(renderer)\n                     for (row, col), cell in self._cells.items()\n                     if row >= 0 and col >= 0]\n            bbox = Bbox.union(boxes)\n            return bbox.contains(mouseevent.x, mouseevent.y), {}\n        else:\n            return False, {}\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1446447372436523}
{"question": "Why does the repeated instantiation of CanvasFrame objects within MyApp's OnInit method impact memory allocation and garbage collection overhead in long-running wxPython applications with multiple frame creations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "__init__", "is_method": true, "class_name": "CanvasFrame", "parameters": ["self"], "calls": ["__init__", "Figure", "self.figure.add_subplot", "np.arange", "np.sin", "self.axes.plot", "FigureCanvas", "wx.BoxSizer", "self.sizer.Add", "self.SetSizer", "self.Fit", "self.add_toolbar", "super"], "code_location": {"file": "embedding_in_wx2_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 22, "end_line": 38}, "code_snippet": "    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.add_toolbar()  # comment this out for no toolbar\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "CanvasFrame", "parameters": ["self"], "calls": ["__init__", "Figure", "self.figure.add_subplot", "np.arange", "np.sin", "self.axes.plot", "FigureCanvas", "wx.BoxSizer", "self.sizer.Add", "MyNavigationToolbar", "self.toolbar.Realize", "self.sizer.Add", "self.toolbar.update", "self.SetSizer", "self.Fit", "super"], "code_location": {"file": "embedding_in_wx4_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 42, "end_line": 66}, "code_snippet": "    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure(figsize=(5, 4), dpi=100)\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n\n        self.toolbar = MyNavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n        self.SetSizer(self.sizer)\n        self.Fit()\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "FigureFrameWx", "parameters": ["self", "num", "fig"], "calls": ["__init__", "_log.debug", "_set_frame_icon", "canvas_class", "FigureManagerWx", "map", "self.canvas.SetInitialSize", "self.canvas.SetMinSize", "self.canvas.SetFocus", "self.Fit", "self.Bind", "wx.Point", "type", "self.SetToolBar", "self.FromDIP", "self.FromDIP", "super", "wx.Size", "wx.Size"], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 914, "end_line": 943}, "code_snippet": "    def __init__(self, num, fig, *, canvas_class):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        self.canvas = canvas_class(self, -1, fig)\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(self.FromDIP(wx.Size(w, h)))\n        self.canvas.SetMinSize(self.FromDIP(wx.Size(2, 2)))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)\n", "type": "function"}, {"name": "OnInit", "is_method": true, "class_name": "MyApp", "parameters": ["self"], "calls": ["CanvasFrame", "self.SetTopWindow", "frame.Show"], "code_location": {"file": "mathtext_wx_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 124, "end_line": 128}, "code_snippet": "    def OnInit(self):\n        frame = CanvasFrame(None, \"wxPython mathtext demo app\")\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "CanvasFrame", "parameters": ["self"], "calls": ["__init__", "Figure", "self.figure.add_subplot", "np.arange", "np.sin", "self.axes.plot", "self.axes.set_xlabel", "self.axes.set_ylabel", "FigureCanvas", "self.figure_canvas.mpl_connect", "self.figure_canvas.Bind", "wx.BoxSizer", "self.sizer.Add", "self.SetSizer", "self.Fit", "wx.StatusBar", "self.SetStatusBar", "NavigationToolbar2Wx", "self.sizer.Add", "self.toolbar.Show", "super"], "code_location": {"file": "wxcursor_demo_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 19, "end_line": 47}, "code_snippet": "    def __init__(self, ):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2*np.pi*t)\n\n        self.axes.plot(t, s)\n        self.axes.set_xlabel('t')\n        self.axes.set_ylabel('sin(t)')\n        self.figure_canvas = FigureCanvas(self, -1, self.figure)\n\n        # Note that event is a MplEvent\n        self.figure_canvas.mpl_connect(\n            'motion_notify_event', self.UpdateStatusBar)\n        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.statusBar = wx.StatusBar(self, -1)\n        self.SetStatusBar(self.statusBar)\n\n        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.toolbar.Show()\n", "type": "function"}, {"name": "test_donot_cache_tracebacks", "is_method": false, "class_name": null, "parameters": [], "calls": ["inner", "gc.get_objects", "SomeObject", "mfigure.Figure", "fig.subplots", "fig.text", "isinstance", "BytesIO", "pytest.fail", "warnings.catch_warnings", "warnings.filterwarnings", "fig.savefig"], "code_location": {"file": "test_font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 352, "end_line": 371}, "code_snippet": "def test_donot_cache_tracebacks():\n\n    class SomeObject:\n        pass\n\n    def inner():\n        x = SomeObject()\n        fig = mfigure.Figure()\n        ax = fig.subplots()\n        fig.text(.5, .5, 'aardvark', family='doesnotexist')\n        with BytesIO() as out:\n            with warnings.catch_warnings():\n                warnings.filterwarnings('ignore')\n                fig.savefig(out, format='raw')\n\n    inner()\n\n    for obj in gc.get_objects():\n        if isinstance(obj, SomeObject):\n            pytest.fail(\"object from inner stack still alive\")\n", "type": "function"}, {"name": "OnInit", "is_method": true, "class_name": "App", "parameters": ["self"], "calls": ["CanvasFrame", "frame.Show"], "code_location": {"file": "embedding_in_wx4_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 70, "end_line": 74}, "code_snippet": "    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        frame.Show(True)\n        return True\n", "type": "function"}, {"name": "FigureManagerWx", "docstring": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.\n\nAttributes\n----------\ncanvas : `FigureCanvas`\n    a FigureCanvasWx(wx.Panel) instance\nwindow : wxFrame\n    a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html", "methods": ["__init__", "create_with_canvas", "start_main_loop", "show", "destroy", "full_screen_toggle", "get_window_title", "set_window_title", "resize"], "attributes": [], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 962, "end_line": 1032}, "type": "class"}, {"name": "OnInit", "is_method": true, "class_name": "App", "parameters": ["self"], "calls": ["self.Init", "CanvasFrame", "frame.Show"], "code_location": {"file": "embedding_in_wx2_sgskip.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/user_interfaces", "start_line": 53, "end_line": 59}, "code_snippet": "    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        self.Init()\n        frame = CanvasFrame()\n        frame.Show(True)\n\n        return True\n", "type": "function"}, {"name": "test_canvas_reinit", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "plt.subplots", "FigureCanvasQTAgg", "fig.canvas.draw_idle"], "code_location": {"file": "test_backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 285, "end_line": 300}, "code_snippet": "def test_canvas_reinit():\n    from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg\n\n    called = False\n\n    def crashing_callback(fig, stale):\n        nonlocal called\n        fig.canvas.draw_idle()\n        called = True\n\n    fig, ax = plt.subplots()\n    fig.stale_callback = crashing_callback\n    # this should not raise\n    canvas = FigureCanvasQTAgg(fig)\n    fig.stale = True\n    assert called\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1458842754364014}
{"question": "Why would using a singleton pattern versus repeatedly instantiating the _Unset class throughout matplotlib's codebase impact memory overhead in scenarios with thousands of default parameter checks?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_set_markercolor", "is_method": true, "class_name": "Line2D", "parameters": ["self", "name", "has_rcdefault", "val"], "calls": ["getattr", "setattr", "isinstance", "neq.any"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1205, "end_line": 1217}, "code_snippet": "    def _set_markercolor(self, name, has_rcdefault, val):\n        if val is None:\n            val = mpl.rcParams[f\"lines.{name}\"] if has_rcdefault else \"auto\"\n        attr = f\"_{name}\"\n        current = getattr(self, attr)\n        if current is None:\n            self.stale = True\n        else:\n            neq = current != val\n            # Much faster than `np.any(current != val)` if no arrays are used.\n            if neq.any() if isinstance(neq, np.ndarray) else neq:\n                self.stale = True\n        setattr(self, attr, val)\n", "type": "function"}, {"name": "_get_default_antialiased", "is_method": true, "class_name": "LineCollection", "parameters": ["self"], "calls": [], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1778, "end_line": 1779}, "code_snippet": "    def _get_default_antialiased(self):\n        return mpl.rcParams['lines.antialiased']\n", "type": "function"}, {"name": "_get_default_antialiased", "is_method": true, "class_name": "Collection", "parameters": ["self"], "calls": [], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 807, "end_line": 809}, "code_snippet": "    def _get_default_antialiased(self):\n        # This may be overridden in a subclass.\n        return mpl.rcParams['patch.antialiased']\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "GraphicsContextBase", "parameters": ["self"], "calls": ["CapStyle", "JoinStyle"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 696, "end_line": 714}, "code_snippet": "    def __init__(self):\n        self._alpha = 1.0\n        self._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        self._antialiased = 1  # use 0, 1 not True, False for extension code\n        self._capstyle = CapStyle('butt')\n        self._cliprect = None\n        self._clippath = None\n        self._dashes = 0, None\n        self._joinstyle = JoinStyle('round')\n        self._linestyle = 'solid'\n        self._linewidth = 1\n        self._rgb = (0.0, 0.0, 0.0, 1.0)\n        self._hatch = None\n        self._hatch_color = None\n        self._hatch_linewidth = rcParams['hatch.linewidth']\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = None\n", "type": "function"}, {"name": "MarkerStyle", "docstring": "A class representing marker types.\n\nInstances are immutable. If you need to change anything, create a new\ninstance.\n\nAttributes\n----------\nmarkers : dict\n    All known markers.\nfilled_markers : tuple\n    All known filled markers. This is a subset of *markers*.\nfillstyles : tuple\n    The supported fillstyles.", "methods": ["__init__", "_recache", "__bool__", "is_filled", "get_fillstyle", "_set_fillstyle", "get_joinstyle", "get_capstyle", "get_marker", "_set_marker", "get_path", "get_transform", "get_alt_path", "get_alt_transform", "get_snap_threshold", "get_user_transform", "transformed", "rotated", "scaled", "_set_nothing", "_set_custom_marker", "_set_path_marker", "_set_vertices", "_set_tuple_marker", "_set_mathtext_path", "_half_fill", "_set_circle", "_set_point", "_set_pixel", "_set_triangle", "_set_triangle_up", "_set_triangle_down", "_set_triangle_left", "_set_triangle_right", "_set_square", "_set_diamond", "_set_thin_diamond", "_set_pentagon", "_set_star", "_set_hexagon1", "_set_hexagon2", "_set_octagon", "_set_vline", "_set_hline", "_set_tickleft", "_set_tickright", "_set_tickup", "_set_tickdown", "_set_tri_down", "_set_tri_up", "_set_tri_left", "_set_tri_right", "_set_caretdown", "_set_caretup", "_set_caretleft", "_set_caretright", "_set_caretdownbase", "_set_caretupbase", "_set_caretleftbase", "_set_caretrightbase", "_set_plus", "_set_x", "_set_plus_filled", "_set_x_filled"], "attributes": ["markers", "filled_markers", "fillstyles", "_half_fillstyles", "_triangle_path", "_triangle_path_u", "_triangle_path_d", "_triangle_path_l", "_triangle_path_r", "_line_marker_path", "_tickhoriz_path", "_tickvert_path", "_tri_path", "_caret_path", "_caret_path_base", "_plus_path", "_x_path", "_plus_filled_path", "_plus_filled_path_t", "_x_filled_path", "_x_filled_path_t"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 150, "end_line": 907}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "value_formatter", "parameters": ["self", "value"], "calls": ["isinstance", "repr", "type"], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 82, "end_line": 95}, "code_snippet": "    def __init__(self, value):\n        if value is mlab.detrend_none:\n            self._repr = \"mlab.detrend_none\"\n        elif value is mlab.window_hanning:\n            self._repr = \"mlab.window_hanning\"\n        elif value is np.mean:\n            self._repr = \"np.mean\"\n        elif value is _api.deprecation._deprecated_parameter:\n            self._repr = \"_api.deprecation._deprecated_parameter\"\n        elif isinstance(value, Enum):\n            # Enum str is Class.Name whereas their repr is <Class.Name: value>.\n            self._repr = f'{type(value).__name__}.{value.name}'\n        else:\n            self._repr = repr(value)\n", "type": "function"}, {"name": "_get_default_linewidth", "is_method": true, "class_name": "Collection", "parameters": ["self"], "calls": [], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 645, "end_line": 647}, "code_snippet": "    def _get_default_linewidth(self):\n        # This may be overridden in a subclass.\n        return mpl.rcParams['patch.linewidth']  # validated as float\n", "type": "function"}, {"name": "__init_subclass__", "is_method": true, "class_name": "_AxesBase", "parameters": ["cls"], "calls": ["__init_subclass__", "super", "_api.warn_deprecated", "super"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 770, "end_line": 782}, "code_snippet": "    def __init_subclass__(cls, **kwargs):\n        parent_uses_cla = super(cls, cls)._subclass_uses_cla\n        if 'cla' in cls.__dict__:\n            _api.warn_deprecated(\n                '3.6',\n                pending=True,\n                message=f'Overriding `Axes.cla` in {cls.__qualname__} is '\n                'pending deprecation in %(since)s and will be fully '\n                'deprecated in favor of `Axes.clear` in the future. '\n                'Please report '\n                f'this to the {cls.__module__!r} author.')\n        cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla\n        super().__init_subclass__(**kwargs)\n", "type": "function"}, {"name": "test_default_antialiased", "is_method": false, "class_name": null, "parameters": [], "calls": ["Patch", "patch.set_antialiased", "patch.set_antialiased", "patch.get_antialiased", "patch.get_antialiased"], "code_location": {"file": "test_patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 893, "end_line": 900}, "code_snippet": "def test_default_antialiased():\n    patch = Patch()\n\n    patch.set_antialiased(not rcParams['patch.antialiased'])\n    assert patch.get_antialiased() == (not rcParams['patch.antialiased'])\n    # Check that None resets the state\n    patch.set_antialiased(None)\n    assert patch.get_antialiased() == rcParams['patch.antialiased']\n", "type": "function"}, {"name": "value_formatter", "docstring": "Format function default values as needed for inspect.formatargspec.\nThe interesting part is a hard-coded list of functions used\nas defaults in pyplot methods.", "methods": ["__init__", "__repr__"], "attributes": [], "code_location": {"file": "boilerplate.py", "path": "/data3/pwh/swebench-repos/matplotlib/tools", "start_line": 75, "end_line": 98}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.157489538192749}
{"question": "Why does the ParserState class use a property decorator for the font attribute instead of direct attribute access, and how does this design choice enable the coupling between font and font_class state management?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "ParserState", "docstring": "Parser state.\n\nStates are pushed and popped from a stack as necessary, and the \"current\"\nstate is always at the top of the stack.\n\nUpon entering and leaving a group { } or math/non-math, the stack is pushed\nand popped accordingly.", "methods": ["__init__", "copy", "font", "font", "get_current_underline_thickness"], "attributes": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1744, "end_line": 1779}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "Rule", "parameters": ["self", "width", "height", "depth", "state"], "calls": ["__init__", "super"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1397, "end_line": 1399}, "code_snippet": "    def __init__(self, width: float, height: float, depth: float, state: ParserState):\n        super().__init__(width, height, depth)\n        self.fontset = state.fontset\n", "type": "function"}, {"name": "_get_font_constant_set", "is_method": false, "class_name": null, "parameters": ["state"], "calls": ["_font_constant_mapping.get", "isinstance", "state.fontset._get_font"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 999, "end_line": 1007}, "code_snippet": "def _get_font_constant_set(state: ParserState) -> type[FontConstantsBase]:\n    constants = _font_constant_mapping.get(\n        state.fontset._get_font(state.font).family_name, FontConstantsBase)\n    # STIX sans isn't really its own fonts, just different code points\n    # in the STIX fonts, so we have to detect this one separately.\n    if (constants is STIXFontConstants and\n            isinstance(state.fontset, StixSansFonts)):\n        return STIXSansFontConstants\n    return constants\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Char", "parameters": ["self", "c", "state"], "calls": ["__init__", "self._update_metrics", "super"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1081, "end_line": 1091}, "code_snippet": "    def __init__(self, c: str, state: ParserState):\n        super().__init__()\n        self.c = c\n        self.fontset = state.fontset\n        self.font = state.font\n        self.font_class = state.font_class\n        self.fontsize = state.fontsize\n        self.dpi = state.dpi\n        # The real width, height and depth will be set during the\n        # pack phase, after we know the real fontsize\n        self._update_metrics()\n", "type": "function"}, {"name": "FontEntry", "docstring": "A class for storing Font properties.\n\nIt is used when populating the font lookup dictionary.", "methods": ["_repr_html_", "_repr_png_"], "attributes": [], "code_location": {"file": "font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 314, "end_line": 341}, "type": "class"}, {"name": "FontInfo", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 211, "end_line": 218}, "type": "class"}, {"name": "font", "is_method": true, "class_name": "Parser", "parameters": ["self", "toks"], "calls": ["self.get_state"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2417, "end_line": 2419}, "code_snippet": "    def font(self, toks: ParseResults) -> T.Any:\n        self.get_state().font = toks[\"font\"]\n        return []\n", "type": "function"}, {"name": "FontProperties", "docstring": "A class for storing and manipulating font properties.\n\nThe font properties are the six properties described in the\n`W3C Cascading Style Sheet, Level 1\n<http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ font\nspecification and *math_fontfamily* for math fonts:\n\n- family: A list of font names in decreasing order of priority.\n  The items may include a generic font family name, either 'sans-serif',\n  'serif', 'cursive', 'fantasy', or 'monospace'.  In that case, the actual\n  font to be used will be looked up from the associated rcParam during the\n  search process in `.findfont`. Default: :rc:`font.family`\n\n- style: Either 'normal', 'italic' or 'oblique'.\n  Default: :rc:`font.style`\n\n- variant: Either 'normal' or 'small-caps'.\n  Default: :rc:`font.variant`\n\n- stretch: A numeric value in the range 0-1000 or one of\n  'ultra-condensed', 'extra-condensed', 'condensed',\n  'semi-condensed', 'normal', 'semi-expanded', 'expanded',\n  'extra-expanded' or 'ultra-expanded'. Default: :rc:`font.stretch`\n\n- weight: A numeric value in the range 0-1000 or one of\n  'ultralight', 'light', 'normal', 'regular', 'book', 'medium',\n  'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy',\n  'extra bold', 'black'. Default: :rc:`font.weight`\n\n- size: Either a relative value of 'xx-small', 'x-small',\n  'small', 'medium', 'large', 'x-large', 'xx-large' or an\n  absolute font size, e.g., 10. Default: :rc:`font.size`\n\n- math_fontfamily: The family of fonts used to render math text.\n  Supported values are: 'dejavusans', 'dejavuserif', 'cm',\n  'stix', 'stixsans' and 'custom'. Default: :rc:`mathtext.fontset`\n\nAlternatively, a font may be specified using the absolute path to a font\nfile, by using the *fname* kwarg.  However, in this case, it is typically\nsimpler to just pass the path (as a `pathlib.Path`, not a `str`) to the\n*font* kwarg of the `.Text` object.\n\nThe preferred usage of font sizes is to use the relative values,\ne.g.,  'large', instead of absolute font sizes, e.g., 12.  This\napproach allows all text sizes to be made larger or smaller based\non the font manager's default font size.\n\nThis class accepts a single positional string as fontconfig_ pattern_,\nor alternatively individual properties as keyword arguments::\n\n    FontProperties(pattern)\n    FontProperties(*, family=None, style=None, variant=None, ...)\n\nThis support does not depend on fontconfig; we are merely borrowing its\npattern syntax for use here.\n\n.. _fontconfig: https://www.freedesktop.org/wiki/Software/fontconfig/\n.. _pattern:\n   https://www.freedesktop.org/software/fontconfig/fontconfig-user.html\n\nNote that Matplotlib's internal font manager and fontconfig use a\ndifferent algorithm to lookup fonts, so the results of the same pattern\nmay be different in Matplotlib than in other applications that use\nfontconfig.", "methods": ["__init__", "_from_any", "__hash__", "__eq__", "__str__", "get_family", "get_name", "get_style", "get_variant", "get_weight", "get_stretch", "get_size", "get_file", "get_fontconfig_pattern", "set_family", "set_style", "set_variant", "set_weight", "set_stretch", "set_size", "set_file", "set_fontconfig_pattern", "get_math_fontfamily", "set_math_fontfamily", "copy"], "attributes": ["set_name", "get_slant", "set_slant", "get_size_in_points"], "code_location": {"file": "font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 592, "end_line": 967}, "type": "class"}, {"name": "font", "is_method": true, "class_name": "ParserState", "parameters": ["self", "name"], "calls": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1771, "end_line": 1774}, "code_snippet": "    def font(self, name: str) -> None:\n        if name in ('rm', 'it', 'bf', 'bfit'):\n            self.font_class = name\n        self._font = name\n", "type": "function"}, {"name": "FontLayout", "docstring": "Font selection", "methods": ["__init__", "get_font"], "attributes": [], "code_location": {"file": "_formlayout.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends/qt_editor", "start_line": 163, "end_line": 202}, "type": "class"}], "retrieved_count": 10, "cost_time": 1.1767652034759521}
{"question": "Why does the FigureCanvasPS class reconcile the dual rendering pathways between _print_figure and _print_figure_tex to maintain consistent PostScript output quality while accommodating both standard and TeX-based text rendering modes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_print_figure_tex", "is_method": true, "class_name": "FigureCanvasPS", "parameters": ["self", "fmt", "outfile"], "calls": ["self.figure.get_size_inches", "StringIO", "RendererPS", "MixedModeRenderer", "self.figure.draw", "TemporaryDirectory", "pathlib.Path", "tmppath.write_text", "_convert_psfrags", "_move_path_to_path_or_stream", "orientation.swap_if_landscape", "_try_distill", "self.figure.get_size_inches", "_try_distill", "_get_bbox_header", "len", "join", "_nums_to_str", "_nums_to_str", "self._pswriter.getvalue"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1131, "end_line": 1216}, "code_snippet": "    def _print_figure_tex(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n                                     bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{_get_bbox_header(bbox)}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)\n", "type": "function"}, {"name": "_print_ps", "is_method": true, "class_name": "FigureCanvasPS", "parameters": ["self", "fmt", "outfile"], "calls": ["isinstance", "get", "os.getenv", "join", "papertype.lower", "_api.check_in_list", "_api.check_getitem", "printer", "decode", "strftime", "time.ctime", "pathlib.Path", "orientation.lower", "filename.encode", "datetime.datetime.fromtimestamp", "dsc_comments.items", "int"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 960, "end_line": 1000}, "code_snippet": "    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "RendererPS", "parameters": ["self", "width", "height", "pswriter", "imagedpi"], "calls": ["__init__", "_backend_pdf_ps.CharacterTracker", "functools.cache", "super"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 406, "end_line": 431}, "code_snippet": "    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and then scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self._logwarn_once = functools.cache(_log.warning)\n", "type": "function"}, {"name": "draw_tex", "is_method": true, "class_name": "RendererPS", "parameters": ["self", "gc", "x", "y", "s", "prop", "angle"], "calls": ["self._is_transparent", "self.get_text_width_height_descent", "prop.get_size_in_points", "_nums_to_str", "get", "np.radians", "_nums_to_str", "self.psfrag.append", "self._pswriter.write", "gc.get_rgb", "hasattr", "self._logwarn_once", "self.draw_text", "gc.get_rgb", "np.cos", "np.sin"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 720, "end_line": 759}, "code_snippet": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = _nums_to_str(*gc.get_rgb()[:3], sep=',')\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to bottom-left alignment, so subtract descent from the text-normal\n        # direction since text is normally positioned by its baseline.\n        rangle = np.radians(angle + 90)\n        pos = _nums_to_str(x - bl * np.cos(rangle), y - bl * np.sin(rangle))\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1\n", "type": "function"}, {"name": "_print_figure", "is_method": true, "class_name": "FigureCanvasPS", "parameters": ["self", "fmt", "outfile"], "calls": ["self.figure.get_size_inches", "StringIO", "RendererPS", "MixedModeRenderer", "self.figure.draw", "ValueError", "orientation.swap_if_landscape", "print", "len", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "fh.flush", "isinstance", "is_writable_file_like", "print", "print", "print", "len", "join", "ps_renderer._character_tracker.used.items", "print", "print", "self._pswriter.getvalue", "print", "TemporaryDirectory", "os.path.join", "_move_path_to_path_or_stream", "cbook.open_file_cm", "print_figure_impl", "print", "fh.flush", "_nums_to_str", "open", "print_figure_impl", "_try_distill", "file_requires_unicode", "_get_bbox_header", "len", "fh.write", "_font_to_ps_type42", "_nums_to_str", "_try_distill", "codecs.getwriter", "_font_to_ps_type3"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1002, "end_line": 1129}, "code_snippet": "    def _print_figure(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is a\n        string containing Document Structuring Convention comments,\n        generated from the *metadata* parameter to `.print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n        if not (isinstance(outfile, (str, os.PathLike))\n                or is_writable_file_like(outfile)):\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if is_eps or papertype == 'figure':\n            paper_width, paper_height = width, height\n        else:\n            paper_width, paper_height = orientation.swap_if_landscape(\n                papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(\"%!PS-Adobe-3.0\", file=fh)\n                if papertype != 'figure':\n                    print(f\"%%DocumentPaperSizes: {papertype}\", file=fh)\n                print(\"%%Pages: 1\", file=fh)\n            print(f\"%%LanguageLevel: 3\\n\"\n                  f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{_get_bbox_header(bbox)}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(_psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(_psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(f\"0 0 {_nums_to_str(width*72, height*72)} rectclip\", file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:  # Write directly to outfile.\n            with cbook.open_file_cm(outfile, \"w\", encoding=\"latin-1\") as file:\n                if not file_requires_unicode(file):\n                    file = codecs.getwriter(\"latin-1\")(file)\n                print_figure_impl(file)\n", "type": "function"}, {"name": "test_partial_usetex", "is_method": false, "class_name": null, "parameters": ["caplog"], "calls": ["caplog.set_level", "plt.figtext", "plt.figtext", "plt.savefig", "io.BytesIO", "record.getMessage"], "code_location": {"file": "test_backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 191, "end_line": 197}, "code_snippet": "def test_partial_usetex(caplog):\n    caplog.set_level(\"WARNING\")\n    plt.figtext(.1, .1, \"foo\", usetex=True)\n    plt.figtext(.2, .2, \"bar\", usetex=True)\n    plt.savefig(io.BytesIO(), format=\"ps\")\n    record, = caplog.records  # asserts there's a single record.\n    assert \"as if usetex=False\" in record.getMessage()\n", "type": "function"}, {"name": "test_single_artist_usenotex", "is_method": false, "class_name": null, "parameters": ["fmt"], "calls": ["pytest.mark.parametrize", "plt.figure", "fig.text", "fig.savefig", "io.BytesIO"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 619, "end_line": 627}, "code_snippet": "def test_single_artist_usenotex(fmt):\n    # Check that a single artist can be marked as not-usetex even though the\n    # rcParam is on (\"2_2_2\" fails if passed to TeX).  This currently skips\n    # postscript output as the ps renderer doesn't support mixing usetex and\n    # non-usetex.\n    plt.rcParams[\"text.usetex\"] = True\n    fig = plt.figure()\n    fig.text(.5, .5, \"2_2_2\", usetex=False)\n    fig.savefig(io.BytesIO(), format=fmt)\n", "type": "function"}, {"name": "xpdf_distill", "is_method": false, "class_name": null, "parameters": ["tmpfile", "eps", "ptype", "bbox", "rotated"], "calls": ["mpl._get_executable_info", "mpl._get_executable_info", "TemporaryDirectory", "pathlib.Path", "pathlib.Path", "cbook._check_and_log_subprocess", "cbook._check_and_log_subprocess", "shutil.move", "pstoeps"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1321, "end_line": 1359}, "code_snippet": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    if eps:\n        paper_option = [\"-dEPSCrop\"]\n    elif ptype == \"figure\":\n        # The bbox will have its lower-left corner at (0, 0), so upper-right\n        # corner corresponds with paper size.\n        paper_option = [f\"-dDEVICEWIDTHPOINTS#{bbox[2]}\",\n                        f\"-dDEVICEHEIGHTPOINTS#{bbox[3]}\"]\n    else:\n        paper_option = [f\"-sPAPERSIZE#{ptype}\"]\n\n    with TemporaryDirectory() as tmpdir:\n        tmppdf = pathlib.Path(tmpdir, \"tmp.pdf\")\n        tmpps = pathlib.Path(tmpdir, \"tmp.ps\")\n        # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows\n        # happy (https://ghostscript.com/doc/9.56.1/Use.htm#MS_Windows).\n        cbook._check_and_log_subprocess(\n            [\"ps2pdf\",\n             \"-dAutoFilterColorImages#false\",\n             \"-dAutoFilterGrayImages#false\",\n             \"-sAutoRotatePages#None\",\n             \"-sGrayImageFilter#FlateEncode\",\n             \"-sColorImageFilter#FlateEncode\",\n             *paper_option,\n             tmpfile, tmppdf], _log)\n        cbook._check_and_log_subprocess(\n            [\"pdftops\", \"-paper\", \"match\", \"-level3\", tmppdf, tmpps], _log)\n        shutil.move(tmpps, tmpfile)\n    if eps:\n        pstoeps(tmpfile)\n", "type": "function"}, {"name": "draw_text", "is_method": true, "class_name": "RendererPS", "parameters": ["self", "gc", "x", "y", "s", "prop", "angle", "ismath", "mtext"], "calls": ["self._is_transparent", "self.set_color", "itertools.groupby", "gc.get_rgb", "self.draw_tex", "self.draw_mathtext", "self._get_font_afm", "decode", "self._get_font_ttf", "self._character_tracker.track", "_text_helpers.layout", "self.set_font", "join", "self._pswriter.write", "prop.get_size_in_points", "uni2type1.get", "font.get_kern_dist_from_name", "stream.append", "decode", "item.ft_object.get_glyph_name", "stream.append", "gc.get_rgb", "prop.get_size_in_points", "font.postscript_name.encode", "ord", "font.get_width_from_char_name", "font.get_width_char", "item.ft_object.postscript_name.encode", "self._get_clip_cmd", "ord", "ord"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 762, "end_line": 818}, "code_snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        stream = []  # list of (ps_name, x, char_name)\n\n        if mpl.rcParams['ps.useafm']:\n            font = self._get_font_afm(prop)\n            ps_name = (font.postscript_name.encode(\"ascii\", \"replace\")\n                        .decode(\"ascii\"))\n            scale = 0.001 * prop.get_size_in_points()\n            thisx = 0\n            last_name = None  # kerns returns 0 for None.\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char(ord('?'))\n                kern = font.get_kern_dist_from_name(last_name, name)\n                last_name = name\n                thisx += kern * scale\n                stream.append((ps_name, thisx, name))\n                thisx += width * scale\n\n        else:\n            font = self._get_font_ttf(prop)\n            self._character_tracker.track(font, s)\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                glyph_name = item.ft_object.get_glyph_name(item.glyph_idx)\n                stream.append((ps_name, item.x, glyph_name))\n        self.set_color(*gc.get_rgb())\n\n        for ps_name, group in itertools. \\\n                groupby(stream, lambda entry: entry[0]):\n            self.set_font(ps_name, prop.get_size_in_points(), False)\n            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n                                for _, x, name in group)\n            self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n{angle:g} rotate\n{thetext}\ngrestore\n\"\"\")\n", "type": "function"}, {"name": "draw_tex", "is_method": true, "class_name": "RendererPdf", "parameters": ["self", "gc", "x", "y", "s", "prop", "angle"], "calls": ["self.get_texmanager", "prop.get_size_in_points", "texmanager.make_dvi", "translate", "self.check_gc", "self.file.output", "self.file.output", "self.new_gc", "boxgc.copy_properties", "boxgc.set_linewidth", "dviread.Dvi", "gc.get_url", "append", "self.file._character_tracker.track", "Path", "self.draw_path", "_get_link_annotation", "self.file.dviFontName", "chr", "len", "rotate_deg", "self.file.output", "mytrans.transform", "self._setup_textpos", "bytes", "abs", "Affine2D", "len", "self.file.output", "self.file.output"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 2271, "end_line": 2353}, "code_snippet": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, page.width, page.height, angle))\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one single-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n            self.file._character_tracker.track(dvifont, chr(glyph))\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1713135242462158}
{"question": "Why does the _update_glyph_map_defs method scale glyph vertices by 64 before path conversion and then apply a 1/64 scale transform in the SVG output?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_update_glyph_map_defs", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "glyph_map_new"], "calls": ["writer.start", "glyph_map_new.items", "writer.end", "self._glyph_map.update", "self._adjust_char_id", "self._convert_path", "writer.element", "Path", "_generate_transform"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1018, "end_line": 1035}, "code_snippet": "    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                # x64 to go back to FreeType's internal (integral) units.\n                path_data = self._convert_path(\n                    Path(vertices * 64, codes), simplify=False)\n                writer.element(\n                    'path', id=char_id, d=path_data,\n                    transform=_generate_transform([('scale', (1 / 64,))]))\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n", "type": "function"}, {"name": "_get_pdf_charprocs", "is_method": false, "class_name": null, "parameters": ["font_path", "glyph_ids"], "calls": ["get_font", "font.load_glyph", "astype", "font.get_path", "astype", "np.nonzero", "np.array", "astype", "astype", "sorted", "all", "font.get_glyph_name", "_path.convert_to_string", "encode", "Path", "np.array", "astype", "join", "map"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 614, "end_line": 657}, "code_snippet": "def _get_pdf_charprocs(font_path, glyph_ids):\n    font = get_font(font_path, hinting_factor=1)\n    conv = 1000 / font.units_per_EM  # Conversion to PS units (1/1000's).\n    procs = {}\n    for glyph_id in glyph_ids:\n        g = font.load_glyph(glyph_id, LoadFlags.NO_SCALE)\n        # NOTE: We should be using round(), but instead use\n        # \"(x+.5).astype(int)\" to keep backcompat with the old ttconv code\n        # (this is different for negative x's).\n        d1 = (np.array([g.horiAdvance, 0, *g.bbox]) * conv + .5).astype(int)\n        v, c = font.get_path()\n        v = (v * 64).astype(int)  # Back to TrueType's internal units (1/64's).\n        # Backcompat with old ttconv code: control points between two quads are\n        # omitted if they are exactly at the midpoint between the control of\n        # the quad before and the quad after, but ttconv used to interpolate\n        # *after* conversion to PS units, causing floating point errors.  Here\n        # we reproduce ttconv's logic, detecting these \"implicit\" points and\n        # re-interpolating them.  Note that occasionally (e.g. with DejaVu Sans\n        # glyph \"0\") a point detected as \"implicit\" is actually explicit, and\n        # will thus be shifted by 1.\n        quads, = np.nonzero(c == 3)\n        quads_on = quads[1::2]\n        quads_mid_on = np.array(\n            sorted({*quads_on} & {*(quads - 1)} & {*(quads + 1)}), int)\n        implicit = quads_mid_on[\n            (v[quads_mid_on]  # As above, use astype(int), not // division\n             == ((v[quads_mid_on - 1] + v[quads_mid_on + 1]) / 2).astype(int))\n            .all(axis=1)]\n        if (font.postscript_name, glyph_id) in [\n                (\"DejaVuSerif-Italic\", 77),  # j\n                (\"DejaVuSerif-Italic\", 135),  # \\AA\n        ]:\n            v[:, 0] -= 1  # Hard-coded backcompat (FreeType shifts glyph by 1).\n        v = (v * conv + .5).astype(int)  # As above re: truncation vs rounding.\n        v[implicit] = ((  # Fix implicit points; again, truncate.\n            (v[implicit - 1] + v[implicit + 1]) / 2).astype(int))\n        procs[font.get_glyph_name(glyph_id)] = (\n            \" \".join(map(str, d1)).encode(\"ascii\") + b\" d1\\n\"\n            + _path.convert_to_string(\n                Path(v, c), None, None, False, None, -1,\n                # no code for quad Beziers triggers auto-conversion to cubics.\n                [b\"m\", b\"l\", b\"\", b\"c\", b\"h\"], True)\n            + b\"f\")\n    return procs\n", "type": "function"}, {"name": "_revalidate_path", "is_method": true, "class_name": "TextPath", "parameters": ["self"], "calls": ["translate", "tr.transform", "scale", "Affine2D"], "code_location": {"file": "textpath.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 358, "end_line": 371}, "code_snippet": "    def _revalidate_path(self):\n        \"\"\"\n        Update the path if necessary.\n\n        The path for the text is initially create with the font size of\n        `.FONT_SCALE`, and this path is rescaled to other size when necessary.\n        \"\"\"\n        if self._invalid or self._cached_vertices is None:\n            tr = (Affine2D()\n                  .scale(self._size / text_to_path.FONT_SCALE)\n                  .translate(*self._xy))\n            self._cached_vertices = tr.transform(self._vertices)\n            self._cached_vertices.flags.writeable = False\n            self._invalid = False\n", "type": "function"}, {"name": "get_glyphs_with_font", "is_method": true, "class_name": "TextToPath", "parameters": ["self", "font", "s", "glyph_map", "return_new_glyphs_only"], "calls": ["_text_helpers.layout", "OrderedDict", "OrderedDict", "self._get_char_id", "glyph_ids.append", "xpositions.append", "len", "len", "list", "ord", "item.ft_object.get_path", "zip"], "code_location": {"file": "textpath.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 132, "end_line": 161}, "code_snippet": "    def get_glyphs_with_font(self, font, s, glyph_map=None,\n                             return_new_glyphs_only=False):\n        \"\"\"\n        Convert string *s* to vertices and codes using the provided ttf font.\n        \"\"\"\n\n        if glyph_map is None:\n            glyph_map = OrderedDict()\n\n        if return_new_glyphs_only:\n            glyph_map_new = OrderedDict()\n        else:\n            glyph_map_new = glyph_map\n\n        xpositions = []\n        glyph_ids = []\n        for item in _text_helpers.layout(s, font):\n            char_id = self._get_char_id(item.ft_object, ord(item.char))\n            glyph_ids.append(char_id)\n            xpositions.append(item.x)\n            if char_id not in glyph_map:\n                glyph_map_new[char_id] = item.ft_object.get_path()\n\n        ypositions = [0] * len(xpositions)\n        sizes = [1.] * len(xpositions)\n\n        rects = []\n\n        return (list(zip(glyph_ids, xpositions, ypositions, sizes)),\n                glyph_map_new, rects)\n", "type": "function"}, {"name": "_convert_path", "is_method": true, "class_name": "RendererPS", "parameters": ["self", "path", "transform", "clip", "simplify"], "calls": ["decode", "_path.convert_to_string"], "code_location": {"file": "backend_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 547, "end_line": 554}, "code_snippet": "    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n", "type": "function"}, {"name": "_convert_path", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "path", "transform", "clip", "simplify", "sketch"], "calls": ["decode", "_path.convert_to_string"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 667, "end_line": 675}, "code_snippet": "    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n", "type": "function"}, {"name": "_index_dvi_to_freetype", "is_method": true, "class_name": "DviFont", "parameters": ["self", "idx"], "calls": ["font_manager.get_font", "PsfontsMap", "ValueError", "face._get_type1_encoding_vector", "find_tex_file", "format", "face.get_name_index", "psfont.psname.decode", "psfont.texname.decode", "_parse_enc"], "code_location": {"file": "dviread.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 657, "end_line": 682}, "code_snippet": "    def _index_dvi_to_freetype(self, idx):\n        \"\"\"Convert dvi glyph indices to FreeType ones.\"\"\"\n        # Glyphs indices stored in the dvi file map to FreeType glyph indices\n        # (i.e., which can be passed to FT_Load_Glyph) in various ways:\n        # - if pdftex.map specifies an \".enc\" file for the font, that file maps\n        #   dvi indices to Adobe glyph names, which can then be converted to\n        #   FreeType glyph indices with FT_Get_Name_Index.\n        # - if no \".enc\" file is specified, then the font must be a Type 1\n        #   font, and dvi indices directly index into the font's CharStrings\n        #   vector.\n        # - (xetex & luatex, currently unsupported, can also declare \"native\n        #   fonts\", for which dvi indices are equal to FreeType indices.)\n        if self._encoding is None:\n            psfont = PsfontsMap(find_tex_file(\"pdftex.map\"))[self.texname]\n            if psfont.filename is None:\n                raise ValueError(\"No usable font file found for {} ({}); \"\n                                 \"the font may lack a Type-1 version\"\n                                 .format(psfont.psname.decode(\"ascii\"),\n                                         psfont.texname.decode(\"ascii\")))\n            face = font_manager.get_font(psfont.filename)\n            if psfont.encoding:\n                self._encoding = [face.get_name_index(name)\n                                  for name in _parse_enc(psfont.encoding)]\n            else:\n                self._encoding = face._get_type1_encoding_vector()\n        return self._encoding[idx]\n", "type": "function"}, {"name": "_update_values", "is_method": true, "class_name": "Path", "parameters": ["self"], "calls": ["len", "np.all"], "code_location": {"file": "path.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 201, "end_line": 208}, "code_snippet": "    def _update_values(self):\n        self._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n        self._should_simplify = (\n            self._simplify_threshold > 0 and\n            mpl.rcParams['path.simplify'] and\n            len(self._vertices) >= 128 and\n            (self._codes is None or np.all(self._codes <= Path.LINETO))\n        )\n", "type": "function"}, {"name": "_set_vertices", "is_method": true, "class_name": "MarkerStyle", "parameters": ["self"], "calls": ["self._set_custom_marker", "Path"], "code_location": {"file": "markers.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 459, "end_line": 460}, "code_snippet": "    def _set_vertices(self):\n        self._set_custom_marker(Path(self._marker))\n", "type": "function"}, {"name": "test_ft2font_get_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["fm.findfont", "ft2font.FT2Font", "font.get_path", "font.load_char", "font.get_path", "np.array", "np.testing.assert_array_equal", "np.full", "np.testing.assert_array_equal", "ord"], "code_location": {"file": "test_ft2font.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 832, "end_line": 857}, "code_snippet": "def test_ft2font_get_path():\n    file = fm.findfont('DejaVu Sans')\n    font = ft2font.FT2Font(file, hinting_factor=1, _kerning_factor=0)\n    vertices, codes = font.get_path()\n    assert vertices.shape == (0, 2)\n    assert codes.shape == (0, )\n    font.load_char(ord('M'))\n    vertices, codes = font.get_path()\n    expected_vertices = np.array([\n        (0.843750, 9.000000), (2.609375, 9.000000),  # Top left.\n        (4.906250, 2.875000),  # Top of midpoint.\n        (7.218750, 9.000000), (8.968750, 9.000000),  # Top right.\n        (8.968750, 0.000000), (7.843750, 0.000000),  # Bottom right.\n        (7.843750, 7.906250),  # Point under top right.\n        (5.531250, 1.734375), (4.296875, 1.734375),  # Bar under midpoint.\n        (1.984375, 7.906250),  # Point under top left.\n        (1.984375, 0.000000), (0.843750, 0.000000),  # Bottom left.\n        (0.843750, 9.000000),  # Back to top left corner.\n        (0.000000, 0.000000),\n    ])\n    np.testing.assert_array_equal(vertices, expected_vertices)\n    expected_codes = np.full(expected_vertices.shape[0], mpath.Path.LINETO,\n                             dtype=mpath.Path.code_type)\n    expected_codes[0] = mpath.Path.MOVETO\n    expected_codes[-1] = mpath.Path.CLOSEPOLY\n    np.testing.assert_array_equal(codes, expected_codes)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.173546552658081}
{"question": "How does the draw method orchestrate the sequence of bbox computation, frame updates, offset calculation, and child rendering to maintain consistency between the patch frame and the positioned child element?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "draw", "is_method": true, "class_name": "PaddedBox", "parameters": ["self", "renderer"], "calls": ["self._get_bbox_and_child_offsets", "self.get_offset", "zip", "self.draw_frame", "self.get_visible_children", "self.get_visible_children", "c.set_offset", "c.draw"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 571, "end_line": 583}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n\n        self.draw_frame(renderer)\n\n        for c in self.get_visible_children():\n            c.draw(renderer)\n\n        self.stale = False\n", "type": "function"}, {"name": "draw_frame", "is_method": true, "class_name": "PaddedBox", "parameters": ["self", "renderer"], "calls": ["self.update_frame", "self.patch.draw", "self.get_window_extent"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 591, "end_line": 594}, "code_snippet": "    def draw_frame(self, renderer):\n        # update the location and size of the legend\n        self.update_frame(self.get_window_extent(renderer))\n        self.patch.draw(renderer)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "PathClippedImagePatch", "parameters": ["self", "renderer"], "calls": ["self.bbox_image.set_clip_path", "self.bbox_image.draw", "draw", "self.get_transform", "super"], "code_location": {"file": "demo_text_path.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/text_labels_and_annotations", "start_line": 40, "end_line": 44}, "code_snippet": "    def draw(self, renderer=None):\n        # the clip path must be updated every draw. any solution? -JJ\n        self.bbox_image.set_clip_path(self._path, self.get_transform())\n        self.bbox_image.draw(renderer)\n        super().draw(renderer)\n", "type": "function"}, {"name": "update_frame", "is_method": true, "class_name": "PaddedBox", "parameters": ["self", "bbox", "fontsize"], "calls": ["self.patch.set_bounds", "self.patch.set_mutation_scale"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 585, "end_line": 589}, "code_snippet": "    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n        self.stale = True\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self", "renderer"], "calls": ["self.get_window_extent", "renderer.points_to_pixels", "self.update_frame", "self.patch.draw", "self.get_offset", "set_offset", "draw", "self.get_visible", "self.prop.get_size_in_points", "self.get_bbox", "self.get_child", "self.get_child"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1085, "end_line": 1099}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n\n        # update the location and size of the legend\n        bbox = self.get_window_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self.update_frame(bbox, fontsize)\n        self.patch.draw(renderer)\n\n        px, py = self.get_offset(self.get_bbox(renderer), renderer)\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False\n", "type": "function"}, {"name": "blit", "is_method": true, "class_name": "FigureCanvasMac", "parameters": ["self", "bbox"], "calls": ["blit", "self.update", "super"], "code_location": {"file": "backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 95, "end_line": 98}, "code_snippet": "    def blit(self, bbox=None):\n        # docstring inherited\n        super().blit(bbox)\n        self.update()\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "Path3DCollection", "parameters": ["self", "renderer"], "calls": ["self._use_zordered_offset", "cbook._setattr_cm", "draw", "super"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 903, "end_line": 906}, "code_snippet": "    def draw(self, renderer):\n        with self._use_zordered_offset():\n            with cbook._setattr_cm(self, _in_draw=True):\n                super().draw(renderer)\n", "type": "function"}, {"name": "update_frame", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self", "bbox", "fontsize"], "calls": ["self.patch.set_bounds", "self.patch.set_mutation_scale"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1080, "end_line": 1083}, "code_snippet": "    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n", "type": "function"}, {"name": "get_bbox", "is_method": true, "class_name": "AuxTransformBox", "parameters": ["self", "renderer"], "calls": ["self.offset_transform.get_matrix", "self.ref_offset_transform.clear", "self.offset_transform.clear", "Bbox.union", "self.ref_offset_transform.translate", "self.offset_transform.set_matrix", "Bbox.from_bounds", "c.get_window_extent"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 885, "end_line": 897}, "code_snippet": "    def get_bbox(self, renderer):\n        # clear the offset transforms\n        _off = self.offset_transform.get_matrix()  # to be restored later\n        self.ref_offset_transform.clear()\n        self.offset_transform.clear()\n        # calculate the extent\n        bboxes = [c.get_window_extent(renderer) for c in self._children]\n        ub = Bbox.union(bboxes)\n        # adjust ref_offset_transform\n        self.ref_offset_transform.translate(-ub.x0, -ub.y0)\n        # restore offset transform\n        self.offset_transform.set_matrix(_off)\n        return Bbox.from_bounds(0, 0, ub.width, ub.height)\n", "type": "function"}, {"name": "draw", "is_method": true, "class_name": "AnnotationBbox", "parameters": ["self", "renderer"], "calls": ["renderer.open_group", "self.update_positions", "self.patch.draw", "self.offsetbox.draw", "renderer.close_group", "self.arrow_patch.draw", "self.get_visible", "self._check_xy", "self.get_gid", "self.arrow_patch.set_figure", "self.arrow_patch.get_figure", "self.get_figure"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1454, "end_line": 1468}, "code_snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        renderer.open_group(self.__class__.__name__, gid=self.get_gid())\n        self.update_positions(renderer)\n        if self.arrow_patch is not None:\n            if (self.arrow_patch.get_figure(root=False) is None and\n                    (fig := self.get_figure(root=False)) is not None):\n                self.arrow_patch.set_figure(fig)\n            self.arrow_patch.draw(renderer)\n        self.patch.draw(renderer)\n        self.offsetbox.draw(renderer)\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.1814241409301758}
{"question": "How does the set_bbox_to_anchor method implement polymorphic input handling for bbox parameters of varying types (BboxBase, 2-tuple, 4-tuple) and what validation strategy ensures correctness during coordinate transformation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "set_bbox_to_anchor", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self", "bbox", "transform"], "calls": ["isinstance", "Bbox.from_bounds", "len", "ValueError"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1034, "end_line": 1057}, "code_snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the box is anchored to.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True\n", "type": "function"}, {"name": "set_bbox_to_anchor", "is_method": true, "class_name": "Legend", "parameters": ["self", "bbox", "transform"], "calls": ["TransformedBbox", "isinstance", "BboxTransformTo", "Bbox.from_bounds", "len", "ValueError"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1085, "end_line": 1126}, "code_snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the legend will be anchored to.\n\n        Parameters\n        ----------\n        bbox : `~matplotlib.transforms.BboxBase` or tuple\n            The bounding box can be specified in the following ways:\n\n            - A `.BboxBase` instance\n            - A tuple of ``(left, bottom, width, height)`` in the given\n              transform (normalized axes coordinate if None)\n            - A tuple of ``(left, bottom)`` where the width and height will be\n              assumed to be zero.\n            - *None*, to remove the bbox anchoring, and use the parent bbox.\n\n        transform : `~matplotlib.transforms.Transform`, optional\n            A transform to apply to the bounding box. If not specified, this\n            will use a transform to the bounding box of the parent.\n        \"\"\"\n        if bbox is None:\n            self._bbox_to_anchor = None\n            return\n        elif isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        if transform is None:\n            transform = BboxTransformTo(self.parent.bbox)\n\n        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\n                                               transform)\n        self.stale = True\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AnchoredSizeLocator", "parameters": ["self", "bbox_to_anchor", "x_size", "y_size", "loc", "borderpad", "bbox_transform"], "calls": ["__init__", "Size.from_any", "Size.from_any", "super"], "code_location": {"file": "inset_locator.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 40, "end_line": 48}, "code_snippet": "    def __init__(self, bbox_to_anchor, x_size, y_size, loc,\n                 borderpad=0.5, bbox_transform=None):\n        super().__init__(\n            bbox_to_anchor, None, loc,\n            borderpad=borderpad, bbox_transform=bbox_transform\n        )\n\n        self.x_size = Size.from_any(x_size)\n        self.y_size = Size.from_any(y_size)\n", "type": "function"}, {"name": "_update_bbox_to_anchor", "is_method": true, "class_name": "DraggableLegend", "parameters": ["self", "loc_in_canvas"], "calls": ["self.legend.axes.transAxes.transform", "self.legend.set_bbox_to_anchor"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 93, "end_line": 95}, "code_snippet": "    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "AnchoredLocatorBase", "parameters": ["self", "bbox_to_anchor", "offsetbox", "loc", "borderpad", "bbox_transform"], "calls": ["__init__", "super"], "code_location": {"file": "inset_locator.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 17, "end_line": 22}, "code_snippet": "    def __init__(self, bbox_to_anchor, offsetbox, loc,\n                 borderpad=0.5, bbox_transform=None):\n        super().__init__(\n            loc, pad=0., child=None, borderpad=borderpad,\n            bbox_to_anchor=bbox_to_anchor, bbox_transform=bbox_transform\n        )\n", "type": "function"}, {"name": "get_bbox_to_anchor", "is_method": true, "class_name": "AnchoredOffsetbox", "parameters": ["self"], "calls": ["TransformedBbox"], "code_location": {"file": "offsetbox.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1023, "end_line": 1032}, "code_snippet": "    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor, transform)\n", "type": "function"}, {"name": "_update_loc", "is_method": true, "class_name": "DraggableLegend", "parameters": ["self", "loc_in_canvas"], "calls": ["self.legend.get_bbox_to_anchor", "BboxTransformFrom", "tuple", "self.legend.set_bbox_to_anchor", "self.legend.get_bbox_to_anchor", "_bbox_transform.transform"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 83, "end_line": 91}, "code_snippet": "    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n", "type": "function"}, {"name": "_get_xy_transform", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "coords"], "calls": ["isinstance", "tr.translate", "self._get_xy_transform", "self._get_xy_transform", "blended_transform_factory", "callable", "coords.split", "scale", "coords", "isinstance", "isinstance", "ValueError", "self.get_figure", "self._get_position_xy", "ValueError", "Affine2D", "BboxTransformTo", "isinstance", "coords.get_window_extent", "BboxTransformTo", "isinstance", "PolarAxes.PolarTransform", "self.get_figure", "Affine2D", "scale", "TypeError", "BboxTransformTo", "isinstance", "self.get_figure", "scale", "ValueError", "Affine2D", "isinstance", "TypeError", "self.get_size", "Affine2D", "self.get_figure", "type", "type"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1522, "end_line": 1594}, "code_snippet": "    def _get_xy_transform(self, renderer, coords):\n\n        if isinstance(coords, tuple):\n            xcoord, ycoord = coords\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, xcoord)\n            tr2 = self._get_xy_transform(renderer, ycoord)\n            return blended_transform_factory(tr1, tr2)\n        elif callable(coords):\n            tr = coords(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise TypeError(\n                    f\"xycoords callable must return a BboxBase or Transform, not a \"\n                    f\"{type(tr).__name__}\")\n        elif isinstance(coords, Artist):\n            bbox = coords.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(coords, BboxBase):\n            return BboxTransformTo(coords)\n        elif isinstance(coords, Transform):\n            return coords\n        elif not isinstance(coords, str):\n            raise TypeError(\n                f\"'xycoords' must be an instance of str, tuple[str, str], Artist, \"\n                f\"Transform, or Callable, not a {type(coords).__name__}\")\n\n        if coords == 'data':\n            return self.axes.transData\n        elif coords == 'polar':\n            from matplotlib.projections import PolarAxes\n            return PolarAxes.PolarTransform() + self.axes.transData\n\n        try:\n            bbox_name, unit = coords.split()\n        except ValueError:  # i.e. len(coords.split()) != 2.\n            raise ValueError(f\"{coords!r} is not a valid coordinate\") from None\n\n        bbox0, xy0 = None, None\n\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.get_figure(root=False).figbbox\n        elif bbox_name == \"subfigure\":\n            bbox0 = self.get_figure(root=False).bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n\n        # reference x, y in display coordinate\n        if bbox0 is not None:\n            xy0 = bbox0.p0\n        elif bbox_name == \"offset\":\n            xy0 = self._get_position_xy(renderer)\n        else:\n            raise ValueError(f\"{coords!r} is not a valid coordinate\")\n\n        if unit == \"points\":\n            tr = Affine2D().scale(\n                self.get_figure(root=True).dpi / 72)  # dpi/72 dots per point\n        elif unit == \"pixels\":\n            tr = Affine2D()\n        elif unit == \"fontsize\":\n            tr = Affine2D().scale(\n                self.get_size() * self.get_figure(root=True).dpi / 72)\n        elif unit == \"fraction\":\n            tr = Affine2D().scale(*bbox0.size)\n        else:\n            raise ValueError(f\"{unit!r} is not a recognized unit\")\n\n        return tr.translate(*xy0)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "LockableBbox", "parameters": ["self", "bbox", "x0", "y0", "x1", "y1"], "calls": ["_api.check_isinstance", "__init__", "self.set_children", "reshape", "super", "np.ma.array"], "code_location": {"file": "transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1183, "end_line": 1210}, "code_snippet": "    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1, or None to leave unlocked.\n\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self.set_children(bbox)\n        self._points = None\n        fp = [x0, y0, x1, y1]\n        mask = [val is None for val in fp]\n        self._locked_points = np.ma.array(fp, float, mask=mask).reshape((2, 2))\n", "type": "function"}, {"name": "_get_anchored_bbox", "is_method": true, "class_name": "Legend", "parameters": ["self", "loc", "bbox", "parentbbox", "renderer"], "calls": ["offsetbox._get_anchored_bbox", "renderer.points_to_pixels"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1128, "end_line": 1146}, "code_snippet": "    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\n        \"\"\"\n        Place the *bbox* inside the *parentbbox* according to a given\n        location code. Return the (x, y) coordinate of the bbox.\n\n        Parameters\n        ----------\n        loc : int\n            A location code in range(1, 11). This corresponds to the possible\n            values for ``self._loc``, excluding \"best\".\n        bbox : `~matplotlib.transforms.Bbox`\n            bbox to be placed, in display coordinates.\n        parentbbox : `~matplotlib.transforms.Bbox`\n            A parent box which will contain the bbox, in display coordinates.\n        \"\"\"\n        pad = self.borderaxespad * renderer.points_to_pixels(self._fontsize)\n        return offsetbox._get_anchored_bbox(\n            loc, bbox, parentbbox,\n            pad, pad)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2228996753692627}
{"question": "Why does the exception handling overhead in the get_alpha method's try-except block impact performance when called repeatedly in tight rendering loops, and what optimization strategy would minimize this overhead while preserving the fallback behavior?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "set_alpha", "is_method": true, "class_name": "GraphicsContextCairo", "parameters": ["self", "alpha"], "calls": ["set_alpha", "_set_rgba", "self.get_alpha", "self.get_forced_alpha", "super"], "code_location": {"file": "backend_cairo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 332, "end_line": 335}, "code_snippet": "    def set_alpha(self, alpha):\n        super().set_alpha(alpha)\n        _set_rgba(\n            self.ctx, self._rgb, self.get_alpha(), self.get_forced_alpha())\n", "type": "function"}, {"name": "test_set_alpha", "is_method": false, "class_name": null, "parameters": [], "calls": ["martist.Artist", "pytest.raises", "art.set_alpha", "pytest.raises", "art.set_alpha", "pytest.raises", "art.set_alpha", "pytest.raises", "art.set_alpha"], "code_location": {"file": "test_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 302, "end_line": 311}, "code_snippet": "def test_set_alpha():\n    art = martist.Artist()\n    with pytest.raises(TypeError, match='^alpha must be numeric or None'):\n        art.set_alpha('string')\n    with pytest.raises(TypeError, match='^alpha must be numeric or None'):\n        art.set_alpha([1, 2, 3])\n    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n        art.set_alpha(1.1)\n    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n        art.set_alpha(np.nan)\n", "type": "function"}, {"name": "set_alpha", "is_method": true, "class_name": "LineCollection", "parameters": ["self", "alpha"], "calls": ["set_alpha", "self.set_gapcolor", "super"], "code_location": {"file": "collections.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1787, "end_line": 1791}, "code_snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        super().set_alpha(alpha)\n        if self._gapcolor is not None:\n            self.set_gapcolor(self._original_gapcolor)\n", "type": "function"}, {"name": "set_alpha", "is_method": true, "class_name": "Patch", "parameters": ["self", "alpha"], "calls": ["set_alpha", "self._set_facecolor", "self._set_edgecolor", "self._set_hatchcolor", "super"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 445, "end_line": 450}, "code_snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        super().set_alpha(alpha)\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)\n        self._set_hatchcolor(self._original_hatchcolor)\n", "type": "function"}, {"name": "set_alpha", "is_method": true, "class_name": "Poly3DCollection", "parameters": ["self", "alpha"], "calls": ["artist.Artist.set_alpha", "mcolors.to_rgba_array", "mcolors.to_rgba_array"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 1436, "end_line": 1449}, "code_snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        artist.Artist.set_alpha(self, alpha)\n        try:\n            self._facecolor3d = mcolors.to_rgba_array(\n                self._facecolor3d, self._alpha)\n        except (AttributeError, TypeError, IndexError):\n            pass\n        try:\n            self._edgecolors = mcolors.to_rgba_array(\n                    self._edgecolor3d, self._alpha)\n        except (AttributeError, TypeError, IndexError):\n            pass\n        self.stale = True\n", "type": "function"}, {"name": "check_gc", "is_method": true, "class_name": "RendererPdf", "parameters": ["self", "gc", "fillcolor"], "calls": ["getattr", "getattr", "self.gc.delta", "gc.get_rgb", "gc.set_foreground", "self.file.output", "len"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1987, "end_line": 2012}, "code_snippet": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas\n", "type": "function"}, {"name": "test_has_alpha_channel", "is_method": false, "class_name": null, "parameters": [], "calls": ["mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel", "mcolors._has_alpha_channel"], "code_location": {"file": "test_colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1230, "end_line": 1244}, "code_snippet": "def test_has_alpha_channel():\n    assert mcolors._has_alpha_channel((0, 0, 0, 0))\n    assert mcolors._has_alpha_channel([1, 1, 1, 1])\n    assert mcolors._has_alpha_channel('#fff8')\n    assert mcolors._has_alpha_channel('#0f0f0f80')\n    assert mcolors._has_alpha_channel(('r', 0.5))\n    assert mcolors._has_alpha_channel(([1, 1, 1, 1], None))\n    assert not mcolors._has_alpha_channel('blue')  # 4-char string!\n    assert not mcolors._has_alpha_channel('0.25')\n    assert not mcolors._has_alpha_channel('r')\n    assert not mcolors._has_alpha_channel((1, 0, 0))\n    assert not mcolors._has_alpha_channel('#fff')\n    assert not mcolors._has_alpha_channel('#0f0f0f')\n    assert not mcolors._has_alpha_channel(('r', None))\n    assert not mcolors._has_alpha_channel(([1, 1, 1], None))\n", "type": "function"}, {"name": "test_image_alpha", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "np.random.seed", "np.random.rand", "plt.subplots", "ax1.imshow", "ax2.imshow", "ax3.imshow"], "code_location": {"file": "test_image.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 270, "end_line": 277}, "code_snippet": "def test_image_alpha():\n    np.random.seed(0)\n    Z = np.random.rand(6, 6)\n\n    fig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n    ax1.imshow(Z, alpha=1.0, interpolation='none')\n    ax2.imshow(Z, alpha=0.5, interpolation='none')\n    ax3.imshow(Z, alpha=0.5, interpolation='nearest')\n", "type": "function"}, {"name": "get_edgecolor", "is_method": true, "class_name": "Patch3DCollection", "parameters": ["self"], "calls": ["cbook._str_equal", "self._maybe_depth_shade_and_sort_colors", "self.get_facecolor", "get_edgecolor", "super"], "code_location": {"file": "art3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 827, "end_line": 833}, "code_snippet": "    def get_edgecolor(self):\n        # We need this check here to make sure we do not double-apply the depth\n        # based alpha shading when the edge color is \"face\" which means the\n        # edge colour should be identical to the face colour.\n        if cbook._str_equal(self._edgecolors, 'face'):\n            return self.get_facecolor()\n        return self._maybe_depth_shade_and_sort_colors(super().get_edgecolor())\n", "type": "function"}, {"name": "test_patch_color_none", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.style.context", "plt.Circle", "c.get_facecolor"], "code_location": {"file": "test_patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 336, "end_line": 340}, "code_snippet": "def test_patch_color_none():\n    # Make sure the alpha kwarg does not override 'none' facecolor.\n    # Addresses issue #7478.\n    c = plt.Circle((0, 0), 1, facecolor='none', alpha=1)\n    assert c.get_facecolor()[0] == 0\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.2594082355499268}
{"question": "How does the Legend class implement a multi-layered validation strategy to handle conflicting parameters like title_fontsize and title_fontproperties, and what design pattern could be applied to generalize this validation logic across similar parameter conflicts?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_legend_title_fontprop_fontsize", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.plot", "plt.legend", "plt.subplots", "plot", "legend", "plot", "legend", "plot", "legend", "plot", "legend", "plot", "legend", "plot", "legend", "range", "pytest.raises", "plt.legend", "get_size", "range", "get_fontsize", "range", "get_fontsize", "range", "get_fontsize", "range", "get_fontsize", "range", "get_fontsize", "range", "get_fontsize", "FontProperties", "leg.get_title", "leg0.get_title", "leg1.get_title", "leg2.get_title", "leg3.get_title", "leg4.get_title", "leg5.get_title"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 735, "end_line": 770}, "code_snippet": "def test_legend_title_fontprop_fontsize():\n    # test the title_fontsize kwarg\n    plt.plot(range(10), label=\"mock data\")\n    with pytest.raises(ValueError):\n        plt.legend(title='Aardvark', title_fontsize=22,\n                   title_fontproperties={'family': 'serif', 'size': 22})\n\n    leg = plt.legend(title='Aardvark', title_fontproperties=FontProperties(\n                                       family='serif', size=22))\n    assert leg.get_title().get_size() == 22\n\n    fig, axes = plt.subplots(2, 3, figsize=(10, 6))\n    axes = axes.flat\n    axes[0].plot(range(10), label=\"mock data\")\n    leg0 = axes[0].legend(title='Aardvark', title_fontsize=22)\n    assert leg0.get_title().get_fontsize() == 22\n    axes[1].plot(range(10), label=\"mock data\")\n    leg1 = axes[1].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif', 'size': 22})\n    assert leg1.get_title().get_fontsize() == 22\n    axes[2].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = None\n    leg2 = axes[2].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg2.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[3].plot(range(10), label=\"mock data\")\n    leg3 = axes[3].legend(title='Aardvark')\n    assert leg3.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[4].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = 20\n    leg4 = axes[4].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg4.get_title().get_fontsize() == 20\n    axes[5].plot(range(10), label=\"mock data\")\n    leg5 = axes[5].legend(title='Aardvark')\n    assert leg5.get_title().get_fontsize() == 20\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Legend", "parameters": ["self", "parent", "handles", "labels"], "calls": ["__init__", "self.prop.get_size_in_points", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "list", "isinstance", "self.set_bbox_to_anchor", "isinstance", "mpl._val_or_rc", "mpl._val_or_rc", "mpl._val_or_rc", "FancyBboxPatch", "self._set_artist_props", "_api.check_in_list", "self._init_legend_box", "self.set_loc", "FontProperties._from_any", "isinstance", "self.set_title", "self.set_draggable", "mpl._val_or_rc", "FontProperties", "FontProperties._from_any", "len", "ValueError", "np.array", "np.asarray", "np.tile", "self.set_figure", "isinstance", "self._shadow_props.update", "ValueError", "mpl._val_or_rc", "isinstance", "zip", "cbook._str_equal", "super", "isinstance", "self.prop.set_size", "len", "parent.get_figure", "self.set_figure", "TypeError", "bool", "ValueError", "mpl._val_or_rc", "title_prop_fp.set_size", "title_prop_fp.set_size", "np.iterable", "mpl._val_or_rc", "reversed", "reversed", "isinstance", "title_prop_fp.set_size", "text.set_color", "zip", "ValueError", "handle.get_array", "isinstance", "itertools.cycle", "text.set_color", "type", "getattr", "text.set_color", "colors.to_rgba_array", "all", "text.set_color", "np.isclose"], "code_location": {"file": "legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 355, "end_line": 620}, "code_snippet": "    def __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        numpoints=None,      # number of points in the legend line\n        markerscale=None,    # relative size of legend markers vs. original\n        markerfirst=True,    # left/right ordering of legend marker and label\n        reverse=False,       # reverse ordering of legend marker and label\n        scatterpoints=None,  # number of scatter points\n        scatteryoffsets=None,\n        prop=None,           # properties for the legend texts\n        fontsize=None,       # keyword to set font size directly\n        labelcolor=None,     # keyword to set the text color\n\n        # spacing & pad defined as a fraction of the font-size\n        borderpad=None,      # whitespace inside the legend border\n        labelspacing=None,   # vertical space between the legend entries\n        handlelength=None,   # length of the legend handles\n        handleheight=None,   # height of the legend handles\n        handletextpad=None,  # pad between the legend handle and text\n        borderaxespad=None,  # pad between the Axes and legend border\n        columnspacing=None,  # spacing between columns\n\n        ncols=1,     # number of columns\n        mode=None,  # horizontal distribution of columns: None or \"expand\"\n\n        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam\n        shadow=None,\n        title=None,           # legend title\n        title_fontsize=None,  # legend title font size\n        framealpha=None,      # set frame alpha\n        edgecolor=None,       # frame patch edgecolor\n        facecolor=None,       # frame patch facecolor\n\n        bbox_to_anchor=None,  # bbox to which the legend will be anchored\n        bbox_transform=None,  # transform for the bbox\n        frameon=None,         # draw frame\n        handler_map=None,\n        title_fontproperties=None,  # properties for the legend title\n        alignment=\"center\",       # control the alignment within the legend box\n        ncol=1,  # synonym for ncols (backward compatibility)\n        draggable=False  # whether the legend can be dragged with the mouse\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        parent : `~matplotlib.axes.Axes` or `.Figure`\n            The artist that contains the legend.\n\n        handles : list of (`.Artist` or tuple of `.Artist`)\n            A list of Artists (lines, patches) to be added to the legend.\n\n        labels : list of str\n            A list of labels to show next to the artists. The length of handles\n            and labels should be the same. If they are not, they are truncated\n            to the length of the shorter list.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Attributes\n        ----------\n        legend_handles\n            List of `.Artist` objects added as legend entries.\n\n            .. versionadded:: 3.7\n        \"\"\"\n        # local import only to avoid circularity\n        from matplotlib.axes import Axes\n        from matplotlib.figure import FigureBase\n\n        super().__init__()\n\n        if prop is None:\n            self.prop = FontProperties(size=mpl._val_or_rc(fontsize, \"legend.fontsize\"))\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n\n        self._fontsize = self.prop.get_size_in_points()\n\n        self.texts = []\n        self.legend_handles = []\n        self._legend_title_box = None\n\n        #: A dictionary with the extra handler mappings for this Legend\n        #: instance.\n        self._custom_handler_map = handler_map\n\n        self.numpoints = mpl._val_or_rc(numpoints, 'legend.numpoints')\n        self.markerscale = mpl._val_or_rc(markerscale, 'legend.markerscale')\n        self.scatterpoints = mpl._val_or_rc(scatterpoints, 'legend.scatterpoints')\n        self.borderpad = mpl._val_or_rc(borderpad, 'legend.borderpad')\n        self.labelspacing = mpl._val_or_rc(labelspacing, 'legend.labelspacing')\n        self.handlelength = mpl._val_or_rc(handlelength, 'legend.handlelength')\n        self.handleheight = mpl._val_or_rc(handleheight, 'legend.handleheight')\n        self.handletextpad = mpl._val_or_rc(handletextpad, 'legend.handletextpad')\n        self.borderaxespad = mpl._val_or_rc(borderaxespad, 'legend.borderaxespad')\n        self.columnspacing = mpl._val_or_rc(columnspacing, 'legend.columnspacing')\n        self.shadow = mpl._val_or_rc(shadow, 'legend.shadow')\n\n        if reverse:\n            labels = [*reversed(labels)]\n            handles = [*reversed(handles)]\n\n        handles = list(handles)\n        if len(handles) < 2:\n            ncols = 1\n        self._ncols = ncols if ncols != 1 else ncol\n\n        if self.numpoints <= 0:\n            raise ValueError(\"numpoints must be > 0; it was %d\" % numpoints)\n\n        # introduce y-offset for handles of the scatter plot\n        if scatteryoffsets is None:\n            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])\n        else:\n            self._scatteryoffsets = np.asarray(scatteryoffsets)\n        reps = self.scatterpoints // len(self._scatteryoffsets) + 1\n        self._scatteryoffsets = np.tile(self._scatteryoffsets,\n                                        reps)[:self.scatterpoints]\n\n        # _legend_box is a VPacker instance that contains all\n        # legend items and will be initialized from _init_legend_box()\n        # method.\n        self._legend_box = None\n\n        if isinstance(parent, Axes):\n            self.isaxes = True\n            self.axes = parent\n            self.set_figure(parent.get_figure(root=False))\n        elif isinstance(parent, FigureBase):\n            self.isaxes = False\n            self.set_figure(parent)\n        else:\n            raise TypeError(\n                \"Legend needs either Axes or FigureBase as parent\"\n            )\n        self.parent = parent\n\n        self._mode = mode\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n\n        # Figure out if self.shadow is valid\n        # If shadow was None, rcParams loads False\n        # So it shouldn't be None here\n\n        self._shadow_props = {'ox': 2, 'oy': -2}  # default location offsets\n        if isinstance(self.shadow, dict):\n            self._shadow_props.update(self.shadow)\n            self.shadow = True\n        elif self.shadow in (0, 1, True, False):\n            self.shadow = bool(self.shadow)\n        else:\n            raise ValueError(\n                'Legend shadow must be a dict or bool, not '\n                f'{self.shadow!r} of type {type(self.shadow)}.'\n            )\n\n        # We use FancyBboxPatch to draw a legend frame. The location\n        # and size of the box will be updated during the drawing time.\n\n        facecolor = mpl._val_or_rc(facecolor, \"legend.facecolor\")\n        if facecolor == 'inherit':\n            facecolor = mpl.rcParams[\"axes.facecolor\"]\n\n        edgecolor = mpl._val_or_rc(edgecolor, \"legend.edgecolor\")\n        if edgecolor == 'inherit':\n            edgecolor = mpl.rcParams[\"axes.edgecolor\"]\n\n        fancybox = mpl._val_or_rc(fancybox, \"legend.fancybox\")\n\n        self.legendPatch = FancyBboxPatch(\n            xy=(0, 0), width=1, height=1,\n            facecolor=facecolor, edgecolor=edgecolor,\n            # If shadow is used, default to alpha=1 (#8943).\n            alpha=(framealpha if framealpha is not None\n                   else 1 if shadow\n                   else mpl.rcParams[\"legend.framealpha\"]),\n            # The width and height of the legendPatch will be set (in draw())\n            # to the length that includes the padding. Thus we set pad=0 here.\n            boxstyle=(\"round,pad=0,rounding_size=0.2\" if fancybox\n                      else \"square,pad=0\"),\n            mutation_scale=self._fontsize,\n            snap=True,\n            visible=mpl._val_or_rc(frameon, \"legend.frameon\")\n        )\n        self._set_artist_props(self.legendPatch)\n\n        _api.check_in_list([\"center\", \"left\", \"right\"], alignment=alignment)\n        self._alignment = alignment\n\n        # init with null renderer\n        self._init_legend_box(handles, labels, markerfirst)\n\n        # Set legend location\n        self.set_loc(loc)\n\n        # figure out title font properties:\n        if title_fontsize is not None and title_fontproperties is not None:\n            raise ValueError(\n                \"title_fontsize and title_fontproperties can't be specified \"\n                \"at the same time. Only use one of them. \")\n        title_prop_fp = FontProperties._from_any(title_fontproperties)\n        if isinstance(title_fontproperties, dict):\n            if \"size\" not in title_fontproperties:\n                title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n                title_prop_fp.set_size(title_fontsize)\n        elif title_fontsize is not None:\n            title_prop_fp.set_size(title_fontsize)\n        elif not isinstance(title_fontproperties, FontProperties):\n            title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n            title_prop_fp.set_size(title_fontsize)\n\n        self.set_title(title, prop=title_prop_fp)\n\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n        # set the text color\n\n        color_getters = {  # getter function depends on line or patch\n            'linecolor':       ['get_color',           'get_facecolor'],\n            'markerfacecolor': ['get_markerfacecolor', 'get_facecolor'],\n            'mfc':             ['get_markerfacecolor', 'get_facecolor'],\n            'markeredgecolor': ['get_markeredgecolor', 'get_edgecolor'],\n            'mec':             ['get_markeredgecolor', 'get_edgecolor'],\n        }\n        labelcolor = mpl._val_or_rc(mpl._val_or_rc(labelcolor, 'legend.labelcolor'),\n                                    'text.color')\n        if isinstance(labelcolor, str) and labelcolor in color_getters:\n            getter_names = color_getters[labelcolor]\n            for handle, text in zip(self.legend_handles, self.texts):\n                try:\n                    if handle.get_array() is not None:\n                        continue\n                except AttributeError:\n                    pass\n                for getter_name in getter_names:\n                    try:\n                        color = getattr(handle, getter_name)()\n                        if isinstance(color, np.ndarray):\n                            if (\n                                    color.shape[0] == 1\n                                    or np.isclose(color, color[0]).all()\n                            ):\n                                text.set_color(color[0])\n                            else:\n                                pass\n                        else:\n                            text.set_color(color)\n                        break\n                    except AttributeError:\n                        pass\n        elif cbook._str_equal(labelcolor, 'none'):\n            for text in self.texts:\n                text.set_color(labelcolor)\n        elif np.iterable(labelcolor):\n            for text, color in zip(self.texts,\n                                   itertools.cycle(\n                                       colors.to_rgba_array(labelcolor))):\n                text.set_color(color)\n        else:\n            raise ValueError(f\"Invalid labelcolor: {labelcolor!r}\")\n", "type": "function"}, {"name": "test_loc_validation_string_value", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "pytest.raises", "ax.legend"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1344, "end_line": 1360}, "code_snippet": "def test_loc_validation_string_value():\n    fig, ax = plt.subplots()\n    labels = [\"mock data\"]\n    ax.legend(loc='best', labels=labels)\n    ax.legend(loc='upper right', labels=labels)\n    ax.legend(loc='best', labels=labels)\n    ax.legend(loc='upper right', labels=labels)\n    ax.legend(loc='upper left', labels=labels)\n    ax.legend(loc='lower left', labels=labels)\n    ax.legend(loc='lower right', labels=labels)\n    ax.legend(loc='right', labels=labels)\n    ax.legend(loc='center left', labels=labels)\n    ax.legend(loc='center right', labels=labels)\n    ax.legend(loc='lower center', labels=labels)\n    ax.legend(loc='upper center', labels=labels)\n    with pytest.raises(ValueError, match=\"'wrong' is not a valid value for\"):\n        ax.legend(loc='wrong', labels=labels)\n", "type": "function"}, {"name": "test_legend_colors", "is_method": false, "class_name": null, "parameters": ["color_type", "param_dict", "target"], "calls": ["pytest.mark.parametrize", "param_dict.pop", "mpl.rc_context", "plt.subplots", "ax.plot", "ax.legend", "range", "getattr"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 169, "end_line": 177}, "code_snippet": "def test_legend_colors(color_type, param_dict, target):\n    param_dict[f'legend.{color_type}color'] = param_dict.pop('color')\n    get_func = f'get_{color_type}color'\n\n    with mpl.rc_context(param_dict):\n        _, ax = plt.subplots()\n        ax.plot(range(3), label='test')\n        leg = ax.legend()\n        assert getattr(leg.legendPatch, get_func)() == target\n", "type": "function"}, {"name": "test_validate_linespacing", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.raises", "plt.text"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 567, "end_line": 569}, "code_snippet": "def test_validate_linespacing():\n    with pytest.raises(TypeError):\n        plt.text(.25, .5, \"foo\", linespacing=\"abc\")\n", "type": "function"}, {"name": "test_loc_validation_numeric_value", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.legend", "ax.legend", "ax.legend", "ax.legend", "pytest.raises", "ax.legend", "pytest.raises", "ax.legend"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1329, "end_line": 1341}, "code_snippet": "def test_loc_validation_numeric_value():\n    fig, ax = plt.subplots()\n    ax.legend(loc=0, labels=[\"mock data\"])\n    ax.legend(loc=1, labels=[\"mock data\"])\n    ax.legend(loc=5, labels=[\"mock data\"])\n    ax.legend(loc=10, labels=[\"mock data\"])\n    with pytest.raises(ValueError, match=('loc must be string, coordinate '\n                       'tuple, or an integer 0-10, not 11')):\n        ax.legend(loc=11, labels=[\"mock data\"])\n\n    with pytest.raises(ValueError, match=('loc must be string, coordinate '\n                       'tuple, or an integer 0-10, not -1')):\n        ax.legend(loc=-1, labels=[\"mock data\"])\n", "type": "function"}, {"name": "test_loc_invalid_tuple_exception", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "pytest.raises", "ax.legend", "pytest.raises", "ax.legend", "pytest.raises", "ax.legend"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1286, "end_line": 1300}, "code_snippet": "def test_loc_invalid_tuple_exception():\n    # check that exception is raised if the loc arg\n    # of legend is not a 2-tuple of numbers\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError, match=('loc must be string, coordinate '\n                       'tuple, or an integer 0-10, not \\\\(1.1,\\\\)')):\n        ax.legend(loc=(1.1, ), labels=[\"mock data\"])\n\n    with pytest.raises(ValueError, match=('loc must be string, coordinate '\n                       'tuple, or an integer 0-10, not \\\\(0.481, 0.4227, 0.4523\\\\)')):\n        ax.legend(loc=(0.481, 0.4227, 0.4523), labels=[\"mock data\"])\n\n    with pytest.raises(ValueError, match=('loc must be string, coordinate '\n                       'tuple, or an integer 0-10, not \\\\(0.481, \\'go blue\\'\\\\)')):\n        ax.legend(loc=(0.481, \"go blue\"), labels=[\"mock data\"])\n", "type": "function"}, {"name": "test_legend_label_three_args", "is_method": true, "class_name": "TestLegendFigureFunction", "parameters": ["self"], "calls": ["plt.subplots", "ax.plot", "range", "pytest.raises", "fig.legend", "pytest.raises", "fig.legend"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 454, "end_line": 460}, "code_snippet": "    def test_legend_label_three_args(self):\n        fig, ax = plt.subplots()\n        lines = ax.plot(range(10))\n        with pytest.raises(TypeError, match=\"0-2\"):\n            fig.legend(lines, ['foobar'], 'right')\n        with pytest.raises(TypeError, match=\"0-2\"):\n            fig.legend(lines, ['foobar'], 'right', loc='left')\n", "type": "function"}, {"name": "test_rcparams_update", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl.RcParams", "pytest.raises", "rc.update"], "code_location": {"file": "test_rcparams.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 107, "end_line": 112}, "code_snippet": "def test_rcparams_update():\n    rc = mpl.RcParams({'figure.figsize': (3.5, 42)})\n    bad_dict = {'figure.figsize': (3.5, 42, 1)}\n    # make sure validation happens on input\n    with pytest.raises(ValueError):\n        rc.update(bad_dict)\n", "type": "function"}, {"name": "test_legend_repeatcheckok", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.scatter", "ax.scatter", "ax.legend", "mlegend._get_legend_handles_labels", "plt.subplots", "ax.scatter", "ax.scatter", "ax.legend", "mlegend._get_legend_handles_labels", "len", "len"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 566, "end_line": 578}, "code_snippet": "def test_legend_repeatcheckok():\n    fig, ax = plt.subplots()\n    ax.scatter(0.0, 1.0, color='k', marker='o', label='test')\n    ax.scatter(0.5, 0.0, color='r', marker='v', label='test')\n    ax.legend()\n    hand, lab = mlegend._get_legend_handles_labels([ax])\n    assert len(lab) == 2\n    fig, ax = plt.subplots()\n    ax.scatter(0.0, 1.0, color='k', marker='o', label='test')\n    ax.scatter(0.5, 0.0, color='k', marker='v', label='test')\n    ax.legend()\n    hand, lab = mlegend._get_legend_handles_labels([ax])\n    assert len(lab) == 2\n", "type": "function"}], "retrieved_count": 10, "cost_time": 1.3174972534179688}
{"question": "Why does the repeated instantiation of figure and axes objects with different DPI values in test_legend_proper_window_extent impact renderer caching and what performance degradation occurs when get_window_extent is called sequentially on legends without renderer state reuse?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_window_extent_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "ax.legend", "fig.legend", "fig.canvas.draw", "leg.get_window_extent", "leg2.get_window_extent", "range"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 724, "end_line": 732}, "code_snippet": "def test_window_extent_cached_renderer():\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    leg2 = fig.legend()\n    fig.canvas.draw()\n    # check that get_window_extent will use the cached renderer\n    leg.get_window_extent()\n    leg2.get_window_extent()\n", "type": "function"}, {"name": "test_legend_proper_window_extent", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "ax.legend", "plt.subplots", "ax.plot", "ax.legend", "range", "leg.get_window_extent", "range", "leg.get_window_extent", "pytest.approx", "fig.canvas.get_renderer", "fig.canvas.get_renderer"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 710, "end_line": 721}, "code_snippet": "def test_legend_proper_window_extent():\n    # test that legend returns the expected extent under various dpi...\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x01 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n\n    fig, ax = plt.subplots(dpi=200)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x02 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n    assert pytest.approx(x01*2, 0.1) == x02\n", "type": "function"}, {"name": "test_legend_annotate", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.plot", "ax.annotate", "ax.legend", "mocked_get_renderer.assert_not_called", "mock.patch.object", "fig.savefig", "io.BytesIO"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1430, "end_line": 1442}, "code_snippet": "def test_legend_annotate():\n    fig, ax = plt.subplots()\n\n    ax.plot([1, 2, 3], label=\"Line\")\n    ax.annotate(\"a\", xy=(1, 1))\n    ax.legend(loc=0)\n\n    with mock.patch.object(\n            fig, '_get_renderer', wraps=fig._get_renderer) as mocked_get_renderer:\n        fig.savefig(io.BytesIO())\n\n    # Finding the legend position should not require _get_renderer to be called\n    mocked_get_renderer.assert_not_called()\n", "type": "function"}, {"name": "test_figure_legend_outside", "is_method": false, "class_name": null, "parameters": [], "calls": ["enumerate", "print", "plt.subplots", "axs.plot", "fig.legend", "fig.draw_without_rendering", "assert_allclose", "assert_allclose", "range", "axs.get_window_extent", "leg.get_window_extent"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 481, "end_line": 519}, "code_snippet": "def test_figure_legend_outside():\n    todos = ['upper ' + pos for pos in ['left', 'center', 'right']]\n    todos += ['lower ' + pos for pos in ['left', 'center', 'right']]\n    todos += ['left ' + pos for pos in ['lower', 'center', 'upper']]\n    todos += ['right ' + pos for pos in ['lower', 'center', 'upper']]\n\n    upperext = [20.347556,  27.722556, 790.583, 545.499]\n    lowerext = [20.347556,  71.056556, 790.583, 588.833]\n    leftext = [151.681556, 27.722556, 790.583, 588.833]\n    rightext = [20.347556,  27.722556, 659.249, 588.833]\n    axbb = [upperext, upperext, upperext,\n            lowerext, lowerext, lowerext,\n            leftext, leftext, leftext,\n            rightext, rightext, rightext]\n\n    legbb = [[10., 555., 133., 590.],     # upper left\n             [338.5, 555., 461.5, 590.],  # upper center\n             [667, 555., 790.,  590.],    # upper right\n             [10., 10., 133.,  45.],      # lower left\n             [338.5, 10., 461.5,  45.],   # lower center\n             [667., 10., 790.,  45.],     # lower right\n             [10., 10., 133., 45.],       # left lower\n             [10., 282.5, 133., 317.5],   # left center\n             [10., 555., 133., 590.],     # left upper\n             [667, 10., 790., 45.],       # right lower\n             [667., 282.5, 790., 317.5],  # right center\n             [667., 555., 790., 590.]]    # right upper\n\n    for nn, todo in enumerate(todos):\n        print(todo)\n        fig, axs = plt.subplots(constrained_layout=True, dpi=100)\n        axs.plot(range(10), label='Boo1')\n        leg = fig.legend(loc='outside ' + todo)\n        fig.draw_without_rendering()\n\n        assert_allclose(axs.get_window_extent().extents,\n                        axbb[nn])\n        assert_allclose(leg.get_window_extent().extents,\n                        legbb[nn])\n", "type": "function"}, {"name": "test_warn_big_data_best_loc", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["itertools.count", "monkeypatch.setattr", "plt.subplots", "fig.canvas.draw", "ax.plot", "rc_context", "ax.legend", "pytest.warns", "fig.draw_artist", "len", "next"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1112, "end_line": 1133}, "code_snippet": "def test_warn_big_data_best_loc(monkeypatch):\n    # Force _find_best_position to think it took a long time.\n    counter = itertools.count(0, step=1.5)\n    monkeypatch.setattr(time, 'perf_counter', lambda: next(counter))\n\n    fig, ax = plt.subplots()\n    fig.canvas.draw()  # So that we can call draw_artist later.\n\n    # Place line across all possible legend locations.\n    x = [0.9, 0.1, 0.1, 0.9, 0.9, 0.5]\n    y = [0.95, 0.95, 0.05, 0.05, 0.5, 0.5]\n    ax.plot(x, y, 'o-', label='line')\n\n    with rc_context({'legend.loc': 'best'}):\n        legend = ax.legend()\n    with pytest.warns(UserWarning,\n                      match='Creating legend with loc=\"best\" can be slow with large '\n                      'amounts of data.') as records:\n        fig.draw_artist(legend)  # Don't bother drawing the lines -- it's slow.\n    # The _find_best_position method of Legend is called twice, duplicating\n    # the warning message.\n    assert len(records) == 2\n", "type": "function"}, {"name": "test_no_warn_big_data_when_loc_specified", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["itertools.count", "monkeypatch.setattr", "plt.subplots", "fig.canvas.draw", "ax.plot", "ax.legend", "fig.draw_artist", "next"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1136, "end_line": 1150}, "code_snippet": "def test_no_warn_big_data_when_loc_specified(monkeypatch):\n    # Force _find_best_position to think it took a long time.\n    counter = itertools.count(0, step=1.5)\n    monkeypatch.setattr(time, 'perf_counter', lambda: next(counter))\n\n    fig, ax = plt.subplots()\n    fig.canvas.draw()\n\n    # Place line across all possible legend locations.\n    x = [0.9, 0.1, 0.1, 0.9, 0.9, 0.5]\n    y = [0.95, 0.95, 0.05, 0.05, 0.5, 0.5]\n    ax.plot(x, y, 'o-', label='line')\n\n    legend = ax.legend('best')\n    fig.draw_artist(legend)  # Check that no warning is emitted.\n", "type": "function"}, {"name": "test_subfigure_legend", "is_method": false, "class_name": null, "parameters": [], "calls": ["subfigures", "subfig.subplots", "ax.plot", "subfig.legend", "leg.get_figure", "plt.figure"], "code_location": {"file": "test_legend.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1243, "end_line": 1249}, "code_snippet": "def test_subfigure_legend():\n    # Test that legend can be added to subfigure (#20723)\n    subfig = plt.figure().subfigures()\n    ax = subfig.subplots()\n    ax.plot([0, 1], [0, 1], label=\"line\")\n    leg = subfig.legend()\n    assert leg.get_figure(root=False) is subfig\n", "type": "function"}, {"name": "test_stackplot_subfig_legend", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.subfigures", "fig.legend", "fig.draw_without_rendering", "_fig.subplots", "ax.stackplot"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 3423, "end_line": 3434}, "code_snippet": "def test_stackplot_subfig_legend():\n    # Smoke test for https://github.com/matplotlib/matplotlib/issues/30158\n\n    fig = plt.figure()\n    subfigs = fig.subfigures(nrows=1, ncols=2)\n\n    for _fig in subfigs:\n        ax = _fig.subplots(nrows=1, ncols=1)\n        ax.stackplot([3, 4], [[1, 2]], labels=['a'])\n\n    fig.legend()\n    fig.draw_without_rendering()\n", "type": "function"}, {"name": "_test_cached_renderer", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.canvas.draw", "plt.figure", "fig.draw_without_rendering", "fig.canvas.get_renderer", "fig.canvas.get_renderer"], "code_location": {"file": "test_backend_macosx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 24}, "code_snippet": "def _test_cached_renderer():\n    # Make sure that figures have an associated renderer after\n    # a fig.canvas.draw() call\n    fig = plt.figure(1)\n    fig.canvas.draw()\n    assert fig.canvas.get_renderer()._renderer is not None\n\n    fig = plt.figure(2)\n    fig.draw_without_rendering()\n    assert fig.canvas.get_renderer()._renderer is not None\n", "type": "function"}, {"name": "test_non_default_dpi", "is_method": false, "class_name": null, "parameters": ["text"], "calls": ["pytest.mark.parametrize", "plt.subplots", "ax.text", "fig.canvas.draw", "t1.get_window_extent", "t1.get_window_extent", "np.testing.assert_allclose", "bbox2.get_points", "bbox1.get_points"], "code_location": {"file": "test_text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 373, "end_line": 385}, "code_snippet": "def test_non_default_dpi(text):\n    fig, ax = plt.subplots()\n\n    t1 = ax.text(0.5, 0.5, text, ha='left', va='bottom')\n    fig.canvas.draw()\n    dpi = fig.dpi\n\n    bbox1 = t1.get_window_extent()\n    bbox2 = t1.get_window_extent(dpi=dpi * 10)\n    np.testing.assert_allclose(bbox2.get_points(), bbox1.get_points() * 10,\n                               rtol=5e-2)\n    # Text.get_window_extent should not permanently change dpi.\n    assert fig.dpi == dpi\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34228062629699707}
{"question": "Why does the _make_flip_transform method consistently apply a vertical flip transformation, and how does this design choice relate to the coordinate system mismatch between matplotlib and SVG?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_make_flip_transform", "is_method": true, "class_name": "RendererSVG", "parameters": ["self", "transform"], "calls": ["translate", "scale", "Affine2D"], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 491, "end_line": 492}, "code_snippet": "    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n", "type": "function"}, {"name": "_get_rotation_transform", "is_method": true, "class_name": "RectangleSelector", "parameters": ["self"], "calls": ["self.ax._get_aspect_ratio", "translate", "scale", "rotate", "scale", "translate", "Affine2D"], "code_location": {"file": "widgets.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3469, "end_line": 3475}, "code_snippet": "    def _get_rotation_transform(self):\n        aspect_ratio = self.ax._get_aspect_ratio()\n        return Affine2D().translate(-self.center[0], -self.center[1]) \\\n                .scale(1, aspect_ratio) \\\n                .rotate(self._rotation) \\\n                .scale(1, 1 / aspect_ratio) \\\n                .translate(*self.center)\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "LambertAxes", "parameters": ["self"], "calls": ["translate", "scale", "Affine2D"], "code_location": {"file": "geo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 508, "end_line": 511}, "code_snippet": "    def _get_affine_transform(self):\n        return Affine2D() \\\n            .scale(0.25) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "transform.transform", "transform.transform", "translate", "scale", "Affine2D"], "code_location": {"file": "geo.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 108, "end_line": 114}, "code_snippet": "    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "_get_affine_transform", "is_method": true, "class_name": "GeoAxes", "parameters": ["self"], "calls": ["self._get_core_transform", "transform.transform", "transform.transform", "translate", "scale", "Affine2D"], "code_location": {"file": "custom_projection.py", "path": "/data3/pwh/swebench-repos/matplotlib/galleries/examples/misc", "start_line": 173, "end_line": 179}, "code_snippet": "    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n", "type": "function"}, {"name": "flipy", "is_method": true, "class_name": "RendererPDFPSBase", "parameters": ["self"], "calls": [], "code_location": {"file": "_backend_pdf_ps.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 130, "end_line": 132}, "code_snippet": "    def flipy(self):\n        # docstring inherited\n        return False  # y increases from bottom to top.\n", "type": "function"}, {"name": "flipy", "is_method": true, "class_name": "RendererSVG", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_svg.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1291, "end_line": 1293}, "code_snippet": "    def flipy(self):\n        # docstring inherited\n        return True\n", "type": "function"}, {"name": "flipy", "is_method": true, "class_name": "RendererWx", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 140, "end_line": 142}, "code_snippet": "    def flipy(self):\n        # docstring inherited\n        return True\n", "type": "function"}, {"name": "flipy", "is_method": true, "class_name": "RendererTemplate", "parameters": ["self"], "calls": [], "code_location": {"file": "backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 85, "end_line": 87}, "code_snippet": "    def flipy(self):\n        # docstring inherited\n        return True\n", "type": "function"}, {"name": "get_patch_transform", "is_method": true, "class_name": "Rectangle", "parameters": ["self"], "calls": ["self.get_bbox", "transforms.BboxTransformTo", "translate", "scale", "rotate_deg", "scale", "translate", "transforms.Affine2D"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 824, "end_line": 843}, "code_snippet": "    def get_patch_transform(self):\n        # Note: This cannot be called until after this has been added to\n        # an Axes, otherwise unit conversion will fail. This makes it very\n        # important to call the accessor method and not directly access the\n        # transformation member variable.\n        bbox = self.get_bbox()\n        if self.rotation_point == 'center':\n            width, height = bbox.x1 - bbox.x0, bbox.y1 - bbox.y0\n            rotation_point = bbox.x0 + width / 2., bbox.y0 + height / 2.\n        elif self.rotation_point == 'xy':\n            rotation_point = bbox.x0, bbox.y0\n        else:\n            rotation_point = self.rotation_point\n        return transforms.BboxTransformTo(bbox) \\\n                + transforms.Affine2D() \\\n                .translate(-rotation_point[0], -rotation_point[1]) \\\n                .scale(1, self._aspect_ratio_correction) \\\n                .rotate_deg(self.angle) \\\n                .scale(1, 1 / self._aspect_ratio_correction) \\\n                .translate(*rotation_point)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.343005895614624}
{"question": "Why does the test_shared_and_moved function verify that tick label visibility remains consistent when axis sharing is combined with explicit tick position changes, and what underlying matplotlib behavior does this test protect against?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_shared_and_moved", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "check_ticklabel_visible", "a2.yaxis.tick_left", "check_ticklabel_visible", "plt.subplots", "check_ticklabel_visible", "a2.xaxis.tick_bottom", "check_ticklabel_visible"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 161, "end_line": 172}, "code_snippet": "def test_shared_and_moved():\n    # test if sharey is on, but then tick_left is called that labels don't\n    # re-appear.  Seaborn does this just to be sure yaxis is on left...\n    f, (a1, a2) = plt.subplots(1, 2, sharey=True)\n    check_ticklabel_visible([a2], [True], [False])\n    a2.yaxis.tick_left()\n    check_ticklabel_visible([a2], [True], [False])\n\n    f, (a1, a2) = plt.subplots(2, 1, sharex=True)\n    check_ticklabel_visible([a1], [False], [True])\n    a2.xaxis.tick_bottom()\n    check_ticklabel_visible([a1], [False], [True])\n", "type": "function"}, {"name": "test_shared_axes_retick", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_subplot", "fig.add_subplot", "ax1.plot", "ax2.plot", "ax1.set_zticks", "ax1.get_zlim", "ax2.get_zlim"], "code_location": {"file": "test_axes3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d/tests", "start_line": 1883, "end_line": 1892}, "code_snippet": "def test_shared_axes_retick():\n    fig = plt.figure()\n    ax1 = fig.add_subplot(211, projection=\"3d\")\n    ax2 = fig.add_subplot(212, projection=\"3d\", sharez=ax1)\n    ax1.plot([0, 1], [0, 1], [0, 2])\n    ax2.plot([0, 1], [0, 1], [0, 2])\n    ax1.set_zticks([-0.5, 0, 2, 2.5])\n    # check that setting ticks on a shared axis is synchronized\n    assert ax1.get_zlim() == (-0.5, 2.5)\n    assert ax2.get_zlim() == (-0.5, 2.5)\n", "type": "function"}, {"name": "test_shared_polar_keeps_ticklabels", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "fig.canvas.draw", "get_visible", "get_visible", "plt.subplot_mosaic", "fig.canvas.draw", "get_visible", "get_visible"], "code_location": {"file": "test_polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 413, "end_line": 423}, "code_snippet": "def test_shared_polar_keeps_ticklabels():\n    fig, axs = plt.subplots(\n        2, 2, subplot_kw={\"projection\": \"polar\"}, sharex=True, sharey=True)\n    fig.canvas.draw()\n    assert axs[0, 1].xaxis.majorTicks[0].get_visible()\n    assert axs[0, 1].yaxis.majorTicks[0].get_visible()\n    fig, axs = plt.subplot_mosaic(\n        \"ab\\ncd\", subplot_kw={\"projection\": \"polar\"}, sharex=True, sharey=True)\n    fig.canvas.draw()\n    assert axs[\"b\"].xaxis.majorTicks[0].get_visible()\n    assert axs[\"b\"].yaxis.majorTicks[0].get_visible()\n", "type": "function"}, {"name": "test_shared_axes_retick", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "set_xticks", "set_yticks", "ax.plot", "ax.get_xlim", "get_xlim", "ax.get_ylim", "get_ylim"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 8819, "end_line": 8831}, "code_snippet": "def test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n\n    for ax in axs.flat:\n        ax.plot([0, 2], 'o-')\n\n    axs[0, 0].set_xticks([-0.5, 0, 1, 1.5])  # should affect all axes xlims\n    for ax in axs.flat:\n        assert ax.get_xlim() == axs[0, 0].get_xlim()\n\n    axs[0, 0].set_yticks([-0.5, 0, 2, 2.5])  # should affect all axes ylims\n    for ax in axs.flat:\n        assert ax.get_ylim() == axs[0, 0].get_ylim()\n", "type": "function"}, {"name": "test_subplots_hide_ticklabels", "is_method": false, "class_name": null, "parameters": ["top", "bottom", "left", "right"], "calls": ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "np.ndenumerate", "plt.rc_context", "subplots", "plt.figure"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 199, "end_line": 214}, "code_snippet": "def test_subplots_hide_ticklabels(top, bottom, left, right):\n    # Ideally, we would also test offset-text visibility (and remove\n    # test_subplots_offsettext), but currently, setting rcParams fails to move\n    # the offset texts as well.\n    with plt.rc_context({\"xtick.labeltop\": top, \"xtick.labelbottom\": bottom,\n                         \"ytick.labelleft\": left, \"ytick.labelright\": right}):\n        axs = plt.figure().subplots(3, 3, sharex=True, sharey=True)\n    for (i, j), ax in np.ndenumerate(axs):\n        xtop = ax.xaxis._major_tick_kw[\"label2On\"]\n        xbottom = ax.xaxis._major_tick_kw[\"label1On\"]\n        yleft = ax.yaxis._major_tick_kw[\"label1On\"]\n        yright = ax.yaxis._major_tick_kw[\"label2On\"]\n        assert xtop == (top and i == 0)\n        assert xbottom == (bottom and i == 2)\n        assert yleft == (left and j == 0)\n        assert yright == (right and j == 2)\n", "type": "function"}, {"name": "test_shared", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "check_shared", "plt.close", "np.ones", "np.zeros", "np.array", "np.array", "plt.subplots", "check_shared", "check_ticklabel_visible", "plt.close"], "code_location": {"file": "test_subplots.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 60, "end_line": 111}, "code_snippet": "def test_shared():\n    rdim = (4, 4, 2)\n    share = {\n            'all': np.ones(rdim[:2], dtype=bool),\n            'none': np.zeros(rdim[:2], dtype=bool),\n            'row': np.array([\n                [False, True, False, False],\n                [True, False, False, False],\n                [False, False, False, True],\n                [False, False, True, False]]),\n            'col': np.array([\n                [False, False, True, False],\n                [False, False, False, True],\n                [True, False, False, False],\n                [False, True, False, False]]),\n            }\n    visible = {\n            'x': {\n                'all': [False, False, True, True],\n                'col': [False, False, True, True],\n                'row': [True] * 4,\n                'none': [True] * 4,\n                False: [True] * 4,\n                True: [False, False, True, True],\n                },\n            'y': {\n                'all': [True, False, True, False],\n                'col': [True] * 4,\n                'row': [True, False, True, False],\n                'none': [True] * 4,\n                False: [True] * 4,\n                True: [True, False, True, False],\n                },\n            }\n    share[False] = share['none']\n    share[True] = share['all']\n\n    # test default\n    f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2)\n    axs = [a1, a2, a3, a4]\n    check_shared(axs, share['none'], share['none'])\n    plt.close(f)\n\n    # test all option combinations\n    ops = [False, True, 'all', 'none', 'row', 'col', 0, 1]\n    for xo in ops:\n        for yo in ops:\n            f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2, sharex=xo, sharey=yo)\n            axs = [a1, a2, a3, a4]\n            check_shared(axs, share[xo], share[yo])\n            check_ticklabel_visible(axs, visible['x'][xo], visible['y'][yo])\n            plt.close(f)\n", "type": "function"}, {"name": "test_retain_tick_visibility", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.subplots", "plt.plot", "plt.setp", "ax.tick_params", "ax.get_yticklabels"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 6674, "end_line": 6678}, "code_snippet": "def test_retain_tick_visibility():\n    fig, ax = plt.subplots()\n    plt.plot([0, 1, 2], [0, -1, 4])\n    plt.setp(ax.get_yticklabels(), visible=False)\n    ax.tick_params(axis=\"y\", which=\"both\", length=0)\n", "type": "function"}, {"name": "test_subplots_shareax_loglabels", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_yscale", "ax.set_xscale", "ax.plot", "len", "len", "len", "len", "ax.xaxis.get_ticklabels", "ax.xaxis.get_ticklabels", "ax.yaxis.get_ticklabels", "ax.yaxis.get_ticklabels"], "code_location": {"file": "test_figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 565, "end_line": 583}, "code_snippet": "def test_subplots_shareax_loglabels():\n    fig, axs = plt.subplots(2, 2, sharex=True, sharey=True, squeeze=False)\n    for ax in axs.flat:\n        ax.plot([10, 20, 30], [10, 20, 30])\n\n    ax.set_yscale(\"log\")\n    ax.set_xscale(\"log\")\n\n    for ax in axs[0, :]:\n        assert 0 == len(ax.xaxis.get_ticklabels(which='both'))\n\n    for ax in axs[1, :]:\n        assert 0 < len(ax.xaxis.get_ticklabels(which='both'))\n\n    for ax in axs[:, 1]:\n        assert 0 == len(ax.yaxis.get_ticklabels(which='both'))\n\n    for ax in axs[:, 0]:\n        assert 0 < len(ax.yaxis.get_ticklabels(which='both'))\n", "type": "function"}, {"name": "test_sharing_does_not_link_positions", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "fig.add_subplot", "fig.add_axes", "ax1.get_position", "fig.subplots_adjust", "all", "get_points", "init_pos.get_points", "ax1.get_position"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 8775, "end_line": 8781}, "code_snippet": "def test_sharing_does_not_link_positions():\n    fig = plt.figure()\n    ax0 = fig.add_subplot(221)\n    ax1 = fig.add_axes((.6, .6, .3, .3), sharex=ax0)\n    init_pos = ax1.get_position()\n    fig.subplots_adjust(left=0)\n    assert (ax1.get_position().get_points() == init_pos.get_points()).all()\n", "type": "function"}, {"name": "test_remove_shared_axes_relim", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "get_xlim", "ax.remove", "ax.set_xlim", "assert_array_equal", "get_xlim"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 7264, "end_line": 7270}, "code_snippet": "def test_remove_shared_axes_relim():\n    fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n    ax = ax_lst[0][0]\n    orig_xlim = ax_lst[0][1].get_xlim()\n    ax.remove()\n    ax.set_xlim(0, 5)\n    assert_array_equal(ax_lst[0][1].get_xlim(), orig_xlim)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3539447784423828}
{"question": "Where does the FontInfo NamedTuple propagate font metrics and glyph data through the mathematical text rendering pipeline, and what control flow determines whether the postscript_name or the FT2Font object is used at different stages of character rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_get_info", "is_method": true, "class_name": "TruetypeFonts", "parameters": ["self", "fontname", "font_class", "sym", "fontsize", "dpi"], "calls": ["self._get_glyph", "font.set_size", "font.load_char", "self._get_offset", "FontMetrics", "FontInfo"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 373, "end_line": 402}, "code_snippet": "    def _get_info(self, fontname: str, font_class: str, sym: str, fontsize: float,\n                  dpi: float) -> FontInfo:\n        font, num, slanted = self._get_glyph(fontname, font_class, sym)\n        font.set_size(fontsize, dpi)\n        glyph = font.load_char(num, flags=self.load_glyph_flags)\n\n        xmin, ymin, xmax, ymax = (val / 64 for val in glyph.bbox)\n        offset = self._get_offset(font, glyph, fontsize, dpi)\n        metrics = FontMetrics(\n            advance=glyph.linearHoriAdvance / 65536,\n            height=glyph.height / 64,\n            width=glyph.width / 64,\n            xmin=xmin,\n            xmax=xmax,\n            ymin=ymin + offset,\n            ymax=ymax + offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg=glyph.horiBearingY / 64 + offset,\n            slanted=slanted\n        )\n\n        return FontInfo(\n            font=font,\n            fontsize=fontsize,\n            postscript_name=font.postscript_name,\n            metrics=metrics,\n            num=num,\n            glyph=glyph,\n            offset=offset\n        )\n", "type": "function"}, {"name": "_get_glyph", "is_method": true, "class_name": "BakomaFonts", "parameters": ["self", "fontname", "font_class", "sym"], "calls": ["self._get_font", "self._stix_fallback._get_glyph", "len", "self._get_font", "font.get_char_index", "ord"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 462, "end_line": 477}, "code_snippet": "    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n        if font is not None and font.get_char_index(num) != 0:\n            return font, num, slanted\n        else:\n            return self._stix_fallback._get_glyph(fontname, font_class, sym)\n", "type": "function"}, {"name": "_get_glyph", "is_method": true, "class_name": "UnicodeFonts", "parameters": ["self", "fontname", "font_class", "sym"], "calls": ["self._map_virtual_font", "get_unicode_index", "self._get_font", "ord", "_log.warning", "chr", "font.get_char_index", "self._fallback_font._get_glyph", "_log.info", "_log.warning", "self._get_font", "startswith", "get_font", "isinstance", "list", "isinstance", "self._get_glyph", "cbook._get_data_path", "BakomaFonts._fontmap.values", "unicodedata.category", "unicodedata.name"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 601, "end_line": 662}, "code_snippet": "    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        try:\n            uniindex = get_unicode_index(sym)\n            found_symbol = True\n        except ValueError:\n            uniindex = ord('?')\n            found_symbol = False\n            _log.warning(\"No TeX to Unicode mapping for %a.\", sym)\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                if (uniindex in self._cmr10_substitutions\n                        and font.family_name == \"cmr10\"):\n                    font = get_font(\n                        cbook._get_data_path(\"fonts/ttf/cmsy10.ttf\"))\n                    uniindex = self._cmr10_substitutions[uniindex]\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self._fallback_font:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self._fallback_font, StixFonts)):\n                    fontname = 'rm'\n\n                g = self._fallback_font._get_glyph(fontname, font_class, sym)\n                family = g[0].family_name\n                if family in list(BakomaFonts._fontmap.values()):\n                    family = \"Computer Modern\"\n                _log.info(\"Substituting symbol %s from %s\", sym, family)\n                return g\n\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym)\n                _log.warning(\"Font %r does not have a glyph for %a [U+%x], \"\n                             \"substituting with a dummy symbol.\",\n                             new_fontname, sym, uniindex)\n                font = self._get_font('rm')\n                uniindex = 0xA4  # currency char, for lack of anything better\n                slanted = False\n\n        return font, uniindex, slanted\n", "type": "function"}, {"name": "FontInfo", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 211, "end_line": 218}, "type": "class"}, {"name": "_get_font", "is_method": false, "class_name": null, "parameters": ["font_filepaths", "hinting_factor"], "calls": ["lru_cache", "_cached_realpath", "ft2font.FT2Font", "ft2font.FT2Font", "cbook._get_data_path", "font_filepaths.index", "font.set_charmap", "set_charmap", "fallback_list.append", "len", "ft2font.FT2Font"], "code_location": {"file": "font_manager.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1557, "end_line": 1589}, "code_snippet": "def _get_font(font_filepaths, hinting_factor, *, _kerning_factor, thread_id,\n              enable_last_resort):\n    first_fontpath, *rest = font_filepaths\n    fallback_list = [\n        ft2font.FT2Font(fpath, hinting_factor, _kerning_factor=_kerning_factor)\n        for fpath in rest\n    ]\n    last_resort_path = _cached_realpath(\n        cbook._get_data_path('fonts', 'ttf', 'LastResortHE-Regular.ttf'))\n    try:\n        last_resort_index = font_filepaths.index(last_resort_path)\n    except ValueError:\n        last_resort_index = -1\n        # Add Last Resort font so we always have glyphs regardless of font, unless we're\n        # already in the list.\n        if enable_last_resort:\n            fallback_list.append(\n                ft2font.FT2Font(last_resort_path, hinting_factor,\n                                _kerning_factor=_kerning_factor,\n                                _warn_if_used=True))\n            last_resort_index = len(fallback_list)\n    font = ft2font.FT2Font(\n        first_fontpath, hinting_factor,\n        _fallback_list=fallback_list,\n        _kerning_factor=_kerning_factor\n    )\n    # Ensure we are using the right charmap for the Last Resort font; FreeType picks the\n    # Unicode one by default, but this exists only for Windows, and is empty.\n    if last_resort_index == 0:\n        font.set_charmap(0)\n    elif last_resort_index > 0:\n        fallback_list[last_resort_index - 1].set_charmap(0)\n    return font\n", "type": "function"}, {"name": "postscript_name", "is_method": true, "class_name": "AFM", "parameters": ["self"], "calls": ["self.get_fontname"], "code_location": {"file": "_afm.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 420, "end_line": 421}, "code_snippet": "    def postscript_name(self):  # For consistency with FT2Font.\n        return self.get_fontname()\n", "type": "function"}, {"name": "_get_text_metrics_with_cache_impl", "is_method": false, "class_name": null, "parameters": ["renderer_ref", "text", "fontprop", "ismath", "dpi"], "calls": ["functools.lru_cache", "get_text_width_height_descent", "renderer_ref"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 74, "end_line": 77}, "code_snippet": "def _get_text_metrics_with_cache_impl(\n        renderer_ref, text, fontprop, ismath, dpi):\n    # dpi is unused, but participates in cache invalidation (via the renderer).\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "UnicodeFonts", "parameters": ["self", "default_font_prop", "load_glyph_flags"], "calls": ["get", "__init__", "split", "FontProperties", "findfont", "isinstance", "font_cls", "findfont", "stixsizedaltfonts.items", "super", "findfont"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 560, "end_line": 593}, "code_snippet": "    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        # This must come first so the backend's owner is set correctly\n        fallback_rc = mpl.rcParams['mathtext.fallback']\n        font_cls: type[TruetypeFonts] | None = {\n            'stix': StixFonts,\n            'stixsans': StixSansFonts,\n            'cm': BakomaFonts\n        }.get(fallback_rc)\n        self._fallback_font = (font_cls(default_font_prop, load_glyph_flags)\n                               if font_cls else None)\n\n        super().__init__(default_font_prop, load_glyph_flags)\n        for texfont in \"cal rm tt it bf sf bfit\".split():\n            prop = mpl.rcParams['mathtext.' + texfont]\n            font = findfont(prop)\n            self.fontmap[texfont] = font\n        prop = FontProperties('cmex10')\n        font = findfont(prop)\n        self.fontmap['ex'] = font\n\n        # include STIX sized alternatives for glyphs if fallback is STIX\n        if isinstance(self._fallback_font, StixFonts):\n            stixsizedaltfonts = {\n                 0: 'STIXGeneral',\n                 1: 'STIXSizeOneSym',\n                 2: 'STIXSizeTwoSym',\n                 3: 'STIXSizeThreeSym',\n                 4: 'STIXSizeFourSym',\n                 5: 'STIXSizeFiveSym'}\n\n            for size, name in stixsizedaltfonts.items():\n                fullpath = findfont(name)\n                self.fontmap[size] = fullpath\n                self.fontmap[name] = fullpath\n", "type": "function"}, {"name": "dviFontInfo", "is_method": true, "class_name": "PdfFile", "parameters": ["self"], "calls": ["_api.deprecated", "dviread.PsfontsMap", "self._dviFontInfo.items", "dviread.find_tex_file", "types.SimpleNamespace", "ValueError", "format"], "code_location": {"file": "backend_pdf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 771, "end_line": 789}, "code_snippet": "    def dviFontInfo(self):\n        d = {}\n        tex_font_map = dviread.PsfontsMap(dviread.find_tex_file('pdftex.map'))\n        for pdfname, dvifont in self._dviFontInfo.items():\n            psfont = tex_font_map[dvifont.texname]\n            if psfont.filename is None:\n                raise ValueError(\n                    \"No usable font file found for {} (TeX: {}); \"\n                    \"the font may lack a Type-1 version\"\n                    .format(psfont.psname, dvifont.texname))\n            d[dvifont.texname] = types.SimpleNamespace(\n                dvifont=dvifont,\n                pdfname=pdfname,\n                fontfile=psfont.filename,\n                basefont=psfont.psname,\n                encodingfile=psfont.encoding,\n                effects=psfont.effects,\n            )\n        return d\n", "type": "function"}, {"name": "FontMetrics", "docstring": "Metrics of a font.\n\nAttributes\n----------\nadvance : float\n    The advance distance (in points) of the glyph.\nheight : float\n    The height of the glyph in points.\nwidth : float\n    The width of the glyph in points.\nxmin, xmax, ymin, ymax : float\n    The ink rectangle of the glyph.\niceberg : float\n    The distance from the baseline to the top of the glyph. (This corresponds to\n    TeX's definition of \"height\".)\nslanted : bool\n    Whether the glyph should be considered as \"slanted\" (currently used for kerning\n    sub/superscripts).", "methods": [], "attributes": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 179, "end_line": 208}, "type": "class"}], "retrieved_count": 10, "cost_time": 0.3396787643432617}
{"question": "Why does the test_tricontourf_path function validate that the path generation algorithm correctly handles the topological distinction between simple polygons, boundary-following polygons, and polygons with holes, and what would be the consequences of the path code sequence [1, 2, 2, 2, 79] being incorrectly implemented in the underlying tricontourf rendering system?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_tricontourf_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["mtri.Triangulation", "plt.subplots", "ax.tricontourf", "cs.get_paths", "assert_array_almost_equal", "assert_array_equal", "assert_array_almost_equal", "ax.tricontourf", "cs.get_paths", "assert_array_almost_equal", "assert_array_equal", "assert_array_almost_equal", "ax.tricontourf", "cs.get_paths", "assert_array_almost_equal", "assert_array_equal", "assert_array_almost_equal", "len", "to_polygons", "len", "to_polygons", "len", "to_polygons", "np.split"], "code_location": {"file": "test_triangulation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1371, "end_line": 1403}, "code_snippet": "def test_tricontourf_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Polygon inside domain\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[0.5, 1.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon following boundary and inside domain\n    cs = ax.tricontourf(triang, [1, 0, 0, 0, 0], levels=[0.5, 1.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2], [0, 0], [2, 0]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon is outer boundary with hole\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[-0.5, 0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[0, 0], [4, 0], [4, 4], [0, 4], [0, 0],\n                         [1, 1], [1, 3], [3, 3], [3, 1], [1, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79, 1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), np.split(expected_vertices, [5]))\n", "type": "function"}, {"name": "test_tricontour_path", "is_method": false, "class_name": null, "parameters": [], "calls": ["mtri.Triangulation", "plt.subplots", "ax.tricontour", "cs.get_paths", "assert_array_almost_equal", "assert_array_equal", "assert_array_almost_equal", "ax.tricontour", "cs.get_paths", "assert_array_almost_equal", "assert_array_equal", "assert_array_almost_equal", "len", "to_polygons", "len", "to_polygons"], "code_location": {"file": "test_triangulation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1345, "end_line": 1368}, "code_snippet": "def test_tricontour_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Line strip from boundary to boundary\n    cs = ax.tricontour(triang, [1, 0, 0, 0, 0], levels=[0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2])\n    assert_array_almost_equal(\n        paths[0].to_polygons(closed_only=False), [expected_vertices])\n\n    # Closed line loop inside domain\n    cs = ax.tricontour(triang, [0, 0, 0, 0, 1], levels=[0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n", "type": "function"}, {"name": "test_contourf3d_fill", "is_method": false, "class_name": null, "parameters": [], "calls": ["mpl3d_image_comparison", "plt.figure", "fig.add_subplot", "np.meshgrid", "X.clip", "ax.contourf", "ax.set_xlim", "ax.set_ylim", "ax.set_zlim", "np.arange", "np.arange"], "code_location": {"file": "test_axes3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d/tests", "start_line": 263, "end_line": 275}, "code_snippet": "def test_contourf3d_fill():\n    plt.rcParams['axes3d.automargin'] = True  # Remove when image is regenerated\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n    X, Y = np.meshgrid(np.arange(-2, 2, 0.25), np.arange(-2, 2, 0.25))\n    Z = X.clip(0, 0)\n    # This produces holes in the z=0 surface that causes rendering errors if\n    # the Poly3DCollection is not aware of path code information (issue #4784)\n    Z[::5, ::5] = 0.1\n    ax.contourf(X, Y, Z, offset=0, levels=[-0.1, 0], cmap=\"coolwarm\")\n    ax.set_xlim(-2, 2)\n    ax.set_ylim(-2, 2)\n    ax.set_zlim(-1, 1)\n", "type": "function"}, {"name": "test_tricontourf", "is_method": true, "class_name": "TestDatetimePlotting", "parameters": ["self"], "calls": ["pytest.mark.xfail", "mpl.style.context", "plt.subplots", "ax.tricontourf"], "code_location": {"file": "test_datetime.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 797, "end_line": 799}, "code_snippet": "    def test_tricontourf(self):\n        fig, ax = plt.subplots()\n        ax.tricontourf(...)\n", "type": "function"}, {"name": "test_tricontourf_decreasing_levels", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.figure", "pytest.raises", "plt.tricontourf"], "code_location": {"file": "test_triangulation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1174, "end_line": 1181}, "code_snippet": "def test_tricontourf_decreasing_levels():\n    # github issue 5477.\n    x = [0.0, 1.0, 1.0]\n    y = [0.0, 0.0, 1.0]\n    z = [0.2, 0.4, 0.6]\n    plt.figure()\n    with pytest.raises(ValueError):\n        plt.tricontourf(x, y, z, [1.0, 0.0])\n", "type": "function"}, {"name": "test_path_no_doubled_point_in_to_polygon", "is_method": false, "class_name": null, "parameters": [], "calls": ["np.array", "Path", "transforms.Bbox", "np.all", "np.all", "to_polygons", "np.vstack", "poly.clip_to_bbox"], "code_location": {"file": "test_path.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 298, "end_line": 330}, "code_snippet": "def test_path_no_doubled_point_in_to_polygon():\n    hand = np.array(\n        [[1.64516129, 1.16145833],\n         [1.64516129, 1.59375],\n         [1.35080645, 1.921875],\n         [1.375, 2.18229167],\n         [1.68548387, 1.9375],\n         [1.60887097, 2.55208333],\n         [1.68548387, 2.69791667],\n         [1.76209677, 2.56770833],\n         [1.83064516, 1.97395833],\n         [1.89516129, 2.75],\n         [1.9516129, 2.84895833],\n         [2.01209677, 2.76041667],\n         [1.99193548, 1.99479167],\n         [2.11290323, 2.63020833],\n         [2.2016129, 2.734375],\n         [2.25403226, 2.60416667],\n         [2.14919355, 1.953125],\n         [2.30645161, 2.36979167],\n         [2.39112903, 2.36979167],\n         [2.41532258, 2.1875],\n         [2.1733871, 1.703125],\n         [2.07782258, 1.16666667]])\n\n    (r0, c0, r1, c1) = (1.0, 1.5, 2.1, 2.5)\n\n    poly = Path(np.vstack((hand[:, 1], hand[:, 0])).T, closed=True)\n    clip_rect = transforms.Bbox([[r0, c0], [r1, c1]])\n    poly_clipped = poly.clip_to_bbox(clip_rect).to_polygons()[0]\n\n    assert np.all(poly_clipped[-2] != poly_clipped[-1])\n    assert np.all(poly_clipped[-1] == poly_clipped[0])\n", "type": "function"}, {"name": "test_path_to_polygons", "is_method": false, "class_name": null, "parameters": [], "calls": ["Path", "assert_array_equal", "assert_array_equal", "assert_array_equal", "assert_array_equal", "Path", "assert_array_equal", "assert_array_equal", "assert_array_equal", "assert_array_equal", "p.to_polygons", "p.to_polygons", "p.to_polygons", "p.to_polygons", "p.to_polygons", "p.to_polygons", "p.to_polygons", "p.to_polygons"], "code_location": {"file": "test_path.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 333, "end_line": 351}, "code_snippet": "def test_path_to_polygons():\n    data = [[10, 10], [20, 20]]\n    p = Path(data)\n\n    assert_array_equal(p.to_polygons(width=40, height=40), [])\n    assert_array_equal(p.to_polygons(width=40, height=40, closed_only=False),\n                       [data])\n    assert_array_equal(p.to_polygons(), [])\n    assert_array_equal(p.to_polygons(closed_only=False), [data])\n\n    data = [[10, 10], [20, 20], [30, 30]]\n    closed_data = [[10, 10], [20, 20], [30, 30], [10, 10]]\n    p = Path(data)\n\n    assert_array_equal(p.to_polygons(width=40, height=40), [closed_data])\n    assert_array_equal(p.to_polygons(width=40, height=40, closed_only=False),\n                       [data])\n    assert_array_equal(p.to_polygons(), [closed_data])\n    assert_array_equal(p.to_polygons(closed_only=False), [data])\n", "type": "function"}, {"name": "test_interpolated_closepoly", "is_method": false, "class_name": null, "parameters": [], "calls": ["Path", "path.interpolated", "np.array", "np.testing.assert_allclose", "np.testing.assert_array_equal", "Path", "path.interpolated", "np.array", "np.concatenate", "np.testing.assert_allclose", "np.testing.assert_array_equal"], "code_location": {"file": "test_path.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 598, "end_line": 631}, "code_snippet": "def test_interpolated_closepoly():\n    codes = [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]\n    vertices = [(4, 3), (5, 4), (5, 3), (0, 0)]\n\n    path = Path(vertices, codes)\n    result = path.interpolated(2)\n\n    expected_vertices = np.array([[4, 3],\n                                  [4.5, 3.5],\n                                  [5, 4],\n                                  [5, 3.5],\n                                  [5, 3],\n                                  [4.5, 3],\n                                  [4, 3]])\n    expected_codes = [Path.MOVETO] + [Path.LINETO]*5 + [Path.CLOSEPOLY]\n\n    np.testing.assert_allclose(result.vertices, expected_vertices)\n    np.testing.assert_array_equal(result.codes, expected_codes)\n\n    # Usually closepoly is the last vertex but does not have to be.\n    codes += [Path.LINETO]\n    vertices += [(2, 1)]\n\n    path = Path(vertices, codes)\n    result = path.interpolated(2)\n\n    extra_expected_vertices = np.array([[3, 2],\n                                        [2, 1]])\n    expected_vertices = np.concatenate([expected_vertices, extra_expected_vertices])\n\n    expected_codes += [Path.LINETO] * 2\n\n    np.testing.assert_allclose(result.vertices, expected_vertices)\n    np.testing.assert_array_equal(result.codes, expected_codes)\n", "type": "function"}, {"name": "test_contour_set_paths", "is_method": false, "class_name": null, "parameters": ["fig_test", "fig_ref"], "calls": ["check_figures_equal", "contour", "contour", "cs_test.set_paths", "cs_ref.get_paths", "fig_test.subplots", "fig_ref.subplots"], "code_location": {"file": "test_contour.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 90, "end_line": 94}, "code_snippet": "def test_contour_set_paths(fig_test, fig_ref):\n    cs_test = fig_test.subplots().contour([[0, 1], [1, 2]])\n    cs_ref = fig_ref.subplots().contour([[1, 0], [2, 1]])\n\n    cs_test.set_paths(cs_ref.get_paths())\n", "type": "function"}, {"name": "test_tricontour_non_finite_z", "is_method": false, "class_name": null, "parameters": [], "calls": ["mtri.Triangulation", "plt.figure", "pytest.raises", "plt.tricontourf", "pytest.raises", "plt.tricontourf", "pytest.raises", "plt.tricontourf", "pytest.raises", "plt.tricontourf", "np.ma.array"], "code_location": {"file": "test_triangulation.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1286, "end_line": 1307}, "code_snippet": "def test_tricontour_non_finite_z():\n    # github issue 10167.\n    x = [0, 1, 0, 1]\n    y = [0, 0, 1, 1]\n    triang = mtri.Triangulation(x, y)\n    plt.figure()\n\n    with pytest.raises(ValueError, match='z array must not contain non-finite '\n                                         'values within the triangulation'):\n        plt.tricontourf(triang, [0, 1, 2, np.inf])\n\n    with pytest.raises(ValueError, match='z array must not contain non-finite '\n                                         'values within the triangulation'):\n        plt.tricontourf(triang, [0, 1, 2, -np.inf])\n\n    with pytest.raises(ValueError, match='z array must not contain non-finite '\n                                         'values within the triangulation'):\n        plt.tricontourf(triang, [0, 1, 2, np.nan])\n\n    with pytest.raises(ValueError, match='z must not contain masked points '\n                                         'within the triangulation'):\n        plt.tricontourf(triang, np.ma.array([0, 1, 2, 3], mask=[1, 0, 0, 0]))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34795117378234863}
{"question": "Where in the AxLine class is the coordinate transformation logic applied to reconcile between data coordinates and display coordinates before computing the line endpoints?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "get_transform", "is_method": true, "class_name": "AxLine", "parameters": ["self"], "calls": ["ax.transScale.transform", "points_transform.transform", "points_transform.transform", "np.isinf", "sorted", "BboxTransformTo", "ValueError", "Bbox"], "code_location": {"file": "lines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1499, "end_line": 1538}, "code_snippet": "    def get_transform(self):\n        ax = self.axes\n        points_transform = self._transform - ax.transData + ax.transScale\n\n        if self._xy2 is not None:\n            # two points were given\n            (x1, y1), (x2, y2) = \\\n                points_transform.transform([self._xy1, self._xy2])\n            dx = x2 - x1\n            dy = y2 - y1\n            if dx == 0:\n                if dy == 0:\n                    raise ValueError(\n                        f\"Cannot draw a line through two identical points \"\n                        f\"(x={(x1, x2)}, y={(y1, y2)})\")\n                slope = np.inf\n            else:\n                slope = dy / dx\n        else:\n            # one point and a slope were given\n            x1, y1 = points_transform.transform(self._xy1)\n            slope = self._slope\n        (vxlo, vylo), (vxhi, vyhi) = ax.transScale.transform(ax.viewLim)\n        # General case: find intersections with view limits in either\n        # direction, and draw between the middle two points.\n        if slope == 0:\n            start = vxlo, y1\n            stop = vxhi, y1\n        elif np.isinf(slope):\n            start = x1, vylo\n            stop = x1, vyhi\n        else:\n            _, start, stop, _ = sorted([\n                (vxlo, y1 + (vxlo - x1) * slope),\n                (vxhi, y1 + (vxhi - x1) * slope),\n                (x1 + (vylo - y1) / slope, vylo),\n                (x1 + (vyhi - y1) / slope, vyhi),\n            ])\n        return (BboxTransformTo(Bbox([start, stop]))\n                + ax.transLimits + ax.transAxes)\n", "type": "function"}, {"name": "get_line_transform", "is_method": true, "class_name": "FloatingAxisArtistHelper", "parameters": ["self", "axes"], "calls": [], "code_location": {"file": "grid_helper_curvelinear.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 268, "end_line": 269}, "code_snippet": "    def get_line_transform(self, axes):\n        return axes.transData\n", "type": "function"}, {"name": "get_line_transform", "is_method": true, "class_name": "_FixedAxisArtistHelperBase", "parameters": ["self", "axes"], "calls": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 137, "end_line": 138}, "code_snippet": "    def get_line_transform(self, axes):\n        return axes.transAxes\n", "type": "function"}, {"name": "get_line_transform", "is_method": true, "class_name": "FloatingAxisArtistHelperRectilinear", "parameters": ["self", "axes"], "calls": [], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 218, "end_line": 219}, "code_snippet": "    def get_line_transform(self, axes):\n        return axes.transAxes\n", "type": "function"}, {"name": "get_line", "is_method": true, "class_name": "FloatingAxisArtistHelperRectilinear", "parameters": ["self", "axes"], "calls": ["data_to_axes.transform", "Path", "self._to_xy"], "code_location": {"file": "axislines.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 212, "end_line": 216}, "code_snippet": "    def get_line(self, axes):\n        fixed_coord = 1 - self.nth_coord\n        data_to_axes = axes.transData - axes.transAxes\n        p = data_to_axes.transform([self._value, self._value])\n        return Path(self._to_xy((0, 1), const=p[fixed_coord]))\n", "type": "function"}, {"name": "test_line_extent_predata_transform_coords", "is_method": true, "class_name": "TestTransformPlotInterface", "parameters": ["self"], "calls": ["plt.axes", "ax.plot", "assert_array_equal", "scale", "ax.dataLim.get_points", "np.array", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 768, "end_line": 774}, "code_snippet": "    def test_line_extent_predata_transform_coords(self):\n        # a simple line in (offset + data) coordinates\n        ax = plt.axes()\n        trans = mtransforms.Affine2D().scale(10) + ax.transData\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[1., -50.], [12., 350.]]))\n", "type": "function"}, {"name": "_set_transform", "is_method": true, "class_name": "QuiverKey", "parameters": ["self"], "calls": ["self.Q.axes.get_figure", "self.set_transform", "_api.check_getitem"], "code_location": {"file": "quiver.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 407, "end_line": 414}, "code_snippet": "    def _set_transform(self):\n        fig = self.Q.axes.get_figure(root=False)\n        self.set_transform(_api.check_getitem({\n            \"data\": self.Q.axes.transData,\n            \"axes\": self.Q.axes.transAxes,\n            \"figure\": fig.transFigure,\n            \"inches\": fig.dpi_scale_trans,\n        }, coordinates=self.coord))\n", "type": "function"}, {"name": "_get_xy", "is_method": true, "class_name": "_AnnotationBase", "parameters": ["self", "renderer", "xy", "coords"], "calls": ["transform", "isinstance", "float", "float", "self.convert_xunits", "self.convert_yunits", "self._get_xy_transform"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1513, "end_line": 1520}, "code_snippet": "    def _get_xy(self, renderer, xy, coords):\n        x, y = xy\n        xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n        if xcoord == 'data':\n            x = float(self.convert_xunits(x))\n        if ycoord == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, coords).transform((x, y))\n", "type": "function"}, {"name": "_set_lim_and_transforms", "is_method": true, "class_name": "ParasiteAxesBase", "parameters": ["self"], "calls": ["mtransforms.blended_transform_factory", "mtransforms.blended_transform_factory", "_set_lim_and_transforms", "super"], "code_location": {"file": "parasite_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 45, "end_line": 54}, "code_snippet": "    def _set_lim_and_transforms(self):\n        if self.transAux is not None:\n            self.transAxes = self._parent_axes.transAxes\n            self.transData = self.transAux + self._parent_axes.transData\n            self._xaxis_transform = mtransforms.blended_transform_factory(\n                self.transData, self.transAxes)\n            self._yaxis_transform = mtransforms.blended_transform_factory(\n                self.transAxes, self.transData)\n        else:\n            super()._set_lim_and_transforms()\n", "type": "function"}, {"name": "test_line_extents_affine", "is_method": true, "class_name": "TestTransformPlotInterface", "parameters": ["self"], "calls": ["plt.axes", "translate", "plt.plot", "assert_array_almost_equal", "np.arange", "np.array", "ax.dataLim.get_points", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 786, "end_line": 791}, "code_snippet": "    def test_line_extents_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        plt.plot(np.arange(10), transform=offset + ax.transData)\n        expected_data_lim = np.array([[0., 0.], [9.,  9.]]) + 10\n        assert_array_almost_equal(ax.dataLim.get_points(), expected_data_lim)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34741997718811035}
{"question": "Where in the matplotlib codebase are the lower-level Colorbar initialization and rendering functions that test_colorbarbase delegates to when instantiating a Colorbar with a colormap?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_colorbarbase", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.gca", "Colorbar"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 317, "end_line": 320}, "code_snippet": "def test_colorbarbase():\n    # smoke test from #3805\n    ax = plt.gca()\n    Colorbar(ax, cmap=plt.colormaps[\"bone\"])\n", "type": "function"}, {"name": "Colorbar", "docstring": "Draw a colorbar in an existing Axes.\n\nTypically, colorbars are created using `.Figure.colorbar` or\n`.pyplot.colorbar` and associated with `.ColorizingArtist`\\s (such as an\n`.AxesImage` generated via `~.axes.Axes.imshow`).\n\nIn order to draw a colorbar not associated with other elements in the\nfigure, e.g. when showing a colormap by itself, one can create an empty\n`.ColorizingArtist`, or directly pass *cmap* and *norm* instead of *mappable*\nto `Colorbar`.\n\nUseful public methods are :meth:`set_label` and :meth:`add_lines`.\n\nAttributes\n----------\nax : `~matplotlib.axes.Axes`\n    The `~.axes.Axes` instance in which the colorbar is drawn.\nlines : list\n    A list of `.LineCollection` (empty if no lines were drawn).\ndividers : `.LineCollection`\n    A LineCollection (empty if *drawedges* is ``False``).", "methods": ["__init__", "long_axis", "locator", "locator", "minorlocator", "minorlocator", "formatter", "formatter", "minorformatter", "minorformatter", "_cbar_cla", "update_normal", "_draw_all", "_add_solids", "_update_dividers", "_add_solids_patches", "_do_extends", "add_lines", "update_ticks", "_get_ticker_locator_formatter", "set_ticks", "get_ticks", "set_ticklabels", "minorticks_on", "minorticks_off", "set_label", "set_alpha", "_set_scale", "remove", "_process_values", "_mesh", "_forward_boundaries", "_inverse_boundaries", "_reset_locator_formatter_scale", "_locate", "_uniform_y", "_proportional_y", "_get_extension_lengths", "_extend_lower", "_extend_upper", "_short_axis", "_get_view", "_set_view", "_set_view_from_bbox", "drag_pan"], "attributes": ["n_rasterize"], "code_location": {"file": "colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 198, "end_line": 1334}, "type": "class"}, {"name": "test_boundarynorm_and_colorbarbase", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "fig.add_axes", "fig.add_axes", "fig.add_axes", "mcolors.BoundaryNorm", "mcolorbar.ColorbarBase", "mcolors.BoundaryNorm", "mcolorbar.ColorbarBase", "mcolors.BoundaryNorm", "mcolorbar.ColorbarBase"], "code_location": {"file": "test_colors.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 855, "end_line": 881}, "code_snippet": "def test_boundarynorm_and_colorbarbase():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    # Make a figure and axes with dimensions as desired.\n    fig = plt.figure()\n    ax1 = fig.add_axes((0.05, 0.80, 0.9, 0.15))\n    ax2 = fig.add_axes((0.05, 0.475, 0.9, 0.15))\n    ax3 = fig.add_axes((0.05, 0.15, 0.9, 0.15))\n\n    # Set the colormap and bounds\n    bounds = [-1, 2, 5, 7, 12, 15]\n    cmap = mpl.colormaps['viridis']\n\n    # Default behavior\n    norm = mcolors.BoundaryNorm(bounds, cmap.N)\n    cb1 = mcolorbar.ColorbarBase(ax1, cmap=cmap, norm=norm, extend='both',\n                                 orientation='horizontal', spacing='uniform')\n    # New behavior\n    norm = mcolors.BoundaryNorm(bounds, cmap.N, extend='both')\n    cb2 = mcolorbar.ColorbarBase(ax2, cmap=cmap, norm=norm,\n                                 orientation='horizontal')\n\n    # User can still force to any extend='' if really needed\n    norm = mcolors.BoundaryNorm(bounds, cmap.N, extend='both')\n    cb3 = mcolorbar.ColorbarBase(ax3, cmap=cmap, norm=norm,\n                                 extend='neither', orientation='horizontal')\n", "type": "function"}, {"name": "test_colorbar_closed_patch", "is_method": false, "class_name": null, "parameters": [], "calls": ["image_comparison", "plt.figure", "fig.add_axes", "fig.add_axes", "fig.add_axes", "fig.add_axes", "fig.add_axes", "resampled", "ax1.pcolormesh", "np.linspace", "dict", "reshape", "rc_context", "plt.colorbar", "plt.colorbar", "plt.colorbar", "plt.colorbar", "np.linspace"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 330, "end_line": 357}, "code_snippet": "def test_colorbar_closed_patch():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    fig = plt.figure(figsize=(8, 6))\n    ax1 = fig.add_axes((0.05, 0.85, 0.9, 0.1))\n    ax2 = fig.add_axes((0.1, 0.65, 0.75, 0.1))\n    ax3 = fig.add_axes((0.05, 0.45, 0.9, 0.1))\n    ax4 = fig.add_axes((0.05, 0.25, 0.9, 0.1))\n    ax5 = fig.add_axes((0.05, 0.05, 0.9, 0.1))\n\n    cmap = mpl.colormaps[\"RdBu\"].resampled(5)\n\n    im = ax1.pcolormesh(np.linspace(0, 10, 16).reshape((4, 4)), cmap=cmap)\n\n    # The use of a \"values\" kwarg here is unusual.  It works only\n    # because it is matched to the data range in the image and to\n    # the number of colors in the LUT.\n    values = np.linspace(0, 10, 5)\n    cbar_kw = dict(orientation='horizontal', values=values, ticks=[])\n\n    # The wide line is to show that the closed path is being handled\n    # correctly.  See PR #4186.\n    with rc_context({'axes.linewidth': 16}):\n        plt.colorbar(im, cax=ax2, extend='both', extendfrac=0.5, **cbar_kw)\n        plt.colorbar(im, cax=ax3, extend='both', **cbar_kw)\n        plt.colorbar(im, cax=ax4, extend='both', extendrect=True, **cbar_kw)\n        plt.colorbar(im, cax=ax5, extend='neither', **cbar_kw)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "Colorbar", "parameters": ["self", "ax", "mappable"], "calls": ["isinstance", "mappable.callbacks.connect", "_get_orientation_from_location", "_api.check_in_list", "_api.check_in_list", "_api.check_in_list", "_ColorbarAxesLocator", "self.set_alpha", "_api.check_getitem", "self.ax.spines.values", "_ColorbarSpine", "collections.LineCollection", "self.ax.add_collection", "self.set_label", "self._reset_locator_formatter_scale", "np.iterable", "isinstance", "self._draw_all", "self.ax.callbacks.connect", "self.ax.callbacks.connect", "mcolorizer.Colorizer", "mcolorizer.ColorizingArtist", "cs.get_alpha", "isinstance", "spine.set_visible", "ticker.FixedLocator", "isinstance", "self.add_lines", "isinstance", "isinstance", "self.ax.set_navigate", "setattr", "ticker.FixedLocator", "mappable.get_alpha", "TypeError", "hasattr", "slice", "slice", "slice", "slice", "_get_ticklocation_from_orientation", "ticker.FormatStrFormatter", "self._formatter", "getattr", "isinstance", "getattr", "len", "ticker.StrMethodFormatter"], "code_location": {"file": "colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 225, "end_line": 428}, "code_snippet": "    def __init__(\n        self, ax, mappable=None, *,\n        alpha=None,\n        location=None,\n        extend=None,\n        extendfrac=None,\n        extendrect=False,\n        ticks=None,\n        format=None,\n        values=None,\n        boundaries=None,\n        spacing='uniform',\n        drawedges=False,\n        label='',\n        cmap=None, norm=None,  # redundant with *mappable*\n        orientation=None, ticklocation='auto',  # redundant with *location*\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The `~.axes.Axes` instance in which the colorbar is drawn.\n\n        mappable : `.ColorizingArtist`\n            The mappable whose colormap and norm will be used.\n\n            To show the colors versus index instead of on a 0-1 scale, set the\n            mappable's norm to ``colors.NoNorm()``.\n\n        alpha : float\n            The colorbar transparency between 0 (transparent) and 1 (opaque).\n\n        location : None or {'left', 'right', 'top', 'bottom'}\n            Set the colorbar's *orientation* and *ticklocation*. Colorbars on\n            the left and right are vertical, colorbars at the top and bottom\n            are horizontal. The *ticklocation* is the same as *location*, so if\n            *location* is 'top', the ticks are on the top. *orientation* and/or\n            *ticklocation* can be provided as well and overrides the value set by\n            *location*, but there will be an error for incompatible combinations.\n\n            .. versionadded:: 3.7\n\n        %(_colormap_kw_doc)s\n\n        Other Parameters\n        ----------------\n        cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            The colormap to use.  This parameter is ignored, unless *mappable* is\n            None.\n\n        norm : `~matplotlib.colors.Normalize`\n            The normalization to use.  This parameter is ignored, unless *mappable*\n            is None.\n\n        orientation : None or {'vertical', 'horizontal'}\n            If None, use the value determined by *location*. If both\n            *orientation* and *location* are None then defaults to 'vertical'.\n\n        ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}\n            The location of the colorbar ticks. The *ticklocation* must match\n            *orientation*. For example, a horizontal colorbar can only have ticks\n            at the top or the bottom. If 'auto', the ticks will be the same as\n            *location*, so a colorbar to the left will have ticks to the left. If\n            *location* is None, the ticks will be at the bottom for a horizontal\n            colorbar and at the right for a vertical.\n        \"\"\"\n        if mappable is None:\n            colorizer = mcolorizer.Colorizer(norm=norm, cmap=cmap)\n            mappable = mcolorizer.ColorizingArtist(colorizer)\n\n        self.mappable = mappable\n        cmap = mappable.cmap\n        norm = mappable.norm\n\n        filled = True\n        if isinstance(mappable, contour.ContourSet):\n            cs = mappable\n            alpha = cs.get_alpha()\n            boundaries = cs._levels\n            values = cs.cvalues\n            extend = cs.extend\n            filled = cs.filled\n            if ticks is None:\n                ticks = ticker.FixedLocator(cs.levels, nbins=10)\n        elif isinstance(mappable, martist.Artist):\n            alpha = mappable.get_alpha()\n\n        mappable.colorbar = self\n        mappable.colorbar_cid = mappable.callbacks.connect(\n            'changed', self.update_normal)\n\n        location_orientation = _get_orientation_from_location(location)\n\n        _api.check_in_list(\n            [None, 'vertical', 'horizontal'], orientation=orientation)\n        _api.check_in_list(\n            ['auto', 'left', 'right', 'top', 'bottom'],\n            ticklocation=ticklocation)\n        _api.check_in_list(\n            ['uniform', 'proportional'], spacing=spacing)\n\n        if location_orientation is not None and orientation is not None:\n            if location_orientation != orientation:\n                raise TypeError(\n                    \"location and orientation are mutually exclusive\")\n        else:\n            orientation = orientation or location_orientation or \"vertical\"\n\n        self.ax = ax\n        self.ax._axes_locator = _ColorbarAxesLocator(self)\n\n        if extend is None:\n            if (not isinstance(mappable, contour.ContourSet)\n                    and getattr(cmap, 'colorbar_extend', False) is not False):\n                extend = cmap.colorbar_extend\n            elif hasattr(norm, 'extend'):\n                extend = norm.extend\n            else:\n                extend = 'neither'\n        self.alpha = None\n        # Call set_alpha to handle array-like alphas properly\n        self.set_alpha(alpha)\n        self.cmap = cmap\n        self.norm = norm\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = _api.check_getitem(\n            {'neither': slice(0, None), 'both': slice(1, -1),\n             'min': slice(1, None), 'max': slice(0, -1)},\n            extend=extend)\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self._filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self._extend_patches = []\n        self.solids = None\n        self.solids_patches = []\n        self.lines = []\n\n        for spine in self.ax.spines.values():\n            spine.set_visible(False)\n        self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n\n        self.dividers = collections.LineCollection(\n            [],\n            colors=[mpl.rcParams['axes.edgecolor']],\n            linewidths=[0.5 * mpl.rcParams['axes.linewidth']],\n            clip_on=False)\n        self.ax.add_collection(self.dividers, autolim=False)\n\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n\n        if ticklocation == 'auto':\n            ticklocation = _get_ticklocation_from_orientation(\n                orientation) if location is None else location\n        self.ticklocation = ticklocation\n\n        self.set_label(label)\n        self._reset_locator_formatter_scale()\n\n        if np.iterable(ticks):\n            self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self._locator = ticks\n\n        if isinstance(format, str):\n            # Check format between FormatStrFormatter and StrMethodFormatter\n            try:\n                self._formatter = ticker.FormatStrFormatter(format)\n                _ = self._formatter(0)\n            except (TypeError, ValueError):\n                self._formatter = ticker.StrMethodFormatter(format)\n        else:\n            self._formatter = format  # Assume it is a Formatter or None\n        self._draw_all()\n\n        if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n            self.add_lines(mappable)\n\n        # Link the Axes and Colorbar for interactive use\n        self.ax._colorbar = self\n        # Don't navigate on any of these types of mappables\n        if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n                isinstance(self.mappable, contour.ContourSet)):\n            self.ax.set_navigate(False)\n\n        # These are the functions that set up interactivity on this colorbar\n        self._interactive_funcs = [\"_get_view\", \"_set_view\",\n                                   \"_set_view_from_bbox\", \"drag_pan\"]\n        for x in self._interactive_funcs:\n            setattr(self.ax, x, getattr(self, x))\n        # Set the cla function to the cbar's method to override it\n        self.ax.cla = self._cbar_cla\n        # Callbacks for the extend calculations to handle inverting the axis\n        self._extend_cid1 = self.ax.callbacks.connect(\n            \"xlim_changed\", self._do_extends)\n        self._extend_cid2 = self.ax.callbacks.connect(\n            \"ylim_changed\", self._do_extends)\n", "type": "function"}, {"name": "_init_locators", "is_method": true, "class_name": "ImageGrid", "parameters": ["self"], "calls": ["enumerate", "enumerate", "range", "self._divider.set_horizontal", "self._divider.set_vertical", "range", "set_axes_locator", "set_visible", "h_ax_pos.append", "h.append", "v_ax_pos.append", "v.append", "self._get_col_row", "self._divider.new_locator", "set_axes_locator", "_cbaraxes_class_factory", "get_figure", "self._divider.get_position", "range", "h.append", "h.append", "self._divider.new_locator", "set_visible", "h.append", "Size.AxesX", "Size.AxesX", "h_cb_pos.append", "h.append", "h.append", "len", "h.append", "h_cb_pos.append", "h.append", "v.append", "Size.AxesY", "Size.AxesY", "v_cb_pos.append", "v.append", "v.append", "len", "v.append", "v_cb_pos.append", "v.append", "set_axes_locator", "h.append", "h.append", "self._divider.new_locator", "range", "set_axes_locator", "set_visible", "range", "Size.AxesX", "Size.from_any", "Size.from_any", "v.append", "v.append", "self._divider.new_locator", "len", "Size.from_any", "Size.from_any", "Size.from_any", "len", "Size.from_any", "len", "Size.from_any", "Size.from_any", "Size.from_any", "len", "Size.from_any", "self._divider.new_locator", "Size.AxesX", "Size.from_any", "Size.from_any", "v.append", "v.append", "self._divider.new_locator", "set_visible", "set_visible", "range", "range", "range", "Size.AxesY", "Size.from_any", "Size.from_any", "self._divider.new_locator", "self._divider.new_locator", "set_axes_locator", "Size.AxesY", "Size.from_any", "Size.from_any", "set_visible", "set_visible", "set_visible", "set_position", "self._divider.new_locator", "set_axes_locator"], "code_location": {"file": "axes_grid.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "start_line": 403, "end_line": 561}, "code_snippet": "    def _init_locators(self):\n        # Slightly abusing this method to inject colorbar creation into init.\n\n        if self._colorbar_pad is None:\n            # horizontal or vertical arrangement?\n            if self._colorbar_location in (\"left\", \"right\"):\n                self._colorbar_pad = self._horiz_pad_size.fixed_size\n            else:\n                self._colorbar_pad = self._vert_pad_size.fixed_size\n        self.cbar_axes = [\n            _cbaraxes_class_factory(self._defaultAxesClass)(\n                self.axes_all[0].get_figure(root=False), self._divider.get_position(),\n                orientation=self._colorbar_location)\n            for _ in range(self.n_axes)]\n\n        cb_mode = self._colorbar_mode\n        cb_location = self._colorbar_location\n\n        h = []\n        v = []\n\n        h_ax_pos = []\n        h_cb_pos = []\n        if cb_mode == \"single\" and cb_location in (\"left\", \"bottom\"):\n            if cb_location == \"left\":\n                sz = self._nrows * Size.AxesX(self.axes_llc)\n                h.append(Size.from_any(self._colorbar_size, sz))\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                locator = self._divider.new_locator(nx=0, ny=0, ny1=-1)\n            elif cb_location == \"bottom\":\n                sz = self._ncols * Size.AxesY(self.axes_llc)\n                v.append(Size.from_any(self._colorbar_size, sz))\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                locator = self._divider.new_locator(nx=0, nx1=-1, ny=0)\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(False)\n            self.cbar_axes[0].set_axes_locator(locator)\n            self.cbar_axes[0].set_visible(True)\n\n        for col, ax in enumerate(self.axes_row[0]):\n            if col != 0:\n                h.append(self._horiz_pad_size)\n\n            if ax:\n                sz = Size.AxesX(ax, aspect=\"axes\", ref_ax=self.axes_all[0])\n            else:\n                sz = Size.AxesX(self.axes_all[0],\n                                aspect=\"axes\", ref_ax=self.axes_all[0])\n\n            if (cb_location == \"left\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and col == 0))):\n                h_cb_pos.append(len(h))\n                h.append(Size.from_any(self._colorbar_size, sz))\n                h.append(Size.from_any(self._colorbar_pad, sz))\n\n            h_ax_pos.append(len(h))\n            h.append(sz)\n\n            if (cb_location == \"right\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and col == self._ncols - 1))):\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                h_cb_pos.append(len(h))\n                h.append(Size.from_any(self._colorbar_size, sz))\n\n        v_ax_pos = []\n        v_cb_pos = []\n        for row, ax in enumerate(self.axes_column[0][::-1]):\n            if row != 0:\n                v.append(self._vert_pad_size)\n\n            if ax:\n                sz = Size.AxesY(ax, aspect=\"axes\", ref_ax=self.axes_all[0])\n            else:\n                sz = Size.AxesY(self.axes_all[0],\n                                aspect=\"axes\", ref_ax=self.axes_all[0])\n\n            if (cb_location == \"bottom\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and row == 0))):\n                v_cb_pos.append(len(v))\n                v.append(Size.from_any(self._colorbar_size, sz))\n                v.append(Size.from_any(self._colorbar_pad, sz))\n\n            v_ax_pos.append(len(v))\n            v.append(sz)\n\n            if (cb_location == \"top\"\n                    and (cb_mode == \"each\"\n                         or (cb_mode == \"edge\" and row == self._nrows - 1))):\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                v_cb_pos.append(len(v))\n                v.append(Size.from_any(self._colorbar_size, sz))\n\n        for i in range(self.n_axes):\n            col, row = self._get_col_row(i)\n            locator = self._divider.new_locator(nx=h_ax_pos[col],\n                                                ny=v_ax_pos[self._nrows-1-row])\n            self.axes_all[i].set_axes_locator(locator)\n\n            if cb_mode == \"each\":\n                if cb_location in (\"right\", \"left\"):\n                    locator = self._divider.new_locator(\n                        nx=h_cb_pos[col], ny=v_ax_pos[self._nrows - 1 - row])\n\n                elif cb_location in (\"top\", \"bottom\"):\n                    locator = self._divider.new_locator(\n                        nx=h_ax_pos[col], ny=v_cb_pos[self._nrows - 1 - row])\n\n                self.cbar_axes[i].set_axes_locator(locator)\n            elif cb_mode == \"edge\":\n                if (cb_location == \"left\" and col == 0\n                        or cb_location == \"right\" and col == self._ncols - 1):\n                    locator = self._divider.new_locator(\n                        nx=h_cb_pos[0], ny=v_ax_pos[self._nrows - 1 - row])\n                    self.cbar_axes[row].set_axes_locator(locator)\n                elif (cb_location == \"bottom\" and row == self._nrows - 1\n                      or cb_location == \"top\" and row == 0):\n                    locator = self._divider.new_locator(nx=h_ax_pos[col],\n                                                        ny=v_cb_pos[0])\n                    self.cbar_axes[col].set_axes_locator(locator)\n\n        if cb_mode == \"single\":\n            if cb_location == \"right\":\n                sz = self._nrows * Size.AxesX(self.axes_llc)\n                h.append(Size.from_any(self._colorbar_pad, sz))\n                h.append(Size.from_any(self._colorbar_size, sz))\n                locator = self._divider.new_locator(nx=-2, ny=0, ny1=-1)\n            elif cb_location == \"top\":\n                sz = self._ncols * Size.AxesY(self.axes_llc)\n                v.append(Size.from_any(self._colorbar_pad, sz))\n                v.append(Size.from_any(self._colorbar_size, sz))\n                locator = self._divider.new_locator(nx=0, nx1=-1, ny=-2)\n            if cb_location in (\"right\", \"top\"):\n                for i in range(self.n_axes):\n                    self.cbar_axes[i].set_visible(False)\n                self.cbar_axes[0].set_axes_locator(locator)\n                self.cbar_axes[0].set_visible(True)\n        elif cb_mode == \"each\":\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(True)\n        elif cb_mode == \"edge\":\n            if cb_location in (\"right\", \"left\"):\n                count = self._nrows\n            else:\n                count = self._ncols\n            for i in range(count):\n                self.cbar_axes[i].set_visible(True)\n            for j in range(i + 1, self.n_axes):\n                self.cbar_axes[j].set_visible(False)\n        else:\n            for i in range(self.n_axes):\n                self.cbar_axes[i].set_visible(False)\n                self.cbar_axes[i].set_position([1., 1., 0.001, 0.001],\n                                               which=\"active\")\n\n        self._divider.set_horizontal(h)\n        self._divider.set_vertical(v)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "_ColorbarSpine", "parameters": ["self", "axes"], "calls": ["__init__", "mpatches.Patch.set_transform", "mpath.Path", "super", "np.empty"], "code_location": {"file": "colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 126, "end_line": 129}, "code_snippet": "    def __init__(self, axes):\n        self._ax = axes\n        super().__init__(axes, 'colorbar', mpath.Path(np.empty((0, 2))))\n        mpatches.Patch.set_transform(self, axes.transAxes)\n", "type": "function"}, {"name": "test_colorbar_axes_parameters", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "imshow", "fig.colorbar", "fig.colorbar", "fig.colorbar", "fig.colorbar", "fig.colorbar", "fig.draw_without_rendering", "values", "enumerate"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1212, "end_line": 1221}, "code_snippet": "def test_colorbar_axes_parameters():\n    fig, ax = plt.subplots(2)\n    im = ax[0].imshow([[0, 1], [2, 3]])\n    # colorbar should accept any form of axes sequence:\n    fig.colorbar(im, ax=ax)\n    fig.colorbar(im, ax=ax[0])\n    fig.colorbar(im, ax=[_ax for _ax in ax])\n    fig.colorbar(im, ax=(ax[0], ax[1]))\n    fig.colorbar(im, ax={i: _ax for i, _ax in enumerate(ax)}.values())\n    fig.draw_without_rendering()\n", "type": "function"}, {"name": "test_colorbar_positioning", "is_method": false, "class_name": null, "parameters": ["use_gridspec"], "calls": ["pytest.mark.parametrize", "image_comparison", "reshape", "plt.figure", "plt.contourf", "plt.colorbar", "plt.figure", "enumerate", "plt.figure", "np.array", "np.repeat", "plt.contourf", "plt.contourf", "plt.contour", "plt.colorbar", "plt.colorbar", "plt.figure", "plt.subplot", "plt.contourf", "plt.subplot", "plt.contourf", "plt.subplot", "plt.contourf", "plt.colorbar", "plt.colorbar", "plt.colorbar", "plt.subplot", "plt.contourf", "plt.colorbar", "np.repeat", "np.arange"], "code_location": {"file": "test_colorbar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 163, "end_line": 214}, "code_snippet": "def test_colorbar_positioning(use_gridspec):\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    data = np.arange(1200).reshape(30, 40)\n    levels = [0, 200, 400, 600, 800, 1000, 1200]\n\n    # -------------------\n    plt.figure()\n    plt.contourf(data, levels=levels)\n    plt.colorbar(orientation='horizontal', use_gridspec=use_gridspec)\n\n    locations = ['left', 'right', 'top', 'bottom']\n    plt.figure()\n    for i, location in enumerate(locations):\n        plt.subplot(2, 2, i + 1)\n        plt.contourf(data, levels=levels)\n        plt.colorbar(location=location, use_gridspec=use_gridspec)\n\n    # -------------------\n    plt.figure()\n    # make some other data (random integers)\n    data_2nd = np.array([[2, 3, 2, 3], [1.5, 2, 2, 3], [2, 3, 3, 4]])\n    # make the random data expand to the shape of the main data\n    data_2nd = np.repeat(np.repeat(data_2nd, 10, axis=1), 10, axis=0)\n\n    color_mappable = plt.contourf(data, levels=levels, extend='both')\n    # test extend frac here\n    hatch_mappable = plt.contourf(data_2nd, levels=[1, 2, 3], colors='none',\n                                  hatches=['/', 'o', '+'], extend='max')\n    plt.contour(hatch_mappable, colors='black')\n\n    plt.colorbar(color_mappable, location='left', label='variable 1',\n                 use_gridspec=use_gridspec)\n    plt.colorbar(hatch_mappable, location='right', label='variable 2',\n                 use_gridspec=use_gridspec)\n\n    # -------------------\n    plt.figure()\n    ax1 = plt.subplot(211, anchor='NE', aspect='equal')\n    plt.contourf(data, levels=levels)\n    ax2 = plt.subplot(223)\n    plt.contourf(data, levels=levels)\n    ax3 = plt.subplot(224)\n    plt.contourf(data, levels=levels)\n\n    plt.colorbar(ax=[ax2, ax3, ax1], location='right', pad=0.0, shrink=0.5,\n                 panchor=False, use_gridspec=use_gridspec)\n    plt.colorbar(ax=[ax2, ax3, ax1], location='left', shrink=0.5,\n                 panchor=False, use_gridspec=use_gridspec)\n    plt.colorbar(ax=[ax1], location='bottom', panchor=False,\n                 anchor=(0.8, 0.5), shrink=0.6, use_gridspec=use_gridspec)\n", "type": "function"}, {"name": "colorbar", "is_method": false, "class_name": null, "parameters": ["mappable", "cax", "ax"], "calls": ["_copy_docstring_and_deprecators", "colorbar", "gci", "RuntimeError", "gcf"], "code_location": {"file": "pyplot.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2621, "end_line": 2635}, "code_snippet": "def colorbar(\n    mappable: ScalarMappable | ColorizingArtist | None = None,\n    cax: matplotlib.axes.Axes | None = None,\n    ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,\n    **kwargs\n) -> Colorbar:\n    if mappable is None:\n        mappable = gci()\n        if mappable is None:\n            raise RuntimeError('No mappable was found to use for colorbar '\n                               'creation. First define a mappable such as '\n                               'an image (with imshow) or a contour set ('\n                               'with contourf).')\n    ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n    return ret\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.33304595947265625}
{"question": "Where is the chain of responsibility that connects the add_toolitem method's position calculation logic through _get_tool_pos to the separator management in _groups, and how does this chain determine the final insertion index for tools?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "add_toolitem", "is_method": true, "class_name": "ToolbarWx", "parameters": ["self", "name", "group", "position", "image_file", "description", "toggle"], "calls": ["self.Realize", "self._toolitems.setdefault", "append", "self.InsertSeparator", "NavigationToolbar2Wx._icon", "self.InsertTool", "self.InsertControl", "self.trigger_tool", "self.Bind", "control.Bind", "self._get_tool_pos", "map", "self._get_tool_pos", "wx.ToggleButton", "wx.Button", "range", "t.IsSeparator", "self._get_tool_pos", "t.IsStretchableSpace", "self.GetTextExtent", "seps.index"], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1221, "end_line": 1264}, "code_snippet": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))\n", "type": "function"}, {"name": "_add_button", "is_method": true, "class_name": "ToolbarGTK4", "parameters": ["self", "button", "group", "position"], "calls": ["insert_child_after", "Gtk.Box", "self._tool_box.append", "self._find_child_at_position", "self._add_separator"], "code_location": {"file": "backend_gtk4.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 496, "end_line": 504}, "code_snippet": "    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n", "type": "function"}, {"name": "_add_to_group", "is_method": true, "class_name": "ToolbarQt", "parameters": ["self", "group", "name", "button", "position"], "calls": ["self._groups.get", "self.insertWidget", "gr.insert", "self.insertSeparator", "gr.append"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1012, "end_line": 1020}, "code_snippet": "    def _add_to_group(self, group, name, button, position):\n        gr = self._groups.get(group, [])\n        if not gr:\n            sep = self.insertSeparator(self._message_action)\n            gr.append(sep)\n        before = gr[position]\n        widget = self.insertWidget(before, button)\n        gr.insert(position, widget)\n        self._groups[group] = gr\n", "type": "function"}, {"name": "add_toolitem", "is_method": true, "class_name": "ToolbarGTK4", "parameters": ["self", "name", "group", "position", "image_file", "description", "toggle"], "calls": ["button.set_label", "button.add_css_class", "self._add_button", "button.connect", "button.set_tooltip_text", "self._toolitems.setdefault", "append", "Gtk.ToggleButton", "Gtk.Button", "Gtk.Image.new_from_gicon", "button.set_child", "button.add_css_class", "Gio.Icon.new_for_string"], "code_location": {"file": "backend_gtk4.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 464, "end_line": 486}, "code_snippet": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n", "type": "function"}, {"name": "_add_button", "is_method": true, "class_name": "ToolbarGTK3", "parameters": ["self", "button", "group", "position"], "calls": ["insert", "Gtk.Toolbar", "toolbar.set_style", "self.pack_start", "toolbar.show_all", "self._add_separator"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 440, "end_line": 449}, "code_snippet": "    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n", "type": "function"}, {"name": "_get_tool_pos", "is_method": true, "class_name": "ToolbarWx", "parameters": ["self", "tool"], "calls": ["range", "self.GetToolByPos"], "code_location": {"file": "backend_wx.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 1210, "end_line": 1219}, "code_snippet": "    def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = (pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool)\n        return pos\n", "type": "function"}, {"name": "add_toolitem", "is_method": true, "class_name": "ToolbarGTK3", "parameters": ["self", "name", "group", "position", "image_file", "description", "toggle"], "calls": ["button.set_label", "self._add_button", "button.connect", "button.set_tooltip_text", "button.show_all", "self._toolitems.setdefault", "append", "Gtk.ToggleToolButton", "Gtk.ToolButton", "Gtk.Image.new_from_gicon", "button.set_icon_widget", "Gio.Icon.new_for_string"], "code_location": {"file": "backend_gtk3.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 416, "end_line": 438}, "code_snippet": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n", "type": "function"}, {"name": "add_tool", "is_method": true, "class_name": "ToolContainerBase", "parameters": ["self", "tool", "group", "position"], "calls": ["self.toolmanager.get_tool", "self._get_image_filename", "self.add_toolitem", "getattr", "self.toolmanager.toolmanager_connect", "self.toggle_toolitem"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 3351, "end_line": 3374}, "code_snippet": "    def add_tool(self, tool, group, position=-1):\n        \"\"\"\n        Add a tool to this container.\n\n        Parameters\n        ----------\n        tool : tool_like\n            The tool to add, see `.ToolManager.get_tool`.\n        group : str\n            The name of the group to add this tool to.\n        position : int, default: -1\n            The position within the group to place this tool.\n        \"\"\"\n        tool = self.toolmanager.get_tool(tool)\n        image = self._get_image_filename(tool)\n        toggle = getattr(tool, 'toggled', None) is not None\n        self.add_toolitem(tool.name, group, position,\n                          image, tool.description, toggle)\n        if toggle:\n            self.toolmanager.toolmanager_connect('tool_trigger_%s' % tool.name,\n                                                 self._tool_toggled_cbk)\n            # If initially toggled\n            if tool.toggled:\n                self.toggle_toolitem(tool.name, True)\n", "type": "function"}, {"name": "add_toolitem", "is_method": true, "class_name": "ToolbarTk", "parameters": ["self", "name", "group", "position", "image_file", "description", "toggle"], "calls": ["self._get_groupframe", "frame.pack_slaves", "NavigationToolbar2Tk._Button", "button.pack_configure", "self._toolitems.setdefault", "append", "add_tooltip", "len", "self._button_click"], "code_location": {"file": "_backend_tk.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 997, "end_line": 1011}, "code_snippet": "    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n        frame = self._get_groupframe(group)\n        buttons = frame.pack_slaves()\n        if position >= len(buttons) or position < 0:\n            before = None\n        else:\n            before = buttons[position]\n        button = NavigationToolbar2Tk._Button(frame, name, image_file, toggle,\n                                              lambda: self._button_click(name))\n        button.pack_configure(before=before)\n        if description is not None:\n            add_tooltip(button, description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append(button)\n", "type": "function"}, {"name": "add_toolitem", "is_method": true, "class_name": "ToolbarQt", "parameters": ["self", "name", "group", "position", "image_file", "description", "toggle"], "calls": ["QtWidgets.QToolButton", "button.setText", "self._toolitems.setdefault", "self._add_to_group", "append", "button.setIcon", "button.setToolTip", "self.trigger_tool", "button.setCheckable", "button.toggled.connect", "button.clicked.connect", "NavigationToolbar2QT._icon"], "code_location": {"file": "backend_qt.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 990, "end_line": 1010}, "code_snippet": "    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.34421873092651367}
{"question": "Where is the NonAffineForTest class defined that is instantiated in the setup_method of TestBasicTransform?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "NonAffineForTest", "docstring": "A class which looks like a non affine transform, but does whatever\nthe given transform does (even if it is affine). This is very useful\nfor testing NonAffine behaviour with a simple Affine transform.", "methods": ["__init__", "transform_non_affine", "transform_path_non_affine"], "attributes": ["is_affine", "output_dims", "input_dims"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 579, "end_line": 598}, "type": "class"}, {"name": "test_non_affine_caching", "is_method": false, "class_name": null, "parameters": [], "calls": ["AssertingNonAffineTransform", "plt.axes", "plt.plot", "plt.draw", "ax.transAxes.invalidate", "plt.draw", "np.arange", "__init__", "scale", "self.underlying_transform.transform_path", "self.underlying_transform.transform", "super", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 370, "end_line": 405}, "code_snippet": "def test_non_affine_caching():\n    class AssertingNonAffineTransform(mtransforms.Transform):\n        \"\"\"\n        This transform raises an assertion error when called when it\n        shouldn't be and ``self.raise_on_transform`` is True.\n\n        \"\"\"\n        input_dims = output_dims = 2\n        is_affine = False\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.raise_on_transform = False\n            self.underlying_transform = mtransforms.Affine2D().scale(10, 10)\n\n        def transform_path_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform_path(path)\n        transform_path = transform_path_non_affine\n\n        def transform_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform(path)\n        transform = transform_non_affine\n\n    my_trans = AssertingNonAffineTransform()\n    ax = plt.axes()\n    plt.plot(np.arange(10), transform=my_trans + ax.transData)\n    plt.draw()\n    # enable the transform to raise an exception if it's non-affine transform\n    # method is triggered again.\n    my_trans.raise_on_transform = True\n    ax.transAxes.invalidate()\n    plt.draw()\n", "type": "function"}, {"name": "setup_method", "is_method": true, "class_name": "TestBasicTransform", "parameters": ["self"], "calls": ["rotate", "translate", "scale", "NonAffineForTest", "NonAffineForTest", "NonAffineForTest", "translate", "translate", "translate", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 602, "end_line": 620}, "code_snippet": "    def setup_method(self):\n\n        self.ta1 = mtransforms.Affine2D(shorthand_name='ta1').rotate(np.pi / 2)\n        self.ta2 = mtransforms.Affine2D(shorthand_name='ta2').translate(10, 0)\n        self.ta3 = mtransforms.Affine2D(shorthand_name='ta3').scale(1, 2)\n\n        self.tn1 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn1')\n        self.tn2 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn2')\n        self.tn3 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn3')\n\n        # creates a transform stack which looks like ((A, (N, A)), A)\n        self.stack1 = (self.ta1 + (self.tn1 + self.ta2)) + self.ta3\n        # creates a transform stack which looks like (((A, N), A), A)\n        self.stack2 = self.ta1 + self.tn1 + self.ta2 + self.ta3\n        # creates a transform stack which is a subset of stack2\n        self.stack2_subset = self.tn1 + self.ta2 + self.ta3\n", "type": "function"}, {"name": "test_resample_nonaffine", "is_method": false, "class_name": null, "parameters": ["data", "interpolation", "expected"], "calls": ["pytest.mark.parametrize", "scale", "np.empty_like", "mimage.resample", "assert_allclose", "np.empty_like", "mimage.resample", "assert_allclose", "NonAffineIdentityTransform", "Affine2D", "np.array", "np.array", "np.array", "np.array"], "code_location": {"file": "test_image.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 1652, "end_line": 1675}, "code_snippet": "def test_resample_nonaffine(data, interpolation, expected):\n    # Test that equivalent affine and nonaffine transforms resample the same\n\n    # Create a simple affine transform for scaling the input array\n    affine_transform = Affine2D().scale(sx=expected.shape[1] / data.shape[1], sy=1)\n\n    affine_result = np.empty_like(expected)\n    mimage.resample(data, affine_result, affine_transform, interpolation=interpolation)\n    assert_allclose(affine_result, expected)\n\n    # Create a nonaffine version of the same transform\n    # by compositing with a nonaffine identity transform\n    class NonAffineIdentityTransform(Transform):\n        input_dims = 2\n        output_dims = 2\n\n        def inverted(self):\n           return self\n    nonaffine_transform = NonAffineIdentityTransform() + affine_transform\n\n    nonaffine_result = np.empty_like(expected)\n    mimage.resample(data, nonaffine_result, nonaffine_transform,\n                    interpolation=interpolation)\n    assert_allclose(nonaffine_result, expected, atol=5e-3)\n", "type": "function"}, {"name": "test_transforms", "is_method": true, "class_name": "TestAsinhScale", "parameters": ["self"], "calls": ["np.linspace", "AsinhTransform", "forward.inverted", "inverse.inverted", "forward.transform_non_affine", "inverse.transform_non_affine", "assert_allclose", "invinv.transform_non_affine", "assert_allclose", "np.arcsinh"], "code_location": {"file": "test_scale.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 229, "end_line": 242}, "code_snippet": "    def test_transforms(self):\n        a0 = 17.0\n        a = np.linspace(-50, 50, 100)\n\n        forward = AsinhTransform(a0)\n        inverse = forward.inverted()\n        invinv = inverse.inverted()\n\n        a_forward = forward.transform_non_affine(a)\n        a_inverted = inverse.transform_non_affine(a_forward)\n        assert_allclose(a_inverted, a)\n\n        a_invinv = invinv.transform_non_affine(a)\n        assert_allclose(a_invinv, a0 * np.arcsinh(a / a0))\n", "type": "function"}, {"name": "test_line_extents_non_affine", "is_method": true, "class_name": "TestTransformPlotInterface", "parameters": ["self"], "calls": ["plt.axes", "translate", "NonAffineForTest", "plt.plot", "assert_array_almost_equal", "translate", "np.arange", "np.array", "ax.dataLim.get_points", "mtransforms.Affine2D", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 793, "end_line": 799}, "code_snippet": "    def test_line_extents_non_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        na_offset = NonAffineForTest(mtransforms.Affine2D().translate(10, 10))\n        plt.plot(np.arange(10), transform=offset + na_offset + ax.transData)\n        expected_data_lim = np.array([[0., 0.], [9.,  9.]]) + 20\n        assert_array_almost_equal(ax.dataLim.get_points(), expected_data_lim)\n", "type": "function"}, {"name": "test_affine_simplification", "is_method": true, "class_name": "TestBasicTransform", "parameters": ["self"], "calls": ["np.array", "self.stack1.transform_non_affine", "self.stack1.transform", "np.array", "np.array", "assert_array_almost_equal", "assert_array_almost_equal", "assert_array_almost_equal", "assert_array_almost_equal", "get_matrix", "get_matrix", "assert_array_equal", "get_matrix", "assert_array_equal", "self.stack1.transform_affine", "transform", "self.stack1.get_affine", "self.stack2.get_affine", "self.stack1.get_affine"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 703, "end_line": 738}, "code_snippet": "    def test_affine_simplification(self):\n        # tests that a transform stack only calls as much is absolutely\n        # necessary \"non-affine\" allowing the best possible optimization with\n        # complex transformation stacks.\n        points = np.array([[0, 0], [10, 20], [np.nan, 1], [-1, 0]],\n                          dtype=np.float64)\n        na_pts = self.stack1.transform_non_affine(points)\n        all_pts = self.stack1.transform(points)\n\n        na_expected = np.array([[1., 2.], [-19., 12.],\n                                [np.nan, np.nan], [1., 1.]], dtype=np.float64)\n        all_expected = np.array([[11., 4.], [-9., 24.],\n                                 [np.nan, np.nan], [11., 2.]],\n                                dtype=np.float64)\n\n        # check we have the expected results from doing the affine part only\n        assert_array_almost_equal(na_pts, na_expected)\n        # check we have the expected results from a full transformation\n        assert_array_almost_equal(all_pts, all_expected)\n        # check we have the expected results from doing the transformation in\n        # two steps\n        assert_array_almost_equal(self.stack1.transform_affine(na_pts),\n                                  all_expected)\n        # check that getting the affine transformation first, then fully\n        # transforming using that yields the same result as before.\n        assert_array_almost_equal(self.stack1.get_affine().transform(na_pts),\n                                  all_expected)\n\n        # check that the affine part of stack1 & stack2 are equivalent\n        # (i.e. the optimization is working)\n        expected_result = (self.ta2 + self.ta3).get_matrix()\n        result = self.stack1.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n        result = self.stack2.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n", "type": "function"}, {"name": "TestAffine2D", "docstring": "", "methods": ["test_init", "test_values", "test_modify_inplace", "test_clear", "test_rotate", "test_rotate_around", "test_scale", "test_skew", "test_translate", "test_rotate_plus_other", "test_rotate_around_plus_other", "test_scale_plus_other", "test_skew_plus_other", "test_translate_plus_other", "test_invalid_transform", "test_copy", "test_deepcopy"], "attributes": ["single_point", "multiple_points", "pivot"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 18, "end_line": 342}, "type": "class"}, {"name": "transform_non_affine", "is_method": true, "class_name": "NonAffineForTest", "parameters": ["self", "values"], "calls": ["self.real_trans.transform"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 594, "end_line": 595}, "code_snippet": "    def transform_non_affine(self, values):\n        return self.real_trans.transform(values)\n", "type": "function"}, {"name": "test_pathc_extents_non_affine", "is_method": true, "class_name": "TestTransformPlotInterface", "parameters": ["self"], "calls": ["plt.axes", "translate", "NonAffineForTest", "Path", "mpatches.PathPatch", "ax.add_patch", "assert_array_almost_equal", "translate", "np.array", "ax.dataLim.get_points", "mtransforms.Affine2D", "mtransforms.Affine2D"], "code_location": {"file": "test_transforms.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 801, "end_line": 810}, "code_snippet": "    def test_pathc_extents_non_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        na_offset = NonAffineForTest(mtransforms.Affine2D().translate(10, 10))\n        pth = Path([[0, 0], [0, 10], [10, 10], [10, 0]])\n        patch = mpatches.PathPatch(pth,\n                                   transform=offset + na_offset + ax.transData)\n        ax.add_patch(patch)\n        expected_data_lim = np.array([[0., 0.], [10.,  10.]]) + 20\n        assert_array_almost_equal(ax.dataLim.get_points(), expected_data_lim)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.33436012268066406}
{"question": "Where does the glyph lookup control flow in DejaVuSerifFonts traverse the fallback chain from the _fontmap dictionary through DejaVuFonts parent class to ultimately reach StixSerif when a glyph is not found?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "DejaVuSerifFonts", "docstring": "A font handling class for the DejaVu Serif fonts\n\nIf a glyph is not found it will fallback to Stix Serif", "methods": [], "attributes": ["_fontmap"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 713, "end_line": 728}, "type": "class"}, {"name": "DejaVuSansFonts", "docstring": "A font handling class for the DejaVu Sans fonts\n\nIf a glyph is not found it will fallback to Stix Sans", "methods": [], "attributes": ["_fontmap"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 731, "end_line": 746}, "type": "class"}, {"name": "__init__", "is_method": true, "class_name": "DejaVuFonts", "parameters": ["self", "default_font_prop", "load_glyph_flags"], "calls": ["isinstance", "BakomaFonts", "TruetypeFonts.__init__", "self._fontmap.update", "self._fontmap.items", "StixFonts", "StixSansFonts", "findfont"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 675, "end_line": 694}, "code_snippet": "    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        # This must come first so the backend's owner is set correctly\n        if isinstance(self, DejaVuSerifFonts):\n            self._fallback_font = StixFonts(default_font_prop, load_glyph_flags)\n        else:\n            self._fallback_font = StixSansFonts(default_font_prop, load_glyph_flags)\n        self.bakoma = BakomaFonts(default_font_prop, load_glyph_flags)\n        TruetypeFonts.__init__(self, default_font_prop, load_glyph_flags)\n        # Include Stix sized alternatives for glyphs\n        self._fontmap.update({\n            1: 'STIXSizeOneSym',\n            2: 'STIXSizeTwoSym',\n            3: 'STIXSizeThreeSym',\n            4: 'STIXSizeFourSym',\n            5: 'STIXSizeFiveSym',\n        })\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "BakomaFonts", "parameters": ["self", "default_font_prop", "load_glyph_flags"], "calls": ["StixFonts", "__init__", "self._fontmap.items", "findfont", "super"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 451, "end_line": 458}, "code_snippet": "    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        self._stix_fallback = StixFonts(default_font_prop, load_glyph_flags)\n\n        super().__init__(default_font_prop, load_glyph_flags)\n        for key, val in self._fontmap.items():\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath\n", "type": "function"}, {"name": "_get_glyph", "is_method": true, "class_name": "BakomaFonts", "parameters": ["self", "fontname", "font_class", "sym"], "calls": ["self._get_font", "self._stix_fallback._get_glyph", "len", "self._get_font", "font.get_char_index", "ord"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 462, "end_line": 477}, "code_snippet": "    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n        if font is not None and font.get_char_index(num) != 0:\n            return font, num, slanted\n        else:\n            return self._stix_fallback._get_glyph(fontname, font_class, sym)\n", "type": "function"}, {"name": "DejaVuSerifFontConstants", "docstring": "", "methods": [], "attributes": [], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 966, "end_line": 967}, "type": "class"}, {"name": "_get_glyph", "is_method": true, "class_name": "UnicodeFonts", "parameters": ["self", "fontname", "font_class", "sym"], "calls": ["self._map_virtual_font", "get_unicode_index", "self._get_font", "ord", "_log.warning", "chr", "font.get_char_index", "self._fallback_font._get_glyph", "_log.info", "_log.warning", "self._get_font", "startswith", "get_font", "isinstance", "list", "isinstance", "self._get_glyph", "cbook._get_data_path", "BakomaFonts._fontmap.values", "unicodedata.category", "unicodedata.name"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 601, "end_line": 662}, "code_snippet": "    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        try:\n            uniindex = get_unicode_index(sym)\n            found_symbol = True\n        except ValueError:\n            uniindex = ord('?')\n            found_symbol = False\n            _log.warning(\"No TeX to Unicode mapping for %a.\", sym)\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                if (uniindex in self._cmr10_substitutions\n                        and font.family_name == \"cmr10\"):\n                    font = get_font(\n                        cbook._get_data_path(\"fonts/ttf/cmsy10.ttf\"))\n                    uniindex = self._cmr10_substitutions[uniindex]\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self._fallback_font:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self._fallback_font, StixFonts)):\n                    fontname = 'rm'\n\n                g = self._fallback_font._get_glyph(fontname, font_class, sym)\n                family = g[0].family_name\n                if family in list(BakomaFonts._fontmap.values()):\n                    family = \"Computer Modern\"\n                _log.info(\"Substituting symbol %s from %s\", sym, family)\n                return g\n\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym)\n                _log.warning(\"Font %r does not have a glyph for %a [U+%x], \"\n                             \"substituting with a dummy symbol.\",\n                             new_fontname, sym, uniindex)\n                font = self._get_font('rm')\n                uniindex = 0xA4  # currency char, for lack of anything better\n                slanted = False\n\n        return font, uniindex, slanted\n", "type": "function"}, {"name": "UnicodeFonts", "docstring": "An abstract base class for handling Unicode fonts.\n\nWhile some reasonably complete Unicode fonts (such as DejaVu) may\nwork in some situations, the only Unicode font I'm aware of with a\ncomplete set of math symbols is STIX.\n\nThis class will \"fallback\" on the Bakoma fonts when a required\nsymbol cannot be found in the font.", "methods": ["__init__", "_map_virtual_font", "_get_glyph", "get_sized_alternatives_for_symbol"], "attributes": ["_cmr10_substitutions", "_slanted_symbols"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 540, "end_line": 669}, "type": "class"}, {"name": "_map_virtual_font", "is_method": true, "class_name": "StixFonts", "parameters": ["self", "fontname", "font_class", "uniindex"], "calls": ["stix_virtual_fonts.get", "isinstance", "isinstance", "len", "stix_glyph_fixes.get"], "code_location": {"file": "_mathtext.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 786, "end_line": 838}, "code_snippet": "    def _map_virtual_font(self, fontname: str, font_class: str,\n                          uniindex: int) -> tuple[str, int]:\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        font_mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and font_mapping is None\n                and fontname not in ('regular', 'default')):\n            font_mapping = stix_virtual_fonts['sf']\n            doing_sans_conversion = True\n        else:\n            doing_sans_conversion = False\n\n        if isinstance(font_mapping, dict):\n            try:\n                mapping = font_mapping[font_class]\n            except KeyError:\n                mapping = font_mapping['rm']\n        elif isinstance(font_mapping, list):\n            mapping = font_mapping\n        else:\n            mapping = None\n\n        if mapping is not None:\n            # Binary search for the source glyph\n            lo = 0\n            hi = len(mapping)\n            while lo < hi:\n                mid = (lo+hi)//2\n                range = mapping[mid]\n                if uniindex < range[0]:\n                    hi = mid\n                elif uniindex <= range[1]:\n                    break\n                else:\n                    lo = mid + 1\n\n            if range[0] <= uniindex <= range[1]:\n                uniindex = uniindex - range[0] + range[3]\n                fontname = range[2]\n            elif not doing_sans_conversion:\n                # This will generate a dummy character\n                uniindex = 0x1\n                fontname = mpl.rcParams['mathtext.default']\n\n        # Fix some incorrect glyphs.\n        if fontname in ('rm', 'it'):\n            uniindex = stix_glyph_fixes.get(uniindex, uniindex)\n\n        # Handle private use area glyphs\n        if fontname in ('it', 'rm', 'bf', 'bfit') and 0xe000 <= uniindex <= 0xf8ff:\n            fontname = 'nonuni' + fontname\n\n        return fontname, uniindex\n", "type": "function"}, {"name": "test__get_fontmap", "is_method": false, "class_name": null, "parameters": [], "calls": ["_gen_multi_font_text", "fm.get_font", "ft._get_fontmap", "fontmap.items", "fm.fontManager._find_fonts_by_props", "fm.FontProperties", "ord", "Path", "Path", "Path"], "code_location": {"file": "test_ft2font.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 897, "end_line": 913}, "code_snippet": "def test__get_fontmap():\n    fonts, test_str = _gen_multi_font_text()\n    # Add some glyphs that don't exist in either font to check the Last Resort fallback.\n    missing_glyphs = '\\n几个汉字'\n    test_str += missing_glyphs\n\n    ft = fm.get_font(\n        fm.fontManager._find_fonts_by_props(fm.FontProperties(family=fonts))\n    )\n    fontmap = ft._get_fontmap(test_str)\n    for char, font in fontmap.items():\n        if char in missing_glyphs:\n            assert Path(font.fname).name == 'LastResortHE-Regular.ttf'\n        elif ord(char) > 127:\n            assert Path(font.fname).name == 'DejaVuSans.ttf'\n        else:\n            assert Path(font.fname).name == 'cmr10.ttf'\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.353163480758667}
{"question": "Where does the conditional evaluation of tick visibility and orientation in _update_label determine the data flow path for computing axislabel_pad, and what is the consequence of the nested boolean condition on the major_ticks.get_tick_out() call?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_update_label", "is_method": true, "class_name": "AxisArtist", "parameters": ["self", "renderer"], "calls": ["self._axis_artist_helper.get_axislabel_pos_angle", "self.label.set", "self.label.get_visible", "max", "self.major_ticks.get_visible", "self.minor_ticks.get_visible", "self.major_ticks.get_tick_out", "self.major_ticks.get_tick_out"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 1005, "end_line": 1032}, "code_snippet": "    def _update_label(self, renderer):\n        if not self.label.get_visible():\n            return\n\n        if self._ticklabel_add_angle != self._axislabel_add_angle:\n            if ((self.major_ticks.get_visible()\n                 and not self.major_ticks.get_tick_out())\n                or (self.minor_ticks.get_visible()\n                    and not self.major_ticks.get_tick_out())):\n                axislabel_pad = self.major_ticks._ticksize\n            else:\n                axislabel_pad = 0\n        else:\n            axislabel_pad = max(self.major_ticklabels._axislabel_pad,\n                                self.minor_ticklabels._axislabel_pad)\n\n        self.label._external_pad = axislabel_pad\n\n        xy, angle_tangent = \\\n            self._axis_artist_helper.get_axislabel_pos_angle(self.axes)\n        if xy is None:\n            return\n\n        angle_label = angle_tangent - 90\n\n        x, y = xy\n        self.label._ref_angle = angle_label + self._axislabel_add_angle\n        self.label.set(x=x, y=y)\n", "type": "function"}, {"name": "_update_ticks", "is_method": true, "class_name": "AxisArtist", "parameters": ["self", "renderer"], "calls": ["renderer.points_to_pixels", "self._axis_artist_helper.get_tick_iterators", "self._get_tick_info", "self.major_ticks.set_locs_angles", "self.major_ticklabels.set_locs_angles_labels", "self._get_tick_info", "self.minor_ticks.set_locs_angles", "self.minor_ticklabels.set_locs_angles_labels", "_get_renderer", "self.major_ticks.get_visible", "self.major_ticks.get_tick_out", "self.get_figure"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 921, "end_line": 948}, "code_snippet": "    def _update_ticks(self, renderer=None):\n        # set extra pad for major and minor ticklabels: use ticksize of\n        # majorticks even for minor ticks. not clear what is best.\n\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        if self.major_ticks.get_visible() and self.major_ticks.get_tick_out():\n            ticklabel_pad = self.major_ticks._ticksize * dpi_cor\n            self.major_ticklabels._external_pad = ticklabel_pad\n            self.minor_ticklabels._external_pad = ticklabel_pad\n        else:\n            self.major_ticklabels._external_pad = 0\n            self.minor_ticklabels._external_pad = 0\n\n        majortick_iter, minortick_iter = \\\n            self._axis_artist_helper.get_tick_iterators(self.axes)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(majortick_iter)\n        self.major_ticks.set_locs_angles(tick_loc_angle)\n        self.major_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(minortick_iter)\n        self.minor_ticks.set_locs_angles(tick_loc_angle)\n        self.minor_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n", "type": "function"}, {"name": "update_position", "is_method": true, "class_name": "ThetaTick", "parameters": ["self", "loc"], "calls": ["update_position", "self.tick1line.get_marker", "self.tick2line.get_marker", "self.label1.set_rotation", "self.label2.set_rotation", "self._update_padding", "axes.get_theta_offset", "rotate", "rotate", "super", "axes.get_theta_direction", "np.rad2deg", "rotate", "rotate", "axes.get_theta_offset", "scale", "scale", "axes.get_theta_direction", "scale", "scale", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D", "mtransforms.Affine2D"], "code_location": {"file": "polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 331, "end_line": 375}, "code_snippet": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())\n", "type": "function"}, {"name": "_init_label", "is_method": true, "class_name": "AxisArtist", "parameters": ["self"], "calls": ["AxisLabel", "self.label.set_figure", "kwargs.get", "self.label.set_pad", "self._axis_artist_helper.get_axislabel_transform", "self.axes.get_figure", "kwargs.get"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 989, "end_line": 1003}, "code_snippet": "    def _init_label(self, **kwargs):\n        tr = (self._axis_artist_helper.get_axislabel_transform(self.axes)\n              + self.offset_transform)\n        self.label = AxisLabel(\n            0, 0, \"__from_axes__\",\n            color=\"auto\",\n            fontsize=kwargs.get(\"labelsize\", mpl.rcParams['axes.labelsize']),\n            fontweight=mpl.rcParams['axes.labelweight'],\n            axis=self.axis,\n            transform=tr,\n            axis_direction=self._axis_direction,\n        )\n        self.label.set_figure(self.axes.get_figure(root=False))\n        labelpad = kwargs.get(\"labelpad\", 5)\n        self.label.set_pad(labelpad)\n", "type": "function"}, {"name": "_update_label_position", "is_method": true, "class_name": "YAxis", "parameters": ["self", "renderer"], "calls": ["self._get_tick_boxes_siblings", "self.label.get_position", "mtransforms.Bbox.union", "self.label.set_position", "mtransforms.Bbox.union", "self.label.set_position", "get_window_extent", "get_window_extent", "self.axes.spines.get", "self.axes.spines.get", "self.get_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2674, "end_line": 2698}, "code_snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'left':\n            # Union with extents of the left spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"left\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x0 - self.labelpad * self.get_figure(root=True).dpi / 72, y))\n        else:\n            # Union with extents of the right spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"right\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x1 + self.labelpad * self.get_figure(root=True).dpi / 72, y))\n", "type": "function"}, {"name": "update_position", "is_method": true, "class_name": "RadialTick", "parameters": ["self", "loc"], "calls": ["update_position", "axes.get_thetamin", "axes.get_thetamax", "axes.get_theta_direction", "axes.get_theta_offset", "np.rad2deg", "_is_full_circle_deg", "self.label1.set_horizontalalignment", "self.label1.set_verticalalignment", "self.label1.set_rotation", "self.tick1line.get_marker", "self._determine_anchor", "self.label2.set_ha", "self.label2.set_va", "self.label2.set_rotation", "self.tick2line.get_marker", "self.label1.get_horizontalalignment", "self.label1.get_verticalalignment", "self._determine_anchor", "rotate", "self.label2.set_visible", "self.tick2line.set_visible", "np.deg2rad", "np.deg2rad", "rotate", "super", "np.deg2rad", "np.deg2rad", "rotate", "rotate", "mtransforms.Affine2D", "rotate", "mtransforms.Affine2D", "rotate", "mtransforms.Affine2D", "mtransforms.Affine2D", "axes.get_rlabel_position", "scale", "scale", "mtransforms.Affine2D", "mtransforms.Affine2D"], "code_location": {"file": "polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 586, "end_line": 664}, "code_snippet": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n", "type": "function"}, {"name": "_update_label_position", "is_method": true, "class_name": "XAxis", "parameters": ["self", "renderer"], "calls": ["self._get_tick_boxes_siblings", "self.label.get_position", "mtransforms.Bbox.union", "self.label.set_position", "mtransforms.Bbox.union", "self.label.set_position", "get_window_extent", "get_window_extent", "self.axes.spines.get", "self.axes.spines.get", "self.get_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2447, "end_line": 2471}, "code_snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'bottom':\n            # Union with extents of the bottom spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"bottom\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y0 - self.labelpad * self.get_figure(root=True).dpi / 72))\n        else:\n            # Union with extents of the top spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"top\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y1 + self.labelpad * self.get_figure(root=True).dpi / 72))\n", "type": "function"}, {"name": "_update_offsetText", "is_method": true, "class_name": "AxisArtist", "parameters": ["self"], "calls": ["self.offsetText.set_text", "self.offsetText.set_size", "self.axis.major.formatter.get_offset", "self.major_ticklabels.get_size", "self.major_ticklabels.get_pad", "self.major_ticklabels.get_size"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 977, "end_line": 983}, "code_snippet": "    def _update_offsetText(self):\n        self.offsetText.set_text(self.axis.major.formatter.get_offset())\n        self.offsetText.set_size(self.major_ticklabels.get_size())\n        offset = (self.major_ticklabels.get_pad()\n                  + self.major_ticklabels.get_size()\n                  + 2)\n        self.offsetText.xyann = (0, offset)\n", "type": "function"}, {"name": "_update_padding", "is_method": true, "class_name": "ThetaTick", "parameters": ["self", "pad", "angle"], "calls": ["self._text1_translate.invalidate", "self._text2_translate.invalidate", "np.cos", "np.sin"], "code_location": {"file": "polar.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/projections", "start_line": 323, "end_line": 329}, "code_snippet": "    def _update_padding(self, pad, angle):\n        padx = pad * np.cos(angle) / 72\n        pady = pad * np.sin(angle) / 72\n        self._text1_translate._t = (padx, pady)\n        self._text1_translate.invalidate()\n        self._text2_translate._t = (-padx, -pady)\n        self._text2_translate.invalidate()\n", "type": "function"}, {"name": "get_tick_padding", "is_method": true, "class_name": "Axis", "parameters": ["self"], "calls": ["len", "len", "max", "values.append", "values.append", "get_tick_padding", "get_tick_padding"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1391, "end_line": 1397}, "code_snippet": "    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3521149158477783}
{"question": "Where is the logic that determines how ticklabel offsets are calculated based on vertical and horizontal alignment properties, and which methods invoke this calculation during the rendering pipeline?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "_get_ticklabels_offsets", "is_method": true, "class_name": "TickLabels", "parameters": ["self", "renderer", "label_direction"], "calls": ["self.get_texts_widths_heights_descents", "self.get_va", "self.get_ha", "max", "max", "max", "max", "max", "max", "max", "max"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 459, "end_line": 513}, "code_snippet": "    def _get_ticklabels_offsets(self, renderer, label_direction):\n        \"\"\"\n        Calculate the ticklabel offsets from the tick and their total heights.\n\n        The offset only takes account the offset due to the vertical alignment\n        of the ticklabels: if axis direction is bottom and va is 'top', it will\n        return 0; if va is 'baseline', it will return (height-descent).\n        \"\"\"\n        whd_list = self.get_texts_widths_heights_descents(renderer)\n\n        if not whd_list:\n            return 0, 0\n\n        r = 0\n        va, ha = self.get_va(), self.get_ha()\n\n        if label_direction == \"left\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"left\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"right\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"right\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"bottom\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"bottom\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_ascent\n                pad = max_ascent + max_descent\n        elif label_direction == \"top\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"top\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_descent\n                pad = max_ascent + max_descent\n\n        # r : offset\n        # pad : total height of the ticklabels. This will be used to\n        # calculate the pad for the axislabel.\n        return r, pad\n", "type": "function"}, {"name": "_draw_offset_text", "is_method": true, "class_name": "Axis", "parameters": ["self", "renderer", "edgep1", "edgep2", "labeldeltas", "centers", "highs", "pep", "dx", "dy"], "calls": ["_move_from_center", "proj3d.proj_transform", "self.offsetText.set_text", "self.offsetText.set_position", "art3d._norm_text_angle", "self.offsetText.set_rotation", "self.offsetText.set_rotation_mode", "proj3d.proj_transform", "self.offsetText.set_va", "self.offsetText.set_ha", "self.offsetText.draw", "self._axmask", "self.major.formatter.get_offset", "np.rad2deg", "np.arctan2", "np.count_nonzero", "highs.tolist", "np.count_nonzero"], "code_location": {"file": "axis3d.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "start_line": 480, "end_line": 549}, "code_snippet": "    def _draw_offset_text(self, renderer, edgep1, edgep2, labeldeltas, centers,\n                          highs, pep, dx, dy):\n        # Get general axis information:\n        info = self._axinfo\n        index = info[\"i\"]\n        juggled = info[\"juggled\"]\n        tickdir = info[\"tickdir\"]\n\n        # Which of the two edge points do we want to\n        # use for locating the offset text?\n        if juggled[2] == 2:\n            outeredgep = edgep1\n            outerindex = 0\n        else:\n            outeredgep = edgep2\n            outerindex = 1\n\n        pos = _move_from_center(outeredgep, centers, labeldeltas,\n                                self._axmask())\n        olx, oly, olz = proj3d.proj_transform(*pos, self.axes.M)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.set_position((olx, oly))\n        angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy, dx)))\n        self.offsetText.set_rotation(angle)\n        # Must set rotation mode to \"anchor\" so that\n        # the alignment point is used as the \"fulcrum\" for rotation.\n        self.offsetText.set_rotation_mode('anchor')\n\n        # ----------------------------------------------------------------------\n        # Note: the following statement for determining the proper alignment of\n        # the offset text. This was determined entirely by trial-and-error\n        # and should not be in any way considered as \"the way\".  There are\n        # still some edge cases where alignment is not quite right, but this\n        # seems to be more of a geometry issue (in other words, I might be\n        # using the wrong reference points).\n        #\n        # (TT, FF, TF, FT) are the shorthand for the tuple of\n        #   (centpt[tickdir] <= pep[tickdir, outerindex],\n        #    centpt[index] <= pep[index, outerindex])\n        #\n        # Three-letters (e.g., TFT, FTT) are short-hand for the array of bools\n        # from the variable 'highs'.\n        # ---------------------------------------------------------------------\n        centpt = proj3d.proj_transform(*centers, self.axes.M)\n        if centpt[tickdir] > pep[tickdir, outerindex]:\n            # if FT and if highs has an even number of Trues\n            if (centpt[index] <= pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually, this means align right, except for the FTT case,\n                # in which offset for axis 1 and 2 are aligned left.\n                if highs.tolist() == [False, True, True] and index in (1, 2):\n                    align = 'left'\n                else:\n                    align = 'right'\n            else:\n                # The FF case\n                align = 'left'\n        else:\n            # if TF and if highs has an even number of Trues\n            if (centpt[index] > pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually mean align left, except if it is axis 2\n                align = 'right' if index == 2 else 'left'\n            else:\n                # The TT case\n                align = 'right'\n\n        self.offsetText.set_va('center')\n        self.offsetText.set_ha(align)\n        self.offsetText.draw(renderer)\n", "type": "function"}, {"name": "_update_offset_text_position", "is_method": true, "class_name": "Axis", "parameters": ["self", "bboxes", "bboxes2"], "calls": ["NotImplementedError"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2257, "end_line": 2262}, "code_snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset text position based on the sequence of bounding\n        boxes of all the ticklabels.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n", "type": "function"}, {"name": "_va_for_angle", "is_method": true, "class_name": "Text", "parameters": ["self", "angle"], "calls": ["self.get_horizontalalignment"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1412, "end_line": 1423}, "code_snippet": "    def _va_for_angle(self, angle):\n        \"\"\"\n        Determines vertical alignment ('va') for rotation_mode \"ytick\" based on\n        the angle of rotation in degrees and the horizontal alignment.\n        \"\"\"\n        anchor_at_left = self.get_horizontalalignment() == 'left'\n        if (angle <= 10 or 350 <= angle or 170 <= angle <= 190\n                or 80 <= angle <= 100 or 260 <= angle <= 280):\n            return 'center'\n        elif 190 < angle < 260 or 10 < angle < 80:\n            return 'baseline' if anchor_at_left else 'top'\n        return 'top' if anchor_at_left else 'baseline'\n", "type": "function"}, {"name": "_ha_for_angle", "is_method": true, "class_name": "Text", "parameters": ["self", "angle"], "calls": ["self.get_verticalalignment"], "code_location": {"file": "text.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1399, "end_line": 1410}, "code_snippet": "    def _ha_for_angle(self, angle):\n        \"\"\"\n        Determines horizontal alignment ('ha') for rotation_mode \"xtick\" based on\n        the angle of rotation in degrees and the vertical alignment.\n        \"\"\"\n        anchor_at_bottom = self.get_verticalalignment() == 'bottom'\n        if (angle <= 10 or 85 <= angle <= 95 or 350 <= angle or\n                170 <= angle <= 190 or 265 <= angle <= 275):\n            return 'center'\n        elif 10 < angle < 85 or 190 < angle < 265:\n            return 'left' if anchor_at_bottom else 'right'\n        return 'right' if anchor_at_bottom else 'left'\n", "type": "function"}, {"name": "_update_offset_text_position", "is_method": true, "class_name": "XAxis", "parameters": ["self", "bboxes", "bboxes2"], "calls": ["self.offsetText.get_position", "self.offsetText.set_position", "hasattr", "len", "mtransforms.Bbox.union", "len", "mtransforms.Bbox.union", "self.get_figure", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2473, "end_line": 2495}, "code_snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not hasattr(self, '_tick_position'):\n            self._tick_position = 'bottom'\n        if self._tick_position == 'bottom':\n            if not len(bboxes):\n                bottom = self.axes.bbox.ymin\n            else:\n                bbox = mtransforms.Bbox.union(bboxes)\n                bottom = bbox.y0\n            y = bottom - self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72\n        else:\n            if not len(bboxes2):\n                top = self.axes.bbox.ymax\n            else:\n                bbox = mtransforms.Bbox.union(bboxes2)\n                top = bbox.y1\n            y = top + self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72\n        self.offsetText.set_position((x, y))\n", "type": "function"}, {"name": "_update_offsetText", "is_method": true, "class_name": "AxisArtist", "parameters": ["self"], "calls": ["self.offsetText.set_text", "self.offsetText.set_size", "self.axis.major.formatter.get_offset", "self.major_ticklabels.get_size", "self.major_ticklabels.get_pad", "self.major_ticklabels.get_size"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 977, "end_line": 983}, "code_snippet": "    def _update_offsetText(self):\n        self.offsetText.set_text(self.axis.major.formatter.get_offset())\n        self.offsetText.set_size(self.major_ticklabels.get_size())\n        offset = (self.major_ticklabels.get_pad()\n                  + self.major_ticklabels.get_size()\n                  + 2)\n        self.offsetText.xyann = (0, offset)\n", "type": "function"}, {"name": "_update_label", "is_method": true, "class_name": "AxisArtist", "parameters": ["self", "renderer"], "calls": ["self._axis_artist_helper.get_axislabel_pos_angle", "self.label.set", "self.label.get_visible", "max", "self.major_ticks.get_visible", "self.minor_ticks.get_visible", "self.major_ticks.get_tick_out", "self.major_ticks.get_tick_out"], "code_location": {"file": "axis_artist.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "start_line": 1005, "end_line": 1032}, "code_snippet": "    def _update_label(self, renderer):\n        if not self.label.get_visible():\n            return\n\n        if self._ticklabel_add_angle != self._axislabel_add_angle:\n            if ((self.major_ticks.get_visible()\n                 and not self.major_ticks.get_tick_out())\n                or (self.minor_ticks.get_visible()\n                    and not self.major_ticks.get_tick_out())):\n                axislabel_pad = self.major_ticks._ticksize\n            else:\n                axislabel_pad = 0\n        else:\n            axislabel_pad = max(self.major_ticklabels._axislabel_pad,\n                                self.minor_ticklabels._axislabel_pad)\n\n        self.label._external_pad = axislabel_pad\n\n        xy, angle_tangent = \\\n            self._axis_artist_helper.get_axislabel_pos_angle(self.axes)\n        if xy is None:\n            return\n\n        angle_label = angle_tangent - 90\n\n        x, y = xy\n        self.label._ref_angle = angle_label + self._axislabel_add_angle\n        self.label.set(x=x, y=y)\n", "type": "function"}, {"name": "_text_shift", "is_method": true, "class_name": "QuiverKey", "parameters": ["self"], "calls": [], "code_location": {"file": "quiver.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 390, "end_line": 396}, "code_snippet": "    def _text_shift(self):\n        return {\n            \"N\": (0, +self.labelsep),\n            \"S\": (0, -self.labelsep),\n            \"E\": (+self.labelsep, 0),\n            \"W\": (-self.labelsep, 0),\n        }[self.labelpos]\n", "type": "function"}, {"name": "_update_offset_text_position", "is_method": true, "class_name": "YAxis", "parameters": ["self", "bboxes", "bboxes2"], "calls": ["self.offsetText.get_position", "self.offsetText.set_position", "get_window_extent", "self.get_figure"], "code_location": {"file": "axis.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2700, "end_line": 2714}, "code_snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, _ = self.offsetText.get_position()\n        if 'outline' in self.axes.spines:\n            # Special case for colorbars:\n            bbox = self.axes.spines['outline'].get_window_extent()\n        else:\n            bbox = self.axes.bbox\n        top = bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72)\n        )\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3333578109741211}
{"question": "Where does the cycler property cycle mechanism propagate through the data flow when ax.plot() is called multiple times, and what control flow ensures that the linestyle values are correctly sequenced across successive plot invocations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_property_collision_plot", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "range", "range", "ax.plot", "ax.plot", "ax.plot", "l.get_linewidth"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 85, "end_line": 93}, "code_snippet": "def test_property_collision_plot():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle('linewidth', [2, 4])\n    t = range(10)\n    for c in range(1, 4):\n        ax.plot(t, t, lw=0.1)\n    ax.plot(t, t)\n    ax.plot(t, t)\n    assert [l.get_linewidth() for l in ax.lines] == [0.1, 0.1, 0.1, 2, 4]\n", "type": "function"}, {"name": "test_linestylecycle_basic", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "range", "cycler", "ax.plot", "range", "range", "l.get_linestyle"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 45, "end_line": 50}, "code_snippet": "def test_linestylecycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('ls', ['-', '--', ':']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_linestyle() for l in ax.lines] == ['-', '--', ':', '-']\n", "type": "function"}, {"name": "set_prop_cycle", "is_method": true, "class_name": "_process_plot_var_args", "parameters": ["self", "cycler"], "calls": ["mpl._val_or_rc"], "code_location": {"file": "_base.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/axes", "start_line": 222, "end_line": 224}, "code_snippet": "    def set_prop_cycle(self, cycler):\n        self._idx = 0\n        self._cycler_items = [*mpl._val_or_rc(cycler, 'axes.prop_cycle')]\n", "type": "function"}, {"name": "test_cycler", "is_method": false, "class_name": null, "parameters": [], "calls": ["add_subplot", "ax.set_prop_cycle", "ax.plot", "pickle.loads", "ax.plot", "pickle.dumps", "l.get_color", "plt.figure"], "code_location": {"file": "test_pickle.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 313, "end_line": 319}, "code_snippet": "def test_cycler():\n    ax = plt.figure().add_subplot()\n    ax.set_prop_cycle(c=[\"c\", \"m\", \"y\", \"k\"])\n    ax.plot([1, 2])\n    ax = pickle.loads(pickle.dumps(ax))\n    l, = ax.plot([3, 4])\n    assert l.get_color() == \"m\"\n", "type": "function"}, {"name": "test_cycle_reset", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "StringIO", "StringIO", "StringIO", "ax.set_prop_cycle", "ax.set_prop_cycle", "contextlib.redirect_stdout", "plt.getp", "contextlib.redirect_stdout", "plt.getp", "prop1.getvalue", "prop0.getvalue", "contextlib.redirect_stdout", "plt.getp", "prop2.getvalue", "prop0.getvalue", "ax.plot", "ax.plot", "ax.plot"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 129, "end_line": 146}, "code_snippet": "def test_cycle_reset():\n    fig, ax = plt.subplots()\n    prop0 = StringIO()\n    prop1 = StringIO()\n    prop2 = StringIO()\n\n    with contextlib.redirect_stdout(prop0):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n\n    ax.set_prop_cycle(linewidth=[10, 9, 4])\n    with contextlib.redirect_stdout(prop1):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop1.getvalue() != prop0.getvalue()\n\n    ax.set_prop_cycle(None)\n    with contextlib.redirect_stdout(prop2):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop2.getvalue() == prop0.getvalue()\n", "type": "function"}, {"name": "test_marker_cycle", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "range", "ax.plot", "cycler", "cycler", "range", "range", "l.get_color", "l.get_marker"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 20, "end_line": 27}, "code_snippet": "def test_marker_cycle():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('c', ['r', 'g', 'y']) +\n                      cycler('marker', ['.', '*', 'x']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_color() for l in ax.lines] == ['r', 'g', 'y', 'r']\n    assert [l.get_marker() for l in ax.lines] == ['.', '*', 'x', '.']\n", "type": "function"}, {"name": "test_property_collision_fill", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "range", "range", "ax.fill", "ax.fill", "ax.fill", "p.get_facecolor", "mpl.colors.to_rgba", "p.get_linewidth"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 96, "end_line": 106}, "code_snippet": "def test_property_collision_fill():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(linewidth=[2, 3, 4, 5, 6], facecolor='bgcmy')\n    t = range(10)\n    for c in range(1, 4):\n        ax.fill(t, t, lw=0.1)\n    ax.fill(t, t)\n    ax.fill(t, t)\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in 'bgcmy'])\n    assert [p.get_linewidth() for p in ax.patches] == [0.1, 0.1, 0.1, 5, 6]\n", "type": "function"}, {"name": "test_fillcycle_basic", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "range", "ax.fill", "cycler", "range", "range", "p.get_facecolor", "mpl.colors.to_rgba", "p.get_hatch", "p.get_linestyle", "cycler", "cycler"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 53, "end_line": 63}, "code_snippet": "def test_fillcycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('c',  ['r', 'g', 'y']) +\n                      cycler('hatch', ['xx', 'O', '|-']) +\n                      cycler('linestyle', ['-', '--', ':']))\n    for _ in range(4):\n        ax.fill(range(10), range(10))\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in ['r', 'g', 'y', 'r']])\n    assert [p.get_hatch() for p in ax.patches] == ['xx', 'O', '|-', 'xx']\n    assert [p.get_linestyle() for p in ax.patches] == ['-', '--', ':', '-']\n", "type": "function"}, {"name": "test_valid_marker_cycles", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "ax.set_prop_cycle", "cycler"], "code_location": {"file": "test_cycles.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 30, "end_line": 32}, "code_snippet": "def test_valid_marker_cycles():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler(marker=[1, \"+\", \".\", 4]))\n", "type": "function"}, {"name": "test_errorbar_colorcycle", "is_method": false, "class_name": null, "parameters": [], "calls": ["plt.subplots", "np.arange", "ax.errorbar", "ax.errorbar", "ax.plot", "mcolors.to_rgba", "mcolors.to_rgba", "mcolors.to_rgba", "mcolors.to_rgba", "mcolors.to_rgba", "mcolors.to_rgba", "e1.get_color", "e2.get_color", "ln1.get_color"], "code_location": {"file": "test_axes.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 4378, "end_line": 4390}, "code_snippet": "def test_errorbar_colorcycle():\n\n    f, ax = plt.subplots()\n    x = np.arange(10)\n    y = 2*x\n\n    e1, _, _ = ax.errorbar(x, y, c=None)\n    e2, _, _ = ax.errorbar(x, 2*y, c=None)\n    ln1, = ax.plot(x, 4*y)\n\n    assert mcolors.to_rgba(e1.get_color()) == mcolors.to_rgba('C0')\n    assert mcolors.to_rgba(e2.get_color()) == mcolors.to_rgba('C1')\n    assert mcolors.to_rgba(ln1.get_color()) == mcolors.to_rgba('C2')\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.33870697021484375}
{"question": "Where in the codebase are the lower-level helper functions that test_pdflatex delegates to for configuring the PGF backend and rendering the test figure?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_pdflatex", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.skipif", "pytest.mark.skipif", "pytest.mark.backend", "image_comparison", "mpl.rcParams.update", "create_figure", "_has_tex_package", "_has_tex_package"], "code_location": {"file": "test_backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 103, "end_line": 110}, "code_snippet": "def test_pdflatex():\n    rc_pdflatex = {'font.family': 'serif',\n                   'pgf.rcfonts': False,\n                   'pgf.texsystem': 'pdflatex',\n                   'pgf.preamble': ('\\\\usepackage[utf8x]{inputenc}'\n                                    '\\\\usepackage[T1]{fontenc}')}\n    mpl.rcParams.update(rc_pdflatex)\n    create_figure()\n", "type": "function"}, {"name": "_build_latex_header", "is_method": true, "class_name": "LatexManager", "parameters": [], "calls": ["join", "_get_preamble"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 206, "end_line": 218}, "code_snippet": "    def _build_latex_header():\n        latex_header = [\n            _DOCUMENTCLASS,\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            _get_preamble(),\n            r\"\\begin{document}\",\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n", "type": "function"}, {"name": "_run_latex", "is_method": true, "class_name": "PdfPages", "parameters": ["self"], "calls": ["TemporaryDirectory", "pathlib.Path", "tex_source.write_bytes", "cbook._check_and_log_subprocess", "shutil.move", "self._file.getvalue", "tex_source.with_suffix"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 961, "end_line": 970}, "code_snippet": "    def _run_latex(self):\n        texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        with TemporaryDirectory() as tmpdir:\n            tex_source = pathlib.Path(tmpdir, \"pdf_pages.tex\")\n            tex_source.write_bytes(self._file.getvalue())\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 tex_source],\n                _log, cwd=tmpdir)\n            shutil.move(tex_source.with_suffix(\".pdf\"), self._output_name)\n", "type": "function"}, {"name": "test_xelatex", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "image_comparison", "mpl.rcParams.update", "create_figure"], "code_location": {"file": "test_backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 82, "end_line": 86}, "code_snippet": "def test_xelatex():\n    rc_xelatex = {'font.family': 'serif',\n                  'pgf.rcfonts': False}\n    mpl.rcParams.update(rc_xelatex)\n    create_figure()\n", "type": "function"}, {"name": "_print_pgf_to_fh", "is_method": true, "class_name": "FigureCanvasPgf", "parameters": ["self", "fh"], "calls": ["splitlines", "header_info_preamble.append", "join", "fh.write", "fh.write", "fh.write", "_writeln", "_writeln", "_writeln", "_writeln", "_writeln", "MixedModeRenderer", "self.figure.draw", "_writeln", "_writeln", "_writeln", "header_info_preamble.append", "self.figure.get_figwidth", "self.figure.get_figheight", "RendererPgf", "_get_preamble"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 757, "end_line": 811}, "code_snippet": "    def _print_pgf_to_fh(self, fh, *, bbox_inches_restore=None):\n\n        header_text = \"\"\"%% Creator: Matplotlib, PGF backend\n%%\n%% To include the figure in your LaTeX document, write\n%%   \\\\input{<filename>.pgf}\n%%\n%% Make sure the required packages are loaded in your preamble\n%%   \\\\usepackage{pgf}\n%%\n%% Also ensure that all the required font packages are loaded; for instance,\n%% the lmodern package is sometimes necessary when using math font.\n%%   \\\\usepackage{lmodern}\n%%\n%% Figures using additional raster images can only be included by \\\\input if\n%% they are in the same directory as the main LaTeX file. For loading figures\n%% from other directories you can use the `import` package\n%%   \\\\usepackage{import}\n%%\n%% and then include the figures with\n%%   \\\\import{<path to file>}{<filename>.pgf}\n%%\n\"\"\"\n\n        # append the preamble used by the backend as a comment for debugging\n        header_info_preamble = [\"%% Matplotlib used the following preamble\"]\n        for line in _get_preamble().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        header_info_preamble.append(\"%%\")\n        header_info_preamble = \"\\n\".join(header_info_preamble)\n\n        # get figure size in inch\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n        dpi = self.figure.dpi\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        _writeln(fh, r\"\\begingroup\")\n        _writeln(fh, r\"\\makeatletter\")\n        _writeln(fh, r\"\\begin{pgfpicture}\")\n        _writeln(fh,\n                 r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\"\n                 % (w, h))\n        _writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        _writeln(fh, r\"\\end{pgfpicture}\")\n        _writeln(fh, r\"\\makeatother\")\n        _writeln(fh, r\"\\endgroup\")\n", "type": "function"}, {"name": "_setup_latex_process", "is_method": true, "class_name": "LatexManager", "parameters": ["self"], "calls": ["weakref.finalize", "self._stdin_writeln", "subprocess.Popen", "latex.kill", "self._build_latex_header", "self._expect", "self._expect_prompt", "RuntimeError", "RuntimeError", "latex.communicate", "latex.wait"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 276, "end_line": 309}, "code_snippet": "    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with or `wait()` on\n        # it.\n        try:\n            self.latex = subprocess.Popen(\n                [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{mpl.rcParams['pgf.texsystem']!r} not found; install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX implementation\"\n            ) from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting {mpl.rcParams['pgf.texsystem']!r}\") from err\n\n        def finalize_latex(latex):\n            latex.kill()\n            try:\n                latex.communicate()\n            except RuntimeError:\n                latex.wait()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        if expect_reply:  # read until 'pgf_backend_query_start' token appears\n            self._expect(\"*pgf_backend_query_start\")\n            self._expect_prompt()\n", "type": "function"}, {"name": "test_mixedmode", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.mark.backend", "image_comparison", "mpl.rcParams.update", "set_rasterized", "plt.pcolor"], "code_location": {"file": "test_backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 169, "end_line": 172}, "code_snippet": "def test_mixedmode():\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    Y, X = np.ogrid[-1:1:40j, -1:1:40j]\n    plt.pcolor(X**2 + Y**2).set_rasterized(True)\n", "type": "function"}, {"name": "get_renderer", "is_method": true, "class_name": "FigureCanvasPgf", "parameters": ["self"], "calls": ["RendererPgf"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 869, "end_line": 870}, "code_snippet": "    def get_renderer(self):\n        return RendererPgf(self.figure, None)\n", "type": "function"}, {"name": "print_png", "is_method": true, "class_name": "FigureCanvasPgf", "parameters": ["self", "fname_or_fh"], "calls": ["make_pdf_to_png_converter", "TemporaryDirectory", "pathlib.Path", "self.print_pdf", "converter", "png_path.open", "cbook.open_file_cm", "shutil.copyfileobj"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 856, "end_line": 867}, "code_snippet": "    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with (png_path.open(\"rb\") as orig,\n                  cbook.open_file_cm(fname_or_fh, \"wb\") as dest):\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n", "type": "function"}, {"name": "print_pdf", "is_method": true, "class_name": "FigureCanvasPgf", "parameters": ["self", "fname_or_fh"], "calls": ["self.figure.get_size_inches", "_create_pdf_info_dict", "join", "TemporaryDirectory", "pathlib.Path", "self.print_pgf", "write_text", "cbook._check_and_log_subprocess", "_metadata_to_str", "join", "open", "cbook.open_file_cm", "shutil.copyfileobj", "info_dict.items", "_get_preamble"], "code_location": {"file": "backend_pgf.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 823, "end_line": 854}, "code_snippet": "    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    _DOCUMENTCLASS,\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with ((tmppath / \"figure.pdf\").open(\"rb\") as orig,\n                  cbook.open_file_cm(fname_or_fh, \"wb\") as dest):\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.3402707576751709}
{"question": "Where is the bootstrap logic that initializes the matplotlib_inline.backend_inline module located, and how does it determine whether to use the 'inline' backend identifier versus the full module path based on IPython version compatibility?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "test_entry_points_inline", "is_method": false, "class_name": null, "parameters": [], "calls": ["pytest.importorskip", "backend_registry.list_all"], "code_location": {"file": "test_backend_registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 97, "end_line": 100}, "code_snippet": "def test_entry_points_inline():\n    pytest.importorskip('matplotlib_inline')\n    backends = backend_registry.list_all()\n    assert 'inline' in backends\n", "type": "function"}, {"name": "_impl_test_lazy_auto_backend_selection", "is_method": false, "class_name": null, "parameters": [], "calls": ["matplotlib.rcParams._get", "plt.plot", "matplotlib.rcParams._get", "isinstance", "isinstance"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 339, "end_line": 350}, "code_snippet": "def _impl_test_lazy_auto_backend_selection():\n    import matplotlib\n    import matplotlib.pyplot as plt\n    # just importing pyplot should not be enough to trigger resolution\n    bk = matplotlib.rcParams._get('backend')\n    assert not isinstance(bk, str)\n    assert plt._backend_mod is None\n    # but actually plotting should\n    plt.plot(5)\n    assert plt._backend_mod is not None\n    bk = matplotlib.rcParams._get('backend')\n    assert isinstance(bk, str)\n", "type": "function"}, {"name": "_read_entry_points", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": ["im.entry_points", "backward_compatible_entry_points", "backward_compatible_entry_points", "im.version", "_parse_to_version_info", "entries.append"], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 128, "end_line": 163}, "code_snippet": "    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entry.name, entry.value) for entry in entry_points]\n\n        # For backward compatibility, if matplotlib-inline and/or ipympl are installed\n        # but too old to include entry points, create them. Do not import ipympl\n        # directly as this calls matplotlib.use() whilst in this function.\n        def backward_compatible_entry_points(\n                entries, module_name, threshold_version, names, target):\n            from matplotlib import _parse_to_version_info\n            try:\n                module_version = im.version(module_name)\n                if _parse_to_version_info(module_version) < threshold_version:\n                    for name in names:\n                        entries.append((name, target))\n            except im.PackageNotFoundError:\n                pass\n\n        names = [entry[0] for entry in entries]\n        if \"inline\" not in names:\n            backward_compatible_entry_points(\n                entries, \"matplotlib_inline\", (0, 1, 7), [\"inline\"],\n                \"matplotlib_inline.backend_inline\")\n        if \"ipympl\" not in names:\n            backward_compatible_entry_points(\n                entries, \"ipympl\", (0, 9, 4), [\"ipympl\", \"widget\"],\n                \"ipympl.backend_nbagg\")\n\n        return entries\n", "type": "function"}, {"name": "test_ipynb", "is_method": false, "class_name": null, "parameters": [], "calls": ["TemporaryDirectory", "Path", "subprocess_run_for_testing", "Path", "out_path.open", "nbformat.read", "cell.get", "str", "str"], "code_location": {"file": "test_backend_inline.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 15, "end_line": 46}, "code_snippet": "def test_ipynb():\n    nb_path = Path(__file__).parent / 'data/test_inline_01.ipynb'\n\n    with TemporaryDirectory() as tmpdir:\n        out_path = Path(tmpdir, \"out.ipynb\")\n\n        subprocess_run_for_testing(\n            [\"jupyter\", \"nbconvert\", \"--to\", \"notebook\",\n             \"--execute\", \"--ExecutePreprocessor.timeout=500\",\n             \"--output\", str(out_path), str(nb_path)],\n            env={**os.environ, \"IPYTHONDIR\": tmpdir},\n            check=True)\n        with out_path.open() as out:\n            nb = nbformat.read(out, nbformat.current_nbformat)\n\n    errors = [output for cell in nb.cells for output in cell.get(\"outputs\", [])\n              if output.output_type == \"error\"]\n    assert not errors\n\n    import IPython\n    if IPython.version_info[:2] >= (8, 24):\n        expected_backend = \"inline\"\n    else:\n        # This code can be removed when Python 3.12, the latest version supported by\n        # IPython < 8.24, reaches end-of-life in late 2028.\n        expected_backend = \"module://matplotlib_inline.backend_inline\"\n    backend_outputs = nb.cells[2][\"outputs\"]\n    assert backend_outputs[0][\"data\"][\"text/plain\"] == f\"'{expected_backend}'\"\n\n    image = nb.cells[1][\"outputs\"][1][\"data\"]\n    assert image[\"text/plain\"] == \"<Figure size 300x200 with 1 Axes>\"\n    assert \"image/png\" in image\n", "type": "function"}, {"name": "_implcore", "is_method": false, "class_name": null, "parameters": [], "calls": [], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 376, "end_line": 382}, "code_snippet": "def _implcore():\n    import matplotlib.backends.backend_qt5  # noqa\n    import sys\n\n    assert 'PyQt6' not in sys.modules\n    assert 'pyside6' not in sys.modules\n    assert 'PyQt5' in sys.modules or 'pyside2' in sys.modules\n", "type": "function"}, {"name": "_repr_html_", "is_method": true, "class_name": "Figure", "parameters": ["self"], "calls": ["backend_webagg.ipython_inline_display", "type"], "code_location": {"file": "figure.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 2752, "end_line": 2757}, "code_snippet": "    def _repr_html_(self):\n        # We can't use \"isinstance\" here, because then we'd end up importing\n        # webagg unconditionally.\n        if 'WebAgg' in type(self.canvas).__name__:\n            from matplotlib.backends import backend_webagg\n            return backend_webagg.ipython_inline_display(self)\n", "type": "function"}, {"name": "__init__", "is_method": true, "class_name": "BackendRegistry", "parameters": ["self"], "calls": [], "code_location": {"file": "registry.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/backends", "start_line": 77, "end_line": 93}, "code_snippet": "    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n", "type": "function"}, {"name": "_fallback_check", "is_method": false, "class_name": null, "parameters": [], "calls": ["ipsh.InteractiveShell.instance", "matplotlib.pyplot.figure"], "code_location": {"file": "test_backends_interactive.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 633, "end_line": 637}, "code_snippet": "def _fallback_check():\n    import IPython.core.interactiveshell as ipsh\n    import matplotlib.pyplot\n    ipsh.InteractiveShell.instance()\n    matplotlib.pyplot.figure()\n", "type": "function"}, {"name": "test_load_old_api", "is_method": false, "class_name": null, "parameters": ["monkeypatch"], "calls": ["SimpleNamespace", "monkeypatch.setitem", "mpl.use", "plt.draw_if_interactive", "FigureManagerTemplate", "type", "vars", "FigureCanvasTemplate", "FigureClass", "plt.figure"], "code_location": {"file": "test_backend_template.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib/tests", "start_line": 21, "end_line": 30}, "code_snippet": "def test_load_old_api(monkeypatch):\n    mpl_test_backend = SimpleNamespace(**vars(backend_template))\n    mpl_test_backend.new_figure_manager = (\n        lambda num, *args, FigureClass=mpl.figure.Figure, **kwargs:\n        FigureManagerTemplate(\n            FigureCanvasTemplate(FigureClass(*args, **kwargs)), num))\n    monkeypatch.setitem(sys.modules, \"mpl_test_backend\", mpl_test_backend)\n    mpl.use(\"module://mpl_test_backend\")\n    assert type(plt.figure().canvas) == FigureCanvasTemplate\n    plt.draw_if_interactive()\n", "type": "function"}, {"name": "_fix_ipython_backend2gui", "is_method": true, "class_name": "FigureCanvasBase", "parameters": ["cls"], "calls": ["sys.modules.get", "IPython.get_ipython", "get", "_is_non_interactive_terminal_ipython", "hasattr", "hasattr", "ip.enable_gui"], "code_location": {"file": "backend_bases.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 1776, "end_line": 1810}, "code_snippet": "    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `cache`).\n\n        # This function will not be needed when Python 3.12, the latest version\n        # supported by IPython < 8.24, reaches end-of-life in late 2028.\n        # At that time this function can be made a no-op and deprecated.\n        mod_ipython = sys.modules.get(\"IPython\")\n        if mod_ipython is None or mod_ipython.version_info[:2] >= (8, 24):\n            # Use of backend2gui is not needed for IPython >= 8.24 as the\n            # functionality has been moved to Matplotlib.\n            return\n\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n            # In case we ever move the patch to IPython and remove these APIs,\n            # don't break on our side.\n            return\n        backend2gui_rif = {\n            \"qt\": \"qt\",\n            \"gtk3\": \"gtk3\",\n            \"gtk4\": \"gtk4\",\n            \"wx\": \"wx\",\n            \"macosx\": \"osx\",\n        }.get(cls.required_interactive_framework)\n        if backend2gui_rif:\n            if _is_non_interactive_terminal_ipython(ip):\n                ip.enable_gui(backend2gui_rif)\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.39263129234313965}
{"question": "Where is the _update_prop method that is called by update_prop in HandlerRegularPolyCollection defined, and what is its inheritance chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"name": "HandlerRegularPolyCollection", "docstring": "Handler for `.RegularPolyCollection`\\s.", "methods": ["__init__", "get_numpoints", "get_sizes", "update_prop", "create_collection", "create_artists"], "attributes": [], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 430, "end_line": 500}, "type": "class"}, {"name": "_default_update_prop", "is_method": true, "class_name": "HandlerBase", "parameters": ["self", "legend_handle", "orig_handle"], "calls": ["legend_handle.update_from"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 83, "end_line": 84}, "code_snippet": "    def _default_update_prop(self, legend_handle, orig_handle):\n        legend_handle.update_from(orig_handle)\n", "type": "function"}, {"name": "_update_prop", "is_method": true, "class_name": "HandlerBase", "parameters": ["self", "legend_handle", "orig_handle"], "calls": ["self._default_update_prop", "self._update_prop_func"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 77, "end_line": 81}, "code_snippet": "    def _update_prop(self, legend_handle, orig_handle):\n        if self._update_prop_func is None:\n            self._default_update_prop(legend_handle, orig_handle)\n        else:\n            self._update_prop_func(legend_handle, orig_handle)\n", "type": "function"}, {"name": "_update_prop", "is_method": true, "class_name": "HandlerPolyCollection", "parameters": ["self", "legend_handle", "orig_handle"], "calls": ["first_color", "first_color", "first_color", "orig_handle.get_fill", "orig_handle.get_hatch", "legend_handle.set_linewidth", "legend_handle.set_linestyle", "legend_handle.set_transform", "tuple", "len", "orig_handle.get_facecolor", "orig_handle.get_edgecolor", "orig_handle.get_hatchcolor", "get_first", "get_first", "get_first", "orig_handle.get_linewidths", "orig_handle.get_linestyles", "orig_handle.get_transforms"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 777, "end_line": 801}, "code_snippet": "    def _update_prop(self, legend_handle, orig_handle):\n        def first_color(colors):\n            if colors.size == 0:\n                return (0, 0, 0, 0)\n            return tuple(colors[0])\n\n        def get_first(prop_array):\n            if len(prop_array):\n                return prop_array[0]\n            else:\n                return None\n\n        # orig_handle is a PolyCollection and legend_handle is a Patch.\n        # Directly set Patch color attributes (must be RGBA tuples).\n        legend_handle._facecolor = first_color(orig_handle.get_facecolor())\n        legend_handle._edgecolor = first_color(orig_handle.get_edgecolor())\n        legend_handle._hatch_color = first_color(orig_handle.get_hatchcolor())\n        legend_handle._original_facecolor = orig_handle._original_facecolor\n        legend_handle._original_edgecolor = orig_handle._original_edgecolor\n        legend_handle._fill = orig_handle.get_fill()\n        legend_handle._hatch = orig_handle.get_hatch()\n        # Setters are fine for the remaining attributes.\n        legend_handle.set_linewidth(get_first(orig_handle.get_linewidths()))\n        legend_handle.set_linestyle(get_first(orig_handle.get_linestyles()))\n        legend_handle.set_transform(get_first(orig_handle.get_transforms()))\n", "type": "function"}, {"name": "update_prop", "is_method": true, "class_name": "HandlerBase", "parameters": ["self", "legend_handle", "orig_handle", "legend"], "calls": ["self._update_prop", "legend._set_artist_props", "legend_handle.set_clip_box", "legend_handle.set_clip_path"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 86, "end_line": 92}, "code_snippet": "    def update_prop(self, legend_handle, orig_handle, legend):\n\n        self._update_prop(legend_handle, orig_handle)\n\n        legend._set_artist_props(legend_handle)\n        legend_handle.set_clip_box(None)\n        legend_handle.set_clip_path(None)\n", "type": "function"}, {"name": "update_prop", "is_method": true, "class_name": "HandlerRegularPolyCollection", "parameters": ["self", "legend_handle", "orig_handle", "legend"], "calls": ["self._update_prop", "legend_handle.set_figure", "legend_handle.set_clip_box", "legend_handle.set_clip_path", "legend.get_figure"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 465, "end_line": 472}, "code_snippet": "    def update_prop(self, legend_handle, orig_handle, legend):\n\n        self._update_prop(legend_handle, orig_handle)\n\n        legend_handle.set_figure(legend.get_figure(root=False))\n        # legend._set_artist_props(legend_handle)\n        legend_handle.set_clip_box(None)\n        legend_handle.set_clip_path(None)\n", "type": "function"}, {"name": "_default_update_prop", "is_method": true, "class_name": "HandlerLineCollection", "parameters": ["self", "legend_handle", "orig_handle"], "calls": ["legend_handle.set_color", "legend_handle.set_linestyle", "legend_handle.set_linewidth", "orig_handle.get_linewidths", "orig_handle.get_colors"], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 408, "end_line": 414}, "code_snippet": "    def _default_update_prop(self, legend_handle, orig_handle):\n        lw = orig_handle.get_linewidths()[0]\n        dashes = orig_handle._us_linestyles[0]\n        color = orig_handle.get_colors()[0]\n        legend_handle.set_color(color)\n        legend_handle.set_linestyle(dashes)\n        legend_handle.set_linewidth(lw)\n", "type": "function"}, {"name": "HandlerCircleCollection", "docstring": "Handler for `.CircleCollection`\\s.", "methods": ["create_collection"], "attributes": [], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 513, "end_line": 518}, "type": "class"}, {"name": "HandlerLineCollection", "docstring": "Handler for `.LineCollection` instances.", "methods": ["get_numpoints", "_default_update_prop", "create_artists"], "attributes": [], "code_location": {"file": "legend_handler.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 398, "end_line": 427}, "type": "class"}, {"name": "update_from", "is_method": true, "class_name": "Patch", "parameters": ["self", "other"], "calls": ["update_from", "self.set_linewidth", "self.set_transform", "other.is_transform_set", "other.get_data_transform", "super"], "code_location": {"file": "patches.py", "path": "/data3/pwh/swebench-repos/matplotlib/lib/matplotlib", "start_line": 283, "end_line": 301}, "code_snippet": "    def update_from(self, other):\n        # docstring inherited.\n        super().update_from(other)\n        # For some properties we don't need or don't want to go through the\n        # getters/setters, so we just copy them directly.\n        self._edgecolor = other._edgecolor\n        self._facecolor = other._facecolor\n        self._original_edgecolor = other._original_edgecolor\n        self._original_facecolor = other._original_facecolor\n        self._fill = other._fill\n        self._hatch = other._hatch\n        self._hatch_color = other._hatch_color\n        self._original_hatchcolor = other._original_hatchcolor\n        self._unscaled_dash_pattern = other._unscaled_dash_pattern\n        self.set_linewidth(other._linewidth)  # also sets scaled dashes\n        self.set_transform(other.get_data_transform())\n        # If the transform of other needs further initialization, then it will\n        # be the case for this artist too.\n        self._transformSet = other.is_transform_set()\n", "type": "function"}], "retrieved_count": 10, "cost_time": 0.6515452861785889}
