{"question": "Why does Flask implement context-local storage?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements context-local storage (docs/reqcontext.rst:15-20, docs/design.rst:170-180) to provide a clean, thread-safe way to access request and application data without explicitly passing objects through function parameters. Since a worker thread handles only one request at a time, request data can be considered global to that worker during the request. Context-local storage allows Flask to bind the current application and WSGI environment to the active context, making request, session, current_app, and g objects available through global proxies that automatically point to the correct data for the current thread. This approach eliminates the need to pass request objects explicitly through function parameters, making the code cleaner and more maintainable. The context system uses Python's contextvars and Werkzeug's LocalProxy (src/flask/globals.py:8, 20, 38) to provide thread-safe access to context-specific data, ensuring that each thread gets its own isolated request and application state. While thread locals can cause issues with non-thread-based servers, Flask is designed for traditional web applications where this approach works well and simplifies the developer experience.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\n\n\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app"}], "retrieved_count": 10, "cost_time": 1.049649715423584}
{"question": "What is the precise definition of Flask's \"application context\"?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's application context (src/flask/ctx.py:238) is a context that keeps track of application-level data during a request, CLI command, or other activity. It is implemented as the AppContext class which contains: 1) A reference to the Flask application object (self.app), 2) A URL adapter for URL generation (self.url_adapter), 3) A g object (src/flask/ctx.py:29) which is a namespace for storing data during the context lifetime, and 4) Context variable tokens for managing the context stack. The application context is automatically pushed when a request context is pushed and provides access to current_app proxy (src/flask/globals.py:25) and g proxy (src/flask/globals.py:30) through context variables. It solves circular import issues and provides a way to access application data without directly importing the app instance, especially useful in blueprints, extensions, and application factory patterns.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\n\n\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app"}, {"start_line": 55000, "end_line": 57000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n      "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}], "retrieved_count": 10, "cost_time": 1.0818238258361816}
{"question": "What is the relationship between Flask's Request class and Response class?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's Request class (src/flask/wrappers.py:18) and Response class (src/flask/wrappers.py:222) are both wrapper classes that extend Werkzeug's base classes. The Request class extends RequestBase from Werkzeug and adds Flask-specific attributes like url_rule, view_args, and routing_exception, while the Response class extends ResponseBase and sets default_mimetype to 'text/html'. Both classes share the same json_module (src/flask/wrappers.py:32, 240) for JSON handling. They work together in the request lifecycle where Request objects are created from WSGI environ dicts in RequestContext (src/flask/ctx.py:315) and Response objects are created from view function return values through make_response (src/flask/app.py:954). The Request class provides access to incoming HTTP data and routing information, while the Response class handles outgoing HTTP data and headers. Both are accessible through global proxies (src/flask/globals.py:42, 47) and are managed by the context system during request processing.", "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 9406, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       if current_app and current_app.debug:\n                raise\n\n            raise BadRequest() from ebr\n\n\nclass Response(ResponseBase):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n\n    .. versionchanged:: 1.0\n\n        Added :attr:`max_cookie_size`.\n    \"\"\"\n\n    default_mimetype: str | None = \"text/html\"\n\n    json_module = json\n\n    autocorrect_location_header = False\n\n    @property\n    def max_cookie_size(self) -> int:  # type: ignore\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]  # type: ignore[no-any-return]\n\n        # return Werkzeug's default when not in an app context\n        return super().max_cookie_size\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.wrappers import Request as RequestBase\nfrom werkzeug.wrappers import Response as ResponseBase\n\nfrom . import json\nfrom .globals import current_app\nfrom .helpers import _split_blueprint_path\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.routing import Rule\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    json_module: t.Any = json\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule: Rule | None = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args: dict[str, t.Any] | None = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised / was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception: HTTPException | None = None\n\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_PARTITIONED\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"MAX_FORM_MEMORY_SIZE\": 500_000,\n            \"MAX_FORM_PARTS\": 1_000,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n            \"PROVIDE_AUTOMATIC_OPTIONS\": True,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class: type[Request] = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class: type[Response] = Response\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface: SessionInterface = SecureCookieSessionInterface()\n\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_fo"}, {"start_line": 1000, "end_line": 2072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ueprint upwards through\n        parent blueprints.\n\n        This will be an empty list if there is no current blueprint, or\n        if URL matching failed.\n\n        .. versionadded:: 2.0.1\n        \"\"\"\n        name = self.blueprint\n\n        if name is None:\n            return []\n\n        return _split_blueprint_path(name)\n\n    def _load_form_data(self) -> None:\n        super()._load_form_data()\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)\n\n    def on_json_loading_failed(self, e: ValueError | None) -> t.Any:\n        try:\n            return super().on_json_loading_failed(e)\n        except BadRequest as ebr:\n            if current_app and current_app.debug:\n                raise\n\n            raise BadRequest() from ebr\n\n\nclass Response(ResponseBase):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n\n    .. versionchanged:: 1.0\n\n        Added :attr:`max_cookie_size`.\n    \"\"\"\n\n    default_mimetype: str | None = \"text/html\"\n\n    json_module = json\n\n    autocorrect_location_header = False\n\n    @property\n    def max_cookie_size(self) -> int:"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n            request.json_module = app.json\n        self.request: Request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes: list[tuple[str, str]] | None = None\n        self.session: SessionMixin | None = session\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        self._cv_tokens: list[\n            tuple[contextvars.Token[RequestContext], AppContext | None]\n        ] = []\n\n    def copy(self) -> RequestContext:\n        \"\"\"Creates a copy of this request context with the same request object.\n        This c"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "st.endpoint, request.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv  # type: ignore[no-any-return]\n\n        return None\n\n    def process_response(self, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n\n    def do_teardown_request(\n        self,\n        exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled th"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}], "retrieved_count": 10, "cost_time": 1.0944476127624512}
{"question": "What is the purpose of Flask's \"request context\" in handling HTTP requests?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's request context (src/flask/ctx.py:287) serves to keep track of request-level data during HTTP request processing. Its primary purposes include: 1) Creating and managing a Request object from the WSGI environ dict, 2) Providing access to request data through the request proxy (src/flask/globals.py:42) without passing the request object explicitly to each function, 3) Managing session data through the session proxy (src/flask/globals.py:47), 4) Creating URL adapters for URL generation and routing, 5) Enabling context-local storage where request data is global to the current worker thread but isolated between different requests, 6) Supporting the context stack system that allows multiple contexts to be pushed and popped, 7) Managing the lifecycle of request-specific resources and teardown functions, 8) Providing thread-safe access to request data in multi-threaded environments through context variables (src/flask/globals.py:38), and 9) Enabling testing scenarios through test_request_context for simulating HTTP requests without actual server calls.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n            request.json_module = app.json\n        self.request: Request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes: list[tuple[str, str]] | None = None\n        self.session: SessionMixin | None = session\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        self._cv_tokens: list[\n            tuple[contextvars.Token[RequestContext], AppContext | None]\n        ] = []\n\n    def copy(self) -> RequestContext:\n        \"\"\"Creates a copy of this request context with the same request object.\n        This c"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n\n\ndef test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.p"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]\n\n\ndef has_request_context() -> bool:\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    cont"}], "retrieved_count": 10, "cost_time": 1.1072862148284912}
{"question": "What are Flask's built-in security features?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's built-in security features include: 1) Secure cookie-based sessions using cryptographic signatures (src/flask/sessions.py:298) with configurable options like HttpOnly, Secure, and SameSite flags, 2) XSS protection through automatic HTML escaping in Jinja2 templates, 3) Request size limits via MAX_CONTENT_LENGTH, MAX_FORM_MEMORY_SIZE (500KB default), and MAX_FORM_PARTS (1000 default) configuration options (src/flask/app.py:200-210), 4) Secure filename handling for file uploads using werkzeug.utils.secure_filename, 5) Session cookie security with configurable lifetime, domain, path, and security flags (src/flask/app.py:200-210), 6) Secret key management for signing cookies and other security needs, 7) Support for security headers like HSTS, CSP, X-Content-Type-Options, and X-Frame-Options, 8) Protection against CSRF through proper session management, and 9) Debug mode protection with PIN-based access control for the development debugger.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "auth.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import functools\n\nfrom flask import Blueprint\nfrom flask import flash\nfrom flask import g\nfrom flask import redirect\nfrom flask import render_template\nfrom flask import request\nfrom flask import session\nfrom flask import url_for\nfrom werkzeug.security import check_password_hash\nfrom werkzeug.security import generate_password_hash\n\nfrom .db import get_db\n\nbp = Blueprint(\"auth\", __name__, url_prefix=\"/auth\")\n\n\ndef login_required(view):\n    \"\"\"View decorator that redirects anonymous users to the login page.\"\"\"\n\n    @functools.wraps(view)\n    def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)\n\n    return wrapped_view\n\n\n@bp.before_app_request\ndef load_logged_in_user():\n    \"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"\n    user_id = session.get(\"user_id\")\n\n    if user_id is None:\n        g.user = None\n    else:\n        g.user = (\n            get_db().execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )\n\n\n@bp.route(\"/register\", methods=(\"GET\", \"POST\"))\ndef register():\n    \"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n\n        if error is None:\n            try:\n                db.execute(\n                    \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                    (username, generate_password_hash(password)),\n                )\n                db.commit()\n            except db.IntegrityError:\n                # The username was already taken, which caused the\n                # commit to fail. Show a validation error."}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_PARTITIONED\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"MAX_FORM_MEMORY_SIZE\": 500_000,\n            \"MAX_FORM_PARTS\": 1_000,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n            \"PROVIDE_AUTOMATIC_OPTIONS\": True,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class: type[Request] = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class: type[Response] = Response\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface: SessionInterface = SecureCookieSessionInterface()\n\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_fo"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute[str | bytes | None](\"SECRET_KEY\")\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute[timedelta](\n        \"PERMANENT_SESSION_LIFETIME\",\n        get_converter=_make_timedelta,  # type: ignore[arg-type]\n    )\n\n    json_provider_class: type[JSONProvider] = DefaultJSONProvider\n    \"\"\"A subclass of :class:`~flask.json.provider.JSONProvider`. An\n    instance is created and assigned to :attr:`app.json` when creating\n    the app.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses\n    Python's built-in :mod:`json` library. A different provider can use\n    a different JSON library.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    #: Options that are passed to the Jinja environment in\n    #: :meth:`create_jinja_environment`. Changing these options after\n    #: the environment is created (accessing :attr:`jinja_env`) will\n    #: have no effect.\n    #:\n    #: .. versionchanged:: 1.1.0\n    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n    #:     easier configuration.\n    #:\n    jinja_options: dict[str, t.Any] = {}\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: The map object to use for storing the URL rules and routing\n    #: confi"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: The path to the root of the application files.\n        This should only be set manually when it can't be detected\n        automatically, such as for namespace packages.\n    \"\"\"\n\n    default_config = ImmutableDict(\n        {\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"SECRET_KEY\": None,\n            \"SECRET_KEY_FALLBACKS\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"TRUSTED_HOSTS\": None,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_PARTITIONED\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"MAX_FORM_MEMORY_SIZE\": 500_000,\n            \"MAX_FORM_PARTS\": 1_000,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n            \"PROVIDE_AUTOMATIC_OPTIONS\": True,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class: type[Request] = Request\n\n    #: The class that is us"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @ap"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "auth.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ").execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )\n\n\n@bp.route(\"/register\", methods=(\"GET\", \"POST\"))\ndef register():\n    \"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n\n        if error is None:\n            try:\n                db.execute(\n                    \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                    (username, generate_password_hash(password)),\n                )\n                db.commit()\n            except db.IntegrityError:\n                # The username was already taken, which caused the\n                # commit to fail. Show a validation error.\n                error = f\"User {username} is already registered.\"\n            else:\n                # Success, go to the login page.\n                return redirect(url_for(\"auth.login\"))\n\n        flash(error)\n\n    return render_template(\"auth/register.html\")\n\n\n@bp.route(\"/login\", methods=(\"GET\", \"POST\"))\ndef login():\n    \"\"\"Log in a registered user by adding the user id to the session.\"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n        user = db.execute(\n            \"SELECT * FROM user WHERE username = ?\", (username,)\n        ).fetchone()\n\n        if user is None:\n            error = \"Incorrect username.\"\n        elif not check_password_hash(user[\"password\"], password):\n            error = \"Incorrect password.\"\n\n        if error is None:\n            # store the user id in a new session and return to the index\n            session.clear()\n            session[\"user"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "``static_url_path``. Relative to the application ``root_path``\n        or an absolute path. Defaults to ``'static'``.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: The path to the root of the application files.\n        This should only be set manually when it can't be detected\n        automatically, such as for namespace packages.\n    \"\"\"\n\n    default_config = ImmutableDict(\n        {\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"SECRET_KEY\": None,\n            \"SECRET_KEY_FALLBACKS\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"TRUSTED_HOSTS\": None,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "sessions.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(_lazy_sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n        if not app.secret_key:\n            return None\n\n        keys: list[str | bytes] = []\n\n        if fallbacks := app.config[\"SECRET_KEY_FALLBACKS\"]:\n            keys.extend(fallbacks)\n\n        keys.append(app.secret_key)  # itsdangerous expects current key at top\n        return URLSafeTimedSerializer(\n            keys,  # type: ignore[arg-type]\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs={\n                \"key_derivation\": self.key_derivation,\n                \"digest_method\": self.digest_method,\n            },\n        )\n\n    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path ="}], "retrieved_count": 10, "cost_time": 1.1406776905059814}
{"question": "What is the role of the Flask application object?", "answer": null, "relative_code_list": null, "ground_truth": "The Flask application object (src/flask/app.py:81) serves as the central WSGI application that acts as a registry for all application components. Its primary roles include: 1) Implementing the WSGI interface through the wsgi_app method, 2) Managing configuration through the config attribute, 3) Registering and managing routes, view functions, and URL rules, 4) Handling template configuration and Jinja2 integration, 5) Managing session interface and secure cookie handling, 6) Providing CLI command registration through the cli attribute, 7) Managing static file serving and routing, 8) Coordinating with blueprints and extensions, 9) Handling request/response processing through the context system, and 10) Providing the central point for application-level data access through current_app proxy (src/flask/globals.py:25). The application object is the main entry point that ties together all Flask components and provides the interface between the WSGI server and the application logic.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 55, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napplication = Flask(__name__)\n"}, {"start_line": 0, "end_line": 47, "belongs_to": {"file_name": "flask.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1/inner2", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n"}, {"start_line": 0, "end_line": 52, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 0, "end_line": 73, "belongs_to": {"file_name": "importerrorapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\nraise ImportError()\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 169, "belongs_to": {"file_name": "factory.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\n\ndef create_app():\n    return Flask(\"app\")\n\n\ndef create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n\n\ndef no_app():\n    pass\n"}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}], "retrieved_count": 10, "cost_time": 1.1569130420684814}
{"question": "What is the relationship between Flask's Application class and Blueprint class?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between Flask's Application class (src/flask/app.py:81) and Blueprint class (src/flask/blueprints.py:18) is hierarchical and complementary. The Flask class inherits from App class (src/flask/sansio/app.py:59) and serves as the main WSGI application, while Blueprint inherits from SansioBlueprint (src/flask/sansio/blueprints.py:119) which inherits from Scaffold. Blueprints are registered on Flask applications through the register_blueprint method, where they defer their operations until registration time. Blueprints use the same decorators as Flask (route, errorhandler, etc.) but record operations for later execution rather than immediately registering them. When a blueprint is registered, its deferred functions are called with BlueprintSetupState (src/flask/sansio/blueprints.py:34) to actually register routes, error handlers, and other functionality on the application. Blueprints share the application's configuration and context but provide modular organization, allowing applications to be factored into smaller components while maintaining a single application instance.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n\n\nclass Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint'"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n      "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n   "}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the ap"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        },\n            )\n            app.error_handler_spec[key] = value\n\n        for endpoint, func in self.view_functions.items():\n            app.view_functions[endpoint] = func\n\n        extend(self.before_request_funcs, app.before_request_funcs)\n        extend(self.after_request_funcs, app.after_request_funcs)\n        extend(\n            self.teardown_request_funcs,\n            app.teardown_request_funcs,\n        )\n        extend(self.url_default_functions, app.url_default_functions)\n        extend(self.url_value_preprocessors, app.url_value_preprocessors)\n        extend(self.template_context_processors, app.template_context_processors)\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )\n\n    @setupmethod\n    def app_template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Equivalen"}], "retrieved_count": 10, "cost_time": 1.1626336574554443}
{"question": "What is Flask's blueprint system?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's blueprint system (src/flask/blueprints.py:18) is a way to organize and modularize Flask applications. Blueprints are objects that allow defining application functions without requiring an application object ahead of time. The Blueprint class (src/flask/sansio/blueprints.py:119) inherits from Scaffold and provides a way to register routes, error handlers, template filters, and other functionality that can be later registered on a Flask application. Blueprints can be registered with URL prefixes, subdomains, and can provide their own static files and templates. They support nesting (parent-child relationships) and can be registered multiple times on the same application. The blueprint system helps factor large applications into smaller, manageable components while sharing application configuration and avoiding the need for multiple separate WSGI applications.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 27000, "end_line": 28778, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n\n\ndef test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n\n\ndef test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)\n\n\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\ndef test_nested_c"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200\n\n\ndef test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @b"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\""}], "retrieved_count": 10, "cost_time": 1.182603120803833}
{"question": "What is the Flask request lifecycle?", "answer": null, "relative_code_list": null, "ground_truth": "The Flask request lifecycle (docs/lifecycle.rst:126-168) follows these steps: 1) WSGI server calls Flask.wsgi_app method, 2) RequestContext is created and converts WSGI environ to Request object, 3) AppContext is pushed making current_app and g available, 4) appcontext_pushed signal is sent, 5) RequestContext is pushed making request and session available, 6) Session is opened using session_interface, 7) URL is matched against registered routes, 8) request_started signal is sent, 9) url_value_preprocessor functions are called, 10) before_request functions are called, 11) View function is called if route matched, 12) Error handlers are called if exceptions occurred, 13) Response value is converted to Response object, 14) after_this_request functions are called, 15) after_request functions are called, 16) Session is saved, 17) request_finished signal is sent, 18) Unhandled exceptions are processed, 19) Response is returned to WSGI server, 20) teardown_request functions are called, 21) request_tearing_down signal is sent, 22) RequestContext is popped, 23) teardown_appcontext functions are called, 24) appcontext_tearing_down signal is sent, 25) AppContext is popped, 26) appcontext_popped signal is sent.", "score": null, "retrieved_content": [{"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "allback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"\n\n\ndef test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n\ndef test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2\n\n\ndef test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpo"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        retu"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_signals.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)\n\n\ndef test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)\n\n\ndef test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)\n"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pp.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexcept"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")\n\n\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/"}, {"start_line": 0, "end_line": 750, "belongs_to": {"file_name": "signals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom blinker import Namespace\n\n# This namespace is only for signals provided by Flask itself.\n_signals = Namespace()\n\ntemplate_rendered = _signals.signal(\"template-rendered\")\nbefore_render_template = _signals.signal(\"before-render-template\")\nrequest_started = _signals.signal(\"request-started\")\nrequest_finished = _signals.signal(\"request-finished\")\nrequest_tearing_down = _signals.signal(\"request-tearing-down\")\ngot_request_exception = _signals.signal(\"got-request-exception\")\nappcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\nappcontext_pushed = _signals.signal(\"appcontext-pushed\")\nappcontext_popped = _signals.signal(\"appcontext-popped\")\nmessage_flashed = _signals.signal(\"message-flashed\")\n"}], "retrieved_count": 10, "cost_time": 1.18043851852417}
{"question": "What are the core components of Flask's WSGI application?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's WSGI application core components include: 1) The Flask class (src/flask/app.py:81) which implements the WSGI application and acts as the central object, 2) The wsgi_app method (src/flask/app.py:1490) which is the actual WSGI application callable, 3) RequestContext and AppContext (src/flask/ctx.py) for managing request and application state, 4) The routing system using Werkzeug's URL mapping, 5) Request and Response wrappers (src/flask/wrappers.py) that extend Werkzeug's base classes, 6) Template engine integration with Jinja2, 7) Session management system, 8) Configuration management, and 9) Extension system for third-party integrations. The Flask class inherits from App class (src/flask/sansio/app.py:59) and provides the main WSGI interface through its __call__ method.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @cached_property\n    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n   "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport logging\nimport os\nimport sys\nimport typing as t\nfrom datetime import timedelta\nfrom itertools import chain\n\nfrom werkzeug.exceptions import Aborter\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import Rule\nfrom werkzeug.sansio.response import Response\nfrom werkzeug.utils import cached_property\nfrom werkzeug.utils import redirect as _wz_redirect\n\nfrom .. import typing as ft\nfrom ..config import Config\nfrom ..config import ConfigAttribute\nfrom ..ctx import _AppCtxGlobals\nfrom ..helpers import _split_blueprint_path\nfrom ..helpers import get_debug_flag\nfrom ..json.provider import DefaultJSONProvider\nfrom ..json.provider import JSONProvider\nfrom ..logging import create_logger\nfrom ..templating import DispatchingJinjaLoader\nfrom ..templating import Environment\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI applicati"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response"}], "retrieved_count": 10, "cost_time": 1.2016663551330566}
{"question": "What is the exact meaning of Flask's \"blueprint\" concept?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's blueprint concept (src/flask/sansio/blueprints.py:119) is a deferred registration mechanism that allows defining application functions without requiring an application object ahead of time. A blueprint is a collection of routes and other app-related functions that can be registered on a real application later. The Blueprint class uses the same decorators as Flask but defers the need for an application by recording operations to execute when registered. When you decorate a function with a blueprint, it creates a deferred function that is called with BlueprintSetupState (src/flask/sansio/blueprints.py:34) when the blueprint is registered on an application. Blueprints are not pluggable applications themselves but rather a set of operations that can be registered on an application, even multiple times. They provide separation at the Flask level while sharing application configuration, and can be registered with URL prefixes, subdomains, and provide their own static files and templates.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 27000, "end_line": 28778, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n\n\nclass Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint'"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the ap"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\""}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):"}], "retrieved_count": 10, "cost_time": 1.2049481868743896}
{"question": "Why are Flask's request and application contexts important?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's request and application contexts are important (docs/reqcontext.rst:1-20, docs/appcontext.rst:1-30) because they solve fundamental architectural problems in web application development. The request context provides access to request data without explicitly passing objects to every function, making code cleaner and more maintainable. The application context solves circular import issues by allowing access to application data through current_app proxy instead of importing the app instance directly. Both contexts enable thread-safe access to context-specific data through global proxies (src/flask/globals.py:20-51) that automatically point to the correct data for the current thread. The contexts support the application factory pattern and blueprint system by providing a way to access application data without direct imports. They also enable proper resource management through teardown functions and support testing scenarios through test_request_context. The context system uses Python's contextvars and Werkzeug's LocalProxy to provide isolation between different requests and applications, ensuring that each thread gets its own isolated state while maintaining a clean API for developers.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\n\n\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n\n\ndef test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.p"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]\n\n\ndef has_request_context() -> bool:\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    cont"}], "retrieved_count": 10, "cost_time": 1.1823883056640625}
{"question": "Why is Flask considered a good choice for small to medium-sized applications?", "answer": null, "relative_code_list": null, "ground_truth": "Flask is considered a good choice for small to medium-sized applications (README.md:3-4, docs/index.rst:6-7) because it is designed to make getting started quick and easy while having the ability to scale up to complex applications. Flask's lightweight WSGI framework design provides a minimal foundation that doesn't force decisions about databases, form validation, or other components, allowing developers to choose the tools that best fit their specific needs. The micro-framework architecture (docs/design.rst:130-150) keeps the core simple but extensible, making it suitable for projects that need to grow organically. Flask's blueprint system (docs/blueprints.rst:15-25) allows applications to be factored into smaller, manageable components as they grow, while the package structure (docs/patterns/packages.rst:1-10) supports both simple single-file applications and complex multi-module applications. Flask's explicit application object design enables easy testing and multiple application instances, while its extension system allows adding functionality as needed without bloating the core framework.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 0, "end_line": 47, "belongs_to": {"file_name": "flask.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1/inner2", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n"}, {"start_line": 0, "end_line": 55, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napplication = Flask(__name__)\n"}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}, {"start_line": 0, "end_line": 52, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 0, "end_line": 169, "belongs_to": {"file_name": "factory.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\n\ndef create_app():\n    return Flask(\"app\")\n\n\ndef create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n\n\ndef no_app():\n    pass\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ch more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `youra"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}], "retrieved_count": 10, "cost_time": 1.2178876399993896}
{"question": "Why does Flask implement a micro-framework architecture?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements a micro-framework architecture (docs/design.rst:130-150) to keep the core simple but extensible while avoiding making decisions for developers. The 'micro' in microframework means Flask aims to provide a minimal foundation without forcing choices about databases, form validation, or other components where different libraries already exist. Flask focuses on being a good foundation for all applications by bridging to Werkzeug for proper WSGI implementation and Jinja2 for templating, while leaving everything else to extensions or developer choice. This design philosophy allows Flask to be everything developers need and nothing they don't, avoiding the complexity of larger frameworks that make many decisions upfront. The micro-framework approach enables developers to make appropriate design decisions for their specific projects as their codebase grows, while Flask continues to provide a simple glue layer to the best Python tools available. This architecture supports both simple single-file applications and complex multi-module applications through extensions and the blueprint system.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 0, "end_line": 47, "belongs_to": {"file_name": "flask.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1/inner2", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        "}, {"start_line": 0, "end_line": 55, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napplication = Flask(__name__)\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ch more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `youra"}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}, {"start_line": 0, "end_line": 52, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\ntestapp = Flask(\"testapp\")\n"}], "retrieved_count": 10, "cost_time": 1.2363059520721436}
{"question": "Why does Flask provide a blueprint system for modular application development?", "answer": null, "relative_code_list": null, "ground_truth": "Flask provides a blueprint system for modular application development (docs/blueprints.rst:1-44) to address the challenges of organizing large applications into manageable components. Blueprints allow developers to factor applications into smaller, logical groups that can be developed and maintained independently. The blueprint system enables registering blueprints with URL prefixes and subdomains, providing common view arguments across all functions in a blueprint. Blueprints can be registered multiple times on an application with different URL rules, making them highly flexible. They provide template filters, static files, templates, and other utilities through a modular structure. The blueprint concept (src/flask/sansio/blueprints.py:119-187) records operations to execute when registered on an application, allowing Flask to associate view functions with blueprints during request dispatching and URL generation. Blueprints provide separation at the Flask level while sharing application configuration, avoiding the need for multiple separate WSGI applications. This modular approach makes large applications easier to maintain, test, and scale, while keeping the benefits of a single application instance and shared configuration.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 27000, "end_line": 28778, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the ap"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200\n\n\ndef test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @b"}], "retrieved_count": 10, "cost_time": 1.222623348236084}
{"question": "Why does Flask use context-local storage for request and application state?", "answer": null, "relative_code_list": null, "ground_truth": "Flask uses context-local storage for request and application state (docs/reqcontext.rst:15-20, docs/quickstart.rst:466-485) because it provides a clean way to access request data without explicitly passing objects to every function. Since a worker thread handles only one request at a time, request data can be considered global to that worker during the request. Context-local storage allows Flask to bind the current application and WSGI environment to the active context, making request, session, current_app, and g objects available through global proxies that automatically point to the correct data for the current thread. This approach eliminates the need to pass request objects explicitly through function parameters, making the code cleaner and more maintainable. The context system uses Python's contextvars and Werkzeug's LocalProxy (src/flask/globals.py:8, 20, 38) to provide thread-safe access to context-specific data, ensuring that each thread gets its own isolated request and application state. This design also enables intelligent context management where one application can invoke another without breaking the context isolation.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}], "retrieved_count": 10, "cost_time": 1.2371537685394287}
{"question": "What is the integration process between Flask and Jinja2?", "answer": null, "relative_code_list": null, "ground_truth": "Flask integrates with Jinja2 through a comprehensive setup process. The integration begins with the Flask application creating a Jinja2 environment through create_jinja_environment (src/flask/app.py:400) which configures autoescaping, auto_reload based on TEMPLATES_AUTO_RELOAD config, and sets up the environment with Flask-specific globals. Flask provides a custom Environment class (src/flask/templating.py:39) that extends Jinja2's BaseEnvironment and includes Flask's blueprint-aware template loading. The integration includes a DispatchingJinjaLoader (src/flask/templating.py:52) that handles template loading from both the main application and blueprints. Flask automatically injects global variables into templates including url_for, get_flashed_messages, config, request, session, and g (src/flask/app.py:410-420). The render_template function (src/flask/templating.py:138) handles template rendering with context processing, while the default template context processor (src/flask/templating.py:24) injects request, session, and g objects. Flask configures autoescaping for HTML templates and provides template inheritance support through Jinja2's syntax.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom jinja2 import BaseLoader\nfrom jinja2 import Environment as BaseEnvironment\nfrom jinja2 import Template\nfrom jinja2 import TemplateNotFound\n\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .helpers import stream_with_context\nfrom .signals import before_render_template\nfrom .signals import template_rendered\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .sansio.app import App\n    from .sansio.scaffold import Scaffold\n\n\ndef _default_template_ctx_processor() -> dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    appctx = _cv_app.get(None)\n    reqctx = _cv_request.get(None)\n    rv: dict[str, t.Any] = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv\n\n\nclass Environment(BaseEnvironment):\n    \"\"\"Works like a regular Jinja2 environment but has some additional\n    knowledge of how Flask's blueprint works so that it can prepend the\n    name of the blueprint to referenced templates if necessary.\n    \"\"\"\n\n    def __init__(self, app: App, **options: t.Any) -> None:\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app\n\n\nclass DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self.app = app\n\n    def get_source(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return sel"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    return rv\n\n\nclass Environment(BaseEnvironment):\n    \"\"\"Works like a regular Jinja2 environment but has some additional\n    knowledge of how Flask's blueprint works so that it can prepend the\n    name of the blueprint to referenced templates if necessary.\n    \"\"\"\n\n    def __init__(self, app: App, **options: t.Any) -> None:\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app\n\n\nclass DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self.app = app\n\n    def get_source(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n\n    def _get_source_explained(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        attempts = []\n        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n\n    def _get_source_fast(\n        self, environment: BaseEnvironment, template: st"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mplate_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n\n            if auto_reload is None:\n                auto_reload = self.debug\n\n            options[\"auto_reload\"] = auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=self.url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.policies[\"json.dumps_function\"] = self.json.dumps\n        return rv\n\n    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionchanged:: 3.1\n            If :data:`SERVER_NAME` is set, it does not restrict requests to\n            only that domain, for both ``subdomain_matching`` and\n            ``host_matching``.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n\n        .. versionchanged:: 0.9\n           This can be called outside a request when the URL adapter is created\n           for an application context.\n\n        .. versionadded:: 0.6\n        \"\"\"\n        if request "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "olean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template"}, {"start_line": 11000, "end_line": 12323, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\nfrom markupsafe import Markup\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n\n\ndef test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n       "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport pathlib\nimport sys\nimport typing as t\nfrom collections import defaultdict\nfrom functools import update_wrapper\n\nfrom jinja2 import BaseLoader\nfrom jinja2 import FileSystemLoader\nfrom werkzeug.exceptions import default_exceptions\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.utils import cached_property\n\nfrom .. import typing as ft\nfrom ..helpers import get_root_path\nfrom ..templating import _default_template_ctx_processor\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from click import Group\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\nT_after_request = t.TypeVar(\"T_after_request\", bound=ft.AfterRequestCallable[t.Any])\nT_before_request = t.TypeVar(\"T_before_request\", bound=ft.BeforeRequestCallable)\nT_error_handler = t.TypeVar(\"T_error_handler\", bound=ft.ErrorHandlerCallable)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_templating.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"]("}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nstead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename: str) -> bool:\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionchanged:: 2.2\n            Autoescaping is now enabled by default for ``.svg`` files.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n\n    @property\n    def debug(self) -> bool:\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n        development server, an interactive debugger will be shown for unhandled\n        exceptions, and the server will be reloaded when code changes. This maps to the\n        :data:`DEBUG` config key. It may not behave as expected if set late.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``False``\n        \"\"\"\n        return self.config[\"DEBUG\"]  # type: ignore[no-any-return]\n\n    @debug.setter\n    def debug(self, value: bool) -> None:\n        self.config[\"DEBUG\"] = value\n\n        if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n            self.jinja_env.auto_reload = value\n\n    @setupmethod\n    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n       "}], "retrieved_count": 10, "cost_time": 1.2647957801818848}
{"question": "Why does Flask use a decorator-based routing system?", "answer": null, "relative_code_list": null, "ground_truth": "Flask uses a decorator-based routing system (docs/design.rst:85-87) because it provides a clean, readable way to associate URL patterns with view functions while keeping the URL right next to the function that handles it. The decorator approach allows developers to declare routes in arbitrary order since Flask's routing system automatically orders routes by complexity. This design choice makes the code more intuitive and maintainable by keeping the route definition close to the implementation. However, Flask also provides alternative approaches like add_url_rule for centralized URL mapping when applications need to import quickly or when the decorator approach becomes unwieldy. The decorator system works with both regular functions and class-based views, and supports method-specific decorators like @app.get and @app.post for different HTTP methods. This flexibility allows developers to choose the most appropriate routing approach for their specific use case while maintaining consistency with Python's decorator patterns.", "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"He"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and build"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llo, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.requ"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user fr"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n    "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import gc\nimport re\nimport typing as t\nimport uuid\nimport warnings\nimport weakref\nfrom contextlib import nullcontext\nfrom datetime import datetime\nfrom datetime import timezone\nfrom platform import python_implementation\n\nimport pytest\nimport werkzeug.serving\nfrom markupsafe import Markup\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import Forbidden\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import RequestRedirect\n\nimport flask\n\nrequire_cpython_gc = pytest.mark.skipif(\n    python_implementation() != \"CPython\",\n    reason=\"Requires CPython GC behavior\",\n)\n\n\ndef test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\n@pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\ndef test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"\n\n\ndef test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run af"}], "retrieved_count": 10, "cost_time": 1.2806930541992188}
{"question": "Why does Flask use the application factory pattern?", "answer": null, "relative_code_list": null, "ground_truth": "Flask uses the application factory pattern (docs/patterns/appfactories.rst:1-15, docs/design.rst:75-77) for several important reasons. First, it enables testing by allowing creation of multiple application instances with different settings to test various scenarios. Second, it supports multiple instances of the same application running in the same process with different configurations, which is useful for deployment scenarios. The factory pattern moves application creation into a function, allowing developers to create application instances on demand rather than at import time. This approach solves circular import issues that can occur when blueprints need to access the application object, as blueprints can use current_app proxy instead of importing the app directly. The factory pattern also enables better extension management by allowing extensions to be initialized without being bound to a specific application instance, making them reusable across multiple applications. Flask's CLI system (src/flask/cli.py:41-91) automatically detects factory functions named create_app or make_app and can call them with arguments, making the pattern seamlessly integrated with Flask's tooling.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1437, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\n\nfrom flask import Flask\n\n\ndef create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from . import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from . import auth\n    from . import blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app\n"}, {"start_line": 0, "end_line": 169, "belongs_to": {"file_name": "factory.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\n\ndef create_app():\n    return Flask(\"app\")\n\n\ndef create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n\n\ndef no_app():\n    pass\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ch more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `youra"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 73, "belongs_to": {"file_name": "importerrorapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\nraise ImportError()\n\ntestapp = Flask(\"testapp\")\n"}], "retrieved_count": 10, "cost_time": 1.2766013145446777}
{"question": "Why does Flask's context management system optimize memory usage?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's context management system optimizes memory usage (docs/reqcontext.rst:30-40, docs/appcontext.rst:80-106) through several key mechanisms. The context system uses Python's contextvars and Werkzeug's LocalProxy to provide thread-safe access to context-specific data without creating global variables that persist across requests. Contexts are automatically created and destroyed as necessary, with the application context being created and destroyed with each request, ensuring that memory is freed when no longer needed. The g object provides a namespace for storing data during a request that is automatically cleaned up when the context ends, preventing memory leaks from accumulated request data. The context system supports teardown functions (src/flask/app.py:1380-1400) that are called when contexts are popped, allowing proper cleanup of resources like database connections. The context stack system allows multiple contexts to be pushed and popped efficiently, with each context being isolated and automatically garbage collected when no longer referenced. This design ensures that memory usage scales linearly with the number of active requests rather than accumulating over time.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n            request.json_module = app.json\n        self.request: Request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes: list[tuple[str, str]] | None = None\n        self.session: SessionMixin | None = session\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        self._cv_tokens: list[\n            tuple[contextvars.Token[RequestContext], AppContext | None]\n        ] = []\n\n    def copy(self) -> RequestContext:\n        \"\"\"Creates a copy of this request context with the same request object.\n        This c"}], "retrieved_count": 10, "cost_time": 1.2722587585449219}
{"question": "Why does Flask's blueprint system enhance application performance through modularization?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's blueprint system enhances application performance through modularization (docs/blueprints.rst:1-44, docs/patterns/packages.rst:131-140) by enabling efficient code organization and resource management. Blueprints allow applications to be factored into smaller, logical groups that can be developed and maintained independently, reducing the complexity of large applications. The modular structure enables lazy loading of components, where only the necessary blueprints are loaded and initialized when needed, reducing startup time and memory usage. Blueprints can be registered with URL prefixes and subdomains, providing efficient route organization that improves URL matching performance. The blueprint concept (src/flask/sansio/blueprints.py:119-187) records operations to execute when registered, allowing Flask to optimize the registration process and route dispatching. Blueprints provide separation at the Flask level while sharing application configuration, avoiding the overhead of multiple separate WSGI applications. This modular approach enables better caching strategies, as different blueprint components can be cached independently, and allows for more efficient resource allocation and cleanup.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 27000, "end_line": 28778, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n\n\ndef test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n\n\ndef test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)\n\n\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n\n\nclass Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint'"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "own2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"\n\n\n@pytest.mark.parametrize(\n    \"parent_init, child_init, parent_registration, child_registration\",\n    [\n        (\"/parent\", \"/child\", None, None),\n        (\"/parent\", None, None, \"/child\"),\n        (None, None, \"/parent\", \"/child\"),\n        (\"/other\", \"/something\", \"/parent\", \"/child\"),\n    ],\n)\ndef test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200\n\n\ndef test_nesting_subdomains(app, client) -> None:\n    app.subdoma"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\ndef test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teard"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get"}], "retrieved_count": 10, "cost_time": 1.2841968536376953}
{"question": "What dependencies exist between Flask's context system and Werkzeug components?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's context system has several key dependencies on Werkzeug components. The context system uses Werkzeug's LocalProxy (src/flask/globals.py:8) to create thread-safe global proxies for current_app, g, request, and session. The RequestContext (src/flask/ctx.py:287) creates Request objects using app.request_class(environ) which extends Werkzeug's RequestBase, and creates URL adapters using app.create_url_adapter() which uses Werkzeug's routing system. The context system handles HTTPException from Werkzeug (src/flask/ctx.py:11) for routing exceptions. Flask's Request and Response classes (src/flask/wrappers.py:18, 222) extend Werkzeug's RequestBase and ResponseBase respectively, inheriting their core functionality while adding Flask-specific features. The context system also depends on Werkzeug's WSGI utilities and datastructures like Headers and ImmutableDict (src/flask/app.py:18-19) for request/response handling. The context variables (src/flask/globals.py:20, 38) work with Python's contextvars but the proxies themselves rely on Werkzeug's LocalProxy for thread-local storage and proxy behavior.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport sys\nimport typing as t\nfrom datetime import datetime\nfrom functools import cache\nfrom functools import update_wrapper\n\nimport werkzeug.utils\nfrom werkzeug.exceptions import abort as _wz_abort\nfrom werkzeug.utils import redirect as _wz_redirect\nfrom werkzeug.wrappers import Response as BaseResponse\n\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .signals import message_flashed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .wrappers import Response\n\n\ndef get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\n\n\ndef get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr],\n) -> t.Iterator[t.AnyStr]: ...\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...\n\n\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to e"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}], "retrieved_count": 10, "cost_time": 1.3432905673980713}
{"question": "Where does the response context flow in Flask's middleware stack?", "answer": null, "relative_code_list": null, "ground_truth": "The response context flows through Flask's middleware stack (docs/lifecycle.rst:91-100, docs/reqcontext.rst:130-148) in a specific order. The middleware stack works like Python decorators, where the outermost middleware is called first by the WSGI server. Each middleware can modify the request data before passing it to the next middleware or Flask application, and can modify the response data after receiving it back. The response flow begins when the view function returns a value, which is converted to a Response object. The response then flows through after_this_request functions (src/flask/ctx.py:117-149) that were registered during the request, followed by after_request functions (src/flask/app.py:1300-1330) that can modify the response object. The response is then passed back through the middleware stack in reverse order, with each middleware having the opportunity to modify the response before it reaches the WSGI server. Common middleware like Werkzeug's ProxyFix can modify the response headers or content. The response context is managed alongside the request context, with both being cleaned up when the request context is popped at the end of the request lifecycle.", "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f\n\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\n\ndef copy_current_request_context(f: F) -> F:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]\n\n\ndef has_request_context() -> bool:\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information i"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]\n\n\ndef make_response(*args: t.Any) -> Response:\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the f"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "st.endpoint, request.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv  # type: ignore[no-any-return]\n\n        return None\n\n    def process_response(self, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n\n    def do_teardown_request(\n        self,\n        exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled th"}, {"start_line": 53000, "end_line": 55000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "uest_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n\n    def do_teardown_request(\n        self,\n        exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled the request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.teardown_request_funcs:\n                for func in reversed(self.teardown_request_funcs[name]):\n                    self.ensure_sync(func)(exc)\n\n        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def do_teardown_appcontext(\n        self,\n        exc: BaseException | "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-> bool:\n        return item in self.__dict__\n\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n\n    def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)\n\n\ndef after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f\n\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\n\ndef copy_current_request_context(f: F) -> F:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_reques"}, {"start_line": 1000, "end_line": 2072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rsionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]\n\n\ndef make_response(*args: t.Any) -> Response:\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a retu"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport sys\nimport typing as t\nfrom datetime import datetime\nfrom functools import cache\nfrom functools import update_wrapper\n\nimport werkzeug.utils\nfrom werkzeug.exceptions import abort as _wz_abort\nfrom werkzeug.utils import redirect as _wz_redirect\nfrom werkzeug.wrappers import Response as BaseResponse\n\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .signals import message_flashed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .wrappers import Response\n\n\ndef get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\n\n\ndef get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr],\n) -> t.Iterator[t.AnyStr]: ...\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...\n\n\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to e"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        (\"debug\", \"expect\"),\n        [\n            (\"\", False),\n            (\"0\", False),\n            (\"False\", False),\n            (\"No\", False),\n            (\"True\", True),\n        ],\n    )\n    def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"\n\n\n@pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\ndef test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in"}], "retrieved_count": 10, "cost_time": 1.3131964206695557}
{"question": "Where is the session data stored in Flask?", "answer": null, "relative_code_list": null, "ground_truth": "Session data in Flask is stored in signed cookies on the client side by default (src/flask/sessions.py:298-388, docs/api.rst:60-80). The default session interface is SecureCookieSessionInterface which uses the itsdangerous library to cryptographically sign session data and store it in HTTP cookies. The session data is serialized using a JSON serializer and then signed with the application's secret key to prevent tampering. The session is stored in the RequestContext (src/flask/ctx.py:287-358) and accessed through the session proxy (src/flask/globals.py:47-51). When a request comes in, the session interface opens the session by reading the signed cookie from the request and deserializing it. When the request ends, the session is saved by serializing the session data, signing it, and setting it as a cookie in the response. The session data persists across requests as long as the cookie is valid and not expired. Flask also supports custom session interfaces that can store session data in databases, Redis, or other server-side storage systems by implementing the SessionInterface class.", "score": null, "retrieved_content": [{"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.rou"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None\n\n\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"\n\n\ndef test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n\n\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str("}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "sessions.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj: object) -> bool:\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app: Flask) -> str:\n        \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n        return app.config[\"SESSION_COOKIE_NAME\"]  # type: ignore[no-any-return]\n\n    def get_cookie_domain(self, app: Flask) -> str | None:\n        \"\"\"The value of the ``Domain`` parameter on the session cookie. If not set,\n        browsers will only send the cookie to the exact domain it was set from.\n        Otherwise, they will send it to any subdomain of the given value as well.\n\n        Uses the :data:`SESSION_COOKIE_DOMAIN` config.\n\n        .. versionchanged:: 2.3\n            Not set by default, does not fall back to ``SERVER_NAME``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_DOMAIN\"]  # type: ignore[no-any-return]\n\n    def get_cookie_path(self, app: Flask) -> str:\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]  # type: ignor"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "sessions.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sion may be sent and handled\n    concurrently. When implementing a new session interface, consider\n    whether reads or writes to the backing store must be synchronized.\n    There is no guarantee on the order in which the session for each\n    request is opened or saved, it will occur in the order that requests\n    begin and end processing.\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app: Flask) -> NullSession:\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj: object) -> bool:\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app: Flask) -> str:\n        \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n        return app.config[\"SESSION_COOKIE_NAME\"]  # type: ign"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssion\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"\n\n\ndef test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]\n\n\ndef test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)\n\n\ndef test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n\n\ndef test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n\n    with pytest.raises(TypeError, match=\"Cookies are disabled.\"):\n        with c.session_transaction():\n            pass\n\n\ndef test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 4"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n\ndef test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "te(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)\n\n\ndef test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n\n\ndef test_flashes(app, req_ctx):\n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "sessions.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "okie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:\n        \"\"\"This is called at the beginning of each request, after\n        pushing the request context, before matching the URL.\n\n        This must return an object which implements a dictionary-like\n        interface as well as the :class:`SessionMixin` interface.\n\n        This will return ``None`` to indicate that loading failed in\n        some way that is not immediately an error. The request\n        context will fall back to using :meth:`make_null_session`\n        in this case.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        \"\"\"This is called at the end of each request, after generating\n        a response, before removing the request context. It is skipped\n        if :meth:`is_null_session` returns ``True``.\n        \"\"\"\n        raise NotImplementedError()\n\n\nsession_json_serializer = TaggedJSONSerializer()\n\n\ndef _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)\n\n\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n\n\ndef test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"\n\n\ndef test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()\n\n\ndef test_ses"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie"}], "retrieved_count": 10, "cost_time": 1.3216893672943115}
{"question": "Why does Flask's lightweight architecture improve performance?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's lightweight architecture improves performance (docs/design.rst:130-150, docs/async-await.rst:30-40) by minimizing overhead and avoiding unnecessary complexity. The micro-framework approach keeps the core simple and extensible, reducing the computational overhead that comes with larger, more feature-heavy frameworks. Flask's minimal core means faster startup times and lower memory usage since it doesn't include database abstraction layers, form validation, or other components that may not be needed for every application. The lightweight design allows Flask to focus on being a simple glue layer to the best Python tools available, leveraging existing libraries like Werkzeug for WSGI implementation and Jinja2 for templating rather than reimplementing these components. This approach reduces the framework's footprint and allows developers to add only the functionality they need through extensions, avoiding the performance penalty of unused features. Flask's design philosophy of being 'everything you need and nothing you don't' means applications can be optimized for their specific use cases without carrying unnecessary framework overhead.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 47, "belongs_to": {"file_name": "flask.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1/inner2", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n"}, {"start_line": 0, "end_line": 55, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp/inner1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napplication = Flask(__name__)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 0, "end_line": 52, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}, {"start_line": 0, "end_line": 73, "belongs_to": {"file_name": "importerrorapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\nraise ImportError()\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 0, "end_line": 97, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/javascript/js_example", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n\nfrom js_example import views  # noqa: E402, F401\n"}], "retrieved_count": 10, "cost_time": 1.3409602642059326}
{"question": "Where in Flask's codebase is the WSGI application implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The WSGI application is implemented in Flask's codebase in the Flask class (src/flask/app.py:81-1535). The Flask class inherits from the App class (src/flask/sansio/app.py:59) and implements the WSGI interface through the wsgi_app method (src/flask/app.py:1490-1535). The wsgi_app method is the actual WSGI application callable that receives the WSGI environ dict and start_response callable. The Flask class also implements the __call__ method (src/flask/app.py:1536) which delegates to wsgi_app, making Flask instances callable and thus WSGI-compliant. The WSGI implementation handles request context creation, request dispatching, response generation, and context cleanup. The Flask class serves as the central WSGI application object that acts as a registry for view functions, URL rules, template configuration, and other application components. The WSGI application is designed to be wrapped by middleware while maintaining a reference to the original application object.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport logging\nimport os\nimport sys\nimport typing as t\nfrom datetime import timedelta\nfrom itertools import chain\n\nfrom werkzeug.exceptions import Aborter\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import Rule\nfrom werkzeug.sansio.response import Response\nfrom werkzeug.utils import cached_property\nfrom werkzeug.utils import redirect as _wz_redirect\n\nfrom .. import typing as ft\nfrom ..config import Config\nfrom ..config import ConfigAttribute\nfrom ..ctx import _AppCtxGlobals\nfrom ..helpers import _split_blueprint_path\nfrom ..helpers import get_debug_flag\nfrom ..json.provider import DefaultJSONProvider\nfrom ..json.provider import JSONProvider\nfrom ..logging import create_logger\nfrom ..templating import DispatchingJinjaLoader\nfrom ..templating import Environment\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI applicati"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @cached_property\n    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "cli.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport ast\nimport collections.abc as cabc\nimport importlib.metadata\nimport inspect\nimport os\nimport platform\nimport re\nimport sys\nimport traceback\nimport typing as t\nfrom functools import update_wrapper\nfrom operator import itemgetter\nfrom types import ModuleType\n\nimport click\nfrom click.core import ParameterSource\nfrom werkzeug import run_simple\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.utils import import_string\n\nfrom .globals import current_app\nfrom .helpers import get_debug_flag\nfrom .helpers import get_load_dotenv\n\nif t.TYPE_CHECKING:\n    import ssl\n\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIApplication\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(module: ModuleType) -> Flask:\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response"}], "retrieved_count": 10, "cost_time": 1.3443400859832764}
{"question": "Where does the application context flow during Flask's request processing?", "answer": null, "relative_code_list": null, "ground_truth": "The application context flows during Flask's request processing (docs/lifecycle.rst:108-151, docs/appcontext.rst:40-50) in a specific sequence. The flow begins when the WSGI server calls Flask's wsgi_app method, which creates a RequestContext object. Before pushing the request context, Flask ensures an application context exists by checking if one is already active (src/flask/ctx.py:330-340). If no application context exists or if it's for a different application, a new AppContext is created and pushed. The application context is pushed first, making current_app and g proxies available (src/flask/globals.py:20-35). The appcontext_pushed signal is sent, then the request context is pushed. During the request processing, the application context remains active and provides access to application-level data through the current_app proxy. The application context flows through all stages of request processing including URL matching, before_request functions, view function execution, after_request functions, and error handling. At the end of the request, the request context is popped first, followed by the application context. The application context is managed using Python's contextvars and Werkzeug's LocalProxy to provide thread-safe access to application data.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 55000, "end_line": 57000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n      "}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\n\n\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 54000, "end_line": 56000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.teardown_request_funcs:\n                for func in reversed(self.teardown_request_funcs[name]):\n                    self.ensure_sync(func)(exc)\n\n        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def do_teardown_appcontext(\n        self,\n        exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}], "retrieved_count": 10, "cost_time": 1.360713243484497}
{"question": "Why does Flask's use of Werkzeug contribute to its performance?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's use of Werkzeug contributes to its performance (docs/design.rst:159-170, README.md:3-4) by leveraging a mature, optimized WSGI toolkit that handles complex WSGI interface tasks efficiently. Werkzeug provides a robust routing system that automatically orders routes by complexity, allowing Flask to declare routes in arbitrary order while maintaining optimal performance. The Werkzeug routing system is designed for high-performance URL matching and generation. Flask benefits from Werkzeug's optimized request and response handling, including efficient parsing of HTTP headers, form data, and file uploads. Werkzeug's LocalProxy implementation provides thread-safe access to context-local data without the overhead of traditional thread-local storage. The development server provided by Werkzeug through Flask's CLI offers fast reloading and debugging capabilities. By building on Werkzeug's foundation, Flask avoids reimplementing complex WSGI functionality and instead focuses on providing a clean, high-level API while benefiting from the performance optimizations and battle-tested code in Werkzeug.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport logging\nimport os\nimport sys\nimport typing as t\nfrom datetime import timedelta\nfrom itertools import chain\n\nfrom werkzeug.exceptions import Aborter\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import Rule\nfrom werkzeug.sansio.response import Response\nfrom werkzeug.utils import cached_property\nfrom werkzeug.utils import redirect as _wz_redirect\n\nfrom .. import typing as ft\nfrom ..config import Config\nfrom ..config import ConfigAttribute\nfrom ..ctx import _AppCtxGlobals\nfrom ..helpers import _split_blueprint_path\nfrom ..helpers import get_debug_flag\nfrom ..json.provider import DefaultJSONProvider\nfrom ..json.provider import JSONProvider\nfrom ..logging import create_logger\nfrom ..templating import DispatchingJinjaLoader\nfrom ..templating import Environment\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI applicati"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around a"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s not None\n        ) != bool(subdomain or url_scheme), (\n            'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n        )\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = urlsplit(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                path = f\"{path}?{url.query}\"\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n\n\n_werkzeug_version = \"\"\n\n\ndef _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n    Flask's contexts to defer the cleanup of the request context until\n    the end of a ``with`` block. For general information about how to\n    use this class refer to :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *arg"}, {"start_line": 1000, "end_line": 2072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n\n\n_werkzeug_version = \"\"\n\n\ndef _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n    Flask's contexts to defer the cleanup of the request context until\n    the end of a ``with`` block. For general information about how to\n    use this class refer to :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n  "}], "retrieved_count": 10, "cost_time": 1.3803205490112305}
{"question": "Where does the request context flow in Flask's WSGI application?", "answer": null, "relative_code_list": null, "ground_truth": "The request context flows through Flask's WSGI application (docs/lifecycle.rst:108-151, docs/reqcontext.rst:80-120) in a specific sequence. The flow begins when the WSGI server calls Flask's wsgi_app method (src/flask/app.py:1490-1535), which creates a RequestContext object. The RequestContext (src/flask/ctx.py:287-358) is created with the WSGI environ dict and converts it into a Request object. The request context is then pushed onto the context stack, making the request and session proxies available globally within that thread. During the request processing, the context flows through several stages: URL matching against registered routes, calling before_request functions, executing the matched view function, calling after_request functions, and finally popping the context. The request context is managed using Python's contextvars and Werkzeug's LocalProxy (src/flask/globals.py:38-51) to provide thread-safe access. The context is automatically popped at the end of the request, calling teardown functions and cleaning up resources. The request context is unique to each thread and cannot be passed between threads, ensuring proper isolation between concurrent requests.", "score": null, "retrieved_content": [{"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n            request.json_module = app.json\n        self.request: Request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes: list[tuple[str, str]] | None = None\n        self.session: SessionMixin | None = session\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        self._cv_tokens: list[\n            tuple[contextvars.Token[RequestContext], AppContext | None]\n        ] = []\n\n    def copy(self) -> RequestContext:\n        \"\"\"Creates a copy of this request context with the same request object.\n        This c"}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterfac"}, {"start_line": 14000, "end_line": 15064, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_close()\n        finally:\n            ctx = _cv_request.get()\n            token, app_ctx = self._cv_tokens.pop()\n            _cv_request.reset(token)\n\n            # get rid of circular dependencies at the end of the request\n            # so that we don't require the GC to be active.\n            if clear_request:\n                ctx.request.environ[\"werkzeug.request\"] = None\n\n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            if ctx is not self:\n                raise AssertionError(\n                    f\"Popped wrong request context. ({ctx!r} instead of {self!r})\"\n                )\n\n    def __enter__(self) -> RequestContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n    def __repr__(self) -> str:\n        return (\n            f\"<{type(self).__name__} {self.request.url!r}\"\n            f\" [{self.request.method}] of {self.app.name}>\"\n        )\n"}], "retrieved_count": 10, "cost_time": 1.3885669708251953}
{"question": "Where does Flask store its routing logic?", "answer": null, "relative_code_list": null, "ground_truth": "Flask stores its routing logic in the url_map attribute of the Flask application object (src/flask/sansio/app.py:400-427, docs/design.rst:85-87). The url_map is an instance of Werkzeug's Map class that contains all the URL rules registered with the application. Routes are added to this map through the add_url_rule method or the route decorator. The routing logic is implemented using Werkzeug's routing system, which automatically orders routes by complexity and provides URL matching capabilities. The url_map is used during request processing to match incoming URLs against registered routes (src/flask/ctx.py:358-365). The routing system supports various URL converters like string, int, float, path, and uuid, and handles URL patterns with variable parts. The routing logic also manages URL building through the url_for function and handles URL redirection behavior for trailing slashes. Blueprints also have their own routing logic that gets merged into the main application's url_map when registered.", "score": null, "retrieved_content": [{"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n   "}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n      "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n    "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run af"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  raise NotImplementedError\n\n    @property\n    def static_folder(self) -> str | None:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None\n\n    @static_folder.setter\n    def static_folder(self, value: str | os.PathLike[str] | None) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value\n\n    @property\n    def has_static_folder(self) -> bool:\n        \"\"\"``True`` if :attr:`static_folder` is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        return self.static_folder is not None\n\n    @property\n    def static_url_path(self) -> str | None:\n        \"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n      "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and build"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @cached_property\n    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport pathlib\nimport sys\nimport typing as t\nfrom collections import defaultdict\nfrom functools import update_wrapper\n\nfrom jinja2 import BaseLoader\nfrom jinja2 import FileSystemLoader\nfrom werkzeug.exceptions import default_exceptions\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.utils import cached_property\n\nfrom .. import typing as ft\nfrom ..helpers import get_root_path\nfrom ..templating import _default_template_ctx_processor\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from click import Group\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\nT_after_request = t.TypeVar(\"T_after_request\", bound=ft.AfterRequestCallable[t.Any])\nT_before_request = t.TypeVar(\"T_before_request\", bound=ft.BeforeRequestCallable)\nT_error_handler = t.TypeVar(\"T_error_handler\", bound=ft.ErrorHandlerCallable)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {"}], "retrieved_count": 10, "cost_time": 1.3805360794067383}
{"question": "Where is the error handling logic located in Flask?", "answer": null, "relative_code_list": null, "ground_truth": "The error handling logic in Flask is located in the Flask application class (src/flask/app.py:860-905, docs/errorhandling.rst:1-523). The main error handling methods are handle_exception and handle_user_exception, which process exceptions that occur during request processing. Error handlers are registered using the errorhandler decorator or register_error_handler method (src/flask/sansio/scaffold.py:647-700). The error handling system supports registering handlers for specific HTTP status codes, exception classes, or generic exception types. Error handlers can be registered at both the application level and blueprint level. The error handling logic is integrated into the request lifecycle and is called when exceptions occur during view function execution, before_request functions, or other request processing stages. The system also includes logging functionality for unhandled exceptions and supports custom error pages. Error handlers can return responses with appropriate HTTP status codes and can handle both HTTP exceptions and general Python exceptions.", "score": null, "retrieved_content": [{"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pp.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexcept"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dex():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(F"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ion_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\nfrom jinja2 import TemplateNotFound\nfrom werkzeug.http import parse_cache_control_header\n\nimport flask\n\n\ndef test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"\n\n\ndef test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.regist"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_user_exception(\n        self, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        if isinstance(e, BadRequestKeyError) and (\n            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        ):\n            e.show_exception = True\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e, request.blueprints)\n\n        if handler is None:\n            raise\n\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_exception(self, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "orbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"\n\n\n@pytest.mark.parametrize(\n    (\"debug\", \"trap\", \"expect_key\", \"expect_abort\"),\n    [(False, None, True, True), (True, None, False, True), (False, True, False, False)],\n)\ndef test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" i"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_user_error_handler.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import pytest\nfrom werkzeug.exceptions import Forbidden\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.exceptions import NotFound\n\nimport flask\n\n\ndef test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"\n\n\ndef test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        re"}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def should_ignore_error(self, error: BaseException | None) -> bool:\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n        \"\"\"Create a redirect response object.\n\n        This is called by :func:`flask.redirect`, and can be called\n        directly as well.\n\n        :param location: The URL to redirect to.\n        :param code: The status code for the redirect.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.redirect``, which calls this method.\n        \"\"\"\n        return _wz_redirect(\n            location,\n            code=code,\n            Response=self.response_class,  # type: ignore[arg-type]\n        )\n\n    def inject_url_defaults(self, endpoint: str, va"}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)  # type: ignore\n\n    def handle_http_exception(\n        self, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_user_exception(\n        self, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_user_error_handler.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "turn \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"\n\n\ndef test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"\n\n\ndef test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_except"}], "retrieved_count": 10, "cost_time": 1.8190433979034424}
{"question": "Where in Flask's codebase is the context system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The context system in Flask's codebase is implemented in the ctx.py module (src/flask/ctx.py:1-397). The core components include the AppContext class (src/flask/ctx.py:238-284) which manages application-level data, and the RequestContext class (src/flask/ctx.py:287-397) which manages request-level data. The context system uses Python's contextvars module and Werkzeug's LocalProxy for thread-safe access to context-local data. The global proxies (current_app, g, request, session) are defined in globals.py (src/flask/globals.py:1-51) using ContextVar and LocalProxy. The context system is integrated into the request lifecycle through the wsgi_app method in the Flask class (src/flask/app.py:1490-1535), where contexts are pushed and popped as needed. The system also includes helper functions like has_app_context and after_this_request for context management. The context system provides thread-safe access to application and request data without explicitly passing objects to every function.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}], "retrieved_count": 10, "cost_time": 1.819105625152588}
{"question": "Where in Flask's codebase is the \"route\" decorator defined?", "answer": null, "relative_code_list": null, "ground_truth": "The route decorator is defined in the Scaffold class (src/flask/sansio/scaffold.py:52-376), which is the base class for both Flask and Blueprint. The route decorator method (src/flask/sansio/scaffold.py:340-376) is decorated with @setupmethod and takes a rule string and optional keyword arguments. The decorator creates an inner decorator function that calls add_url_rule to register the URL rule with the application. The route decorator is used to bind view functions to URL patterns and supports various options like methods, endpoint, defaults, and other routing parameters. The decorator is available on both Flask application instances and Blueprint instances, allowing for consistent routing syntax across the framework. The route decorator is the primary way developers register URL rules in Flask applications, providing a clean and readable syntax for defining web routes.", "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"He"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and build"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llo, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n\n\nclass Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint'"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n    "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run af"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "views.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ould be the bottom\n    #: decorator.\n    #:\n    #: .. versionadded:: 0.8\n    decorators: t.ClassVar[list[t.Callable[..., t.Any]]] = []\n\n    #: Create a new instance of this view class for every request by\n    #: default. If a view subclass sets this to ``False``, the same\n    #: instance is used for every request.\n    #:\n    #: A single instance is more efficient, especially if complex setup\n    #: is done during init. However, storing data on ``self`` is no\n    #: longer safe across requests, and :data:`~flask.g` should be used\n    #: instead.\n    #:\n    #: .. versionadded:: 2.2\n    init_every_request: t.ClassVar[bool] = True\n\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"The actual view function behavior. Subclasses must override\n        this and return a valid response. Any variables from the URL\n        rule are passed as keyword arguments.\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def as_view(\n        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n    ) -> ft.RouteCallable:\n        \"\"\"Convert the class into a view function that can be registered\n        for a route.\n\n        By default, the generated view will create a new instance of the\n        view class for every request and call its\n        :meth:`dispatch_request` method. If the view class sets\n        :attr:`init_every_request` to ``False``, the same instance will\n        be used for every request.\n\n        Except for ``name``, all other arguments passed to this method\n        are forwarded to the view class ``__init__`` method.\n\n        .. versionchanged:: 2.2\n            Added the ``init_every_request`` class attribute.\n        \"\"\"\n        if cls.init_every_request:\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                self = view.view_class(  # type: ignore[attr-defined]\n                    *class_args, **class_kwargs\n                )\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.requ"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import gc\nimport re\nimport typing as t\nimport uuid\nimport warnings\nimport weakref\nfrom contextlib import nullcontext\nfrom datetime import datetime\nfrom datetime import timezone\nfrom platform import python_implementation\n\nimport pytest\nimport werkzeug.serving\nfrom markupsafe import Markup\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import Forbidden\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import RequestRedirect\n\nimport flask\n\nrequire_cpython_gc = pytest.mark.skipif(\n    python_implementation() != \"CPython\",\n    reason=\"Requires CPython GC behavior\",\n)\n\n\ndef test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\n@pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\ndef test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"\n\n\ndef test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status"}], "retrieved_count": 10, "cost_time": 0.8159513473510742}
{"question": "Where is the \"current_app\" proxy defined?", "answer": null, "relative_code_list": null, "ground_truth": "The current_app proxy is defined in the globals.py module (src/flask/globals.py:20-35). It is created as a LocalProxy that points to the app attribute of the current AppContext. The current_app proxy is implemented using Python's contextvars module and Werkzeug's LocalProxy to provide thread-safe access to the current Flask application instance. The proxy is bound to the _cv_app ContextVar which stores the current AppContext. When accessed, current_app automatically resolves to the Flask application object that is currently handling the request or CLI command. The proxy is imported and made available in the main Flask package (src/flask/__init__.py:10) so it can be used throughout Flask applications. The current_app proxy is essential for accessing the application instance without importing it directly, which is particularly useful in blueprints, extensions, and when using the application factory pattern.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_cli.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport sys\nimport typing as t\nfrom datetime import datetime\nfrom functools import cache\nfrom functools import update_wrapper\n\nimport werkzeug.utils\nfrom werkzeug.exceptions import abort as _wz_abort\nfrom werkzeug.utils import redirect as _wz_redirect\nfrom werkzeug.wrappers import Response as BaseResponse\n\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .signals import message_flashed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .wrappers import Response\n\n\ndef get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\n\n\ndef get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr],\n) -> t.Iterator[t.AnyStr]: ...\n\n\n@t.overload\ndef stream_with_context(\n    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...\n\n\ndef stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to e"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      The ``_anchor`` and ``_method`` parameters were added.\n\n    .. versionchanged:: 0.9\n       Calls ``app.handle_url_build_error`` on build errors.\n    \"\"\"\n    return current_app.url_for(\n        endpoint,\n        _anchor=_anchor,\n        _method=_method,\n        _scheme=_scheme,\n        _external=_external,\n        **values,\n    )\n\n\ndef redirect(\n    location: str, code: int = 302, Response: type[BaseResponse] | None = None\n) -> BaseResponse:\n    \"\"\"Create a redirect response object.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`~flask.Flask.redirect` method, otherwise it will use\n    :func:`werkzeug.utils.redirect`.\n\n    :param location: The URL to redirect to.\n    :param code: The status code for the redirect.\n    :param Response: The response class to use. Not used when\n        ``current_app`` is active, which uses ``app.response_class``.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.redirect`` if available instead of always\n        using Werkzeug's default ``redirect``.\n    \"\"\"\n    if current_app:\n        return current_app.redirect(location, code=code)\n\n    return _wz_redirect(location, code=code, Response=Response)\n\n\ndef abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n    status code.\n\n    If :data:`~flask.current_app` is available, it will call its\n    :attr:`~flask.Flask.aborter` object, otherwise it will use\n    :func:`werkzeug.exceptions.abort`.\n\n    :param code: The status code for the exception, which must be\n        registered in ``app.aborter``.\n    :param args: Passed to the exception.\n    :param kwargs: Passed to the exception.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.aborter`` if available instead of always\n        using Werkzeug's default ``abort``.\n    \"\"\"\n    if current_app:\n        current_app.aborter(code, *args, **kwargs)\n\n    _wz_abort(code, *args, **kwargs)\n\n\ndef get_template_attribute"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "cli.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb\n\n\ndef find_app_by_string(module: ModuleType, app_name: str) -> Flask:\n    \"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"\n    from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        ) from None\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = []\n        kwargs = {}\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {\n                kw.arg: ast.literal_eval(kw.value)\n                for kw in expr.keywords\n                if kw.arg is not None\n            }\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            )"}], "retrieved_count": 10, "cost_time": 0.8240399360656738}
{"question": "Where is the \"g\" object defined in Flask?", "answer": null, "relative_code_list": null, "ground_truth": "The g object is defined in the globals.py module (src/flask/globals.py:30-35). It is created as a LocalProxy that points to the g attribute of the current AppContext. The g object is an instance of the _AppCtxGlobals class (src/flask/ctx.py:29-114), which is a plain object used as a namespace for storing data during an application context. The _AppCtxGlobals class provides dictionary-like behavior with methods like get, pop, setdefault, and supports iteration and containment testing. The g object is bound to the _cv_app ContextVar and provides thread-safe access to application context data. The g object is imported and made available in the main Flask package (src/flask/__init__.py:11) and is commonly used to store request-specific data like database connections, user objects, or other resources that need to be shared across functions during a request. The g object has the same lifetime as the application context and is automatically cleaned up when the context ends.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-> bool:\n        return item in self.__dict__\n\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n\n    def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)\n\n\ndef after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f\n\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\n\ndef copy_current_request_context(f: F) -> F:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_reques"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "get(name, default)\n\n    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n\n    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self.__dict__\n\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n\n    def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)\n\n\ndef after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  #:\n    #: Defaults to :class:`werkzeug.exceptions.Aborter`.\n    #:\n    #: .. versionadded:: 2.2\n    aborter_class = Aborter\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute[bool](\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and oth"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}], "retrieved_count": 10, "cost_time": 0.805429220199585}
{"question": "Where in Flask's codebase is the \"Blueprint\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The Blueprint class is defined in two locations in Flask's codebase. The main Blueprint class is defined in src/flask/blueprints.py (src/flask/blueprints.py:18-56) which inherits from SansioBlueprint. The SansioBlueprint class is defined in src/flask/sansio/blueprints.py (src/flask/sansio/blueprints.py:119-225) which inherits from Scaffold. The Blueprint class provides a way to organize related views and other code into modular components that can be registered with a Flask application. Blueprints allow defining routes, error handlers, template filters, and other functionality without requiring an application object ahead of time. The Blueprint class uses the same decorators as Flask (like route) but defers the registration until the blueprint is registered with an application. Blueprints can be registered multiple times on the same application with different URL rules and can provide their own static files and templates. The Blueprint class is imported and made available in the main Flask package (src/flask/__init__.py:3) for use in Flask applications.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n\n\nclass Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint'"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\nT_route = t.TypeVar(\"T_route\", bound=ft.RouteCallable)\n\n\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n\n\nclass Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n   "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the ap"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport os\nimport typing as t\nfrom datetime import timedelta\n\nfrom .cli import AppGroup\nfrom .globals import current_app\nfrom .helpers import send_from_directory\nfrom .sansio.blueprints import Blueprint as SansioBlueprint\nfrom .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa\nfrom .sansio.scaffold import _sentinel\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .wrappers import Response\n\n\nclass Blueprint(SansioBlueprint):\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n    def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\n\n\nclass BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.nam"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport os\nimport typing as t\nfrom collections import defaultdict\nfrom functools import update_wrapper\n\nfrom .. import typing as ft\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import App\n\nDeferredSetupFunction = t.Callable[[\"BlueprintSetupState\"], None]\nT_after_request = t.TypeVar(\"T_after_request\", bound=ft.AfterRequestCallable[t.Any])\nT_before_request = t.TypeVar(\"T_before_request\", bound=ft.BeforeRequestCallable)\nT_error_handler = t.TypeVar(\"T_error_handler\", bound=ft.ErrorHandlerCallable)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_context_processor = t.TypeVar(\n    \"T_template_context_processor\", bound=ft.TemplateContextProcessorCallable\n)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\nT_url_defaults = t.TypeVar(\"T_url_defaults\", bound=ft.URLDefaultCallable)\nT_url_value_preprocessor = t.TypeVar(\n    \"T_url_value_preprocessor\", bound=ft.URLValuePreprocessorCallable\n)\n\n\nclass BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: dict[\n            ft.AppOrBlueprintKey,\n            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the funct"}], "retrieved_count": 10, "cost_time": 0.805924654006958}
{"question": "How does Flask implement its routing system?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements its routing system by leveraging Werkzeug's routing system (docs/design.rst:85-87, docs/api.rst:530-626). The routing system is built around the url_map attribute of the Flask application, which is an instance of Werkzeug's Map class. Routes can be registered using the route decorator (src/flask/sansio/scaffold.py:340-376), the add_url_rule method, or by directly accessing the url_map. The routing system automatically orders routes by complexity, allowing routes to be declared in arbitrary order while maintaining proper matching precedence. During request processing, the URL is matched against registered routes in the dispatch_request method (src/flask/app.py:870-905). The routing system supports variable parts in URLs using angular brackets (e.g., /user/<username>) and various converters like string, int, float, path, and uuid. URL variables are passed to view functions as keyword arguments. The system handles trailing slashes consistently and supports multiple rules for the same function. Blueprints also integrate with the routing system, with their routes being merged into the main application's url_map when registered. The routing system is used for both URL matching during requests and URL generation through the url_for function.", "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and build"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n   "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"He"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run af"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "scaffold.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n    "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_cli.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\",\n        )\n        app.add_url_rule(\"/zzz_post\", methods=[\"POST\"], endpoint=\"aaa_post\")\n        return app\n\n    @pytest.fixture\n    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:], strict=False):\n            # do this instead of startswith for nicer pytest output\n            assert line[: len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\n\n    def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)\n\n    def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output\n\n    def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output\n\n    def test_subdomain(self, runner):\n        app = Flask(__name__, stat"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import gc\nimport re\nimport typing as t\nimport uuid\nimport warnings\nimport weakref\nfrom contextlib import nullcontext\nfrom datetime import datetime\nfrom datetime import timezone\nfrom platform import python_implementation\n\nimport pytest\nimport werkzeug.serving\nfrom markupsafe import Markup\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import Forbidden\nfrom werkzeug.exceptions import NotFound\nfrom werkzeug.http import parse_date\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import RequestRedirect\n\nimport flask\n\nrequire_cpython_gc = pytest.mark.skipif(\n    python_implementation() != \"CPython\",\n    reason=\"Requires CPython GC behavior\",\n)\n\n\ndef test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\n\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n\n\n@pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\ndef test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"\n\n\ndef test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])\n\n\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello World!\"\n\n\ndef test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)\n\n\ndef test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.e"}], "retrieved_count": 10, "cost_time": 0.7944247722625732}
{"question": "How does Flask's application factory pattern work?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's application factory pattern works by moving the creation of the Flask application object into a function instead of creating it at module level (docs/patterns/appfactories.rst:1-116, docs/tutorial/factory.rst:1-131). The factory function (typically named create_app or make_app) creates and configures the Flask application instance, registers blueprints, initializes extensions, and returns the configured application. This pattern enables several benefits: 1) Testing - multiple application instances can be created with different configurations for testing various scenarios, 2) Multiple instances - different versions of the same application can run in the same process with different configurations, 3) Lazy loading - the application is only created when needed, avoiding circular import issues. The factory pattern is supported by Flask's CLI system (src/flask/cli.py:37-91) which can automatically detect and call factory functions. Blueprints and extensions work well with the factory pattern because they can access the application through the current_app proxy instead of importing the app instance directly. The factory pattern is particularly useful for large applications that need to be modular and testable.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1437, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\n\nfrom flask import Flask\n\n\ndef create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from . import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from . import auth\n    from . import blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app\n"}, {"start_line": 0, "end_line": 169, "belongs_to": {"file_name": "factory.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\n\ndef create_app():\n    return Flask(\"app\")\n\n\ndef create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n\n\ndef no_app():\n    pass\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ch more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `youra"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}, {"start_line": 0, "end_line": 97, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/javascript/js_example", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\n\nfrom js_example import views  # noqa: E402, F401\n"}, {"start_line": 0, "end_line": 1317, "belongs_to": {"file_name": "db.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import sqlite3\nfrom datetime import datetime\n\nimport click\nfrom flask import current_app\nfrom flask import g\n\n\ndef get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db(e=None):\n    \"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))\n\n\n@click.command(\"init-db\")\ndef init_db_command():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    init_db()\n    click.echo(\"Initialized the database.\")\n\n\nsqlite3.register_converter(\"timestamp\", lambda v: datetime.fromisoformat(v.decode()))\n\n\ndef init_app(app):\n    \"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)\n"}], "retrieved_count": 10, "cost_time": 0.7946302890777588}
{"question": "How does Flask's blueprint system facilitate modular applications?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's blueprint system facilitates modular applications by providing a way to organize related views and code into separate, reusable components (docs/blueprints.rst:1-200, docs/patterns/packages.rst:131-140). Blueprints allow developers to factor large applications into smaller, logical groups that can be developed and maintained independently. Each blueprint can define its own routes, error handlers, template filters, static files, and templates. Blueprints can be registered with URL prefixes and subdomains, providing common view arguments across all functions in the blueprint. The blueprint system supports nesting, where blueprints can be registered on other blueprints, creating hierarchical structures. Blueprints can be registered multiple times on the same application with different URL rules, making them highly flexible. The system enables separation at the Flask level while sharing application configuration, avoiding the overhead of multiple separate WSGI applications. Blueprints work well with the application factory pattern, allowing for clean separation of concerns and improved testability. The blueprint concept (src/flask/sansio/blueprints.py:119-225) records operations to execute when registered, providing a deferred registration mechanism that enables modular application development.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/blueprintapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp = Flask(__name__)\napp.config[\"DEBUG\"] = True\nfrom blueprintapp.apps.admin import admin  # noqa: E402\nfrom blueprintapp.apps.frontend import frontend  # noqa: E402\n\napp.register_blueprint(admin)\napp.register_blueprint(frontend)\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n"}, {"start_line": 27000, "end_line": 28778, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = su"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n\n\ndef test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n\n\ndef test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)\n\n\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n"}, {"start_line": 0, "end_line": 1437, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/examples/tutorial/flaskr", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\n\nfrom flask import Flask\n\n\ndef create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from . import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from . import auth\n    from . import blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app\n"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\ndef test_nested_c"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\""}, {"start_line": 0, "end_line": 67, "belongs_to": {"file_name": "multiapp.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")\n"}], "retrieved_count": 10, "cost_time": 0.787421464920044}
{"question": "How does Flask implement its context management system?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements its context management system using Python's contextvars module and Werkzeug's LocalProxy (src/flask/ctx.py:1-397, src/flask/globals.py:1-51). The system consists of two main context types: AppContext and RequestContext. The AppContext (src/flask/ctx.py:238-284) manages application-level data and contains the Flask application instance, URL adapter, and g object. The RequestContext (src/flask/ctx.py:287-397) manages request-level data and contains the Request object, session, and URL adapter. Contexts are implemented as stacks using Python's ContextVar, with each context being pushed and popped as needed. The system provides global proxies (current_app, g, request, session) that automatically resolve to the correct data for the current context. Contexts are managed during the request lifecycle through the wsgi_app method (src/flask/app.py:1490-1535), where they are pushed at the beginning of request processing and popped at the end. The context system enables thread-safe access to context-specific data without explicitly passing objects to every function. Contexts can be manually pushed and popped using context managers, and the system includes teardown functions for proper resource cleanup when contexts end.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}], "retrieved_count": 10, "cost_time": 0.7874627113342285}
{"question": "How does Flask handle dynamic URL patterns?", "answer": null, "relative_code_list": null, "ground_truth": "Flask handles dynamic URL patterns through its routing system that leverages Werkzeug's URL mapping capabilities (docs/api.rst:530-626, docs/quickstart.rst:186-244). Dynamic URL patterns are defined using angular brackets with variable names (e.g., /user/<username>) and can include type converters (e.g., /post/<int:post_id>). The routing system supports various built-in converters including string (default), int, float, path, any, and uuid. URL variables are automatically extracted from the request URL and passed as keyword arguments to the view function. The system handles trailing slashes consistently, redirecting users to canonical URLs to maintain URL uniqueness. Flask supports multiple rules for the same function and allows specifying default values for URL variables. The routing system automatically orders routes by complexity and provides URL generation through the url_for function. Dynamic URL patterns are processed during request dispatching in the dispatch_request method (src/flask/app.py:870-905), where the URL is matched against registered routes and the extracted variables are passed to the appropriate view function. The system also supports custom converters that can be defined using the url_map attribute.", "score": null, "retrieved_content": [{"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ndpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"\n\n\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n\n\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n\n\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"\n\n\ndef test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(use"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\ndef test_nested_c"}, {"start_line": 49000, "end_line": 51000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"\n\n\n@pytest.mark.parametrize(\"matching\", (False, True))\ndef test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204\n\n\ndef test_multi_route_rules(app, client):\n    @app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"\n\n\ndef test_multi_route_class_views(app, client):\n    class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"\n\n\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"\n\n\ndef test_run_server_port(monkeypatch"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"\n\n\ndef test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_f"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sert rv.mimetype == \"application/vnd.api+json\"\n\n\ndef test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}\n\n\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"args or kwargs\" in str(e.value)\n\n\ndef test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )\n\n\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\"\n\n\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):"}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "te_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"\n\n\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected\n\n\ndef test_nonascii_pathinfo(app, client):\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello World!\"\n\n\ndef test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\""}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_blueprints.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"\n\n\ndef test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n "}, {"start_line": 0, "end_line": 1093, "belongs_to": {"file_name": "test_converters.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from werkzeug.routing import BaseConverter\n\nfrom flask import request\nfrom flask import session\nfrom flask import url_for\n\n\ndef test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"\n\n\ndef test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}], "retrieved_count": 10, "cost_time": 0.7883381843566895}
{"question": "How does Flask implement its context system?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements its context system using Python's contextvars module and Werkzeug's LocalProxy to provide thread-safe access to context-specific data (src/flask/ctx.py:1-397, src/flask/globals.py:1-51). The system consists of two main context types: AppContext and RequestContext. The AppContext (src/flask/ctx.py:238-284) manages application-level data and contains the Flask application instance, URL adapter, and g object. The RequestContext (src/flask/ctx.py:287-397) manages request-level data and contains the Request object, session, and URL adapter. Contexts are implemented as stacks using Python's ContextVar, with each context being pushed and popped as needed. The system provides global proxies (current_app, g, request, session) that automatically resolve to the correct data for the current context. Contexts are managed during the request lifecycle through the wsgi_app method (src/flask/app.py:1490-1535), where they are pushed at the beginning of request processing and popped at the end. The context system enables thread-safe access to context-specific data without explicitly passing objects to every function. Contexts can be manually pushed and popped using context managers, and the system includes teardown functions for proper resource cleanup when contexts end.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ext.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n\n\nclass AppContext:\n    \"\"\"The app context contains application-specific information. An app\n    context is created and pushed at the beginning of each request if\n    one is not already active. An app context is also pushed when\n    running CLI commands.\n    \"\"\"\n\n    def __init__(self, app: Flask) -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: list[contextvars.Token[AppContext]] = []\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the "}, {"start_line": 0, "end_line": 1713, "belongs_to": {"file_name": "globals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)\n"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> AppContext:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains per-request information. The Flask\n    app creates and pushes it at the beginning of the request, then pops\n    it at the end of the request. It will create the URL adapter and\n    request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the\n    request. When using the interactive debugger, the context will be\n    restored so ``request`` is still accessible. Similarly, the test\n    client can preserve the context after the request ends. However,\n    teardown functions may already have closed some resources such as\n    database connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        environ: WSGIEnvironment,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> N"}, {"start_line": 3000, "end_line": 4978, "belongs_to": {"file_name": "test_appctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport contextvars\nimport sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom . import typing as ft\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__."}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ush()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n"}], "retrieved_count": 10, "cost_time": 0.7834703922271729}
{"question": "How does Flask's request dispatching work?", "answer": null, "relative_code_list": null, "ground_truth": "Flask's request dispatching works through a multi-stage process that begins when the WSGI server calls the Flask application (docs/lifecycle.rst:108-151, src/flask/app.py:870-905). The process starts with the wsgi_app method being called, which creates a RequestContext object that converts the WSGI environ dict into a Request object. The system then pushes the application context and request context, making current_app, g, request, and session proxies available. The URL is matched against registered routes using the url_map, and if a match is found, the request is processed through several stages: before_request functions are called, the matched view function is executed, after_request functions are called, and finally teardown functions are executed. The dispatch_request method (src/flask/app.py:870-905) handles the core dispatching logic, checking for routing exceptions, handling OPTIONS requests automatically, and calling the appropriate view function with extracted URL variables. The system supports both function-based views and class-based views through the View and MethodView classes (src/flask/views.py:16-191). Error handling is integrated throughout the process, with error handlers being called if exceptions occur during any stage. The request dispatching system is designed to be extensible and supports various customization points through decorators and callbacks.", "score": null, "retrieved_content": [{"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\n    def full_dispatch_request(self) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self, _async_wrapper=self.ensure_sync)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(\n        self,\n        rv: ft.ResponseReturnValue | HTTPException,\n        from_error_handler: bool = False,\n    ) -> Response:\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n\ndef test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\n\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")\n\n\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\")"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.wrappers import Request as RequestBase\nfrom werkzeug.wrappers import Response as ResponseBase\n\nfrom . import json\nfrom .globals import current_app\nfrom .helpers import _split_blueprint_path\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.routing import Rule\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    json_module: t.Any = json\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule: Rule | None = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args: dict[str, t.Any] | None = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised / was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception: HTTPException | None = None\n\n"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = request_ctx.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\n    def full_dispatch_request(self) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self, _async_wrapper=self.ensure_sync)\n          "}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pp.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexcept"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}], "retrieved_count": 10, "cost_time": 0.7811985015869141}
{"question": "How does Flask handle error handling and exception processing?", "answer": null, "relative_code_list": null, "ground_truth": "Flask handles error handling and exception processing through a comprehensive system that includes error handlers, exception handling, and logging (docs/errorhandling.rst:1-523, src/flask/app.py:860-905). The system supports registering error handlers for specific HTTP status codes, exception classes, or generic exception types using the errorhandler decorator or register_error_handler method (src/flask/sansio/scaffold.py:647-700). Error handlers can be registered at both the application level and blueprint level, with blueprint handlers taking precedence for requests handled by that blueprint. The system includes two main exception handling methods: handle_user_exception for HTTP exceptions and handle_exception for unhandled exceptions (src/flask/app.py:860-905). When an exception occurs, Flask first looks for a registered error handler by status code, then by exception class hierarchy, choosing the most specific handler available. If no handler is found, Flask returns a 500 Internal Server Error by default. The system supports custom exception classes and provides the abort function for raising HTTP exceptions with specific status codes. Error handlers can return custom responses, including JSON for API applications, and the system includes logging functionality for unhandled exceptions. The error handling system is integrated into the request lifecycle and respects the exception class hierarchy for proper handler selection.", "score": null, "retrieved_content": [{"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pp.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n\n\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexcept"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dex():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n\n\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(F"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"\n\n\n@pytest.mark.parametrize(\n    (\"debug\", \"trap\", \"expect_key\", \"expect_abort\"),\n    [(False, None, True, True), (True, None, False, True), (False, True, False, False)],\n)\ndef test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n"}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)  # type: ignore\n\n    def handle_http_exception(\n        self, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_user_exception(\n        self, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(\n        self, f: T_shell_context_processor\n    ) -> T_shell_context_processor:\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    def _find_error_handler(\n        self, e: Exception, blueprints: list[str]\n    ) -> ft.ErrorHandlerCallable | None:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None\n\n    def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n     "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "S\", \"DEBUG\", None])\ndef test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500\n\n\n@pytest.mark.parametrize(\"debug\", [True, False])\n@pytest.mark.parametrize(\"use_debugger\", [True, False])\n@pytest.mark.parametrize(\"use_reloader\", [True, False])\n@pytest.mark.parametrize(\"propagate_exceptions\", [None, True, False])\ndef test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n\n\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"\n\n\ndef test_inject_blueprint_url_"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ion_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n\n\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n\n\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"\n\n\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"\n\n\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")\n\n\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")\n\n\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n\n\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)\n\n\ndef test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"Hllo Wrld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"Hllo Wrld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_user_exception(\n        self, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        if isinstance(e, BadRequestKeyError) and (\n            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        ):\n            e.show_exception = True\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e, request.blueprints)\n\n        if handler is None:\n            raise\n\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_exception(self, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = request_ctx.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\n    def full_dispatch_request(self) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self, _async_wrapper=self.ensure_sync)\n          "}], "retrieved_count": 10, "cost_time": 0.7729439735412598}
{"question": "How does Flask handle request and response objects?", "answer": null, "relative_code_list": null, "ground_truth": "Flask handles request and response objects through wrapper classes that extend Werkzeug's base classes (src/flask/wrappers.py:18-257, docs/api.rst:25-69). The Request class extends Werkzeug's RequestBase and adds Flask-specific attributes like url_rule, view_args, and routing_exception. The Response class extends ResponseBase and sets default_mimetype to 'text/html'. Both classes share the same json_module for JSON handling. Request objects are created from WSGI environ dicts in the RequestContext (src/flask/ctx.py:287-397) and are accessible through the request proxy. Response objects are created through the make_response function (src/flask/helpers.py:139-185) which can convert various return types from view functions into proper Response objects. The system automatically converts strings to HTML responses, dicts/lists to JSON responses using jsonify (src/flask/json/__init__.py:138-170), and supports tuples for status codes and headers. The finalize_request method (src/flask/app.py:905-954) handles converting view function return values into Response objects and applies post-processing. The system includes JSON support through the JSONProvider class (src/flask/json/provider.py:19-215) which handles serialization and deserialization of JSON data. Request and response objects are integrated into the context system and are available throughout the request lifecycle.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 2072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.wrappers import Request as RequestBase\nfrom werkzeug.wrappers import Response as ResponseBase\n\nfrom . import json\nfrom .globals import current_app\nfrom .helpers import _split_blueprint_path\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.routing import Rule\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    json_module: t.Any = json\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule: Rule | None = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args: dict[str, t.Any] | None = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised / was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception: HTTPException | None = None\n\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "test_testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value  # noqa: B018\n\n\ndef test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n\ndef test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args\n\n\ndef test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data\n\n\ndef test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n      "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args\n\n\ndef test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data\n\n\ndef test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1\n\n\ndef test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n\n\ndef test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n"}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "st.endpoint, request.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv  # type: ignore[no-any-return]\n\n        return None\n\n    def process_response(self, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n\n    def do_teardown_request(\n        self,\n        exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled th"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n\n\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n\n\ndef test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n\n\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n\n\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_PARTITIONED\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"MAX_FORM_MEMORY_SIZE\": 500_000,\n            \"MAX_FORM_PARTS\": 1_000,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n            \"PROVIDE_AUTOMATIC_OPTIONS\": True,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class: type[Request] = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class: type[Response] = Response\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface: SessionInterface = SecureCookieSessionInterface()\n\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_fo"}], "retrieved_count": 10, "cost_time": 0.7610001564025879}
{"question": "How does Flask implement its testing framework?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements its testing framework through several key components that provide comprehensive testing capabilities (docs/testing.rst:1-301, src/flask/testing.py:1-139). The framework includes a test client (FlaskClient) that extends Werkzeug's test client and provides Flask-specific functionality. The test_client method (src/flask/app.py:554-721) creates a test client instance that can make requests to the application without running a live server. The framework also includes a CLI runner (FlaskCliRunner) for testing command-line interfaces. The testing system supports fixtures for setting up test environments, including app fixtures for creating application instances with test configurations. The framework integrates with pytest and provides utilities for testing functions that require active application or request contexts. The test client can handle various request types (GET, POST, etc.) and provides access to response data, status codes, and headers. The framework supports testing with different configurations, database setups, and can handle form data, JSON data, and file uploads. The testing system includes utilities for creating temporary databases, managing test data, and cleaning up resources after tests. The framework is designed to work with the application factory pattern and supports testing blueprints, extensions, and complex application scenarios.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\nimport sys\n\nimport pytest\nfrom _pytest import monkeypatch\n\nfrom flask import Flask\nfrom flask.globals import request_ctx\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef _standard_os_environ():\n    \"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"\n    mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, \"FLASK_ENV_FILE\", monkeypatch.notset),\n        (os.environ, \"FLASK_APP\", monkeypatch.notset),\n        (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n        (os.environ, \"FLASK_RUN_FROM_CLI\", monkeypatch.notset),\n        (os.environ, \"WERKZEUG_RUN_MAIN\", monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()\n\n\n@pytest.fixture(autouse=True)\ndef _reset_os_environ(monkeypatch, _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)\n\n\n@pytest.fixture\ndef app():\n    app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY=\"test key\",\n    )\n    return app\n\n\n@pytest.fixture\ndef app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n\n@pytest.fixture\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport importlib.metadata\nimport typing as t\nfrom contextlib import contextmanager\nfrom contextlib import ExitStack\nfrom copy import copy\nfrom types import TracebackType\nfrom urllib.parse import urlsplit\n\nimport werkzeug.test\nfrom click.testing import CliRunner\nfrom click.testing import Result\nfrom werkzeug.test import Client\nfrom werkzeug.wrappers import Request as BaseRequest\n\nfrom .cli import ScriptInfo\nfrom .sessions import SessionMixin\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n    from werkzeug.test import TestResponse\n\n    from .app import Flask\n\n\nclass EnvironBuilder(werkzeug.test.EnvironBuilder):\n    \"\"\"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\n    application.\n\n    :param app: The Flask application to configure the environment from.\n    :param path: URL path being requested.\n    :param base_url: Base URL where the app is being served, which\n        ``path`` is relative to. If not given, built from\n        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n    :param url_scheme: Scheme to use instead of\n        :data:`PREFERRED_URL_SCHEME`.\n    :param json: If given, this is serialized as JSON and passed as\n        ``data``. Also defaults ``content_type`` to\n        ``application/json``.\n    :param args: other positional arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    :param kwargs: other keyword arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        path: str = \"/\",\n        base_url: str | None = None,\n        subdomain: str | None = None,\n        url_scheme: str | None = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url i"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "alse\n\n    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :doc:`/testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)\n\n\n@pytest.fixture\ndef app():\n    app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY=\"test key\",\n    )\n    return app\n\n\n@pytest.fixture\ndef app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n\n@pytest.fixture\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for key in sys.modules.keys() - original_modules:\n        sys.modules.pop(key)\n\n\n@pytest.fixture(autouse=True)\ndef leak_detector():\n    yield\n\n    # make sure we're not leaking a request context since we are\n    # testing flask internally in debug mode in a few cases\n    leaks = []\n    while request_ctx:\n        leaks.append(request_ctx._get_current_object())\n        request_ctx.pop()\n\n    assert leaks == []\n\n\n@pytest.fixture\ndef modules_tmp_path(tmp_path, monkeypatch):\n    \"\"\"A temporary directory added to sys.path.\"\"\"\n    rv = tmp_path / \"modules_tmp\"\n    rv.mkdir()\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv\n\n\n@pytest.fixture\ndef modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\n    monkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\n    return modules_tmp_path\n\n\n@pytest.fixture\ndef site_packages(modules_tmp_path, monkeypatch):\n    \"\"\"Create a fake site-packages.\"\"\"\n    py_dir = f\"python{sys.version_info.major}.{sys.version_info.minor}\"\n    rv = modul"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  #:\n    #: Defaults to :class:`werkzeug.exceptions.Aborter`.\n    #:\n    #: .. versionadded:: 2.2\n    aborter_class = Aborter\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute[bool](\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and oth"}, {"start_line": 0, "end_line": 52, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests/test_apps/cliapp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from flask import Flask\n\ntestapp = Flask(\"testapp\")\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_reqctx.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n\n\ndef test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.p"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "testing.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n\n\n_werkzeug_version = \"\"\n\n\ndef _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n    Flask's contexts to defer the cleanup of the request context until\n    the end of a ``with`` block. For general information about how to\n    use this class refer to :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n  "}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(  # type: ignore\n            self, self.response_class, use_cookies=use_cookies, **kwargs\n        )\n\n    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)  # type: ignore\n\n    def handle_http_exception(\n        self, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # "}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around a"}], "retrieved_count": 10, "cost_time": 0.7577455043792725}
{"question": "How does Flask support WebSocket connections?", "answer": null, "relative_code_list": null, "ground_truth": "Flask does not natively support WebSocket connections as it is built on the WSGI standard which is designed for request-response HTTP communication (docs/design.rst:158-201, docs/async-await.rst:1-99). Flask is fundamentally a WSGI application framework that handles traditional HTTP requests and responses. However, there are several ways to add WebSocket support to Flask applications. One approach is to use the asgiref WsgiToAsgi adapter to convert Flask to ASGI, which then enables WebSocket support through ASGI servers (docs/deploying/asgi.rst:1-27). Another approach is to use eventlet or gevent with Flask, which can provide WebSocket capabilities through their WSGI servers (docs/deploying/eventlet.rst:1-71). Flask also supports async/await syntax for view functions, but this is implemented by running coroutines in separate threads rather than using an event loop, which limits its effectiveness for WebSocket-like functionality. For applications that require extensive WebSocket support, the documentation recommends considering Quart, which is a reimplementation of Flask based on the ASGI standard that can handle WebSockets natively. Flask's design philosophy focuses on simplicity and traditional web application patterns rather than real-time communication protocols.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_helpers.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        (\"debug\", \"expect\"),\n        [\n            (\"\", False),\n            (\"0\", False),\n            (\"False\", False),\n            (\"No\", False),\n            (\"True\", True),\n        ],\n    )\n    def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"\n\n\n@pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\ndef test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in"}, {"start_line": 0, "end_line": 750, "belongs_to": {"file_name": "signals.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom blinker import Namespace\n\n# This namespace is only for signals provided by Flask itself.\n_signals = Namespace()\n\ntemplate_rendered = _signals.signal(\"template-rendered\")\nbefore_render_template = _signals.signal(\"before-render-template\")\nrequest_started = _signals.signal(\"request-started\")\nrequest_finished = _signals.signal(\"request-finished\")\nrequest_tearing_down = _signals.signal(\"request-tearing-down\")\ngot_request_exception = _signals.signal(\"got-request-exception\")\nappcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\nappcontext_pushed = _signals.signal(\"appcontext-pushed\")\nappcontext_popped = _signals.signal(\"appcontext-popped\")\nmessage_flashed = _signals.signal(\"message-flashed\")\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\nfrom werkzeug.wsgi import get_host\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskCl"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "wrappers.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.wrappers import Request as RequestBase\nfrom werkzeug.wrappers import Response as ResponseBase\n\nfrom . import json\nfrom .globals import current_app\nfrom .helpers import _split_blueprint_path\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.routing import Rule\n\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    json_module: t.Any = json\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule: Rule | None = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args: dict[str, t.Any] | None = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised / was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception: HTTPException | None = None\n\n"}, {"start_line": 60000, "end_line": 61744, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n"}, {"start_line": 1000, "end_line": 2072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_basic.py", "upper_path": "/data2/raymone/swebench-repos/flask/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n\n\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n\n\ndef test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data =="}], "retrieved_count": 10, "cost_time": 0.7556161880493164}
{"question": "How does Flask implement its extension system for third-party integrations?", "answer": null, "relative_code_list": null, "ground_truth": "Flask implements its extension system for third-party integrations through a well-defined pattern that allows external packages to add functionality to Flask applications (docs/extensions.rst:1-48, docs/extensiondev.rst:1-286). The extension system is based on the principle that extensions should not store application state on themselves, but rather use the init_app pattern to support multiple applications and the application factory pattern. Extensions typically create a class with an init_app method that registers functionality with the Flask application. The system supports various integration points including before_request, after_request, teardown_request, error handlers, template filters, CLI commands, and blueprints. Extensions can access the application through current_app proxy and store application-specific state in app.extensions dictionary. The system includes CLI integration through entry points (docs/cli.rst:395-477) that allow extensions to register commands with the flask CLI. Extensions follow naming conventions (Flask-ExtensionName or ExtensionName-Flask) and are designed to support multiple applications running in the same process. The extension system enables Flask to remain a micro-framework while providing a rich ecosystem of third-party functionality for database integration, form validation, authentication, and other features. Extensions can add views, models, configuration options, and custom behavior while maintaining compatibility with Flask's core design principles.", "score": null, "retrieved_content": [{"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n   "}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n      "}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__`"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a d"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "om .scaffold import find_package\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n\n    from ..testing import FlaskClient\n    from ..testing import FlaskCliRunner\n    from .blueprints import Blueprint\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import StartResponse\n    from _typeshed.wsgi import WSGIEnvironment\n\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n    from .typing import HeadersValue\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n\n\nclass Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and mu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappe"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "app.py", "upper_path": "/data2/raymone/swebench-repos/flask/src/flask/sansio", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "y as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the requ"}], "retrieved_count": 10, "cost_time": 0.7539458274841309}
