{"question": "What is the structure of messages in Pylint?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint messages have a structured format that includes several key components: 1) Message ID - a unique identifier (e.g., 'W0101') that indicates the message type and category, 2) Symbol - a human-readable name for the message (e.g., 'unreachable'), 3) Message text - the descriptive text explaining the issue, 4) Location information - file path, line number, column number, and optional end positions, 5) Confidence level - indicating how certain Pylint is about the analysis result, 6) Category - the severity level (convention, refactor, warning, error, fatal), 7) Module and object context - information about the containing module and function/class, 8) Optional arguments - additional context-specific information. Messages are created by checkers using the add_message() method and are processed by reporters for output in various formats. The structured format allows for consistent reporting and enables tools to parse and process the output programmatically.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass\n\nfrom pylint.constants import MSG_TYPES\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.typing import MessageLocationTuple\n\n\n@dataclass(unsafe_hash=True)\nclass Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None\n    end_column: int | None\n\n    def __init__(\n        self,\n        msg_id: str,\n        symbol: str,\n        location: MessageLocationTuple,\n        msg: str,\n        confidence: Confidence | None,\n    ) -> None:\n        self.msg_id = msg_id\n        self.symbol = symbol\n        self.msg = msg\n        self.C = msg_id[0]\n        self.category = MSG_TYPES[msg_id[0]]\n        self.confidence = confidence or UNDEFINED\n        self.abspath = location.abspath\n        self.path = location.path\n        self.module = location.module\n        self.obj = location.obj\n        self.line = location.line\n        self.column = location.column\n        self.end_line = location.end_line\n        self.end_column = location.end_column\n\n    def format(self, template: str) -> str:\n        \"\"\"Format the message according to the given template.\n\n        The template format is the one of the format method :\n        cf. https://docs.python.org/2/library/string.html#formatstrings\n        \"\"\"\n        return template.format(**asdict(self))\n\n    @property\n    def location(self) -> MessageLocationTuple:\n        return MessageLocationTuple(\n            self.abspath,\n            self.pa"}, {"start_line": 0, "end_line": 632, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"All the classes related to Message handling.\"\"\"\n\nfrom pylint.message.message import Message\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_definition_store import MessageDefinitionStore\nfrom pylint.message.message_id_store import MessageIdStore\n\n__all__ = [\n    \"Message\",\n    \"MessageDefinition\",\n    \"MessageDefinitionStore\",\n    \"MessageIdStore\",\n]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "output_line.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Any, NamedTuple, TypeVar\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.message.message import Message\n\n_T = TypeVar(\"_T\")\n\n\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.\n\n    Class name cannot start with Test as pytest doesn't allow constructors in test classes.\n    \"\"\"\n\n\nclass OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n\n    @classmethod\n    def from_msg(cls, msg: Message, check_endline: bool = True) -> OutputLine:\n        \"\"\"Create an OutputLine from a Pylint Message.\"\"\"\n        column = cls._get_column(msg.column)\n        end_line = cls._get_end_line_and_end_col(msg.end_line, check_endline)\n        end_column = cls._get_end_line_and_end_col(msg.end_column, check_endline)\n        return cls(\n            msg.symbol,\n            msg.line,\n            column,\n            end_line,\n            end_column,\n            msg.obj or \"\",\n            msg.msg.replace(\"\\r\\n\", \"\\n\"),\n            msg.confidence.name,\n        )\n\n    @staticmethod\n    def _get_column(column: str | int) -> int:\n        \"\"\"Handle column numbers.\"\"\"\n        return int(column)\n\n    @staticmethod\n    def _get_end_line_and_end_col(value: _T, check_endline: bool) -> _T | None:\n        \"\"\"Used to make end_line and end_column N"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_definition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.constants import _SCOPE_EXEMPT, MSG_TYPES, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.utils import normalize_text\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n\n\nclass MessageDefinition:\n    # pylint: disable-next=too-many-arguments\n    def __init__(\n        self,\n        checker: BaseChecker,\n        msgid: str,\n        msg: str,\n        description: str,\n        symbol: str,\n        scope: str,\n        minversion: tuple[int, int] | None = None,\n        maxversion: tuple[int, int] | None = None,\n        old_names: list[tuple[str, str]] | None = None,\n        shared: bool = False,\n        default_enabled: bool = True,\n    ) -> None:\n        self.checker_name = checker.name\n        self.check_msgid(msgid)\n        self.msgid = msgid\n        self.symbol = symbol\n        self.msg = msg\n        self.description = description\n        self.scope = scope\n        self.minversion = minversion\n        self.maxversion = maxversion\n        self.shared = shared\n        self.default_enabled = default_enabled\n        self.old_names: list[tuple[str, str]] = []\n        if old_names:\n            for old_msgid, old_symbol in old_names:\n                self.check_msgid(old_msgid)\n                self.old_names.append(\n                    (old_msgid, old_symbol),\n                )\n\n    @staticmethod\n    def check_msgid(msgid: str) -> None:\n        if len(msgid) != 5:\n            raise InvalidMessageError(f\"Invalid message id {msgid!r}\")\n        if msgid[0] not in MSG_TYPES:\n            raise InvalidMessageError(f\"Bad message type {msgid[0]} in {msgid!r}\")\n\n    def __eq__(self, other: object) ->"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_definition_store.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nimport sys\nfrom collections.abc import Sequence, ValuesView\nfrom functools import cache\nfrom typing import TYPE_CHECKING\n\nfrom pylint.exceptions import UnknownMessageError\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_id_store import MessageIdStore\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n\n\nclass MessageDefinitionStore:\n    \"\"\"The messages store knows information about every possible message definition but\n    has no particular state during analysis.\n    \"\"\"\n\n    def __init__(\n        self, py_version: tuple[int, ...] | sys._version_info = sys.version_info\n    ) -> None:\n        self.message_id_store: MessageIdStore = MessageIdStore()\n        # Primary registry for all active messages definitions.\n        # It contains the 1:1 mapping from msgid to MessageDefinition.\n        # Keys are msgid, values are MessageDefinition\n        self._messages_definitions: dict[str, MessageDefinition] = {}\n        # MessageDefinition kept by category\n        self._msgs_by_category: dict[str, list[str]] = collections.defaultdict(list)\n        self.py_version = py_version\n\n    @property\n    def messages(self) -> ValuesView[MessageDefinition]:\n        \"\"\"The list of all active messages.\"\"\"\n        return self._messages_definitions.values()\n\n    def register_messages_from_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Register all messages definitions from a checker.\"\"\"\n        checker.check_consistency()\n        for message in checker.messages:\n            self.register_message(message)\n\n    def register_message(self, message: MessageDefinition) -> None:\n        \"\"\"Register a MessageDefinition with consistency in mind.\"\"\"\n      "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylint_messages.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Script used to generate the messages files.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import defaultdict\nfrom enum import Enum\nfrom inspect import getmodule\nfrom itertools import chain, groupby\nfrom pathlib import Path\nfrom typing import NamedTuple\n\nfrom sphinx.application import Sphinx\n\nfrom pylint.checkers import initialize as initialize_checkers\nfrom pylint.constants import MSG_TYPES\nfrom pylint.extensions import initialize as initialize_extensions\nfrom pylint.lint import PyLinter\nfrom pylint.message import MessageDefinition\nfrom pylint.utils import get_rst_title\n\nPYLINT_BASE_PATH = Path(__file__).resolve().parent.parent.parent\n\"\"\"Base path to the project folder.\"\"\"\n\nPYLINT_MESSAGES_PATH = PYLINT_BASE_PATH / \"doc/user_guide/messages\"\n\"\"\"Path to the messages documentation folder.\"\"\"\n\nPYLINT_MESSAGES_DATA_PATH = PYLINT_BASE_PATH / \"doc\" / \"data\" / \"messages\"\n\"\"\"Path to the folder with data for the messages documentation.\"\"\"\n\nMSG_TYPES_DOC = {k: v if v != \"info\" else \"information\" for k, v in MSG_TYPES.items()}\n\nMESSAGES_WITHOUT_EXAMPLES = {\n    \"astroid-error\",  # internal\n    \"bad-configuration-section\",  # configuration\n    \"bad-plugin-value\",  # internal\n    \"c-extension-no-member\",  # not easy to implement in the current doc framework\n    \"config-parse-error\",  # configuration\n    \"fatal\",  # internal\n    \"import-self\",  # not easy to implement in the current doc framework\n    \"invalid-character-nul\",  # not easy to implement in the current doc framework\n    \"invalid-characters-in-docstring\",  # internal in py-enchant\n    \"invalid-unicode-codec\",  # placeholder (not implemented yet)\n    \"method-check-failed\",  # internal\n    \"parse-error\",  # internal\n    \"raw-checker-failed\",  # internal\n    \"unrecognized"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import ValuesView\n\nfrom pylint.interfaces import HIGH\nfrom pylint.message import Message\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import MessageLocationTuple\n\n\ndef test_new_message(message_definitions: ValuesView[MessageDefinition]) -> None:\n    def build_message(\n        message_definition_: MessageDefinition, location_value: MessageLocationTuple\n    ) -> Message:\n        return Message(\n            symbol=message_definition_.symbol,\n            msg_id=message_definition_.msgid,\n            location=location_value,\n            msg=message_definition_.msg,\n            confidence=HIGH,\n        )\n\n    template = \"{path}:{line}:{column}: {msg_id}: {msg} ({symbol})\"\n    for message_definition in message_definitions:\n        if message_definition.msgid == \"E1234\":\n            e1234_message_definition = message_definition\n        if message_definition.msgid == \"W1234\":\n            w1234_message_definition = message_definition\n    e1234_location_values = MessageLocationTuple(\n        abspath=\"1\",\n        path=\"2\",\n        module=\"3\",\n        obj=\"4\",\n        line=5,\n        column=6,\n        end_line=5,\n        end_column=9,\n    )\n    w1234_location_values = MessageLocationTuple(\n        abspath=\"7\",\n        path=\"8\",\n        module=\"9\",\n        obj=\"10\",\n        line=11,\n        column=12,\n        end_line=11,\n        end_column=14,\n    )\n    expected = (\n        \"2:5:6: E1234: Duplicate keyword argument %r in %s call (duplicate-keyword-arg)\"\n    )\n    # pylint: disable=possibly-used-before-assignment\n    e1234 = build_message(e1234_message_definition, e1234_location_values)\n    w1234 = build_message(w1234_message_definition, w1234_location_values"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}], "retrieved_count": 10, "cost_time": 1.0482690334320068}
{"question": "What is the role of the severity level in Pylint's message classification system?", "answer": null, "relative_code_list": null, "ground_truth": "The severity level in Pylint's message classification system helps users prioritize which issues to address first. It provides a hierarchical categorization of issues based on their impact and importance: Convention (C) issues are style violations and coding standards that improve code readability but don't affect functionality. Refactor (R) issues suggest code improvements for better maintainability. Warning (W) issues indicate potential problems that might cause issues. Error (E) issues are definite problems that will cause issues. Fatal (F) issues are severe errors that prevent Pylint from continuing analysis. Users can configure which severity levels to display or ignore, allowing them to focus on the most critical issues first. The severity system helps teams establish coding standards and prioritize code quality improvements based on their impact.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 0, "end_line": 1191, "belongs_to": {"file_name": "interfaces.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n__all__ = (\n    \"CONFIDENCE_LEVELS\",\n    \"CONFIDENCE_LEVEL_NAMES\",\n    \"CONTROL_FLOW\",\n    \"HIGH\",\n    \"INFERENCE\",\n    \"INFERENCE_FAILURE\",\n    \"UNDEFINED\",\n)\n\n\nclass Confidence(NamedTuple):\n    name: str\n    description: str\n\n\n# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\n\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nCONFIDENCE_MAP = {i.name: i for i in CONFIDENCE_LEVELS}\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass\n\nfrom pylint.constants import MSG_TYPES\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.typing import MessageLocationTuple\n\n\n@dataclass(unsafe_hash=True)\nclass Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None\n    end_column: int | None\n\n    def __init__(\n        self,\n        msg_id: str,\n        symbol: str,\n        location: MessageLocationTuple,\n        msg: str,\n        confidence: Confidence | None,\n    ) -> None:\n        self.msg_id = msg_id\n        self.symbol = symbol\n        self.msg = msg\n        self.C = msg_id[0]\n        self.category = MSG_TYPES[msg_id[0]]\n        self.confidence = confidence or UNDEFINED\n        self.abspath = location.abspath\n        self.path = location.path\n        self.module = location.module\n        self.obj = location.obj\n        self.line = location.line\n        self.column = location.column\n        self.end_line = location.end_line\n        self.end_column = location.end_column\n\n    def format(self, template: str) -> str:\n        \"\"\"Format the message according to the given template.\n\n        The template format is the one of the format method :\n        cf. https://docs.python.org/2/library/string.html#formatstrings\n        \"\"\"\n        return template.format(**asdict(self))\n\n    @property\n    def location(self) -> MessageLocationTuple:\n        return MessageLocationTuple(\n            self.abspath,\n            self.pa"}, {"start_line": 0, "end_line": 632, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"All the classes related to Message handling.\"\"\"\n\nfrom pylint.message.message import Message\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_definition_store import MessageDefinitionStore\nfrom pylint.message.message_id_store import MessageIdStore\n\n__all__ = [\n    \"Message\",\n    \"MessageDefinition\",\n    \"MessageDefinitionStore\",\n    \"MessageIdStore\",\n]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_definition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.constants import _SCOPE_EXEMPT, MSG_TYPES, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.utils import normalize_text\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n\n\nclass MessageDefinition:\n    # pylint: disable-next=too-many-arguments\n    def __init__(\n        self,\n        checker: BaseChecker,\n        msgid: str,\n        msg: str,\n        description: str,\n        symbol: str,\n        scope: str,\n        minversion: tuple[int, int] | None = None,\n        maxversion: tuple[int, int] | None = None,\n        old_names: list[tuple[str, str]] | None = None,\n        shared: bool = False,\n        default_enabled: bool = True,\n    ) -> None:\n        self.checker_name = checker.name\n        self.check_msgid(msgid)\n        self.msgid = msgid\n        self.symbol = symbol\n        self.msg = msg\n        self.description = description\n        self.scope = scope\n        self.minversion = minversion\n        self.maxversion = maxversion\n        self.shared = shared\n        self.default_enabled = default_enabled\n        self.old_names: list[tuple[str, str]] = []\n        if old_names:\n            for old_msgid, old_symbol in old_names:\n                self.check_msgid(old_msgid)\n                self.old_names.append(\n                    (old_msgid, old_symbol),\n                )\n\n    @staticmethod\n    def check_msgid(msgid: str) -> None:\n        if len(msgid) != 5:\n            raise InvalidMessageError(f\"Invalid message id {msgid!r}\")\n        if msgid[0] not in MSG_TYPES:\n            raise InvalidMessageError(f\"Bad message type {msgid[0]} in {msgid!r}\")\n\n    def __eq__(self, other: object) ->"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline iteration\",\n    \"typevar\": \"type variable\",\n    \"typealias\": \"type alias\",\n}\n\n# ignore some messages when emitting useless-suppression:\n# - cyclic-import: can show false positives due to incomplete context\n# - deprecated-{module, argument, class, method, decorator}:\n#   can cause false positives for multi-interpreter projects\n#   when linting with an interpreter on a lower python version\nINCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset(\n    [\n        \"R0401\",  # cyclic-import\n        \"W0402\",  # deprecated-module\n        \"W1505\",  # deprecated-method\n        \"W1511\",  # deprecated-argument\n        \"W1512\",  # deprecated-class\n        \"W1513\",  # deprecated-decorator\n        \"R0801\",  # duplicate-code\n    ]\n)\n\n\ndef _get_pylint_home() -> str:\n    \"\"\"Return the pylint home.\"\"\"\n    if \"PYLINTHOME\" in os.environ:\n        return os.environ[\"PYLINTHOME\"]\n    return DEFAULT_PYLINT_HOME\n\n\nPYLINT_HOME = _get_pylint_home()\n\nTYPING_NORETURN = frozenset(\n    (\n        \"typing.NoReturn\",\n        \"ty"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "output_line.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Any, NamedTuple, TypeVar\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.message.message import Message\n\n_T = TypeVar(\"_T\")\n\n\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.\n\n    Class name cannot start with Test as pytest doesn't allow constructors in test classes.\n    \"\"\"\n\n\nclass OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n\n    @classmethod\n    def from_msg(cls, msg: Message, check_endline: bool = True) -> OutputLine:\n        \"\"\"Create an OutputLine from a Pylint Message.\"\"\"\n        column = cls._get_column(msg.column)\n        end_line = cls._get_end_line_and_end_col(msg.end_line, check_endline)\n        end_column = cls._get_end_line_and_end_col(msg.end_column, check_endline)\n        return cls(\n            msg.symbol,\n            msg.line,\n            column,\n            end_line,\n            end_column,\n            msg.obj or \"\",\n            msg.msg.replace(\"\\r\\n\", \"\\n\"),\n            msg.confidence.name,\n        )\n\n    @staticmethod\n    def _get_column(column: str | int) -> int:\n        \"\"\"Handle column numbers.\"\"\"\n        return int(column)\n\n    @staticmethod\n    def _get_end_line_and_end_col(value: _T, check_endline: bool) -> _T | None:\n        \"\"\"Used to make end_line and end_column N"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_definition_store.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nimport sys\nfrom collections.abc import Sequence, ValuesView\nfrom functools import cache\nfrom typing import TYPE_CHECKING\n\nfrom pylint.exceptions import UnknownMessageError\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_id_store import MessageIdStore\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n\n\nclass MessageDefinitionStore:\n    \"\"\"The messages store knows information about every possible message definition but\n    has no particular state during analysis.\n    \"\"\"\n\n    def __init__(\n        self, py_version: tuple[int, ...] | sys._version_info = sys.version_info\n    ) -> None:\n        self.message_id_store: MessageIdStore = MessageIdStore()\n        # Primary registry for all active messages definitions.\n        # It contains the 1:1 mapping from msgid to MessageDefinition.\n        # Keys are msgid, values are MessageDefinition\n        self._messages_definitions: dict[str, MessageDefinition] = {}\n        # MessageDefinition kept by category\n        self._msgs_by_category: dict[str, list[str]] = collections.defaultdict(list)\n        self.py_version = py_version\n\n    @property\n    def messages(self) -> ValuesView[MessageDefinition]:\n        \"\"\"The list of all active messages.\"\"\"\n        return self._messages_definitions.values()\n\n    def register_messages_from_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Register all messages definitions from a checker.\"\"\"\n        checker.check_consistency()\n        for message in checker.messages:\n            self.register_message(message)\n\n    def register_message(self, message: MessageDefinition) -> None:\n        \"\"\"Register a MessageDefinition with consistency in mind.\"\"\"\n      "}], "retrieved_count": 10, "cost_time": 1.0486268997192383}
{"question": "What dependencies exist between Pylint's astroid library and the checker system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's astroid library and checker system have a fundamental dependency relationship. Astroid provides the enhanced AST representation that all AST-based checkers depend on for analysis. Checkers rely on astroid's node types, inference capabilities, and additional information beyond the standard library's ast module. Astroid's type inference system enables sophisticated type-related checks, while its import resolution capabilities allow checkers to analyze cross-module dependencies. The checker system depends on astroid's ability to handle syntax errors gracefully and provide detailed location information for diagnostic messages. Astroid's transformation capabilities, such as decorator expansion and class hierarchy analysis, enable checkers to perform more accurate analysis. This dependency ensures that improvements to astroid's capabilities directly benefit all Pylint checkers.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "custom.py", "upper_path": "/data2/raymone/swebench-repos/pylint/examples", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# Checkers should always inherit from `BaseChecker`.\n\n\nclass MyAstroidChecker(BaseChecker):\n    \"\"\"Add class member attributes to the class local's dictionary.\"\"\"\n\n    # The name defines a custom section of the config for this checker.\n    name = \"custom\"\n    # This class variable declares the messages (i.e. the warnings and errors)\n    # that the checker can emit.\n    msgs = {\n        # Each message has a code, a message that the user will see,\n        # a unique symbol that identifies the message,\n        # and a detailed help message\n        # that will be included in the documentation.\n        \"W0001\": (\"Message that will be emitted\", \"message-symbol\", \"Message help\")\n    }\n    # This class variable declares the options\n    # that are configurable by the user.\n    options = (\n        # Each option definition has a name which is used on the command line\n        # and in config files, and a dictionary of arguments\n        # (similar to argparse.ArgumentParser.add_argument).\n        (\n            \"store-locals-indicator\",\n            {\n                \"default\": \"properties\",\n                \"help\": (\n                    \"The expression name that indicates that the locals should \"\n                    \"be stored\"\n                ),\n            },\n        ),\n    )\n\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`.nodes.Call` node is visited.\n\n        See :mod:`astroid` for the description of available nodes.\n        \"\"\"\n        if not (\n            isinstance(node.func, nodes.Attribute)\n            and isinstance(node.func.expr, nodes.Name)\n            and node.func.expr.name == self.linter.config.store_locals_indicator\n            and node.func.attrname == \"create\"\n        ):\n            return\n        in_class = node.frame()\n        for p"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "statements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no activated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}], "retrieved_count": 10, "cost_time": 1.049900770187378}
{"question": "What is the role of the _ArgumentsManager class in Pylint's configuration system?", "answer": null, "relative_code_list": null, "ground_truth": "The _ArgumentsManager class is the central component of Pylint's configuration system that handles command-line argument parsing and option management. It maintains a hierarchical configuration structure with support for per-directory configurations, allowing different settings for different parts of a codebase. The _ArgumentsManager registers options from various providers (checkers, reporters, etc.), parses configuration files in multiple formats (INI, TOML, pyproject.toml), and handles command-line arguments with proper precedence (command-line overrides config file overrides defaults). It provides a unified interface for accessing configuration values and manages the relationship between option definitions and their runtime values.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stants import MAIN_CHECKER_NAME\nfrom pylint.typing import DirectoryNamespaceDict, OptionDict\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\n\nif TYPE_CHECKING:\n    from pylint.config.arguments_provider import _ArgumentsProvider\n\n\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n\n        This is necessary for the per-directory configuration support. Whenever we\n        fail to match a file with a directory we fall back to the Namespace object\n        created during initialization.\n        \"\"\"\n\n        self._arg_parser = argparse.ArgumentParser(\n            prog=prog,\n            usage=usage or \"%(prog)s [options]\",\n            description=description,\n            formatter_class=_HelpFormatter,\n            # Needed to let 'pylint-config' overwrite the -h command\n            conflict_handler=\"resolve\",\n        )\n        \"\"\"The command line argument parser.\"\"\"\n\n        self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n        \"\"\"Dictionary of all the argument groups.\"\"\"\n\n        self._option_dicts: dict[str, OptionDict] = {}\n        \"\"\"All option dictionaries that have been registered.\"\"\"\n\n        self._directory_namespaces: DirectoryNamespaceDict = {}\n        \"\"\"Mapping of directories and their respective namespace objects.\"\"\"\n\n    @property\n    def config(self) -> argparse.Namespace:\n        \"\"\"Namespace for all options.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: argparse.Namespace) -> None:\n        self._config = value\n\n    def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n        \"\""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport re\nimport sys\nimport textwrap\nimport warnings\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Any, TextIO\n\nimport tomlkit\n\nfrom pylint import utils\nfrom pylint.config.argument import (\n    _Argument,\n    _CallableArgument,\n    _ExtendArgument,\n    _StoreArgument,\n    _StoreNewNamesArgument,\n    _StoreOldNamesArgument,\n    _StoreTrueArgument,\n)\nfrom pylint.config.exceptions import (\n    UnrecognizedArgumentAction,\n    _UnrecognizedOptionError,\n)\nfrom pylint.config.help_formatter import _HelpFormatter\nfrom pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value\nfrom pylint.constants import MAIN_CHECKER_NAME\nfrom pylint.typing import DirectoryNamespaceDict, OptionDict\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\n\nif TYPE_CHECKING:\n    from pylint.config.arguments_provider import _ArgumentsProvider\n\n\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n\n        This is necessary for the per-directory configuration support. Whenever we\n        fail to match a file with a directory we fall back to the Namespace object\n        created during initialization.\n        \"\"\"\n\n        self._arg_parser = argparse.ArgumentParser(\n            prog=prog,\n            usa"}, {"start_line": 0, "end_line": 826, "belongs_to": {"file_name": "exceptions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\n\nclass UnrecognizedArgumentAction(Exception):\n    \"\"\"Raised if an ArgumentManager instance tries to add an argument for which the\n    action is not recognized.\n    \"\"\"\n\n\nclass _UnrecognizedOptionError(Exception):\n    \"\"\"Raised if an ArgumentManager instance tries to parse an option that is\n    unknown.\n    \"\"\"\n\n    def __init__(self, options: list[str], *args: object) -> None:\n        self.options = options\n        super().__init__(*args)\n\n\nclass ArgumentPreprocessingError(Exception):\n    \"\"\"Raised if an error occurs during argument pre-processing.\"\"\"\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "arguments_provider.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Arguments provider class used to expose options.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom typing import Any\n\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.typing import OptionDict, Options\n\n\nclass _ArgumentsProvider:\n    \"\"\"Base class for classes that provide arguments.\"\"\"\n\n    name: str\n    \"\"\"Name of the provider.\"\"\"\n\n    options: Options = ()\n    \"\"\"Options provided by this provider.\"\"\"\n\n    option_groups_descs: dict[str, str] = {}\n    \"\"\"Option groups of this provider and their descriptions.\"\"\"\n\n    def __init__(self, arguments_manager: _ArgumentsManager) -> None:\n        self._arguments_manager = arguments_manager\n        \"\"\"The manager that will parse and register any options provided.\"\"\"\n\n        self._arguments_manager._register_options_provider(self)\n\n    def _option_value(self, opt: str) -> Any:\n        \"\"\"Get the current value for the given option.\"\"\"\n        return getattr(self._arguments_manager.config, opt.replace(\"-\", \"_\"), None)\n\n    def _options_by_section(\n        self,\n    ) -> Iterator[\n        tuple[str, list[tuple[str, OptionDict, Any]]]\n        | tuple[None, dict[str, list[tuple[str, OptionDict, Any]]]]\n    ]:\n        \"\"\"Return an iterator on options grouped by section.\n\n        (section, [list of (optname, optdict, optvalue)])\n        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n            yield None, sections.pop(None)  # type: ignore[call-overload]\n        for section, optio"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ge=usage or \"%(prog)s [options]\",\n            description=description,\n            formatter_class=_HelpFormatter,\n            # Needed to let 'pylint-config' overwrite the -h command\n            conflict_handler=\"resolve\",\n        )\n        \"\"\"The command line argument parser.\"\"\"\n\n        self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n        \"\"\"Dictionary of all the argument groups.\"\"\"\n\n        self._option_dicts: dict[str, OptionDict] = {}\n        \"\"\"All option dictionaries that have been registered.\"\"\"\n\n        self._directory_namespaces: DirectoryNamespaceDict = {}\n        \"\"\"Mapping of directories and their respective namespace objects.\"\"\"\n\n    @property\n    def config(self) -> argparse.Namespace:\n        \"\"\"Namespace for all options.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: argparse.Namespace) -> None:\n        self._config = value\n\n    def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n        \"\"\"Register an options provider and load its defaults.\"\"\"\n        for opt, optdict in provider.options:\n            self._option_dicts[opt] = optdict\n            argument = _convert_option_to_argument(opt, optdict)\n            section = argument.section or provider.name.capitalize()\n\n            section_desc = provider.option_groups_descs.get(section, None)\n\n            # We exclude main since its docstring comes from PyLinter\n            if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n                section_desc = provider.__doc__.split(\"\\n\\n\")[0]\n\n            self._add_arguments_to_parser(section, section_desc, argument)\n\n        self._load_default_argument_values()\n\n    def _add_arguments_to_parser(\n        self, section: str, section_desc: str | None, argument: _Argument\n    ) -> None:\n        \"\"\"Add an argument to the correct argument section/group.\"\"\"\n        try:\n            section_group = self._argument_groups_dict[section]\n        except KeyError:\n            if se"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "argument.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Definition of an Argument class and transformers for various argument types.\n\nAn Argument instance represents a pylint option to be handled by an argparse.ArgumentParser\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport pathlib\nimport re\nfrom collections.abc import Callable, Sequence\nfrom glob import glob\nfrom re import Pattern\nfrom typing import Any, Literal\n\nfrom pylint import interfaces\nfrom pylint import utils as pylint_utils\nfrom pylint.config.callback_actions import _CallbackAction\nfrom pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction\n\n_ArgumentTypes = (\n    str\n    | int\n    | float\n    | bool\n    | Pattern[str]\n    | Sequence[str]\n    | Sequence[Pattern[str]]\n    | tuple[int, ...]\n)\n\"\"\"List of possible argument types.\"\"\"\n\n\ndef _confidence_transformer(value: str) -> Sequence[str]:\n    \"\"\"Transforms a comma separated string of confidence values.\"\"\"\n    if not value:\n        return interfaces.CONFIDENCE_LEVEL_NAMES\n    values = pylint_utils._check_csv(value)\n    for confidence in values:\n        if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:\n            raise argparse.ArgumentTypeError(\n                f\"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}\"\n            )\n    return values\n\n\ndef _csv_transformer(value: str) -> Sequence[str]:\n    \"\"\"Transforms a comma separated string.\"\"\"\n    return pylint_utils._check_csv(value)\n\n\nYES_VALUES = {\"y\", \"yes\", \"true\"}\nNO_VALUES = {\"n\", \"no\", \"false\"}\n\n\ndef _yn_transformer(value: str) -> bool:\n    \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n    value = value.lower()\n    if value in YES_VALUES:\n        return True\n    if value in NO_VALUES:\n        return False\n    raise argparse.ArgumentTypeError(\n        Non"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Utils for arguments/options parsing and handling.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom collections.abc import Callable, Sequence\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nfrom pylint import extensions, utils\nfrom pylint.config.argument import (\n    _CallableArgument,\n    _ExtendArgument,\n    _StoreArgument,\n    _StoreNewNamesArgument,\n    _StoreOldNamesArgument,\n    _StoreTrueArgument,\n)\nfrom pylint.config.callback_actions import _CallbackAction\nfrom pylint.config.exceptions import ArgumentPreprocessingError\n\nif TYPE_CHECKING:\n    from pylint.lint.run import Run\n\n\ndef _convert_option_to_argument(\n    opt: str, optdict: dict[str, Any]\n) -> (\n    _StoreArgument\n    | _StoreTrueArgument\n    | _CallableArgument\n    | _StoreOldNamesArgument\n    | _StoreNewNamesArgument\n    | _ExtendArgument\n):\n    \"\"\"Convert an optdict to an Argument class instance.\"\"\"\n    # Get the long and short flags\n    flags = [f\"--{opt}\"]\n    if \"short\" in optdict:\n        flags += [f\"-{optdict['short']}\"]\n\n    # Get the action type\n    action = optdict.get(\"action\", \"store\")\n\n    if action == \"store_true\":\n        return _StoreTrueArgument(\n            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n        return _CallableArgument(\n            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_argparse_config.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Test for the (new) implementation of option parsing with argparse.\"\"\"\n\nimport re\nfrom os.path import abspath, dirname, join\n\nimport pytest\n\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.config.exceptions import UnrecognizedArgumentAction\nfrom pylint.testutils._run import _Run as Run\n\nHERE = abspath(dirname(__file__))\nREGRTEST_DATA_DIR = join(HERE, \"..\", \"regrtest_data\")\nEMPTY_MODULE = join(REGRTEST_DATA_DIR, \"empty.py\")\nLOGGING_TEST = join(HERE, \"data\", \"logging_format_interpolation_style.py\")\n\n\nclass TestArgparseOptionsProviderMixin:\n    \"\"\"Tests for the argparse implementation of OptionsProviderMixIn.\n\n    The logger checker is used as an example checker for this implementation.\n    \"\"\"\n\n    @staticmethod\n    def test_logger_without_options() -> None:\n        \"\"\"Check that we raise messages when we do not supply any options.\"\"\"\n        with pytest.raises(SystemExit) as ex:\n            Run([LOGGING_TEST])\n        assert ex.value.code == 2\n\n    @staticmethod\n    def test_logger_commandline() -> None:\n        \"\"\"Check that we parse command-line options for the logging checker correctly.\"\"\"\n        with pytest.raises(SystemExit) as ex:\n            Run([LOGGING_TEST, \"--logging-format-style=new\"])\n        assert ex.value.code == 0\n\n    @staticmethod\n    def test_logger_rcfile() -> None:\n        \"\"\"Check that we parse the rcfile for the logging checker correctly.\"\"\"\n        with pytest.raises(SystemExit) as ex:\n            # replace only the last .py in the string with .rc\n            # we do so by inverting the string and replace the first occurrence (of the inverted tokens!)\n            _rcfile = LOGGING_TEST[::-1].replace(\"yp.\", \"cr.\", 1)[::-1]\n            Run([LOGGING_TEST, f\"--rcfile={_rcfile}\"])\n        as"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "argument.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing and return one of the supported\nArgument types. It will only be called when parsing 1) command-line,\n2) configuration files and 3) a string default value.\nNon-string default values are assumed to be of the correct type.\n\"\"\"\n\n\nclass _Argument:\n    \"\"\"Class representing an argument to be parsed by an argparse.ArgumentsParser.\n\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        flags: list[str],\n        arg_help: str,\n        hide_help: bool,\n        section: str | None,\n    ) -> None:\n        self.flags = flags\n        \"\"\"The name of the argument.\"\"\"\n\n        self.hide_help = hide_help\n        \"\"\"Whether to hide this argument in the help message.\"\"\"\n\n        # argparse uses % formatting on help strings, so a % needs to be escaped\n        self.help = arg_help.replace(\"%\", \"%%\")\n        \"\"\"The description of the argument.\"\"\"\n\n        if hide_help:\n            self.help = argparse.SUPPRESS\n\n        self.section = section\n        \"\"\"The section to add this argument to.\"\"\"\n\n\nclass _BaseStoreArgument(_Argument):\n    \"\"\"Base class for store arguments to be parsed by an argparse.ArgumentsParser.\n\n    This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n    See:\n    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        flags: list[str],\n        action: str,\n        default: _ArgumentTypes,\n        arg_help: str,\n        hide_help: bool,\n        section: str | None,\n    ) -> None:\n        super().__init__(\n            flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n        )\n\n        self.action = action\n        \"\"\"The action to perform with the argument.\"\"\"\n\n        self.default = default\n        \"\"\"The default value of the argument.\"\"\"\n\n\nclass _Sto"}], "retrieved_count": 10, "cost_time": 1.0741899013519287}
{"question": "Why does Pylint include confidence levels in its diagnostic messages?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint includes confidence levels in its diagnostic messages for several important reasons: 1) Analysis reliability - helps users understand how certain Pylint is about the detected issue, 2) False positive management - users can filter out less certain warnings to reduce noise, 3) Decision making - developers can prioritize fixes based on confidence levels, 4) Type inference limitations - Python's dynamic typing means some analysis results are inherently uncertain, 5) Complex code handling - confidence levels help users understand when analysis is limited by code complexity, 6) Tool integration - IDEs and other tools can provide different visual indicators for different confidence levels, 7) Team communication - confidence levels help teams discuss and validate analysis results, 8) Configuration flexibility - users can configure which confidence levels to display or ignore, 9) Learning tool - helps developers understand the limitations of static analysis, 10) Quality assurance - teams can establish policies for handling different confidence levels. This transparency helps users make informed decisions about which warnings to address.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1191, "belongs_to": {"file_name": "interfaces.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n__all__ = (\n    \"CONFIDENCE_LEVELS\",\n    \"CONFIDENCE_LEVEL_NAMES\",\n    \"CONTROL_FLOW\",\n    \"HIGH\",\n    \"INFERENCE\",\n    \"INFERENCE_FAILURE\",\n    \"UNDEFINED\",\n)\n\n\nclass Confidence(NamedTuple):\n    name: str\n    description: str\n\n\n# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\n\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nCONFIDENCE_MAP = {i.name: i for i in CONFIDENCE_LEVELS}\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass\n\nfrom pylint.constants import MSG_TYPES\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.typing import MessageLocationTuple\n\n\n@dataclass(unsafe_hash=True)\nclass Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None\n    end_column: int | None\n\n    def __init__(\n        self,\n        msg_id: str,\n        symbol: str,\n        location: MessageLocationTuple,\n        msg: str,\n        confidence: Confidence | None,\n    ) -> None:\n        self.msg_id = msg_id\n        self.symbol = symbol\n        self.msg = msg\n        self.C = msg_id[0]\n        self.category = MSG_TYPES[msg_id[0]]\n        self.confidence = confidence or UNDEFINED\n        self.abspath = location.abspath\n        self.path = location.path\n        self.module = location.module\n        self.obj = location.obj\n        self.line = location.line\n        self.column = location.column\n        self.end_line = location.end_line\n        self.end_column = location.end_column\n\n    def format(self, template: str) -> str:\n        \"\"\"Format the message according to the given template.\n\n        The template format is the one of the format method :\n        cf. https://docs.python.org/2/library/string.html#formatstrings\n        \"\"\"\n        return template.format(**asdict(self))\n\n    @property\n    def location(self) -> MessageLocationTuple:\n        return MessageLocationTuple(\n            self.abspath,\n            self.pa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "output_line.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Any, NamedTuple, TypeVar\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.message.message import Message\n\n_T = TypeVar(\"_T\")\n\n\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.\n\n    Class name cannot start with Test as pytest doesn't allow constructors in test classes.\n    \"\"\"\n\n\nclass OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n\n    @classmethod\n    def from_msg(cls, msg: Message, check_endline: bool = True) -> OutputLine:\n        \"\"\"Create an OutputLine from a Pylint Message.\"\"\"\n        column = cls._get_column(msg.column)\n        end_line = cls._get_end_line_and_end_col(msg.end_line, check_endline)\n        end_column = cls._get_end_line_and_end_col(msg.end_column, check_endline)\n        return cls(\n            msg.symbol,\n            msg.line,\n            column,\n            end_line,\n            end_column,\n            msg.obj or \"\",\n            msg.msg.replace(\"\\r\\n\", \"\\n\"),\n            msg.confidence.name,\n        )\n\n    @staticmethod\n    def _get_column(column: str | int) -> int:\n        \"\"\"Handle column numbers.\"\"\"\n        return int(column)\n\n    @staticmethod\n    def _get_end_line_and_end_col(value: _T, check_endline: bool) -> _T | None:\n        \"\"\"Used to make end_line and end_column N"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unknown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn'"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport tokenize\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Literal\n\nfrom pylint import exceptions, interfaces\nfrom pylint.constants import (\n    MSG_STATE_CONFIDENCE,\n    MSG_STATE_SCOPE_CONFIG,\n    MSG_STATE_SCOPE_MODULE,\n    MSG_TYPES,\n    MSG_TYPES_LONG,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.message import MessageDefinition\nfrom pylint.typing import ManagedMessage, MessageDefinitionTuple\nfrom pylint.utils.pragma_parser import (\n    OPTION_PO,\n    InvalidPragmaError,\n    UnRecognizedOptionError,\n    parse_pragma,\n)\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass _MessageStateHandler:\n    \"\"\"Class that handles message disabling & enabling and processing of inline\n    pragma's.\n    \"\"\"\n\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,\n            \"disable-next\": self.disable_next,\n        }\n        self._bw_options_methods = {\n            \"disable-msg\": self._options_methods[\"disable\"],\n            \"enable-msg\": self._options_methods[\"enable\"],\n        }\n        self._pragma_lineno: dict[str, int] = {}\n        self._stashed_messages: defaultdict[\n            tuple[str, str], list[tuple[str | None, str]]\n        ] = defaultdict(list)\n        \"\"\"Some messages in the options (for --enable and --disable) are encountered\n        too early to warn about t"}], "retrieved_count": 10, "cost_time": 1.0512375831604004}
{"question": "What is the structure of Pylint's configuration system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's configuration system is built around several key components: 1) _ArgumentsManager class handles command-line arguments and options parsing, managing a hierarchical configuration structure with support for per-directory configurations. 2) _ArgumentsProvider base class that checkers and other components inherit from to expose configurable options. 3) _ConfigurationFileParser handles reading configuration from various file formats (INI, TOML, pyproject.toml). 4) The system supports multiple configuration sources with precedence: command-line arguments override configuration file settings, which override defaults. 5) Configuration options are defined using the _Argument class hierarchy with type transformers for validation. 6) The system supports option groups, help text generation, and automatic registration of checker-specific options. 7) Per-directory configuration allows different settings for different parts of a codebase. The configuration system integrates with Pylint's plugin architecture, allowing external checkers to define their own configuration options.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "config_file_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Configuration file parser class.\"\"\"\n\nfrom __future__ import annotations\n\nimport configparser\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom pylint.config.utils import _parse_rich_type_value\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nPylintConfigFileData = tuple[dict[str, str], list[str]]\n\n\nclass _RawConfParser:\n    \"\"\"Class to parse various formats of configuration files.\"\"\"\n\n    @staticmethod\n    def parse_ini_file(file_path: Path) -> PylintConfigFileData:\n        \"\"\"Parse and handle errors of an ini configuration file.\n\n        Raises ``configparser.Error``.\n        \"\"\"\n        parser = configparser.ConfigParser(inline_comment_prefixes=(\"#\", \";\"))\n        # Use this encoding in order to strip the BOM marker, if any.\n        with open(file_path, encoding=\"utf_8_sig\") as fp:\n            parser.read_file(fp)\n\n        config_content: dict[str, str] = {}\n        options: list[str] = []\n        ini_file_with_sections = _RawConfParser._ini_file_with_sections(file_path)\n        for section in parser.sections():\n            if ini_file_with_sections and not section.startswith(\"pylint\"):\n                continue\n            for option, value in parser[section].items():\n                config_content[option] = value\n                options += [f\"--{option}\", value]\n        return config_content, options\n\n    @staticmethod\n    def _ini_file_with_sections(file_path: Path) -> bool:\n        \"\"\"Return whether the file uses sections.\"\"\"\n        if \"setup.cfg\" in file_path.parts:\n            return True\n        if \"tox.ini\" in file_path.parts:\n            return True\n        return False\n\n    @staticmethod\n    def p"}, {"start_line": 0, "end_line": 571, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Everything related to the 'pylint-config' command.\n\nEverything in this module is private.\n\"\"\"\n\nfrom pylint.config._pylint_config.main import _handle_pylint_config_commands\nfrom pylint.config._pylint_config.setup import _register_generate_config_options\n\n__all__ = (\"_handle_pylint_config_commands\", \"_register_generate_config_options\")\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    {\n                \"type\": \"yn\",\n                \"metavar\": \"<yn>\",\n                \"default\": False,\n                \"help\": \"Discover python modules and packages in the file system subtree.\",\n            },\n        ),\n        (\n            \"py-version\",\n            {\n                \"default\": sys.version_info[:2],\n                \"type\": \"py_version\",\n                \"metavar\": \"<py_version>\",\n                \"help\": (\n                    \"Minimum Python version to use for version dependent checks. \"\n                    \"Will default to the version used to run pylint.\"\n                ),\n            },\n        ),\n        (\n            \"ignored-modules\",\n            {\n                \"default\": (),\n                \"type\": \"csv\",\n                \"metavar\": \"<module names>\",\n                \"help\": \"List of module names for which member attributes \"\n                \"should not be checked and will not be imported \"\n                \"(useful for modules/projects \"\n                \"where namespaces are manipulated during runtime and \"\n                \"thus existing member attributes cannot be \"\n                \"deduced by static analysis). It supports qualified \"\n                \"module names, as well as Unix pattern matching.\",\n            },\n        ),\n        (\n            \"analyse-fallback-blocks\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Analyse import fallback blocks. This can be used to \"\n                \"support both Python 2 and 3 compatible code, which \"\n                \"means that the block might have code that exists \"\n                \"only in one or another interpreter, leading to false \"\n                \"positives when analysed.\",\n            },\n        ),\n        (\n            \"clear-cache-post-run\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Clear in-memo"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "formation. \"\n                    \"See doc for all details.\"\n                ),\n            },\n        ),\n        (\n            \"jobs\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<n-processes>\",\n                \"short\": \"j\",\n                \"default\": 1,\n                \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n                \"auto-detect the number of processors available to use, and will cap \"\n                \"the count on Windows to avoid hangs.\",\n            },\n        ),\n        (\n            \"unsafe-load-any-extension\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"hide\": True,\n                \"help\": (\n                    \"Allow loading of arbitrary C extensions. Extensions\"\n                    \" are imported into the active Python interpreter and\"\n                    \" may run arbitrary code.\"\n                ),\n            },\n        ),\n        (\n            \"limit-inference-results\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<number-of-results>\",\n                \"default\": 100,\n                \"help\": (\n                    \"Control the amount of potential inferred values when inferring \"\n                    \"a single object. This can help the performance when dealing with \"\n                    \"large functions or complex, nested conditions.\"\n                ),\n            },\n        ),\n        (\n            \"extension-pkg-allow-list\",\n            {\n                \"type\": \"csv\",\n                \"metavar\": \"<pkg[,pkg]>\",\n                \"default\": [],\n                \"help\": (\n                    \"A comma-separated list of package or module names\"\n                    \" from where C extensions may be loaded. Extensions are\"\n                    \" loading into the active Python interpreter and may run\"\n                    \" arbitrary code.\"\n                ),\n            },\n        ),"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             \"where it should appear only once). \"\n                'You can also use \"--disable=all\" to disable everything first '\n                \"and then re-enable specific checks. For example, if you want \"\n                \"to run only the similarities checker, you can use \"\n                '\"--disable=all --enable=similarities\". '\n                \"If you want to run only the classes checker, but have no \"\n                \"Warning level messages displayed, use \"\n                '\"--disable=all --enable=classes --disable=W\".',\n                \"kwargs\": {\"linter\": linter},\n            },\n        ),\n        (\n            \"msg-template\",\n            {\n                \"type\": \"string\",\n                \"default\": \"\",\n                \"metavar\": \"<template>\",\n                \"group\": \"Reports\",\n                \"help\": (\n                    \"Template used to display messages. \"\n                    \"This is a python new-style format string \"\n                    \"used to format the message information. \"\n                    \"See doc for all details.\"\n                ),\n            },\n        ),\n        (\n            \"jobs\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<n-processes>\",\n                \"short\": \"j\",\n                \"default\": 1,\n                \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n                \"auto-detect the number of processors available to use, and will cap \"\n                \"the count on Windows to avoid hangs.\",\n            },\n        ),\n        (\n            \"unsafe-load-any-extension\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"hide\": True,\n                \"help\": (\n                    \"Allow loading of arbitrary C extensions. Extensions\"\n                    \" are imported into the active Python interpreter and\"\n                    \" may run arbitrary code.\"\n                ),\n            },\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "config_initialization.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport warnings\nfrom glob import glob\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom pylint import reporters\nfrom pylint.config.config_file_parser import _ConfigurationFileParser\nfrom pylint.config.exceptions import (\n    ArgumentPreprocessingError,\n    _UnrecognizedOptionError,\n)\nfrom pylint.utils import utils\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef _config_initialization(  # pylint: disable=too-many-statements\n    linter: PyLinter,\n    args_list: list[str],\n    reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n    config_file: None | str | Path = None,\n    verbose_mode: bool = False,\n) -> list[str]:\n    \"\"\"Parse all available options, read config files and command line arguments and\n    set options accordingly.\n    \"\"\"\n    linter.verbose = verbose_mode\n    config_file = Path(config_file) if config_file else None\n\n    # Set the current module to the configuration file\n    # to allow raising messages on the configuration file.\n    linter.set_current_module(str(config_file) if config_file else \"\")\n\n    # Read the configuration file\n    config_file_parser = _ConfigurationFileParser(verbose_mode, linter)\n    try:\n        config_data, config_args = config_file_parser.parse_config_file(\n            file_path=config_file\n        )\n    except OSError as ex:\n        print(ex, file=sys.stderr)\n        sys.exit(32)\n\n    # Order --enable=all or --disable=all to come first.\n    config_args = _order_all_first(config_args, joined=False)\n\n    # Run init hook, if present, before loading plugins\n    if \"init-hook\" in config_data:\n        exec(utils._unquote(config_data[\"init-hook\"]))  # pylint: disable=exec-used\n\n    # "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stants import MAIN_CHECKER_NAME\nfrom pylint.typing import DirectoryNamespaceDict, OptionDict\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\n\nif TYPE_CHECKING:\n    from pylint.config.arguments_provider import _ArgumentsProvider\n\n\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n\n        This is necessary for the per-directory configuration support. Whenever we\n        fail to match a file with a directory we fall back to the Namespace object\n        created during initialization.\n        \"\"\"\n\n        self._arg_parser = argparse.ArgumentParser(\n            prog=prog,\n            usage=usage or \"%(prog)s [options]\",\n            description=description,\n            formatter_class=_HelpFormatter,\n            # Needed to let 'pylint-config' overwrite the -h command\n            conflict_handler=\"resolve\",\n        )\n        \"\"\"The command line argument parser.\"\"\"\n\n        self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n        \"\"\"Dictionary of all the argument groups.\"\"\"\n\n        self._option_dicts: dict[str, OptionDict] = {}\n        \"\"\"All option dictionaries that have been registered.\"\"\"\n\n        self._directory_namespaces: DirectoryNamespaceDict = {}\n        \"\"\"Mapping of directories and their respective namespace objects.\"\"\"\n\n    @property\n    def config(self) -> argparse.Namespace:\n        \"\"\"Namespace for all options.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: argparse.Namespace) -> None:\n        self._config = value\n\n    def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n        \"\""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "argument.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Definition of an Argument class and transformers for various argument types.\n\nAn Argument instance represents a pylint option to be handled by an argparse.ArgumentParser\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport pathlib\nimport re\nfrom collections.abc import Callable, Sequence\nfrom glob import glob\nfrom re import Pattern\nfrom typing import Any, Literal\n\nfrom pylint import interfaces\nfrom pylint import utils as pylint_utils\nfrom pylint.config.callback_actions import _CallbackAction\nfrom pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction\n\n_ArgumentTypes = (\n    str\n    | int\n    | float\n    | bool\n    | Pattern[str]\n    | Sequence[str]\n    | Sequence[Pattern[str]]\n    | tuple[int, ...]\n)\n\"\"\"List of possible argument types.\"\"\"\n\n\ndef _confidence_transformer(value: str) -> Sequence[str]:\n    \"\"\"Transforms a comma separated string of confidence values.\"\"\"\n    if not value:\n        return interfaces.CONFIDENCE_LEVEL_NAMES\n    values = pylint_utils._check_csv(value)\n    for confidence in values:\n        if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:\n            raise argparse.ArgumentTypeError(\n                f\"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}\"\n            )\n    return values\n\n\ndef _csv_transformer(value: str) -> Sequence[str]:\n    \"\"\"Transforms a comma separated string.\"\"\"\n    return pylint_utils._check_csv(value)\n\n\nYES_VALUES = {\"y\", \"yes\", \"true\"}\nNO_VALUES = {\"n\", \"no\", \"false\"}\n\n\ndef _yn_transformer(value: str) -> bool:\n    \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n    value = value.lower()\n    if value in YES_VALUES:\n        return True\n    if value in NO_VALUES:\n        return False\n    raise argparse.ArgumentTypeError(\n        Non"}], "retrieved_count": 10, "cost_time": 1.0975348949432373}
{"question": "What are the three types of checkers in Pylint?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint supports three types of checkers: 1) Raw checkers (BaseRawFileChecker) which analyze each module as a raw file stream, allowing access to the original source code content through the node.stream() method. 2) Token checkers (BaseTokenChecker) which analyze files using the list of tokens that represent the source code, providing access to the tokenized representation of the code. 3) AST checkers (BaseChecker) which work on an AST representation of the module provided by the astroid library, enabling sophisticated semantic analysis of code structure, relationships, and patterns. Each type serves different analysis needs - raw checkers for file-level analysis, token checkers for lexical analysis, and AST checkers for structural and semantic analysis.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", False)\n        self.set_option(\"score\", False)\n\n    # code checking methods ###################################################\n\n    def get_checkers(self) -> list[BaseChecker]:\n        \"\"\"Return all available checkers as an ordered list.\"\"\"\n        return sorted(c for _checkers in self._checkers.values() for c in _checkers)\n\n    def get_checker_names(self) -> list[str]:\n        \"\"\"Get all the checker names that this linter knows about.\"\"\"\n        return sorted(\n            {\n                checker.name\n                for checker in self.get_checkers()\n                if checker.name != MAIN_CHECKER_NAME\n            }\n        )\n\n    def prepare_checkers(self) -> list[BaseChecker]:\n        \"\"\"Return checkers needed for activated messages and reports.\"\"\"\n        if not self.config.reports:\n            self.disable_reporters()\n        # get needed checkers\n        needed_checkers: list[BaseChecker] = [self]\n        for checker in self.get_checkers()[1:]:\n            messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}\n            if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):\n                needed_checkers.append(checker)\n        return needed_checkers\n\n    # pylint: disable=unused-argument\n    @staticmethod\n    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n        \"\"\"Returns whether a module should be checked.\n\n        This implementation returns True for all python source files (.py and .pyi),\n        indicating that all files should be linted.\n\n        Subclasses may override this method to indicate that modules satisfying\n        certain conditions should not be linted.\n\n        :param str modname: The name of the module to be checked.\n        :param str path: The full path to the source code of the module.\n        :param bool is_argument: Whether the file is an argument to pylint or not.\n                                 Files which respect this property are always\n         "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Basic checker for Python code.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport itertools\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING, Literal, cast\n\nimport astroid\nfrom astroid import nodes, objects, util\n\nfrom pylint import utils as lint_utils\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.interfaces import HIGH, INFERENCE, Confidence\nfrom pylint.reporters.ureports import nodes as reporter_nodes\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass _BasicChecker(BaseChecker):\n    \"\"\"Permits separating multiple checks with the same checker name into\n    classes/file.\n    \"\"\"\n\n    name = \"basic\"\n\n\nREVERSED_PROTOCOL_METHOD = \"__reversed__\"\nSEQUENCE_PROTOCOL_METHODS = (\"__getitem__\", \"__len__\")\nREVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments\nDEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),\n    **{\n        x: f\"{x}()\"\n        for x in (\n            \"collections.deque\",\n            \"collections.ChainMap\",\n            \"collections.Counter\",\n            \"collections.OrderedDict\",\n            \"collections.defaultdict\",\n            \"collections.UserDict\",\n            \"collections.UserList\",\n        )\n    },\n)\n\n\ndef report_by_type_stats(\n    sect: reporter_nodes.Section,\n    stats: LinterStats,\n    old_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make a report of.\n\n    * percentage of different types documented\n    * percentage of different types with a bad name\n    \"\"\"\n    # percentage of diffe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   def create_message_definition_from_tuple(\n        self, msgid: str, msg_tuple: MessageDefinitionTuple\n    ) -> MessageDefinition:\n        if isinstance(self, (BaseTokenChecker, BaseRawFileChecker)):\n            default_scope = WarningScope.LINE\n        else:\n            default_scope = WarningScope.NODE\n        options: ExtraMessageOptions = {}\n        if len(msg_tuple) == 4:\n            (msg, symbol, descr, msg_options) = msg_tuple\n            options = ExtraMessageOptions(**msg_options)\n        elif len(msg_tuple) == 3:\n            (msg, symbol, descr) = msg_tuple\n        else:\n            error_msg = \"\"\"Messages should have a msgid, a symbol and a description. Something like this :\n\n\"W1234\": (\n    \"message\",\n    \"message-symbol\",\n    \"Message description with detail.\",\n    ...\n),\n\"\"\"\n            raise InvalidMessageError(error_msg)\n        options.setdefault(\"scope\", default_scope)\n        return MessageDefinition(self, msgid, msg, descr, symbol, **options)\n\n    @property\n    def messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @"}], "retrieved_count": 10, "cost_time": 1.112151861190796}
{"question": "What is the relationship between Pylint's PyLinter class and the BaseChecker class in establishing the connection between the main linter and individual checkers?", "answer": null, "relative_code_list": null, "ground_truth": "The PyLinter class interacts with BaseChecker classes through a registration and delegation pattern. PyLinter maintains a registry of all checkers and coordinates their execution during the analysis process. When a checker is registered with PyLinter, it becomes part of the analysis pipeline. PyLinter provides checkers with access to shared resources like the configuration system, message handling, and AST data. During analysis, PyLinter orchestrates the execution of checkers by calling their lifecycle methods (open, close) and delegating AST traversal to the ASTWalker, which then calls the appropriate visit and leave methods on each checker. PyLinter also provides checkers with utility methods for message creation and configuration access. This design allows PyLinter to coordinate multiple specialized checkers while maintaining a clean separation of concerns.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consistent hashing.\",\n            {\"old_names\": [(\"W1003\", \"old-message-with-options\")], \"shared\": True},\n        ),\n    }\n\n\ndef test_base_checker_doc() -> None:\n    basic = OtherBasicChecker()\n    expected_beginning = \"\"\"\\\nBasic checker\n~~~~~~~~~~~~~\n\nVerbatim name of the checker is ``basic``.\n\n\"\"\"\n    expected_middle = \"\"\"\\\nBasic checker Options\n^^^^^^^^^^^^^^^^^^^^^\n:example-args:\n  Example of integer argument for the checker.\n\n  Default: ``42``\n\n\"\"\"\n    expected_end = \"\"\"\\\nBasic checker Messages\n^^^^^^^^^^^^^^^^^^^^^^\n:basic-checker-example (W0001): *Basic checker has an example.*\n  Used nowhere and serves no purpose.\n\n\n\"\"\"\n    assert str(basic) == expected_beginning + expected_end\n    assert repr(basic) == \"Checker 'basic' (responsible for 'W0001')\"\n    less_basic = LessBasicChecker()\n\n    assert str(less_basic) == expected_beginning + expected_middle + expected_end\n    assert repr(less_basic) == repr(basic)\n\n\ndef test_base_checker_ordering() -> None:\n    \"\"\"Test ordering of checkers based"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " on their __gt__ method.\"\"\"\n    linter = PyLinter()\n    imports_builtin = ImportsChecker(linter)\n    typecheck_builtin = TypeChecker(linter)\n    basic_1_ext = OtherBasicChecker()\n    basic_2_ext = LessBasicChecker()\n    basic_3_ext = DifferentBasicChecker()\n    while_used_ext = WhileChecker(linter)\n    broad_try_clause_ext = BroadTryClauseChecker(linter)\n\n    list_of_checkers = [\n        1,\n        basic_1_ext,\n        basic_2_ext,\n        basic_3_ext,\n        typecheck_builtin,\n        broad_try_clause_ext,\n        imports_builtin,\n        while_used_ext,\n        linter,\n    ]\n    assert sorted(list_of_checkers) == [  # type: ignore[type-var]\n        linter,\n        imports_builtin,\n        typecheck_builtin,\n        basic_3_ext,\n        basic_1_ext,\n        basic_2_ext,\n        broad_try_clause_ext,\n        while_used_ext,\n        1,\n    ]\n    # main checker is always smaller\n    assert linter < basic_1_ext\n    assert linter < while_used_ext\n    assert linter < imports_builtin\n    assert basic_2_ext > linter\n    assert while_used_ext > linter\n    assert imports_builtin > linter\n    # builtin are smaller than extension (even when not alphabetically)\n    assert imports_builtin < while_used_ext\n    assert imports_builtin < broad_try_clause_ext\n    assert while_used_ext > imports_builtin\n    assert broad_try_clause_ext > imports_builtin\n    # alphabetical order for builtin\n    assert imports_builtin < typecheck_builtin\n    assert typecheck_builtin > imports_builtin\n    # alphabetical order for extension\n    assert typecheck_builtin < while_used_ext\n    assert while_used_ext > typecheck_builtin\n    assert basic_1_ext > basic_3_ext\n    assert basic_2_ext > basic_3_ext\n    assert basic_1_ext == basic_2_ext\n\n\ndef test_base_checker_invalid_message() -> None:\n    linter = PyLinter()\n    with pytest.raises(InvalidMessageError):\n        linter.register_checker(MissingFieldsChecker(linter))\n\n\ndef test_base_checker_consistent_hash() -> None:\n    linter = PyLinter()\n    checker "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}], "retrieved_count": 10, "cost_time": 1.0916388034820557}
{"question": "What are the different reporter types in Pylint?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint supports several different reporter types for outputting analysis results: 1) TextReporter - the default reporter that outputs human-readable text grouped by module, 2) ColorizedTextReporter - an ANSI colorized version of the text reporter for better visual distinction, 3) JSONReporter - outputs results in JSON format for programmatic consumption, 4) JSON2Reporter - an improved JSON reporter with better structure, 5) CollectingReporter - collects messages in memory without outputting them, useful for testing and programmatic access, 6) MultiReporter - allows combining multiple reporters to output to different formats simultaneously, 7) ParseableTextReporter - outputs in a parseable format for integration with other tools. All reporters inherit from BaseReporter and implement the handle_message() and display methods to process and format Pylint's analysis results according to their specific output requirements.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1072, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Utilities methods and classes for reporters.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint import utils\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.collecting_reporter import CollectingReporter\nfrom pylint.reporters.json_reporter import JSON2Reporter, JSONReporter\nfrom pylint.reporters.multi_reporter import MultiReporter\nfrom pylint.reporters.reports_handler_mix_in import ReportsHandlerMixIn\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with reporters in this package.\"\"\"\n    utils.register_plugins(linter, __path__[0])\n\n\n__all__ = [\n    \"BaseReporter\",\n    \"CollectingReporter\",\n    \"JSON2Reporter\",\n    \"JSONReporter\",\n    \"MultiReporter\",\n    \"ReportsHandlerMixIn\",\n]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "report_functions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nfrom collections import defaultdict\n\nfrom pylint import checkers, exceptions\nfrom pylint.reporters.ureports.nodes import Section, Table\nfrom pylint.utils import LinterStats\n\n\ndef report_total_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    previous_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make total errors / warnings report.\"\"\"\n    lines = [\"type\", \"number\", \"previous\", \"difference\"]\n    lines += checkers.table_lines_from_stats(stats, previous_stats, \"message_types\")\n    sect.append(Table(children=lines, cols=4, rheaders=1))\n\n\ndef report_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make messages type report.\"\"\"\n    by_msg_stats = stats.by_msg\n    in_order = sorted(\n        (value, msg_id)\n        for msg_id, value in by_msg_stats.items()\n        if not msg_id.startswith(\"I\")\n    )\n    in_order.reverse()\n    lines = [\"message id\", \"occurrences\"]\n    for value, msg_id in in_order:\n        lines += [msg_id, str(value)]\n    sect.append(Table(children=lines, cols=2, rheaders=1))\n\n\ndef report_messages_by_module_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make errors / warnings by modules report.\"\"\"\n    module_stats = stats.by_module\n    if len(module_stats) == 1:\n        # don't print this report when we are analysing a single module\n        raise exceptions.EmptyReportError()\n    by_mod: defaultdict[str, dict[str, int | float]] = collections.defaultdict(dict)\n    for m_type in (\"fatal\", \"error\", \"warning\", \"refactor\", \"convention\"):\n        total = stats.get_global_message_count(m_type)\n        for module in module_stats.keys():\n            mod_total = stats.get_"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "reports_handler_mix_in.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nfrom collections.abc import MutableSequence\nfrom typing import TYPE_CHECKING\n\nfrom pylint.exceptions import EmptyReportError\nfrom pylint.reporters.ureports.nodes import Section\nfrom pylint.typing import ReportsCallable\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n    from pylint.lint.pylinter import PyLinter\n\nReportsDict = collections.defaultdict[\n    \"BaseChecker\", list[tuple[str, str, ReportsCallable]]\n]\n\n\nclass ReportsHandlerMixIn:\n    \"\"\"A mix-in class containing all the reports and stats manipulation\n    related methods for the main lint class.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._reports: ReportsDict = collections.defaultdict(list)\n        self._reports_state: dict[str, bool] = {}\n\n    def report_order(self) -> MutableSequence[BaseChecker]:\n        \"\"\"Return a list of reporters.\"\"\"\n        return list(self._reports)\n\n    def register_report(\n        self, reportid: str, r_title: str, r_cb: ReportsCallable, checker: BaseChecker\n    ) -> None:\n        \"\"\"Register a report.\n\n        :param reportid: The unique identifier for the report\n        :param r_title: The report's title\n        :param r_cb: The method to call to make the report\n        :param checker: The checker defining the report\n        \"\"\"\n        reportid = reportid.upper()\n        self._reports[checker].append((reportid, r_title, r_cb))\n\n    def enable_report(self, reportid: str) -> None:\n        \"\"\"Enable the report of the given id.\"\"\"\n        reportid = reportid.upper()\n        self._reports_state[reportid] = True\n\n    def disable_report(self, reportid: str) -> None:\n        \"\"\"Disable the report of the given id.\"\"\"\n        reportid = reportid"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import TYPE_CHECKING, TextIO\n\nfrom pylint.message import Message\nfrom pylint.reporters.ureports.nodes import Text\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass BaseReporter:\n    \"\"\"Base class for reporters.\n\n    symbols: show short symbolic names for messages.\n    \"\"\"\n\n    extension = \"\"\n\n    name = \"base\"\n    \"\"\"Name of the reporter.\"\"\"\n\n    def __init__(self, output: TextIO | None = None) -> None:\n        self.linter: PyLinter\n        self.section = 0\n        self.out: TextIO = output or sys.stdout\n        self.messages: list[Message] = []\n        # Build the path prefix to strip to get relative paths\n        self.path_strip_prefix = os.getcwd() + os.sep\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Handle a new message triggered on the current file.\"\"\"\n        self.messages.append(msg)\n\n    def writeln(self, string: str = \"\") -> None:\n        \"\"\"Write a line in the output buffer.\"\"\"\n        print(string, file=self.out)\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Display results encapsulated in the layout tree.\"\"\"\n        self.section = 0\n        if layout.report_id:\n            if isinstance(layout.children[0].children[0], Text):\n                layout.children[0].children[0].data += f\" ({layout.report_id})\"\n            else:\n                raise ValueError(f\"Incorrect child for {layout.children[0].children}\")\n        self._display(layout)\n\n    def _display(self, layout: Section) -> None:\n        \"\"\"Display the layout.\"\"\"\n        raise NotImplementedError()\n\n    def display_messages(self, layout: Section | N"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "reports_handler_mix_in.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "list)\n        self._reports_state: dict[str, bool] = {}\n\n    def report_order(self) -> MutableSequence[BaseChecker]:\n        \"\"\"Return a list of reporters.\"\"\"\n        return list(self._reports)\n\n    def register_report(\n        self, reportid: str, r_title: str, r_cb: ReportsCallable, checker: BaseChecker\n    ) -> None:\n        \"\"\"Register a report.\n\n        :param reportid: The unique identifier for the report\n        :param r_title: The report's title\n        :param r_cb: The method to call to make the report\n        :param checker: The checker defining the report\n        \"\"\"\n        reportid = reportid.upper()\n        self._reports[checker].append((reportid, r_title, r_cb))\n\n    def enable_report(self, reportid: str) -> None:\n        \"\"\"Enable the report of the given id.\"\"\"\n        reportid = reportid.upper()\n        self._reports_state[reportid] = True\n\n    def disable_report(self, reportid: str) -> None:\n        \"\"\"Disable the report of the given id.\"\"\"\n        reportid = reportid.upper()\n        self._reports_state[reportid] = False\n\n    def report_is_enabled(self, reportid: str) -> bool:\n        \"\"\"Is the report associated to the given identifier enabled ?\"\"\"\n        return self._reports_state.get(reportid, True)\n\n    def make_reports(  # type: ignore[misc] # ReportsHandlerMixIn is always mixed with PyLinter\n        self: PyLinter,\n        stats: LinterStats,\n        old_stats: LinterStats | None,\n    ) -> Section:\n        \"\"\"Render registered reports.\"\"\"\n        sect = Section(\"Report\", f\"{self.stats.statement} statements analysed.\")\n        for checker in self.report_order():\n            for reportid, r_title, r_cb in self._reports[checker]:\n                if not self.report_is_enabled(reportid):\n                    continue\n                report_sect = Section(r_title)\n                try:\n                    r_cb(report_sect, stats, old_stats)\n                except EmptyReportError:\n                    continue\n                report_sect.report_id = r"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_self.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p(lc_ctype_env)\n        if original_lctype:\n            os.environ[lc_ctype_env] = original_lctype\n\n\nclass MultiReporter(BaseReporter):\n    def __init__(self, reporters: list[BaseReporter]) -> None:\n        # pylint: disable=super-init-not-called\n        # We don't call it because there is an attribute \"linter\" that is set inside the base class,\n        # and we have another setter here using yet undefined attribute.\n        # I don't think fixing the init order in a test class used once is worth it.\n        self._reporters = reporters\n        self.path_strip_prefix = os.getcwd() + os.sep\n\n    def on_set_current_module(self, *args: str, **kwargs: Any) -> None:\n        for rep in self._reporters:\n            rep.on_set_current_module(*args, **kwargs)\n\n    def handle_message(self, msg: Message) -> None:\n        for rep in self._reporters:\n            rep.handle_message(msg)\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n    @property\n    def out(self) -> TextIO:  # type: ignore[override]\n        return self._reporters[0].out\n\n    @property\n    def linter(self) -> PyLinter:\n        return self._linter\n\n    @linter.setter\n    def linter(self, value: PyLinter) -> None:\n        self._linter = value\n        for rep in self._reporters:\n            rep.linter = value\n\n\nclass TestRunTC:\n    def _runtest(\n        self,\n        args: list[str],\n        reporter: Any = None,\n        out: StringIO | None = None,\n        code: int | None = None,\n    ) -> None:\n        if out is None:\n            out = StringIO()\n        args = _add_rcfile_default_pylintrc(args)\n        pylint_code = self._run_pylint(args, reporter=reporter, out=out)\n        if reporter:\n            output = reporter.out.getvalue()\n        elif hasattr(out, \"getvalue\"):\n            output = out.getvalue()\n        else:\n            output = None\n        msg = f\"expected output status {code}, got {pylint_code}\"\n        if output is not None:\n            msg = f\"{msg}. Below pylint output: \\n{output}\""}, {"start_line": 0, "end_line": 320, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters/ureports", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n__all__ = (\"BaseWriter\",)\n\nfrom pylint.reporters.ureports.base_writer import BaseWriter\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "multi_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Callable\nfrom copy import copy\nfrom typing import TYPE_CHECKING, TextIO\n\nfrom pylint.message import Message\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass MultiReporter:\n    \"\"\"Reports messages and layouts in plain text.\"\"\"\n\n    name = \"_internal_multi_reporter\"\n    # Note: do not register this reporter with linter.register_reporter as it is\n    #       not intended to be used directly like a regular reporter, but is\n    #       instead used to implement the\n    #       `--output-format=json:somefile.json,colorized`\n    #       multiple output formats feature\n\n    extension = \"\"\n\n    def __init__(\n        self,\n        sub_reporters: list[BaseReporter],\n        close_output_files: Callable[[], None],\n        output: TextIO | None = None,\n    ):\n        self._sub_reporters = sub_reporters\n        self.close_output_files = close_output_files\n        self._path_strip_prefix = os.getcwd() + os.sep\n        self._linter: PyLinter | None = None\n        self.out = output\n        self.messages: list[Message] = []\n\n    @property\n    def out(self) -> TextIO | None:\n        return self.__out\n\n    @out.setter\n    def out(self, output: TextIO | None = None) -> None:\n        \"\"\"MultiReporter doesn't have its own output.\n\n        This method is only provided for API parity with BaseReporter\n        and should not be called with non-None values for 'output'.\n        \"\"\"\n        self.__out = None\n        if output is not None:\n            raise NotImplementedError(\"MultiReporter does not support direct output.\")\n\n    def"}, {"start_line": 0, "end_line": 735, "belongs_to": {"file_name": "collecting_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.reporters.base_reporter import BaseReporter\n\nif TYPE_CHECKING:\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass CollectingReporter(BaseReporter):\n    \"\"\"Collects messages.\"\"\"\n\n    name = \"collector\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.messages = []\n\n    def reset(self) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}], "retrieved_count": 10, "cost_time": 1.1125845909118652}
{"question": "Why does Pylint implement a hook-based plugin system instead of inheritance-based extension mechanisms?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements a hook-based plugin system instead of inheritance-based extension mechanisms for several important reasons: 1) Flexibility - hook-based systems allow plugins to be loaded dynamically without modifying the core codebase, 2) Loose coupling - plugins don't need to inherit from specific base classes, reducing tight dependencies, 3) Runtime extensibility - new functionality can be added without restarting or recompiling the core system, 4) Multiple plugin support - the same hook can be used by multiple plugins simultaneously, 5) Configuration-driven loading - plugins can be enabled/disabled through configuration rather than code changes, 6) Backward compatibility - new plugins can be added without affecting existing functionality, 7) Testing isolation - plugins can be tested independently without complex inheritance hierarchies, 8) Maintenance simplicity - core system changes don't require updates to all plugin implementations. This design choice makes Pylint more modular and easier to extend.", "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " code from the init_hook.\n\n    This can be used to set the 'sys.path' for example.\n    \"\"\"\n    assert value is not None\n    exec(value)  # pylint: disable=exec-used\n\n\ndef _set_rcfile(run: Run, value: str | None) -> None:\n    \"\"\"Set the rcfile.\"\"\"\n    assert value is not None\n    run._rcfile = value\n\n\ndef _set_output(run: Run, value: str | None) -> None:\n    \"\"\"Set the output.\"\"\"\n    assert value is not None\n    run._output = value\n\n\ndef _add_plugins(run: Run, value: str | None) -> None:\n    \"\"\"Add plugins to the list of loadable plugins.\"\"\"\n    assert value is not None\n    run._plugins.extend(utils._splitstrip(value))\n\n\ndef _set_verbose_mode(run: Run, value: str | None) -> None:\n    assert value is None\n    run.verbose = True\n\n\ndef _enable_all_extensions(run: Run, value: str | None) -> None:\n    \"\"\"Enable all extensions.\"\"\"\n    assert value is None\n    for filename in Path(extensions.__file__).parent.iterdir():\n        if filename.suffix == \".py\" and not filename.stem.startswith(\"_\"):\n            extension_name = f\"pylint.extensions.{filename.stem}\"\n            if extension_name not in run._plugins:\n                run._plugins.append(extension_name)\n\n\nPREPROCESSABLE_OPTIONS: dict[\n    str, tuple[bool, Callable[[Run, str | None], None], int]\n] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    # pylint: disable=useless-suppression, wrong-spelling-in-comment\n    # Argparse by default allows abbreviations. It behaves differently\n    # if you turn this off, so we also turn it on. We mimic this\n    # by allowing some abbreviations or incorrect spelling here.\n    # The integer at the end of the tuple indicates how many letters\n    # should match, include the '-'. 0 indicates a full match.\n    #\n    # Clashes with --init-(import)\n    \"--init-hook\": (True, _init_hook, 8),\n    # Clashes with --r(ecursive)\n    \"--rcfile\": (True, _set_rcfile, 4),\n    # Clashes with --output(-format)\n    \"--output\": (True, _set_output, 0),\n    # Clashes with --lo(ng-help)\n    \"-"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of parents for a class (see R0901).\",\n            },\n        ),\n        (\n            \"ignored-parents\",\n            {\n                \"default\": (),\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated list of class names>\",\n                \"help\": \"List of qualified class names to ignore when counting class parents (see R0901)\",\n            },\n        ),\n        (\n            \"max-attributes\",\n            {\n                \"default\": 7,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of attributes for a class \\\n(see R0902).\",\n            },\n        ),\n        (\n            \"min-public-methods\",\n            {\n                \"default\": 2,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Minimum number of public methods for a class \\\n(see R0903).\",\n            },\n        ),\n        (\n            \"max-public-methods\",\n            {\n                \"default\": 20,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of public methods for a class \\\n(see R0904).\",\n            },\n        ),\n        (\n            \"max-bool-expr\",\n            {\n                \"default\": 5,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of boolean expressions in an if \"\n                \"statement (see R0916).\",\n            },\n        ),\n        (\n            \"exclude-too-few-public-methods\",\n            {\n                \"default\": [],\n                \"type\": \"regexp_csv\",\n                \"metavar\": \"<pattern>[,<pattern>...]\",\n                \"help\": \"List of regular expressions of class ancestor names \"\n                \"to ignore when counting public methods (see R0903)\",\n            },\n        ),\n    )\n\n    def __init__(self, linter: PyLinter) -> None:\n        super().__"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             \"where it should appear only once). \"\n                'You can also use \"--disable=all\" to disable everything first '\n                \"and then re-enable specific checks. For example, if you want \"\n                \"to run only the similarities checker, you can use \"\n                '\"--disable=all --enable=similarities\". '\n                \"If you want to run only the classes checker, but have no \"\n                \"Warning level messages displayed, use \"\n                '\"--disable=all --enable=classes --disable=W\".',\n                \"kwargs\": {\"linter\": linter},\n            },\n        ),\n        (\n            \"msg-template\",\n            {\n                \"type\": \"string\",\n                \"default\": \"\",\n                \"metavar\": \"<template>\",\n                \"group\": \"Reports\",\n                \"help\": (\n                    \"Template used to display messages. \"\n                    \"This is a python new-style format string \"\n                    \"used to format the message information. \"\n                    \"See doc for all details.\"\n                ),\n            },\n        ),\n        (\n            \"jobs\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<n-processes>\",\n                \"short\": \"j\",\n                \"default\": 1,\n                \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n                \"auto-detect the number of processors available to use, and will cap \"\n                \"the count on Windows to avoid hangs.\",\n            },\n        ),\n        (\n            \"unsafe-load-any-extension\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"hide\": True,\n                \"help\": (\n                    \"Allow loading of arbitrary C extensions. Extensions\"\n                    \" are imported into the active Python interpreter and\"\n                    \" may run arbitrary code.\"\n                ),\n            },\n     "}], "retrieved_count": 10, "cost_time": 1.0960447788238525}
{"question": "What is the purpose of the confidence level in Pylint's diagnostic messages?", "answer": null, "relative_code_list": null, "ground_truth": "The confidence level in Pylint's diagnostic messages indicates how certain the analysis is about the detected issue. It helps users understand the reliability of Pylint's analysis results. HIGH confidence indicates the analysis is very certain about the issue, typically for straightforward syntax or style violations. INFERENCE confidence indicates the result is based on type inference which may have some uncertainty due to the complexity of Python's dynamic typing. INFERENCE_FAILURE indicates that type inference failed but the issue was still detected through other means. UNDEFINED indicates no specific confidence level was set. Users can configure which confidence levels to display or ignore, allowing them to focus on the most reliable warnings and filter out potentially false positives from less certain analysis.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1191, "belongs_to": {"file_name": "interfaces.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n__all__ = (\n    \"CONFIDENCE_LEVELS\",\n    \"CONFIDENCE_LEVEL_NAMES\",\n    \"CONTROL_FLOW\",\n    \"HIGH\",\n    \"INFERENCE\",\n    \"INFERENCE_FAILURE\",\n    \"UNDEFINED\",\n)\n\n\nclass Confidence(NamedTuple):\n    name: str\n    description: str\n\n\n# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\n\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nCONFIDENCE_MAP = {i.name: i for i in CONFIDENCE_LEVELS}\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass\n\nfrom pylint.constants import MSG_TYPES\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.typing import MessageLocationTuple\n\n\n@dataclass(unsafe_hash=True)\nclass Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None\n    end_column: int | None\n\n    def __init__(\n        self,\n        msg_id: str,\n        symbol: str,\n        location: MessageLocationTuple,\n        msg: str,\n        confidence: Confidence | None,\n    ) -> None:\n        self.msg_id = msg_id\n        self.symbol = symbol\n        self.msg = msg\n        self.C = msg_id[0]\n        self.category = MSG_TYPES[msg_id[0]]\n        self.confidence = confidence or UNDEFINED\n        self.abspath = location.abspath\n        self.path = location.path\n        self.module = location.module\n        self.obj = location.obj\n        self.line = location.line\n        self.column = location.column\n        self.end_line = location.end_line\n        self.end_column = location.end_column\n\n    def format(self, template: str) -> str:\n        \"\"\"Format the message according to the given template.\n\n        The template format is the one of the format method :\n        cf. https://docs.python.org/2/library/string.html#formatstrings\n        \"\"\"\n        return template.format(**asdict(self))\n\n    @property\n    def location(self) -> MessageLocationTuple:\n        return MessageLocationTuple(\n            self.abspath,\n            self.pa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "output_line.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Any, NamedTuple, TypeVar\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.message.message import Message\n\n_T = TypeVar(\"_T\")\n\n\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.\n\n    Class name cannot start with Test as pytest doesn't allow constructors in test classes.\n    \"\"\"\n\n\nclass OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n\n    @classmethod\n    def from_msg(cls, msg: Message, check_endline: bool = True) -> OutputLine:\n        \"\"\"Create an OutputLine from a Pylint Message.\"\"\"\n        column = cls._get_column(msg.column)\n        end_line = cls._get_end_line_and_end_col(msg.end_line, check_endline)\n        end_column = cls._get_end_line_and_end_col(msg.end_column, check_endline)\n        return cls(\n            msg.symbol,\n            msg.line,\n            column,\n            end_line,\n            end_column,\n            msg.obj or \"\",\n            msg.msg.replace(\"\\r\\n\", \"\\n\"),\n            msg.confidence.name,\n        )\n\n    @staticmethod\n    def _get_column(column: str | int) -> int:\n        \"\"\"Handle column numbers.\"\"\"\n        return int(column)\n\n    @staticmethod\n    def _get_end_line_and_end_col(value: _T, check_endline: bool) -> _T | None:\n        \"\"\"Used to make end_line and end_column N"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sgid})\")\n            else:\n                disabled.append(f\"  {message.symbol} ({message.msgid})\")\n        print(\"Enabled messages:\")\n        for msg in enabled:\n            print(msg)\n        print(\"\\nDisabled messages:\")\n        for msg in disabled:\n            print(msg)\n        print(\"\\nNon-emittable messages with current interpreter:\")\n        for msg_def in non_emittable:\n            print(f\"  {msg_def.symbol} ({msg_def.msgid})\")\n        print(\"\")\n\n    def _get_message_state_scope(\n        self,\n        msgid: str,\n        line: int | None = None,\n        confidence: interfaces.Confidence | None = None,\n    ) -> Literal[0, 1, 2] | None:\n        \"\"\"Returns the scope at which a message was enabled/disabled.\"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        if confidence.name not in self.linter.config.confidence:\n            return MSG_STATE_CONFIDENCE  # type: ignore[return-value] # mypy does not infer Literal correctly\n        try:\n            if line in self.linter.file_state._module_msgs_state[msgid]:\n                return MSG_STATE_SCOPE_MODULE  # type: ignore[return-value]\n        except (KeyError, TypeError):\n            return MSG_STATE_SCOPE_CONFIG  # type: ignore[return-value]\n        return None\n\n    def _is_one_message_enabled(self, msgid: str, line: int | None) -> bool:\n        \"\"\"Checks state of a single message for the current file.\n\n        This function can't be cached as it depends on self.file_state which can\n        change.\n        \"\"\"\n        if line is None:\n            return self._msgs_state.get(msgid, True)\n        try:\n            return self.linter.file_state._module_msgs_state[msgid][line]\n        except KeyError:\n            # Check if the message's line is after the maximum line existing in ast tree.\n            # This line won't appear in the ast tree and won't be referred in\n            # self.file_state._module_msgs_state\n            # This happens for example with a commented line at the en"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_output_line.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nfrom typing import Protocol\n\nimport pytest\n\nfrom pylint.interfaces import HIGH, INFERENCE, Confidence\nfrom pylint.message import Message\nfrom pylint.testutils.output_line import OutputLine\nfrom pylint.typing import MessageLocationTuple\n\n\nclass _MessageCallable(Protocol):\n    def __call__(self, confidence: Confidence = HIGH) -> Message: ...\n\n\n@pytest.fixture()\ndef message() -> _MessageCallable:\n    def inner(confidence: Confidence = HIGH) -> Message:\n        return Message(\n            symbol=\"missing-docstring\",\n            msg_id=\"C0123\",\n            location=MessageLocationTuple(\n                \"abspath\", \"path\", \"module\", \"obj\", 1, 2, 1, 3\n            ),\n            msg=\"msg\",\n            confidence=confidence,\n        )\n\n    return inner\n\n\ndef test_output_line() -> None:\n    \"\"\"Test that the OutputLine NamedTuple is instantiated correctly.\"\"\"\n    output_line = OutputLine(\n        symbol=\"missing-docstring\",\n        lineno=1,\n        column=2,\n        end_lineno=1,\n        end_column=4,\n        object=\"\",\n        msg=\"Missing docstring's bad.\",\n        confidence=HIGH.name,\n    )\n    assert output_line.symbol == \"missing-docstring\"\n    assert output_line.lineno == 1\n    assert output_line.column == 2\n    assert output_line.end_lineno == 1\n    assert output_line.end_column == 4\n    assert output_line.object == \"\"\n    assert output_line.msg == \"Missing docstring's bad.\"\n    assert output_line.confidence == \"HIGH\"\n\n\ndef test_output_line_from_message(message: _MessageCallable) -> None:\n    \"\"\"Test that the OutputLine NamedTuple is instantiated correctly with from_msg.\"\"\"\n    output_line = OutputLine.from_msg(message())\n    assert output_line.symbol == \"missing-doc"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport tokenize\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Literal\n\nfrom pylint import exceptions, interfaces\nfrom pylint.constants import (\n    MSG_STATE_CONFIDENCE,\n    MSG_STATE_SCOPE_CONFIG,\n    MSG_STATE_SCOPE_MODULE,\n    MSG_TYPES,\n    MSG_TYPES_LONG,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.message import MessageDefinition\nfrom pylint.typing import ManagedMessage, MessageDefinitionTuple\nfrom pylint.utils.pragma_parser import (\n    OPTION_PO,\n    InvalidPragmaError,\n    UnRecognizedOptionError,\n    parse_pragma,\n)\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass _MessageStateHandler:\n    \"\"\"Class that handles message disabling & enabling and processing of inline\n    pragma's.\n    \"\"\"\n\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,\n            \"disable-next\": self.disable_next,\n        }\n        self._bw_options_methods = {\n            \"disable-msg\": self._options_methods[\"disable\"],\n            \"enable-msg\": self._options_methods[\"enable\"],\n        }\n        self._pragma_lineno: dict[str, int] = {}\n        self._stashed_messages: defaultdict[\n            tuple[str, str], list[tuple[str | None, str]]\n        ] = defaultdict(list)\n        \"\"\"Some messages in the options (for --enable and --disable) are encountered\n        too early to warn about t"}], "retrieved_count": 10, "cost_time": 1.1164882183074951}
{"question": "Why does Pylint implement a multi-phase analysis process instead of single-pass linting?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements a multi-phase analysis process instead of single-pass linting for several important reasons: 1) Dependency resolution - later phases can depend on information gathered in earlier phases, such as type information and import resolution, 2) Context building - early phases establish context that later phases can use for more accurate analysis, 3) Performance optimization - phases can be optimized independently and some phases can be skipped based on configuration, 4) Error recovery - if one phase fails, subsequent phases can still provide useful analysis, 5) Modularity - different types of analysis can be performed in separate phases with clear interfaces, 6) Incremental analysis - phases can be designed to support incremental updates when files change, 7) Resource management - phases can manage memory and computational resources more efficiently, 8) Extensibility - new analysis phases can be added without modifying existing phases. This multi-phase approach enables more sophisticated and accurate analysis than would be possible with a single-pass approach.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 0, "end_line": 315, "belongs_to": {"file_name": "__main__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#!/usr/bin/env python\n\n# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nimport pylint\n\npylint.modify_sys_path()\npylint.run_pylint()\n"}], "retrieved_count": 10, "cost_time": 1.0954046249389648}
{"question": "What is the difference between visit and leave methods in Pylint checkers?", "answer": null, "relative_code_list": null, "ground_truth": "In Pylint checkers, visit and leave methods serve different purposes in the AST traversal process: 1) Visit methods (e.g., visit_functiondef) are called when the ASTWalker first encounters a node, before visiting its children. They are used for initial analysis, setting up context, and performing checks that don't depend on the node's children. 2) Leave methods (e.g., leave_functiondef) are called after all children of a node have been visited. They are used for final analysis, cleanup, and checks that depend on having analyzed the entire subtree. This two-phase approach allows checkers to perform both top-down and bottom-up analysis, enabling sophisticated checks that require understanding both the context and the complete structure of code blocks.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "statements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no activated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 2000, "end_line": 3959, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tivated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__.__name__.lower()\n\n        visit_events = self.visit_events[cid]\n        leave_events = self.leave_events[cid]\n\n        # pylint: disable = too-many-try-statements\n        try:\n            if astroid.is_statement:\n                self.nbstatements += 1\n            # generate events for this node on each checker\n            for callback in visit_events:\n                callback(astroid)\n            # recurse on children\n            for child in astroid.get_children():\n                self.walk(child)\n            for callback in leave_events:\n                callback(astroid)\n        except Exception:\n            if self.exception_msg is False:\n                file = getattr(astroid.root(), \"file\", None)\n                print(\n                    f\"Exception on node {astroid!r} in file '{file}'\",\n                    file=sys.stderr,\n                )\n                traceback.print_exc()\n                self.exception_msg = True\n            raise\n"}, {"start_line": 1000, "end_line": 2877, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = func()\"))\n        assert {\"module\", \"assignname\"} == checker.called\n\n    def test_deprecated_methods(self) -> None:\n        class Checker(BaseChecker):\n            # pylint: disable-next=super-init-not-called\n            def __init__(self) -> None:\n                self.called = False\n\n            @only_required_for_messages(\"first-message\")\n            def visit_assname(\n                self, node: nodes.AssignName  # pylint: disable=unused-argument\n            ) -> None:\n                self.called = True\n\n        linter = self.MockLinter({\"first-message\": True})\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = Checker()\n        walker.add_checker(checker)\n        with warnings.catch_warnings(record=True):\n            warnings.simplefilter(\"always\")\n            walker.walk(astroid.parse(\"x = 1\"))\n\n            assert not checker.called\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   def create_message_definition_from_tuple(\n        self, msgid: str, msg_tuple: MessageDefinitionTuple\n    ) -> MessageDefinition:\n        if isinstance(self, (BaseTokenChecker, BaseRawFileChecker)):\n            default_scope = WarningScope.LINE\n        else:\n            default_scope = WarningScope.NODE\n        options: ExtraMessageOptions = {}\n        if len(msg_tuple) == 4:\n            (msg, symbol, descr, msg_options) = msg_tuple\n            options = ExtraMessageOptions(**msg_options)\n        elif len(msg_tuple) == 3:\n            (msg, symbol, descr) = msg_tuple\n        else:\n            error_msg = \"\"\"Messages should have a msgid, a symbol and a description. Something like this :\n\n\"W1234\": (\n    \"message\",\n    \"message-symbol\",\n    \"Message description with detail.\",\n    ...\n),\n\"\"\"\n            raise InvalidMessageError(error_msg)\n        options.setdefault(\"scope\", default_scope)\n        return MessageDefinition(self, msgid, msg, descr, symbol, **options)\n\n    @property\n    def messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @"}, {"start_line": 8000, "end_line": 9221, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @abc.abstractmethod\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n\n        The module's content is accessible via ``astroid.stream``\n        \"\"\"\n        raise NotImplementedError()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "custom.py", "upper_path": "/data2/raymone/swebench-repos/pylint/examples", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# Checkers should always inherit from `BaseChecker`.\n\n\nclass MyAstroidChecker(BaseChecker):\n    \"\"\"Add class member attributes to the class local's dictionary.\"\"\"\n\n    # The name defines a custom section of the config for this checker.\n    name = \"custom\"\n    # This class variable declares the messages (i.e. the warnings and errors)\n    # that the checker can emit.\n    msgs = {\n        # Each message has a code, a message that the user will see,\n        # a unique symbol that identifies the message,\n        # and a detailed help message\n        # that will be included in the documentation.\n        \"W0001\": (\"Message that will be emitted\", \"message-symbol\", \"Message help\")\n    }\n    # This class variable declares the options\n    # that are configurable by the user.\n    options = (\n        # Each option definition has a name which is used on the command line\n        # and in config files, and a dictionary of arguments\n        # (similar to argparse.ArgumentParser.add_argument).\n        (\n            \"store-locals-indicator\",\n            {\n                \"default\": \"properties\",\n                \"help\": (\n                    \"The expression name that indicates that the locals should \"\n                    \"be stored\"\n                ),\n            },\n        ),\n    )\n\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`.nodes.Call` node is visited.\n\n        See :mod:`astroid` for the description of available nodes.\n        \"\"\"\n        if not (\n            isinstance(node.func, nodes.Attribute)\n            and isinstance(node.func.expr, nodes.Name)\n            and node.func.expr.name == self.linter.config.store_locals_indicator\n            and node.func.attrname == \"create\"\n        ):\n            return\n        in_class = node.frame()\n        for p"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "refactoring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/refactoring", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " inside_comp = node.args[0].as_string()[1:-1]\n                if node.keywords:\n                    inside_comp = f\"({inside_comp})\"\n                    inside_comp += \", \"\n                    inside_comp += \", \".join(kw.as_string() for kw in node.keywords)\n                call_name = node.func.name\n                if call_name in {\"any\", \"all\"}:\n                    self.add_message(\n                        \"use-a-generator\",\n                        node=node,\n                        args=(call_name, inside_comp),\n                    )\n                else:\n                    self.add_message(\n                        \"consider-using-generator\",\n                        node=node,\n                        args=(call_name, inside_comp),\n                    )\n\n    @utils.only_required_for_messages(\n        \"stop-iteration-return\",\n        \"consider-using-dict-comprehension\",\n        \"consider-using-set-comprehension\",\n        \"consider-using-sys-exit\",\n        \"super-with-arguments\",\n        \"consider-using-generator\",\n        \"consider-using-with\",\n        \"use-list-literal\",\n        \"use-dict-literal\",\n        \"use-a-generator\",\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        self._check_raising_stopiteration_in_generator_next_call(node)\n        self._check_consider_using_comprehension_constructor(node)\n        self._check_quit_exit_call(node)\n        self._check_super_with_arguments(node)\n        self._check_consider_using_generator(node)\n        self._check_consider_using_with(node)\n        self._check_use_list_literal(node)\n        self._check_use_dict_literal(node)\n\n    @utils.only_required_for_messages(\"use-yield-from\")\n    def visit_yield(self, node: nodes.Yield) -> None:\n        if not isinstance(node.value, nodes.Name):\n            return\n\n        loop_node = node.parent.parent\n        if (\n            not isinstance(loop_node, nodes.For)\n            or isinstance(loop_node, nodes.AsyncFor)\n            or len(loop_node.body) != 1\n            "}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "de)\n\n    @utils.only_required_for_messages(\n        \"eval-used\",\n        \"exec-used\",\n        \"bad-reversed-sequence\",\n        \"misplaced-format-function\",\n        \"unreachable\",\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Visit a Call node.\"\"\"\n        if utils.is_terminating_func(node):\n            self._check_unreachable(node, confidence=INFERENCE)\n        self._check_misplaced_format_function(node)\n        if isinstance(node.func, nodes.Name):\n            name = node.func.name\n            # ignore the name if it's not a builtin (i.e. not defined in the\n            # locals nor globals scope)\n            if not (name in node.frame() or name in node.root()):\n                if name == \"exec\":\n                    self.add_message(\"exec-used\", node=node)\n                elif name == \"reversed\":\n                    self._check_reversed(node)\n                elif name == \"eval\":\n                    self.add_message(\"eval-used\", node=node)\n\n    @utils.only_required_for_messages(\"assert-on-tuple\", \"assert-on-string-literal\")\n    def visit_assert(self, node: nodes.Assert) -> None:\n        \"\"\"Check whether assert is used on a tuple or string literal.\"\"\"\n        if isinstance(node.test, nodes.Tuple) and len(node.test.elts) > 0:\n            self.add_message(\"assert-on-tuple\", node=node, confidence=HIGH)\n\n        if isinstance(node.test, nodes.Const) and isinstance(node.test.value, str):\n            if node.test.value:\n                when = \"never\"\n            else:\n                when = \"always\"\n            self.add_message(\"assert-on-string-literal\", node=node, args=(when,))\n\n    @utils.only_required_for_messages(\"duplicate-key\")\n    def visit_dict(self, node: nodes.Dict) -> None:\n        \"\"\"Check duplicate key in dictionary.\"\"\"\n        keys = set()\n        for k, _ in node.items:\n            if isinstance(k, nodes.Const):\n                key = k.value\n            elif isinstance(k, nodes.Attribute):\n                key = k.as_string()\n           "}], "retrieved_count": 10, "cost_time": 1.1263039112091064}
{"question": "Why does Pylint's AST-based analysis impact performance compared to regex-based linting tools?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's AST-based analysis impacts performance compared to regex-based linting tools for several reasons: 1) Parsing overhead - AST analysis requires parsing the entire code into a structured representation, while regex tools can scan text linearly, 2) Memory usage - AST analysis builds and maintains a complete tree representation of the code in memory, 3) Type inference - sophisticated type analysis requires additional computation and memory, 4) Import resolution - resolving imports and building module dependencies adds computational complexity, 5) Context building - AST analysis builds context information that regex tools don't need, 6) Multi-pass analysis - AST analysis often requires multiple passes through the code for different types of analysis, 7) Complex pattern matching - AST-based pattern matching is more computationally intensive than simple text matching, 8) Error recovery - AST analysis includes error recovery mechanisms that add overhead, 9) Plugin system - the plugin architecture adds indirection and coordination overhead, 10) Caching complexity - AST caching is more complex than simple text caching. However, this performance cost is offset by the significantly improved accuracy and capabilities of AST-based analysis.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pragma_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport re\nfrom collections.abc import Generator\nfrom typing import NamedTuple\n\n# Allow stopping after the first semicolon/hash encountered,\n# so that an option can be continued with the reasons\n# why it is active or disabled.\nOPTION_RGX = r\"\"\"\n    (?:^\\s*\\#.*|\\s*|               # Comment line, or whitespaces,\n       \\s*\\#.*(?=\\#.*?\\bpylint:))  # or a beginning of an inline comment\n                                   # followed by \"pylint:\" pragma\n    (\\#                            # Beginning of comment\n    .*?                            # Anything (as little as possible)\n    \\bpylint:                      # pylint word and column\n    \\s*                            # Any number of whitespaces\n    ([^;#\\n]+))                    # Anything except semicolon or hash or\n                                   # newline (it is the second matched group)\n                                   # and end of the first matched group\n    [;#]{0,1}                      # From 0 to 1 repetition of semicolon or hash\n\"\"\"\nOPTION_PO = re.compile(OPTION_RGX, re.VERBOSE)\n\n\nclass PragmaRepresenter(NamedTuple):\n    action: str\n    messages: list[str]\n\n\nATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,\n# 'disable' string should not be matched instead of 'disable-all'\nALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)\n)\n\n\nTOKEN_SPECIFICATION = [\n    (\"KEYWORD\", rf\"\\b({ALL_KEYWO"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 57, "belongs_to": {"file_name": "good.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/w/wrong-import-order", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\nimport sys\n\nimport pylint\n\nfrom . import utils\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_regr.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Non regression tests for pylint, which requires a too specific configuration\nto be incorporated in the automatic functional test framework.\n\"\"\"\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom collections.abc import Callable, Iterator\nfrom os.path import abspath, dirname, join\nfrom typing import cast\n\nimport pytest\n\nfrom pylint import testutils\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.utils.linterstats import LinterStats\n\nREGR_DATA = join(dirname(abspath(__file__)), \"regrtest_data\")\nsys.path.insert(1, REGR_DATA)\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[testutils.GenericTestReporter]:\n    return testutils.GenericTestReporter\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> list[str]:\n    return [\"I\"]\n\n\n@pytest.fixture\ndef finalize_linter(linter: PyLinter) -> Iterator[PyLinter]:\n    \"\"\"Call reporter.finalize() to clean up pending messages if a test\n    finished badly.\n    \"\"\"\n    yield linter\n    linter.reporter = cast(  # Due to fixture\n        testutils.GenericTestReporter, linter.reporter\n    )\n    linter.reporter.finalize()\n\n\ndef Equals(expected: str) -> Callable[[str], bool]:\n    return lambda got: got == expected\n\n\n@pytest.mark.parametrize(\n    \"file_names, check\",\n    [\n        ([\"package.__init__\"], Equals(\"\")),\n        ([\"precedence_test\"], Equals(\"\")),\n        ([\"import_package_subpackage_module\"], Equals(\"\")),\n        ([\"pylint.checkers.__init__\"], lambda x: \"__path__\" not in x),\n        ([join(REGR_DATA, \"classdoc_usage.py\")], Equals(\"\")),\n        ([join(REGR_DATA, \"module_global.py\")], Equals(\"\")),\n        ([join(REGR_DATA, \"decimal_inference.py\")], Equals(\"\")),\n        ([join(REGR_DATA, \"absimp\", \"string.py\")], Equals(\"\")),\n        ([join(R"}], "retrieved_count": 10, "cost_time": 1.1123368740081787}
{"question": "Why does Pylint use an AST-based analysis approach instead of regex-based pattern matching?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint uses an AST-based analysis approach instead of regex-based pattern matching for several important reasons: 1) Semantic accuracy - AST analysis understands the actual meaning and structure of code, not just text patterns, 2) Context awareness - AST analysis can understand variable scopes, function definitions, and class hierarchies, 3) False positive reduction - AST analysis can distinguish between similar-looking code that has different meanings, 4) Type safety - AST analysis can understand type information and relationships, 5) Refactoring safety - AST analysis is more robust when code is refactored or reformatted, 6) Complex pattern detection - AST analysis can detect complex patterns that would be difficult or impossible to express with regex, 7) Language evolution - AST analysis is more resilient to language changes and new syntax features, 8) Performance - AST analysis can be more efficient for complex analysis tasks, 9) Maintainability - AST-based rules are often easier to understand and maintain than complex regex patterns, 10) Integration capabilities - AST analysis can integrate with other tools that also use AST representations. This approach enables more sophisticated and accurate static analysis.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pragma_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport re\nfrom collections.abc import Generator\nfrom typing import NamedTuple\n\n# Allow stopping after the first semicolon/hash encountered,\n# so that an option can be continued with the reasons\n# why it is active or disabled.\nOPTION_RGX = r\"\"\"\n    (?:^\\s*\\#.*|\\s*|               # Comment line, or whitespaces,\n       \\s*\\#.*(?=\\#.*?\\bpylint:))  # or a beginning of an inline comment\n                                   # followed by \"pylint:\" pragma\n    (\\#                            # Beginning of comment\n    .*?                            # Anything (as little as possible)\n    \\bpylint:                      # pylint word and column\n    \\s*                            # Any number of whitespaces\n    ([^;#\\n]+))                    # Anything except semicolon or hash or\n                                   # newline (it is the second matched group)\n                                   # and end of the first matched group\n    [;#]{0,1}                      # From 0 to 1 repetition of semicolon or hash\n\"\"\"\nOPTION_PO = re.compile(OPTION_RGX, re.VERBOSE)\n\n\nclass PragmaRepresenter(NamedTuple):\n    action: str\n    messages: list[str]\n\n\nATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,\n# 'disable' string should not be matched instead of 'disable-all'\nALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)\n)\n\n\nTOKEN_SPECIFICATION = [\n    (\"KEYWORD\", rf\"\\b({ALL_KEYWO"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 0, "end_line": 1325, "belongs_to": {"file_name": "custom_raw.py", "upper_path": "/data2/raymone/swebench-repos/pylint/examples", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseRawFileChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass MyRawChecker(BaseRawFileChecker):\n    r\"\"\"Check for line continuations with '\\' instead of using triple\n    quoted string or parenthesis.\n    \"\"\"\n\n    name = \"custom_raw\"\n    msgs = {\n        \"W9901\": (\n            \"use \\\\ for line continuation\",\n            \"backslash-line-continuation\",\n            (\n                \"Used when a \\\\ is used for a line continuation instead\"\n                \" of using triple quoted string or parenthesis.\"\n            ),\n        )\n    }\n    options = ()\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n\n        the module's content is accessible via node.stream() function\n        \"\"\"\n        with node.stream() as stream:\n            for lineno, line in enumerate(stream):\n                if line.rstrip().endswith(\"\\\\\"):\n                    self.add_message(\"backslash-line-continuation\", line=lineno)\n\n\ndef register(linter: PyLinter) -> None:\n    \"\"\"This required method auto registers the checker during initialization.\n\n    :param linter: The linter to register the checker to.\n    \"\"\"\n    linter.register_checker(MyRawChecker(linter))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "format.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Python code format's checker.\n\nBy default, try to follow Guido's style guide :\n\nhttps://www.python.org/doc/essays/styleguide/\n\nSome parts of the process_token method is based from The Tab Nanny std module.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport tokenize\nfrom functools import reduce\nfrom re import Match\nfrom typing import TYPE_CHECKING, Literal\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseRawFileChecker, BaseTokenChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.constants import WarningScope\nfrom pylint.interfaces import HIGH\nfrom pylint.typing import MessageDefinitionTuple\nfrom pylint.utils.pragma_parser import OPTION_PO, PragmaParserError, parse_pragma\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n_KEYWORD_TOKENS = {\n    \"assert\",\n    \"del\",\n    \"elif\",\n    \"except\",\n    \"for\",\n    \"if\",\n    \"in\",\n    \"not\",\n    \"raise\",\n    \"return\",\n    \"while\",\n    \"yield\",\n    \"with\",\n    \"=\",\n    \":=\",\n}\n_JUNK_TOKENS = {tokenize.COMMENT, tokenize.NL}\n\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"C0301\": (\n        \"Line too long (%s/%s)\",\n        \"line-too-long\",\n        \"Used when a line is longer than a given number of characters.\",\n    ),\n    \"C0302\": (\n        \"Too many lines in module (%s/%s)\",  # was W0302\n        \"too-many-lines\",\n        \"Used when a module has too many lines, reducing its readability.\",\n    ),\n    \"C0303\": (\n        \"Trailing whitespace\",\n        \"trailing-whitespace\",\n        \"Used when there is whitespace between the end of a line and the newline.\",\n    ),\n    \"C0304\": (\n        \"Final newline missing\",\n        \"missing-final-newline\",\n        \"Used when the last line in a file is missing a newline.\",\n    ),\n    \"C0305\": (\n        \"Trailing newlines"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "naming_style.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport re\nfrom re import Pattern\n\nfrom pylint import constants\nfrom pylint.typing import OptionDict, Options\n\n\nclass NamingStyle:\n    \"\"\"Class to register all accepted forms of a single naming style.\n\n    It may seem counter-intuitive that single naming style has multiple \"accepted\"\n    forms of regular expressions, but we need to special-case stuff like dunder\n    names in method names.\n    \"\"\"\n\n    ANY: Pattern[str] = re.compile(\".*\")\n    CLASS_NAME_RGX: Pattern[str] = ANY\n    MOD_NAME_RGX: Pattern[str] = ANY\n    CONST_NAME_RGX: Pattern[str] = ANY\n    COMP_VAR_RGX: Pattern[str] = ANY\n    DEFAULT_NAME_RGX: Pattern[str] = ANY\n    CLASS_ATTRIBUTE_RGX: Pattern[str] = ANY\n\n    @classmethod\n    def get_regex(cls, name_type: str) -> Pattern[str]:\n        return {\n            \"module\": cls.MOD_NAME_RGX,\n            \"const\": cls.CONST_NAME_RGX,\n            \"class\": cls.CLASS_NAME_RGX,\n            \"function\": cls.DEFAULT_NAME_RGX,\n            \"method\": cls.DEFAULT_NAME_RGX,\n            \"attr\": cls.DEFAULT_NAME_RGX,\n            \"argument\": cls.DEFAULT_NAME_RGX,\n            \"variable\": cls.DEFAULT_NAME_RGX,\n            \"class_attribute\": cls.CLASS_ATTRIBUTE_RGX,\n            \"class_const\": cls.CONST_NAME_RGX,\n            \"inlinevar\": cls.COMP_VAR_RGX,\n        }[name_type]\n\n\nclass SnakeCaseStyle(NamingStyle):\n    \"\"\"Regex rules for snake_case naming style.\"\"\"\n\n    CLASS_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\WA-Z]*$\")\n    MOD_NAME_RGX = re.compile(r\"[^\\W\\dA-Z][^\\WA-Z]*$\")\n    CONST_NAME_RGX = re.compile(r\"([^\\W\\dA-Z][^\\WA-Z]*|__.*__)$\")\n    COMP_VAR_RGX = CLASS_NAME_RGX\n    DEFAULT_NAME_RGX = re.compile(\n        r\"([^\\W\\dA-Z][^\\WA-Z]*|_[^\\WA-Z]*|__[^\\WA-Z\\d_][^\\WA-Z]+__)$\"\n    )\n    CLASS_ATTRIBUTE_RGX = re.compile(r"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Check source code is ascii only or has an encoding declaration (PEP 263).\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport tokenize\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseRawFileChecker, BaseTokenChecker\nfrom pylint.typing import ManagedMessage\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass ByIdManagedMessagesChecker(BaseRawFileChecker):\n    \"\"\"Checks for messages that are enabled or disabled by id instead of symbol.\"\"\"\n\n    name = \"miscellaneous\"\n    msgs = {\n        \"I0023\": (\n            \"%s\",\n            \"use-symbolic-message-instead\",\n            \"Used when a message is enabled or disabled by id.\",\n            {\"default_enabled\": False},\n        )\n    }\n    options = ()\n\n    def _clear_by_id_managed_msgs(self) -> None:\n        self.linter._by_id_managed_msgs.clear()\n\n    def _get_by_id_managed_msgs(self) -> list[ManagedMessage]:\n        return self.linter._by_id_managed_msgs\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find messages activated or deactivated by id.\"\"\"\n        managed_msgs = self._get_by_id_managed_msgs()\n        for mod_name, msgid, symbol, lineno, is_disabled in managed_msgs:\n            if mod_name == node.name:\n                verb = \"disable\" if is_disabled else \"enable\"\n                txt = f\"'{msgid}' is cryptic: use '# pylint: {verb}={symbol}' instead\"\n                self.add_message(\"use-symbolic-message-instead\", line=lineno, args=txt)\n        self._clear_by_id_managed_msgs()\n\n\nclass EncodingChecker(BaseTokenChecker, BaseRawFileChecker):\n    \"\"\"BaseChecker for encoding issues and fixme notes.\n\n    Checks for:\n    * warning notes in the code like FIXME, XXX\n    * encoding issu"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "recommendation_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/refactoring", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r.rsplit(sep, maxsplit=1)[-1] \"\n            \"instead.\",\n        ),\n        \"C0208\": (\n            \"Use a sequence type when iterating over values\",\n            \"use-sequence-for-iteration\",\n            \"When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) \"\n            \"are more efficient than ``sets``.\",\n        ),\n        \"C0209\": (\n            \"Formatting a regular string which could be an f-string\",\n            \"consider-using-f-string\",\n            \"Used when we detect a string that is being formatted with format() or % \"\n            \"which could potentially be an f-string. The use of f-strings is preferred. \"\n            \"Requires Python 3.6 and ``py-version >= 3.6``.\",\n        ),\n    }\n\n    def open(self) -> None:\n        py_version = self.linter.config.py_version\n        self._py36_plus = py_version >= (3, 6)\n\n    @staticmethod\n    def _is_builtin(node: nodes.NodeNG, function: str) -> bool:\n        inferred = utils.safe_infer(node)\n        if not inferred:\n            return False\n        return utils.is_builtin_object(inferred) and inferred.name == function\n\n    @utils.only_required_for_messages(\n        \"consider-iterating-dictionary\", \"use-maxsplit-arg\"\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        self._check_consider_iterating_dictionary(node)\n        self._check_use_maxsplit_arg(node)\n\n    def _check_consider_iterating_dictionary(self, node: nodes.Call) -> None:\n        if not isinstance(node.func, nodes.Attribute):\n            return\n        if node.func.attrname != \"keys\":\n            return\n\n        if isinstance(node.parent, nodes.BinOp) and node.parent.op in {\"&\", \"|\", \"^\"}:\n            return\n\n        comp_ancestor = utils.get_node_first_ancestor_of_type(node, nodes.Compare)\n        if isinstance(node.parent, (nodes.For, nodes.Comprehension)) or (\n            comp_ancestor\n            and any(\n                op\n                for op, comparator in comp_ancestor.ops\n                if op in {\"i"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pragma_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "RDS:s})\\b\"),\n    (\"MESSAGE_STRING\", r\"[0-9A-Za-z\\-\\_]{2,}\"),  # Identifiers\n    (\"ASSIGN\", r\"=\"),  # Assignment operator\n    (\"MESSAGE_NUMBER\", r\"[CREIWF]{1}\\d*\"),\n]\n\nTOK_REGEX = \"|\".join(\n    f\"(?P<{token_name:s}>{token_rgx:s})\"\n    for token_name, token_rgx in TOKEN_SPECIFICATION\n)\n\n\ndef emit_pragma_representer(action: str, messages: list[str]) -> PragmaRepresenter:\n    if not messages and action in MESSAGE_KEYWORDS:\n        raise InvalidPragmaError(\n            \"The keyword is not followed by message identifier\", action\n        )\n    return PragmaRepresenter(action, messages)\n\n\nclass PragmaParserError(Exception):\n    \"\"\"A class for exceptions thrown by pragma_parser module.\"\"\"\n\n    def __init__(self, message: str, token: str) -> None:\n        \"\"\":args message: explain the reason why the exception has been thrown\n        :args token: token concerned by the exception.\n        \"\"\"\n        self.message = message\n        self.token = token\n        super().__init__(self.message)\n\n\nclass UnRecognizedOptionError(PragmaParserError):\n    \"\"\"Thrown in case the of a valid but unrecognized option.\"\"\"\n\n\nclass InvalidPragmaError(PragmaParserError):\n    \"\"\"Thrown in case the pragma is invalid.\"\"\"\n\n\ndef parse_pragma(pylint_pragma: str) -> Generator[PragmaRepresenter]:\n    action: str | None = None\n    messages: list[str] = []\n    assignment_required = False\n    previous_token = \"\"\n\n    for mo in re.finditer(TOK_REGEX, pylint_pragma):\n        kind = mo.lastgroup\n        value = mo.group()\n\n        if kind == \"ASSIGN\":\n            if not assignment_required:\n                if action:\n                    # A keyword has been found previously but doesn't support assignment\n                    raise UnRecognizedOptionError(\n                        \"The keyword doesn't support assignment\", action\n                    )\n                if previous_token:\n                    # Something found previously but not a known keyword\n                    raise UnRecognizedOptionError(\n          "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}], "retrieved_count": 10, "cost_time": 1.1184723377227783}
{"question": "What is the relationship between Pylint's configuration system and checker behavior?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's configuration system and checker behavior are tightly integrated through a hierarchical configuration model. Each checker can define its own configuration options that are automatically integrated into the overall configuration system. The configuration system provides checkers with access to their specific settings through the linter.config object, allowing checkers to adapt their behavior based on user preferences. Configuration options can control which messages a checker emits, how aggressive its analysis is, and which patterns it should ignore. The system supports per-directory configurations, allowing different checker behavior for different parts of a codebase. Checkers can also register their options with the configuration system to enable command-line and configuration file support. This integration ensures that checker behavior is consistently configurable and that users can fine-tune analysis to match their project's needs.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consistent hashing.\",\n            {\"old_names\": [(\"W1003\", \"old-message-with-options\")], \"shared\": True},\n        ),\n    }\n\n\ndef test_base_checker_doc() -> None:\n    basic = OtherBasicChecker()\n    expected_beginning = \"\"\"\\\nBasic checker\n~~~~~~~~~~~~~\n\nVerbatim name of the checker is ``basic``.\n\n\"\"\"\n    expected_middle = \"\"\"\\\nBasic checker Options\n^^^^^^^^^^^^^^^^^^^^^\n:example-args:\n  Example of integer argument for the checker.\n\n  Default: ``42``\n\n\"\"\"\n    expected_end = \"\"\"\\\nBasic checker Messages\n^^^^^^^^^^^^^^^^^^^^^^\n:basic-checker-example (W0001): *Basic checker has an example.*\n  Used nowhere and serves no purpose.\n\n\n\"\"\"\n    assert str(basic) == expected_beginning + expected_end\n    assert repr(basic) == \"Checker 'basic' (responsible for 'W0001')\"\n    less_basic = LessBasicChecker()\n\n    assert str(less_basic) == expected_beginning + expected_middle + expected_end\n    assert repr(less_basic) == repr(basic)\n\n\ndef test_base_checker_ordering() -> None:\n    \"\"\"Test ordering of checkers based"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n        linter.set_option(\"output-format\", \"missing.module.Class\")\n\n    # AssertionError\n    with pytest.raises(exceptions.InvalidReporterError):\n        linter.set_option(\"output-format\", \"lint.unittest_lint._CustomPyLinter\")\n\n    # AttributeError\n    with pytest.raises(exceptions.InvalidReporterError):\n        linter.set_option(\"output-format\", \"lint.unittest_lint.MyReporter\")\n\n\ndef test_set_option_1(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    linter.set_option(\"disable\", \"C0111,W0234\")\n    assert not linter.is_message_enabled(\"C0111\")\n    assert not linter.is_message_enabled(\"W0234\")\n    assert linter.is_message_enabled(\"W0113\")\n    assert not linter.is_message_enabled(\"missing-docstring\")\n    assert not linter.is_message_enabled(\"non-iterator-returned\")\n\n\ndef test_set_option_2(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    linter.set_option(\"disable\", (\"C0111\", \"W0234\"))\n    assert not linter.is_message_enabled(\"C0111\")\n    assert not linter.is_message_enabled(\"W0234\")\n    assert linter.is_message_enabled(\"W0113\")\n    assert not linter.is_message_enabled(\"missing-docstring\")\n    assert not linter.is_message_enabled(\"non-iterator-returned\")\n\n\ndef test_enable_checkers(linter: PyLinter) -> None:\n    linter.disable(\"design\")\n    assert \"design\" not in [c.name for c in linter.prepare_checkers()]\n    linter.enable(\"design\")\n    assert \"design\" in [c.name for c in linter.prepare_checkers()]\n\n\ndef test_errors_only(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    linter._error_mode = True\n    linter._parse_error_mode()\n    checkers = linter.prepare_checkers()\n    checker_names = {c.name for c in checkers}\n    should_not = {\"design\", \"format\", \"metrics\", \"miscellaneous\", \"similarities\"}\n    assert set() == should_not & checker_names\n\n\ndef test_disable_similar(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    linter.set_option(\"disable\", \"RP0801\")\n    linter.set_"}], "retrieved_count": 10, "cost_time": 1.1359844207763672}
{"question": "Why does Pylint use astroid instead of the standard library's ast module?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint uses astroid instead of the standard library's ast module because astroid provides significant enhancements that are essential for sophisticated static analysis: 1) Enhanced AST nodes - astroid adds additional information and methods to AST nodes that make analysis easier and more accurate, 2) Type inference capabilities - astroid can infer types and provide type information that the standard ast module cannot, 3) Import resolution - astroid can resolve imports and build module dependencies automatically, 4) Better error handling - astroid provides more graceful handling of syntax errors and import failures, 5) Additional context - astroid nodes contain more context information like scope, parent relationships, and inferred types, 6) Utility methods - astroid provides helper methods for common analysis tasks like finding definitions and usages, 7) Backward compatibility - astroid maintains compatibility with the standard ast interface while adding features, 8) Active development - astroid is actively developed alongside Pylint to support advanced analysis features. These enhancements enable Pylint to perform more sophisticated and accurate static analysis than would be possible with the standard ast module.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Visitor doing some post-processing on the astroid tree.\n\nTry to resolve definitions (namespace) dictionary, relationship...\n\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport os\nimport traceback\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Callable, Sequence\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import constants\nfrom pylint.checkers.utils import safe_infer\nfrom pylint.pyreverse import utils\n\n_WrapperFuncT = Callable[\n    [Callable[[str], nodes.Module], str, bool], nodes.Module | None\n]\n\n\ndef _astroid_wrapper(\n    func: Callable[[str], nodes.Module],\n    modname: str,\n    verbose: bool = False,\n) -> nodes.Module | None:\n    if verbose:\n        print(f\"parsing {modname}...\")\n    try:\n        return func(modname)\n    except astroid.exceptions.AstroidBuildingError as exc:\n        print(exc)\n    except Exception:  # pylint: disable=broad-except\n        traceback.print_exc()\n    return None\n\n\nclass IdGeneratorMixIn:\n    \"\"\"Mixin adding the ability to generate integer uid.\"\"\"\n\n    def __init__(self, start_value: int = 0) -> None:\n        self.id_count = start_value\n\n    def init_counter(self, start_value: int = 0) -> None:\n        \"\"\"Init the id counter.\"\"\"\n        self.id_count = start_value\n\n    def generate_id(self) -> int:\n        \"\"\"Generate a new identifier.\"\"\"\n        self.id_count += 1\n        return self.id_count\n\n\nclass Project:\n    \"\"\"A project handle a set of modules / packages.\"\"\"\n\n    def __init__(self, name: str = \"\"):\n        self.name = name\n        self.uid: int | None = None\n        self.path: str = \"\"\n        self.modules: list[nodes.Module] = []\n        self.locals: dict[str, nodes.Module] = {}\n        self.__getitem__ = self.locals.__getitem__\n        self.__iter__ = se"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ile to check\n        - name: Python module name\n        :param callable check_astroid_module: callable checking an AST taking the following\n               arguments\n        - ast: AST of the module\n        :param FileItem file: data about the file\n        :raises AstroidError: for any failures stemming from astroid\n        \"\"\"\n        self.set_current_module(file.name, file.filepath)\n        # get the module representation\n        ast_node = get_ast(file.filepath, file.name)\n        if ast_node is None:\n            return\n\n        self._ignore_file = False\n\n        self.file_state = FileState(file.modpath, self.msgs_store, ast_node)\n        # fix the current file (if the source file was not available or\n        # if it's actually a c extension)\n        self.current_file = ast_node.file\n        try:\n            check_astroid_module(ast_node)\n        except Exception as e:  # pragma: no cover\n            raise astroid.AstroidError from e\n        # warn about spurious inline messages handling\n        spurious_messages = self.file_state.iter_spurious_suppression_messages(\n            self.msgs_store\n        )\n        for msgid, line, args in spurious_messages:\n            self.add_message(msgid, line, None, args)\n\n    def _get_file_descr_from_stdin(self, filepath: str) -> Iterator[FileItem]:\n        \"\"\"Return file description (tuple of module name, file path, base name) from\n        given file path.\n\n        This method is used for creating suitable file description for _check_files when the\n        source is standard input.\n        \"\"\"\n        if _is_ignored_file(\n            filepath,\n            self.config.ignore,\n            self.config.ignore_patterns,\n            self.config.ignore_paths,\n        ):\n            self.stats.skipped += 1\n            return\n\n        try:\n            # Note that this function does not really perform an\n            # __import__ but may raise an ImportError exception, which\n            # we want to catch here.\n            modname = \".\"."}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dname)\n    except astroid.exceptions.AstroidBuildingError as exc:\n        print(exc)\n    except Exception:  # pylint: disable=broad-except\n        traceback.print_exc()\n    return None\n\n\nclass IdGeneratorMixIn:\n    \"\"\"Mixin adding the ability to generate integer uid.\"\"\"\n\n    def __init__(self, start_value: int = 0) -> None:\n        self.id_count = start_value\n\n    def init_counter(self, start_value: int = 0) -> None:\n        \"\"\"Init the id counter.\"\"\"\n        self.id_count = start_value\n\n    def generate_id(self) -> int:\n        \"\"\"Generate a new identifier.\"\"\"\n        self.id_count += 1\n        return self.id_count\n\n\nclass Project:\n    \"\"\"A project handle a set of modules / packages.\"\"\"\n\n    def __init__(self, name: str = \"\"):\n        self.name = name\n        self.uid: int | None = None\n        self.path: str = \"\"\n        self.modules: list[nodes.Module] = []\n        self.locals: dict[str, nodes.Module] = {}\n        self.__getitem__ = self.locals.__getitem__\n        self.__iter__ = self.locals.__iter__\n        self.values = self.locals.values\n        self.keys = self.locals.keys\n        self.items = self.locals.items\n\n    def add_module(self, node: nodes.Module) -> None:\n        self.locals[node.name] = node\n        self.modules.append(node)\n\n    def get_module(self, name: str) -> nodes.Module:\n        return self.locals[name]\n\n    def get_children(self) -> list[nodes.Module]:\n        return self.modules\n\n    def __repr__(self) -> str:\n        return f\"<Project {self.name!r} at {id(self)} ({len(self.modules)} modules)>\"\n\n\nclass Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n    \"\"\"Walk on the project tree and resolve relationships.\n\n    According to options the following attributes may be\n    added to visited nodes:\n\n    * uid,\n      a unique identifier for the node (on astroid.Project, astroid.Module,\n      astroid.Class and astroid.locals_type). Only if the linker\n      has been instantiated with tag=True parameter (False by default).\n\n    * Function\n      a mapp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Try to find more bugs in the code using astroid inference capabilities.\"\"\"\n\nfrom __future__ import annotations\n\nimport heapq\nimport itertools\nimport operator\nimport re\nimport shlex\nimport sys\nfrom collections.abc import Callable, Iterable\nfrom functools import cached_property, lru_cache, singledispatch\nfrom re import Pattern\nfrom typing import TYPE_CHECKING, Any, Literal, TypeAlias\n\nimport astroid\nimport astroid.exceptions\nimport astroid.helpers\nfrom astroid import arguments, bases, nodes, util\nfrom astroid.nodes import _base_nodes\nfrom astroid.typing import InferenceResult, SuccessfulInferenceResult\n\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.checkers.utils import (\n    decorated_with,\n    decorated_with_property,\n    has_known_bases,\n    is_builtin_object,\n    is_comprehension,\n    is_hashable,\n    is_inside_abstract_class,\n    is_iterable,\n    is_mapping,\n    is_module_ignored,\n    is_node_in_type_annotation_context,\n    is_none,\n    is_overload_stub,\n    is_postponed_evaluation_enabled,\n    is_super,\n    node_ignores_exception,\n    only_required_for_messages,\n    safe_infer,\n    supports_delitem,\n    supports_getitem,\n    supports_membership_test,\n    supports_setitem,\n)\nfrom pylint.interfaces import HIGH, INFERENCE\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nCallableObjects: TypeAlias = (\n    bases.BoundMethod\n    | bases.UnboundMethod\n    | nodes.FunctionDef\n    | nodes.Lambda\n    | nodes.ClassDef\n)\n\nSTR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nBUILTINS_IMPLICIT_RETURN_NONE = {\n   "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "custom.py", "upper_path": "/data2/raymone/swebench-repos/pylint/examples", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# Checkers should always inherit from `BaseChecker`.\n\n\nclass MyAstroidChecker(BaseChecker):\n    \"\"\"Add class member attributes to the class local's dictionary.\"\"\"\n\n    # The name defines a custom section of the config for this checker.\n    name = \"custom\"\n    # This class variable declares the messages (i.e. the warnings and errors)\n    # that the checker can emit.\n    msgs = {\n        # Each message has a code, a message that the user will see,\n        # a unique symbol that identifies the message,\n        # and a detailed help message\n        # that will be included in the documentation.\n        \"W0001\": (\"Message that will be emitted\", \"message-symbol\", \"Message help\")\n    }\n    # This class variable declares the options\n    # that are configurable by the user.\n    options = (\n        # Each option definition has a name which is used on the command line\n        # and in config files, and a dictionary of arguments\n        # (similar to argparse.ArgumentParser.add_argument).\n        (\n            \"store-locals-indicator\",\n            {\n                \"default\": \"properties\",\n                \"help\": (\n                    \"The expression name that indicates that the locals should \"\n                    \"be stored\"\n                ),\n            },\n        ),\n    )\n\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`.nodes.Call` node is visited.\n\n        See :mod:`astroid` for the description of available nodes.\n        \"\"\"\n        if not (\n            isinstance(node.func, nodes.Attribute)\n            and isinstance(node.func.expr, nodes.Name)\n            and node.func.expr.name == self.linter.config.store_locals_indicator\n            and node.func.attrname == \"create\"\n        ):\n            return\n        in_class = node.frame()\n        for p"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Some functions that may be useful for various checkers.\"\"\"\n\nfrom __future__ import annotations\n\nimport _string\nimport builtins\nimport fnmatch\nimport itertools\nimport numbers\nimport re\nimport string\nfrom collections.abc import Callable, Iterable, Iterator\nfrom functools import lru_cache, partial\nfrom re import Match\nfrom typing import TYPE_CHECKING, TypeVar\n\nimport astroid.objects\nfrom astroid import TooManyLevelsError, nodes, util\nfrom astroid.context import InferenceContext\nfrom astroid.exceptions import AstroidError\nfrom astroid.nodes._base_nodes import ImportNode, Statement\nfrom astroid.typing import InferenceResult, SuccessfulInferenceResult\n\nfrom pylint.constants import TYPING_NEVER, TYPING_NORETURN\n\nif TYPE_CHECKING:\n\n    from pylint.checkers import BaseChecker\n\n_NodeT = TypeVar(\"_NodeT\", bound=nodes.NodeNG)\n_CheckerT = TypeVar(\"_CheckerT\", bound=\"BaseChecker\")\nAstCallbackMethod = Callable[[_CheckerT, _NodeT], None]\n\nCOMP_NODE_TYPES = (\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.DictComp,\n    nodes.GeneratorExp,\n)\nEXCEPTIONS_MODULE = \"builtins\"\nABC_MODULES = {\"abc\", \"_py_abc\"}\nABC_METHODS = {\n    \"abc.abstractproperty\",\n    \"abc.abstractmethod\",\n    \"abc.abstractclassmethod\",\n    \"abc.abstractstaticmethod\",\n}\nTYPING_PROTOCOLS = frozenset(\n    {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}\n)\nCOMMUTATIVE_OPERATORS = frozenset({\"*\", \"+\", \"^\", \"&\", \"|\"})\nITER_METHOD = \"__iter__\"\nAITER_METHOD = \"__aiter__\"\nNEXT_METHOD = \"__next__\"\nGETITEM_METHOD = \"__getitem__\"\nCLASS_GETITEM_METHOD = \"__class_getitem__\"\nSETITEM_METHOD = \"__setitem__\"\nDELITEM_METHOD = \"__delitem__\"\nCONTAINS_METHOD = \"__contains__\"\nKEYS_METHOD = \"keys\"\n\n# Dictionary which maps the number of expected parameters a\n# special method can have to a set o"}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}], "retrieved_count": 10, "cost_time": 1.1317086219787598}
{"question": "Why does Pylint implement a plugin-based architecture instead of a monolithic linting system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements a plugin-based architecture instead of a monolithic linting system for several important reasons: 1) Modularity - different types of analysis can be developed and maintained independently, 2) Extensibility - new analysis capabilities can be added without modifying the core system, 3) Customization - users can enable/disable specific analysis features based on their needs, 4) Maintainability - individual plugins can be updated and fixed without affecting the entire system, 5) Testing - plugins can be tested in isolation, making debugging and validation easier, 6) Performance - users can disable unnecessary plugins to improve analysis speed, 7) Community contribution - third-party developers can create plugins without deep knowledge of the core system, 8) Configuration flexibility - different projects can use different sets of plugins based on their requirements, 9) Backward compatibility - new plugins can be added without breaking existing functionality, 10) Separation of concerns - each plugin focuses on a specific aspect of code analysis. This architecture makes Pylint more flexible, maintainable, and adaptable to different use cases.", "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Callable\nfrom pathlib import Path\n\nimport pytest\n\nfrom pylint import checkers\nfrom pylint.checkers import BaseChecker\nfrom pylint.lint import PyLinter\nfrom pylint.lint.run import _cpu_count\nfrom pylint.reporters import BaseReporter\nfrom pylint.testutils import MinimalTestReporter\n\nHERE = Path(__file__).parent\n\n\n@pytest.fixture()\ndef tests_directory() -> Path:\n    return HERE\n\n\n@pytest.fixture\ndef linter(\n    checker: type[BaseChecker] | None,\n    register: Callable[[PyLinter], None] | None,\n    enable: str | None,\n    disable: str | None,\n    reporter: type[BaseReporter],\n) -> PyLinter:\n    _linter = PyLinter()\n    _linter.set_reporter(reporter())\n    checkers.initialize(_linter)\n    if register:\n        register(_linter)\n    if checker:\n        _linter.register_checker(checker(_linter))\n    if disable:\n        for msg in disable:\n            _linter.disable(msg)\n    if enable:\n        for msg in enable:\n            _linter.enable(msg)\n    os.environ.pop(\"PYLINTRC\", None)\n    return _linter\n\n\n@pytest.fixture(scope=\"module\")\ndef checker() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef register() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef enable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[MinimalTestReporter]:\n    return MinimalTestReporter\n\n\ndef pytest_addoption(parser: pytest.Parser) -> None:\n    parser.addoption(\n        \"--primer-stdlib\",\n        action=\"store_true\",\n        default=False,\n        help=\"Run primer stdlib tests\",\n    )\n    parser.addoption(\n        \"--minimal-mes"}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "version\":\n            value = str(_format_option_value(optdict, value))\n            result += f\"\\n  Default: ``{value.replace('`` ', '```` ``')}``\\n\"\n    return result\n\n\ndef decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)\n\n\ndef tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\n\n\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (extension in PY_EXTS and base != \"__init__\") or (\n            not extension\n            and os.path.isdir(os.path.join(directory, base))\n            and not filename.startswith(\".\")\n        ):\n            try:\n                module = modutils.load_module_from_file(\n                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n            else:\n                if hasattr(module, \"register\"):\n                    module.register(linter)\n                    imported[base] = 1\n\n\ndef _splitstrip(string: str, sep: str = \",\") -> list[str]:\n    r\"\"\"Return a list of stripped string by splitting the string gi"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}], "retrieved_count": 10, "cost_time": 1.1322622299194336}
{"question": "Why does Pylint provide multiple severity levels for different types of issues?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint provides multiple severity levels for different types of issues for several important reasons: 1) Prioritization - users can focus on the most critical issues first, addressing errors and warnings before style issues, 2) Team workflow - different team members can work on different types of issues based on their roles and expertise, 3) Project maturity - teams can start with high-severity issues and gradually address lower-severity ones as the codebase matures, 4) CI/CD integration - build systems can be configured to fail on high-severity issues while allowing lower-severity ones, 5) Gradual adoption - teams can gradually adopt stricter standards by starting with high-severity checks, 6) Resource allocation - helps teams allocate development resources more effectively, 7) Code review focus - reviewers can prioritize their attention based on severity levels, 8) Compliance requirements - different organizations may have different requirements for which issues must be addressed, 9) Tool integration - IDEs and other tools can provide different visual indicators for different severity levels, 10) Reporting flexibility - reports can be filtered and grouped by severity for different audiences. This system helps teams establish and maintain appropriate code quality standards.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1191, "belongs_to": {"file_name": "interfaces.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n__all__ = (\n    \"CONFIDENCE_LEVELS\",\n    \"CONFIDENCE_LEVEL_NAMES\",\n    \"CONTROL_FLOW\",\n    \"HIGH\",\n    \"INFERENCE\",\n    \"INFERENCE_FAILURE\",\n    \"UNDEFINED\",\n)\n\n\nclass Confidence(NamedTuple):\n    name: str\n    description: str\n\n\n# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n    \"INFERENCE_FAILURE\", \"Warning based on inference with failures.\"\n)\nUNDEFINED = Confidence(\"UNDEFINED\", \"Warning without any associated confidence level.\")\n\nCONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]\nCONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]\nCONFIDENCE_MAP = {i.name: i for i in CONFIDENCE_LEVELS}\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline iteration\",\n    \"typevar\": \"type variable\",\n    \"typealias\": \"type alias\",\n}\n\n# ignore some messages when emitting useless-suppression:\n# - cyclic-import: can show false positives due to incomplete context\n# - deprecated-{module, argument, class, method, decorator}:\n#   can cause false positives for multi-interpreter projects\n#   when linting with an interpreter on a lower python version\nINCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset(\n    [\n        \"R0401\",  # cyclic-import\n        \"W0402\",  # deprecated-module\n        \"W1505\",  # deprecated-method\n        \"W1511\",  # deprecated-argument\n        \"W1512\",  # deprecated-class\n        \"W1513\",  # deprecated-decorator\n        \"R0801\",  # duplicate-code\n    ]\n)\n\n\ndef _get_pylint_home() -> str:\n    \"\"\"Return the pylint home.\"\"\"\n    if \"PYLINTHOME\" in os.environ:\n        return os.environ[\"PYLINTHOME\"]\n    return DEFAULT_PYLINT_HOME\n\n\nPYLINT_HOME = _get_pylint_home()\n\nTYPING_NORETURN = frozenset(\n    (\n        \"typing.NoReturn\",\n        \"ty"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unknown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn'"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 1726, "belongs_to": {"file_name": "exceptions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Exception classes raised by various operations within pylint.\"\"\"\n\n\nclass InvalidMessageError(Exception):\n    \"\"\"Raised when a message creation, registration or addition is rejected.\"\"\"\n\n\nclass UnknownMessageError(Exception):\n    \"\"\"Raised when an unregistered message id is encountered.\"\"\"\n\n\nclass DeletedMessageError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was deleted from pylint is\n    encountered.\n    \"\"\"\n\n    def __init__(self, msgid_or_symbol: str, removal_explanation: str):\n        super().__init__(\n            f\"'{msgid_or_symbol}' was removed from pylint, see {removal_explanation}.\"\n        )\n\n\nclass MessageBecameExtensionError(UnknownMessageError):\n    \"\"\"Raised when a message id or symbol that was moved to an optional\n    extension is encountered.\n    \"\"\"\n\n    def __init__(self, msgid_or_symbol: str, moved_explanation: str):\n        super().__init__(\n            f\"'{msgid_or_symbol}' was moved to an optional extension, see {moved_explanation}.\"\n        )\n\n\nclass EmptyReportError(Exception):\n    \"\"\"Raised when a report is empty and so should not be displayed.\"\"\"\n\n\nclass InvalidReporterError(Exception):\n    \"\"\"Raised when selected reporter is invalid (e.g. not found).\"\"\"\n\n\nclass InvalidArgsError(ValueError):\n    \"\"\"Raised when passed arguments are invalid, e.g., have the wrong length.\"\"\"\n\n\nclass NoLineSuppliedError(Exception):\n    \"\"\"Raised when trying to disable a message on a next line without supplying a line\n    number.\n    \"\"\"\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "primer_run_command.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils/_primer", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    assert (\n                not fatal_msgs\n            ), f\"We encountered {len(fatal_msgs)} fatal error message{plural} (see log).\"\n\n    @staticmethod\n    def _filter_fatal_errors(\n        messages: list[OldJsonExport],\n    ) -> list[Message]:\n        \"\"\"Separate fatal errors so we can report them independently.\"\"\"\n        fatal_msgs: list[Message] = []\n        for raw_message in messages:\n            message = JSONReporter.deserialize(raw_message)\n            if message.category == \"fatal\":\n                if GITHUB_CRASH_TEMPLATE_LOCATION in message.msg:\n                    # Remove the crash template location if we're running on GitHub.\n                    # We were falsely getting \"new\" errors when the timestamp changed.\n                    message.msg = message.msg.rsplit(CRASH_TEMPLATE_INTRO)[0]\n                fatal_msgs.append(message)\n        return fatal_msgs\n\n    @staticmethod\n    def _print_msgs(msgs: list[Message]) -> str:\n        return \"\\n\".join(f\"- {JSONReporter.serialize(m)}\" for m in msgs)\n\n    def _lint_package(\n        self, package_name: str, data: PackageToLint\n    ) -> tuple[list[OldJsonExport], list[Message]]:\n        # We want to test all the code we can\n        enables = [\"--enable-all-extensions\", \"--enable=all\"]\n        # Duplicate code takes too long and is relatively safe\n        # TODO: Find a way to allow cyclic-import and compare output correctly\n        disables = [\"--disable=duplicate-code,cyclic-import\"]\n        additional = [\"--clear-cache-post-run=y\"]\n        arguments = data.pylint_args + enables + disables + additional\n        output = StringIO()\n        reporter = JSONReporter(output)\n        print(f\"Running 'pylint {', '.join(arguments)}'\")\n        pylint_exit_code = -1\n        try:\n            Run(arguments, reporter=reporter)\n        except SystemExit as e:\n            pylint_exit_code = int(e.code)  # type: ignore[arg-type]\n        readable_messages: str = output.getvalue()\n        messages: list[OldJsonExport] = json.l"}], "retrieved_count": 10, "cost_time": 1.1336259841918945}
{"question": "Why does Pylint use a message-based reporting system instead of direct output to stdout?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint uses a message-based reporting system instead of direct output to stdout for several important reasons: 1) Flexibility - messages can be formatted and output in multiple formats (text, JSON, XML, etc.) through different reporters, 2) Programmatic access - messages can be collected, filtered, and processed programmatically for integration with other tools, 3) Structured data - messages contain rich metadata (location, severity, confidence) that can be used for advanced filtering and sorting, 4) Multiple output formats - the same analysis can produce different output formats simultaneously using MultiReporter, 5) Integration capabilities - structured messages enable integration with IDEs, CI/CD systems, and other development tools, 6) Filtering and customization - messages can be filtered by severity, confidence, or other criteria before output, 7) Testing and validation - structured messages are easier to test and validate programmatically, 8) Extensibility - new output formats can be added without modifying core analysis logic. This design separates analysis from output formatting, making Pylint more versatile and integrable.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "reporter_for_tests.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom io import StringIO\nfrom os import getcwd, sep\nfrom typing import TYPE_CHECKING\n\nfrom pylint.message import Message\nfrom pylint.reporters import BaseReporter\n\nif TYPE_CHECKING:\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass GenericTestReporter(BaseReporter):\n    \"\"\"Reporter storing plain text messages.\"\"\"\n\n    out: StringIO\n\n    def __init__(  # pylint: disable=super-init-not-called # See https://github.com/pylint-dev/pylint/issues/4941\n        self,\n    ) -> None:\n        self.path_strip_prefix: str = getcwd() + sep\n        self.reset()\n\n    def reset(self) -> None:\n        self.out = StringIO()\n        self.messages: list[Message] = []\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Append messages to the list of messages of the reporter.\"\"\"\n        self.messages.append(msg)\n\n    def finalize(self) -> str:\n        \"\"\"Format and print messages in the context of the path.\"\"\"\n        messages: list[str] = []\n        for msg in self.messages:\n            obj = \"\"\n            if msg.obj:\n                obj = f\":{msg.obj}\"\n            messages.append(f\"{msg.msg_id[0]}:{msg.line:>3}{obj}: {msg.msg}\")\n\n        messages.sort()\n        for message in messages:\n            print(message, file=self.out)\n\n        result = self.out.getvalue()\n        self.reset()\n        return result\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        pass\n\n    # pylint: enable=unused-argument\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts.\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> N"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import TYPE_CHECKING, TextIO\n\nfrom pylint.message import Message\nfrom pylint.reporters.ureports.nodes import Text\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass BaseReporter:\n    \"\"\"Base class for reporters.\n\n    symbols: show short symbolic names for messages.\n    \"\"\"\n\n    extension = \"\"\n\n    name = \"base\"\n    \"\"\"Name of the reporter.\"\"\"\n\n    def __init__(self, output: TextIO | None = None) -> None:\n        self.linter: PyLinter\n        self.section = 0\n        self.out: TextIO = output or sys.stdout\n        self.messages: list[Message] = []\n        # Build the path prefix to strip to get relative paths\n        self.path_strip_prefix = os.getcwd() + os.sep\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Handle a new message triggered on the current file.\"\"\"\n        self.messages.append(msg)\n\n    def writeln(self, string: str = \"\") -> None:\n        \"\"\"Write a line in the output buffer.\"\"\"\n        print(string, file=self.out)\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Display results encapsulated in the layout tree.\"\"\"\n        self.section = 0\n        if layout.report_id:\n            if isinstance(layout.children[0].children[0], Text):\n                layout.children[0].children[0].data += f\" ({layout.report_id})\"\n            else:\n                raise ValueError(f\"Incorrect child for {layout.children[0].children}\")\n        self._display(layout)\n\n    def _display(self, layout: Section) -> None:\n        \"\"\"Display the layout.\"\"\"\n        raise NotImplementedError()\n\n    def display_messages(self, layout: Section | N"}, {"start_line": 0, "end_line": 735, "belongs_to": {"file_name": "collecting_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.reporters.base_reporter import BaseReporter\n\nif TYPE_CHECKING:\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass CollectingReporter(BaseReporter):\n    \"\"\"Collects messages.\"\"\"\n\n    name = \"collector\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.messages = []\n\n    def reset(self) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom dataclasses import asdict, dataclass\n\nfrom pylint.constants import MSG_TYPES\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.typing import MessageLocationTuple\n\n\n@dataclass(unsafe_hash=True)\nclass Message:  # pylint: disable=too-many-instance-attributes\n    \"\"\"This class represent a message to be issued by the reporters.\"\"\"\n\n    msg_id: str\n    symbol: str\n    msg: str\n    C: str\n    category: str\n    confidence: Confidence\n    abspath: str\n    path: str\n    module: str\n    obj: str\n    line: int\n    column: int\n    end_line: int | None\n    end_column: int | None\n\n    def __init__(\n        self,\n        msg_id: str,\n        symbol: str,\n        location: MessageLocationTuple,\n        msg: str,\n        confidence: Confidence | None,\n    ) -> None:\n        self.msg_id = msg_id\n        self.symbol = symbol\n        self.msg = msg\n        self.C = msg_id[0]\n        self.category = MSG_TYPES[msg_id[0]]\n        self.confidence = confidence or UNDEFINED\n        self.abspath = location.abspath\n        self.path = location.path\n        self.module = location.module\n        self.obj = location.obj\n        self.line = location.line\n        self.column = location.column\n        self.end_line = location.end_line\n        self.end_column = location.end_column\n\n    def format(self, template: str) -> str:\n        \"\"\"Format the message according to the given template.\n\n        The template format is the one of the format method :\n        cf. https://docs.python.org/2/library/string.html#formatstrings\n        \"\"\"\n        return template.format(**asdict(self))\n\n    @property\n    def location(self) -> MessageLocationTuple:\n        return MessageLocationTuple(\n            self.abspath,\n            self.pa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "report_functions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nfrom collections import defaultdict\n\nfrom pylint import checkers, exceptions\nfrom pylint.reporters.ureports.nodes import Section, Table\nfrom pylint.utils import LinterStats\n\n\ndef report_total_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    previous_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make total errors / warnings report.\"\"\"\n    lines = [\"type\", \"number\", \"previous\", \"difference\"]\n    lines += checkers.table_lines_from_stats(stats, previous_stats, \"message_types\")\n    sect.append(Table(children=lines, cols=4, rheaders=1))\n\n\ndef report_messages_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make messages type report.\"\"\"\n    by_msg_stats = stats.by_msg\n    in_order = sorted(\n        (value, msg_id)\n        for msg_id, value in by_msg_stats.items()\n        if not msg_id.startswith(\"I\")\n    )\n    in_order.reverse()\n    lines = [\"message id\", \"occurrences\"]\n    for value, msg_id in in_order:\n        lines += [msg_id, str(value)]\n    sect.append(Table(children=lines, cols=2, rheaders=1))\n\n\ndef report_messages_by_module_stats(\n    sect: Section,\n    stats: LinterStats,\n    _: LinterStats | None,\n) -> None:\n    \"\"\"Make errors / warnings by modules report.\"\"\"\n    module_stats = stats.by_module\n    if len(module_stats) == 1:\n        # don't print this report when we are analysing a single module\n        raise exceptions.EmptyReportError()\n    by_mod: defaultdict[str, dict[str, int | float]] = collections.defaultdict(dict)\n    for m_type in (\"fatal\", \"error\", \"warning\", \"refactor\", \"convention\"):\n        total = stats.get_global_message_count(m_type)\n        for module in module_stats.keys():\n            mod_total = stats.get_"}, {"start_line": 1000, "end_line": 2321, "belongs_to": {"file_name": "reporter_for_tests.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ppend messages to the list of messages of the reporter.\"\"\"\n        self.messages.append(msg)\n\n    def finalize(self) -> str:\n        \"\"\"Format and print messages in the context of the path.\"\"\"\n        messages: list[str] = []\n        for msg in self.messages:\n            obj = \"\"\n            if msg.obj:\n                obj = f\":{msg.obj}\"\n            messages.append(f\"{msg.msg_id[0]}:{msg.line:>3}{obj}: {msg.msg}\")\n\n        messages.sort()\n        for message in messages:\n            print(message, file=self.out)\n\n        result = self.out.getvalue()\n        self.reset()\n        return result\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        pass\n\n    # pylint: enable=unused-argument\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts.\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass FunctionalTestReporter(BaseReporter):\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts and don't call self._display().\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "multi_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Callable\nfrom copy import copy\nfrom typing import TYPE_CHECKING, TextIO\n\nfrom pylint.message import Message\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass MultiReporter:\n    \"\"\"Reports messages and layouts in plain text.\"\"\"\n\n    name = \"_internal_multi_reporter\"\n    # Note: do not register this reporter with linter.register_reporter as it is\n    #       not intended to be used directly like a regular reporter, but is\n    #       instead used to implement the\n    #       `--output-format=json:somefile.json,colorized`\n    #       multiple output formats feature\n\n    extension = \"\"\n\n    def __init__(\n        self,\n        sub_reporters: list[BaseReporter],\n        close_output_files: Callable[[], None],\n        output: TextIO | None = None,\n    ):\n        self._sub_reporters = sub_reporters\n        self.close_output_files = close_output_files\n        self._path_strip_prefix = os.getcwd() + os.sep\n        self._linter: PyLinter | None = None\n        self.out = output\n        self.messages: list[Message] = []\n\n    @property\n    def out(self) -> TextIO | None:\n        return self.__out\n\n    @out.setter\n    def out(self, output: TextIO | None = None) -> None:\n        \"\"\"MultiReporter doesn't have its own output.\n\n        This method is only provided for API parity with BaseReporter\n        and should not be called with non-None values for 'output'.\n        \"\"\"\n        self.__out = None\n        if output is not None:\n            raise NotImplementedError(\"MultiReporter does not support direct output.\")\n\n    def"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "all parameters in the template are attributes of the Message\n        arguments = re.findall(r\"\\{(\\w+?)(:.*)?\\}\", template)\n        for argument in arguments:\n            if argument[0] not in MESSAGE_FIELDS:\n                warnings.warn(\n                    f\"Don't recognize the argument '{argument[0]}' in the --msg-template. \"\n                    \"Are you sure it is supported on the current version of pylint?\",\n                    stacklevel=2,\n                )\n                template = re.sub(r\"\\{\" + argument[0] + r\"(:.*?)?\\}\", \"\", template)\n        self._fixed_template = template\n\n    def write_message(self, msg: Message) -> None:\n        \"\"\"Convenience method to write a formatted message with class default\n        template.\n        \"\"\"\n        self_dict = asdict(msg)\n        for key in (\"end_line\", \"end_column\"):\n            self_dict[key] = self_dict[key] or \"\"\n\n        self.writeln(self._fixed_template.format(**self_dict))\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Manage message of different type and in the context of path.\"\"\"\n        if msg.module not in self._modules:\n            self.writeln(make_header(msg))\n            self._modules.add(msg.module)\n        self.write_message(msg)\n\n    def _display(self, layout: Section) -> None:\n        \"\"\"Launch layouts display.\"\"\"\n        print(file=self.out)\n        TextWriter().format(layout, self.out)\n\n\nclass NoHeaderReporter(TextReporter):\n    \"\"\"Reports messages and layouts in plain text without a module header.\"\"\"\n\n    name = \"no-header\"\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Write message(s) without module header.\"\"\"\n        if msg.module not in self._modules:\n            self._modules.add(msg.module)\n        self.write_message(msg)\n\n\nclass ParseableTextReporter(TextReporter):\n    \"\"\"A reporter very similar to TextReporter, but display messages in a form\n    recognized by most text editors :\n\n    <filename>:<linenum>:<msg>\n    \"\"\"\n\n    name = \"parseable\"\n    line_"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}], "retrieved_count": 10, "cost_time": 1.1504409313201904}
{"question": "What is the relationship between Pylint's ASTWalker class and the Checker classes in establishing the connection between AST traversal and rule checking?", "answer": null, "relative_code_list": null, "ground_truth": "The ASTWalker class implements the visitor pattern to coordinate AST traversal with checker execution. It maintains callbacks for different node types and manages the traversal order. When walking the AST, ASTWalker calls the appropriate visit and leave methods on registered checkers based on the node type. For each AST node, it first calls all visit methods on checkers that have registered for that node type, then recursively visits all children of the node, and finally calls all leave methods. This two-phase approach allows checkers to perform both top-down and bottom-up analysis. ASTWalker also tracks statistics like the number of statements processed and handles exceptions that may occur during checker execution. The relationship enables checkers to focus on their specific analysis logic while ASTWalker handles the complex traversal coordination.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "statements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no activated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     self.current_file = filepath or modname\n        self.stats.init_single_module(modname or \"\")\n\n        # If there is an actual filepath we might need to update the config attribute\n        if filepath:\n            namespace = self._get_namespace_for_file(\n                Path(filepath), self._directory_namespaces\n            )\n            if namespace:\n                self.config = namespace or self._base_config\n\n    def _get_namespace_for_file(\n        self, filepath: Path, namespaces: DirectoryNamespaceDict\n    ) -> argparse.Namespace | None:\n        for directory in namespaces:\n            if Path.is_relative_to(filepath, directory):\n                namespace = self._get_namespace_for_file(\n                    filepath, namespaces[directory][1]\n                )\n                if namespace is None:\n                    return namespaces[directory][0]\n        return None\n\n    @contextlib.contextmanager\n    def _astroid_module_checker(\n        self,\n    ) -> Iterator[Callable[[nodes.Module], bool | None]]:\n        \"\"\"Context manager for checking ASTs.\n\n        The value in the context is callable accepting AST as its only argument.\n        \"\"\"\n        walker = ASTWalker(self)\n        _checkers = self.prepare_checkers()\n        tokencheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseTokenChecker)\n        ]\n        rawcheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)\n        ]\n        for checker in _checkers:\n            checker.open()\n            walker.add_checker(checker)\n\n        yield functools.partial(\n            self.check_astroid_module,\n            walker=walker,\n            tokencheckers=tokencheckers,\n            rawcheckers=rawcheckers,\n        )\n\n        # notify global end\n        self.stats.statement = walker.nbstatements\n        for checker in reversed(_checkers):\n            checker.close()\n\n    def get_ast(\n        self, filepath: str, modname: str, data: str | None = None\n    "}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}], "retrieved_count": 10, "cost_time": 1.1586635112762451}
{"question": "Where does Pylint store its message configuration and severity level management?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint stores its message configuration and severity level management in several key locations: 1) MessageDefinition class - defines the structure and metadata for each message type, 2) MessageDefinitionStore - manages the registration and retrieval of all message definitions, 3) MessageIdStore - maintains the mapping between message IDs and symbols, 4) Individual checker classes - each checker defines its messages in the msgs dictionary, 5) Configuration files - message enable/disable settings are stored in configuration files, 6) PyLinter instance - maintains the current state of which messages are enabled/disabled, 7) Constants module - defines severity level constants and message type mappings, 8) Command-line arguments - message settings can be overridden via command-line options, 9) Per-directory configurations - different message settings can be applied to different directories, 10) Plugin message registration - custom plugins can register their own message definitions. This system provides flexible and hierarchical control over which messages are displayed and their severity levels.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 632, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"All the classes related to Message handling.\"\"\"\n\nfrom pylint.message.message import Message\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_definition_store import MessageDefinitionStore\nfrom pylint.message.message_id_store import MessageIdStore\n\n__all__ = [\n    \"Message\",\n    \"MessageDefinition\",\n    \"MessageDefinitionStore\",\n    \"MessageIdStore\",\n]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_definition_store.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nimport sys\nfrom collections.abc import Sequence, ValuesView\nfrom functools import cache\nfrom typing import TYPE_CHECKING\n\nfrom pylint.exceptions import UnknownMessageError\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.message.message_id_store import MessageIdStore\n\nif TYPE_CHECKING:\n    from pylint.checkers import BaseChecker\n\n\nclass MessageDefinitionStore:\n    \"\"\"The messages store knows information about every possible message definition but\n    has no particular state during analysis.\n    \"\"\"\n\n    def __init__(\n        self, py_version: tuple[int, ...] | sys._version_info = sys.version_info\n    ) -> None:\n        self.message_id_store: MessageIdStore = MessageIdStore()\n        # Primary registry for all active messages definitions.\n        # It contains the 1:1 mapping from msgid to MessageDefinition.\n        # Keys are msgid, values are MessageDefinition\n        self._messages_definitions: dict[str, MessageDefinition] = {}\n        # MessageDefinition kept by category\n        self._msgs_by_category: dict[str, list[str]] = collections.defaultdict(list)\n        self.py_version = py_version\n\n    @property\n    def messages(self) -> ValuesView[MessageDefinition]:\n        \"\"\"The list of all active messages.\"\"\"\n        return self._messages_definitions.values()\n\n    def register_messages_from_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Register all messages definitions from a checker.\"\"\"\n        checker.check_consistency()\n        for message in checker.messages:\n            self.register_message(message)\n\n    def register_message(self, message: MessageDefinition) -> None:\n        \"\"\"Register a MessageDefinition with consistency in mind.\"\"\"\n      "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_id_store.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NoReturn\n\nfrom pylint.exceptions import (\n    DeletedMessageError,\n    InvalidMessageError,\n    MessageBecameExtensionError,\n    UnknownMessageError,\n)\nfrom pylint.message._deleted_message_ids import (\n    is_deleted_msgid,\n    is_deleted_symbol,\n    is_moved_msgid,\n    is_moved_symbol,\n)\n\n\nclass MessageIdStore:\n    \"\"\"The MessageIdStore store MessageId and make sure that there is a 1-1 relation\n    between msgid and symbol.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.__msgid_to_symbol: dict[str, str] = {}\n        self.__symbol_to_msgid: dict[str, str] = {}\n        self.__old_names: dict[str, list[str]] = {}\n        self.__active_msgids: dict[str, list[str]] = {}\n\n    def __len__(self) -> int:\n        return len(self.__msgid_to_symbol)\n\n    def __repr__(self) -> str:\n        result = \"MessageIdStore: [\\n\"\n        for msgid, symbol in self.__msgid_to_symbol.items():\n            result += f\"  - {msgid} ({symbol})\\n\"\n        result += \"]\"\n        return result\n\n    def get_symbol(self, msgid: str) -> str:\n        try:\n            return self.__msgid_to_symbol[msgid.upper()]\n        except KeyError as e:\n            msg = f\"'{msgid}' is not stored in the message store.\"\n            raise UnknownMessageError(msg) from e\n\n    def get_msgid(self, symbol: str) -> str:\n        try:\n            return self.__symbol_to_msgid[symbol]\n        except KeyError as e:\n            msg = f\"'{symbol}' is not stored in the message store.\"\n            raise UnknownMessageError(msg) from e\n\n    def register_message_definition(\n        self, msgid: str, symbol: str, old_names: list[tuple[str, str]]\n    ) -> None:\n        self.check_msgid_and_symbol(msgid, symbol)\n        self.add_msgid_and_symbol(m"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ine\n    pragma's.\n    \"\"\"\n\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,\n            \"disable-next\": self.disable_next,\n        }\n        self._bw_options_methods = {\n            \"disable-msg\": self._options_methods[\"disable\"],\n            \"enable-msg\": self._options_methods[\"enable\"],\n        }\n        self._pragma_lineno: dict[str, int] = {}\n        self._stashed_messages: defaultdict[\n            tuple[str, str], list[tuple[str | None, str]]\n        ] = defaultdict(list)\n        \"\"\"Some messages in the options (for --enable and --disable) are encountered\n        too early to warn about them.\n\n        i.e. before all option providers have been fully parsed. Thus, this dict stores\n        option_value and msg_id needed to (later) emit the messages keyed on module names.\n        \"\"\"\n\n    def _set_one_msg_status(\n        self, scope: str, msg: MessageDefinition, line: int | None, enable: bool\n    ) -> None:\n        \"\"\"Set the status of an individual message.\"\"\"\n        if scope in {\"module\", \"line\"}:\n            assert isinstance(line, int)  # should always be int inside module scope\n\n            self.linter.file_state.set_msg_status(msg, line, enable, scope)\n            if not enable and msg.symbol != \"locally-disabled\":\n                self.linter.add_message(\n                    \"locally-disabled\", line=line, args=(msg.symbol, msg.msgid)\n                )\n        else:\n            msgs = self._msgs_state\n            msgs[msg.msgid] = enable\n\n    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinitio"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hem.\n\n        i.e. before all option providers have been fully parsed. Thus, this dict stores\n        option_value and msg_id needed to (later) emit the messages keyed on module names.\n        \"\"\"\n\n    def _set_one_msg_status(\n        self, scope: str, msg: MessageDefinition, line: int | None, enable: bool\n    ) -> None:\n        \"\"\"Set the status of an individual message.\"\"\"\n        if scope in {\"module\", \"line\"}:\n            assert isinstance(line, int)  # should always be int inside module scope\n\n            self.linter.file_state.set_msg_status(msg, line, enable, scope)\n            if not enable and msg.symbol != \"locally-disabled\":\n                self.linter.add_message(\n                    \"locally-disabled\", line=line, args=(msg.symbol, msg.msgid)\n                )\n        else:\n            msgs = self._msgs_state\n            msgs[msg.msgid] = enable\n\n    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinition]:\n        \"\"\"Do some tests and find the actual messages of which the status should be set.\"\"\"\n        message_definitions: list[MessageDefinition] = []\n        if msgid == \"all\":\n            for _msgid in MSG_TYPES:\n                message_definitions.extend(\n                    self._get_messages_to_set(_msgid, enable, ignore_unknown)\n                )\n            if not enable:\n                # \"all\" should not disable pylint's own warnings\n                message_definitions = list(\n                    filter(\n                        lambda m: m.msgid not in self.default_enabled_messages,\n                        message_definitions,\n                    )\n                )\n            return message_definitions\n\n        # msgid is a category?\n        category_id = msgid.upper()\n        if category_id not in MSG_TYPES:\n            category_id_formatted = MSG_TYPES_LONG.get(category_id)\n        else:\n            category_id_formatted = category_id\n        if category_id_formatted is"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylint_messages.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sages\"\n\"\"\"Path to the messages documentation folder.\"\"\"\n\nPYLINT_MESSAGES_DATA_PATH = PYLINT_BASE_PATH / \"doc\" / \"data\" / \"messages\"\n\"\"\"Path to the folder with data for the messages documentation.\"\"\"\n\nMSG_TYPES_DOC = {k: v if v != \"info\" else \"information\" for k, v in MSG_TYPES.items()}\n\nMESSAGES_WITHOUT_EXAMPLES = {\n    \"astroid-error\",  # internal\n    \"bad-configuration-section\",  # configuration\n    \"bad-plugin-value\",  # internal\n    \"c-extension-no-member\",  # not easy to implement in the current doc framework\n    \"config-parse-error\",  # configuration\n    \"fatal\",  # internal\n    \"import-self\",  # not easy to implement in the current doc framework\n    \"invalid-character-nul\",  # not easy to implement in the current doc framework\n    \"invalid-characters-in-docstring\",  # internal in py-enchant\n    \"invalid-unicode-codec\",  # placeholder (not implemented yet)\n    \"method-check-failed\",  # internal\n    \"parse-error\",  # internal\n    \"raw-checker-failed\",  # internal\n    \"unrecognized-option\",  # configuration\n}\nMESSAGES_WITHOUT_BAD_EXAMPLES = {\n    \"invalid-character-carriage-return\",  # can't be raised in normal pylint use\n    \"return-arg-in-generator\",  # can't be raised in modern python\n}\n\n\nclass MessageData(NamedTuple):\n    checker: str\n    id: str\n    name: str\n    definition: MessageDefinition\n    example_code: str\n    checker_module_name: str\n    checker_module_path: str\n    shared: bool = False\n    default_enabled: bool = True\n\n\nclass ExampleType(str, Enum):\n    GOOD = \"good\"\n    BAD = \"bad\"\n\n\nMessagesDict = dict[str, list[MessageData]]\nOldMessagesDict = dict[str, defaultdict[tuple[str, str], list[tuple[str, str]]]]\n\"\"\"DefaultDict is indexed by tuples of (old name symbol, old name id) and values are\ntuples of (new name symbol, new name category).\n\"\"\"\n\n\ndef _register_all_checkers_and_extensions(linter: PyLinter) -> None:\n    \"\"\"Registers all checkers and extensions found in the default folders.\"\"\"\n    initialize_checkers(linter)\n    initialize_extensions(li"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}], "retrieved_count": 10, "cost_time": 1.1960158348083496}
{"question": "Why does Pylint implement caching mechanisms for repeated analysis?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements caching mechanisms for repeated analysis to improve performance and user experience: 1) AST caching - parsed AST representations are cached to avoid re-parsing unchanged files, 2) Configuration caching - parsed configuration settings are cached to avoid repeated parsing, 3) Import resolution caching - resolved import dependencies are cached to avoid repeated resolution, 4) Type inference caching - computed type information is cached to avoid redundant computation, 5) Message definition caching - message definitions are cached to avoid repeated registration, 6) Plugin loading caching - loaded plugins are cached to avoid repeated loading overhead, 7) File discovery caching - file patterns and discovery results are cached for repeated runs, 8) Analysis result caching - intermediate analysis results are cached when possible, 9) Memory efficiency - caching reduces memory allocation and garbage collection pressure, 10) Incremental analysis support - caching enables efficient incremental analysis when only some files have changed. These caching mechanisms significantly improve performance for repeated analysis runs, especially in large codebases.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport pickle\nimport sys\nimport warnings\nfrom pathlib import Path\n\nfrom pylint.constants import PYLINT_HOME\nfrom pylint.utils import LinterStats\n\nPYLINT_HOME_AS_PATH = Path(PYLINT_HOME)\n\n\ndef _get_pdata_path(\n    base_name: Path, recurs: int, pylint_home: Path = PYLINT_HOME_AS_PATH\n) -> Path:\n    # We strip all characters that can't be used in a filename. Also strip '/' and\n    # '\\\\' because we want to create a single file, not sub-directories.\n    underscored_name = \"_\".join(\n        str(p.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\"))\n        for p in base_name.parts\n    )\n    return pylint_home / f\"{underscored_name}_{recurs}.stats\"\n\n\ndef load_results(\n    base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n\n    if not data_file.exists():\n        return None\n\n    try:\n        with open(data_file, \"rb\") as stream:\n            data = pickle.load(stream)\n            if not isinstance(data, LinterStats):\n                warnings.warn(\n                    \"You're using an old pylint cache with invalid data following \"\n                    f\"an upgrade, please delete '{data_file}'.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                raise TypeError\n            return data\n    except Exception:  # pylint: disable=broad-except\n        # There's an issue with the cache but we just continue as if it isn't there\n        return None\n\n\ndef save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n     "}, {"start_line": 1000, "end_line": 2424, "belongs_to": {"file_name": "caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "E\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n\n    if not data_file.exists():\n        return None\n\n    try:\n        with open(data_file, \"rb\") as stream:\n            data = pickle.load(stream)\n            if not isinstance(data, LinterStats):\n                warnings.warn(\n                    \"You're using an old pylint cache with invalid data following \"\n                    f\"an upgrade, please delete '{data_file}'.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                raise TypeError\n            return data\n    except Exception:  # pylint: disable=broad-except\n        # There's an issue with the cache but we just continue as if it isn't there\n        return None\n\n\ndef save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n        pylint_home.mkdir(parents=True, exist_ok=True)\n    except OSError:  # pragma: no cover\n        print(f\"Unable to create directory {pylint_home}\", file=sys.stderr)\n    data_file = _get_pdata_path(base, 1)\n    try:\n        with open(data_file, \"wb\") as stream:\n            pickle.dump(results, stream)\n    except OSError as ex:  # pragma: no cover\n        print(f\"Unable to create file {data_file}: {ex}\", file=sys.stderr)\n"}, {"start_line": 0, "end_line": 1071, "belongs_to": {"file_name": "clear_lru_cache.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nfrom pylint.checkers.typecheck import _similar_names\nfrom pylint.checkers.utils import (\n    class_is_abstract,\n    in_for_else_branch,\n    infer_all,\n    is_overload_stub,\n    overridden_method,\n    safe_infer,\n    unimplemented_abstract_methods,\n)\n\nif TYPE_CHECKING:\n    from functools import _lru_cache_wrapper\n\n\ndef clear_lru_caches() -> None:\n    \"\"\"Clear caches holding references to AST nodes.\"\"\"\n    caches_holding_node_references: list[_lru_cache_wrapper[Any]] = [\n        class_is_abstract,\n        in_for_else_branch,\n        infer_all,\n        is_overload_stub,\n        overridden_method,\n        unimplemented_abstract_methods,\n        safe_infer,\n        _similar_names,\n    ]\n    for lru in caches_holding_node_references:\n        lru.cache_clear()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# Pytest fixtures work like this by design\n# pylint: disable=redefined-outer-name\n\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nfrom pylint.constants import PYLINT_HOME\nfrom pylint.lint.caching import _get_pdata_path, load_results, save_results\nfrom pylint.utils import LinterStats\nfrom pylint.utils.linterstats import BadNames\n\nPYLINT_HOME_PATH = Path(PYLINT_HOME)\n\n\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,expected\",\n    [\n        [\"\", 1, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"_1.stats\"],\n        [\"\", 2, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"_2.stats\"],\n        [\"a/path\", 42, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"a_path_42.stats\"],\n    ],\n)\ndef test__get_pdata_path(\n    path: str, recur: int, pylint_home: Path, expected: Path\n) -> None:\n    assert _get_pdata_path(Path(path), recur, pylint_home) == expected\n\n\n@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Path type of *nix\")\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,expected\",\n    [\n        [\n            \"/workspace/MyDir/test.py\",\n            1,\n            Path(\"/root/.cache/pylint\"),\n            Path(\"/root/.cache/pylint\") / \"__workspace_MyDir_test.py_1.stats\",\n        ],\n        [\n            \"/workspace/MyDir/test.py\",\n            1,\n            Path(\"//host/computer/.cache\"),\n            Path(\"//host/computer/.cache\") / \"__workspace_MyDir_test.py_1.stats\",\n        ],\n    ],\n)\ndef test__get_pdata_path_nix(\n    path: str, recur: int, pylint_home: Path, expected: Path\n) -> None:\n    \"\"\"test__get_pdata_path but specifically for *nix system paths.\"\"\"\n    assert _get_pdata_path(Path(path), recur, pylint_home) == expected\n\n\n@pytest.mark.skipif(sys.platform != \"win32\", reason=\"Path type of windows\")\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,exp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "enerate events to astroid checkers\n        walker.walk(node)\n        return True\n\n    def open(self) -> None:\n        \"\"\"Initialize counters.\"\"\"\n        MANAGER.always_load_extensions = self.config.unsafe_load_any_extension\n        MANAGER.max_inferable_values = self.config.limit_inference_results\n        MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)\n        MANAGER.module_denylist.update(self.config.ignored_modules)\n        MANAGER.prefer_stubs = self.config.prefer_stubs\n        if self.config.extension_pkg_whitelist:\n            MANAGER.extension_package_whitelist.update(\n                self.config.extension_pkg_whitelist\n            )\n        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n        # Display whatever messages are left on the reporter.\n        self.reporter.display_messages(report_nodes.Section())\n        if not self.file_state._is_base_filestate:\n            # load previous results if any\n            previous_stats = load_results(self.file_state.base_name)\n            self.reporter.on_close(self.stats, previous_stats)\n            if self.config.reports:\n                sect = self.make_reports(self.stats, previous_stats)\n            else:\n                sect = report_nodes.Section()\n\n            if self.config.reports:\n                self.reporter.display_reports(sect)\n\n            score_value = self._report_evaluation(verbose)\n            # save results if persistent run\n            if self.config.persistent:\n                save_results(self.stats, self.file_state.base_name)\n        else:\n            self.reporter.on_close(self.stats, LinterStats())\n            score_value = None\n        return score_value\n\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evalu"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}], "retrieved_count": 10, "cost_time": 1.2345852851867676}
{"question": "Where does the message reporting flow from checker detection to final output generation?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's message reporting flow follows a structured process from checker detection to final output generation: 1) Issue detection - checkers detect violations and potential issues during AST analysis, 2) Message creation - checkers create Message objects using the add_message() method with detailed information, 3) Message collection - messages are collected by the PyLinter and stored in the message system, 4) Message filtering - messages are filtered based on configuration settings (severity, confidence, etc.), 5) Message enrichment - additional context information is added to messages (location, module, etc.), 6) Message aggregation - messages are grouped and organized for reporting, 7) Reporter selection - the appropriate reporter is selected based on configuration, 8) Message formatting - messages are formatted according to the reporter's output format, 9) Report generation - any additional reports are generated based on collected messages and statistics, 10) Final output - formatted messages and reports are displayed or written to files. This flow ensures that all detected issues are properly captured, processed, and presented to users in a consistent and useful format.", "score": null, "retrieved_content": [{"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "elf.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n                    msg += f\" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})\"\n\n            if verbose:\n                checked_files_count = self.stats.node_count[\"module\"]\n                unchecked_files_count = self.stats.undocumented[\"module\"]\n                checked_files = \", \".join(self.stats.modules_names)\n                msg += (\n                    f\"\\nChecked {checked_files_count} files/modules ({checked_files}),\"\n                    f\" skipped {unchecked_files_count} files/modules\"\n                )\n\n        if self.config.score:\n            sect = report_nodes.EvaluationSection(msg)\n            self.reporter.display_reports(sect)\n        return note\n\n    def _add_one_message(\n        self,\n        message_definition: MessageDefinition,\n        line: int | None,\n        node: nodes.NodeNG | None,\n        args: Any | None,\n        confidence: interfaces.Confidence | None,\n        col_offset: int | None,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        \"\"\"After various checks have passed a single Message is\n        passed to the reporter and added to stats.\n        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line = node.fromlineno\n              "}, {"start_line": 1000, "end_line": 2321, "belongs_to": {"file_name": "reporter_for_tests.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ppend messages to the list of messages of the reporter.\"\"\"\n        self.messages.append(msg)\n\n    def finalize(self) -> str:\n        \"\"\"Format and print messages in the context of the path.\"\"\"\n        messages: list[str] = []\n        for msg in self.messages:\n            obj = \"\"\n            if msg.obj:\n                obj = f\":{msg.obj}\"\n            messages.append(f\"{msg.msg_id[0]}:{msg.line:>3}{obj}: {msg.msg}\")\n\n        messages.sort()\n        for message in messages:\n            print(message, file=self.out)\n\n        result = self.out.getvalue()\n        self.reset()\n        return result\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        pass\n\n    # pylint: enable=unused-argument\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts.\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass FunctionalTestReporter(BaseReporter):\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts and don't call self._display().\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "module:\n            result += f\"This checker is provided by ``{module}``.\\n\"\n        result += f\"Verbatim name of the checker is ``{self.name}``.\\n\\n\"\n        if doc:\n            # Provide anchor to link against\n            result += get_rst_title(f\"{checker_title} Documentation\", \"^\")\n            result += f\"{cleandoc(doc)}\\n\\n\"\n        # options might be an empty generator and not be False when cast to boolean\n        options_list = list(options)\n        if options_list:\n            if show_options:\n                result += get_rst_title(f\"{checker_title} Options\", \"^\")\n                result += f\"{get_rst_section(None, options_list)}\\n\"\n            else:\n                result += f\"See also :ref:`{self.name} checker's options' documentation <{self.name}-options>`\\n\\n\"\n        if msgs:\n            result += get_rst_title(f\"{checker_title} Messages\", \"^\")\n            for msgid, msg in sorted(\n                msgs.items(), key=lambda kv: (_MSG_ORDER.index(kv[0][0]), kv[1])\n            ):\n                msg_def = self.create_message_definition_from_tuple(msgid, msg)\n                result += f\"{msg_def.format_help(checkerref=False)}\\n\"\n            result += \"\\n\"\n        if reports:\n            result += get_rst_title(f\"{checker_title} Reports\", \"^\")\n            for report in reports:\n                result += f\":{report[0]}: {report[1]}\\n\"\n            result += \"\\n\"\n        result += \"\\n\"\n        return result\n\n    def add_message(\n        self,\n        msgid: str,\n        line: int | None = None,\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.linter.add_message(\n            msgid, line, node, args, confidence, col_offset, end_lineno, end_col_offset\n        )\n\n    def check_consistency(self) -> None:\n        \"\"\"Check the consistency of msgid.\n\n        m"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "se_output_files = stack.pop_all().close\n\n        if len(sub_reporters) > 1 or output_files:\n            self.set_reporter(\n                reporters.MultiReporter(\n                    sub_reporters,\n                    close_output_files,\n                )\n            )\n        else:\n            self.set_reporter(sub_reporters[0])\n\n    def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:\n        name = reporter_name.lower()\n        if name in self._reporters:\n            return self._reporters[name]()\n\n        try:\n            reporter_class = _load_reporter_by_class(reporter_name)\n        except (ImportError, AttributeError, AssertionError) as e:\n            raise exceptions.InvalidReporterError(name) from e\n\n        return reporter_class()\n\n    def set_reporter(\n        self, reporter: reporters.BaseReporter | reporters.MultiReporter\n    ) -> None:\n        \"\"\"Set the reporter used to display messages and reports.\"\"\"\n        self.reporter = reporter\n        reporter.linter = self\n\n    def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -> None:\n        \"\"\"Registers a reporter class on the _reporters attribute.\"\"\"\n        self._reporters[reporter_class.name] = reporter_class\n\n    def report_order(self) -> list[BaseChecker]:\n        reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n        try:\n            # Remove the current reporter and add it\n            # at the end of the list.\n            reports.pop(reports.index(self))\n        except ValueError:\n            pass\n        else:\n            reports.append(self)\n        return reports\n\n    # checkers manipulation methods ############################################\n\n    def register_checker(self, checker: checkers.BaseChecker) -> None:\n        \"\"\"This method auto registers the checker.\"\"\"\n        self._checkers[checker.name].append(checker)\n        for r_id, r_title, r_cb in checker.reports:\n            self.register_report(r_id, r_title, r_cb,"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "unittest_reporting.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "--------\\n\"\n        \"\\n\"\n        \"+-----------+-------+---------+-----------+\\n\"\n        \"|type       |number |previous |difference |\\n\"\n        \"+===========+=======+=========+===========+\\n\"\n        \"|convention |2      |NC       |NC         |\\n\"\n        \"+-----------+-------+---------+-----------+\\n\"\n        \"|refactor   |0      |NC       |NC         |\\n\"\n        \"+-----------+-------+---------+-----------+\\n\"\n        \"|warning    |0      |NC       |NC         |\\n\"\n        \"+-----------+-------+---------+-----------+\\n\"\n        \"|error      |0      |NC       |NC         |\\n\"\n        \"+-----------+-------+---------+-----------+\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"Messages\\n\"\n        \"--------\\n\"\n        \"\\n\"\n        \"+-------------------------+------------+\\n\"\n        \"|message id               |occurrences |\\n\"\n        \"+=========================+============+\\n\"\n        \"|missing-module-docstring |1           |\\n\"\n        \"+-------------------------+------------+\\n\"\n        \"|line-too-long            |1           |\\n\"\n        \"+-------------------------+------------+\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"-----------------------------------\\n\"\n        \"Your code has been rated at 0.00/10\\n\"\n        \"\\n\"\n        \"direct output\\n\"\n    )\n\n\ndef test_multi_reporter_independant_messages() -> None:\n    \"\"\"Messages should not be modified by multiple reporters.\"\"\"\n    check_message = \"Not modified\"\n\n    class ReporterModify(BaseReporter):\n        def handle_message(self, msg: Message) -> None:\n            msg.msg = \"Modified message\"\n\n        def writeln(self, string: str = \"\") -> None:\n            pass\n\n        def _display(self, layout: Section) -> None:\n            pass\n\n    class ReporterCheck(BaseReporter):\n        def handle_message(self, msg: Message) -> None:\n            assert (\n                msg.msg == check_message\n            ), \"Message object should not be changed by other reporters.\"\n\n        def writeln(self, stri"}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        node: nodes.NodeNG | None,\n        args: Any | None,\n        confidence: interfaces.Confidence | None,\n        col_offset: int | None,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        \"\"\"After various checks have passed a single Message is\n        passed to the reporter and added to stats.\n        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line = node.fromlineno\n                if not col_offset:\n                    col_offset = node.col_offset\n                if not end_lineno:\n                    end_lineno = node.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.end_col_offset\n\n        # should this message be displayed\n        if not self.is_message_enabled(message_definition.msgid, line, confidence):\n            self.file_state.handle_ignored_message(\n                self._get_message_state_scope(\n                    message_definition.msgid, line, confidence\n                ),\n                message_definition.msgid,\n                line,\n            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n        self.stats.increase_single_module_message_count(self.current_name, msg_cat, 1)\n        try:\n            self.stats.by_msg"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " ):\n                msg_def = self.create_message_definition_from_tuple(msgid, msg)\n                result += f\"{msg_def.format_help(checkerref=False)}\\n\"\n            result += \"\\n\"\n        if reports:\n            result += get_rst_title(f\"{checker_title} Reports\", \"^\")\n            for report in reports:\n                result += f\":{report[0]}: {report[1]}\\n\"\n            result += \"\\n\"\n        result += \"\\n\"\n        return result\n\n    def add_message(\n        self,\n        msgid: str,\n        line: int | None = None,\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.linter.add_message(\n            msgid, line, node, args, confidence, col_offset, end_lineno, end_col_offset\n        )\n\n    def check_consistency(self) -> None:\n        \"\"\"Check the consistency of msgid.\n\n        msg ids for a checker should be a string of len 4, where the two first\n        characters are the checker id and the two last the msg id in this\n        checker.\n\n        :raises InvalidMessageError: If the checker id in the messages are not\n        always the same.\n        \"\"\"\n        checker_id = None\n        existing_ids = []\n        for message in self.messages:\n            # Id's for shared messages such as the 'deprecated-*' messages\n            # can be inconsistent with their checker id.\n            if message.shared:\n                continue\n            if checker_id is not None and checker_id != message.msgid[1:3]:\n                error_msg = \"Inconsistent checker part in message id \"\n                error_msg += f\"'{message.msgid}' (expected 'x{checker_id}xx' \"\n                error_msg += f\"because we already had {existing_ids}).\"\n                raise InvalidMessageError(error_msg)\n            checker_id = message.msgid[1:3]\n            existing_ids.append(message.msgid)\n\n "}, {"start_line": 0, "end_line": 735, "belongs_to": {"file_name": "collecting_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.reporters.base_reporter import BaseReporter\n\nif TYPE_CHECKING:\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass CollectingReporter(BaseReporter):\n    \"\"\"Collects messages.\"\"\"\n\n    name = \"collector\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.messages = []\n\n    def reset(self) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 11000, "end_line": 12985, "belongs_to": {"file_name": "unittest_reporting.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        \"|line-too-long            |1           |\\n\"\n        \"+-------------------------+------------+\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"\\n\"\n        \"-----------------------------------\\n\"\n        \"Your code has been rated at 0.00/10\\n\"\n        \"\\n\"\n        \"direct output\\n\"\n    )\n\n\ndef test_multi_reporter_independant_messages() -> None:\n    \"\"\"Messages should not be modified by multiple reporters.\"\"\"\n    check_message = \"Not modified\"\n\n    class ReporterModify(BaseReporter):\n        def handle_message(self, msg: Message) -> None:\n            msg.msg = \"Modified message\"\n\n        def writeln(self, string: str = \"\") -> None:\n            pass\n\n        def _display(self, layout: Section) -> None:\n            pass\n\n    class ReporterCheck(BaseReporter):\n        def handle_message(self, msg: Message) -> None:\n            assert (\n                msg.msg == check_message\n            ), \"Message object should not be changed by other reporters.\"\n\n        def writeln(self, string: str = \"\") -> None:\n            pass\n\n        def _display(self, layout: Section) -> None:\n            pass\n\n    multi_reporter = MultiReporter([ReporterModify(), ReporterCheck()], lambda: None)\n\n    message = Message(\n        symbol=\"missing-docstring\",\n        msg_id=\"C0123\",\n        location=MessageLocationTuple(\"abspath\", \"path\", \"module\", \"obj\", 1, 2, 1, 3),\n        msg=check_message,\n        confidence=HIGH,\n    )\n\n    multi_reporter.handle_message(message)\n\n    assert (\n        message.msg == check_message\n    ), \"Message object should not be changed by reporters.\"\n\n\ndef test_display_results_is_renamed() -> None:\n    class CustomReporter(TextReporter):\n        def _display(self, layout: Section) -> None:\n            return None\n\n    reporter = CustomReporter()\n    with pytest.raises(AttributeError) as exc:\n        # pylint: disable=no-member\n        reporter.display_results()  # type: ignore[attr-defined]\n    assert \"no attribute 'display_results'\" in str(exc)\n"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "               fail_on_msgs.add(val)\n\n        # For every message in every checker, if cat or msg flagged, enable check\n        for all_checkers in self._checkers.values():\n            for checker in all_checkers:\n                for msg in checker.messages:\n                    if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:\n                        # message id/symbol matched, enable and flag it\n                        self.enable(msg.msgid)\n                        self.fail_on_symbols.append(msg.symbol)\n                    elif msg.msgid[0] in fail_on_cats:\n                        # message starts with a category value, flag (but do not enable) it\n                        self.fail_on_symbols.append(msg.symbol)\n\n    def any_fail_on_issues(self) -> bool:\n        return any(x in self.fail_on_symbols for x in self.stats.by_msg.keys())\n\n    def pass_fail_on_config_to_color_reporter(self) -> None:\n        \"\"\"Pass fail_on symbol configuration to colorized text reporter.\"\"\"\n        if isinstance(self.reporter, ColorizedTextReporter):\n            self.reporter.set_fail_on_symbols(self.fail_on_symbols)\n        elif isinstance(self.reporter, reporters.MultiReporter):\n            for _reporter in self.reporter._sub_reporters:\n                if isinstance(self.reporter, ColorizedTextReporter):\n                    self.reporter.set_fail_on_symbols(self.fail_on_symbols)\n\n    def disable_reporters(self) -> None:\n        \"\"\"Disable all reporters.\"\"\"\n        for _reporters in self._reports.values():\n            for report_id, _, _ in _reporters:\n                self.disable_report(report_id)\n\n    def _parse_error_mode(self) -> None:\n        \"\"\"Parse the current state of the error mode.\n\n        Error mode: enable only errors; no reports, no persistent.\n        \"\"\"\n        if not self._error_mode:\n            return\n\n        self.disable_noerror_messages()\n        self.disable(\"miscellaneous\")\n        self.set_option(\"reports\", False)\n        self.set_option(\"persistent\""}], "retrieved_count": 10, "cost_time": 1.228126049041748}
{"question": "Where does Pylint implement its plugin loading and management system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements its plugin loading and management system in several key locations: 1) PyLinter.load_plugin_modules() method - handles the loading of plugin modules, 2) Plugin registration system - manages the registration of custom checkers and reporters, 3) Configuration integration - integrates plugin options into the configuration system, 4) Dynamic plugin loading - supports loading plugins at runtime based on configuration, 5) Plugin discovery - automatically discovers and loads available plugins, 6) Plugin validation - validates plugin interfaces and compatibility, 7) Plugin lifecycle management - handles plugin initialization and cleanup, 8) Plugin configuration - manages plugin-specific configuration options, 9) Plugin dependency resolution - handles dependencies between plugins, 10) Plugin error handling - manages errors that occur during plugin loading and execution. The system is designed to be extensible and allows third-party developers to create custom checkers and reporters that integrate seamlessly with Pylint's core functionality.", "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "version\":\n            value = str(_format_option_value(optdict, value))\n            result += f\"\\n  Default: ``{value.replace('`` ', '```` ``')}``\\n\"\n    return result\n\n\ndef decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)\n\n\ndef tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\n\n\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (extension in PY_EXTS and base != \"__init__\") or (\n            not extension\n            and os.path.isdir(os.path.join(directory, base))\n            and not filename.startswith(\".\")\n        ):\n            try:\n                module = modutils.load_module_from_file(\n                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n            else:\n                if hasattr(module, \"register\"):\n                    module.register(linter)\n                    imported[base] = 1\n\n\ndef _splitstrip(string: str, sep: str = \",\") -> list[str]:\n    r\"\"\"Return a list of stripped string by splitting the string gi"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me_path)\n\n\ndef test_load_plugin_command_line_with_init_hook_command_line() -> None:\n    dummy_plugin_path = abspath(\n        join(REGRTEST_DATA_DIR, \"dummy_plugin\", \"dummy_plugin.py\")\n    )\n\n    with fake_home() as home_path:\n        copy(dummy_plugin_path, join(home_path, \"copy_dummy.py\"))\n        # construct a basic rc file that just modifies the path\n        assert home_path not in sys.path\n        run = Run(\n            [\n                \"--init-hook\",\n                f'import sys; sys.path.append(r\"{home_path}\")',\n                \"--load-plugins\",\n                \"copy_dummy\",\n                join(REGRTEST_DATA_DIR, \"empty.py\"),\n            ],\n            exit=False,\n        )\n        assert (\n            len(\n                [\n                    ch.name\n                    for ch in run.linter.get_checkers()\n                    if ch.name == \"dummy_plugin\"\n                ]\n            )\n            == 2\n        )\n        assert home_path in sys.path\n\n        # Necessary as the executed init-hook modifies sys.path\n        sys.path.remove(home_path)\n\n\ndef test_load_plugin_config_file() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n    config_path = join(REGRTEST_DATA_DIR, \"dummy_plugin.rc\")\n\n    run = Run(\n        [\"--rcfile\", config_path, join(REGRTEST_DATA_DIR, \"empty.py\")],\n        exit=False,\n    )\n    assert (\n        len([ch.name for ch in run.linter.get_checkers() if ch.name == \"dummy_plugin\"])\n        == 2\n    )\n\n    sys.path.remove(dummy_plugin_path)\n\n\ndef test_load_plugin_configuration() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n\n    run = Run(\n        [\n            \"--load-plugins\",\n            \"dummy_conf_plugin\",\n            \"--ignore\",\n            \"foo,bar\",\n            join(REGRTEST_DATA_DIR, \"empty.py\"),\n        ],\n        exit=False,\n    )\n\n    sys.path.remove(dummy_plugin_path)\n    assert run.linter.config.ig"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "test_self.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "}:\"):\n                # Appending a colon to PYTHONPATH should not break path stripping\n                # https://github.com/pylint-dev/pylint/issues/3636\n                subprocess.check_output(pylint_call, cwd=str(tmp_path))\n\n    @staticmethod\n    def test_import_plugin_from_local_directory_if_pythonpath_cwd(\n        tmp_path: Path,\n    ) -> None:\n        p_plugin = tmp_path / \"plugin.py\"\n        p_plugin.write_text(\"# Some plugin content\")\n        if sys.platform == \"win32\":\n            python_path = \".\"\n        else:\n            python_path = f\"{os.environ.get('PYTHONPATH', '').strip(':')}:.\"\n        with _test_cwd(tmp_path), _test_environ_pythonpath(python_path):\n            args = [sys.executable, \"-m\", \"pylint\", \"--load-plugins\", \"plugin\"]\n            process = subprocess.run(\n                args, cwd=str(tmp_path), stderr=subprocess.PIPE, check=False\n            )\n            assert (\n                \"AttributeError: module 'plugin' has no attribute 'register'\"\n                in process.stderr.decode()\n            )\n\n    def test_allow_import_of_files_found_in_modules_during_parallel_check(\n        self, tmp_path: Path\n    ) -> None:\n        test_directory = tmp_path / \"test_directory\"\n        test_directory.mkdir()\n        spam_module = test_directory / \"spam.py\"\n        spam_module.write_text(\"'Empty'\")\n\n        init_module = test_directory / \"__init__.py\"\n        init_module.write_text(\"'Empty'\")\n\n        # For multiple jobs we could not find the `spam.py` file.\n        with _test_cwd(tmp_path):\n            args = [\n                \"-j2\",\n                \"--disable=missing-docstring, missing-final-newline\",\n                \"test_directory\",\n            ]\n            self._runtest(args, code=0)\n\n        # A single job should be fine as well\n        with _test_cwd(tmp_path):\n            args = [\n                \"-j1\",\n                \"--disable=missing-docstring, missing-final-newline\",\n                \"test_directory\",\n            ]\n            self._run"}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "executed init-hook modifies sys.path\n        sys.path.remove(home_path)\n\n\ndef test_load_plugin_config_file() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n    config_path = join(REGRTEST_DATA_DIR, \"dummy_plugin.rc\")\n\n    run = Run(\n        [\"--rcfile\", config_path, join(REGRTEST_DATA_DIR, \"empty.py\")],\n        exit=False,\n    )\n    assert (\n        len([ch.name for ch in run.linter.get_checkers() if ch.name == \"dummy_plugin\"])\n        == 2\n    )\n\n    sys.path.remove(dummy_plugin_path)\n\n\ndef test_load_plugin_configuration() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n\n    run = Run(\n        [\n            \"--load-plugins\",\n            \"dummy_conf_plugin\",\n            \"--ignore\",\n            \"foo,bar\",\n            join(REGRTEST_DATA_DIR, \"empty.py\"),\n        ],\n        exit=False,\n    )\n\n    sys.path.remove(dummy_plugin_path)\n    assert run.linter.config.ignore == [\"foo\", \"bar\", \"bin\"]\n\n\ndef test_init_hooks_called_before_load_plugins() -> None:\n    with pytest.raises(RuntimeError):\n        Run([\"--load-plugins\", \"unexistant\", \"--init-hook\", \"raise RuntimeError\"])\n    with pytest.raises(RuntimeError):\n        Run([\"--init-hook\", \"raise RuntimeError\", \"--load-plugins\", \"unexistant\"])\n    with pytest.raises(SystemExit):\n        Run([\"--init-hook\"])\n\n\ndef test_analyze_explicit_script(linter: PyLinter) -> None:\n    linter.set_reporter(testutils.GenericTestReporter())\n    linter.check([os.path.join(DATA_DIR, \"a_script\")])\n    assert len(linter.reporter.messages) == 1\n    assert linter.reporter.messages[0] == Message(\n        msg_id=\"C0301\",\n        symbol=\"line-too-long\",\n        msg=\"Line too long (175/100)\",\n        confidence=interfaces.Confidence(\n            name=\"UNDEFINED\",\n            description=\"Warning without any associated confidence level.\",\n        ),\n        location=MessageLocationTuple(\n            abspath=os.path.join(abspat"}, {"start_line": 4000, "end_line": 5412, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et_checkers():\n        if checker.name == MAIN_CHECKER_NAME:\n            continue\n        module = checker.__module__\n        # Plugins only - skip over core checkers\n        if re.match(\"pylint.checkers\", module):\n            continue\n        # Find any .rst documentation associated with this plugin\n        doc = \"\"\n        doc_file = doc_files.get(module)\n        if doc_file:\n            with open(doc_file, encoding=\"utf-8\") as f:\n                doc = f.read()\n        try:\n            by_checker[checker][\"checker\"] = checker\n            by_checker[checker][\"options\"] += checker._options_and_values()\n            by_checker[checker][\"msgs\"].update(checker.msgs)\n            by_checker[checker][\"reports\"] += checker.reports\n            by_checker[checker][\"doc\"] += doc\n            by_checker[checker][\"module\"] += module\n        except KeyError:\n            by_checker[checker] = _CheckerInfo(\n                checker=checker,\n                options=list(checker._options_and_values()),\n                msgs=dict(checker.msgs),\n                reports=list(checker.reports),\n                doc=doc,\n                module=module,\n            )\n    return by_checker\n\n\ndef setup(app: Sphinx) -> dict[str, str | bool]:\n    app.connect(\"builder-inited\", builder_inited)\n    return {\"version\": sphinx.__display_version__, \"parallel_read_safe\": True}\n\n\nif __name__ == \"__main__\":\n    builder_inited(None)\n"}], "retrieved_count": 10, "cost_time": 1.2201228141784668}
{"question": "Where in Pylint's codebase is the AST parsing and transformation logic implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The AST parsing and transformation logic in Pylint's codebase is primarily implemented in the astroid library, which Pylint uses as its core parsing engine. Within Pylint itself, the integration with astroid is handled in several locations: 1) PyLinter.get_ast() method - coordinates the parsing of source files using astroid, 2) ASTWalker class - manages the traversal of parsed ASTs, 3) Checker visit/leave methods - implement the analysis logic on AST nodes, 4) Astroid integration utilities - helper functions for working with astroid nodes, 5) Type inference integration - uses astroid's type inference capabilities, 6) Import resolution - leverages astroid's import resolution system, 7) Error handling - manages astroid parsing errors and exceptions, 8) AST caching - manages caching of parsed AST representations, 9) Node type handling - provides utilities for working with different AST node types, 10) Context management - manages AST context information for analysis. The actual parsing and transformation logic is implemented in the astroid library, while Pylint provides the framework for using these capabilities in its analysis pipeline.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dules\n                ]\n            ).keys()\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        progress_reporter = ProgressReporter(self.verbose)\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets up the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n      "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n                ast_per_fileitem[fileitem] = self.get_ast(\n                    fileitem.filepath, fileitem.name, data\n                )\n            except astroid.AstroidBuildingError as ex:\n                template_path = prepare_crash_report(\n                    ex, fileitem.filepath, self.crash_file_path\n                )\n                msg = get_fatal_error_message(fileitem.filepath, template_path)\n                self.add_message(\n                    \"astroid-error\",\n                    args=(fileitem.filepath, msg),\n                    confidence=HIGH,\n                )\n\n        return ast_per_fileitem\n\n    def check_single_file_item(self, file: FileItem) -> None:\n        \"\"\"Check single file item.\n\n        The arguments are the same that are documented in _check_files\n\n        initialize() should be called before calling this method\n        \"\"\"\n        with self._astroid_module_checker() as check_astroid_module:\n            self._check_file(self.get_ast, check_astroid_module, file)\n\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Visitor doing some post-processing on the astroid tree.\n\nTry to resolve definitions (namespace) dictionary, relationship...\n\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport os\nimport traceback\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Callable, Sequence\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import constants\nfrom pylint.checkers.utils import safe_infer\nfrom pylint.pyreverse import utils\n\n_WrapperFuncT = Callable[\n    [Callable[[str], nodes.Module], str, bool], nodes.Module | None\n]\n\n\ndef _astroid_wrapper(\n    func: Callable[[str], nodes.Module],\n    modname: str,\n    verbose: bool = False,\n) -> nodes.Module | None:\n    if verbose:\n        print(f\"parsing {modname}...\")\n    try:\n        return func(modname)\n    except astroid.exceptions.AstroidBuildingError as exc:\n        print(exc)\n    except Exception:  # pylint: disable=broad-except\n        traceback.print_exc()\n    return None\n\n\nclass IdGeneratorMixIn:\n    \"\"\"Mixin adding the ability to generate integer uid.\"\"\"\n\n    def __init__(self, start_value: int = 0) -> None:\n        self.id_count = start_value\n\n    def init_counter(self, start_value: int = 0) -> None:\n        \"\"\"Init the id counter.\"\"\"\n        self.id_count = start_value\n\n    def generate_id(self) -> int:\n        \"\"\"Generate a new identifier.\"\"\"\n        self.id_count += 1\n        return self.id_count\n\n\nclass Project:\n    \"\"\"A project handle a set of modules / packages.\"\"\"\n\n    def __init__(self, name: str = \"\"):\n        self.name = name\n        self.uid: int | None = None\n        self.path: str = \"\"\n        self.modules: list[nodes.Module] = []\n        self.locals: dict[str, nodes.Module] = {}\n        self.__getitem__ = self.locals.__getitem__\n        self.__iter__ = se"}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es.Module], bool | None]]:\n        \"\"\"Context manager for checking ASTs.\n\n        The value in the context is callable accepting AST as its only argument.\n        \"\"\"\n        walker = ASTWalker(self)\n        _checkers = self.prepare_checkers()\n        tokencheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseTokenChecker)\n        ]\n        rawcheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)\n        ]\n        for checker in _checkers:\n            checker.open()\n            walker.add_checker(checker)\n\n        yield functools.partial(\n            self.check_astroid_module,\n            walker=walker,\n            tokencheckers=tokencheckers,\n            rawcheckers=rawcheckers,\n        )\n\n        # notify global end\n        self.stats.statement = walker.nbstatements\n        for checker in reversed(_checkers):\n            checker.close()\n\n    def get_ast(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module | None:\n        \"\"\"Return an ast(roid) representation of a module or a string.\n\n        :param filepath: path to checked file.\n        :param str modname: The name of the module to be checked.\n        :param str data: optional contents of the checked file.\n        :returns: the AST\n        :rtype: astroid.nodes.Module\n        :raises AstroidBuildingError: Whenever we encounter an unexpected exception\n        \"\"\"\n        try:\n            if data is None:\n                return MANAGER.ast_from_file(filepath, modname, source=True)\n            return astroid.builder.AstroidBuilder(MANAGER).string_build(\n                data, modname, filepath\n            )\n        except astroid.AstroidSyntaxError as ex:\n            line = getattr(ex.error, \"lineno\", None)\n            if line is None:\n                line = 0\n            self.add_message(\n                \"syntax-error\",\n                line=line,\n                col_offset=getattr(ex.error, \"offset\", None),\n             "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "statements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no activated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     self.current_file = filepath or modname\n        self.stats.init_single_module(modname or \"\")\n\n        # If there is an actual filepath we might need to update the config attribute\n        if filepath:\n            namespace = self._get_namespace_for_file(\n                Path(filepath), self._directory_namespaces\n            )\n            if namespace:\n                self.config = namespace or self._base_config\n\n    def _get_namespace_for_file(\n        self, filepath: Path, namespaces: DirectoryNamespaceDict\n    ) -> argparse.Namespace | None:\n        for directory in namespaces:\n            if Path.is_relative_to(filepath, directory):\n                namespace = self._get_namespace_for_file(\n                    filepath, namespaces[directory][1]\n                )\n                if namespace is None:\n                    return namespaces[directory][0]\n        return None\n\n    @contextlib.contextmanager\n    def _astroid_module_checker(\n        self,\n    ) -> Iterator[Callable[[nodes.Module], bool | None]]:\n        \"\"\"Context manager for checking ASTs.\n\n        The value in the context is callable accepting AST as its only argument.\n        \"\"\"\n        walker = ASTWalker(self)\n        _checkers = self.prepare_checkers()\n        tokencheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseTokenChecker)\n        ]\n        rawcheckers = [\n            c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)\n        ]\n        for checker in _checkers:\n            checker.open()\n            walker.add_checker(checker)\n\n        yield functools.partial(\n            self.check_astroid_module,\n            walker=walker,\n            tokencheckers=tokencheckers,\n            rawcheckers=rawcheckers,\n        )\n\n        # notify global end\n        self.stats.statement = walker.nbstatements\n        for checker in reversed(_checkers):\n            checker.close()\n\n    def get_ast(\n        self, filepath: str, modname: str, data: str | None = None\n    "}], "retrieved_count": 10, "cost_time": 1.2213668823242188}
{"question": "Where does the configuration loading flow from file discovery to checker initialization?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's configuration loading flow follows a structured process from file discovery to checker initialization: 1) Configuration file discovery - Pylint searches for configuration files in the current directory and parent directories, 2) File format detection - the system identifies the format of configuration files (INI, TOML, pyproject.toml), 3) Configuration parsing - configuration files are parsed and converted into internal data structures, 4) Command-line argument processing - command-line arguments are parsed and integrated with file-based configuration, 5) Precedence resolution - the system resolves conflicts between different configuration sources using precedence rules, 6) Option validation - configuration options are validated for correctness and compatibility, 7) Default value application - default values are applied for unspecified options, 8) Checker option integration - checker-specific options are integrated into the overall configuration, 9) Configuration distribution - configuration values are distributed to relevant components, 10) Checker initialization - checkers are initialized with their specific configuration values. This flow ensures that all components have access to the appropriate configuration settings for their operation.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "config_initialization.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Load plugins if specified in the config file\n    if \"load-plugins\" in config_data:\n        linter.load_plugin_modules(utils._splitstrip(config_data[\"load-plugins\"]))\n\n    unrecognized_options_message = None\n    # First we parse any options from a configuration file\n    try:\n        linter._parse_configuration_file(config_args)\n    except _UnrecognizedOptionError as exc:\n        unrecognized_options_message = \", \".join(exc.options)\n\n    # Then, if a custom reporter is provided as argument, it may be overridden\n    # by file parameters, so we re-set it here. We do this before command line\n    # parsing, so it's still overridable by command line options\n    if reporter:\n        linter.set_reporter(reporter)\n\n    # Set the current module to the command line\n    # to allow raising messages on it\n    linter.set_current_module(\"Command line\")\n\n    # Now we parse any options from the command line, so they can override\n    # the configuration file\n    args_list = _order_all_first(args_list, joined=True)\n    parsed_args_list = linter._parse_command_line_configuration(args_list)\n\n    # Remove the positional arguments separator from the list of arguments if it exists\n    try:\n        parsed_args_list.remove(\"--\")\n    except ValueError:\n        pass\n\n    # Check if there are any options that we do not recognize\n    unrecognized_options: list[str] = []\n    for opt in parsed_args_list:\n        if opt.startswith(\"--\"):\n            unrecognized_options.append(opt[2:])\n        elif opt.startswith(\"-\"):\n            unrecognized_options.append(opt[1:])\n    if unrecognized_options:\n        msg = \", \".join(unrecognized_options)\n        try:\n            linter._arg_parser.error(f\"Unrecognized option found: {msg}\")\n        except SystemExit:\n            sys.exit(32)\n\n    # Now that config file and command line options have been loaded\n    # with all disables, it is safe to emit messages\n    if unrecognized_options_message is not None:\n        linter.set_current_module(str(config_file) if c"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "modules:\n            if os.path.isdir(something) and not os.path.isfile(\n                os.path.join(something, \"__init__.py\")\n            ):\n                skip_subtrees: list[str] = []\n                for root, _, files in os.walk(something):\n                    if any(root.startswith(s) for s in skip_subtrees):\n                        # Skip subtree of already discovered package.\n                        continue\n\n                    if _is_ignored_file(\n                        root,\n                        self.config.ignore,\n                        self.config.ignore_patterns,\n                        self.config.ignore_paths,\n                    ):\n                        skip_subtrees.append(root)\n                        continue\n\n                    if \"__init__.py\" in files:\n                        skip_subtrees.append(root)\n                        yield root\n                    else:\n                        yield from (\n                            os.path.join(root, file)\n                            for file in files\n                            if file.endswith((\".py\", \".pyi\"))\n                        )\n            else:\n                yield something\n\n    def check(self, files_or_modules: Sequence[str]) -> None:\n        \"\"\"Main checking entry: check a list of files or modules from their name.\n\n        files_or_modules is either a string or list of strings presenting modules to check.\n        \"\"\"\n        self.initialize()\n        if self.config.recursive:\n            files_or_modules = tuple(self._discover_files(files_or_modules))\n        if self.config.from_stdin:\n            if len(files_or_modules) != 1:\n                raise exceptions.InvalidArgsError(\n                    \"Missing filename required for --from-stdin\"\n                )\n\n        extra_packages_paths = list(\n            dict.fromkeys(\n                [\n                    discover_package_path(file_or_module, self.config.source_roots)\n                    for file_or_module in files_or_mo"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "config_initialization.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "module(\"Command line or configuration file\")\n\n    # We have loaded configuration from config file and command line. Now, we can\n    # load plugin specific configuration.\n    linter.load_plugin_configuration()\n\n    # Now that plugins are loaded, get list of all fail_on messages, and\n    # enable them\n    linter.enable_fail_on_messages()\n\n    # Now that fail_on messages are enabled, pass them to colorized reporter\n    linter.pass_fail_on_config_to_color_reporter()\n\n    linter._parse_error_mode()\n\n    # Link the base Namespace object on the current directory\n    linter._directory_namespaces[Path().resolve()] = (linter.config, {})\n\n    # parsed_args_list should now only be a list of inputs to lint.\n    # All other options have been removed from the list.\n    return list(\n        chain.from_iterable(\n            # NOTE: 'or [arg]' is needed in the case the input file or directory does\n            # not exist and 'glob(arg)' cannot find anything. Without this we would\n            # not be able to output the fatal import error for this module later on,\n            # as it would get silently ignored.\n            glob(arg, recursive=True) or [arg]\n            for arg in parsed_args_list\n        )\n    )\n\n\ndef _order_all_first(config_args: list[str], *, joined: bool) -> list[str]:\n    \"\"\"Reorder config_args such that --enable=all or --disable=all comes first.\n\n    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n    all_action = \"\"\n\n    for i, arg in enumerate(config_args):\n        if joined and arg.startswith((\"--enable=\", \"--disable=\")):\n            value = arg.split(\"=\")[1]\n        elif arg in {\"--enable\", \"--disable\"}:\n            value = config_args[i + 1]\n        else:\n            continue\n\n        if \"all\" not in (msg.strip() for msg in value.split(\",\")):\n            continue\n\n        arg = arg.split(\"=\")["}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r msg in checker.msgs if self.is_message_enabled(msg)}\n            if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):\n                needed_checkers.append(checker)\n        return needed_checkers\n\n    # pylint: disable=unused-argument\n    @staticmethod\n    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n        \"\"\"Returns whether a module should be checked.\n\n        This implementation returns True for all python source files (.py and .pyi),\n        indicating that all files should be linted.\n\n        Subclasses may override this method to indicate that modules satisfying\n        certain conditions should not be linted.\n\n        :param str modname: The name of the module to be checked.\n        :param str path: The full path to the source code of the module.\n        :param bool is_argument: Whether the file is an argument to pylint or not.\n                                 Files which respect this property are always\n                                 checked, since the user requested it explicitly.\n        :returns: True if the module should be checked.\n        \"\"\"\n        if is_argument:\n            return True\n        return path.endswith((\".py\", \".pyi\"))\n\n    # pylint: enable=unused-argument\n\n    def initialize(self) -> None:\n        \"\"\"Initialize linter for linting.\n\n        This method is called before any linting is done.\n        \"\"\"\n        self._ignore_paths = self.config.ignore_paths\n        # initialize msgs_state now that all messages have been registered into\n        # the store\n        for msg in self.msgs_store.messages:\n            if not msg.may_be_emitted(self.config.py_version):\n                self._msgs_state[msg.msgid] = False\n\n    def _discover_files(self, files_or_modules: Sequence[str]) -> Iterator[str]:\n        \"\"\"Discover python modules and packages in sub-directory.\n\n        Returns iterator of paths to discovered modules and packages.\n        \"\"\"\n        for something in files_or_"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                         for file in files\n                            if file.endswith((\".py\", \".pyi\"))\n                        )\n            else:\n                yield something\n\n    def check(self, files_or_modules: Sequence[str]) -> None:\n        \"\"\"Main checking entry: check a list of files or modules from their name.\n\n        files_or_modules is either a string or list of strings presenting modules to check.\n        \"\"\"\n        self.initialize()\n        if self.config.recursive:\n            files_or_modules = tuple(self._discover_files(files_or_modules))\n        if self.config.from_stdin:\n            if len(files_or_modules) != 1:\n                raise exceptions.InvalidArgsError(\n                    \"Missing filename required for --from-stdin\"\n                )\n\n        extra_packages_paths = list(\n            dict.fromkeys(\n                [\n                    discover_package_path(file_or_module, self.config.source_roots)\n                    for file_or_module in files_or_modules\n                ]\n            ).keys()\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        progress_reporter = ProgressReporter(self.verbose)\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets u"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me_path)\n\n\ndef test_load_plugin_command_line_with_init_hook_command_line() -> None:\n    dummy_plugin_path = abspath(\n        join(REGRTEST_DATA_DIR, \"dummy_plugin\", \"dummy_plugin.py\")\n    )\n\n    with fake_home() as home_path:\n        copy(dummy_plugin_path, join(home_path, \"copy_dummy.py\"))\n        # construct a basic rc file that just modifies the path\n        assert home_path not in sys.path\n        run = Run(\n            [\n                \"--init-hook\",\n                f'import sys; sys.path.append(r\"{home_path}\")',\n                \"--load-plugins\",\n                \"copy_dummy\",\n                join(REGRTEST_DATA_DIR, \"empty.py\"),\n            ],\n            exit=False,\n        )\n        assert (\n            len(\n                [\n                    ch.name\n                    for ch in run.linter.get_checkers()\n                    if ch.name == \"dummy_plugin\"\n                ]\n            )\n            == 2\n        )\n        assert home_path in sys.path\n\n        # Necessary as the executed init-hook modifies sys.path\n        sys.path.remove(home_path)\n\n\ndef test_load_plugin_config_file() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n    config_path = join(REGRTEST_DATA_DIR, \"dummy_plugin.rc\")\n\n    run = Run(\n        [\"--rcfile\", config_path, join(REGRTEST_DATA_DIR, \"empty.py\")],\n        exit=False,\n    )\n    assert (\n        len([ch.name for ch in run.linter.get_checkers() if ch.name == \"dummy_plugin\"])\n        == 2\n    )\n\n    sys.path.remove(dummy_plugin_path)\n\n\ndef test_load_plugin_configuration() -> None:\n    dummy_plugin_path = join(REGRTEST_DATA_DIR, \"dummy_plugin\")\n    sys.path.append(dummy_plugin_path)\n\n    run = Run(\n        [\n            \"--load-plugins\",\n            \"dummy_conf_plugin\",\n            \"--ignore\",\n            \"foo,bar\",\n            join(REGRTEST_DATA_DIR, \"empty.py\"),\n        ],\n        exit=False,\n    )\n\n    sys.path.remove(dummy_plugin_path)\n    assert run.linter.config.ig"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_functional_config_loading.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "*.{ext}\")\n    if (str_path := str(path))\n    # The enable/disable all tests are not practical with this framework.\n    # They require manually listing ~400 messages, which will\n    # require constant updates.\n    and \"enable_all\" not in str_path and \"disable_all\" not in str_path\n]\n\n\n@pytest.fixture()\ndef default_configuration(\n    tmp_path: Path, file_to_lint_path: str\n) -> PylintConfiguration:\n    empty_pylintrc = tmp_path / \"pylintrc\"\n    empty_pylintrc.write_text(\"\")\n    runner = run_using_a_configuration_file(str(empty_pylintrc), file_to_lint_path)\n    assert runner.linter.msg_status == 0\n    return runner.linter.config.__dict__\n\n\n@pytest.mark.parametrize(\"configuration_path\", CONFIGURATION_PATHS)\ndef test_functional_config_loading(\n    configuration_path: str,\n    default_configuration: PylintConfiguration,\n    file_to_lint_path: str,\n    capsys: CaptureFixture[str],\n    caplog: LogCaptureFixture,\n) -> None:\n    \"\"\"Functional tests for configurations.\"\"\"\n    # logging is helpful to see what's expected and why. The output of the\n    # program is checked during the test so printing messes with the result.\n    caplog.set_level(logging.INFO)\n    configuration_path = str(FUNCTIONAL_DIR / configuration_path)\n    msg = f\"Wrong result with configuration {configuration_path}\"\n    expected_code, expected_output = get_expected_output(\n        configuration_path, USER_SPECIFIC_PATH\n    )\n    expected_loaded_configuration = get_expected_configuration(\n        configuration_path, default_configuration\n    )\n    runner = None  # The runner can fail to init if conf is bad enough.\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", message=\"The use of 'MASTER'.*\", category=UserWarning\n        )\n        try:\n            runner = run_using_a_configuration_file(\n                configuration_path, file_to_lint_path\n            )\n            assert runner.linter.msg_status == expected_code\n        except SystemExit as e:\n            # Case whe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "magic_value.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    options = (\n        (\n            \"valid-magic-values\",\n            {\n                \"default\": (0, -1, 1, \"\", \"__main__\"),\n                \"type\": \"csv\",\n                \"metavar\": \"<argument names>\",\n                \"help\": \"List of valid magic values that `magic-value-compare` will not detect. \"\n                \"Supports integers, floats, negative numbers, for empty string enter ``''``,\"\n                \" for backslash values just use one backslash e.g \\\\n.\",\n            },\n        ),\n    )\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Initialize checker instance.\"\"\"\n        super().__init__(linter=linter)\n        self.valid_magic_vals: tuple[float | str, ...] = ()\n\n    def open(self) -> None:\n        # Extra manipulation is needed in case of using external configuration like an rcfile\n        if self._magic_vals_ext_configured():\n            self.valid_magic_vals = tuple(\n                self._parse_rcfile_magic_numbers(value)\n                for value in self.linter.config.valid_magic_values\n            )\n        else:\n            self.valid_magic_vals = self.linter.config.valid_magic_values\n\n    def _magic_vals_ext_configured(self) -> bool:\n        return not isinstance(self.linter.config.valid_magic_values, tuple)\n\n    def _check_constants_comparison(self, node: nodes.Compare) -> None:\n        \"\"\"\n        Magic values in any side of the comparison should be avoided,\n        Detects comparisons that `comparison-of-constants` core checker cannot detect.\n        \"\"\"\n        const_operands = []\n        LEFT_OPERAND = 0\n        RIGHT_OPERAND = 1\n\n        left_operand = node.left\n        const_operands.append(isinstance(left_operand, nodes.Const))\n\n        right_operand = node.ops[0][1]\n        const_operands.append(isinstance(right_operand, nodes.Const))\n\n        if all(const_operands):\n            # `comparison-of-constants` avoided\n            return\n\n        operand_value = None\n        if const_operands[LEFT_OPERAND] and self._is_magic_val"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_config.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cted_disabled: set[str] | None = None,\n    expected_jobs: int = 10,\n    expected_reports_truthey: bool = True,\n) -> None:\n    \"\"\"Check that what we initialized the linter with what was expected.\"\"\"\n    if expected_disabled is None:\n        # \"logging-not-lazy\" and \"logging-format-interpolation\"\n        expected_disabled = {\"W1201\", \"W1202\"}\n    for msgid in expected_disabled:\n        assert not runner.linter.is_message_enabled(msgid)\n    assert runner.linter.config.jobs == expected_jobs\n    assert bool(runner.linter.config.reports) == expected_reports_truthey\n\n\ndef test_can_read_toml_env_variable(tmp_path: Path, file_to_lint_path: str) -> None:\n    \"\"\"We can read and open a properly formatted toml file.\"\"\"\n    config_file = tmp_path / \"pyproject.toml\"\n    config_file.write_text(\n        \"\"\"\n[tool.pylint.\"messages control\"]\ndisable = \"logging-not-lazy,logging-format-interpolation\"\njobs = \"10\"\nreports = \"yes\"\n\"\"\"\n    )\n    env_var = \"tmp_path_env\"\n    os.environ[env_var] = str(config_file)\n    runner = run_using_a_configuration_file(f\"${env_var}\", file_to_lint_path)\n    assert runner.linter.msg_status == 0\n    check_configuration_file_reader(runner)\n\n\ndef test_unknown_message_id(capsys: CaptureFixture) -> None:\n    \"\"\"Check that we correctly raise a message on an unknown id.\"\"\"\n    Run([str(EMPTY_MODULE), \"--disable=12345\"], exit=False)\n    output = capsys.readouterr()\n    assert \"Command line:1:0: W0012: Unknown option value for '--disable'\" in output.out\n\n\ndef test_unknown_option_name(capsys: CaptureFixture) -> None:\n    \"\"\"Check that we correctly raise a message on an unknown option.\"\"\"\n    with pytest.raises(SystemExit):\n        Run([str(EMPTY_MODULE), \"--unknown-option=yes\"], exit=False)\n    output = capsys.readouterr()\n    assert \"usage: pylint\" in output.err\n    assert \"Unrecognized option\" in output.err\n\n\ndef test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n    \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n    with py"}], "retrieved_count": 10, "cost_time": 1.2370378971099854}
{"question": "Why does Pylint use incremental analysis for performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint uses incremental analysis for performance optimization to avoid redundant work when only some files have changed: 1) File change detection - Pylint can detect which files have been modified since the last analysis, 2) Selective re-analysis - only changed files and their dependencies need to be re-analyzed, 3) Cached results utilization - unchanged files can use cached analysis results, 4) Dependency tracking - Pylint tracks dependencies between files to determine what needs re-analysis, 5) AST caching - parsed AST representations are reused for unchanged files, 6) Import resolution caching - resolved imports are cached to avoid repeated resolution, 7) Type inference caching - computed type information is reused when possible, 8) Configuration caching - parsed configuration is reused across runs, 9) Plugin state preservation - plugin state can be preserved for unchanged files, 10) Memory efficiency - incremental analysis reduces memory usage by reusing existing data structures. This approach significantly improves performance for repeated analysis runs, especially in large codebases where only a small subset of files changes between runs.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport pickle\nimport sys\nimport warnings\nfrom pathlib import Path\n\nfrom pylint.constants import PYLINT_HOME\nfrom pylint.utils import LinterStats\n\nPYLINT_HOME_AS_PATH = Path(PYLINT_HOME)\n\n\ndef _get_pdata_path(\n    base_name: Path, recurs: int, pylint_home: Path = PYLINT_HOME_AS_PATH\n) -> Path:\n    # We strip all characters that can't be used in a filename. Also strip '/' and\n    # '\\\\' because we want to create a single file, not sub-directories.\n    underscored_name = \"_\".join(\n        str(p.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\"))\n        for p in base_name.parts\n    )\n    return pylint_home / f\"{underscored_name}_{recurs}.stats\"\n\n\ndef load_results(\n    base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n\n    if not data_file.exists():\n        return None\n\n    try:\n        with open(data_file, \"rb\") as stream:\n            data = pickle.load(stream)\n            if not isinstance(data, LinterStats):\n                warnings.warn(\n                    \"You're using an old pylint cache with invalid data following \"\n                    f\"an upgrade, please delete '{data_file}'.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                raise TypeError\n            return data\n    except Exception:  # pylint: disable=broad-except\n        # There's an issue with the cache but we just continue as if it isn't there\n        return None\n\n\ndef save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "file_state.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nfrom collections import defaultdict\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING, Literal\n\nfrom astroid import nodes\n\nfrom pylint.constants import (\n    INCOMPATIBLE_WITH_USELESS_SUPPRESSION,\n    MSG_STATE_SCOPE_MODULE,\n    WarningScope,\n)\n\nif TYPE_CHECKING:\n    from pylint.message import MessageDefinition, MessageDefinitionStore\n\n\nMessageStateDict = dict[str, dict[int, bool]]\n\n\nclass FileState:\n    \"\"\"Hold internal state specific to the currently analyzed file.\"\"\"\n\n    def __init__(\n        self,\n        modname: str,\n        msg_store: MessageDefinitionStore,\n        node: nodes.Module | None = None,\n        *,\n        is_base_filestate: bool = False,\n    ) -> None:\n        self.base_name = modname\n        self._module_msgs_state: MessageStateDict = {}\n        self._raw_module_msgs_state: MessageStateDict = {}\n        self._ignored_msgs: defaultdict[tuple[str, int], set[int]] = (\n            collections.defaultdict(set)\n        )\n        self._suppression_mapping: dict[tuple[str, int], int] = {}\n        self._module = node\n        if node:\n            self._effective_max_line_number = node.tolineno\n        else:\n            self._effective_max_line_number = None\n        self._msgs_store = msg_store\n        self._is_base_filestate = is_base_filestate\n        \"\"\"If this FileState is the base state made during initialization of\n        PyLinter.\n        \"\"\"\n\n    def _set_state_on_block_lines(\n        self,\n        msgs_store: MessageDefinitionStore,\n        node: nodes.NodeNG,\n        msg: MessageDefinition,\n        msg_state: dict[int, bool],\n    ) -> None:\n        \"\"\"Recursively walk (depth first) AST to collect block level options\n        line numbers and se"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "enerate events to astroid checkers\n        walker.walk(node)\n        return True\n\n    def open(self) -> None:\n        \"\"\"Initialize counters.\"\"\"\n        MANAGER.always_load_extensions = self.config.unsafe_load_any_extension\n        MANAGER.max_inferable_values = self.config.limit_inference_results\n        MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)\n        MANAGER.module_denylist.update(self.config.ignored_modules)\n        MANAGER.prefer_stubs = self.config.prefer_stubs\n        if self.config.extension_pkg_whitelist:\n            MANAGER.extension_package_whitelist.update(\n                self.config.extension_pkg_whitelist\n            )\n        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n        # Display whatever messages are left on the reporter.\n        self.reporter.display_messages(report_nodes.Section())\n        if not self.file_state._is_base_filestate:\n            # load previous results if any\n            previous_stats = load_results(self.file_state.base_name)\n            self.reporter.on_close(self.stats, previous_stats)\n            if self.config.reports:\n                sect = self.make_reports(self.stats, previous_stats)\n            else:\n                sect = report_nodes.Section()\n\n            if self.config.reports:\n                self.reporter.display_reports(sect)\n\n            score_value = self._report_evaluation(verbose)\n            # save results if persistent run\n            if self.config.persistent:\n                save_results(self.stats, self.file_state.base_name)\n        else:\n            self.reporter.on_close(self.stats, LinterStats())\n            score_value = None\n        return score_value\n\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evalu"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport functools\nfrom collections import defaultdict\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Any\n\nimport dill\n\nfrom pylint import reporters\nfrom pylint.lint.utils import _augment_sys_path\nfrom pylint.message import Message\nfrom pylint.typing import FileItem\nfrom pylint.utils import LinterStats, merge_stats\n\ntry:\n    import multiprocessing\nexcept ImportError:\n    multiprocessing = None  # type: ignore[assignment]\n\ntry:\n    from concurrent.futures import ProcessPoolExecutor\nexcept ImportError:\n    ProcessPoolExecutor = None  # type: ignore[assignment,misc]\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# PyLinter object used by worker processes when checking files using parallel mode\n# should only be used by the worker processes\n_worker_linter: PyLinter | None = None\n\n\ndef _worker_initialize(\n    linter: bytes, extra_packages_paths: Sequence[str] | None = None\n) -> None:\n    \"\"\"Function called to initialize a worker for a Process within a concurrent Pool.\n\n    :param linter: A linter-class (PyLinter) instance pickled with dill\n    :param extra_packages_paths: Extra entries to be added to `sys.path`\n    \"\"\"\n    global _worker_linter  # pylint: disable=global-statement\n    _worker_linter = dill.loads(linter)\n    assert _worker_linter\n\n    # On the worker process side the messages are just collected and passed back to\n    # parent process as _worker_check_file function's return value\n    _worker_linter.set_reporter(reporters.CollectingReporter())\n    _worker_linter.open()\n\n    # Re-register dynamic plugins, since the pool does not have access to the\n    # astroid module that existed when the linter was pickled.\n    _worker_linter.load_plugin_modules(_worker_"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}], "retrieved_count": 10, "cost_time": 1.2571825981140137}
{"question": "Where does Pylint's checker system flow from checker registration through rule application to violation reporting?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's checker system flow follows a structured process from registration to violation reporting: 1) Checker registration - checkers are registered with the PyLinter during initialization, 2) Configuration integration - checker options are integrated into the configuration system, 3) Message definition registration - checker message definitions are registered with the message system, 4) Checker instantiation - checker instances are created and initialized with the linter, 5) Lifecycle management - checkers' open() methods are called to prepare for analysis, 6) AST traversal coordination - the ASTWalker coordinates traversal and calls checker methods, 7) Rule application - checkers apply their analysis rules by implementing visit/leave methods, 8) Issue detection - checkers detect violations and potential issues during analysis, 9) Message generation - checkers create diagnostic messages using add_message() method, 10) Message collection and reporting - messages are collected, filtered, and formatted by reporters. This flow ensures that checkers are properly integrated into the analysis pipeline and can effectively contribute to the overall code quality assessment.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 4000, "end_line": 5412, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et_checkers():\n        if checker.name == MAIN_CHECKER_NAME:\n            continue\n        module = checker.__module__\n        # Plugins only - skip over core checkers\n        if re.match(\"pylint.checkers\", module):\n            continue\n        # Find any .rst documentation associated with this plugin\n        doc = \"\"\n        doc_file = doc_files.get(module)\n        if doc_file:\n            with open(doc_file, encoding=\"utf-8\") as f:\n                doc = f.read()\n        try:\n            by_checker[checker][\"checker\"] = checker\n            by_checker[checker][\"options\"] += checker._options_and_values()\n            by_checker[checker][\"msgs\"].update(checker.msgs)\n            by_checker[checker][\"reports\"] += checker.reports\n            by_checker[checker][\"doc\"] += doc\n            by_checker[checker][\"module\"] += module\n        except KeyError:\n            by_checker[checker] = _CheckerInfo(\n                checker=checker,\n                options=list(checker._options_and_values()),\n                msgs=dict(checker.msgs),\n                reports=list(checker.reports),\n                doc=doc,\n                module=module,\n            )\n    return by_checker\n\n\ndef setup(app: Sphinx) -> dict[str, str | bool]:\n    app.connect(\"builder-inited\", builder_inited)\n    return {\"version\": sphinx.__display_version__, \"parallel_read_safe\": True}\n\n\nif __name__ == \"__main__\":\n    builder_inited(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}], "retrieved_count": 10, "cost_time": 1.2512705326080322}
{"question": "Where in Pylint's codebase are the checker configuration settings stored?", "answer": null, "relative_code_list": null, "ground_truth": "Checker configuration settings in Pylint's codebase are stored in several locations: 1) Individual checker classes - each checker defines its own options in the options tuple within the checker class, 2) Configuration files - settings are stored in pylintrc, pyproject.toml, or other configuration files, 3) _ArgumentsManager - the central configuration manager stores all parsed configuration values, 4) PyLinter.config - the main linter instance maintains the current configuration state, 5) Checker instances - each checker instance has access to its configuration through self.linter.config, 6) Configuration validation - settings are validated and stored in the configuration system, 7) Default values - default configuration values are defined in checker classes and configuration files, 8) Command-line arguments - settings can be overridden via command-line arguments, 9) Per-directory configurations - different settings can be stored for different directories, 10) Plugin configurations - custom plugins can define and store their own configuration settings. This distributed approach allows for flexible and extensible configuration management.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 749, "belongs_to": {"file_name": "importing_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/importing_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from importlib import import_module\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass ImportingChecker(BaseChecker):\n    options = (\n        (\n            \"settings-module\",\n            {\n                \"default\": \"settings\",\n                \"type\": \"string\",\n                \"metavar\": \"<settings module>\"\n            },\n        ),\n    )\n\n    msgs = {\n        \"E9999\": (\n            \"Importing checker error message\",\n            \"importing-checker-error\",\n            \"Importing checker error message\",\n        ),\n    }\n\n    def open(self) -> None:\n        import_module(self.linter.config.settings_module)\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(ImportingChecker(linter))\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylint_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "().parent.parent.parent\n\"\"\"Base path to the project folder.\"\"\"\n\nPYLINT_USERGUIDE_PATH = PYLINT_BASE_PATH / \"doc\" / \"user_guide\"\n\"\"\"Path to the messages documentation folder.\"\"\"\n\nDYNAMICALLY_DEFINED_OPTIONS: dict[str, dict[str, str]] = {\n    # Option name, key / values we want to modify\n    \"py-version\": {\"default\": \"sys.version_info[:2]\"},\n    \"spelling-dict\": {\n        \"choices\": \"Values from 'enchant.Broker().list_dicts()' depending on your local enchant installation\",\n        \"help\": \"Spelling dictionary name. Available dictionaries depends on your local enchant installation\",\n    },\n}\n\n\ndef _register_all_checkers_and_extensions(linter: PyLinter) -> None:\n    \"\"\"Registers all checkers and extensions found in the default folders.\"\"\"\n    initialize_checkers(linter)\n    initialize_extensions(linter)\n\n\ndef _get_all_options(linter: PyLinter) -> OptionsDataDict:\n    \"\"\"Get all options registered to a linter and return the data.\"\"\"\n    all_options: OptionsDataDict = defaultdict(list)\n    for checker in sorted(linter.get_checkers()):\n        for option_name, option_info in checker.options:\n            changes_to_do = DYNAMICALLY_DEFINED_OPTIONS.get(option_name, {})\n            if changes_to_do:\n                for key_to_change, new_value in changes_to_do.items():\n                    print(\n                        f\"Doc value for {option_name!r}['{key_to_change}'] changed to \"\n                        f\"{new_value!r} (instead of {option_info[key_to_change]!r})\"\n                    )\n                    option_info[key_to_change] = new_value\n            all_options[checker.name].append(\n                OptionsData(\n                    option_name,\n                    option_info,\n                    checker,\n                    getmodule(checker).__name__.startswith(\"pylint.extensions.\"),  # type: ignore[union-attr]\n                )\n            )\n\n    return all_options\n\n\ndef _create_checker_section(\n    checker: str, options: list[OptionsData], linter: PyLinter\n) -> str:"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 4000, "end_line": 5412, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et_checkers():\n        if checker.name == MAIN_CHECKER_NAME:\n            continue\n        module = checker.__module__\n        # Plugins only - skip over core checkers\n        if re.match(\"pylint.checkers\", module):\n            continue\n        # Find any .rst documentation associated with this plugin\n        doc = \"\"\n        doc_file = doc_files.get(module)\n        if doc_file:\n            with open(doc_file, encoding=\"utf-8\") as f:\n                doc = f.read()\n        try:\n            by_checker[checker][\"checker\"] = checker\n            by_checker[checker][\"options\"] += checker._options_and_values()\n            by_checker[checker][\"msgs\"].update(checker.msgs)\n            by_checker[checker][\"reports\"] += checker.reports\n            by_checker[checker][\"doc\"] += doc\n            by_checker[checker][\"module\"] += module\n        except KeyError:\n            by_checker[checker] = _CheckerInfo(\n                checker=checker,\n                options=list(checker._options_and_values()),\n                msgs=dict(checker.msgs),\n                reports=list(checker.reports),\n                doc=doc,\n                module=module,\n            )\n    return by_checker\n\n\ndef setup(app: Sphinx) -> dict[str, str | bool]:\n    app.connect(\"builder-inited\", builder_inited)\n    return {\"version\": sphinx.__display_version__, \"parallel_read_safe\": True}\n\n\nif __name__ == \"__main__\":\n    builder_inited(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "docs.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Various helper functions to create the docs of a linter object.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING, Any, TextIO\n\nfrom pylint.constants import MAIN_CHECKER_NAME\nfrom pylint.utils.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\ndef _get_checkers_infos(linter: PyLinter) -> dict[str, dict[str, Any]]:\n    \"\"\"Get info from a checker and handle KeyError.\"\"\"\n    by_checker: dict[str, dict[str, Any]] = {}\n    for checker in linter.get_checkers():\n        name = checker.name\n        if name != MAIN_CHECKER_NAME:\n            try:\n                by_checker[name][\"checker\"] = checker\n                by_checker[name][\"options\"] += checker._options_and_values()\n                by_checker[name][\"msgs\"].update(checker.msgs)\n                by_checker[name][\"reports\"] += checker.reports\n            except KeyError:\n                by_checker[name] = {\n                    \"checker\": checker,\n                    \"options\": list(checker._options_and_values()),\n                    \"msgs\": dict(checker.msgs),\n                    \"reports\": list(checker.reports),\n                }\n    return by_checker\n\n\ndef _get_global_options_documentation(linter: PyLinter) -> str:\n    \"\"\"Get documentation for the main checker.\"\"\"\n    result = get_rst_title(\"Pylint global options and switches\", \"-\")\n    result += \"\"\"\nPylint provides global options and switches.\n\n\"\"\"\n    for checker in linter.get_checkers():\n        if checker.name == MAIN_CHECKER_NAME and checker.options:\n            for section, options in checker._options_by_section():\n                if section is None:\n                    title = \"General options\"\n                else:\n                    tit"}], "retrieved_count": 10, "cost_time": 1.2535603046417236}
{"question": "Where does Pylint's analysis flow from source file parsing through AST traversal to final message generation?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's analysis flow follows a structured pipeline from source file parsing to final message generation: 1) File discovery - Pylint identifies which files to analyze based on patterns and exclusions, 2) Source file parsing - each file is parsed using astroid to generate an enhanced AST representation, 3) Raw and token analysis - raw checkers and token checkers process the file content and token stream, 4) AST traversal - the ASTWalker traverses the AST and calls appropriate methods on registered checkers, 5) Checker execution - individual checkers analyze specific aspects of the code and generate diagnostic messages, 6) Message collection - all messages from checkers are collected and filtered based on configuration, 7) Message processing - messages are formatted and enriched with additional context information, 8) Report generation - any requested reports are generated based on collected messages and statistics, 9) Output formatting - messages and reports are formatted according to the configured reporter, 10) Final output - results are displayed or written to files in the specified format. This flow ensures systematic and comprehensive analysis while maintaining flexibility for different use cases.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "file_state.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport collections\nfrom collections import defaultdict\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING, Literal\n\nfrom astroid import nodes\n\nfrom pylint.constants import (\n    INCOMPATIBLE_WITH_USELESS_SUPPRESSION,\n    MSG_STATE_SCOPE_MODULE,\n    WarningScope,\n)\n\nif TYPE_CHECKING:\n    from pylint.message import MessageDefinition, MessageDefinitionStore\n\n\nMessageStateDict = dict[str, dict[int, bool]]\n\n\nclass FileState:\n    \"\"\"Hold internal state specific to the currently analyzed file.\"\"\"\n\n    def __init__(\n        self,\n        modname: str,\n        msg_store: MessageDefinitionStore,\n        node: nodes.Module | None = None,\n        *,\n        is_base_filestate: bool = False,\n    ) -> None:\n        self.base_name = modname\n        self._module_msgs_state: MessageStateDict = {}\n        self._raw_module_msgs_state: MessageStateDict = {}\n        self._ignored_msgs: defaultdict[tuple[str, int], set[int]] = (\n            collections.defaultdict(set)\n        )\n        self._suppression_mapping: dict[tuple[str, int], int] = {}\n        self._module = node\n        if node:\n            self._effective_max_line_number = node.tolineno\n        else:\n            self._effective_max_line_number = None\n        self._msgs_store = msg_store\n        self._is_base_filestate = is_base_filestate\n        \"\"\"If this FileState is the base state made during initialization of\n        PyLinter.\n        \"\"\"\n\n    def _set_state_on_block_lines(\n        self,\n        msgs_store: MessageDefinitionStore,\n        node: nodes.NodeNG,\n        msg: MessageDefinition,\n        msg_state: dict[int, bool],\n    ) -> None:\n        \"\"\"Recursively walk (depth first) AST to collect block level options\n        line numbers and se"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n                ast_per_fileitem[fileitem] = self.get_ast(\n                    fileitem.filepath, fileitem.name, data\n                )\n            except astroid.AstroidBuildingError as ex:\n                template_path = prepare_crash_report(\n                    ex, fileitem.filepath, self.crash_file_path\n                )\n                msg = get_fatal_error_message(fileitem.filepath, template_path)\n                self.add_message(\n                    \"astroid-error\",\n                    args=(fileitem.filepath, msg),\n                    confidence=HIGH,\n                )\n\n        return ast_per_fileitem\n\n    def check_single_file_item(self, file: FileItem) -> None:\n        \"\"\"Check single file item.\n\n        The arguments are the same that are documented in _check_files\n\n        initialize() should be called before calling this method\n        \"\"\"\n        with self._astroid_module_checker() as check_astroid_module:\n            self._check_file(self.get_ast, check_astroid_module, file)\n\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 8000, "end_line": 9221, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @abc.abstractmethod\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n\n        The module's content is accessible via ``astroid.stream``\n        \"\"\"\n        raise NotImplementedError()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dules\n                ]\n            ).keys()\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        progress_reporter = ProgressReporter(self.verbose)\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets up the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n      "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}], "retrieved_count": 10, "cost_time": 1.2623889446258545}
{"question": "Why does Pylint's plugin system impact memory usage and performance in large codebases?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's plugin system impacts memory usage and performance in large codebases for several reasons: 1) Plugin loading overhead - each plugin must be loaded and initialized, adding startup time and memory usage, 2) Multiple checker instances - each plugin creates checker instances that maintain their own state and data structures, 3) Coordination overhead - the plugin system requires coordination between multiple checkers, adding computational complexity, 4) Memory fragmentation - different plugins may allocate memory in different patterns, leading to fragmentation, 5) Context sharing - plugins need to share context information, which can create memory overhead, 6) Message aggregation - collecting and processing messages from multiple plugins adds processing overhead, 7) Configuration complexity - managing configuration for multiple plugins increases memory usage, 8) Plugin dependencies - some plugins may depend on others, creating additional coordination overhead, 9) State management - each plugin maintains its own state during analysis, multiplying memory usage, 10) Extension loading - dynamic loading of plugins can cause memory spikes and garbage collection pressure. However, this overhead is managed through efficient plugin architecture and configuration options that allow users to disable unnecessary plugins.", "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_baseline_benchmarks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/benchmark", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Profiles basic -jX functionality.\"\"\"\n\n# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=missing-function-docstring\n\nimport os\nimport pprint\nimport time\nfrom unittest.mock import patch\n\nimport pytest\nfrom astroid import nodes\nfrom pytest_benchmark.fixture import BenchmarkFixture\n\nfrom pylint.checkers import BaseRawFileChecker\nfrom pylint.lint import PyLinter, check_parallel\nfrom pylint.testutils import GenericTestReporter as Reporter\nfrom pylint.testutils._run import _Run as Run\nfrom pylint.typing import FileItem\nfrom pylint.utils import register_plugins\n\n\ndef _empty_filepath() -> str:\n    return os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__), \"..\", \"input\", \"benchmark_minimal_file.py\"\n        )\n    )\n\n\nclass SleepingChecker(BaseRawFileChecker):\n    \"\"\"A checker that sleeps, the wall-clock time should reduce as we add workers.\n\n    As we apply a roughly constant amount of \"work\" in this checker any variance is\n    likely to be caused by the pylint system.\n    \"\"\"\n\n    name = \"sleeper\"\n    msgs = {\n        \"R9999\": (\n            \"Test\",\n            \"test-check\",\n            \"Some helpful text.\",\n        )\n    }\n    sleep_duration = 0.5  # the time to pretend we're doing work for\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Sleeps for `sleep_duration` on each call.\n\n        This effectively means each file costs ~`sleep_duration`+framework overhead\n        \"\"\"\n        time.sleep(self.sleep_duration)\n\n\nclass SleepingCheckerLong(BaseRawFileChecker):\n    \"\"\"A checker that sleeps, the wall-clock time should reduce as we add workers.\n\n    As we apply a roughly constant amount of \"work\" in this checker any variance is\n    likely to be caused by the pylint system.\n    \"\"\"\n\n    name = \"long-sleeper\"\n    msgs = {\n        \"R9"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}], "retrieved_count": 10, "cost_time": 1.3256545066833496}
{"question": "Where in Pylint's codebase is the \"visit_functiondef\" method defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"visit_functiondef\" method is defined in individual checker classes throughout Pylint's codebase. Each checker that needs to analyze function definitions implements its own visit_functiondef method. These methods are not defined in a single location but are distributed across various checker classes such as: 1) BasicChecker - for basic function analysis like complexity and docstring checks, 2) FunctionChecker - for function-specific analysis like argument counts and return statements, 3) TypeChecker - for type-related function analysis, 4) VariablesChecker - for variable usage analysis within functions, 5) ClassesChecker - for method analysis within classes, 6) Custom checkers - user-defined checkers that implement their own visit_functiondef methods. The ASTWalker class calls these methods when it encounters FunctionDef nodes during AST traversal, but the actual implementation is provided by each individual checker that registers for function definition analysis.", "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            \"metavar\": \"<y or n>\",\n                \"help\": \"Whether to accept totally missing return \"\n                \"documentation in the docstring of a function that \"\n                \"returns a statement.\",\n            },\n        ),\n        (\n            \"accept-no-yields-doc\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Whether to accept totally missing yields \"\n                \"documentation in the docstring of a generator.\",\n            },\n        ),\n        (\n            \"default-docstring-type\",\n            {\n                \"type\": \"choice\",\n                \"default\": \"default\",\n                \"metavar\": \"<docstring type>\",\n                \"choices\": list(utils.DOCSTRING_TYPES),\n                \"help\": \"If the docstring type cannot be guessed \"\n                \"the specified docstring type will be used.\",\n            },\n        ),\n    )\n\n    constructor_names = {\"__init__\", \"__new__\"}\n    not_needed_param_in_docstring = {\"self\", \"cls\"}\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`\n        \"\"\"\n        if checker_utils.is_overload_stub(node):\n            return\n\n        node_doc = utils.docstringify(\n            node.doc_node, self.linter.config.default_docstring_type\n        )\n\n        # skip functions that match the 'no-docstring-rgx' config option\n        no_docstring_rgx = self.linter.config.no_docstring_rgx\n        if no_docstring_rgx and re.match(no_docstring_rgx, node.name):\n            return\n\n        # skip functions smaller than 'docstring-min-length'\n        if self._is_shorter_than_min_length(node):\n            return\n\n        self.check_functiondef_params(node, node_doc)\n        self.check_functiondef_returns(node, node_doc)\n        self"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ew__\"}\n    not_needed_param_in_docstring = {\"self\", \"cls\"}\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`\n        \"\"\"\n        if checker_utils.is_overload_stub(node):\n            return\n\n        node_doc = utils.docstringify(\n            node.doc_node, self.linter.config.default_docstring_type\n        )\n\n        # skip functions that match the 'no-docstring-rgx' config option\n        no_docstring_rgx = self.linter.config.no_docstring_rgx\n        if no_docstring_rgx and re.match(no_docstring_rgx, node.name):\n            return\n\n        # skip functions smaller than 'docstring-min-length'\n        if self._is_shorter_than_min_length(node):\n            return\n\n        self.check_functiondef_params(node, node_doc)\n        self.check_functiondef_returns(node, node_doc)\n        self.check_functiondef_yields(node, node_doc)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def check_functiondef_params(\n        self, node: nodes.FunctionDef, node_doc: Docstring\n    ) -> None:\n        node_allow_no_param = None\n        if node.name in self.constructor_names:\n            class_node = checker_utils.node_frame_class(node)\n            if class_node is not None:\n                class_doc = utils.docstringify(\n                    class_node.doc_node, self.linter.config.default_docstring_type\n                )\n                self.check_single_constructor_params(class_doc, node_doc, class_node)\n\n                # __init__ or class docstrings can have no parameters documented\n                # as long as the other documents them.\n                node_allow_no_param = (\n                    class_doc.has_params()\n                    or class_doc.params_documented_elsewhere()\n                    or None\n                )\n                class_allow_no_param = (\n            "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nDef) -> None:\n        self._check_nonlocal_and_global(node)\n        self._check_name_used_prior_global(node)\n        if not redefined_by_decorator(\n            node\n        ) and not utils.is_registered_in_singledispatch_function(node):\n            self._check_redefinition(\n                (node.is_method() and \"method\") or \"function\", node\n            )\n        # checks for max returns, branch, return in __init__\n        returns = node.nodes_of_class(\n            nodes.Return, skip_klass=(nodes.FunctionDef, nodes.ClassDef)\n        )\n        if node.is_method() and node.name == \"__init__\":\n            if node.is_generator():\n                self.add_message(\"init-is-generator\", node=node)\n            else:\n                values = [r.value for r in returns]\n                # Are we returning anything but None from constructors\n                if any(v for v in values if not utils.is_none(v)):\n                    self.add_message(\"return-in-init\", node=node)\n        # Check for duplicate names by clustering args with same name for detailed report\n        arg_clusters = {}\n        for arg in node.args.arguments:\n            if arg.name in arg_clusters:\n                self.add_message(\n                    \"duplicate-argument-name\",\n                    node=arg,\n                    args=(arg.name,),\n                    confidence=HIGH,\n                )\n            else:\n                arg_clusters[arg.name] = arg\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_name_used_prior_global(self, node: nodes.FunctionDef) -> None:\n        scope_globals = {\n            name: child\n            for child in node.nodes_of_class(nodes.Global)\n            for name in child.names\n            if child.scope() is node\n        }\n\n        if not scope_globals:\n            return\n\n        for node_name in node.nodes_of_class(nodes.Name):\n            if node_name.scope() is not node:\n                continue\n\n            name = node_name.name\n            corresponding_glo"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".check_functiondef_yields(node, node_doc)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def check_functiondef_params(\n        self, node: nodes.FunctionDef, node_doc: Docstring\n    ) -> None:\n        node_allow_no_param = None\n        if node.name in self.constructor_names:\n            class_node = checker_utils.node_frame_class(node)\n            if class_node is not None:\n                class_doc = utils.docstringify(\n                    class_node.doc_node, self.linter.config.default_docstring_type\n                )\n                self.check_single_constructor_params(class_doc, node_doc, class_node)\n\n                # __init__ or class docstrings can have no parameters documented\n                # as long as the other documents them.\n                node_allow_no_param = (\n                    class_doc.has_params()\n                    or class_doc.params_documented_elsewhere()\n                    or None\n                )\n                class_allow_no_param = (\n                    node_doc.has_params()\n                    or node_doc.params_documented_elsewhere()\n                    or None\n                )\n\n                self.check_arguments_in_docstring(\n                    class_doc, node.args, class_node, class_allow_no_param\n                )\n\n        self.check_arguments_in_docstring(\n            node_doc, node.args, node, node_allow_no_param\n        )\n\n    def check_functiondef_returns(\n        self, node: nodes.FunctionDef, node_doc: Docstring\n    ) -> None:\n        if (not node_doc.supports_yields and node.is_generator()) or node.is_abstract():\n            return\n\n        return_nodes = node.nodes_of_class(astroid.Return)\n        if (node_doc.has_returns() or node_doc.has_rtype()) and not any(\n            utils.returns_something(ret_node) for ret_node in return_nodes\n        ):\n            self.add_message(\"redundant-returns-doc\", node=node, confidence=HIGH)\n\n    def check_functiondef_yields(\n        self, node: nodes.FunctionDef, node_doc: D"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "special_methods_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nvalid-bool-returned\",\n        \"invalid-index-returned\",\n        \"invalid-repr-returned\",\n        \"invalid-str-returned\",\n        \"invalid-bytes-returned\",\n        \"invalid-hash-returned\",\n        \"invalid-length-hint-returned\",\n        \"invalid-format-returned\",\n        \"invalid-getnewargs-returned\",\n        \"invalid-getnewargs-ex-returned\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if not node.is_method():\n            return\n\n        inferred = _safe_infer_call_result(node, node)\n        # Only want to check types that we are able to infer\n        if (\n            inferred\n            and node.name in self._protocol_map\n            and not is_function_body_ellipsis(node)\n        ):\n            self._protocol_map[node.name](node, inferred)\n\n        if node.name in PYMETHODS:\n            self._check_unexpected_method_signature(node)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_unexpected_method_signature(self, node: nodes.FunctionDef) -> None:\n        expected_params = SPECIAL_METHODS_PARAMS[node.name]\n\n        if expected_params is None:\n            # This can support a variable number of parameters.\n            return\n        if not node.args.args and not node.args.vararg:\n            # Method has no parameter, will be caught\n            # by no-method-argument.\n            return\n\n        if decorated_with(node, [\"builtins.staticmethod\"]):\n            # We expect to not take in consideration self.\n            all_args = node.args.args\n        else:\n            all_args = node.args.args[1:]\n        mandatory = len(all_args) - len(node.args.defaults)\n        optional = len(node.args.defaults)\n        current_params = mandatory + optional\n\n        emit = False  # If we don't know we choose a false negative\n        if isinstance(expected_params, tuple):\n            # The expected number of parameters can be any value from this\n            # tuple, although the user should implement the method\n            # to t"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      node=node,\n                args=(my_methods, self.linter.config.max_public_methods),\n            )\n\n        # Stop here if the class is excluded via configuration.\n        if node.type == \"class\" and self._exclude_too_few_public_methods:\n            for ancestor in node.ancestors():\n                if any(\n                    pattern.match(ancestor.qname())\n                    for pattern in self._exclude_too_few_public_methods\n                ):\n                    return\n\n        # Stop here for exception, metaclass, interface classes and other\n        # classes for which we don't need to count the methods.\n        if node.type != \"class\" or _is_exempt_from_public_methods(node):\n            return\n\n        # Does the class contain more than n public methods ?\n        # This checks all the methods defined by ancestors and\n        # by the current class.\n        all_methods = _count_methods_in_class(node)\n        if all_methods < self.linter.config.min_public_methods:\n            self.add_message(\n                \"too-few-public-methods\",\n                node=node,\n                args=(all_methods, self.linter.config.min_public_methods),\n            )\n\n    @only_required_for_messages(\n        \"too-many-return-statements\",\n        \"too-many-branches\",\n        \"too-many-arguments\",\n        \"too-many-locals\",\n        \"too-many-positional-arguments\",\n        \"too-many-statements\",\n        \"keyword-arg-before-vararg\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check function name, docstring, arguments, redefinition,\n        variable names, max locals.\n        \"\"\"\n        # init branch and returns counters\n        self._returns.append(0)\n        # check number of arguments\n        args = node.args.args + node.args.posonlyargs + node.args.kwonlyargs\n        pos_args = node.args.args + node.args.posonlyargs\n        ignored_argument_names = self.linter.config.ignored_argument_names\n        if args is not None:\n            ignore"}, {"start_line": 21000, "end_line": 22739, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".parent.test.op == \"not\"\n                    and isinstance(node.parent.test.operand, nodes.Name)\n                    and node.parent.test.operand.name == node.name\n                ):\n                    return\n\n                # Exempt \"if <func> is not None\" cases\n                # pylint: disable=too-many-boolean-expressions\n                if (\n                    isinstance(node.parent.test, nodes.Compare)\n                    and isinstance(node.parent.test.left, nodes.Name)\n                    and node.parent.test.left.name == node.name\n                    and node.parent.test.ops[0][0] == \"is\"\n                    and isinstance(node.parent.test.ops[0][1], nodes.Const)\n                    and node.parent.test.ops[0][1].value is None\n                ):\n                    return\n\n            # Check if we have forward references for this node.\n            try:\n                redefinition_index = redefinitions.index(node)\n            except ValueError:\n                pass\n            else:\n                for redefinition in redefinitions[:redefinition_index]:\n                    inferred = utils.safe_infer(redefinition)\n                    if (\n                        inferred\n                        and isinstance(inferred, astroid.Instance)\n                        and inferred.qname() == TYPING_FORWARD_REF_QNAME\n                    ):\n                        return\n\n            dummy_variables_rgx = self.linter.config.dummy_variables_rgx\n            if dummy_variables_rgx and dummy_variables_rgx.match(node.name):\n                return\n            self.add_message(\n                \"function-redefined\",\n                node=node,\n                args=(redeftype, defined_self.fromlineno),\n            )\n"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_args_num = 0\n            if ignored_argument_names:\n                ignored_pos_args_num = sum(\n                    1 for arg in pos_args if ignored_argument_names.match(arg.name)\n                )\n                ignored_kwonly_args_num = sum(\n                    1\n                    for arg in node.args.kwonlyargs\n                    if ignored_argument_names.match(arg.name)\n                )\n                ignored_args_num = ignored_pos_args_num + ignored_kwonly_args_num\n\n            argnum = len(args) - ignored_args_num\n            if argnum > self.linter.config.max_args:\n                self.add_message(\n                    \"too-many-arguments\",\n                    node=node,\n                    args=(len(args), self.linter.config.max_args),\n                )\n            pos_args_count = (\n                len(args) - len(node.args.kwonlyargs) - ignored_pos_args_num\n            )\n            if pos_args_count > self.linter.config.max_positional_arguments:\n                self.add_message(\n                    \"too-many-positional-arguments\",\n                    node=node,\n                    args=(pos_args_count, self.linter.config.max_positional_arguments),\n                    confidence=HIGH,\n                )\n        else:\n            ignored_args_num = 0\n        # check number of local variables\n        locnum = len(node.locals) - ignored_args_num\n\n        # decrement number of local variables if '_' is one of them\n        if \"_\" in node.locals:\n            locnum -= 1\n\n        if locnum > self.linter.config.max_locals:\n            self.add_message(\n                \"too-many-locals\",\n                node=node,\n                args=(locnum, self.linter.config.max_locals),\n            )\n        # init new statements counter\n        self._stmts.append(1)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    @only_required_for_messages(\n        \"too-many-return-statements\",\n        \"too-many-branches\",\n        \"too-many-arguments\",\n        \"too-many-locals\",\n "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          node.uid = self.generate_id()\n        # resolve ancestors\n        for baseobj in node.ancestors(recurs=False):\n            specializations = getattr(baseobj, \"specializations\", [])\n            specializations.append(node)\n            baseobj.specializations = specializations\n        # resolve instance attributes\n        node.instance_attrs_type = collections.defaultdict(list)\n        node.aggregations_type = collections.defaultdict(list)\n        node.associations_type = collections.defaultdict(list)\n        for assignattrs in tuple(node.instance_attrs.values()):\n            for assignattr in assignattrs:\n                if not isinstance(assignattr, nodes.Unknown):\n                    self.associations_handler.handle(assignattr, node)\n                    self.handle_assignattr_type(assignattr, node)\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Visit an astroid.Function node.\n\n        * set the locals_type mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n        node.locals_type = collections.defaultdict(list)\n        if self.tag:\n            node.uid = self.generate_id()\n\n    def visit_assignname(self, node: nodes.AssignName) -> None:\n        \"\"\"Visit an astroid.AssignName node.\n\n        handle locals_type\n        \"\"\"\n        # avoid double parsing done by different Linkers.visit\n        # running over the same project:\n        if hasattr(node, \"_handled\"):\n            return\n        node._handled = True\n        if node.name in node.frame():\n            frame = node.frame()\n        else:\n            # the name has been defined as 'global' in the frame and belongs\n            # there.\n            frame = node.root()\n        if not hasattr(frame, \"locals_type\"):\n            # If the frame doesn't have a locals_type yet,\n            # it means it wasn't yet visited. Visit it now\n            # to add what's missing from it.\n            if isinstan"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "okup(name.name)[0] is node:\n                return\n\n        self.add_message(\"unnecessary-lambda\", line=node.fromlineno, node=node)\n\n    @utils.only_required_for_messages(\"dangerous-default-value\")\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check function name, docstring, arguments, redefinition,\n        variable names, max locals.\n        \"\"\"\n        if node.is_method():\n            self.linter.stats.node_count[\"method\"] += 1\n        else:\n            self.linter.stats.node_count[\"function\"] += 1\n        self._check_dangerous_default(node)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_dangerous_default(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check for dangerous default values as arguments.\"\"\"\n\n        def is_iterable(internal_node: nodes.NodeNG) -> bool:\n            return isinstance(internal_node, (nodes.List, nodes.Set, nodes.Dict))\n\n        defaults = (node.args.defaults or []) + (node.args.kw_defaults or [])\n        for default in defaults:\n            if not default:\n                continue\n            try:\n                value = next(default.infer())\n            except astroid.InferenceError:\n                continue\n\n            if (\n                isinstance(value, astroid.Instance)\n                and value.qname() in DEFAULT_ARGUMENT_SYMBOLS\n            ):\n                if value is default:\n                    msg = DEFAULT_ARGUMENT_SYMBOLS[value.qname()]\n                elif isinstance(value, astroid.Instance) or is_iterable(value):\n                    # We are here in the following situation(s):\n                    #   * a dict/set/list/tuple call which wasn't inferred\n                    #     to a syntax node ({}, () etc.). This can happen\n                    #     when the arguments are invalid or unknown to\n                    #     the inference.\n                    #   * a variable from somewhere else, which turns out to be a list\n                    #     or a dict.\n             "}], "retrieved_count": 10, "cost_time": 0.3352012634277344}
{"question": "Where are Pylint's built-in checker implementations located?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's built-in checker implementations are located in the pylint/checkers/ directory. This directory contains several subdirectories and files that organize the different types of checkers: 1) pylint/checkers/base/ - contains basic checkers for fundamental analysis, 2) pylint/checkers/classes/ - contains checkers for class and object-oriented analysis, 3) pylint/checkers/imports/ - contains checkers for import statement analysis, 4) pylint/checkers/strings/ - contains checkers for string formatting and usage, 5) pylint/checkers/typecheck.py - contains type checking functionality, 6) pylint/checkers/variables.py - contains variable usage analysis, 7) pylint/checkers/exceptions.py - contains exception handling analysis, 8) pylint/checkers/format.py - contains code formatting checks, 9) pylint/checkers/misc.py - contains miscellaneous checks, 10) pylint/checkers/similar.py - contains code duplication detection. Each checker file contains one or more checker classes that implement specific analysis logic for different aspects of Python code quality.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "colorized.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 355, "belongs_to": {"file_name": "custom_colors.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/colorized_output", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers.exceptions import ExceptionsChecker\nfrom pylint.checkers.stdlib import StdlibChecker\nfrom pylint.extensions.check_elif import ElseifUsedChecker\n\n\nclass CheckerCollector:\n    def __init__(self):\n        self.checker1 = ExceptionsChecker(None)\n        self.checker2 = ElseifUsedChecker(None)\n        self.checker3 = StdlibChecker(None)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", False)\n        self.set_option(\"score\", False)\n\n    # code checking methods ###################################################\n\n    def get_checkers(self) -> list[BaseChecker]:\n        \"\"\"Return all available checkers as an ordered list.\"\"\"\n        return sorted(c for _checkers in self._checkers.values() for c in _checkers)\n\n    def get_checker_names(self) -> list[str]:\n        \"\"\"Get all the checker names that this linter knows about.\"\"\"\n        return sorted(\n            {\n                checker.name\n                for checker in self.get_checkers()\n                if checker.name != MAIN_CHECKER_NAME\n            }\n        )\n\n    def prepare_checkers(self) -> list[BaseChecker]:\n        \"\"\"Return checkers needed for activated messages and reports.\"\"\"\n        if not self.config.reports:\n            self.disable_reporters()\n        # get needed checkers\n        needed_checkers: list[BaseChecker] = [self]\n        for checker in self.get_checkers()[1:]:\n            messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}\n            if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):\n                needed_checkers.append(checker)\n        return needed_checkers\n\n    # pylint: disable=unused-argument\n    @staticmethod\n    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n        \"\"\"Returns whether a module should be checked.\n\n        This implementation returns True for all python source files (.py and .pyi),\n        indicating that all files should be linted.\n\n        Subclasses may override this method to indicate that modules satisfying\n        certain conditions should not be linted.\n\n        :param str modname: The name of the module to be checked.\n        :param str path: The full path to the source code of the module.\n        :param bool is_argument: Whether the file is an argument to pylint or not.\n                                 Files which respect this property are always\n         "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "version\":\n            value = str(_format_option_value(optdict, value))\n            result += f\"\\n  Default: ``{value.replace('`` ', '```` ``')}``\\n\"\n    return result\n\n\ndef decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)\n\n\ndef tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\n\n\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (extension in PY_EXTS and base != \"__init__\") or (\n            not extension\n            and os.path.isdir(os.path.join(directory, base))\n            and not filename.startswith(\".\")\n        ):\n            try:\n                module = modutils.load_module_from_file(\n                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n            else:\n                if hasattr(module, \"register\"):\n                    module.register(linter)\n                    imported[base] = 1\n\n\ndef _splitstrip(string: str, sep: str = \",\") -> list[str]:\n    r\"\"\"Return a list of stripped string by splitting the string gi"}], "retrieved_count": 10, "cost_time": 0.33957839012145996}
{"question": "Where is the \"add_message\" method defined in the message reporting hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "The \"add_message\" method is defined in the BaseChecker class, which serves as the foundation for all Pylint checkers. This method is inherited by all checker classes that extend BaseChecker. The add_message method is responsible for creating and registering diagnostic messages with the PyLinter instance. It takes parameters such as the message ID, node location, message text, and optional arguments. The method integrates with Pylint's message system to ensure proper formatting, filtering, and reporting of diagnostic messages. Since all checkers inherit from BaseChecker, they all have access to this method for generating diagnostic output. The method is part of the core message reporting infrastructure that allows checkers to communicate their findings to users through the configured reporters.", "score": null, "retrieved_content": [{"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "elf.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n                    msg += f\" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})\"\n\n            if verbose:\n                checked_files_count = self.stats.node_count[\"module\"]\n                unchecked_files_count = self.stats.undocumented[\"module\"]\n                checked_files = \", \".join(self.stats.modules_names)\n                msg += (\n                    f\"\\nChecked {checked_files_count} files/modules ({checked_files}),\"\n                    f\" skipped {unchecked_files_count} files/modules\"\n                )\n\n        if self.config.score:\n            sect = report_nodes.EvaluationSection(msg)\n            self.reporter.display_reports(sect)\n        return note\n\n    def _add_one_message(\n        self,\n        message_definition: MessageDefinition,\n        line: int | None,\n        node: nodes.NodeNG | None,\n        args: Any | None,\n        confidence: interfaces.Confidence | None,\n        col_offset: int | None,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        \"\"\"After various checks have passed a single Message is\n        passed to the reporter and added to stats.\n        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line = node.fromlineno\n              "}, {"start_line": 1000, "end_line": 2692, "belongs_to": {"file_name": "unittest_linter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "deNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"Add a MessageTest to the _messages attribute of the linter class.\"\"\"\n        # If confidence is None we set it to UNDEFINED as well in PyLinter\n        if confidence is None:\n            confidence = UNDEFINED\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line = node.fromlineno\n                if not col_offset:\n                    col_offset = node.col_offset\n                if not end_lineno:\n                    end_lineno = node.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.end_col_offset\n\n        self._messages.append(\n            MessageTest(\n                msgid,\n                line,\n                node,\n                args,\n                confidence,\n                col_offset,\n                end_lineno,\n                end_col_offset,\n            )\n        )\n\n    @staticmethod\n    def is_message_enabled(*unused_args: Any, **unused_kwargs: Any) -> Literal[True]:\n        return True\n"}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        node: nodes.NodeNG | None,\n        args: Any | None,\n        confidence: interfaces.Confidence | None,\n        col_offset: int | None,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        \"\"\"After various checks have passed a single Message is\n        passed to the reporter and added to stats.\n        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line = node.fromlineno\n                if not col_offset:\n                    col_offset = node.col_offset\n                if not end_lineno:\n                    end_lineno = node.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.end_col_offset\n\n        # should this message be displayed\n        if not self.is_message_enabled(message_definition.msgid, line, confidence):\n            self.file_state.handle_ignored_message(\n                self._get_message_state_scope(\n                    message_definition.msgid, line, confidence\n                ),\n                message_definition.msgid,\n                line,\n            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n        self.stats.increase_single_module_message_count(self.current_name, msg_cat, 1)\n        try:\n            self.stats.by_msg"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  if not col_offset:\n                    col_offset = node.col_offset\n                if not end_lineno:\n                    end_lineno = node.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.end_col_offset\n\n        # should this message be displayed\n        if not self.is_message_enabled(message_definition.msgid, line, confidence):\n            self.file_state.handle_ignored_message(\n                self._get_message_state_scope(\n                    message_definition.msgid, line, confidence\n                ),\n                message_definition.msgid,\n                line,\n            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n        self.stats.increase_single_module_message_count(self.current_name, msg_cat, 1)\n        try:\n            self.stats.by_msg[message_definition.symbol] += 1\n        except KeyError:\n            self.stats.by_msg[message_definition.symbol] = 1\n        # Interpolate arguments into message string\n        msg = message_definition.msg\n        if args is not None:\n            msg %= args\n        # get module and object\n        if node is None:\n            module, obj = self.current_name, \"\"\n            abspath = self.current_file\n        else:\n            module, obj = utils.get_module_and_frameid(node)\n            abspath = node.root().file\n        if abspath is not None:\n            path = abspath.replace(self.reporter.path_strip_prefix, \"\", 1)\n        else:\n            path = \"configuration\"\n        # add the message\n        self.reporter.handle_message(\n            Message(\n                message_definition.msgid,\n                message_definition.symbol,\n                MessageLocationTuple(\n                    abspath or \"\",\n                    path,\n                    module or \"\",\n                    o"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[message_definition.symbol] += 1\n        except KeyError:\n            self.stats.by_msg[message_definition.symbol] = 1\n        # Interpolate arguments into message string\n        msg = message_definition.msg\n        if args is not None:\n            msg %= args\n        # get module and object\n        if node is None:\n            module, obj = self.current_name, \"\"\n            abspath = self.current_file\n        else:\n            module, obj = utils.get_module_and_frameid(node)\n            abspath = node.root().file\n        if abspath is not None:\n            path = abspath.replace(self.reporter.path_strip_prefix, \"\", 1)\n        else:\n            path = \"configuration\"\n        # add the message\n        self.reporter.handle_message(\n            Message(\n                message_definition.msgid,\n                message_definition.symbol,\n                MessageLocationTuple(\n                    abspath or \"\",\n                    path,\n                    module or \"\",\n                    obj,\n                    line or 1,\n                    col_offset or 0,\n                    end_lineno,\n                    end_col_offset,\n                ),\n                msg,\n                confidence,\n            )\n        )\n\n    def add_message(\n        self,\n        msgid: str,\n        line: int | None = None,\n        node: nodes.NodeNG | None = None,\n        args: Any | None = None,\n        confidence: interfaces.Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"Adds a message given by ID or name.\n\n        If provided, the message string is expanded using args.\n\n        AST checkers must provide the node argument (but may optionally\n        provide line if the line number is different), raw and token checkers\n        must provide the line argument.\n        \"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        message_def"}, {"start_line": 49000, "end_line": 51000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "bj,\n                    line or 1,\n                    col_offset or 0,\n                    end_lineno,\n                    end_col_offset,\n                ),\n                msg,\n                confidence,\n            )\n        )\n\n    def add_message(\n        self,\n        msgid: str,\n        line: int | None = None,\n        node: nodes.NodeNG | None = None,\n        args: Any | None = None,\n        confidence: interfaces.Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"Adds a message given by ID or name.\n\n        If provided, the message string is expanded using args.\n\n        AST checkers must provide the node argument (but may optionally\n        provide line if the line number is different), raw and token checkers\n        must provide the line argument.\n        \"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        message_definitions = self.msgs_store.get_message_definitions(msgid)\n        for message_definition in message_definitions:\n            self._add_one_message(\n                message_definition,\n                line,\n                node,\n                args,\n                confidence,\n                col_offset,\n                end_lineno,\n                end_col_offset,\n            )\n\n    def add_ignored_message(\n        self,\n        msgid: str,\n        line: int,\n        node: nodes.NodeNG | None = None,\n        confidence: interfaces.Confidence | None = interfaces.UNDEFINED,\n    ) -> None:\n        \"\"\"Prepares a message to be added to the ignored message storage.\n\n        Some checks return early in special cases and never reach add_message(),\n        even though they would normally issue a message.\n        This creates false positives for useless-suppression.\n        This function avoids this by adding those message to the ignored msgs attribute\n        \"\"\"\n        message_definitions = se"}, {"start_line": 1000, "end_line": 2321, "belongs_to": {"file_name": "reporter_for_tests.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ppend messages to the list of messages of the reporter.\"\"\"\n        self.messages.append(msg)\n\n    def finalize(self) -> str:\n        \"\"\"Format and print messages in the context of the path.\"\"\"\n        messages: list[str] = []\n        for msg in self.messages:\n            obj = \"\"\n            if msg.obj:\n                obj = f\":{msg.obj}\"\n            messages.append(f\"{msg.msg_id[0]}:{msg.line:>3}{obj}: {msg.msg}\")\n\n        messages.sort()\n        for message in messages:\n            print(message, file=self.out)\n\n        result = self.out.getvalue()\n        self.reset()\n        return result\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        pass\n\n    # pylint: enable=unused-argument\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts.\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        self.messages = []\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass FunctionalTestReporter(BaseReporter):\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts and don't call self._display().\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n"}, {"start_line": 2000, "end_line": 3771, "belongs_to": {"file_name": "multi_reporter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " __del__(self) -> None:\n        self.close_output_files()\n\n    @property\n    def path_strip_prefix(self) -> str:\n        return self._path_strip_prefix\n\n    @property\n    def linter(self) -> PyLinter | None:\n        return self._linter\n\n    @linter.setter\n    def linter(self, value: PyLinter) -> None:\n        self._linter = value\n        for rep in self._sub_reporters:\n            rep.linter = value\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Handle a new message triggered on the current file.\"\"\"\n        for rep in self._sub_reporters:\n            # We provide a copy so reporters can't modify message for others.\n            rep.handle_message(copy(msg))\n\n    def writeln(self, string: str = \"\") -> None:\n        \"\"\"Write a line in the output buffer.\"\"\"\n        for rep in self._sub_reporters:\n            rep.writeln(string)\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Display results encapsulated in the layout tree.\"\"\"\n        for rep in self._sub_reporters:\n            rep.display_reports(layout)\n\n    def display_messages(self, layout: Section | None) -> None:\n        \"\"\"Hook for displaying the messages of the reporter.\"\"\"\n        for rep in self._sub_reporters:\n            rep.display_messages(layout)\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        \"\"\"Hook called when a module starts to be analysed.\"\"\"\n        for rep in self._sub_reporters:\n            rep.on_set_current_module(module, filepath)\n\n    def on_close(\n        self,\n        stats: LinterStats,\n        previous_stats: LinterStats | None,\n    ) -> None:\n        \"\"\"Hook called when a module finished analyzing.\"\"\"\n        for rep in self._sub_reporters:\n            rep.on_close(stats, previous_stats)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "reporter_for_tests.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom io import StringIO\nfrom os import getcwd, sep\nfrom typing import TYPE_CHECKING\n\nfrom pylint.message import Message\nfrom pylint.reporters import BaseReporter\n\nif TYPE_CHECKING:\n    from pylint.reporters.ureports.nodes import Section\n\n\nclass GenericTestReporter(BaseReporter):\n    \"\"\"Reporter storing plain text messages.\"\"\"\n\n    out: StringIO\n\n    def __init__(  # pylint: disable=super-init-not-called # See https://github.com/pylint-dev/pylint/issues/4941\n        self,\n    ) -> None:\n        self.path_strip_prefix: str = getcwd() + sep\n        self.reset()\n\n    def reset(self) -> None:\n        self.out = StringIO()\n        self.messages: list[Message] = []\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Append messages to the list of messages of the reporter.\"\"\"\n        self.messages.append(msg)\n\n    def finalize(self) -> str:\n        \"\"\"Format and print messages in the context of the path.\"\"\"\n        messages: list[str] = []\n        for msg in self.messages:\n            obj = \"\"\n            if msg.obj:\n                obj = f\":{msg.obj}\"\n            messages.append(f\"{msg.msg_id[0]}:{msg.line:>3}{obj}: {msg.msg}\")\n\n        messages.sort()\n        for message in messages:\n            print(message, file=self.out)\n\n        result = self.out.getvalue()\n        self.reset()\n        return result\n\n    def on_set_current_module(self, module: str, filepath: str | None) -> None:\n        pass\n\n    # pylint: enable=unused-argument\n\n    def display_reports(self, layout: Section) -> None:\n        \"\"\"Ignore layouts.\"\"\"\n\n    def _display(self, layout: Section) -> None:\n        pass\n\n\nclass MinimalTestReporter(BaseReporter):\n    def on_set_current_module(self, module: str, filepath: str | None) -> N"}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ation report.\"\"\"\n        # check with at least a statement (usually 0 when there is a\n        # syntax error preventing pylint from further processing)\n        note = None\n        previous_stats = load_results(self.file_state.base_name)\n        if self.stats.statement == 0:\n            return note\n\n        # get a global note for the code\n        evaluation = self.config.evaluation\n        try:\n            stats_dict = {\n                \"fatal\": self.stats.fatal,\n                \"error\": self.stats.error,\n                \"warning\": self.stats.warning,\n                \"refactor\": self.stats.refactor,\n                \"convention\": self.stats.convention,\n                \"statement\": self.stats.statement,\n                \"info\": self.stats.info,\n            }\n            note = eval(evaluation, {}, stats_dict)  # pylint: disable=eval-used\n        except Exception as ex:  # pylint: disable=broad-except\n            msg = f\"An exception occurred while rating: {ex}\"\n        else:\n            self.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n                    msg += f\" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})\"\n\n            if verbose:\n                checked_files_count = self.stats.node_count[\"module\"]\n                unchecked_files_count = self.stats.undocumented[\"module\"]\n                checked_files = \", \".join(self.stats.modules_names)\n                msg += (\n                    f\"\\nChecked {checked_files_count} files/modules ({checked_files}),\"\n                    f\" skipped {unchecked_files_count} files/modules\"\n                )\n\n        if self.config.score:\n            sect = report_nodes.EvaluationSection(msg)\n            self.reporter.display_reports(sect)\n        return note\n\n    def _add_one_message(\n        self,\n        message_definition: MessageDefinition,\n        line: int | None,"}], "retrieved_count": 10, "cost_time": 0.3540048599243164}
{"question": "Where in Pylint's codebase is the \"BaseChecker\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The \"BaseChecker\" class is defined in the pylint/checkers/base_checker.py file. This file contains the foundational class that all Pylint checkers inherit from. The BaseChecker class provides the essential infrastructure and interface that all checkers must implement, including methods for message creation, configuration management, and lifecycle management. It inherits from _ArgumentsProvider to handle configuration options and provides the add_message method for generating diagnostic messages. The BaseChecker class also defines the basic structure that checkers must follow, including the name, options, msgs, and reports attributes. This central location ensures that all checkers have consistent behavior and interface, making the checker system modular and maintainable.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the BaseChecker class.\"\"\"\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.checkers.typecheck import TypeChecker\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.extensions.broad_try_clause import BroadTryClauseChecker\nfrom pylint.extensions.while_used import WhileChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass OtherBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"basic\"\n    msgs = {\n        \"W0001\": (\n            \"Basic checker has an example.\",\n            \"basic-checker-example\",\n            \"Used nowhere and serves no purpose.\",\n        )\n    }\n\n\nclass MissingFieldsChecker(BaseChecker):\n    name = \"basic\"\n    msgs = {\"W0001\": (\"msg-name\",)}  # type: ignore[dict-item]\n\n\nclass LessBasicChecker(OtherBasicChecker):\n    options = (\n        (\n            \"example-args\",\n            {\n                \"default\": 42,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": \"Example of integer argument for the checker.\",\n            },\n        ),\n    )\n\n\nclass DifferentBasicChecker(BaseChecker):\n    def __init__(self) -> None:\n        super().__init__(PyLinter())\n\n    name = \"a-different-checker\"\n    msgs = {\n        \"W0002\": (\n            \"Blah blah example.\",\n            \"blah-blah-example\",\n            \"I only exist to be different to OtherBasicChecker :(\",\n        )\n    }\n\n\nclass MessageWithOptionsChecker(BaseChecker):\n    name = \"message-with-options-checker\"\n    msgs = {\n        \"W0003\": (\n            \"Just a message with pre-defined options %s()\",\n            \"message-with-options\",\n            \"Message with options dict to test consisten"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "inter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alphabetical order.\n        \"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        if self.name == MAIN_CHECKER_NAME:\n            return False\n        if other.name == MAIN_CHECKER_NAME:\n            return True\n        self_is_builtin = type(self).__module__.startswith(\"pylint.checkers\")\n        if self_is_builtin ^ type(other).__module__.startswith(\"pylint.checkers\"):\n            return not self_is_builtin\n        return self.name > other.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Permit to assert Checkers are equal.\"\"\"\n        if not isinstance(other, BaseChecker):\n            return False\n        return f\"{self.name}{self.msgs}\" == f\"{other.name}{other.msgs}\"\n\n    def __hash__(self) -> int:\n        \"\"\"Make Checker hashable.\"\"\"\n        return hash(f\"{self.name}{self.msgs}\")\n\n    def __repr__(self) -> str:\n        status = \"Checker\" if self.enabled else \"Disabled checker\"\n        msgs = \"', '\".join(self.msgs.keys())\n        return f\"{status"}, {"start_line": 8000, "end_line": 9221, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @abc.abstractmethod\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Process a module.\n\n        The module's content is accessible via ``astroid.stream``\n        \"\"\"\n        raise NotImplementedError()\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   def create_message_definition_from_tuple(\n        self, msgid: str, msg_tuple: MessageDefinitionTuple\n    ) -> MessageDefinition:\n        if isinstance(self, (BaseTokenChecker, BaseRawFileChecker)):\n            default_scope = WarningScope.LINE\n        else:\n            default_scope = WarningScope.NODE\n        options: ExtraMessageOptions = {}\n        if len(msg_tuple) == 4:\n            (msg, symbol, descr, msg_options) = msg_tuple\n            options = ExtraMessageOptions(**msg_options)\n        elif len(msg_tuple) == 3:\n            (msg, symbol, descr) = msg_tuple\n        else:\n            error_msg = \"\"\"Messages should have a msgid, a symbol and a description. Something like this :\n\n\"W1234\": (\n    \"message\",\n    \"message-symbol\",\n    \"Message description with detail.\",\n    ...\n),\n\"\"\"\n            raise InvalidMessageError(error_msg)\n        options.setdefault(\"scope\", default_scope)\n        return MessageDefinition(self, msgid, msg, descr, symbol, **options)\n\n    @property\n    def messages(self) -> list[MessageDefinition]:\n        return [\n            self.create_message_definition_from_tuple(msgid, msg_tuple)\n            for msgid, msg_tuple in sorted(self.msgs.items())\n        ]\n\n    def open(self) -> None:\n        \"\"\"Called before visiting project (i.e. set of modules).\"\"\"\n\n    def close(self) -> None:\n        \"\"\"Called after visiting project (i.e set of modules).\"\"\"\n\n    def get_map_data(self) -> Any:\n        return None\n\n    # pylint: disable-next=unused-argument\n    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -> None:\n        return None\n\n\nclass BaseTokenChecker(BaseChecker):\n    \"\"\"Base class for checkers that want to have access to the token stream.\"\"\"\n\n    @abc.abstractmethod\n    def process_tokens(self, tokens: list[TokenInfo]) -> None:\n        \"\"\"Should be overridden by subclasses.\"\"\"\n        raise NotImplementedError()\n\n\nclass BaseRawFileChecker(BaseChecker):\n    \"\"\"Base class for checkers which need to parse the raw file.\"\"\"\n\n    @"}, {"start_line": 0, "end_line": 588, "belongs_to": {"file_name": "unittest_base.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unittest for the base checker.\"\"\"\n\nimport unittest\n\n\nclass TestNoSix(unittest.TestCase):\n    @unittest.skip(\"too many dependencies need six :(\")\n    def test_no_six(self) -> None:\n        try:\n            has_six = True\n        except ImportError:\n            has_six = False\n\n        self.assertFalse(has_six, \"pylint must be able to run without six\")\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Basic checker for Python code.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport itertools\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING, Literal, cast\n\nimport astroid\nfrom astroid import nodes, objects, util\n\nfrom pylint import utils as lint_utils\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.interfaces import HIGH, INFERENCE, Confidence\nfrom pylint.reporters.ureports import nodes as reporter_nodes\nfrom pylint.utils import LinterStats\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass _BasicChecker(BaseChecker):\n    \"\"\"Permits separating multiple checks with the same checker name into\n    classes/file.\n    \"\"\"\n\n    name = \"basic\"\n\n\nREVERSED_PROTOCOL_METHOD = \"__reversed__\"\nSEQUENCE_PROTOCOL_METHODS = (\"__getitem__\", \"__len__\")\nREVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))\n# A mapping from qname -> symbol, to be used when generating messages\n# about dangerous default values as arguments\nDEFAULT_ARGUMENT_SYMBOLS = dict(\n    zip(\n        [\".\".join([\"builtins\", x]) for x in (\"set\", \"dict\", \"list\")],\n        [\"set()\", \"{}\", \"[]\"],\n    ),\n    **{\n        x: f\"{x}()\"\n        for x in (\n            \"collections.deque\",\n            \"collections.ChainMap\",\n            \"collections.Counter\",\n            \"collections.OrderedDict\",\n            \"collections.defaultdict\",\n            \"collections.UserDict\",\n            \"collections.UserList\",\n        )\n    },\n)\n\n\ndef report_by_type_stats(\n    sect: reporter_nodes.Section,\n    stats: LinterStats,\n    old_stats: LinterStats | None,\n) -> None:\n    \"\"\"Make a report of.\n\n    * percentage of different types documented\n    * percentage of different types with a bad name\n    \"\"\"\n    # percentage of diffe"}, {"start_line": 0, "end_line": 320, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/reporters/ureports", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n__all__ = (\"BaseWriter\",)\n\nfrom pylint.reporters.ureports.base_writer import BaseWriter\n"}, {"start_line": 0, "end_line": 1697, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code # This is similar to the __init__ of .name_checker\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"KNOWN_NAME_TYPES_WITH_STYLE\",\n    \"AnyStyle\",\n    \"CamelCaseStyle\",\n    \"NameChecker\",\n    \"NamingStyle\",\n    \"PascalCaseStyle\",\n    \"SnakeCaseStyle\",\n    \"UpperCaseStyle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.base.basic_checker import BasicChecker\nfrom pylint.checkers.base.basic_error_checker import BasicErrorChecker\nfrom pylint.checkers.base.comparison_checker import ComparisonChecker\nfrom pylint.checkers.base.docstring_checker import DocStringChecker\nfrom pylint.checkers.base.function_checker import FunctionChecker\nfrom pylint.checkers.base.name_checker import (\n    KNOWN_NAME_TYPES_WITH_STYLE,\n    AnyStyle,\n    CamelCaseStyle,\n    NamingStyle,\n    PascalCaseStyle,\n    SnakeCaseStyle,\n    UpperCaseStyle,\n)\nfrom pylint.checkers.base.name_checker.checker import NameChecker\nfrom pylint.checkers.base.pass_checker import PassChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(BasicErrorChecker(linter))\n    linter.register_checker(BasicChecker(linter))\n    linter.register_checker(NameChecker(linter))\n    linter.register_checker(DocStringChecker(linter))\n    linter.register_checker(PassChecker(linter))\n    linter.register_checker(ComparisonChecker(linter))\n    linter.register_checker(FunctionChecker(linter))\n"}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.checkers.classes.class_checker import ClassChecker\nfrom pylint.checkers.classes.special_methods_checker import SpecialMethodsChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ClassChecker(linter))\n    linter.register_checker(SpecialMethodsChecker(linter))\n"}], "retrieved_count": 10, "cost_time": 0.3468022346496582}
{"question": "How does Pylint's design facilitate integration with other development tools?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's design facilitates integration with other development tools through several key features: 1) Multiple output formats - support for text, JSON, XML, and other formats that tools can parse, 2) Structured message format - consistent message structure with location, severity, and confidence information, 3) Exit codes - standardized exit codes that CI/CD systems can use to determine success/failure, 4) Configuration file support - tools can generate or modify configuration files programmatically, 5) API access - programmatic access to Pylint's functionality through Python APIs, 6) Plugin system - tools can extend Pylint's capabilities through custom plugins, 7) Filtering options - tools can filter messages by severity, confidence, or other criteria, 8) Per-directory configuration - different settings for different parts of a codebase, 9) Incremental analysis - support for analyzing only changed files, 10) Message suppression - tools can suppress specific messages or categories. These features make Pylint easily integrable with IDEs, CI/CD pipelines, code review tools, and other development infrastructure.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 315, "belongs_to": {"file_name": "__main__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#!/usr/bin/env python\n\n# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nimport pylint\n\npylint.modify_sys_path()\npylint.run_pylint()\n"}, {"start_line": 0, "end_line": 57, "belongs_to": {"file_name": "good.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/w/wrong-import-order", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\nimport sys\n\nimport pylint\n\nfrom . import utils\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"__version__\",\n    \"modify_sys_path\",\n    \"run_pylint\",\n    \"run_pyreverse\",\n    \"run_symilar\",\n    \"version\",\n]\n\nimport os\nimport sys\nfrom collections.abc import Sequence\nfrom typing import NoReturn\n\nfrom pylint.__pkginfo__ import __version__\n\n# pylint: disable=import-outside-toplevel\n\n\ndef run_pylint(argv: Sequence[str] | None = None) -> None:\n    \"\"\"Run pylint.\n\n    argv can be a sequence of strings normally supplied as arguments on the command line\n    \"\"\"\n    from pylint.lint import Run as PylintRun\n\n    try:\n        PylintRun(argv or sys.argv[1:])\n    except KeyboardInterrupt:\n        sys.exit(1)\n\n\ndef _run_pylint_config(argv: Sequence[str] | None = None) -> None:\n    \"\"\"Run pylint-config.\n\n    argv can be a sequence of strings normally supplied as arguments on the command line\n    \"\"\"\n    from pylint.lint.run import _PylintConfigRun\n\n    _PylintConfigRun(argv or sys.argv[1:])\n\n\ndef run_pyreverse(argv: Sequence[str] | None = None) -> NoReturn:\n    \"\"\"Run pyreverse.\n\n    argv can be a sequence of strings normally supplied as arguments on the command line\n    \"\"\"\n    from pylint.pyreverse.main import Run as PyreverseRun\n\n    sys.exit(PyreverseRun(argv or sys.argv[1:]).run())\n\n\ndef run_symilar(argv: Sequence[str] | None = None) -> NoReturn:\n    \"\"\"Run symilar.\n\n    argv can be a sequence of strings normally supplied as arguments on the command line\n    \"\"\"\n    from pylint.checkers.symilar import Run as SymilarRun\n\n    SymilarRun(argv or sys.argv[1:])\n\n\ndef modify_sys_path() -> None:\n    \"\"\"Modify sys path for execution as Python module.\n\n    Strip out the current working directory from sys.path.\n    Having the working directory in `sys.path` means that `pylint` might\n    inadvertently"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 0, "end_line": 695, "belongs_to": {"file_name": "global_test_linter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom pylint import checkers\nfrom pylint.lint import PyLinter\nfrom pylint.testutils.reporter_for_tests import GenericTestReporter\n\n\ndef create_test_linter() -> PyLinter:\n    test_reporter = GenericTestReporter()\n    linter_ = PyLinter()\n    linter_.set_reporter(test_reporter)\n    linter_.config.persistent = 0\n    checkers.initialize(linter_)\n    return linter_\n\n\n# Can't be renamed to a constant (easily), it breaks countless tests\nlinter = create_test_linter()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}], "retrieved_count": 10, "cost_time": 0.3305056095123291}
{"question": "How does Pylint's architecture support extensibility through plugins?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's architecture supports extensibility through plugins through several key design patterns: 1) Plugin registration system - provides a standardized way to register custom checkers and reporters, 2) Base class inheritance - all plugins inherit from BaseChecker or BaseReporter, ensuring consistent interfaces, 3) Configuration integration - plugin options are automatically integrated into Pylint's configuration system, 4) Message system integration - plugins can define and emit their own diagnostic messages, 5) AST access - plugins have full access to the AST representation for sophisticated analysis, 6) Lifecycle management - plugins can implement open() and close() methods for initialization and cleanup, 7) Dynamic loading - plugins can be loaded at runtime based on configuration, 8) Error isolation - plugin errors are isolated and don't crash the entire system, 9) Documentation generation - plugin options and messages are automatically included in help output, 10) Testing support - plugins can be tested independently using Pylint's testing framework. This architecture allows developers to extend Pylint's capabilities without modifying the core codebase.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "version\":\n            value = str(_format_option_value(optdict, value))\n            result += f\"\\n  Default: ``{value.replace('`` ', '```` ``')}``\\n\"\n    return result\n\n\ndef decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)\n\n\ndef tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\n\n\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (extension in PY_EXTS and base != \"__init__\") or (\n            not extension\n            and os.path.isdir(os.path.join(directory, base))\n            and not filename.startswith(\".\")\n        ):\n            try:\n                module = modutils.load_module_from_file(\n                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n            else:\n                if hasattr(module, \"register\"):\n                    module.register(linter)\n                    imported[base] = 1\n\n\ndef _splitstrip(string: str, sep: str = \",\") -> list[str]:\n    r\"\"\"Return a list of stripped string by splitting the string gi"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Callable\nfrom pathlib import Path\n\nimport pytest\n\nfrom pylint import checkers\nfrom pylint.checkers import BaseChecker\nfrom pylint.lint import PyLinter\nfrom pylint.lint.run import _cpu_count\nfrom pylint.reporters import BaseReporter\nfrom pylint.testutils import MinimalTestReporter\n\nHERE = Path(__file__).parent\n\n\n@pytest.fixture()\ndef tests_directory() -> Path:\n    return HERE\n\n\n@pytest.fixture\ndef linter(\n    checker: type[BaseChecker] | None,\n    register: Callable[[PyLinter], None] | None,\n    enable: str | None,\n    disable: str | None,\n    reporter: type[BaseReporter],\n) -> PyLinter:\n    _linter = PyLinter()\n    _linter.set_reporter(reporter())\n    checkers.initialize(_linter)\n    if register:\n        register(_linter)\n    if checker:\n        _linter.register_checker(checker(_linter))\n    if disable:\n        for msg in disable:\n            _linter.disable(msg)\n    if enable:\n        for msg in enable:\n            _linter.enable(msg)\n    os.environ.pop(\"PYLINTRC\", None)\n    return _linter\n\n\n@pytest.fixture(scope=\"module\")\ndef checker() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef register() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef enable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[MinimalTestReporter]:\n    return MinimalTestReporter\n\n\ndef pytest_addoption(parser: pytest.Parser) -> None:\n    parser.addoption(\n        \"--primer-stdlib\",\n        action=\"store_true\",\n        default=False,\n        help=\"Run primer stdlib tests\",\n    )\n    parser.addoption(\n        \"--minimal-mes"}], "retrieved_count": 10, "cost_time": 0.3391733169555664}
{"question": "How does Pylint ensure backward compatibility when introducing new features?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint ensures backward compatibility when introducing new features through several strategies: 1) Deprecation warnings - old features are marked as deprecated before removal, giving users time to migrate, 2) Version-based feature flags - new features can be enabled/disabled based on Python version compatibility, 3) Configuration migration - automatic migration of old configuration formats to new ones, 4) Message ID preservation - existing message IDs are maintained even when implementation changes, 5) API stability - core APIs are designed to remain stable across versions, 6) Plugin compatibility - plugin interfaces are designed to remain compatible across versions, 7) Default behavior preservation - existing default behaviors are maintained unless explicitly changed, 8) Documentation updates - comprehensive documentation of changes and migration guides, 9) Testing infrastructure - extensive testing ensures existing functionality continues to work, 10) Gradual rollout - new features are introduced gradually with opt-in mechanisms. This approach allows Pylint to evolve while maintaining stability for existing users and integrations.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unittest_reporting.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s new\n    parameters do not break on previous versions.\n    \"\"\"\n    output = StringIO()\n    linter.reporter.out = output\n    linter.config.msg_template = \"{path}:{line}:{categ}:({a_second_new_option:03d})\"\n    linter.open()\n    with pytest.warns(UserWarning) as records:\n        linter.set_current_module(\"my_mod\")\n        assert len(records) == 2\n        assert \"Don't recognize the argument 'categ'\" in records[0].message.args[0]\n    assert (\n        \"Don't recognize the argument 'a_second_new_option'\"\n        in records[1].message.args[0]\n    )\n\n    linter.add_message(\"C0301\", line=1, args=(1, 2))\n    linter.add_message(\n        \"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4)\n    )\n\n    out_lines = output.getvalue().split(\"\\n\")\n    assert out_lines[1] == \"my_mod:1::()\"\n    assert out_lines[2] == \"my_mod:2::()\"\n\n\ndef test_template_option_with_header(linter: PyLinter) -> None:\n    output = StringIO()\n    linter.reporter.out = output\n    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n    linter.open()\n    linter.set_current_module(\"my_mod\")\n\n    linter.add_message(\"C0301\", line=1, args=(1, 2))\n    linter.add_message(\n        \"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4)\n    )\n\n    out_lines = output.getvalue().split(\"\\n\")\n    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n    assert out_lines[2] == '{ \"Category\": \"convention\" }'\n\n\ndef test_parseable_output_deprecated() -> None:\n    with warnings.catch_warnings(record=True) as cm:\n        warnings.simplefilter(\"always\")\n        ParseableTextReporter()\n\n    assert len(cm) == 1\n    assert isinstance(cm[0].message, DeprecationWarning)\n\n\ndef test_parseable_output_regression() -> None:\n    output = StringIO()\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n        linter = PyLinter(reporter=ParseableTextReporter())\n\n    checkers.initialize(linter)\n    linter.config.persistent = 0\n    linter.rep"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "deprecation_actions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=too-many-arguments, redefined-builtin\n\n\"\"\"Deprecated option actions.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport warnings\nfrom collections.abc import Sequence\nfrom typing import Any\n\n\nclass _OldNamesAction(argparse._StoreAction):\n    \"\"\"Store action that also sets the value to old names.\"\"\"\n\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,\n        choices: None = None,\n        required: bool = False,\n        help: str = \"\",\n        metavar: str = \"\",\n        old_names: list[str] | None = None,\n    ) -> None:\n        assert old_names\n        self.old_names = old_names\n        super().__init__(\n            option_strings,\n            dest,\n            1,\n            const,\n            default,\n            type,\n            choices,\n            required,\n            help,\n            metavar,\n        )\n\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str | Sequence[Any] | None,\n        option_string: str | None = None,\n    ) -> None:\n        assert isinstance(values, list)\n        setattr(namespace, self.dest, values[0])\n        for old_name in self.old_names:\n            setattr(namespace, old_name, values[0])\n\n\nclass _NewNamesAction(argparse._StoreAction):\n    \"\"\"Store action that also emits a deprecation warning about a new name.\"\"\"\n\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: None = None,\n        const: None = None,\n        default: None = None,\n        type: None = None,\n        choices: None = None,\n        re"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    {\n                \"type\": \"yn\",\n                \"metavar\": \"<yn>\",\n                \"default\": False,\n                \"help\": \"Discover python modules and packages in the file system subtree.\",\n            },\n        ),\n        (\n            \"py-version\",\n            {\n                \"default\": sys.version_info[:2],\n                \"type\": \"py_version\",\n                \"metavar\": \"<py_version>\",\n                \"help\": (\n                    \"Minimum Python version to use for version dependent checks. \"\n                    \"Will default to the version used to run pylint.\"\n                ),\n            },\n        ),\n        (\n            \"ignored-modules\",\n            {\n                \"default\": (),\n                \"type\": \"csv\",\n                \"metavar\": \"<module names>\",\n                \"help\": \"List of module names for which member attributes \"\n                \"should not be checked and will not be imported \"\n                \"(useful for modules/projects \"\n                \"where namespaces are manipulated during runtime and \"\n                \"thus existing member attributes cannot be \"\n                \"deduced by static analysis). It supports qualified \"\n                \"module names, as well as Unix pattern matching.\",\n            },\n        ),\n        (\n            \"analyse-fallback-blocks\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Analyse import fallback blocks. This can be used to \"\n                \"support both Python 2 and 3 compatible code, which \"\n                \"means that the block might have code that exists \"\n                \"only in one or another interpreter, leading to false \"\n                \"positives when analysed.\",\n            },\n        ),\n        (\n            \"clear-cache-post-run\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Clear in-memo"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             \"where it should appear only once). \"\n                'You can also use \"--disable=all\" to disable everything first '\n                \"and then re-enable specific checks. For example, if you want \"\n                \"to run only the similarities checker, you can use \"\n                '\"--disable=all --enable=similarities\". '\n                \"If you want to run only the classes checker, but have no \"\n                \"Warning level messages displayed, use \"\n                '\"--disable=all --enable=classes --disable=W\".',\n                \"kwargs\": {\"linter\": linter},\n            },\n        ),\n        (\n            \"msg-template\",\n            {\n                \"type\": \"string\",\n                \"default\": \"\",\n                \"metavar\": \"<template>\",\n                \"group\": \"Reports\",\n                \"help\": (\n                    \"Template used to display messages. \"\n                    \"This is a python new-style format string \"\n                    \"used to format the message information. \"\n                    \"See doc for all details.\"\n                ),\n            },\n        ),\n        (\n            \"jobs\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<n-processes>\",\n                \"short\": \"j\",\n                \"default\": 1,\n                \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n                \"auto-detect the number of processors available to use, and will cap \"\n                \"the count on Windows to avoid hangs.\",\n            },\n        ),\n        (\n            \"unsafe-load-any-extension\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"hide\": True,\n                \"help\": (\n                    \"Allow loading of arbitrary C extensions. Extensions\"\n                    \" are imported into the active Python interpreter and\"\n                    \" may run arbitrary code.\"\n                ),\n            },\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_breaking_changes.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"List the breaking changes in configuration files and their solutions.\"\"\"\n\nfrom __future__ import annotations\n\nimport enum\nfrom typing import NamedTuple\n\n\nclass BreakingChange(enum.Enum):\n    MESSAGE_MADE_DISABLED_BY_DEFAULT = \"{symbol} ({msgid}) was disabled by default\"\n    MESSAGE_MADE_ENABLED_BY_DEFAULT = \"{symbol} ({msgid}) was enabled by default\"\n    MESSAGE_MOVED_TO_EXTENSION = \"{symbol} ({msgid}) was moved to {extension}\"\n    EXTENSION_REMOVED = \"{extension} was removed\"\n    # This kind of upgrade is non-breaking but if we want to automatically upgrade it,\n    # then we should use the message store and old_names values instead of duplicating\n    # MESSAGE_RENAMED= \"{symbol} ({msgid}) was renamed\"\n\n\nclass Condition(enum.Enum):\n    MESSAGE_IS_ENABLED = \"{symbol} ({msgid}) is enabled\"\n    MESSAGE_IS_NOT_ENABLED = \"{symbol} ({msgid}) is not enabled\"\n    MESSAGE_IS_DISABLED = \"{symbol} ({msgid}) is disabled\"\n    MESSAGE_IS_NOT_DISABLED = \"{symbol} ({msgid}) is not disabled\"\n    EXTENSION_IS_LOADED = \"{extension} is loaded\"\n    EXTENSION_IS_NOT_LOADED = \"{extension} is not loaded\"\n\n\nclass Information(NamedTuple):\n    msgid_or_symbol: str\n    extension: str | None\n\n\nclass Solution(enum.Enum):\n    ADD_EXTENSION = \"Add {extension} in 'load-plugins' option\"\n    REMOVE_EXTENSION = \"Remove {extension} from the 'load-plugins' option\"\n    ENABLE_MESSAGE_EXPLICITLY = (\n        \"{symbol} ({msgid}) should be added in the 'enable' option\"\n    )\n    ENABLE_MESSAGE_IMPLICITLY = (\n        \"{symbol} ({msgid}) should be removed from the 'disable' option\"\n    )\n    DISABLE_MESSAGE_EXPLICITLY = (\n        \"{symbol} ({msgid}) should be added in the 'disable' option\"\n    )\n    DISABLE_MESSAGE_IMPLICITLY = (\n        \"{symbol} ({msgid}) should be removed from"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unsupported_version.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Checker for features used that are not supported by all python versions\nindicated by the py-version setting.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import (\n    only_required_for_messages,\n    safe_infer,\n    uninferable_final_decorators,\n)\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass UnsupportedVersionChecker(BaseChecker):\n    \"\"\"Checker for features that are not supported by all python versions\n    indicated by the py-version setting.\n    \"\"\"\n\n    name = \"unsupported_version\"\n    msgs = {\n        \"W2601\": (\n            \"F-strings are not supported by all versions included in the py-version setting\",\n            \"using-f-string-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.6 and pylint encounters \"\n            \"an f-string.\",\n        ),\n        \"W2602\": (\n            \"typing.final is not supported by all versions included in the py-version setting\",\n            \"using-final-decorator-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.8 and pylint encounters \"\n            \"a ``typing.final`` decorator.\",\n        ),\n        \"W2603\": (\n            \"Exception groups are not supported by all versions included in the py-version setting\",\n            \"using-exception-groups-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.11 and pylint encounters \"\n            \"``except*`` or `ExceptionGroup``.\",\n        ),\n        \"W2604\": (\n            \"Generic type syntax (PEP 695) is not supported by all versions included in the py-versi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_deleted_message_ids.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom functools import cache\nfrom typing import NamedTuple\n\n\nclass DeletedMessage(NamedTuple):\n    msgid: str\n    symbol: str\n    old_names: list[tuple[str, str]] = []\n\n\nDELETED_MSGID_PREFIXES: list[int] = []\n\nDELETED_MESSAGES_IDS = {\n    # Everything until the next comment is from the PY3K+ checker\n    \"https://github.com/pylint-dev/pylint/pull/4942\": [\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"E1601\", \"print-statement\"),\n        DeletedMessage(\"E1602\", \"parameter-unpacking\"),\n        DeletedMessage(\n            \"E1603\", \"unpacking-in-except\", [(\"W0712\", \"old-unpacking-in-except\")]\n        ),\n        DeletedMessage(\n            \"E1604\", \"old-raise-syntax\", [(\"W0121\", \"old-old-raise-syntax\")]\n        ),\n        DeletedMessage(\"E1605\", \"backtick\", [(\"W0333\", \"old-backtick\")]),\n        DeletedMessage(\"E1609\", \"import-star-module-level\"),\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"W1602\", \"basestring-builtin\"),\n        DeletedMessage(\"W1603\", \"buffer-builtin\"),\n        DeletedMessage(\"W1604\", \"cmp-builtin\"),\n        DeletedMessage(\"W1605\", \"coerce-builtin\"),\n        DeletedMessage(\"W1606\", \"execfile-builtin\"),\n        DeletedMessage(\"W1607\", \"file-builtin\"),\n        DeletedMessage(\"W1608\", \"long-builtin\"),\n        DeletedMessage(\"W1609\", \"raw_input-builtin\"),\n        DeletedMessage(\"W1610\", \"reduce-builtin\"),\n        DeletedMessage(\"W1611\", \"standarderror-builtin\"),\n        DeletedMessage(\"W1612\", \"unicode-builtin\"),\n        DeletedMessage(\"W1613\", \"xrange-builtin\"),\n        DeletedMessage(\"W1614\", \"coerce-method\"),\n        DeletedMessage(\"W1615\", \"delslice-method\"),\n        DeletedMessage(\"W1616\", \"getslice-method\"),\n        DeletedMessage(\"W16"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s, since their idiomatic use is\n        # 'too dynamic' for pylint to grok.\n        (\n            \"ignored-classes\",\n            {\n                \"default\": (\n                    \"optparse.Values\",\n                    \"thread._local\",\n                    \"_thread._local\",\n                    \"argparse.Namespace\",\n                ),\n                \"type\": \"csv\",\n                \"metavar\": \"<members names>\",\n                \"help\": \"List of class names for which member attributes \"\n                \"should not be checked (useful for classes with \"\n                \"dynamically set attributes). This supports \"\n                \"the use of qualified names.\",\n            },\n        ),\n        (\n            \"generated-members\",\n            {\n                \"default\": (),\n                \"type\": \"string\",\n                \"metavar\": \"<members names>\",\n                \"help\": \"List of members which are set dynamically and \\\nmissed by pylint inference system, and so shouldn't trigger E1101 when \\\naccessed. Python regular expressions are accepted.\",\n            },\n        ),\n        (\n            \"contextmanager-decorators\",\n            {\n                \"default\": [\"contextlib.contextmanager\"],\n                \"type\": \"csv\",\n                \"metavar\": \"<decorator names>\",\n                \"help\": \"List of decorators that produce context managers, \"\n                \"such as contextlib.contextmanager. Add to this list \"\n                \"to register other decorators that produce valid \"\n                \"context managers.\",\n            },\n        ),\n        (\n            \"missing-member-hint-distance\",\n            {\n                \"default\": 1,\n                \"type\": \"int\",\n                \"metavar\": \"<member hint edit distance>\",\n                \"help\": \"The maximum edit distance a name should have in order \"\n                \"to be considered a similar match for a missing member name.\",\n            },\n        ),\n        (\n            \"missing-member-max-choices\",\n            {\n"}], "retrieved_count": 10, "cost_time": 0.3404700756072998}
{"question": "How does Pylint implement its configuration management system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements its configuration management system through a hierarchical and extensible architecture: 1) _ArgumentsManager class - central component that handles command-line arguments, configuration file parsing, and option management, 2) _ArgumentsProvider base class - provides the interface for components to define configurable options, 3) Multiple configuration sources - support for INI files, TOML files, pyproject.toml, and command-line arguments with precedence rules, 4) Per-directory configuration - allows different settings for different parts of a codebase, 5) Option validation - type checking and validation of configuration values, 6) Default value management - automatic application of sensible defaults for unspecified options, 7) Configuration inheritance - hierarchical configuration where child directories can inherit from parent configurations, 8) Dynamic option registration - checkers and plugins can register their own configuration options, 9) Configuration persistence - settings can be saved and reused across sessions, 10) Configuration migration - automatic migration of old configuration formats to new ones. This system provides flexibility while maintaining consistency and validation.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stants import MAIN_CHECKER_NAME\nfrom pylint.typing import DirectoryNamespaceDict, OptionDict\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\n\nif TYPE_CHECKING:\n    from pylint.config.arguments_provider import _ArgumentsProvider\n\n\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n\n        This is necessary for the per-directory configuration support. Whenever we\n        fail to match a file with a directory we fall back to the Namespace object\n        created during initialization.\n        \"\"\"\n\n        self._arg_parser = argparse.ArgumentParser(\n            prog=prog,\n            usage=usage or \"%(prog)s [options]\",\n            description=description,\n            formatter_class=_HelpFormatter,\n            # Needed to let 'pylint-config' overwrite the -h command\n            conflict_handler=\"resolve\",\n        )\n        \"\"\"The command line argument parser.\"\"\"\n\n        self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n        \"\"\"Dictionary of all the argument groups.\"\"\"\n\n        self._option_dicts: dict[str, OptionDict] = {}\n        \"\"\"All option dictionaries that have been registered.\"\"\"\n\n        self._directory_namespaces: DirectoryNamespaceDict = {}\n        \"\"\"Mapping of directories and their respective namespace objects.\"\"\"\n\n    @property\n    def config(self) -> argparse.Namespace:\n        \"\"\"Namespace for all options.\"\"\"\n        return self._config\n\n    @config.setter\n    def config(self, value: argparse.Namespace) -> None:\n        self._config = value\n\n    def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n        \"\""}, {"start_line": 0, "end_line": 571, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Everything related to the 'pylint-config' command.\n\nEverything in this module is private.\n\"\"\"\n\nfrom pylint.config._pylint_config.main import _handle_pylint_config_commands\nfrom pylint.config._pylint_config.setup import _register_generate_config_options\n\n__all__ = (\"_handle_pylint_config_commands\", \"_register_generate_config_options\")\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport re\nimport sys\nimport textwrap\nimport warnings\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Any, TextIO\n\nimport tomlkit\n\nfrom pylint import utils\nfrom pylint.config.argument import (\n    _Argument,\n    _CallableArgument,\n    _ExtendArgument,\n    _StoreArgument,\n    _StoreNewNamesArgument,\n    _StoreOldNamesArgument,\n    _StoreTrueArgument,\n)\nfrom pylint.config.exceptions import (\n    UnrecognizedArgumentAction,\n    _UnrecognizedOptionError,\n)\nfrom pylint.config.help_formatter import _HelpFormatter\nfrom pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value\nfrom pylint.constants import MAIN_CHECKER_NAME\nfrom pylint.typing import DirectoryNamespaceDict, OptionDict\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\n\nif TYPE_CHECKING:\n    from pylint.config.arguments_provider import _ArgumentsProvider\n\n\nclass _ArgumentsManager:\n    \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n\n    def __init__(\n        self, prog: str, usage: str | None = None, description: str | None = None\n    ) -> None:\n        self._config = argparse.Namespace()\n        \"\"\"Namespace for all options.\"\"\"\n\n        self._base_config = self._config\n        \"\"\"Fall back Namespace object created during initialization.\n\n        This is necessary for the per-directory configuration support. Whenever we\n        fail to match a file with a directory we fall back to the Namespace object\n        created during initialization.\n        \"\"\"\n\n        self._arg_parser = argparse.ArgumentParser(\n            prog=prog,\n            usa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "config_initialization.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport warnings\nfrom glob import glob\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom pylint import reporters\nfrom pylint.config.config_file_parser import _ConfigurationFileParser\nfrom pylint.config.exceptions import (\n    ArgumentPreprocessingError,\n    _UnrecognizedOptionError,\n)\nfrom pylint.utils import utils\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef _config_initialization(  # pylint: disable=too-many-statements\n    linter: PyLinter,\n    args_list: list[str],\n    reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n    config_file: None | str | Path = None,\n    verbose_mode: bool = False,\n) -> list[str]:\n    \"\"\"Parse all available options, read config files and command line arguments and\n    set options accordingly.\n    \"\"\"\n    linter.verbose = verbose_mode\n    config_file = Path(config_file) if config_file else None\n\n    # Set the current module to the configuration file\n    # to allow raising messages on the configuration file.\n    linter.set_current_module(str(config_file) if config_file else \"\")\n\n    # Read the configuration file\n    config_file_parser = _ConfigurationFileParser(verbose_mode, linter)\n    try:\n        config_data, config_args = config_file_parser.parse_config_file(\n            file_path=config_file\n        )\n    except OSError as ex:\n        print(ex, file=sys.stderr)\n        sys.exit(32)\n\n    # Order --enable=all or --disable=all to come first.\n    config_args = _order_all_first(config_args, joined=False)\n\n    # Run init hook, if present, before loading plugins\n    if \"init-hook\" in config_data:\n        exec(utils._unquote(config_data[\"init-hook\"]))  # pylint: disable=exec-used\n\n    # "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "config_file_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Configuration file parser class.\"\"\"\n\nfrom __future__ import annotations\n\nimport configparser\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom pylint.config.utils import _parse_rich_type_value\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nPylintConfigFileData = tuple[dict[str, str], list[str]]\n\n\nclass _RawConfParser:\n    \"\"\"Class to parse various formats of configuration files.\"\"\"\n\n    @staticmethod\n    def parse_ini_file(file_path: Path) -> PylintConfigFileData:\n        \"\"\"Parse and handle errors of an ini configuration file.\n\n        Raises ``configparser.Error``.\n        \"\"\"\n        parser = configparser.ConfigParser(inline_comment_prefixes=(\"#\", \";\"))\n        # Use this encoding in order to strip the BOM marker, if any.\n        with open(file_path, encoding=\"utf_8_sig\") as fp:\n            parser.read_file(fp)\n\n        config_content: dict[str, str] = {}\n        options: list[str] = []\n        ini_file_with_sections = _RawConfParser._ini_file_with_sections(file_path)\n        for section in parser.sections():\n            if ini_file_with_sections and not section.startswith(\"pylint\"):\n                continue\n            for option, value in parser[section].items():\n                config_content[option] = value\n                options += [f\"--{option}\", value]\n        return config_content, options\n\n    @staticmethod\n    def _ini_file_with_sections(file_path: Path) -> bool:\n        \"\"\"Return whether the file uses sections.\"\"\"\n        if \"setup.cfg\" in file_path.parts:\n            return True\n        if \"tox.ini\" in file_path.parts:\n            return True\n        return False\n\n    @staticmethod\n    def p"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    {\n                \"type\": \"yn\",\n                \"metavar\": \"<yn>\",\n                \"default\": False,\n                \"help\": \"Discover python modules and packages in the file system subtree.\",\n            },\n        ),\n        (\n            \"py-version\",\n            {\n                \"default\": sys.version_info[:2],\n                \"type\": \"py_version\",\n                \"metavar\": \"<py_version>\",\n                \"help\": (\n                    \"Minimum Python version to use for version dependent checks. \"\n                    \"Will default to the version used to run pylint.\"\n                ),\n            },\n        ),\n        (\n            \"ignored-modules\",\n            {\n                \"default\": (),\n                \"type\": \"csv\",\n                \"metavar\": \"<module names>\",\n                \"help\": \"List of module names for which member attributes \"\n                \"should not be checked and will not be imported \"\n                \"(useful for modules/projects \"\n                \"where namespaces are manipulated during runtime and \"\n                \"thus existing member attributes cannot be \"\n                \"deduced by static analysis). It supports qualified \"\n                \"module names, as well as Unix pattern matching.\",\n            },\n        ),\n        (\n            \"analyse-fallback-blocks\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Analyse import fallback blocks. This can be used to \"\n                \"support both Python 2 and 3 compatible code, which \"\n                \"means that the block might have code that exists \"\n                \"only in one or another interpreter, leading to false \"\n                \"positives when analysed.\",\n            },\n        ),\n        (\n            \"clear-cache-post-run\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Clear in-memo"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "arguments_provider.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Arguments provider class used to expose options.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom typing import Any\n\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.typing import OptionDict, Options\n\n\nclass _ArgumentsProvider:\n    \"\"\"Base class for classes that provide arguments.\"\"\"\n\n    name: str\n    \"\"\"Name of the provider.\"\"\"\n\n    options: Options = ()\n    \"\"\"Options provided by this provider.\"\"\"\n\n    option_groups_descs: dict[str, str] = {}\n    \"\"\"Option groups of this provider and their descriptions.\"\"\"\n\n    def __init__(self, arguments_manager: _ArgumentsManager) -> None:\n        self._arguments_manager = arguments_manager\n        \"\"\"The manager that will parse and register any options provided.\"\"\"\n\n        self._arguments_manager._register_options_provider(self)\n\n    def _option_value(self, opt: str) -> Any:\n        \"\"\"Get the current value for the given option.\"\"\"\n        return getattr(self._arguments_manager.config, opt.replace(\"-\", \"_\"), None)\n\n    def _options_by_section(\n        self,\n    ) -> Iterator[\n        tuple[str, list[tuple[str, OptionDict, Any]]]\n        | tuple[None, dict[str, list[tuple[str, OptionDict, Any]]]]\n    ]:\n        \"\"\"Return an iterator on options grouped by section.\n\n        (section, [list of (optname, optdict, optvalue)])\n        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n            yield None, sections.pop(None)  # type: ignore[call-overload]\n        for section, optio"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "base_options.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "formation. \"\n                    \"See doc for all details.\"\n                ),\n            },\n        ),\n        (\n            \"jobs\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<n-processes>\",\n                \"short\": \"j\",\n                \"default\": 1,\n                \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n                \"auto-detect the number of processors available to use, and will cap \"\n                \"the count on Windows to avoid hangs.\",\n            },\n        ),\n        (\n            \"unsafe-load-any-extension\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"hide\": True,\n                \"help\": (\n                    \"Allow loading of arbitrary C extensions. Extensions\"\n                    \" are imported into the active Python interpreter and\"\n                    \" may run arbitrary code.\"\n                ),\n            },\n        ),\n        (\n            \"limit-inference-results\",\n            {\n                \"type\": \"int\",\n                \"metavar\": \"<number-of-results>\",\n                \"default\": 100,\n                \"help\": (\n                    \"Control the amount of potential inferred values when inferring \"\n                    \"a single object. This can help the performance when dealing with \"\n                    \"large functions or complex, nested conditions.\"\n                ),\n            },\n        ),\n        (\n            \"extension-pkg-allow-list\",\n            {\n                \"type\": \"csv\",\n                \"metavar\": \"<pkg[,pkg]>\",\n                \"default\": [],\n                \"help\": (\n                    \"A comma-separated list of package or module names\"\n                    \" from where C extensions may be loaded. Extensions are\"\n                    \" loading into the active Python interpreter and may run\"\n                    \" arbitrary code.\"\n                ),\n            },\n        ),"}, {"start_line": 0, "end_line": 855, "belongs_to": {"file_name": "main.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Everything related to the 'pylint-config' command.\"\"\"\n\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.config._pylint_config.generate_command import handle_generate_command\nfrom pylint.config._pylint_config.help_message import get_help\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\ndef _handle_pylint_config_commands(linter: PyLinter) -> int:\n    \"\"\"Handle whichever command is passed to 'pylint-config'.\"\"\"\n    if linter.config.config_subcommand == \"generate\":\n        return handle_generate_command(linter)\n\n    print(get_help(linter._arg_parser))\n    return 32\n"}], "retrieved_count": 10, "cost_time": 0.33828067779541016}
{"question": "How does Pylint handle multi-threading in its analysis process?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint handles multi-threading in its analysis process through several mechanisms: 1) File-level parallelism - multiple files can be analyzed in parallel when possible, 2) Thread-safe message collection - messages from different threads are collected safely without race conditions, 3) Shared configuration access - configuration is shared across threads in a thread-safe manner, 4) AST caching coordination - AST cache access is coordinated to prevent conflicts, 5) Plugin thread safety - plugins are designed to be thread-safe when possible, 6) Resource management - shared resources are managed to prevent conflicts between threads, 7) Error isolation - errors in one thread don't affect analysis in other threads, 8) Progress tracking - progress is tracked across multiple threads, 9) Memory coordination - memory usage is coordinated to prevent excessive memory consumption, 10) Result aggregation - results from multiple threads are aggregated safely. However, Pylint's multi-threading support is limited by the complexity of AST analysis and the need to maintain consistency across the analysis process.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport functools\nfrom collections import defaultdict\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Any\n\nimport dill\n\nfrom pylint import reporters\nfrom pylint.lint.utils import _augment_sys_path\nfrom pylint.message import Message\nfrom pylint.typing import FileItem\nfrom pylint.utils import LinterStats, merge_stats\n\ntry:\n    import multiprocessing\nexcept ImportError:\n    multiprocessing = None  # type: ignore[assignment]\n\ntry:\n    from concurrent.futures import ProcessPoolExecutor\nexcept ImportError:\n    ProcessPoolExecutor = None  # type: ignore[assignment,misc]\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# PyLinter object used by worker processes when checking files using parallel mode\n# should only be used by the worker processes\n_worker_linter: PyLinter | None = None\n\n\ndef _worker_initialize(\n    linter: bytes, extra_packages_paths: Sequence[str] | None = None\n) -> None:\n    \"\"\"Function called to initialize a worker for a Process within a concurrent Pool.\n\n    :param linter: A linter-class (PyLinter) instance pickled with dill\n    :param extra_packages_paths: Extra entries to be added to `sys.path`\n    \"\"\"\n    global _worker_linter  # pylint: disable=global-statement\n    _worker_linter = dill.loads(linter)\n    assert _worker_linter\n\n    # On the worker process side the messages are just collected and passed back to\n    # parent process as _worker_check_file function's return value\n    _worker_linter.set_reporter(reporters.CollectingReporter())\n    _worker_linter.open()\n\n    # Re-register dynamic plugins, since the pool does not have access to the\n    # astroid module that existed when the linter was pickled.\n    _worker_linter.load_plugin_modules(_worker_"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dict(os.environ, {\"PYLINTHOME\": \"whatever.d\"})\ndef test_pylint_home_from_environ() -> None:\n    assert _get_pylint_home() == \"whatever.d\"\n\n\nclass _CustomPyLinter(PyLinter):\n    @staticmethod\n    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n        if os.path.basename(path) == \"wrong.py\":\n            return False\n\n        return super(_CustomPyLinter, _CustomPyLinter).should_analyze_file(\n            modname, path, is_argument=is_argument\n        )\n\n\n@pytest.mark.needs_two_cores\ndef test_custom_should_analyze_file() -> None:\n    \"\"\"Check that we can write custom should_analyze_file that work\n    even for arguments.\n    \"\"\"\n    package_dir = os.path.join(REGRTEST_DATA_DIR, \"bad_package\")\n    wrong_file = os.path.join(package_dir, \"wrong.py\")\n\n    for jobs in (1, 2):\n        reporter = testutils.GenericTestReporter()\n        linter = _CustomPyLinter()\n        linter.config.jobs = jobs\n        linter.config.persistent = 0\n        linter.open()\n        linter.set_reporter(reporter)\n\n        try:\n            sys.path.append(os.path.dirname(package_dir))\n            linter.check([package_dir, wrong_file])\n        finally:\n            sys.path.pop()\n\n        messages = reporter.messages\n        assert len(messages) == 1\n        assert \"invalid syntax\" in messages[0].msg\n\n\n# we do the check with jobs=1 as well, so that we are sure that the duplicates\n# are created by the multiprocessing problem.\n@pytest.mark.needs_two_cores\n@pytest.mark.parametrize(\"jobs\", [1, 2])\ndef test_multiprocessing(jobs: int) -> None:\n    \"\"\"Check that multiprocessing does not create duplicates.\"\"\"\n    # For the bug (#3584) to show up we need more than one file with issues\n    # per process\n    filenames = [\n        \"special_attr_scope_lookup_crash.py\",\n        \"syntax_error.py\",\n        \"unused_variable.py\",\n        \"wildcard.py\",\n        \"wrong_import_position.py\",\n    ]\n\n    reporter = testutils.GenericTestReporter()\n    linter = PyLinter()\n    linter.config."}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llel mode\n# should only be used by the worker processes\n_worker_linter: PyLinter | None = None\n\n\ndef _worker_initialize(\n    linter: bytes, extra_packages_paths: Sequence[str] | None = None\n) -> None:\n    \"\"\"Function called to initialize a worker for a Process within a concurrent Pool.\n\n    :param linter: A linter-class (PyLinter) instance pickled with dill\n    :param extra_packages_paths: Extra entries to be added to `sys.path`\n    \"\"\"\n    global _worker_linter  # pylint: disable=global-statement\n    _worker_linter = dill.loads(linter)\n    assert _worker_linter\n\n    # On the worker process side the messages are just collected and passed back to\n    # parent process as _worker_check_file function's return value\n    _worker_linter.set_reporter(reporters.CollectingReporter())\n    _worker_linter.open()\n\n    # Re-register dynamic plugins, since the pool does not have access to the\n    # astroid module that existed when the linter was pickled.\n    _worker_linter.load_plugin_modules(_worker_linter._dynamic_plugins, force=True)\n    _worker_linter.load_plugin_configuration()\n\n    if extra_packages_paths:\n        _augment_sys_path(extra_packages_paths)\n\n\ndef _worker_check_single_file(\n    file_item: FileItem,\n) -> tuple[\n    int,\n    str,\n    str,\n    str,\n    list[Message],\n    LinterStats,\n    int,\n    defaultdict[str, list[Any]],\n]:\n    if not _worker_linter:\n        raise RuntimeError(\"Worker linter not yet initialised\")\n    _worker_linter.open()\n    _worker_linter.check_single_file_item(file_item)\n    mapreduce_data = defaultdict(list)\n    for checker in _worker_linter.get_checkers():\n        data = checker.get_map_data()\n        if data is not None:\n            mapreduce_data[checker.name].append(data)\n    msgs = _worker_linter.reporter.messages\n    assert isinstance(_worker_linter.reporter, reporters.CollectingReporter)\n    _worker_linter.reporter.reset()\n    return (\n        id(multiprocessing.current_process()),\n        _worker_linter.current_name,\n        file_item"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Puts the check_parallel system under test.\"\"\"\n\n# pylint: disable=protected-access,missing-function-docstring\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom concurrent.futures import ProcessPoolExecutor\nfrom concurrent.futures.process import BrokenProcessPool\nfrom pathlib import Path\nfrom pickle import PickleError\nfrom typing import TYPE_CHECKING\nfrom unittest.mock import patch\n\nimport dill\nimport pytest\n\nimport pylint.interfaces\nimport pylint.lint.parallel\nfrom pylint.checkers import BaseRawFileChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.lint import PyLinter, augmented_sys_path\nfrom pylint.lint.parallel import _worker_check_single_file as worker_check_single_file\nfrom pylint.lint.parallel import _worker_initialize as worker_initialize\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.testutils import GenericTestReporter as Reporter\nfrom pylint.testutils.utils import _test_cwd\nfrom pylint.typing import FileItem\nfrom pylint.utils import LinterStats, ModuleStats\n\nif TYPE_CHECKING:\n    from unittest.mock import MagicMock\n\n    from astroid import nodes\n\n\ndef _gen_file_data(idx: int = 0) -> FileItem:\n    \"\"\"Generates a file to use as a stream.\"\"\"\n    filepath = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"input\", \"similar1\")\n    )\n    file_data = FileItem(\n        f\"--test-file_data-name-{idx}--\",\n        filepath,\n        f\"--test-file_data-modname-{idx}--\",\n    )\n    return file_data\n\n\ndef _gen_file_datas(count: int = 1) -> list[FileItem]:\n    return [_gen_file_data(idx) for idx in range(count)]\n\n\nclass SequentialTestChecker(BaseRawFileChecker):\n    \"\"\"A checker that does not need to con"}, {"start_line": 8000, "end_line": 9929, "belongs_to": {"file_name": "run.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                 file=sys.stderr,\n                )\n                linter.set_option(\"jobs\", 1)\n            elif linter.config.jobs == 0:\n                linter.config.jobs = _cpu_count()\n\n        if self._output:\n            try:\n                with open(self._output, \"w\", encoding=\"utf-8\") as output:\n                    linter.reporter.out = output\n                    linter.check(args)\n                    score_value = linter.generate_reports(verbose=self.verbose)\n            except OSError as ex:\n                print(ex, file=sys.stderr)\n                sys.exit(32)\n        else:\n            linter.check(args)\n            score_value = linter.generate_reports(verbose=self.verbose)\n        if linter.config.clear_cache_post_run:\n            clear_lru_caches()\n            MANAGER.clear_cache()\n\n        if exit:\n            if linter.config.exit_zero:\n                sys.exit(0)\n            elif linter.any_fail_on_issues():\n                # We need to make sure we return a failing exit code in this case.\n                # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.\n                sys.exit(self.linter.msg_status or 1)\n            elif score_value is not None:\n                if score_value >= linter.config.fail_under:\n                    sys.exit(0)\n                else:\n                    # We need to make sure we return a failing exit code in this case.\n                    # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.\n                    sys.exit(self.linter.msg_status or 1)\n            else:\n                sys.exit(self.linter.msg_status)\n\n\nclass _PylintConfigRun(Run):\n    \"\"\"A private wrapper for the 'pylint-config' command.\"\"\"\n\n    _is_pylint_config: ClassVar[bool] = True\n    \"\"\"Boolean whether or not this is a 'pylint-config' run.\n\n    Used by _PylintConfigRun to make the 'pylint-config' command work.\n    \"\"\"\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "run.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eless-suppression\n    if sched_getaffinity:\n        cpu_count = len(sched_getaffinity(0))\n    elif multiprocessing:\n        cpu_count = multiprocessing.cpu_count()\n    else:\n        cpu_count = 1\n    if sys.platform == \"win32\":\n        # See also https://github.com/python/cpython/issues/94242\n        cpu_count = min(cpu_count, 56)  # pragma: no cover\n    if cpu_share is not None:\n        return min(cpu_share, cpu_count)\n    return cpu_count\n\n\nclass Run:\n    \"\"\"Helper class to use as main for pylint with 'run(*sys.argv[1:])'.\"\"\"\n\n    LinterClass = PyLinter\n    option_groups = (\n        (\n            \"Commands\",\n            \"Options which are actually commands. Options in this \\\ngroup are mutually exclusive.\",\n        ),\n    )\n    _is_pylint_config: ClassVar[bool] = False\n    \"\"\"Boolean whether or not this is a 'pylint-config' run.\n\n    Used by _PylintConfigRun to make the 'pylint-config' command work.\n    \"\"\"\n\n    # pylint: disable = too-many-statements, too-many-branches\n    def __init__(\n        self,\n        args: Sequence[str],\n        reporter: BaseReporter | None = None,\n        exit: bool = True,  # pylint: disable=redefined-builtin\n    ) -> None:\n        # Immediately exit if user asks for version\n        if \"--version\" in args:\n            print(full_version)\n            sys.exit(0)\n\n        self._rcfile: str | None = None\n        self._output: str | None = None\n        self._plugins: list[str] = []\n        self.verbose: bool = False\n\n        # Pre-process certain options and remove them from args list\n        try:\n            args = _preprocess_options(self, args)\n        except ArgumentPreprocessingError as ex:\n            print(ex, file=sys.stderr)\n            sys.exit(32)\n\n        # Determine configuration file\n        if self._rcfile is None:\n            default_file = next(config.find_default_config_files(), None)\n            if default_file:\n                self._rcfile = str(default_file)\n\n        self.linter = linter = self.LinterClass(\n            "}, {"start_line": 0, "end_line": 1951, "belongs_to": {"file_name": "threading_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages, safe_infer\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass ThreadingChecker(BaseChecker):\n    \"\"\"Checks for threading module.\n\n    - useless with lock - locking used in wrong way that has no effect (with threading.Lock():)\n    \"\"\"\n\n    name = \"threading\"\n\n    LOCKS = frozenset(\n        (\n            \"threading.Lock\",\n            \"threading.RLock\",\n            \"threading.Condition\",\n            \"threading.Semaphore\",\n            \"threading.BoundedSemaphore\",\n        )\n    )\n\n    msgs = {\n        \"W2101\": (\n            \"'%s()' directly created in 'with' has no effect\",\n            \"useless-with-lock\",\n            \"Used when a new lock instance is created by using with statement \"\n            \"which has no effect. Instead, an existing instance should be used to acquire lock.\",\n        ),\n    }\n\n    @only_required_for_messages(\"useless-with-lock\")\n    def visit_with(self, node: nodes.With) -> None:\n        context_managers = (c for c, _ in node.items if isinstance(c, nodes.Call))\n        for context_manager in context_managers:\n            if isinstance(context_manager, nodes.Call):\n                infered_function = safe_infer(context_manager.func)\n                if infered_function is None:\n                    continue\n                qname = infered_function.qname()\n                if qname in self.LOCKS:\n                    self.add_message(\"useless-with-lock\", node=node, args=qname)\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ThreadingChecker(linter))\n"}], "retrieved_count": 10, "cost_time": 0.34344935417175293}
{"question": "How does Pylint implement its type inference system?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements its type inference system through astroid's sophisticated type analysis capabilities: 1) Type annotation analysis - processing type hints and annotations in modern Python code, 2) Built-in type knowledge - understanding Python's built-in types and their capabilities, 3) Import resolution - resolving imported types and their definitions, 4) Function signature analysis - understanding parameter types and return types, 5) Class hierarchy analysis - understanding inheritance relationships and method signatures, 6) Context-aware inference - considering the context in which variables are used, 7) Confidence levels - indicating the reliability of inferred types, 8) Type checking utilities - helper functions for type comparison and validation, 9) Error handling - graceful handling of inference failures and uninferable types, 10) Caching - caching inferred types to avoid redundant computation. The type inference system enables Pylint to perform sophisticated type-related checks and provide more accurate warnings about potential type-related issues.", "score": null, "retrieved_content": [{"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ontext(builder_args)\n    try:\n        inferred = next(func.infer_call_result(func, context), None)\n    except astroid.InferenceError:\n        return None\n    return inferred or None\n\n\ndef _is_c_extension(module_node: InferenceResult) -> bool:\n    return (\n        isinstance(module_node, nodes.Module)\n        and not astroid.modutils.is_stdlib_module(module_node.name)\n        and not module_node.fully_defined()\n    )\n\n\ndef _is_invalid_isinstance_type(arg: nodes.NodeNG) -> bool:\n    # Return True if we are sure that arg is not a type\n    if isinstance(arg, nodes.BinOp) and arg.op == \"|\":\n        return any(\n            _is_invalid_isinstance_type(elt) and not is_none(elt)\n            for elt in (arg.left, arg.right)\n        )\n    inferred = utils.safe_infer(arg)\n    if not inferred:\n        # Cannot infer it so skip it.\n        return False\n    if isinstance(inferred, nodes.Tuple):\n        return any(_is_invalid_isinstance_type(elt) for elt in inferred.elts)\n    if isinstance(inferred, nodes.ClassDef):\n        return False\n    if isinstance(inferred, astroid.Instance) and inferred.qname() == BUILTIN_TUPLE:\n        return False\n    if isinstance(inferred, bases.UnionType):\n        return any(\n            _is_invalid_isinstance_type(elt) and not is_none(elt)\n            for elt in (inferred.left, inferred.right)\n        )\n    return True\n\n\nclass TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n\n    # configuration section name\n    name = \"typecheck\"\n    # messages\n    msgs = MSGS\n    # configuration options\n    options = (\n        (\n            \"ignore-on-opaque-inference\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"This flag controls whether pylint should warn about \"\n                \"no-member and similar checks whenever an opaque object \"\n                \"is returned when inferring. The inference can return \"\n                \"multipl"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "odes.ClassDef):\n        return False\n    if isinstance(inferred, astroid.Instance) and inferred.qname() == BUILTIN_TUPLE:\n        return False\n    if isinstance(inferred, bases.UnionType):\n        return any(\n            _is_invalid_isinstance_type(elt) and not is_none(elt)\n            for elt in (inferred.left, inferred.right)\n        )\n    return True\n\n\nclass TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n\n    # configuration section name\n    name = \"typecheck\"\n    # messages\n    msgs = MSGS\n    # configuration options\n    options = (\n        (\n            \"ignore-on-opaque-inference\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"This flag controls whether pylint should warn about \"\n                \"no-member and similar checks whenever an opaque object \"\n                \"is returned when inferring. The inference can return \"\n                \"multiple potential results while evaluating a Python object, \"\n                \"but some branches might not be evaluated, which results in \"\n                \"partial inference. In that case, it might be useful to still emit \"\n                \"no-member and other checks for the rest of the inferred objects.\",\n            },\n        ),\n        (\n            \"mixin-class-rgx\",\n            {\n                \"default\": \".*[Mm]ixin\",\n                \"type\": \"regexp\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"Regex pattern to define which classes are considered mixins.\",\n            },\n        ),\n        (\n            \"ignore-mixin-members\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Tells whether missing members accessed in mixin \"\n                \"class should be ignored. A class is considered mixin if its name matches \"\n                \"the mixin-class-rgx option.\",\n            "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Try to find more bugs in the code using astroid inference capabilities.\"\"\"\n\nfrom __future__ import annotations\n\nimport heapq\nimport itertools\nimport operator\nimport re\nimport shlex\nimport sys\nfrom collections.abc import Callable, Iterable\nfrom functools import cached_property, lru_cache, singledispatch\nfrom re import Pattern\nfrom typing import TYPE_CHECKING, Any, Literal, TypeAlias\n\nimport astroid\nimport astroid.exceptions\nimport astroid.helpers\nfrom astroid import arguments, bases, nodes, util\nfrom astroid.nodes import _base_nodes\nfrom astroid.typing import InferenceResult, SuccessfulInferenceResult\n\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.checkers.utils import (\n    decorated_with,\n    decorated_with_property,\n    has_known_bases,\n    is_builtin_object,\n    is_comprehension,\n    is_hashable,\n    is_inside_abstract_class,\n    is_iterable,\n    is_mapping,\n    is_module_ignored,\n    is_node_in_type_annotation_context,\n    is_none,\n    is_overload_stub,\n    is_postponed_evaluation_enabled,\n    is_super,\n    node_ignores_exception,\n    only_required_for_messages,\n    safe_infer,\n    supports_delitem,\n    supports_getitem,\n    supports_membership_test,\n    supports_setitem,\n)\nfrom pylint.interfaces import HIGH, INFERENCE\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nCallableObjects: TypeAlias = (\n    bases.BoundMethod\n    | bases.UnboundMethod\n    | nodes.FunctionDef\n    | nodes.Lambda\n    | nodes.ClassDef\n)\n\nSTR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nBUILTINS_IMPLICIT_RETURN_NONE = {\n   "}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "em_protocol)\n\n\ndef supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_setitem_protocol)\n\n\ndef supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_delitem_protocol)\n\n\ndef _get_python_type_of_node(node: nodes.NodeNG) -> str | None:\n    pytype: Callable[[], str] | None = getattr(node, \"pytype\", None)\n    if callable(pytype):\n        return pytype()\n    return None\n\n\n@lru_cache(maxsize=1024)\ndef safe_infer(\n    node: nodes.NodeNG,\n    context: InferenceContext | None = None,\n    *,\n    compare_constants: bool = False,\n    compare_constructors: bool = False,\n) -> InferenceResult | None:\n    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n\n    If compare_constants is True and if multiple constants are inferred,\n    unequal inferred values are also considered ambiguous and return None.\n\n    If compare_constructors is True and if multiple classes are inferred,\n    constructors with different signatures are held ambiguous and return None.\n    \"\"\"\n    inferred_types: set[str | None] = set()\n    try:\n        infer_gen = node.infer(context=context)\n        value = next(infer_gen)\n    except astroid.InferenceError:\n        return None\n    except Exception as e:  # pragma: no cover\n        raise AstroidError from e\n\n    if not isinstance(value, util.UninferableBase):\n        inferred_types.add(_get_python_type_of_node(value))\n\n    # pylint: disable = too-many-try-statements\n    try:\n        for inferred in infer_gen:\n            inferred_type = _get_python_type_of_node(inferred)\n            if inferred_type not in inferred_types:\n                return None  # If there is ambiguity on the inferred node.\n            if (\n                compare_constants\n                and isinstance(inferred, nodes.Const)\n                and isinstan"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is_builtin_object,\n    is_comprehension,\n    is_hashable,\n    is_inside_abstract_class,\n    is_iterable,\n    is_mapping,\n    is_module_ignored,\n    is_node_in_type_annotation_context,\n    is_none,\n    is_overload_stub,\n    is_postponed_evaluation_enabled,\n    is_super,\n    node_ignores_exception,\n    only_required_for_messages,\n    safe_infer,\n    supports_delitem,\n    supports_getitem,\n    supports_membership_test,\n    supports_setitem,\n)\nfrom pylint.interfaces import HIGH, INFERENCE\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nCallableObjects: TypeAlias = (\n    bases.BoundMethod\n    | bases.UnboundMethod\n    | nodes.FunctionDef\n    | nodes.Lambda\n    | nodes.ClassDef\n)\n\nSTR_FORMAT = {\"builtins.str.format\"}\nASYNCIO_COROUTINE = \"asyncio.coroutines.coroutine\"\nBUILTIN_TUPLE = \"builtins.tuple\"\nTYPE_ANNOTATION_NODES_TYPES = (\n    nodes.AnnAssign,\n    nodes.Arguments,\n    nodes.FunctionDef,\n)\nBUILTINS_IMPLICIT_RETURN_NONE = {\n    \"builtins.dict\": {\"clear\", \"update\"},\n    \"builtins.list\": {\n        \"append\",\n        \"clear\",\n        \"extend\",\n        \"insert\",\n        \"remove\",\n        \"reverse\",\n        \"sort\",\n    },\n    \"builtins.set\": {\n        \"add\",\n        \"clear\",\n        \"difference_update\",\n        \"discard\",\n        \"intersection_update\",\n        \"remove\",\n        \"symmetric_difference_update\",\n        \"update\",\n    },\n}\n\n\nclass VERSION_COMPATIBLE_OVERLOAD:\n    pass\n\n\nVERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()\n\n\ndef _is_owner_ignored(\n    owner: SuccessfulInferenceResult,\n    attrname: str | None,\n    ignored_classes: Iterable[str],\n    ignored_modules: Iterable[str],\n) -> bool:\n    \"\"\"Check if the given owner should be ignored.\n\n    This will verify if the owner's module is in *ignored_modules*\n    or the owner's module fully qualified name is in *ignored_modules*\n    or if the *ignored_modules* contains a pattern which catches\n    the fully qualified name of the module.\n\n "}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_callback(value)\n\n    return False\n\n\ndef is_iterable(value: nodes.NodeNG, check_async: bool = False) -> bool:\n    if check_async:\n        protocol_check = _supports_async_iteration_protocol\n    else:\n        protocol_check = _supports_iteration_protocol\n    return _supports_protocol(value, protocol_check)\n\n\ndef is_mapping(value: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_mapping_protocol)\n\n\ndef supports_membership_test(value: nodes.NodeNG) -> bool:\n    supported = _supports_protocol(value, _supports_membership_test_protocol)\n    return supported or is_iterable(value)\n\n\ndef supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getitem_protocol)\n\n\ndef supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_setitem_protocol)\n\n\ndef supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_delitem_protocol)\n\n\ndef _get_python_type_of_node(node: nodes.NodeNG) -> str | None:\n    pytype: Callable[[], str] | None = getattr(node, \"pytype\", None)\n    if callable(pytype):\n        return pytype()\n    return None\n\n\n@lru_cache(maxsize=1024)\ndef safe_infer(\n    node: nodes.NodeNG,\n    context: InferenceContext | None = None,\n    *,\n    compare_constants: bool = False,\n    compare_constructors: bool = False,\n) -> InferenceResult | None:\n    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n\n    If compare_constants is True and if multiple constants are inferred,\n    unequal inferred values are als"}, {"start_line": 0, "end_line": 1071, "belongs_to": {"file_name": "clear_lru_cache.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nfrom pylint.checkers.typecheck import _similar_names\nfrom pylint.checkers.utils import (\n    class_is_abstract,\n    in_for_else_branch,\n    infer_all,\n    is_overload_stub,\n    overridden_method,\n    safe_infer,\n    unimplemented_abstract_methods,\n)\n\nif TYPE_CHECKING:\n    from functools import _lru_cache_wrapper\n\n\ndef clear_lru_caches() -> None:\n    \"\"\"Clear caches holding references to AST nodes.\"\"\"\n    caches_holding_node_references: list[_lru_cache_wrapper[Any]] = [\n        class_is_abstract,\n        in_for_else_branch,\n        infer_all,\n        is_overload_stub,\n        overridden_method,\n        unimplemented_abstract_methods,\n        safe_infer,\n        _similar_names,\n    ]\n    for lru in caches_holding_node_references:\n        lru.cache_clear()\n"}, {"start_line": 50000, "end_line": 52000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o-any-return]\n    except AttributeError:\n        pass\n    for base in klass.bases:\n        result = safe_infer(base, context=context)\n        if (\n            not isinstance(result, nodes.ClassDef)\n            or result is klass\n            or not has_known_bases(result, context=context)\n        ):\n            klass._all_bases_known = False\n            return False\n    klass._all_bases_known = True\n    return True\n\n\ndef is_none(node: nodes.NodeNG) -> bool:\n    return (\n        node is None\n        or (isinstance(node, nodes.Const) and node.value is None)\n        or (isinstance(node, nodes.Name) and node.name == \"None\")\n    )\n\n\ndef node_type(node: nodes.NodeNG) -> SuccessfulInferenceResult | None:\n    \"\"\"Return the inferred type for `node`.\n\n    If there is more than one possible type, or if inferred type is Uninferable or None,\n    return None\n    \"\"\"\n    # check there is only one possible type for the assign node. Else we\n    # don't handle it for now\n    types: set[SuccessfulInferenceResult] = set()\n    try:\n        for var_type in node.infer():\n            if isinstance(var_type, util.UninferableBase) or is_none(var_type):\n                continue\n            types.add(var_type)\n            if len(types) > 1:\n                return None\n    except astroid.InferenceError:\n        return None\n    return types.pop() if types else None\n\n\ndef is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n    singledispatch_qnames = (\n        \"functools.singledispatch\",\n        \"singledispatch.singledispatch\",\n    )\n\n    if not isinstance(node, nodes.FunctionDef):\n        return False\n\n    decorators = node.decorators.nodes if node.decorators else []\n    for decorator in decorators:\n        # func.register are function calls or register attributes\n        # when the function is annotated with types\n        if isinstance(decorator, nodes.Call):\n            func = decorator.func\n        "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "redefined_variable_type.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import is_none, node_type, only_required_for_messages\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass MultipleTypesChecker(BaseChecker):\n    \"\"\"Checks for variable type redefinition (NoneType excepted).\n\n    At a function, method, class or module scope\n\n    This rule could be improved:\n\n    - Currently, if an attribute is set to different types in 2 methods of a\n      same class, it won't be detected (see functional test)\n    - One could improve the support for inference on assignment with tuples,\n      ifexpr, etc. Also, it would be great to have support for inference on\n      str.split()\n    \"\"\"\n\n    name = \"multiple_types\"\n    msgs = {\n        \"R0204\": (\n            \"Redefinition of %s type from %s to %s\",\n            \"redefined-variable-type\",\n            \"Used when the type of a variable changes inside a \"\n            \"method or a function.\",\n        )\n    }\n\n    def visit_classdef(self, _: nodes.ClassDef) -> None:\n        self._assigns.append({})\n\n    @only_required_for_messages(\"redefined-variable-type\")\n    def leave_classdef(self, _: nodes.ClassDef) -> None:\n        self._check_and_add_messages()\n\n    visit_functiondef = visit_asyncfunctiondef = visit_classdef\n    leave_functiondef = leave_asyncfunctiondef = leave_module = leave_classdef\n\n    def visit_module(self, _: nodes.Module) -> None:\n        self._assigns: list[dict[str, list[tuple[nodes.Assign, str]]]] = [{}]\n\n    def _check_and_add_messages(self) -> None:\n        assigns = self._assigns.pop()\n        for name, args in assigns.items():\n            if len(args) <= 1:\n                continue\n    "}], "retrieved_count": 10, "cost_time": 0.3411121368408203}
{"question": "How does Pylint optimize its AST traversal for large codebases?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint optimizes its AST traversal for large codebases through several performance strategies: 1) AST caching - parsed AST representations are cached to avoid re-parsing unchanged files, 2) Incremental analysis - only changed files and their dependencies are re-analyzed, 3) Selective checker execution - checkers can be enabled/disabled based on configuration to reduce analysis overhead, 4) Early termination - analysis can stop early when certain conditions are met, 5) Memory management - efficient memory usage through object reuse and garbage collection optimization, 6) Parallel processing - support for analyzing multiple files in parallel when possible, 7) Dependency tracking - smart dependency analysis to minimize re-analysis of unaffected files, 8) Configuration-based optimization - analysis depth and scope can be adjusted based on configuration, 9) Plugin optimization - unnecessary plugins can be disabled to reduce overhead, 10) Type inference caching - computed type information is cached to avoid redundant computation. These optimizations help Pylint scale efficiently to large codebases while maintaining analysis quality.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport sys\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nif TYPE_CHECKING:\n    from pylint.checkers.base_checker import BaseChecker\n    from pylint.lint import PyLinter\n\n# Callable parameter type NodeNG not completely correct.\n# Due to contravariance of Callable parameter types,\n# it should be a Union of all NodeNG subclasses.\n# However, since the methods are only retrieved with\n# getattr(checker, member) and thus are inferred as Any,\n# NodeNG will work too.\nAstCallback = Callable[[nodes.NodeNG], None]\n\n\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no ac"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "statements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.linter = linter\n        self.exception_msg = False\n\n    def _is_method_enabled(self, method: AstCallback) -> bool:\n        if not hasattr(method, \"checks_msgs\"):\n            return True\n        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)\n\n    def add_checker(self, checker: BaseChecker) -> None:\n        \"\"\"Walk to the checker's dir and collect visit and leave methods.\"\"\"\n        vcids: set[str] = set()\n        lcids: set[str] = set()\n        visits = self.visit_events\n        leaves = self.leave_events\n        for member in dir(checker):\n            cid = member[6:]\n            if cid == \"default\":\n                continue\n            if member.startswith(\"visit_\"):\n                v_meth = getattr(checker, member)\n                # don't use visit_methods with no activated message:\n                if self._is_method_enabled(v_meth):\n                    visits[cid].append(v_meth)\n                    vcids.add(cid)\n            elif member.startswith(\"leave_\"):\n                l_meth = getattr(checker, member)\n                # don't use leave_methods with no activated message:\n                if self._is_method_enabled(l_meth):\n                    leaves[cid].append(l_meth)\n                    lcids.add(cid)\n        visit_default = getattr(checker, \"visit_default\", None)\n        if visit_default:\n            for cls in nodes.ALL_NODE_CLASSES:\n                cid = cls.__name__.lower()\n                if cid not in vcids:\n                    visits[cid].append(visit_default)\n        # For now, we have no \"leave_default\" method in Pylint\n\n    def walk(self, astroid: nodes.NodeNG) -> None:\n        \"\"\"Call visit events of astroid checkers for the given node, recurse on\n        its children, then leave events.\n        \"\"\"\n        cid = astroid.__class__"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "mccabe.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Module to add McCabe checker class for pylint.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Any, TypeAlias, TypeVar\n\nfrom astroid import nodes\nfrom mccabe import PathGraph as Mccabe_PathGraph\nfrom mccabe import PathGraphingAstVisitor as Mccabe_PathGraphingAstVisitor\n\nfrom pylint import checkers\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n_StatementNodes: TypeAlias = (\n    nodes.Assert\n    | nodes.Assign\n    | nodes.AugAssign\n    | nodes.Delete\n    | nodes.Raise\n    | nodes.Yield\n    | nodes.Import\n    | nodes.Call\n    | nodes.Subscript\n    | nodes.Pass\n    | nodes.Continue\n    | nodes.Break\n    | nodes.Global\n    | nodes.Return\n    | nodes.Expr\n    | nodes.Await\n)\n\n_SubGraphNodes: TypeAlias = nodes.If | nodes.Try | nodes.For | nodes.While\n_AppendableNodeT = TypeVar(\n    \"_AppendableNodeT\", bound=_StatementNodes | nodes.While | nodes.FunctionDef\n)\n\n\nclass PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()\n        self._bottom_counter = 0\n        self.graph: PathGraph | None = None\n\n    def default(self, node: nodes.NodeNG, *args: Any) -> None:\n        for child in node.get_children():\n            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n "}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dules\n                ]\n            ).keys()\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        progress_reporter = ProgressReporter(self.verbose)\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets up the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n      "}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data, progress_reporter)\n\n                # 3) Lint each ast\n                self._lint_files(\n                    ast_per_fileitem, check_astroid_module, progress_reporter\n                )\n\n    def _get_asts(\n        self,\n        fileitems: Iterator[FileItem],\n        data: str | None,\n        progress_reporter: ProgressReporter,\n    ) -> dict[FileItem, nodes.Module | None]:\n        \"\"\"Get the AST for all given FileItems.\"\"\"\n        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}\n\n        progress_reporter.start_get_asts()\n\n        for fileitem in fileitems:\n            progress_reporter.get_ast_for_file(fileitem.filepath)\n            self.set_current_module(fileitem.name, fileitem.filepath)\n\n            try:\n                ast_per_fileitem[fileitem] = self.get_ast(\n                    fileitem.filepath, fileitem.name, data\n                )\n            except astroid.AstroidBuildingError as ex:\n                template_path = prepare_crash_report(\n                    ex, fileitem.filepath, self.crash_file_path\n                )\n                msg = get_fatal_error_message(fileitem.filepath, template_path)\n                self.add_message(\n                    \"astroid-error\",\n                    args=(fileitem.filepath, msg),\n                    confidence=HIGH,\n                )\n\n        return ast_per_fileitem\n\n    def check_single_file_item(self, file: FileItem) -> None:\n        \"\"\"Check single file item.\n\n        The arguments are the same that are documented in _check_files\n\n        initialize() should be called before calling this method\n        \"\"\"\n        with self._astroid_module_checker() as check_astroid_module:\n            self._check_file(self.get_ast, check_astroid_module, file)\n\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "mccabe.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s.Break\n    | nodes.Global\n    | nodes.Return\n    | nodes.Expr\n    | nodes.Await\n)\n\n_SubGraphNodes: TypeAlias = nodes.If | nodes.Try | nodes.For | nodes.While\n_AppendableNodeT = TypeVar(\n    \"_AppendableNodeT\", bound=_StatementNodes | nodes.While | nodes.FunctionDef\n)\n\n\nclass PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()\n        self._bottom_counter = 0\n        self.graph: PathGraph | None = None\n\n    def default(self, node: nodes.NodeNG, *args: Any) -> None:\n        for child in node.get_children():\n            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n            meth = getattr(self.visitor, \"visit\" + class_name, self.default)\n            self._cache[klass] = meth\n        return meth(node, *args)\n\n    def visitFunctionDef(self, node: nodes.FunctionDef) -> None:\n        if self.graph is not None:\n            # closure\n            pathnode = self._append_node(node)\n            self.tail = pathnode\n            self.dispatch_list(node.body)\n            bottom = f\"{self._bottom_counter}\"\n            self._bottom_counter += 1\n            self.graph.connect(self.tail, bottom)\n            self.graph.connect(node, bottom)\n            self.tail = bottom\n        else:\n            self.graph = PathGraph(node)\n            self.tail = node\n            self.dispatch_list(node.body)\n            self.graphs[f\"{self.classname}{node.name}\"] = self.graph\n            self.reset()\n\n    visitAsyncFunctionDef = visitFunctionDef\n\n    def visitSimpleStatement(self, node: _StatementNodes) -> None"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "enerate events to astroid checkers\n        walker.walk(node)\n        return True\n\n    def open(self) -> None:\n        \"\"\"Initialize counters.\"\"\"\n        MANAGER.always_load_extensions = self.config.unsafe_load_any_extension\n        MANAGER.max_inferable_values = self.config.limit_inference_results\n        MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)\n        MANAGER.module_denylist.update(self.config.ignored_modules)\n        MANAGER.prefer_stubs = self.config.prefer_stubs\n        if self.config.extension_pkg_whitelist:\n            MANAGER.extension_package_whitelist.update(\n                self.config.extension_pkg_whitelist\n            )\n        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n        # Display whatever messages are left on the reporter.\n        self.reporter.display_messages(report_nodes.Section())\n        if not self.file_state._is_base_filestate:\n            # load previous results if any\n            previous_stats = load_results(self.file_state.base_name)\n            self.reporter.on_close(self.stats, previous_stats)\n            if self.config.reports:\n                sect = self.make_reports(self.stats, previous_stats)\n            else:\n                sect = report_nodes.Section()\n\n            if self.config.reports:\n                self.reporter.display_reports(sect)\n\n            score_value = self._report_evaluation(verbose)\n            # save results if persistent run\n            if self.config.persistent:\n                save_results(self.stats, self.file_state.base_name)\n        else:\n            self.reporter.on_close(self.stats, LinterStats())\n            score_value = None\n        return score_value\n\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evalu"}], "retrieved_count": 10, "cost_time": 0.35884904861450195}
{"question": "How does Pylint implement its caching mechanism to improve performance?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements its caching mechanism to improve performance through several layers of caching: 1) AST caching - parsed AST representations are cached to avoid re-parsing unchanged files, 2) Configuration caching - parsed configuration settings are cached to avoid repeated parsing, 3) Import resolution caching - resolved import dependencies are cached to avoid repeated resolution, 4) Type inference caching - computed type information is cached to avoid redundant computation, 5) Message definition caching - message definitions are cached to avoid repeated registration, 6) Plugin loading caching - loaded plugins are cached to avoid repeated loading overhead, 7) File discovery caching - file patterns and discovery results are cached for repeated runs, 8) Analysis result caching - intermediate analysis results are cached when possible, 9) Memory-based caching - in-memory caching for frequently accessed data, 10) Persistent caching - some cache data can be persisted across sessions. These caching mechanisms significantly improve performance for repeated analysis runs, especially in large codebases where the same files are analyzed multiple times.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport pickle\nimport sys\nimport warnings\nfrom pathlib import Path\n\nfrom pylint.constants import PYLINT_HOME\nfrom pylint.utils import LinterStats\n\nPYLINT_HOME_AS_PATH = Path(PYLINT_HOME)\n\n\ndef _get_pdata_path(\n    base_name: Path, recurs: int, pylint_home: Path = PYLINT_HOME_AS_PATH\n) -> Path:\n    # We strip all characters that can't be used in a filename. Also strip '/' and\n    # '\\\\' because we want to create a single file, not sub-directories.\n    underscored_name = \"_\".join(\n        str(p.replace(\":\", \"_\").replace(\"/\", \"_\").replace(\"\\\\\", \"_\"))\n        for p in base_name.parts\n    )\n    return pylint_home / f\"{underscored_name}_{recurs}.stats\"\n\n\ndef load_results(\n    base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n\n    if not data_file.exists():\n        return None\n\n    try:\n        with open(data_file, \"rb\") as stream:\n            data = pickle.load(stream)\n            if not isinstance(data, LinterStats):\n                warnings.warn(\n                    \"You're using an old pylint cache with invalid data following \"\n                    f\"an upgrade, please delete '{data_file}'.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                raise TypeError\n            return data\n    except Exception:  # pylint: disable=broad-except\n        # There's an issue with the cache but we just continue as if it isn't there\n        return None\n\n\ndef save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n     "}, {"start_line": 1000, "end_line": 2424, "belongs_to": {"file_name": "caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "E\n) -> LinterStats | None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    data_file = _get_pdata_path(base, 1, pylint_home)\n\n    if not data_file.exists():\n        return None\n\n    try:\n        with open(data_file, \"rb\") as stream:\n            data = pickle.load(stream)\n            if not isinstance(data, LinterStats):\n                warnings.warn(\n                    \"You're using an old pylint cache with invalid data following \"\n                    f\"an upgrade, please delete '{data_file}'.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                raise TypeError\n            return data\n    except Exception:  # pylint: disable=broad-except\n        # There's an issue with the cache but we just continue as if it isn't there\n        return None\n\n\ndef save_results(\n    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME\n) -> None:\n    base = Path(base)\n    pylint_home = Path(pylint_home)\n    try:\n        pylint_home.mkdir(parents=True, exist_ok=True)\n    except OSError:  # pragma: no cover\n        print(f\"Unable to create directory {pylint_home}\", file=sys.stderr)\n    data_file = _get_pdata_path(base, 1)\n    try:\n        with open(data_file, \"wb\") as stream:\n            pickle.dump(results, stream)\n    except OSError as ex:  # pragma: no cover\n        print(f\"Unable to create file {data_file}: {ex}\", file=sys.stderr)\n"}, {"start_line": 0, "end_line": 1071, "belongs_to": {"file_name": "clear_lru_cache.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nfrom pylint.checkers.typecheck import _similar_names\nfrom pylint.checkers.utils import (\n    class_is_abstract,\n    in_for_else_branch,\n    infer_all,\n    is_overload_stub,\n    overridden_method,\n    safe_infer,\n    unimplemented_abstract_methods,\n)\n\nif TYPE_CHECKING:\n    from functools import _lru_cache_wrapper\n\n\ndef clear_lru_caches() -> None:\n    \"\"\"Clear caches holding references to AST nodes.\"\"\"\n    caches_holding_node_references: list[_lru_cache_wrapper[Any]] = [\n        class_is_abstract,\n        in_for_else_branch,\n        infer_all,\n        is_overload_stub,\n        overridden_method,\n        unimplemented_abstract_methods,\n        safe_infer,\n        _similar_names,\n    ]\n    for lru in caches_holding_node_references:\n        lru.cache_clear()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_caching.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# Pytest fixtures work like this by design\n# pylint: disable=redefined-outer-name\n\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nfrom pylint.constants import PYLINT_HOME\nfrom pylint.lint.caching import _get_pdata_path, load_results, save_results\nfrom pylint.utils import LinterStats\nfrom pylint.utils.linterstats import BadNames\n\nPYLINT_HOME_PATH = Path(PYLINT_HOME)\n\n\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,expected\",\n    [\n        [\"\", 1, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"_1.stats\"],\n        [\"\", 2, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"_2.stats\"],\n        [\"a/path\", 42, PYLINT_HOME_PATH, PYLINT_HOME_PATH / \"a_path_42.stats\"],\n    ],\n)\ndef test__get_pdata_path(\n    path: str, recur: int, pylint_home: Path, expected: Path\n) -> None:\n    assert _get_pdata_path(Path(path), recur, pylint_home) == expected\n\n\n@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Path type of *nix\")\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,expected\",\n    [\n        [\n            \"/workspace/MyDir/test.py\",\n            1,\n            Path(\"/root/.cache/pylint\"),\n            Path(\"/root/.cache/pylint\") / \"__workspace_MyDir_test.py_1.stats\",\n        ],\n        [\n            \"/workspace/MyDir/test.py\",\n            1,\n            Path(\"//host/computer/.cache\"),\n            Path(\"//host/computer/.cache\") / \"__workspace_MyDir_test.py_1.stats\",\n        ],\n    ],\n)\ndef test__get_pdata_path_nix(\n    path: str, recur: int, pylint_home: Path, expected: Path\n) -> None:\n    \"\"\"test__get_pdata_path but specifically for *nix system paths.\"\"\"\n    assert _get_pdata_path(Path(path), recur, pylint_home) == expected\n\n\n@pytest.mark.skipif(sys.platform != \"win32\", reason=\"Path type of windows\")\n@pytest.mark.parametrize(\n    \"path,recur,pylint_home,exp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n    ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    retur"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be done before initialization of other ancestors...\n        # messages store / checkers / reporter / astroid manager\n\n        # Attributes for reporters\n        self.reporter: reporters.BaseReporter | reporters.MultiReporter\n        if reporter:\n            self.set_reporter(reporter)\n        else:\n            self.set_reporter(TextReporter())\n        self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n        \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n\n        # Attributes for checkers and plugins\n        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (\n            collections.defaultdict(list)\n        )\n        \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}\n        \"\"\"Set of loaded plugin names.\"\"\"\n\n        # Attributes related to stats\n        self.stats = LinterStats()\n\n        # Attributes related to (command-line) options and their parsing\n     "}], "retrieved_count": 10, "cost_time": 0.3501417636871338}
{"question": "How does Pylint handle inline disabling of messages?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint handles inline disabling of messages through several mechanisms: 1) Comment-based disabling - using special comments like '# pylint: disable=message-id' to disable specific messages, 2) Line-level disabling - disabling messages for specific lines using '# pylint: disable=message-id', 3) Block-level disabling - disabling messages for code blocks using '# pylint: disable=message-id' and '# pylint: enable=message-id', 4) Category disabling - disabling entire categories of messages using '# pylint: disable=C,R,W,E,F', 5) All message disabling - disabling all messages for a line or block using '# pylint: disable=all', 6) Context-aware disabling - disabling messages based on specific conditions or contexts, 7) Suppression comments - using comments to explain why messages are disabled, 8) Configuration integration - inline disabling works with configuration file settings, 9) Message filtering - disabled messages are filtered out during the reporting phase, 10) Documentation - disabled messages are documented to help maintain code quality. This system allows developers to selectively suppress warnings while maintaining overall code quality standards.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport tokenize\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Literal\n\nfrom pylint import exceptions, interfaces\nfrom pylint.constants import (\n    MSG_STATE_CONFIDENCE,\n    MSG_STATE_SCOPE_CONFIG,\n    MSG_STATE_SCOPE_MODULE,\n    MSG_TYPES,\n    MSG_TYPES_LONG,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.message import MessageDefinition\nfrom pylint.typing import ManagedMessage, MessageDefinitionTuple\nfrom pylint.utils.pragma_parser import (\n    OPTION_PO,\n    InvalidPragmaError,\n    UnRecognizedOptionError,\n    parse_pragma,\n)\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass _MessageStateHandler:\n    \"\"\"Class that handles message disabling & enabling and processing of inline\n    pragma's.\n    \"\"\"\n\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,\n            \"disable-next\": self.disable_next,\n        }\n        self._bw_options_methods = {\n            \"disable-msg\": self._options_methods[\"disable\"],\n            \"enable-msg\": self._options_methods[\"enable\"],\n        }\n        self._pragma_lineno: dict[str, int] = {}\n        self._stashed_messages: defaultdict[\n            tuple[str, str], list[tuple[str | None, str]]\n        ] = defaultdict(list)\n        \"\"\"Some messages in the options (for --enable and --disable) are encountered\n        too early to warn about t"}, {"start_line": 16000, "end_line": 17960, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                 line=start[0],\n                                args=(\"disable=all\", \"skip-file\"),\n                            )\n                            self.linter.add_message(\"file-ignored\", line=start[0])\n                            self._ignore_file = True\n                            return\n                            # If we did not see a newline between the previous line and now,\n                            # we saw a backslash so treat the two lines as one.\n                        l_start = start[0]\n                        if not saw_newline:\n                            l_start -= 1\n                        try:\n                            meth(msgid, \"module\", l_start)\n                        except (\n                            exceptions.DeletedMessageError,\n                            exceptions.MessageBecameExtensionError,\n                        ) as e:\n                            self.linter.add_message(\n                                \"useless-option-value\",\n                                args=(pragma_repr.action, e),\n                                line=start[0],\n                                confidence=HIGH,\n                            )\n                        except exceptions.UnknownMessageError:\n                            self.linter.add_message(\n                                \"unknown-option-value\",\n                                args=(pragma_repr.action, msgid),\n                                line=start[0],\n                                confidence=HIGH,\n                            )\n\n            except UnRecognizedOptionError as err:\n                self.linter.add_message(\n                    \"unrecognized-inline-option\", args=err.token, line=start[0]\n                )\n                continue\n            except InvalidPragmaError as err:\n                self.linter.add_message(\n                    \"bad-inline-option\", args=err.token, line=start[0]\n                )\n                continue\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pragma_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport re\nfrom collections.abc import Generator\nfrom typing import NamedTuple\n\n# Allow stopping after the first semicolon/hash encountered,\n# so that an option can be continued with the reasons\n# why it is active or disabled.\nOPTION_RGX = r\"\"\"\n    (?:^\\s*\\#.*|\\s*|               # Comment line, or whitespaces,\n       \\s*\\#.*(?=\\#.*?\\bpylint:))  # or a beginning of an inline comment\n                                   # followed by \"pylint:\" pragma\n    (\\#                            # Beginning of comment\n    .*?                            # Anything (as little as possible)\n    \\bpylint:                      # pylint word and column\n    \\s*                            # Any number of whitespaces\n    ([^;#\\n]+))                    # Anything except semicolon or hash or\n                                   # newline (it is the second matched group)\n                                   # and end of the first matched group\n    [;#]{0,1}                      # From 0 to 1 repetition of semicolon or hash\n\"\"\"\nOPTION_PO = re.compile(OPTION_RGX, re.VERBOSE)\n\n\nclass PragmaRepresenter(NamedTuple):\n    action: str\n    messages: list[str]\n\n\nATOMIC_KEYWORDS = frozenset((\"disable-all\", \"skip-file\"))\nMESSAGE_KEYWORDS = frozenset(\n    (\"disable-next\", \"disable-msg\", \"enable-msg\", \"disable\", \"enable\")\n)\n# sorted is necessary because sets are unordered collections and ALL_KEYWORDS\n# string should not vary between executions\n# reverse is necessary in order to have the longest keywords first, so that, for example,\n# 'disable' string should not be matched instead of 'disable-all'\nALL_KEYWORDS = \"|\".join(\n    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)\n)\n\n\nTOKEN_SPECIFICATION = [\n    (\"KEYWORD\", rf\"\\b({ALL_KEYWO"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": (\n        \"error while parsing the configuration: %s\",\n        \"config-parse-error\",\n        \"Used when an exception occurred while parsing a pylint configuration file.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"I0001\": (\n        \"Unable to run raw checkers on built-in module %s\",\n        \"raw-checker-failed\",\n        \"Used to inform that a built-in module has not been checked \"\n        \"using the raw checkers.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0010\": (\n        \"Unable to consider inline option %r\",\n        \"bad-inline-option\",\n        \"Used when an inline option is either badly formatted or can't \"\n        \"be used inside modules.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0011\": (\n        \"Locally disabling %s (%s)\",\n        \"locally-disabled\",\n        \"Used when an inline option disables a message or a messages category.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0013\": (\n        \"Ignoring entire file\",\n        \"file-ignored\",\n        \"Used to inform that the file will not be checked\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0020\": (\n        \"Suppressed %s (from line %d)\",\n        \"suppressed-message\",\n        \"A message was triggered on a line, but suppressed explicitly \"\n        \"by a disable= comment in the file. This message is not \"\n        \"generated for messages that are ignored due to configuration \"\n        \"settings.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0021\": (\n        \"Useless suppression of %s\",\n        \"useless-suppression\",\n        \"Reported when a message is explicitly disabled for a line or \"\n        \"a block of code, but never triggered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"I0022\": (\n        'Pragma \"%s\" is deprecated, use \"%s\" instead',\n        \"deprecated-pragma\",\n        \"Some inline pylint options have been renamed or reworked, \"\n        \"only the most recent form should be used. \"\n        \"NOTE:skip-all is only available with pylint >= 0.26\",\n        {\n            \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n            \"scope\": WarningScope.LINE,\n            \"default_enabled\": False,\n        },\n    ),\n    \"E0001\": (\n        \"%s\",\n        \"syntax-error\",\n        \"Used when a syntax error is raised for a module.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0011\": (\n        \"Unrecognized file option %r\",\n        \"unrecognized-inline-option\",\n        \"Used when an unknown inline option is encountered.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"W0012\": (\n        \"Unknown option value for '%s', expected a valid pylint message and got '%s'\",\n        \"unk"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ine\n    pragma's.\n    \"\"\"\n\n    def __init__(self, linter: PyLinter) -> None:\n        self.linter = linter\n        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n            \"enable\": self.enable,\n            \"disable\": self.disable,\n            \"disable-next\": self.disable_next,\n        }\n        self._bw_options_methods = {\n            \"disable-msg\": self._options_methods[\"disable\"],\n            \"enable-msg\": self._options_methods[\"enable\"],\n        }\n        self._pragma_lineno: dict[str, int] = {}\n        self._stashed_messages: defaultdict[\n            tuple[str, str], list[tuple[str | None, str]]\n        ] = defaultdict(list)\n        \"\"\"Some messages in the options (for --enable and --disable) are encountered\n        too early to warn about them.\n\n        i.e. before all option providers have been fully parsed. Thus, this dict stores\n        option_value and msg_id needed to (later) emit the messages keyed on module names.\n        \"\"\"\n\n    def _set_one_msg_status(\n        self, scope: str, msg: MessageDefinition, line: int | None, enable: bool\n    ) -> None:\n        \"\"\"Set the status of an individual message.\"\"\"\n        if scope in {\"module\", \"line\"}:\n            assert isinstance(line, int)  # should always be int inside module scope\n\n            self.linter.file_state.set_msg_status(msg, line, enable, scope)\n            if not enable and msg.symbol != \"locally-disabled\":\n                self.linter.add_message(\n                    \"locally-disabled\", line=line, args=(msg.symbol, msg.msgid)\n                )\n        else:\n            msgs = self._msgs_state\n            msgs[msg.msgid] = enable\n\n    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinitio"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_pragma_parser.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nimport pytest\n\nfrom pylint.utils.pragma_parser import (\n    OPTION_PO,\n    InvalidPragmaError,\n    UnRecognizedOptionError,\n    parse_pragma,\n)\n\n\ndef test_simple_pragma() -> None:\n    comment = \"#pylint: disable = missing-docstring\"\n    match = OPTION_PO.search(comment)\n    assert match\n    for pragma_repr in parse_pragma(match.group(2)):\n        assert pragma_repr.action == \"disable\"\n        assert pragma_repr.messages == [\"missing-docstring\"]\n\n\ndef test_disable_checker_with_number_in_name() -> None:\n    comment = \"#pylint: disable = j3-custom-checker\"\n    match = OPTION_PO.search(comment)\n    assert match\n    for pragma_repr in parse_pragma(match.group(2)):\n        assert pragma_repr.action == \"disable\"\n        assert pragma_repr.messages == [\"j3-custom-checker\"]\n\n\ndef test_simple_pragma_no_messages() -> None:\n    comment = \"#pylint: skip-file\"\n    match = OPTION_PO.search(comment)\n    assert match\n    for pragma_repr in parse_pragma(match.group(2)):\n        assert pragma_repr.action == \"skip-file\"\n        assert not pragma_repr.messages\n\n\ndef test_simple_pragma_multiple_messages() -> None:\n    comment = \"#pylint: disable = missing-docstring, invalid-name\"\n    match = OPTION_PO.search(comment)\n    assert match\n    for pragma_repr in parse_pragma(match.group(2)):\n        assert pragma_repr.action == \"disable\"\n        assert pragma_repr.messages == [\"missing-docstring\", \"invalid-name\"]\n\n\ndef test_multiple_pragma_multiple_messages() -> None:\n    comment = \"#pylint: disable = missing-docstring, invalid-name, enable = R0202, no-staticmethod-decorator\"\n    match = OPTION_PO.search(comment)\n    assert match\n    res = list(parse_pragma(match.group(2)))\n    assert res[0].action == \"disable\"\n    assert res[0].messages == [\"missing-docstring\", \"in"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " except KeyError:\n                        meth = self._bw_options_methods[pragma_repr.action]\n                        # found a \"(dis|en)able-msg\" pragma deprecated suppression\n                        self.linter.add_message(\n                            \"deprecated-pragma\",\n                            line=start[0],\n                            args=(\n                                pragma_repr.action,\n                                pragma_repr.action.replace(\"-msg\", \"\"),\n                            ),\n                        )\n                    for msgid in pragma_repr.messages:\n                        # Add the line where a control pragma was encountered.\n                        if pragma_repr.action in control_pragmas:\n                            self._pragma_lineno[msgid] = start[0]\n\n                        if (pragma_repr.action, msgid) == (\"disable\", \"all\"):\n                            self.linter.add_message(\n                                \"deprecated-pragma\",\n                                line=start[0],\n                                args=(\"disable=all\", \"skip-file\"),\n                            )\n                            self.linter.add_message(\"file-ignored\", line=start[0])\n                            self._ignore_file = True\n                            return\n                            # If we did not see a newline between the previous line and now,\n                            # we saw a backslash so treat the two lines as one.\n                        l_start = start[0]\n                        if not saw_newline:\n                            l_start -= 1\n                        try:\n                            meth(msgid, \"module\", l_start)\n                        except (\n                            exceptions.DeletedMessageError,\n                            exceptions.MessageBecameExtensionError,\n                        ) as e:\n                            self.linter.add_message(\n                                \"useless-option-value\",\n         "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "file_state.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                # For block nodes first_ is their definition line. For example, we\n                # set the state of line zero for a module to allow disabling\n                # invalid-name for the module. For example:\n                # 1. # pylint: disable=invalid-name\n                # 2. ...\n                # OR\n                # 1. \"\"\"Module docstring\"\"\"\n                # 2. # pylint: disable=invalid-name\n                # 3. ...\n                #\n                # But if we already visited line 0 we don't need to set its state again\n                # 1. # pylint: disable=invalid-name\n                # 2. # pylint: enable=invalid-name\n                # 3. ...\n                # The state should come from line 1, not from line 2\n                # Therefore, if the 'fromlineno' is already in the states we just start\n                # with the lineno we were originally visiting.\n                # pylint: enable=useless-suppression\n                if (\n                    first_ == node.fromlineno\n                    and first_ >= firstchildlineno\n                    and node.fromlineno in self._module_msgs_state.get(msg.msgid, ())\n                ):\n                    first_ = lineno\n\n            else:\n                first_ = lineno\n                last_ = last\n            for line in range(first_, last_ + 1):\n                # Do not override existing entries. This is especially important\n                # when parsing the states for a scoped node where some line-disables\n                # have already been parsed.\n                if (\n                    (\n                        isinstance(node, nodes.Module)\n                        and node.fromlineno <= line < lineno\n                    )\n                    or (\n                        not isinstance(node, nodes.Module)\n                        and node.fromlineno < line < lineno\n                    )\n                ) and line in self._module_msgs_state.get(msg.msgid, ()):\n                    continue\n     "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "message_state_handler.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_id_managed_msgs.append(managed)\n\n    def disable(\n        self,\n        msgid: str,\n        scope: str = \"package\",\n        line: int | None = None,\n        ignore_unknown: bool = False,\n    ) -> None:\n        \"\"\"Disable a message for a scope.\"\"\"\n        self._set_msg_status(\n            msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown\n        )\n        self._register_by_id_managed_msg(msgid, line)\n\n    def disable_next(\n        self,\n        msgid: str,\n        _: str = \"package\",\n        line: int | None = None,\n        ignore_unknown: bool = False,\n    ) -> None:\n        \"\"\"Disable a message for the next line.\"\"\"\n        if not line:\n            raise exceptions.NoLineSuppliedError\n        self._set_msg_status(\n            msgid,\n            enable=False,\n            scope=\"line\",\n            line=line + 1,\n            ignore_unknown=ignore_unknown,\n        )\n        self._register_by_id_managed_msg(msgid, line + 1)\n\n    def enable(\n        self,\n        msgid: str,\n        scope: str = \"package\",\n        line: int | None = None,\n        ignore_unknown: bool = False,\n    ) -> None:\n        \"\"\"Enable a message for a scope.\"\"\"\n        self._set_msg_status(\n            msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown\n        )\n        self._register_by_id_managed_msg(msgid, line, is_disabled=False)\n\n    def disable_noerror_messages(self) -> None:\n        \"\"\"Disable message categories other than `error` and `fatal`.\"\"\"\n        for msgcat in self.linter.msgs_store._msgs_by_category:\n            if msgcat in {\"E\", \"F\"}:\n                continue\n            self.disable(msgcat)\n\n    def list_messages_enabled(self) -> None:\n        emittable, non_emittable = self.linter.msgs_store.find_emittable_messages()\n        enabled: list[str] = []\n        disabled: list[str] = []\n        for message in emittable:\n            if self.is_message_enabled(message.msgid):\n                enabled.append(f\"  {message.symbol} ({message.m"}], "retrieved_count": 10, "cost_time": 0.3526949882507324}
{"question": "How does Pylint support custom linting rules through its API?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint supports custom linting rules through its API through several mechanisms: 1) BaseChecker inheritance - custom checkers inherit from BaseChecker to implement specific analysis logic, 2) Plugin registration - custom checkers can be registered with the linter through the plugin system, 3) AST access - custom checkers have full access to the AST representation for sophisticated analysis, 4) Message creation - custom checkers can create and emit diagnostic messages using the add_message() method, 5) Configuration integration - custom checkers can define their own configuration options, 6) Lifecycle management - custom checkers can implement open() and close() methods for initialization and cleanup, 7) Node type handling - custom checkers can implement visit and leave methods for specific AST node types, 8) Context access - custom checkers have access to analysis context and configuration, 9) Testing support - custom checkers can be tested using Pylint's testing framework, 10) Documentation generation - custom checker options and messages are automatically included in help output. This API allows developers to create sophisticated custom analysis rules that integrate seamlessly with Pylint's core functionality.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Callable\nfrom pathlib import Path\n\nimport pytest\n\nfrom pylint import checkers\nfrom pylint.checkers import BaseChecker\nfrom pylint.lint import PyLinter\nfrom pylint.lint.run import _cpu_count\nfrom pylint.reporters import BaseReporter\nfrom pylint.testutils import MinimalTestReporter\n\nHERE = Path(__file__).parent\n\n\n@pytest.fixture()\ndef tests_directory() -> Path:\n    return HERE\n\n\n@pytest.fixture\ndef linter(\n    checker: type[BaseChecker] | None,\n    register: Callable[[PyLinter], None] | None,\n    enable: str | None,\n    disable: str | None,\n    reporter: type[BaseReporter],\n) -> PyLinter:\n    _linter = PyLinter()\n    _linter.set_reporter(reporter())\n    checkers.initialize(_linter)\n    if register:\n        register(_linter)\n    if checker:\n        _linter.register_checker(checker(_linter))\n    if disable:\n        for msg in disable:\n            _linter.disable(msg)\n    if enable:\n        for msg in enable:\n            _linter.enable(msg)\n    os.environ.pop(\"PYLINTRC\", None)\n    return _linter\n\n\n@pytest.fixture(scope=\"module\")\ndef checker() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef register() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef enable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> None:\n    return None\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[MinimalTestReporter]:\n    return MinimalTestReporter\n\n\ndef pytest_addoption(parser: pytest.Parser) -> None:\n    parser.addoption(\n        \"--primer-stdlib\",\n        action=\"store_true\",\n        default=False,\n        help=\"Run primer stdlib tests\",\n    )\n    parser.addoption(\n        \"--minimal-mes"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    This class needs to support pickling for parallel linting to work. The exception\n    is reporter member; see check_parallel function for more details.\n    \"\"\"\n\n    name = MAIN_CHECKER_NAME\n    msgs = MSGS\n    # Will be used like this : datetime.now().strftime(crash_file_path)\n    crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H-%M-%S.txt\"\n\n    option_groups_descs = {\n        \"Messages control\": \"Options controlling analysis messages\",\n        \"Reports\": \"Options related to output formatting and reporting\",\n    }\n\n    def __init__(\n        self,\n        options: Options = (),\n        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n        option_groups: tuple[tuple[str, str], ...] = (),\n        # TODO: Deprecate passing the pylintrc parameter\n        pylintrc: str | None = None,  # pylint: disable=unused-argument\n    ) -> None:\n        _ArgumentsManager.__init__(self, prog=\"pylint\")\n        _MessageStateHandler.__init__(self, self)\n\n        # Some stuff has to be "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "base_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n@functools.total_ordering\nclass BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n    # reports issued by this checker\n    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()\n    # mark this checker as enabled or not.\n    enabled: bool = True\n\n    def __init__(self, linter: PyLinter) -> None:\n        \"\"\"Checker instances should have the linter as argument.\"\"\"\n        if self.name is not None:\n            self.name = self.name.lower()\n        self.linter = linter\n        _ArgumentsProvider.__init__(self, linter)\n\n    def __gt__(self, other: Any) -> bool:\n        \"\"\"Permits sorting checkers for stable doc and tests.\n\n        The main checker is always the first one, then builtin checkers in alphabetical\n        order, then extension checkers in alp"}, {"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_path\n        with lint.augmented_sys_path(extra_sys_paths):\n            assert sys.path == expected\n        assert sys.path == fake_path\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> list[str]:\n    return [\"I\"]\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[testutils.GenericTestReporter]:\n    return testutils.GenericTestReporter\n\n\n@pytest.fixture\ndef initialized_linter(linter: PyLinter) -> PyLinter:\n    linter.open()\n    linter.set_current_module(\"long_test_file\", \"long_test_file\")\n    linter.file_state = FileState(\n        \"long_test_file\",\n        linter.msgs_store,\n        linter.get_ast(\n            str(join(REGRTEST_DATA_DIR, \"long_test_file.py\")), \"long_test_file\"\n        ),\n    )\n    return linter\n\n\ndef test_pylint_visit_method_taken_in_account(linter: PyLinter) -> None:\n    class CustomChecker(checkers.BaseChecker):\n        name = \"custom\"\n        msgs = {\"W9999\": (\"\", \"custom\", \"\")}\n\n        @only_required_for_messages(\"custom\")\n        def visit_class(self, _: nodes.ClassDef) -> None:\n            pass\n\n    linter.register_checker(CustomChecker(linter))\n    linter.open()\n    out = StringIO()\n    linter.set_reporter(text.TextReporter(out))\n    linter.check([\"abc\"])\n\n\ndef test_enable_message(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.disable(\"W0101\", scope=\"package\")\n    linter.disable(\"W0102\", scope=\"module\", line=1)\n    assert not linter.is_message_enabled(\"W0101\")\n    assert not linter.is_message_enabled(\"W0102\", 1)\n    linter.set_current_module(\"tutu\")\n    assert not linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.enable(\"W0101\", scope=\"package\")\n    linter.enable(\"W0102\", scope=\"module\", line=1)\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\", 1)\n\n\ndef test_enable_message_category(initialized_linter: PyLinter) -> None:\n    l"}, {"start_line": 0, "end_line": 1394, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint [options] modules_or_packages.\n\nCheck that module(s) satisfy a coding standard (and more !).\n\npylint --help\n\nDisplay this help message and exit.\n\npylint --help-msg <msg-id>[,<msg-id>]\n\nDisplay help messages about given message identifiers and exit.\n\"\"\"\nimport sys\n\nfrom pylint.config.exceptions import ArgumentPreprocessingError\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import discover_package_path\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.run import Run\nfrom pylint.lint.utils import _augment_sys_path, augmented_sys_path\n\n__all__ = [\n    \"ArgumentPreprocessingError\",\n    \"PyLinter\",\n    \"Run\",\n    \"_augment_sys_path\",\n    \"augmented_sys_path\",\n    \"check_parallel\",\n    \"discover_package_path\",\n    \"load_results\",\n    \"report_messages_by_module_stats\",\n    \"report_messages_stats\",\n    \"report_total_messages_stats\",\n    \"save_results\",\n]\n\nif __name__ == \"__main__\":\n    Run(sys.argv[1:])\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "custom.py", "upper_path": "/data2/raymone/swebench-repos/pylint/examples", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n# Checkers should always inherit from `BaseChecker`.\n\n\nclass MyAstroidChecker(BaseChecker):\n    \"\"\"Add class member attributes to the class local's dictionary.\"\"\"\n\n    # The name defines a custom section of the config for this checker.\n    name = \"custom\"\n    # This class variable declares the messages (i.e. the warnings and errors)\n    # that the checker can emit.\n    msgs = {\n        # Each message has a code, a message that the user will see,\n        # a unique symbol that identifies the message,\n        # and a detailed help message\n        # that will be included in the documentation.\n        \"W0001\": (\"Message that will be emitted\", \"message-symbol\", \"Message help\")\n    }\n    # This class variable declares the options\n    # that are configurable by the user.\n    options = (\n        # Each option definition has a name which is used on the command line\n        # and in config files, and a dictionary of arguments\n        # (similar to argparse.ArgumentParser.add_argument).\n        (\n            \"store-locals-indicator\",\n            {\n                \"default\": \"properties\",\n                \"help\": (\n                    \"The expression name that indicates that the locals should \"\n                    \"be stored\"\n                ),\n            },\n        ),\n    )\n\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`.nodes.Call` node is visited.\n\n        See :mod:`astroid` for the description of available nodes.\n        \"\"\"\n        if not (\n            isinstance(node.func, nodes.Attribute)\n            and isinstance(node.func.expr, nodes.Name)\n            and node.func.expr.name == self.linter.config.store_locals_indicator\n            and node.func.attrname == \"create\"\n        ):\n            return\n        in_class = node.frame()\n        for p"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   ManagedMessage,\n    MessageDefinitionTuple,\n    MessageLocationTuple,\n    ModuleDescriptionDict,\n    Options,\n)\nfrom pylint.utils import ASTWalker, FileState, LinterStats, utils\n\nMANAGER = astroid.MANAGER\n\n\nclass GetAstProtocol(Protocol):\n    def __call__(\n        self, filepath: str, modname: str, data: str | None = None\n    ) -> nodes.Module: ...\n\n\ndef _read_stdin() -> str:\n    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n    assert isinstance(sys.stdin, TextIOWrapper)\n    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n    return sys.stdin.read()\n\n\ndef _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n    qname = reporter_class\n    module_part = astroid.modutils.get_module_part(qname)\n    module = astroid.modutils.load_module_from_name(module_part)\n    class_name = qname.split(\".\")[-1]\n    klass = getattr(module, class_name)\n    assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n    return klass  # type: ignore[no-any-return]\n\n\n# Python Linter class #########################################################\n\n# pylint: disable-next=consider-using-namedtuple-or-dataclass\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0001\": (\n        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n        \"%s: %s\",\n        \"astroid-error\",\n        \"Used when an unexpected error occurred while building the \"\n        \"Astroid  representation. This is usually accompanied by a \"\n        \"traceback. Please report such errors !\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0010\": (\n        \"error while code parsing: %s\",\n        \"parse-error\",\n        \"Used when an exception occurred while building the Astroid \"\n        \"representation which could be handled by astroid.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0011\""}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}], "retrieved_count": 10, "cost_time": 0.3348879814147949}
{"question": "How does Pylint's framework handle version compatibility with Python updates?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint's framework handles version compatibility with Python updates through several strategies: 1) Version detection - automatic detection of Python version and available features, 2) Feature flags - conditional enabling of features based on Python version compatibility, 3) Syntax adaptation - adapting to new Python syntax features and language constructs, 4) AST compatibility - ensuring AST analysis works with different Python versions, 5) Import resolution updates - adapting import resolution to handle new module structures, 6) Type annotation support - supporting new type annotation features as they are introduced, 7) Deprecation handling - gracefully handling deprecated features and syntax, 8) Backward compatibility - maintaining compatibility with older Python versions when possible, 9) Testing infrastructure - comprehensive testing across multiple Python versions, 10) Documentation updates - keeping documentation current with Python version changes. This approach allows Pylint to work effectively across different Python versions while taking advantage of new language features when available.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1376, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nimport operator\nimport re\nimport sys\nfrom pathlib import Path\n\n# This is faster/terser without f-strings:\n# '\"%d%d%d\" % sys.version_info[:3]': (best of 5: 214 nanoseconds per loop)\n# '\"\".join(str(x) for x in sys.version_info[:3])'`: best of 5: 546 nanoseconds per loop\n# pylint: disable-next=consider-using-f-string\nSYS_VERS_STR = \"%d%d%d\" % sys.version_info[:3]  # noqa: UP031\nTITLE_UNDERLINES = [\"\", \"=\", \"-\", \".\"]\nUPDATE_OPTION = \"--update-functional-output\"\nUPDATE_FILE = Path(\"pylint-functional-test-update\")\n# Common sub-expressions.\n_MESSAGE = {\"msg\": r\"[a-z][a-z\\-]+\"}\n# Matches a #,\n#  - followed by a comparison operator and a Python version (optional),\n#  - followed by a line number with a +/- (optional),\n#  - followed by a list of bracketed message symbols.\n# Used to extract expected messages from testdata files.\n_EXPECTED_RE = re.compile(\n    r\"\\s*#\\s*(?:(?P<line>[+-]?[0-9]+):)?\"  # pylint: disable=consider-using-f-string\n    r\"(?:(?P<op>[><=]+) *(?P<version>[0-9.]+):)?\"\n    r\"\\s*\\[(?P<msgs>{msg}(?:,\\s*{msg})*)]\".format(**_MESSAGE)\n)\n\n_OPERATORS = {\">\": operator.gt, \"<\": operator.lt, \">=\": operator.ge, \"<=\": operator.le}\n"}, {"start_line": 0, "end_line": 1364, "belongs_to": {"file_name": "__pkginfo__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"This module exists for compatibility reasons.\n\nIt's updated via tbump, do not modify.\n\"\"\"\n\nfrom __future__ import annotations\n\n__version__ = \"4.0.0-dev0\"\n\n\ndef get_numversion_from_version(v: str) -> tuple[int, int, int]:\n    \"\"\"Kept for compatibility reason.\n\n    See https://github.com/pylint-dev/pylint/issues/4399\n    https://github.com/pylint-dev/pylint/issues/4420,\n    \"\"\"\n    version = v.replace(\"pylint-\", \"\")\n    result_version = []\n    for number in version.split(\".\")[0:3]:\n        try:\n            result_version.append(int(number))\n        except ValueError:\n            current_number = \"\"\n            for char in number:\n                if char.isdigit():\n                    current_number += char\n                else:\n                    break\n            try:\n                result_version.append(int(current_number))\n            except ValueError:\n                result_version.append(0)\n    while len(result_version) != 3:\n        result_version.append(0)\n\n    return tuple(result_version)  # type: ignore[return-value] # mypy can't infer the length\n\n\nnumversion = get_numversion_from_version(__version__)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nimport astroid\nimport platformdirs\n\nfrom pylint.__pkginfo__ import __version__\nfrom pylint.typing import MessageTypesFullName\n\nPY311_PLUS = sys.version_info[:2] >= (3, 11)\nPY312_PLUS = sys.version_info[:2] >= (3, 12)\nPY314_PLUS = sys.version_info[:2] >= (3, 14)\n\nIS_PYPY = platform.python_implementation() == \"PyPy\"\n\nPY_EXTS = (\".py\", \".pyc\", \".pyo\", \".pyw\", \".so\", \".dll\")\n\nMSG_STATE_CONFIDENCE = 2\n_MSG_ORDER = \"EWRCIF\"\nMSG_STATE_SCOPE_CONFIG = 0\nMSG_STATE_SCOPE_MODULE = 1\n\n# The line/node distinction does not apply to fatal errors and reports.\n_SCOPE_EXEMPT = \"FR\"\n\nMSG_TYPES: dict[str, MessageTypesFullName] = {\n    \"I\": \"info\",\n    \"C\": \"convention\",\n    \"R\": \"refactor\",\n    \"W\": \"warning\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline i"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unsupported_version.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Checker for features used that are not supported by all python versions\nindicated by the py-version setting.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import (\n    only_required_for_messages,\n    safe_infer,\n    uninferable_final_decorators,\n)\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass UnsupportedVersionChecker(BaseChecker):\n    \"\"\"Checker for features that are not supported by all python versions\n    indicated by the py-version setting.\n    \"\"\"\n\n    name = \"unsupported_version\"\n    msgs = {\n        \"W2601\": (\n            \"F-strings are not supported by all versions included in the py-version setting\",\n            \"using-f-string-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.6 and pylint encounters \"\n            \"an f-string.\",\n        ),\n        \"W2602\": (\n            \"typing.final is not supported by all versions included in the py-version setting\",\n            \"using-final-decorator-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.8 and pylint encounters \"\n            \"a ``typing.final`` decorator.\",\n        ),\n        \"W2603\": (\n            \"Exception groups are not supported by all versions included in the py-version setting\",\n            \"using-exception-groups-in-unsupported-version\",\n            \"Used when the py-version set by the user is lower than 3.11 and pylint encounters \"\n            \"``except*`` or `ExceptionGroup``.\",\n        ),\n        \"W2604\": (\n            \"Generic type syntax (PEP 695) is not supported by all versions included in the py-versi"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unittest_reporting.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/reporters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s new\n    parameters do not break on previous versions.\n    \"\"\"\n    output = StringIO()\n    linter.reporter.out = output\n    linter.config.msg_template = \"{path}:{line}:{categ}:({a_second_new_option:03d})\"\n    linter.open()\n    with pytest.warns(UserWarning) as records:\n        linter.set_current_module(\"my_mod\")\n        assert len(records) == 2\n        assert \"Don't recognize the argument 'categ'\" in records[0].message.args[0]\n    assert (\n        \"Don't recognize the argument 'a_second_new_option'\"\n        in records[1].message.args[0]\n    )\n\n    linter.add_message(\"C0301\", line=1, args=(1, 2))\n    linter.add_message(\n        \"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4)\n    )\n\n    out_lines = output.getvalue().split(\"\\n\")\n    assert out_lines[1] == \"my_mod:1::()\"\n    assert out_lines[2] == \"my_mod:2::()\"\n\n\ndef test_template_option_with_header(linter: PyLinter) -> None:\n    output = StringIO()\n    linter.reporter.out = output\n    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n    linter.open()\n    linter.set_current_module(\"my_mod\")\n\n    linter.add_message(\"C0301\", line=1, args=(1, 2))\n    linter.add_message(\n        \"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4)\n    )\n\n    out_lines = output.getvalue().split(\"\\n\")\n    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n    assert out_lines[2] == '{ \"Category\": \"convention\" }'\n\n\ndef test_parseable_output_deprecated() -> None:\n    with warnings.catch_warnings(record=True) as cm:\n        warnings.simplefilter(\"always\")\n        ParseableTextReporter()\n\n    assert len(cm) == 1\n    assert isinstance(cm[0].message, DeprecationWarning)\n\n\ndef test_parseable_output_regression() -> None:\n    output = StringIO()\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n        linter = PyLinter(reporter=ParseableTextReporter())\n\n    checkers.initialize(linter)\n    linter.config.persistent = 0\n    linter.rep"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "lint_module_test.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport csv\nimport operator\nimport platform\nimport sys\nfrom collections import Counter\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import TextIO\n\nimport pytest\nfrom _pytest.config import Config\n\nfrom pylint import checkers\nfrom pylint.config.config_initialization import _config_initialization\nfrom pylint.lint import PyLinter\nfrom pylint.message.message import Message\nfrom pylint.testutils.constants import _EXPECTED_RE, _OPERATORS, UPDATE_OPTION\n\n# need to import from functional.test_file to avoid cyclic import\nfrom pylint.testutils.functional.test_file import (\n    FunctionalTestFile,\n    NoFileError,\n    parse_python_version,\n)\nfrom pylint.testutils.output_line import OutputLine\nfrom pylint.testutils.reporter_for_tests import FunctionalTestReporter\n\nMessageCounter = Counter[tuple[int, str]]\n\nPYLINTRC = Path(__file__).parent / \"testing_pylintrc\"\n\n\nclass LintModuleTest:\n    maxDiff = None\n\n    def __init__(\n        self, test_file: FunctionalTestFile, config: Config | None = None\n    ) -> None:\n        _test_reporter = FunctionalTestReporter()\n        self._linter = PyLinter()\n        self._linter.config.persistent = 0\n        checkers.initialize(self._linter)\n\n        # See if test has its own .rc file, if so we use that one\n        rc_file: Path | str = PYLINTRC\n        try:\n            rc_file = test_file.option_file\n            self._linter.disable(\"suppressed-message\")\n            self._linter.disable(\"locally-disabled\")\n            self._linter.disable(\"useless-suppression\")\n        except NoFileError:\n            pass\n\n        self._test_file = test_file\n        try:\n            args = [test_file.source]\n        except NoFileError:\n            # If we're still raising NoFileError t"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "constants.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng\",\n    \"E\": \"error\",\n    \"F\": \"fatal\",\n}\nMSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}\n\nMSG_TYPES_STATUS = {\"I\": 0, \"C\": 16, \"R\": 8, \"W\": 4, \"E\": 2, \"F\": 1}\n\n# You probably don't want to change the MAIN_CHECKER_NAME\n# This would affect rcfile generation and retro-compatibility\n# on all project using [MAIN] in their rcfile.\nMAIN_CHECKER_NAME = \"main\"\n\nDEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(\"pylint\")\n\nDEFAULT_IGNORE_LIST = (\"CVS\",)\n\n\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\nastroid {astroid.__version__}\nPython {sys.version}\"\"\"\n\nHUMAN_READABLE_TYPES = {\n    \"file\": \"file\",\n    \"module\": \"module\",\n    \"const\": \"constant\",\n    \"class\": \"class\",\n    \"function\": \"function\",\n    \"method\": \"method\",\n    \"attr\": \"attribute\",\n    \"argument\": \"argument\",\n    \"variable\": \"variable\",\n    \"class_attribute\": \"class attribute\",\n    \"class_const\": \"class constant\",\n    \"inlinevar\": \"inline iteration\",\n    \"typevar\": \"type variable\",\n    \"typealias\": \"type alias\",\n}\n\n# ignore some messages when emitting useless-suppression:\n# - cyclic-import: can show false positives due to incomplete context\n# - deprecated-{module, argument, class, method, decorator}:\n#   can cause false positives for multi-interpreter projects\n#   when linting with an interpreter on a lower python version\nINCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset(\n    [\n        \"R0401\",  # cyclic-import\n        \"W0402\",  # deprecated-module\n        \"W1505\",  # deprecated-method\n        \"W1511\",  # deprecated-argument\n        \"W1512\",  # deprecated-class\n        \"W1513\",  # deprecated-decorator\n        \"R0801\",  # duplicate-code\n    ]\n)\n\n\ndef _get_pylint_home() -> str:\n    \"\"\"Return the pylint home.\"\"\"\n    if \"PYLINTHOME\" in os.environ:\n        return os.environ[\"PYLINTHOME\"]\n    return DEFAULT_PYLINT_HOME\n\n\nPYLINT_HOME = _get_pylint_home()\n\nTYPING_NORETURN = frozenset(\n    (\n        \"typing.NoReturn\",\n        \"ty"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_deleted_message_ids.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom functools import cache\nfrom typing import NamedTuple\n\n\nclass DeletedMessage(NamedTuple):\n    msgid: str\n    symbol: str\n    old_names: list[tuple[str, str]] = []\n\n\nDELETED_MSGID_PREFIXES: list[int] = []\n\nDELETED_MESSAGES_IDS = {\n    # Everything until the next comment is from the PY3K+ checker\n    \"https://github.com/pylint-dev/pylint/pull/4942\": [\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"E1601\", \"print-statement\"),\n        DeletedMessage(\"E1602\", \"parameter-unpacking\"),\n        DeletedMessage(\n            \"E1603\", \"unpacking-in-except\", [(\"W0712\", \"old-unpacking-in-except\")]\n        ),\n        DeletedMessage(\n            \"E1604\", \"old-raise-syntax\", [(\"W0121\", \"old-old-raise-syntax\")]\n        ),\n        DeletedMessage(\"E1605\", \"backtick\", [(\"W0333\", \"old-backtick\")]),\n        DeletedMessage(\"E1609\", \"import-star-module-level\"),\n        DeletedMessage(\"W1601\", \"apply-builtin\"),\n        DeletedMessage(\"W1602\", \"basestring-builtin\"),\n        DeletedMessage(\"W1603\", \"buffer-builtin\"),\n        DeletedMessage(\"W1604\", \"cmp-builtin\"),\n        DeletedMessage(\"W1605\", \"coerce-builtin\"),\n        DeletedMessage(\"W1606\", \"execfile-builtin\"),\n        DeletedMessage(\"W1607\", \"file-builtin\"),\n        DeletedMessage(\"W1608\", \"long-builtin\"),\n        DeletedMessage(\"W1609\", \"raw_input-builtin\"),\n        DeletedMessage(\"W1610\", \"reduce-builtin\"),\n        DeletedMessage(\"W1611\", \"standarderror-builtin\"),\n        DeletedMessage(\"W1612\", \"unicode-builtin\"),\n        DeletedMessage(\"W1613\", \"xrange-builtin\"),\n        DeletedMessage(\"W1614\", \"coerce-method\"),\n        DeletedMessage(\"W1615\", \"delslice-method\"),\n        DeletedMessage(\"W1616\", \"getslice-method\"),\n        DeletedMessage(\"W16"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport functools\nimport os\nimport sys\nimport tokenize\nimport traceback\nfrom collections import defaultdict\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom io import TextIOWrapper\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import ModuleType\nfrom typing import Any, Protocol\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import checkers, exceptions, interfaces, reporters\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.config.arguments_manager import _ArgumentsManager\nfrom pylint.constants import (\n    MAIN_CHECKER_NAME,\n    MSG_TYPES,\n    MSG_TYPES_STATUS,\n    WarningScope,\n)\nfrom pylint.interfaces import HIGH\nfrom pylint.lint.base_options import _make_linter_options\nfrom pylint.lint.caching import load_results, save_results\nfrom pylint.lint.expand_modules import (\n    _is_ignored_file,\n    discover_package_path,\n    expand_modules,\n)\nfrom pylint.lint.message_state_handler import _MessageStateHandler\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.lint.report_functions import (\n    report_messages_by_module_stats,\n    report_messages_stats,\n    report_total_messages_stats,\n)\nfrom pylint.lint.utils import (\n    augmented_sys_path,\n    get_fatal_error_message,\n    prepare_crash_report,\n)\nfrom pylint.message import Message, MessageDefinition, MessageDefinitionStore\nfrom pylint.reporters.base_reporter import BaseReporter\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.reporters.text import ColorizedTextReporter, TextReporter\nfrom pylint.reporters.ureports import nodes as report_nodes\nfrom pylint.typing import (\n    DirectoryNamespaceDict,\n    FileItem,\n "}], "retrieved_count": 10, "cost_time": 0.3575606346130371}
{"question": "How does Pylint implement its plugin API for third-party extensions?", "answer": null, "relative_code_list": null, "ground_truth": "Pylint implements its plugin API for third-party extensions through several key components: 1) Plugin registration system - standardized way to register custom checkers and reporters with the linter, 2) Base class interfaces - BaseChecker and BaseReporter provide consistent interfaces for all plugins, 3) Dynamic loading - plugins can be loaded at runtime based on configuration or discovery, 4) Configuration integration - plugin options are automatically integrated into Pylint's configuration system, 5) Message system integration - plugins can define and emit their own diagnostic messages, 6) AST access - plugins have full access to the AST representation for sophisticated analysis, 7) Lifecycle management - plugins can implement initialization and cleanup methods, 8) Error isolation - plugin errors are isolated and don't crash the entire system, 9) Documentation generation - plugin options and messages are automatically included in help output, 10) Testing support - plugins can be tested independently using Pylint's testing framework. This API design allows third-party developers to extend Pylint's capabilities while maintaining compatibility and consistency with the core system.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 585, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom pylint.utils import register_plugins\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\ndef initialize(linter: PyLinter) -> None:\n    \"\"\"Initialize linter with checkers in the extensions' directory.\"\"\"\n    register_plugins(linter, __path__[0])\n\n\n__all__ = [\"initialize\"]\n"}, {"start_line": 0, "end_line": 902, "belongs_to": {"file_name": "dummy_plugin.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/dummy_plugin", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\n\n\nclass DummyPlugin1(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9061': ('Dummy short desc 01', 'dummy-message-01', 'Dummy long desc')}\n    options = (\n        ('dummy_option_1', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 1',\n            'default': ''\n        }),\n    )\n\n\nclass DummyPlugin2(BaseChecker):\n    name = 'dummy_plugin'\n    msgs = {'I9060': ('Dummy short desc 02', 'dummy-message-02', 'Dummy long desc')}\n    options = (\n        ('dummy_option_2', {\n            'type': 'string',\n            'metavar': '<string>',\n            'help': 'Dummy option 2',\n            'default': ''\n        }),\n    )\n\n\ndef register(linter: \"PyLinter\") -> None:\n    linter.register_checker(DummyPlugin1(linter))\n    linter.register_checker(DummyPlugin2(linter))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#!/usr/bin/env python\n\n# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Script used to generate the extensions file before building the actual documentation.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport sys\nfrom typing import Any, TypedDict\n\nimport sphinx\nfrom sphinx.application import Sphinx\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.constants import MAIN_CHECKER_NAME\nfrom pylint.lint import PyLinter\nfrom pylint.typing import MessageDefinitionTuple, OptionDict, ReportsCallable\nfrom pylint.utils import get_rst_title\n\n\nclass _CheckerInfo(TypedDict):\n    \"\"\"Represents data about a checker.\"\"\"\n\n    checker: BaseChecker\n    options: list[tuple[str, OptionDict, Any]]\n    msgs: dict[str, MessageDefinitionTuple]\n    reports: list[tuple[str, str, ReportsCallable]]\n    doc: str\n    module: str\n\n\n# pylint: disable-next=unused-argument\ndef builder_inited(app: Sphinx | None) -> None:\n    \"\"\"Output full documentation in ReST format for all extension modules.\"\"\"\n    # PACKAGE/docs/exts/pylint_extensions.py --> PACKAGE/\n    base_path = os.path.dirname(\n        os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    )\n    # PACKAGE/ --> PACKAGE/pylint/extensions\n    ext_path = os.path.join(base_path, \"pylint\", \"extensions\")\n    modules = []\n    doc_files: dict[str, str] = {}\n    for filename in os.listdir(ext_path):\n        name, ext = os.path.splitext(filename)\n        if name[0] == \"_\":\n            continue\n        if ext == \".py\":\n            modules.append(f\"pylint.extensions.{name}\")\n        elif ext == \".rst\":\n            doc_files[\"pylint.extensions.\" + name] = os.path.join(ext_path, filename)\n    modules.sort()\n    if not modules:\n        sys.exit(\"No Pylint extensions found?\")\n\n    linter = PyLinter()\n    linter.load_plugin_modules(modules)\n\n    exten"}, {"start_line": 4000, "end_line": 5412, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et_checkers():\n        if checker.name == MAIN_CHECKER_NAME:\n            continue\n        module = checker.__module__\n        # Plugins only - skip over core checkers\n        if re.match(\"pylint.checkers\", module):\n            continue\n        # Find any .rst documentation associated with this plugin\n        doc = \"\"\n        doc_file = doc_files.get(module)\n        if doc_file:\n            with open(doc_file, encoding=\"utf-8\") as f:\n                doc = f.read()\n        try:\n            by_checker[checker][\"checker\"] = checker\n            by_checker[checker][\"options\"] += checker._options_and_values()\n            by_checker[checker][\"msgs\"].update(checker.msgs)\n            by_checker[checker][\"reports\"] += checker.reports\n            by_checker[checker][\"doc\"] += doc\n            by_checker[checker][\"module\"] += module\n        except KeyError:\n            by_checker[checker] = _CheckerInfo(\n                checker=checker,\n                options=list(checker._options_and_values()),\n                msgs=dict(checker.msgs),\n                reports=list(checker.reports),\n                doc=doc,\n                module=module,\n            )\n    return by_checker\n\n\ndef setup(app: Sphinx) -> dict[str, str | bool]:\n    app.connect(\"builder-inited\", builder_inited)\n    return {\"version\": sphinx.__display_version__, \"parallel_read_safe\": True}\n\n\nif __name__ == \"__main__\":\n    builder_inited(None)\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "version\":\n            value = str(_format_option_value(optdict, value))\n            result += f\"\\n  Default: ``{value.replace('`` ', '```` ``')}``\\n\"\n    return result\n\n\ndef decoding_stream(\n    stream: BufferedReader | BytesIO,\n    encoding: str,\n    errors: Literal[\"strict\"] = \"strict\",\n) -> codecs.StreamReader:\n    try:\n        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())\n    except LookupError:\n        reader_cls = codecs.getreader(sys.getdefaultencoding())\n    return reader_cls(stream, errors)\n\n\ndef tokenize_module(node: nodes.Module) -> list[tokenize.TokenInfo]:\n    with node.stream() as stream:\n        readline = stream.readline\n        return list(tokenize.tokenize(readline))\n\n\ndef register_plugins(linter: PyLinter, directory: str) -> None:\n    \"\"\"Load all module and package in the given directory, looking for a\n    'register' function in each one, used to register pylint checkers.\n    \"\"\"\n    imported = {}\n    for filename in os.listdir(directory):\n        base, extension = os.path.splitext(filename)\n        if base in imported or base == \"__pycache__\":\n            continue\n        if (extension in PY_EXTS and base != \"__init__\") or (\n            not extension\n            and os.path.isdir(os.path.join(directory, base))\n            and not filename.startswith(\".\")\n        ):\n            try:\n                module = modutils.load_module_from_file(\n                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n            else:\n                if hasattr(module, \"register\"):\n                    module.register(linter)\n                    imported[base] = 1\n\n\ndef _splitstrip(string: str, sep: str = \",\") -> list[str]:\n    r\"\"\"Return a list of stripped string by splitting the string gi"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `force` is True (useful when multiprocessing), then the plugin is\n        reloaded regardless if an entry exists in self._dynamic_plugins.\n        \"\"\"\n        for modname in modnames:\n            if modname in self._dynamic_plugins and not force:\n                continue\n            try:\n                module = astroid.modutils.load_module_from_name(modname)\n                module.register(self)\n                self._dynamic_plugins[modname] = module\n            except ModuleNotFoundError as mnf_e:\n                self._dynamic_plugins[modname] = mnf_e\n\n    def load_plugin_configuration(self) -> None:\n        \"\"\"Call the configuration hook for plugins.\n\n        This walks through the list of plugins, grabs the \"load_configuration\"\n        hook, if exposed, and calls it to allow plugins to configure specific\n        settings.\n\n        The result of attempting to load the plugin of the given name\n        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.\n\n       "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nown-option-value\",\n        \"Used when an unknown value is encountered for an option.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"R0022\": (\n        \"Useless option value for '%s', %s\",\n        \"useless-option-value\",\n        \"Used when a value for an option that is now deleted from pylint\"\n        \" is encountered.\",\n        {\n            \"scope\": WarningScope.LINE,\n            \"old_names\": [(\"E0012\", \"bad-option-value\")],\n        },\n    ),\n    \"E0013\": (\n        \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n        \"bad-plugin-value\",\n        \"Used when a bad value is used in 'load-plugins'.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0015\": (\n        \"Unrecognized option found: %s\",\n        \"unrecognized-option\",\n        \"Used when we detect an option that we do not recognize.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n}\n\n\n# pylint: disable=too-many-instance-attributes,too-many-public-methods\nclass PyLinter(\n    _ArgumentsManager,\n    _MessageStateHandler,\n    reporters.ReportsHandlerMixIn,\n    checkers.BaseChecker,\n):\n    \"\"\"Lint Python modules using external checkers.\n\n    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n    `astroid.MANAGER.clear_cache()` across runs if you want\n    to ensure the latest code version is actually checked.\n\n    Thi"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pylinter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self.options: Options = options + _make_linter_options(self)\n        for opt_group in option_groups:\n            self.option_groups_descs[opt_group[0]] = opt_group[1]\n        self._option_groups: tuple[tuple[str, str], ...] = (\n            *option_groups,\n            *PyLinter.option_groups_descs.items(),\n        )\n        self.fail_on_symbols: list[str] = []\n        \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n        self._error_mode = False\n\n        reporters.ReportsHandlerMixIn.__init__(self)\n        checkers.BaseChecker.__init__(self, self)\n        # provided reports\n        self.reports = (\n            (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n            (\n                \"RP0002\",\n                \"% errors / warnings by module\",\n                report_messages_by_module_stats,\n            ),\n            (\"RP0003\", \"Messages\", report_messages_stats),\n        )\n\n        # Attributes related to registering messages and their handling\n        self.msgs_store = MessageDefinitionStore(self.config.py_version)\n        self.msg_status = 0\n        self._by_id_managed_msgs: list[ManagedMessage] = []\n\n        # Attributes related to visiting files\n        self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n        self.current_name: str = \"\"\n        self.current_file: str | None = None\n        self._ignore_file = False\n        self._ignore_paths: list[Pattern[str]] = []\n        self.verbose = False\n\n        self.register_checker(self)\n\n    def load_default_plugins(self) -> None:\n        checkers.initialize(self)\n        reporters.initialize(self)\n\n    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -> None:\n        \"\"\"Check a list of pylint plugins modules, load and register them.\n\n        If a module cannot be loaded, never try to load it again and instead\n        store the error message for later use in ``load_plugin_configuration``\n        below.\n\n        If `fo"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pylint_extensions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " by_checker = get_plugins_info(linter, doc_files)\n        max_len = len(by_checker)\n        for i, checker_information in enumerate(sorted(by_checker.items())):\n            checker, information = checker_information\n            j = -1\n            checker = information[\"checker\"]\n            if i == max_len - 1:\n                # Remove the \\n\\n at the end of the file\n                j = -3\n            print(\n                checker.get_full_documentation(\n                    msgs=information[\"msgs\"],\n                    options=information[\"options\"],\n                    reports=information[\"reports\"],\n                    doc=information[\"doc\"],\n                    module=information[\"module\"],\n                    show_options=False,\n                )[:j],\n                file=stream,\n            )\n\n\ndef get_plugins_info(\n    linter: PyLinter, doc_files: dict[str, str]\n) -> dict[BaseChecker, _CheckerInfo]:\n    by_checker: dict[BaseChecker, _CheckerInfo] = {}\n    for checker in linter.get_checkers():\n        if checker.name == MAIN_CHECKER_NAME:\n            continue\n        module = checker.__module__\n        # Plugins only - skip over core checkers\n        if re.match(\"pylint.checkers\", module):\n            continue\n        # Find any .rst documentation associated with this plugin\n        doc = \"\"\n        doc_file = doc_files.get(module)\n        if doc_file:\n            with open(doc_file, encoding=\"utf-8\") as f:\n                doc = f.read()\n        try:\n            by_checker[checker][\"checker\"] = checker\n            by_checker[checker][\"options\"] += checker._options_and_values()\n            by_checker[checker][\"msgs\"].update(checker.msgs)\n            by_checker[checker][\"reports\"] += checker.reports\n            by_checker[checker][\"doc\"] += doc\n            by_checker[checker][\"module\"] += module\n        except KeyError:\n            by_checker[checker] = _CheckerInfo(\n                checker=checker,\n                options=list(checker._options_and_values()),\n  "}, {"start_line": 0, "end_line": 1525, "belongs_to": {"file_name": "pylint_features.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/exts", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#!/usr/bin/env python\n\n# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Script used to generate the features file before building the actual\ndocumentation.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\n\nimport sphinx\nfrom sphinx.application import Sphinx\n\nfrom pylint.lint import PyLinter\nfrom pylint.utils import get_rst_title, print_full_documentation\n\n\n# pylint: disable-next=unused-argument\ndef builder_inited(app: Sphinx | None) -> None:\n    # PACKAGE/docs/exts/pylint_extensions.py --> PACKAGE/\n    base_path = os.path.dirname(\n        os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    )\n    linter = PyLinter()\n    linter.load_default_plugins()\n    features = os.path.join(base_path, \"doc\", \"user_guide\", \"checkers\", \"features.rst\")\n    with open(features, \"w\", encoding=\"utf-8\") as stream:\n        stream.write(get_rst_title(\"Pylint features\", \"=\"))\n        stream.write(\n            \"\"\"\n.. This file is auto-generated. Make any changes to the associated\n.. docs extension in 'doc/exts/pylint_features.py'.\n\n\"\"\"\n        )\n        print_full_documentation(linter, stream, False)\n\n\ndef setup(app: Sphinx) -> dict[str, str | bool]:\n    app.connect(\"builder-inited\", builder_inited)\n    return {\"version\": sphinx.__display_version__, \"parallel_read_safe\": True}\n\n\nif __name__ == \"__main__\":\n    builder_inited(None)\n"}], "retrieved_count": 10, "cost_time": 0.354236364364624}
