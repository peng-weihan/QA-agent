{"question": "What cascading effects would occur if modifications to the exception handling pattern for sibling exception handlers propagate through the unused variable checker's analysis pipeline?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n            # If the two try/finally ancestors are not the same, then\n            # node_statement's closest try/finally ancestor needs to be in\n            # the final body of other_node's try/finally ancestor, or\n            # descend from one of the statements in that final body.\n            if (\n                other_node_try_finally_ancestor is not closest_try_finally_ancestor\n                and not any(\n                    other_node_final_statement is closest_try_finally_ancestor\n                    or other_node_final_statement.parent_of(\n                        closest_try_finally_ancestor\n                    )\n                    for other_node_final_statement in other_node_try_finally_ancestor.finalbody\n                )\n            ):\n                continue\n            # Is the name defined in all exception clauses?\n            if other_node_try_finally_ancestor.handlers and all(\n                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)\n                for handler in other_node_try_finally_ancestor.handlers\n            ):\n                continue\n            # Passed all tests for uncertain execution\n            uncertain_nodes.append(other_node)\n        return uncertain_nodes\n\n\n# pylint: disable=too-many-public-methods\nclass VariablesChecker(BaseChecker):\n    \"\"\"BaseChecker for variables.\n\n    Checks for\n    * unused variables / imports\n    * undefined variables\n    * redefinition of variable from builtins or from an outer scope or except handler\n    * use of variable before assignment\n    * __all__ consistency\n    * self/cls assignment\n    \"\"\"\n\n    name = \"variables\"\n    msgs = MSGS\n    options = (\n        (\n            \"init-import\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Tells whether we should check for unused import in \"\n                \"__init__ files.\",\n            },\n        ),\n        (\n            \"dummy-varia"}, {"start_line": 3000, "end_line": 4990, "belongs_to": {"file_name": "unused_variable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n\ndef func():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except error:\n            print(\"error\")\n\ndef func2():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except:\n            raise Exception(\"\") from error\n\ndef func3():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        print(f\"{error}\")\n        try:\n            1 / 2\n        except TypeError as error:  # [unused-variable, redefined-outer-name]\n            print(\"warning\")\n\ndef func4():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:  # [unused-variable]\n        try:\n            1 / 0\n        except ZeroDivisionError as error:  # [redefined-outer-name]\n            print(\"error\")\n\n\ndef main(lst):\n    \"\"\"https://github.com/pylint-dev/astroid/pull/1111#issuecomment-890367609\"\"\"\n    try:\n        raise ValueError\n    except ValueError as e:  # [unused-variable]\n        pass\n\n    for e in lst:\n        pass\n\n    # e will be undefined if lst is empty\n    print(e)  # [undefined-loop-variable]\n\nmain([])\n\n\ndef func5():\n    \"\"\"No unused-variable for a container if iterated in comprehension\"\"\"\n    x = []\n    # Test case requires homonym between \"for x\" and \"in x\"\n    assert [True for x in x]\n\n\ndef sibling_except_handlers():\n    try:\n        pass\n    except ValueError as e:\n        print(e)\n    try:\n        pass\n    except ValueError as e:\n        print(e)\n\ndef func6():\n    a = 1\n\n    def nonlocal_writer():\n        nonlocal a\n\n        for a in range(10):\n            pass\n\n    nonlocal_writer()\n\n    assert a == 9, a\n\ndef test_regression_8595():\n    # pylint: disable=broad-exception-caught\n    import logging\n    def compute():\n        pass\n    try:\n        compute()\n        error = False\n    except Exception as e:\n        logging.error(e)\n        error = True\n    if error:\n        try:\n            compute()\n        except Exception as e:  # [unused-variable]\n            pass\n"}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            for handler in other_node_try_finally_ancestor.handlers\n            ):\n                continue\n            # Passed all tests for uncertain execution\n            uncertain_nodes.append(other_node)\n        return uncertain_nodes\n\n\n# pylint: disable=too-many-public-methods\nclass VariablesChecker(BaseChecker):\n    \"\"\"BaseChecker for variables.\n\n    Checks for\n    * unused variables / imports\n    * undefined variables\n    * redefinition of variable from builtins or from an outer scope or except handler\n    * use of variable before assignment\n    * __all__ consistency\n    * self/cls assignment\n    \"\"\"\n\n    name = \"variables\"\n    msgs = MSGS\n    options = (\n        (\n            \"init-import\",\n            {\n                \"default\": False,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Tells whether we should check for unused import in \"\n                \"__init__ files.\",\n            },\n        ),\n        (\n            \"dummy-variables-rgx\",\n            {\n                \"default\": \"_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\",\n                \"type\": \"regexp\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"A regular expression matching the name of dummy \"\n                \"variables (i.e. expected to not be used).\",\n            },\n        ),\n        (\n            \"additional-builtins\",\n            {\n                \"default\": (),\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated list>\",\n                \"help\": \"List of additional names supposed to be defined in \"\n                \"builtins. Remember that you should avoid defining new builtins \"\n                \"when possible.\",\n            },\n        ),\n        (\n            \"callbacks\",\n            {\n                \"default\": (\"cb_\", \"_cb\"),\n                \"type\": \"csv\",\n                \"metavar\": \"<callbacks>\",\n                \"help\": \"List of strings which can identify a callback \"\n                \"f"}, {"start_line": 65000, "end_line": 67000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       node=node,\n                )\n                break\n\n        self._except_handler_names_queue.append((node, node.name))\n\n    @utils.only_required_for_messages(\"redefined-outer-name\")\n    def leave_excepthandler(self, node: nodes.ExceptHandler) -> None:\n        if not node.name or not isinstance(node.name, nodes.AssignName):\n            return\n        self._except_handler_names_queue.pop()\n\n    def _undefined_and_used_before_checker(\n        self,\n        node: nodes.Name,\n        stmt: nodes.NodeNG,\n    ) -> None:\n        frame = stmt.scope()\n        start_index = len(self._to_consume) - 1\n\n        # iterates through parent scopes, from the inner to the outer\n        base_scope_type = self._to_consume[start_index].scope_type\n\n        for i in range(start_index, -1, -1):\n            current_consumer = self._to_consume[i]\n\n            # Certain nodes shouldn't be checked as they get checked another time\n            if self._should_node_be_skipped(node, current_consumer, i == start_index):\n                continue\n\n            action, nodes_to_consume = self._check_consumer(\n                node, stmt, frame, current_consumer, base_scope_type\n            )\n            if nodes_to_consume:\n                # Any nodes added to consumed_uncertain by get_next_to_consume()\n                # should be added back so that they are marked as used.\n                # They will have already had a chance to emit used-before-assignment.\n                # We check here instead of before every single return in _check_consumer()\n                nodes_to_consume += current_consumer.consumed_uncertain[node.name]\n                current_consumer.mark_as_consumed(node.name, nodes_to_consume)\n            if action is VariableVisitConsumerAction.CONTINUE:\n                continue\n            if action is VariableVisitConsumerAction.RETURN:\n                return\n\n        # we have not found the name, if it isn't a builtin, that's an\n        # undefined name !\n        if not (\n         "}, {"start_line": 2000, "end_line": 3326, "belongs_to": {"file_name": "overlapping_exceptions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " in exc.ancestors() if isinstance(a, astroid.ClassDef)\n                ]\n\n                for prev_part, prev_exc in handled_in_clause:\n                    prev_exc_ancestors = [\n                        a\n                        for a in prev_exc.ancestors()\n                        if isinstance(a, astroid.ClassDef)\n                    ]\n                    if exc == prev_exc:\n                        self.add_message(\n                            \"overlapping-except\",\n                            node=handler.type,\n                            args=f\"{prev_part.as_string()} and {part.as_string()} are the same\",\n                        )\n                    elif prev_exc in exc_ancestors or exc in prev_exc_ancestors:\n                        ancestor = part if exc in prev_exc_ancestors else prev_part\n                        descendant = part if prev_exc in exc_ancestors else prev_part\n                        self.add_message(\n                            \"overlapping-except\",\n                            node=handler.type,\n                            args=f\"{ancestor.as_string()} is an ancestor class of {descendant.as_string()}\",\n                        )\n                handled_in_clause += [(part, exc)]\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(OverlappingExceptionsChecker(linter))\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "unused_variable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f nodes coming from some 'elif'\n    if node.orelse and len(node.orelse) > 1:\n        branches += 1\n    self.inc_branch(branches)\n    self.stmts += branches\n\n\ndef test_global():\n    \"\"\" Test various assignments of global\n    variables through imports.\n    \"\"\"\n    # pylint: disable=redefined-outer-name\n    global PATH, OS, collections, deque  # [global-statement]\n    from os import path as PATH\n    import os as OS\n    import collections\n    from collections import deque\n    # make sure that these triggers unused-variable\n    from sys import platform  # [unused-import]\n    from sys import version as VERSION  # [unused-import]\n    import this  # [unused-import]\n    import re as RE  # [unused-import]\n\n# test cases that include exceptions\ndef function2():\n    unused = 1  # [unused-variable]\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except ZeroDivisionError as error:  # [redefined-outer-name]\n            raise Exception(\"\") from error\n\ndef func():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except error:\n            print(\"error\")\n\ndef func2():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        try:\n            1 / 0\n        except:\n            raise Exception(\"\") from error\n\ndef func3():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:\n        print(f\"{error}\")\n        try:\n            1 / 2\n        except TypeError as error:  # [unused-variable, redefined-outer-name]\n            print(\"warning\")\n\ndef func4():\n    try:\n        1 / 0\n    except ZeroDivisionError as error:  # [unused-variable]\n        try:\n            1 / 0\n        except ZeroDivisionError as error:  # [redefined-outer-name]\n            print(\"error\")\n\n\ndef main(lst):\n    \"\"\"https://github.com/pylint-dev/astroid/pull/1111#issuecomment-890367609\"\"\"\n    try:\n        raise ValueError\n    except ValueError as e:  # [unused-variable]\n        pass\n\n    for e in lst:\n "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t is a sibling attached to the try ancestor,\n            # or is an ancestor of the try ancestor.\n            if not any(\n                closest_except_handler in other_node_try_ancestor.handlers\n                or other_node_try_ancestor_except_handler\n                in closest_except_handler.node_ancestors()\n                for other_node_try_ancestor_except_handler in other_node_try_ancestor.handlers\n            ):\n                continue\n            # Passed all tests for uncertain execution\n            uncertain_nodes.append(other_node)\n        return uncertain_nodes\n\n    @staticmethod\n    def _uncertain_nodes_in_try_blocks_when_evaluating_finally_blocks(\n        found_nodes: list[nodes.NodeNG],\n        node_statement: _base_nodes.Statement,\n        name: str,\n    ) -> list[nodes.NodeNG]:\n        uncertain_nodes: list[nodes.NodeNG] = []\n        (\n            closest_try_finally_ancestor,\n            child_of_closest_try_finally_ancestor,\n        ) = utils.get_node_first_ancestor_of_type_and_its_child(\n            node_statement, nodes.Try\n        )\n        if closest_try_finally_ancestor is None:\n            return uncertain_nodes\n        if (\n            child_of_closest_try_finally_ancestor\n            not in closest_try_finally_ancestor.finalbody\n        ):\n            return uncertain_nodes\n        for other_node in found_nodes:\n            other_node_statement = other_node.statement()\n            (\n                other_node_try_finally_ancestor,\n                child_of_other_node_try_finally_ancestor,\n            ) = utils.get_node_first_ancestor_of_type_and_its_child(\n                other_node_statement, nodes.Try\n            )\n            if other_node_try_finally_ancestor is None:\n                continue\n            # other_node needs to descend from the try of a try/finally.\n            if (\n                child_of_other_node_try_finally_ancestor\n                not in other_node_try_finally_ancestor.body\n            ):\n                continue"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = any(\n                isinstance(try_statement, nodes.Return)\n                for try_statement in closest_try_except.body\n            )\n            else_block_returns = any(\n                isinstance(else_statement, nodes.Return)\n                for else_statement in closest_try_except.orelse\n            )\n            else_block_exits = any(\n                isinstance(else_statement, nodes.Expr)\n                and isinstance(else_statement.value, nodes.Call)\n                and utils.is_terminating_func(else_statement.value)\n                for else_statement in closest_try_except.orelse\n            )\n            else_block_continues = any(\n                isinstance(else_statement, nodes.Continue)\n                for else_statement in closest_try_except.orelse\n            )\n            if (\n                else_block_continues\n                and isinstance(node_statement.parent, (nodes.For, nodes.While))\n                and closest_try_except.parent.parent_of(node_statement)\n            ):\n                continue\n\n            if try_block_returns or else_block_returns or else_block_exits:\n                # Exception: if this node is in the final block of the other_node_statement,\n                # it will execute before returning. Assume the except statements are uncertain.\n                if (\n                    isinstance(node_statement.parent, nodes.Try)\n                    and node_statement in node_statement.parent.finalbody\n                    and closest_try_except.parent.parent_of(node_statement)\n                ):\n                    uncertain_nodes.append(other_node)\n                # Or the node_statement is in the else block of the relevant Try\n                elif (\n                    isinstance(node_statement.parent, nodes.Try)\n                    and node_statement in node_statement.parent.orelse\n                    and closest_try_except.parent.parent_of(node_statement)\n                ):\n                    uncertain_nodes.append(other_nod"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "exceptions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pt.\n\n                excs_in_current_handler = gather_exceptions_from_handler(handler)\n                if not excs_in_current_handler:\n                    break\n                if exceptions_in_bare_handler is None:\n                    # It can be `None` when the inference failed\n                    break\n                for exc_in_current_handler in excs_in_current_handler:\n                    inferred_current = utils.safe_infer(exc_in_current_handler)\n                    if any(\n                        utils.is_subclass_of(utils.safe_infer(e), inferred_current)\n                        for e in exceptions_in_bare_handler\n                    ):\n                        bare_raise = False\n                        break\n\n            # `raise` as the first operator inside the except handler\n            if _is_raising([handler.body[0]]):\n                # flags when there is a bare raise\n                if handler.body[0].exc is None:\n                    bare_raise = True\n                    handler_having_bare_raise = handler\n                    exceptions_in_bare_handler = gather_exceptions_from_handler(handler)\n        else:\n            if bare_raise:\n                self.add_message(\"try-except-raise\", node=handler_having_bare_raise)\n\n    @utils.only_required_for_messages(\"wrong-exception-operation\")\n    def visit_binop(self, node: nodes.BinOp) -> None:\n        if isinstance(node.parent, nodes.ExceptHandler):\n            both_sides_tuple_or_uninferable = isinstance(\n                utils.safe_infer(node.left), (nodes.Tuple, util.UninferableBase)\n            ) and isinstance(\n                utils.safe_infer(node.right), (nodes.Tuple, util.UninferableBase)\n            )\n            # Tuple concatenation allowed\n            if both_sides_tuple_or_uninferable:\n                if node.op == \"+\":\n                    return\n                suggestion = f\"Did you mean '({node.left.as_string()} + {node.right.as_string()})' instead?\"\n            # except (V | A)\n            el"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dler\n        )\n        if closest_except_handler is None:\n            return uncertain_nodes\n        for other_node in found_nodes:\n            other_node_statement = other_node.statement()\n            # If the other statement is the except handler guarding `node`, it executes\n            if other_node_statement is closest_except_handler:\n                continue\n            # Ensure other_node is in a try block\n            (\n                other_node_try_ancestor,\n                other_node_try_ancestor_visited_child,\n            ) = utils.get_node_first_ancestor_of_type_and_its_child(\n                other_node_statement, nodes.Try\n            )\n            if other_node_try_ancestor is None:\n                continue\n            if (\n                other_node_try_ancestor_visited_child\n                not in other_node_try_ancestor.body\n            ):\n                continue\n            # Make sure nesting is correct -- there should be at least one\n            # except handler that is a sibling attached to the try ancestor,\n            # or is an ancestor of the try ancestor.\n            if not any(\n                closest_except_handler in other_node_try_ancestor.handlers\n                or other_node_try_ancestor_except_handler\n                in closest_except_handler.node_ancestors()\n                for other_node_try_ancestor_except_handler in other_node_try_ancestor.handlers\n            ):\n                continue\n            # Passed all tests for uncertain execution\n            uncertain_nodes.append(other_node)\n        return uncertain_nodes\n\n    @staticmethod\n    def _uncertain_nodes_in_try_blocks_when_evaluating_finally_blocks(\n        found_nodes: list[nodes.NodeNG],\n        node_statement: _base_nodes.Statement,\n        name: str,\n    ) -> list[nodes.NodeNG]:\n        uncertain_nodes: list[nodes.NodeNG] = []\n        (\n            closest_try_finally_ancestor,\n            child_of_closest_try_finally_ancestor,\n        ) = utils.get_node_first_ancesto"}], "retrieved_count": 10, "cost_time": 1.0202574729919434}
{"question": "What is the architectural pattern that distinguishes type-annotated from non-annotated instance attribute initialization using AST node type separation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "name)\n        assert got == expected, f\"got {got} instead of {expected} for value {name}\"\n\n\n@pytest.mark.parametrize(\n    \"assign, label\",\n    [\n        (\"a: str = None\", \"Optional[str]\"),\n        (\"a: str = 'mystr'\", \"str\"),\n        (\"a: Optional[str] = 'str'\", \"Optional[str]\"),\n        (\"a: Optional[str] = None\", \"Optional[str]\"),\n    ],\n)\ndef test_get_annotation_annassign(assign: str, label: str) -> None:\n    \"\"\"AnnAssign.\"\"\"\n    node: nodes.AnnAssign = astroid.extract_node(assign)\n    annotation = get_annotation(node.value)\n    assert annotation is not None\n    got = annotation.name\n    assert isinstance(node, nodes.AnnAssign)\n    assert got == label, f\"got {got} instead of {label} for value {node}\"\n\n\n@pytest.mark.parametrize(\n    \"init_method, label\",\n    [\n        (\"def __init__(self, x: str):                   self.x = x\", \"str\"),\n        (\"def __init__(self, x: str = 'str'):           self.x = x\", \"str\"),\n        (\"def __init__(self, x: str = None):            self.x = x\", \"Optional[str]\"),\n        (\"def __init__(self, x: Optional[str]):         self.x = x\", \"Optional[str]\"),\n        (\"def __init__(self, x: Optional[str] = None):  self.x = x\", \"Optional[str]\"),\n        (\"def __init__(self, x: Optional[str] = 'str'): self.x = x\", \"Optional[str]\"),\n    ],\n)\ndef test_get_annotation_assignattr(init_method: str, label: str) -> None:\n    \"\"\"AssignAttr.\"\"\"\n    assign = rf\"\"\"\n        class A:\n            {init_method}\n    \"\"\"\n    node = astroid.extract_node(assign)\n    instance_attrs = node.instance_attrs\n    for assign_attrs in instance_attrs.values():\n        for assign_attr in assign_attrs:\n            annotation = get_annotation(assign_attr)\n            assert annotation is not None\n            got = annotation.name\n            assert isinstance(assign_attr, nodes.AssignAttr)\n            assert got == label, f\"got {got} instead of {label} for value {node}\"\n\n\n@pytest.mark.parametrize(\n    \"node_text, expected_label\",\n    [\n        (\"def f() -> None: pass\", \"None\""}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "possibility of an annotation either being a Name, i.e. just type,\n        or a Subscript e.g. `Optional[type]` or an Attribute, e.g. `pylint.lint.linter`.\n        \"\"\"\n        if isinstance(node, nodes.Name) and node.name not in all_used_type_annotations:\n            all_used_type_annotations[node.name] = True\n            return node.name  # type: ignore[no-any-return]\n        if isinstance(node, nodes.Subscript):  # e.g. Optional[List[str]]\n            # slice is the next nested type\n            self._populate_type_annotations_annotation(\n                node.slice, all_used_type_annotations\n            )\n            # value is the current type name: could be a Name or Attribute\n            return self._populate_type_annotations_annotation(\n                node.value, all_used_type_annotations\n            )\n        if isinstance(node, nodes.Attribute):\n            # An attribute is a type like `pylint.lint.pylinter`. node.expr is the next level\n            # up, could be another attribute\n            return self._populate_type_annotations_annotation(\n                node.expr, all_used_type_annotations\n            )\n        return None\n\n    @staticmethod\n    def _assignments_call_private_name(\n        assignments: list[nodes.AnnAssign | nodes.Assign], private_name: str\n    ) -> bool:\n        \"\"\"Returns True if no assignments involve accessing `private_name`.\"\"\"\n        if all(not assignment.value for assignment in assignments):\n            # Variable annotated but unassigned is not allowed because there may be\n            # possible illegal access elsewhere\n            return False\n        for assignment in assignments:\n            current_attribute = None\n            if isinstance(assignment.value, nodes.Call):\n                current_attribute = assignment.value.func\n            elif isinstance(assignment.value, nodes.Attribute):\n                current_attribute = assignment.value\n            elif isinstance(assignment.value, nodes.Name):\n                current_"}, {"start_line": 84000, "end_line": 86000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    self._store_type_annotation_names(node)\n\n    def visit_arguments(self, node: nodes.Arguments) -> None:\n        for annotation in node.type_comment_args:\n            self._store_type_annotation_node(annotation)\n\n    # Relying on other checker's options, which might not have been initialized yet.\n    @cached_property\n    def _analyse_fallback_blocks(self) -> bool:\n        return bool(self.linter.config.analyse_fallback_blocks)\n\n    @cached_property\n    def _ignored_modules(self) -> Iterable[str]:\n        return self.linter.config.ignored_modules  # type: ignore[no-any-return]\n\n    @cached_property\n    def _allow_global_unused_variables(self) -> bool:\n        return bool(self.linter.config.allow_global_unused_variables)\n\n    @staticmethod\n    def _defined_in_function_definition(\n        node: nodes.NodeNG,\n        frame: nodes.NodeNG,\n    ) -> bool:\n        in_annotation_or_default_or_decorator = False\n        if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:\n            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n                or (frame.decorators and frame.decorators.parent_of(node))\n                or (\n                    frame.returns\n                    and (node is frame.returns or frame.returns.parent_of(node))\n                )\n            )\n        return in_annotation_or_default_or_decorator\n\n    @staticmethod\n    def _in_lambda_or_comprehension_body(\n        node: nodes.NodeNG,\n        frame: nodes.NodeNG,\n    ) -> bool:\n        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes i"}, {"start_line": 119000, "end_line": 121000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f isinstance(type_annotation, nodes.Name):\n            self._type_annotation_names.append(type_annotation.name)\n            return\n\n        if isinstance(type_annotation, nodes.Attribute):\n            self._store_type_annotation_node(type_annotation.expr)\n            return\n\n        if not isinstance(type_annotation, nodes.Subscript):\n            return\n\n        if (\n            isinstance(type_annotation.value, nodes.Attribute)\n            and isinstance(type_annotation.value.expr, nodes.Name)\n            and type_annotation.value.expr.name == TYPING_MODULE\n        ):\n            self._type_annotation_names.append(TYPING_MODULE)\n            return\n\n        self._type_annotation_names.extend(\n            annotation.name for annotation in type_annotation.nodes_of_class(nodes.Name)\n        )\n\n    def _store_type_annotation_names(\n        self,\n        node: nodes.For | nodes.Assign | nodes.With,\n    ) -> None:\n        type_annotation = node.type_annotation\n        if not type_annotation:\n            return\n        self._store_type_annotation_node(node.type_annotation)\n\n    def _check_self_cls_assign(self, node: nodes.Assign) -> None:\n        \"\"\"Check that self/cls don't get assigned.\"\"\"\n        assign_names: set[str | None] = set()\n        for target in node.targets:\n            if isinstance(target, nodes.AssignName):\n                assign_names.add(target.name)\n            elif isinstance(target, nodes.Tuple):\n                assign_names.update(\n                    elt.name for elt in target.elts if isinstance(elt, nodes.AssignName)\n                )\n        scope = node.scope()\n        nonlocals_with_same_name = node.scope().parent and any(\n            child for child in scope.body if isinstance(child, nodes.Nonlocal)\n        )\n        if nonlocals_with_same_name:\n            scope = node.scope().parent.scope()\n\n        if not (\n            isinstance(scope, nodes.FunctionDef)\n            and scope.is_method()\n            and \"builtins.staticmethod\" not in scope."}, {"start_line": 79000, "end_line": 81000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pt astroid.NotFoundError:\n                pass\n            # is it an instance attribute of a parent class ?\n            try:\n                next(node.instance_attr_ancestors(attr))\n                # yes, stop here\n                continue\n            except StopIteration:\n                pass\n            # is it an instance attribute ?\n            try:\n                defstmts = node.instance_attr(attr)\n            except astroid.NotFoundError:\n                pass\n            else:\n                # filter out augment assignment nodes\n                defstmts = [stmt for stmt in defstmts if stmt not in nodes_lst]\n                if not defstmts:\n                    # only augment assignment for this node, no-member should be\n                    # triggered by the typecheck checker\n                    continue\n                # filter defstmts to only pick the first one when there are\n                # several assignments in the same scope\n                scope = defstmts[0].scope()\n                defstmts = [\n                    stmt\n                    for i, stmt in enumerate(defstmts)\n                    if i == 0 or stmt.scope() is not scope\n                ]\n                # if there are still more than one, don't attempt to be smarter\n                # than we can be\n                if len(defstmts) == 1:\n                    defstmt = defstmts[0]\n                    # check that if the node is accessed in the same method as\n                    # it's defined, it's accessed after the initial assignment\n                    frame = defstmt.frame()\n                    lno = defstmt.fromlineno\n                    for _node in nodes_lst:\n                        if (\n                            _node.frame() is frame\n                            and _node.fromlineno < lno\n                            and not astroid.are_exclusive(\n                                _node.statement(), defstmt, excs\n                            )\n                        ):\n             "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ional[str]\"),\n        (\"def __init__(self, x: Optional[str]):         self.x = x\", \"Optional[str]\"),\n        (\"def __init__(self, x: Optional[str] = None):  self.x = x\", \"Optional[str]\"),\n        (\"def __init__(self, x: Optional[str] = 'str'): self.x = x\", \"Optional[str]\"),\n    ],\n)\ndef test_get_annotation_assignattr(init_method: str, label: str) -> None:\n    \"\"\"AssignAttr.\"\"\"\n    assign = rf\"\"\"\n        class A:\n            {init_method}\n    \"\"\"\n    node = astroid.extract_node(assign)\n    instance_attrs = node.instance_attrs\n    for assign_attrs in instance_attrs.values():\n        for assign_attr in assign_attrs:\n            annotation = get_annotation(assign_attr)\n            assert annotation is not None\n            got = annotation.name\n            assert isinstance(assign_attr, nodes.AssignAttr)\n            assert got == label, f\"got {got} instead of {label} for value {node}\"\n\n\n@pytest.mark.parametrize(\n    \"node_text, expected_label\",\n    [\n        (\"def f() -> None: pass\", \"None\"),\n        (\"def f() -> int: pass\", \"int\"),\n        (\"def f(a) -> Optional[int]: return 1 if a else None\", \"Optional[int]\"),\n        (\"def f() -> 'MyType': pass\", \"'MyType'\"),\n    ],\n)\ndef test_get_annotation_label_of_return_type(\n    node_text: str, expected_label: str\n) -> None:\n    func = astroid.extract_node(node_text)\n    assert isinstance(func, nodes.FunctionDef)\n    assert get_annotation_label(func.returns) == expected_label\n\n\n@patch(\"pylint.pyreverse.utils.get_annotation\")\n@patch(\"astroid.nodes.NodeNG.infer\", side_effect=astroid.InferenceError)\ndef test_infer_node_1(mock_infer: Any, mock_get_annotation: Any) -> None:\n    \"\"\"Return set() when astroid.InferenceError is raised and an annotation has\n    not been returned.\n    \"\"\"\n    mock_get_annotation.return_value = None\n    node = astroid.extract_node(\"a: str = 'mystr'\")\n    mock_infer.return_value = \"x\"\n    assert infer_node(node) == set()\n    assert mock_infer.called\n\n\n@patch(\"pylint.pyreverse.utils.get_annotation\")\n@patch(\"as"}, {"start_line": 0, "end_line": 620, "belongs_to": {"file_name": "duplicates.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/attributes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Test for https://github.com/pylint-dev/pylint/issues/8189\nclass DuplicateFields():\n    example1: int\n    example2: int\n\n    def __init__(self):\n        self.example1 = 1\n        self.example2 = 2\n\n\n# Test for https://github.com/pylint-dev/pylint/issues/8522\nclass A:\n    pass\n\nclass DuplicateArrows:\n    a: A\n\n    def __init__(self):\n        self.a = A()\n\n\n\n# Test for https://github.com/pylint-dev/pylint/issues/8888\nclass DuplicateAnnotations:\n    def __init__(self) -> None:\n        self.val: str | int = \"1\"\n        self.lav: list[str] = []\n\n    def bar(self) -> None:\n        self.val = \"2\"\n        self.lav = []\n"}, {"start_line": 70000, "end_line": 72000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     return\n                if node.attrname in klass.locals:\n                    for local_name in klass.locals.get(node.attrname):\n                        statement = local_name.statement()\n                        if (\n                            isinstance(statement, nodes.AnnAssign)\n                            and not statement.value\n                        ):\n                            return\n                    if _has_data_descriptor(klass, node.attrname):\n                        # Descriptors circumvent the slots mechanism as well.\n                        return\n                if node.attrname == \"__class__\" and _has_same_layout_slots(\n                    slots, node.parent.value\n                ):\n                    return\n                self.add_message(\n                    \"assigning-non-slot\",\n                    args=(node.attrname,),\n                    node=node,\n                    confidence=INFERENCE,\n                )\n\n    @only_required_for_messages(\n        \"protected-access\", \"no-classmethod-decorator\", \"no-staticmethod-decorator\"\n    )\n    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n        if self._uses_mandatory_method_param(node):\n            return\n        self._check_protected_attribute_access(node)\n\n    def _check_classmethod_declaration(self, node: nodes.Assign) -> None:\n        \"\"\"Checks for uses of classmethod() or staticmethod().\n\n        When a @classmethod or @staticmethod decorator should be used instead.\n        A message will be emitted only if the assignment is at a class scope\n        and only if the classmethod's argument belongs to the class where it\n        is defined.\n        `node` is an assign node.\n        \"\"\"\n        if not isinstance(node.value, nodes.Call):\n            return\n\n        # check the function called is \"classmethod\" or \"st"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "check_noreturn and node.name == \"NoReturn\":\n            self._check_broken_noreturn(node)\n        if self._should_check_callable and node.name == \"Callable\":\n            self._check_broken_callable(node)\n\n    @only_required_for_messages(\n        \"deprecated-typing-alias\",\n        \"consider-using-alias\",\n        \"consider-alternative-union-syntax\",\n        \"broken-noreturn\",\n        \"broken-collections-callable\",\n    )\n    def visit_attribute(self, node: nodes.Attribute) -> None:\n        if self._should_check_typing_alias and node.attrname in ALIAS_NAMES:\n            self._check_for_typing_alias(node)\n        if self._should_check_alternative_union_syntax and node.attrname in UNION_NAMES:\n            self._check_for_alternative_union_syntax(node, node.attrname)\n        if self._should_check_noreturn and node.attrname == \"NoReturn\":\n            self._check_broken_noreturn(node)\n        if self._should_check_callable and node.attrname == \"Callable\":\n            self._check_broken_callable(node)\n\n    @only_required_for_messages(\"redundant-typehint-argument\")\n    def visit_annassign(self, node: nodes.AnnAssign) -> None:\n        annotation = node.annotation\n        if self._is_deprecated_union_annotation(annotation, \"Optional\"):\n            if self._is_optional_none_annotation(annotation):\n                self.add_message(\n                    \"redundant-typehint-argument\",\n                    node=annotation,\n                    args=\"None\",\n                    confidence=HIGH,\n                )\n            return\n        if self._is_deprecated_union_annotation(annotation, \"Union\") and isinstance(\n            annotation.slice, nodes.Tuple\n        ):\n            types = annotation.slice.elts\n        elif self._is_binop_union_annotation(annotation):\n            types = self._parse_binops_typehints(annotation)\n        else:\n            return\n\n        self._check_union_types(types, node)\n\n    @only_required_for_messages(\"unnecessary-default-type-args\")\n    def visit_subscrip"}, {"start_line": 91000, "end_line": 93000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n                maybe_before_assign and stmt.fromlineno <= defstmt.fromlineno\n            )\n            if maybe_before_assign and stmt.fromlineno == defstmt.fromlineno:\n                if (\n                    isinstance(defframe, nodes.FunctionDef)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and (\n                        defnode in defframe.type_params\n                        # Single statement function, with the statement on the\n                        # same line as the function definition\n                        or stmt is not defstmt\n                    )\n                ):\n                    maybe_before_assign = False\n                elif (\n                    isinstance(defstmt, NODES_WITH_VALUE_ATTR)\n                    and VariablesChecker._maybe_used_and_assigned_at_once(defstmt)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and stmt is defstmt\n   "}], "retrieved_count": 10, "cost_time": 1.027550458908081}
{"question": "What dependencies exist between the named tuple storing class node metadata with method definitions and the node rendering function's formatting of method signatures with return type annotations in PlantUML output?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "diagrams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "operties\n        for attr_name, attr_type in list(node.locals_type.items()) + list(\n            node.instance_attrs_type.items()\n        ):\n            if attr_name not in properties:\n                properties[attr_name] = attr_type\n\n        for node_name, associated_nodes in properties.items():\n            if not self.show_attr(node_name):\n                continue\n\n            # Handle property methods differently to correctly extract return type\n            if isinstance(\n                associated_nodes, nodes.FunctionDef\n            ) and decorated_with_property(associated_nodes):\n                if associated_nodes.returns:\n                    type_annotation = get_annotation_label(associated_nodes.returns)\n                    node_name = f\"{node_name} : {type_annotation}\"\n\n            # Handle regular attributes\n            else:\n                names = self.class_names(associated_nodes)\n                if names:\n                    node_name = f\"{node_name} : {', '.join(names)}\"\n\n            attrs.append(node_name)\n        return sorted(attrs)\n\n    def get_methods(self, node: nodes.ClassDef) -> list[nodes.FunctionDef]:\n        \"\"\"Return visible methods.\"\"\"\n        methods = [\n            m\n            for m in node.values()\n            if isinstance(m, nodes.FunctionDef)\n            and not isinstance(m, astroid.objects.Property)\n            and not decorated_with_property(m)\n            and self.show_attr(m.name)\n        ]\n        return sorted(methods, key=lambda n: n.name)\n\n    def add_object(self, title: str, node: nodes.ClassDef) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = ClassEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n\n    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -> list[str]:\n        \"\"\"Return class names if needed in diagram.\"\"\"\n        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n        "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "mermaidjs_printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es.methods:\n                args = self._get_method_arguments(func)\n                # Escape method name and arguments\n                escaped_method_name = self._escape_mermaid_text(func.name)\n                escaped_args = [self._escape_mermaid_text(arg) for arg in args]\n                line = f\"{escaped_method_name}({', '.join(escaped_args)})\"\n                line += \"*\" if func.is_abstract() else \"\"\n                if func.returns:\n                    # Escape return type annotation\n                    return_type = get_annotation_label(func.returns)\n                    escaped_return_type = self._escape_mermaid_text(return_type)\n                    line += f\" {escaped_return_type}\"\n                body.append(line)\n        name = name.split(\".\")[-1]\n        self.emit(f\"{nodetype} {name} {{\")\n        self._inc_indent()\n        for line in body:\n            self.emit(line)\n        self._dec_indent()\n        self.emit(\"}\")\n        # apply style for colored output\n        if properties.color and properties.color != self.DEFAULT_COLOR:\n            self.emit(f\"style {name} fill:{properties.color}\")\n\n    def emit_edge(\n        self,\n        from_node: str,\n        to_node: str,\n        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        from_node = from_node.split(\".\")[-1]\n        to_node = to_node.split(\".\")[-1]\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n        if label:\n            edge += f\" : {self._escape_mermaid_text(label)}\"\n        self.emit(edge)\n\n    def _close_graph(self) -> None:\n        \"\"\"Emit the lines needed to properly close the graph.\"\"\"\n        self._dec_indent()\n\n\nclass HTMLMermaidJSPrinter(MermaidJSPrinter):\n    \"\"\"Printer for MermaidJS diagrams wrapped in a html boilerplate.\"\"\"\n\n    HTML_OPEN_BOILERPLATE = \"\"\"<html>\n  <body>\n    <script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"></script>\n      <div class=\"m"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "diagrams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\n\n            attrs.append(node_name)\n        return sorted(attrs)\n\n    def get_methods(self, node: nodes.ClassDef) -> list[nodes.FunctionDef]:\n        \"\"\"Return visible methods.\"\"\"\n        methods = [\n            m\n            for m in node.values()\n            if isinstance(m, nodes.FunctionDef)\n            and not isinstance(m, astroid.objects.Property)\n            and not decorated_with_property(m)\n            and self.show_attr(m.name)\n        ]\n        return sorted(methods, key=lambda n: n.name)\n\n    def add_object(self, title: str, node: nodes.ClassDef) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = ClassEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n\n    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -> list[str]:\n        \"\"\"Return class names if needed in diagram.\"\"\"\n        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n                isinstance(\n                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)\n                )\n                and hasattr(node, \"name\")\n                and not self.has_node(node)\n            ):\n                if node.name not in names:\n                    node_name = node.name\n                    names.append(node_name)\n        # sorted to get predictable (hence testable) results\n        return sorted(\n            name\n            for name in names\n            if all(name not in other or name == other for other in names)\n        )\n\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n        \"\"\"Return the diagram object mapped to node.\"\"\"\n        return self._nodes[node]\n\n    def classes(self) -> list[ClassEntity]:\n        \"\"\"Ret"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "olor: str | None = None\n    fontcolor: str | None = None\n\n\nclass Printer(ABC):\n    \"\"\"Base class defining the interface for a printer.\"\"\"\n\n    def __init__(\n        self,\n        title: str,\n        layout: Layout | None = None,\n        use_automatic_namespace: bool | None = None,\n    ) -> None:\n        self.title: str = title\n        self.layout = layout\n        self.use_automatic_namespace = use_automatic_namespace\n        self.lines: list[str] = []\n        self._indent = \"\"\n        self._open_graph()\n\n    def _inc_indent(self) -> None:\n        \"\"\"Increment indentation.\"\"\"\n        self._indent += \"  \"\n\n    def _dec_indent(self) -> None:\n        \"\"\"Decrement indentation.\"\"\"\n        self._indent = self._indent[:-2]\n\n    @abstractmethod\n    def _open_graph(self) -> None:\n        \"\"\"Emit the header lines, i.e. all boilerplate code that defines things like\n        layout etc.\n        \"\"\"\n\n    def emit(self, line: str, force_newline: bool | None = True) -> None:\n        if force_newline and not line.endswith(\"\\n\"):\n            line += \"\\n\"\n        self.lines.append(self._indent + line)\n\n    @abstractmethod\n    def emit_node(\n        self,\n        name: str,\n        type_: NodeType,\n        properties: NodeProperties | None = None,\n    ) -> None:\n        \"\"\"Create a new node.\n\n        Nodes can be classes, packages, participants etc.\n        \"\"\"\n\n    @abstractmethod\n    def emit_edge(\n        self,\n        from_node: str,\n        to_node: str,\n        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n\n    @staticmethod\n    def _get_method_arguments(method: nodes.FunctionDef) -> list[str]:\n        if method.args.args is None:\n            return []\n\n        first_arg = 0 if method.type in {\"function\", \"staticmethod\"} else 1\n        arguments: list[nodes.AssignName] = method.args.args[first_arg:]\n\n        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))\n   "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " ann.name is not None:\n        return ann.name  # type: ignore[no-any-return]\n    if isinstance(ann, nodes.NodeNG):\n        return ann.as_string()  # type: ignore[no-any-return]\n    return \"\"\n\n\ndef get_annotation(\n    node: nodes.AssignAttr | nodes.AssignName,\n) -> nodes.Name | nodes.Subscript | None:\n    \"\"\"Return the annotation for `node`.\"\"\"\n    ann = None\n    if isinstance(node.parent, nodes.AnnAssign):\n        ann = node.parent.annotation\n    elif isinstance(node, nodes.AssignAttr):\n        init_method = node.parent.parent\n        try:\n            annotations = dict(zip(init_method.locals, init_method.args.annotations))\n            ann = annotations.get(node.parent.value.name)\n        except AttributeError:\n            pass\n    else:\n        return ann\n\n    try:\n        default, *_ = node.infer()\n    except astroid.InferenceError:\n        default = \"\"\n\n    label = get_annotation_label(ann)\n\n    if (\n        ann\n        and getattr(default, \"value\", \"value\") is None\n        and not label.startswith(\"Optional\")\n        and (\n            not isinstance(ann, nodes.BinOp)\n            or not any(\n                isinstance(child, nodes.Const) and child.value is None\n                for child in ann.get_children()\n            )\n        )\n    ):\n        label = rf\"Optional[{label}]\"\n\n    if label and ann:\n        ann.name = label\n    return ann\n\n\ndef infer_node(node: nodes.AssignAttr | nodes.AssignName) -> set[InferenceResult]:\n    \"\"\"Return a set containing the node annotation if it exists\n    otherwise return a set of the inferred types using the NodeNG.infer method.\n    \"\"\"\n    ann = get_annotation(node)\n    try:\n        if ann:\n            if isinstance(ann, nodes.Subscript) or (\n                isinstance(ann, nodes.BinOp) and ann.op == \"|\"\n            ):\n                return {ann}\n            return set(ann.infer())\n        return set(node.infer())\n    except astroid.InferenceError:\n        return {ann} if ann else set()\n\n\ndef check_graphviz_availability() -> N"}, {"start_line": 2000, "end_line": 3726, "belongs_to": {"file_name": "printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d not line.endswith(\"\\n\"):\n            line += \"\\n\"\n        self.lines.append(self._indent + line)\n\n    @abstractmethod\n    def emit_node(\n        self,\n        name: str,\n        type_: NodeType,\n        properties: NodeProperties | None = None,\n    ) -> None:\n        \"\"\"Create a new node.\n\n        Nodes can be classes, packages, participants etc.\n        \"\"\"\n\n    @abstractmethod\n    def emit_edge(\n        self,\n        from_node: str,\n        to_node: str,\n        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n\n    @staticmethod\n    def _get_method_arguments(method: nodes.FunctionDef) -> list[str]:\n        if method.args.args is None:\n            return []\n\n        first_arg = 0 if method.type in {\"function\", \"staticmethod\"} else 1\n        arguments: list[nodes.AssignName] = method.args.args[first_arg:]\n\n        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))\n        for arg in arguments:\n            annotation_label = \"\"\n            ann = annotations.get(arg)\n            if ann:\n                annotation_label = get_annotation_label(ann)\n            annotations[arg] = annotation_label\n\n        return [\n            f\"{arg.name}: {ann}\" if ann else f\"{arg.name}\"\n            for arg, ann in annotations.items()\n        ]\n\n    def generate(self, outputfile: str) -> None:\n        \"\"\"Generate and save the final outputfile.\"\"\"\n        self._close_graph()\n        with open(outputfile, \"w\", encoding=\"utf-8\") as outfile:\n            outfile.writelines(self.lines)\n\n    @abstractmethod\n    def _close_graph(self) -> None:\n        \"\"\"Emit the lines needed to properly close the graph.\"\"\"\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "diagrams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        node = node._proxied\n            if (\n                isinstance(\n                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)\n                )\n                and hasattr(node, \"name\")\n                and not self.has_node(node)\n            ):\n                if node.name not in names:\n                    node_name = node.name\n                    names.append(node_name)\n        # sorted to get predictable (hence testable) results\n        return sorted(\n            name\n            for name in names\n            if all(name not in other or name == other for other in names)\n        )\n\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n        \"\"\"Return the diagram object mapped to node.\"\"\"\n        return self._nodes[node]\n\n    def classes(self) -> list[ClassEntity]:\n        \"\"\"Return all class nodes in the diagram.\"\"\"\n        return [o for o in self.objects if isinstance(o, ClassEntity)]\n\n    def classe(self, name: str) -> ClassEntity:\n        \"\"\"Return a class by its name, raise KeyError if not found.\"\"\"\n        for klass in self.classes():\n            if klass.node.name == name:\n                return klass\n        raise KeyError(name)\n\n    def extract_relationships(self) -> None:\n        \"\"\"Extract relationships between nodes in the diagram.\"\"\"\n        for obj in self.classes():\n            node = obj.node\n            obj.attrs = self.get_attrs(node)\n            obj.methods = self.get_methods(node)\n            obj.shape = \"class\"\n            # inheritance link\n            for par_node in node.ancestors(recurs=False):\n                try:\n                    par_obj = self.object_from_node(par_node)\n                    self.add_relationship(obj, par_obj, \"specialization\")\n                except KeyError:\n                    continue\n\n            # association"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "mermaidjs_printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n        self._inc_indent()\n\n    def _escape_mermaid_text(self, text: str) -> str:\n        \"\"\"Escape characters that conflict with Markdown formatting.\"\"\"\n        text = text.replace(\"__\", r\"\\_\\_\")  # Double underscore  escaped\n        return text\n\n    def emit_node(\n        self,\n        name: str,\n        type_: NodeType,\n        properties: NodeProperties | None = None,\n    ) -> None:\n        \"\"\"Create a new node.\n\n        Nodes can be classes, packages, participants etc.\n        \"\"\"\n        # pylint: disable=duplicate-code\n        if properties is None:\n            properties = NodeProperties(label=name)\n        nodetype = self.NODES[type_]\n        body = []\n        if properties.attrs:\n            # Escape attribute names to prevent Markdown formatting issues\n            escaped_attrs = [\n                self._escape_mermaid_text(attr) for attr in properties.attrs\n            ]\n            body.extend(escaped_attrs)\n        if properties.methods:\n            for func in properties.methods:\n                args = self._get_method_arguments(func)\n                # Escape method name and arguments\n                escaped_method_name = self._escape_mermaid_text(func.name)\n                escaped_args = [self._escape_mermaid_text(arg) for arg in args]\n                line = f\"{escaped_method_name}({', '.join(escaped_args)})\"\n                line += \"*\" if func.is_abstract() else \"\"\n                if func.returns:\n                    # Escape return type annotation\n                    return_type = get_annotation_label(func.returns)\n                    escaped_return_type = self._escape_mermaid_text(return_type)\n                    line += f\" {escaped_return_type}\"\n                body.append(line)\n        name = name.split(\".\")[-1]\n        self.emit(f\"{nodetype} {name} {{\")\n        self._inc_indent()\n        for line in body:\n            self.emit(line)\n        self._dec_indent()\n        self.emit(\"}\")\n        # apply style for colored output\n        if propertie"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Base class defining the interface for a printer.\"\"\"\n\nfrom __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import NamedTuple\n\nfrom astroid import nodes\n\nfrom pylint.pyreverse.utils import get_annotation_label\n\n\nclass NodeType(Enum):\n    CLASS = \"class\"\n    PACKAGE = \"package\"\n\n\nclass EdgeType(Enum):\n    INHERITS = \"inherits\"\n    ASSOCIATION = \"association\"\n    AGGREGATION = \"aggregation\"\n    USES = \"uses\"\n    TYPE_DEPENDENCY = \"type_dependency\"\n\n\nclass Layout(Enum):\n    LEFT_TO_RIGHT = \"LR\"\n    RIGHT_TO_LEFT = \"RL\"\n    TOP_TO_BOTTOM = \"TB\"\n    BOTTOM_TO_TOP = \"BT\"\n\n\nclass NodeProperties(NamedTuple):\n    label: str\n    attrs: list[str] | None = None\n    methods: list[nodes.FunctionDef] | None = None\n    color: str | None = None\n    fontcolor: str | None = None\n\n\nclass Printer(ABC):\n    \"\"\"Base class defining the interface for a printer.\"\"\"\n\n    def __init__(\n        self,\n        title: str,\n        layout: Layout | None = None,\n        use_automatic_namespace: bool | None = None,\n    ) -> None:\n        self.title: str = title\n        self.layout = layout\n        self.use_automatic_namespace = use_automatic_namespace\n        self.lines: list[str] = []\n        self._indent = \"\"\n        self._open_graph()\n\n    def _inc_indent(self) -> None:\n        \"\"\"Increment indentation.\"\"\"\n        self._indent += \"  \"\n\n    def _dec_indent(self) -> None:\n        \"\"\"Decrement indentation.\"\"\"\n        self._indent = self._indent[:-2]\n\n    @abstractmethod\n    def _open_graph(self) -> None:\n        \"\"\"Emit the header lines, i.e. all boilerplate code that defines things like\n        layout etc.\n        \"\"\"\n\n    def emit(self, line: str, force_newline: bool | None = True) -> None:\n        if force_newline an"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "dot_printer.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "perties.fontcolor else \"\"\n        )\n        self.emit(\n            f'\"{name}\" [color=\"{color}\"{fontcolor_part}{label_part}, shape=\"{shape}\", style=\"{style}\"];'\n        )\n\n    def _build_label_for_node(self, properties: NodeProperties) -> str:\n        if not properties.label:\n            return \"\"\n\n        label: str = properties.label\n        if properties.attrs is None and properties.methods is None:\n            # return a \"compact\" form which only displays the class name in a box\n            return label\n\n        # Add class attributes\n        attrs: list[str] = properties.attrs or []\n        attrs_string = rf\"{HTMLLabels.LINEBREAK_LEFT.value}\".join(\n            attr.replace(\"|\", r\"\\|\") for attr in attrs\n        )\n        label = rf\"{{{label}|{attrs_string}{HTMLLabels.LINEBREAK_LEFT.value}|\"\n\n        # Add class methods\n        methods: list[nodes.FunctionDef] = properties.methods or []\n        for func in methods:\n            args = \", \".join(self._get_method_arguments(func)).replace(\"|\", r\"\\|\")\n            method_name = (\n                f\"<I>{func.name}</I>\" if func.is_abstract() else f\"{func.name}\"\n            )\n            label += rf\"{method_name}({args})\"\n            if func.returns:\n                annotation_label = get_annotation_label(func.returns)\n                label += \": \" + self._escape_annotation_label(annotation_label)\n            label += rf\"{HTMLLabels.LINEBREAK_LEFT.value}\"\n        label += \"}\"\n        return label\n\n    def _escape_annotation_label(self, annotation_label: str) -> str:\n        # Escape vertical bar characters to make them appear as a literal characters\n        # otherwise it gets treated as field separator of record-based nodes\n        annotation_label = annotation_label.replace(\"|\", r\"\\|\")\n\n        return annotation_label\n\n    def emit_edge(\n        self,\n        from_node: str,\n        to_node: str,\n        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to"}], "retrieved_count": 10, "cost_time": 1.0428414344787598}
{"question": "How does a base class without a slot restriction declaration interact with the attribute assignment validation checker when inherited by subclasses that define slot restrictions or include the dynamic attribute dictionary in their slot restrictions?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def __setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Checks assigning attributes not found in class slots\nwill trigger assigning-non-slot warning.\n\"\"\"\n# pylint: disable=too-few-public-methods, missing-docstring, import-error, redundant-u-string-prefix, unnecessary-dunder-call\n# pylint: disable=attribute-defined-outside-init\n\nfrom collections import deque\n\nfrom missing import Unknown\n\nclass Empty:\n    \"\"\" empty \"\"\"\n\nclass Bad:\n    \"\"\" missing not in slots. \"\"\"\n\n    __slots__ = ['member']\n\n    def __init__(self):\n        self.missing = 42 # [assigning-non-slot]\n\nclass Bad2:\n    \"\"\" missing not in slots \"\"\"\n    __slots__ = [deque.__name__, 'member']\n\n    def __init__(self):\n        self.deque = 42\n        self.missing = 42 # [assigning-non-slot]\n\nclass Bad3(Bad):\n    \"\"\" missing not found in slots \"\"\"\n\n    __slots__ = ['component']\n\n    def __init__(self):\n        self.component = 42\n        self.member = 24\n        self.missing = 42 # [assigning-non-slot]\n        super().__init__()\n\nclass Good(Empty):\n    \"\"\" missing not in slots, but Empty doesn't\n    specify __slots__.\n    \"\"\"\n    __slots__ = ['a']\n\n    def __init__(self):\n        self.missing = 42\n\nclass Good2:\n    \"\"\" Using __dict__ in slots will be safe. \"\"\"\n\n    __slots__ = ['__dict__', 'comp']\n\n    def __init__(self):\n        self.comp = 4\n        self.missing = 5\n\nclass PropertyGood:\n    \"\"\" Using properties is safe. \"\"\"\n\n    __slots__ = ['tmp', '_value']\n\n    @property\n    def test(self):\n        return self._value\n\n    @test.setter\n    def test(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    def __init__(self):\n        self.test = 42\n\nclass PropertyGood2:\n    \"\"\" Using properties in the body of the class is safe. \"\"\"\n    __slots__ = ['_value']\n\n    def _getter(self):\n        return self._value\n\n    def _setter(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    test = property(_getter, _setter)\n\n    def __init__(self):\n        self.test = 24\n\nclass U"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def _"}, {"start_line": 4000, "end_line": 5061, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n    __slots__ = ()\n\n\nrepro = Repro()\nrepro.attr2 = \"anything\"\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Empty doesn't\n    specify __slots__.\n    \"\"\"\n    __slots__ = ['a']\n\n    def __init__(self):\n        self.missing = 42\n\nclass Good2:\n    \"\"\" Using __dict__ in slots will be safe. \"\"\"\n\n    __slots__ = ['__dict__', 'comp']\n\n    def __init__(self):\n        self.comp = 4\n        self.missing = 5\n\nclass PropertyGood:\n    \"\"\" Using properties is safe. \"\"\"\n\n    __slots__ = ['tmp', '_value']\n\n    @property\n    def test(self):\n        return self._value\n\n    @test.setter\n    def test(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    def __init__(self):\n        self.test = 42\n\nclass PropertyGood2:\n    \"\"\" Using properties in the body of the class is safe. \"\"\"\n    __slots__ = ['_value']\n\n    def _getter(self):\n        return self._value\n\n    def _setter(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    test = property(_getter, _setter)\n\n    def __init__(self):\n        self.test = 24\n\nclass UnicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descri"}, {"start_line": 67000, "end_line": 69000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          if hasattr(elt, \"attrname\") and elt.attrname == \"__class__\":\n                    class_index = i\n            if class_index == -1:\n                # This should not happen because we checked that the node name\n                # is '__class__' earlier, but let's not be too confident here\n                return  # pragma: no cover\n            inferred = safe_infer(node.parent.parent.value.elts[class_index])\n        else:\n            inferred = safe_infer(node.parent.value)\n        if (\n            isinstance(inferred, (nodes.ClassDef, util.UninferableBase))\n            or inferred is None\n        ):\n            # If is uninferable, we allow it to prevent false positives\n            return\n        self.add_message(\n            \"invalid-class-object\",\n            node=node,\n            args=inferred.__class__.__name__,\n            confidence=INFERENCE,\n        )\n\n    def _check_in_slots(self, node: nodes.AssignAttr) -> None:\n        \"\"\"Check that the given AssignAttr node\n        is defined in the class slots.\n        \"\"\"\n        inferred = safe_infer(node.expr)\n        if not isinstance(inferred, astroid.Instance):\n            return\n\n        klass = inferred._proxied\n        if not has_known_bases(klass):\n            return\n        if \"__slots__\" not in klass.locals:\n            return\n        # If `__setattr__` is defined on the class, then we can't reason about\n        # what will happen when assigning to an attribute.\n        if any(\n            base.locals.get(\"__setattr__\")\n            for base in klass.mro()\n            if base.qname() != \"builtins.object\"\n        ):\n            return\n\n        # If 'typing.Generic' is a base of bases of klass, the cached version\n        # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.\n        if any(base.qname() == \"typing.Generic\" for base in klass.mro()):\n            cache = getattr(klass, \"__cache\", None)\n            if cache and cache.get(klass.slots) is not None:\n                del"}, {"start_line": 0, "end_line": 481, "belongs_to": {"file_name": "assigning_non_slot_4509.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=invalid-name,missing-docstring,too-few-public-methods\n\n# Slots with base that inherits from 'Generic'\n# https://github.com/pylint-dev/pylint/issues/4509\n# https://github.com/pylint-dev/astroid/issues/999\n\nfrom typing import Generic, TypeVar\nT = TypeVar(\"T\")\n\nclass Base(Generic[T]):\n    __slots__ = ()\n\nclass Foo(Base[T]):\n    __slots__ = ['_value']\n\n    def __init__(self, value: T):\n        self._value = value\n        self._bar = value  # [assigning-non-slot]\n"}, {"start_line": 0, "end_line": 217, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/a/assigning-non-slot", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Student:\n    __slots__ = (\"name\",)\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n\n    def setup(self):\n        pass\n"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ve __slots__, attributes can be set dynamically, so stop\n            if not self._has_valid_slots(ancestor):\n                return\n            for slot_name in self._get_classdef_slots_names(ancestor):\n                if slot_name == \"__dict__\":\n                    return\n                slot_names.append(slot_name)\n\n        # Every class in bases has __slots__, our __slots__ is non-empty and there is no __dict__\n\n        for child in node.body:\n            if isinstance(child, nodes.AnnAssign):\n                if child.value is not None:\n                    continue\n                if isinstance(child.target, nodes.AssignName):\n                    if child.target.name not in slot_names:\n                        self.add_message(\n                            \"declare-non-slot\",\n                            args=child.target.name,\n                            node=child.target,\n                            confidence=INFERENCE,\n                        )\n\n    def _check_consistent_mro(self, node: nodes.ClassDef) -> None:\n        \"\"\"Detect that a class has a consistent mro or duplicate bases.\"\"\"\n        try:\n            node.mro()\n        except astroid.InconsistentMroError:\n            self.add_message(\"inconsistent-mro\", args=node.name, node=node)\n        except astroid.DuplicateBasesError:\n            self.add_message(\"duplicate-bases\", args=node.name, node=node)\n\n    def _check_enum_base(self, node: nodes.ClassDef, ancestor: nodes.ClassDef) -> None:\n        members = ancestor.getattr(\"__members__\")\n        if members and isinstance(members[0], nodes.Dict) and members[0].items:\n            for _, name_node in members[0].items:\n                # Exempt type annotations without value assignments\n                if all(\n                    isinstance(item.parent, nodes.AnnAssign)\n                    and item.parent.value is None\n                    for item in ancestor.getattr(name_node.name)\n                ):\n                    continue\n                self.add_message("}, {"start_line": 0, "end_line": 1165, "belongs_to": {"file_name": "redefined_slots.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/redefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Checks that a subclass does not redefine a slot which has been defined in a parent class.\"\"\"\n\n# pylint: disable=too-few-public-methods, invalid-slots-object\n\nfrom collections import deque\n\n\nclass Base:\n    \"\"\"Class defining the `a`, `b` & `deque.__name__` slots\"\"\"\n    __slots__ = (\"a\", \"b\", deque.__name__)\n\n\nclass Subclass1(Base):\n    \"\"\"Redefining the `a` & `deque.__name__` slots & adding the `d` & `e` slots\"\"\"\n    __slots__ = (\"a\", deque.__name__, \"d\", \"e\")  # [redefined-slots-in-subclass]\n\n\nclass Subclass2(Base):\n    \"\"\"Adding the `f`, `g` & `h` slots\"\"\"\n    __slots__ = (\"f\", \"g\", \"h\")\n\n\nclass Base2:\n    \"\"\"Class defining the `i`, `j` & `k` slots\"\"\"\n    __slots__ = (\"i\", \"j\", \"k\")\n\n\nclass Subclass3(Base, Base2):\n    \"\"\"Adding the `l`, `m`, `n` slots\n       Redefining the `a`, `b`, & `c` slot already defined in `Base`\n       Redefining the `i`, `j`, `k` slot already defined in `Base2`\n    \"\"\"\n    __slots__ = (\"a\", \"b\", \"c\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\")  # [redefined-slots-in-subclass]\n\n\n# https://github.com/pylint-dev/pylint/issues/6100\nclass MyClass:\n    \"\"\"No crash when the type of the slot is not a Const or a str\"\"\"\n    __slots__ = [str]\n"}], "retrieved_count": 10, "cost_time": 1.0327112674713135}
{"question": "What is the dependency relationship between the test class's instance initialization method accessing the class name attribute and Python's object model?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 536, "belongs_to": {"file_name": "access_to__name__.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/access", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"test access to __name__ gives undefined member on new/old class instances\nbut not on new/old class object\n\"\"\"\n\n\nclass Aaaa:\n    \"\"\"old class\"\"\"\n    def __init__(self):\n        print(self.__name__)  # [no-member]\n        print(self.__class__.__name__)\n\nclass NewClass:\n    \"\"\"new class\"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        print('new', cls.__name__)\n        return object.__new__(cls, *args, **kwargs)\n\n    def __init__(self):\n        print('init', self.__name__)  # [no-member]\n"}, {"start_line": 0, "end_line": 462, "belongs_to": {"file_name": "object_as_class_attribute.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/o", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"Test case for the problem described below :\n - A class extends 'object'\n - This class defines its own __init__()\n   * pylint will therefore check that baseclasses' init()\n     are called\n - If this class defines an 'object' attribute, then pylint\n   will use this new definition when trying to retrieve\n   object.__init__()\n\"\"\"\n\n\nclass Statement:\n    \"\"\" ... \"\"\"\n    def __init__(self):\n        pass\n    object = None\n"}, {"start_line": 0, "end_line": 449, "belongs_to": {"file_name": "_monkey.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse/functional/class_diagrams/attributes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# This is not a standalone test\n# Monkey class is called from Tree class in delayed_external_monkey_patching.py\n\n\nclass Monkey:\n    def __init__(self, name):\n        # pylint: disable=import-outside-toplevel\n        from delayed_external_monkey_patching import Tree\n\n        self.name = name\n        self.tree = Tree()\n        self.tree.has_tasty_bananas = True  # This monkey patching will increase the number of items in instance_attrs for `Tree`\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      false_obj.func = func\n        false_obj.__args = args  # Do not emit message here\n        false_obj.__secret_bool = False\n        false_obj.__unused = None  # [unused-private-member]\n        return false_obj\n        # unreachable but non-Name return value\n        return 3+4\n\n    def exec(self):\n        print(self.__secret_bool)\n        return self.func(*self.__args)\n\n\n# https://github.com/pylint-dev/pylint/issues/4673\n# Nested functions shouldn't cause a false positive if they are properly used\nclass FalsePositive4673:\n    \"\"\" The testing class \"\"\"\n\n    def __init__(self, in_thing):\n        self.thing = False\n        self.do_thing(in_thing)\n\n    def do_thing(self, in_thing):\n        \"\"\" Checks the false-positive condition, sets a property. \"\"\"\n        def __false_positive(in_thing):\n            print(in_thing)\n\n        def __true_positive(in_thing):  # [unused-private-member]\n            print(in_thing)\n\n        __false_positive(in_thing)\n        self.thing = True\n\n    def undo_thing(self):\n        \"\"\" Unsets a property. \"\"\"\n        self.thing = False\n\n    def complicated_example(self, flag):\n        def __inner_1():\n            pass\n\n        def __inner_2():\n            pass\n\n        def __inner_3(fn):\n            return fn\n\n        def __inner_4():  # [unused-private-member]\n            pass\n\n        fn_to_return = __inner_1 if flag else __inner_3(__inner_2)\n        return fn_to_return\n\n\n# https://github.com/pylint-dev/pylint/issues/4755\n# Nested attributes shouldn't cause crash\nclass Crash4755Context:\n    def __init__(self):\n        self.__messages = None  # [unused-private-member]\n\nclass Crash4755Command:\n    def __init__(self):\n        self.context = Crash4755Context()\n\n    def method(self):\n        self.context.__messages = []\n        for message in self.context.__messages:\n            print(message)\n\n\n# https://github.com/pylint-dev/pylint/issues/4681\n# Accessing attributes of the class using the class name should not result in a false positive\n# as lon"}, {"start_line": 0, "end_line": 460, "belongs_to": {"file_name": "metaclass_attr_access.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"test attribute access on metaclass\"\"\"\n\n\nclass Meta(type):\n    \"\"\"the meta class\"\"\"\n    def __init__(cls, name, bases, dictionary):\n        super(Meta, cls).__init__(name, bases, dictionary)\n        print(cls, cls._meta_args)\n        delattr(cls, '_meta_args')\n\n\nclass Test:\n    \"\"\"metaclassed class\"\"\"\n    __metaclass__ = Meta\n    _meta_args = ('foo', 'bar')\n\n    def __init__(self):\n        print('__init__', self)\n"}, {"start_line": 4000, "end_line": 5484, "belongs_to": {"file_name": "member_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m/member", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ething.conjugate()\n\n\nclass NoDunderNameInInstance:\n    \"\"\"Emit a warning when accessing __name__ from an instance.\"\"\"\n    def __init__(self):\n        self.var = self.__name__ # [no-member]\n\n\nclass InvalidAccessBySlots:\n    __slots__ = ('a', )\n    def __init__(self):\n        var = self.teta # [no-member]\n        self.teta = 24\n\n\nclass MetaWithDynamicGetattr(type):\n\n    def __getattr__(cls, attr):\n        return attr\n\n\nclass SomeClass(metaclass=MetaWithDynamicGetattr):\n    pass\n\n\nSomeClass.does_not_exist\n\nclass ClassWithMangledAttribute:\n    def __init__(self):\n        self.name = 'Bug1643'\n    def __bar(self):\n        print(self.name + \"xD\")\n\nClassWithMangledAttribute()._ClassWithMangledAttribute__bar()  # pylint: disable=protected-access\n\n\nimport enum\n\n\nclass Cls(enum.IntEnum):\n    BAR = 0\n\n\nSOME_VALUE = Cls.BAZ  # [no-member]\n\n\n\n# Does not crash when inferring the `append` attribute on the slice object\nclass SomeClassUsingSlice:\n    def __init__(self, flag):\n        if flag:\n            self.attribute = slice(None)\n        else:\n            self.attribute = []\n            self.attribute.append(1)\n\nfrom enum import Enum\nclass Animal(Enum):\n    ANT = 1\n    BEE = 2\n    CAT = 3\n    DOG = 4\n# To test false positive no-member on Enum.__members__.items()\nfor itm in Animal.__members__.items():\n    print(itm)\nfor keyy in Animal.__members__.keys():  # pylint: disable=consider-iterating-dictionary\n    print(keyy)\nfor vall in Animal.__members__.values():\n    print(vall)\n"}, {"start_line": 8000, "end_line": 9683, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "__defaults_set = False\n\n    def __init__(self, value):\n        self.value = value\n\n    def __init_defaults(self):  # [unused-private-member]\n        if not self.__defaults_set:\n            type(self).__defaults = { \"fur\": \"pink\" }\n            type(self).__defaults_set = True\n\n    def __get_fur_color(self):  # [unused-private-member]\n        color = lookup_attribute(self.__defaults, \"fur\")\n        return color\n\n\ndef lookup_attribute(mapping, key):\n    return mapping[key]\n\n\n# Test for regression on checking __class__ attribute\n# See: https://github.com/pylint-dev/pylint/issues/5261\nclass Foo:\n    __ham = 1\n\n    def method(self):\n        print(self.__class__.__ham)\n\n\n# https://github.com/pylint-dev/pylint/issues/4756\n# Check for false positives emitted when private functions are not referenced in the class body\n# with standard calls but passed as arguments to other functions.\nclass FalsePositive4756a:\n    def __bar(self, x):\n        print(x)\n    fizz = partialmethod(__bar, 'fizz')\ntest = FalsePositive4756a()\ntest.fizz()\n\nclass FalsePositive4756b:\n    def __get_prop(self):\n        pass\n\n    def __set_prop(self, value):\n        pass\n\n    def __del_prop(self):\n        pass\n\n    prop = property(__get_prop, __set_prop, __del_prop)\n\n\nclass TypeSelfCallInMethod:\n    \"\"\"Regression test for issue 5569\"\"\"\n    @classmethod\n    def b(cls) -> None:\n        cls.__a = ''  # [unused-private-member]\n\n    def a(self):\n        return type(self).__a\n\n\nclass Item:\n    \"\"\"Regression test for https://github.com/pylint-dev/pylint/issues/6709\"\"\"\n    def __init__(self, parent):\n        self.__parent: Item = parent\n        self.__item = self.__parent.__item  # [unused-private-member]\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "()\n\n    @classmethod\n    def get_class_var(cls):\n        return cls.__class_var\n\n\nclass Bla:\n    \"\"\"Regression test for issue 4638\"\"\"\n\n    def __init__(self):\n        type(self).__a()\n        self.__b()\n        Bla.__c()\n\n    @classmethod\n    def __a(cls):\n        pass\n\n    @classmethod\n    def __b(cls):\n        pass\n\n    @classmethod\n    def __c(cls):\n        pass\n\n\nclass Klass:\n    \"\"\"Regression test for 4644\"\"\"\n\n    __seventyseven = 77\n    __ninetyone = 91\n\n    def __init__(self):\n        self.twentyone = 21 * (1 / (self.__seventyseven + 33)) % 100\n        self.ninetyfive = Klass.__ninetyone + 4\n\n\nk = Klass()\nprint(k.twentyone)\nprint(k.ninetyfive)\n\n# https://github.com/pylint-dev/pylint/issues/4657\n# Mutation of class member with cls should not fire a false-positive\nclass FalsePositive4657:\n    \"\"\"False positive tests for 4657\"\"\"\n    __attr_a = None\n    __attr_b = 'b'\n\n    @classmethod\n    def load_attrs(cls):\n        \"\"\"Load attributes.\"\"\"\n        cls.__attr_a = 'a'\n\n    @property\n    def attr_a(self):\n        \"\"\"Get a.\"\"\"\n        return self.__attr_a\n\n    @property\n    def attr_b(self):\n        \"\"\"Get b.\"\"\"\n        return self.__attr_b\n\n    # Test cases where we assign self.attr, but try to\n    # access cls.attr\n\n    def __init__(self):\n        self.__attr_c = \"this is an unused private instance attribute\"  # [unused-private-member]\n\n    @property\n    def attr_c(self):\n        \"\"\"Get c.\"\"\"\n        return cls.__attr_c  # [undefined-variable]\n\n\n# https://github.com/pylint-dev/pylint/issues/4668\n# Attributes assigned within __new__() has to be processed as part of the class\nclass FalsePositive4668:\n    # pylint: disable=protected-access, no-member, unreachable\n\n    def __new__(cls, func, *args):\n        if args:\n            true_obj = super(FalsePositive4668, cls).__new__(cls)\n            true_obj.func = func\n            true_obj.__args = args  # Do not emit message here\n            return true_obj\n\n        false_obj = super(FalsePositive4668, cls).__new__(cls)\n  "}, {"start_line": 0, "end_line": 564, "belongs_to": {"file_name": "class_attributes.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test that valid class attribute doesn't trigger errors\"\"\"\n# pylint: disable=missing-docstring,too-few-public-methods\n\n\nclass Clazz:\n    \"dummy class\"\n\n    def __init__(self):\n        self.topic = 5\n        self._data = 45\n\n    def change_type(self, new_class):\n        \"\"\"Change type\"\"\"\n        self.__class__ = new_class\n\n    def do_nothing(self):\n        \"I do nothing useful\"\n        return self.topic + 56\n\n\nclass Base:\n    _class_prop: int\n\n\nclass Child(Base):\n    _class_prop = 42\n\n    def method(self):\n        print(self._class_prop)\n\n\nChild().method()\n"}, {"start_line": 0, "end_line": 541, "belongs_to": {"file_name": "regression_4982.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Regression test for a crash reported in https://github.com/pylint-dev/pylint/issues/4982\"\"\"\n# pylint: disable=too-few-public-methods\n\nclass Base:\n    \"\"\"A class\"\"\"\n    @classmethod\n    def get_first_subclass(cls):\n        \"\"\"Return the first subclass of this class\"\"\"\n        for subklass in cls.__subclasses__():\n            return subklass\n        return object\n\n\nsubclass = Base.get_first_subclass()  # pylint: disable=invalid-name\n\n\nclass Another(subclass):\n    \"\"\"Create a class from the __subclasses__ attribute of another class\"\"\"\n"}], "retrieved_count": 10, "cost_time": 1.0656695365905762}
{"question": "What is the exception handling pattern that catches an exception and raises a new one with 'from None' to decouple error detection from propagation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "raise_missing_from.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint:disable=missing-docstring, unreachable, using-constant-test, invalid-name, bare-except\n# pylint:disable=try-except-raise, undefined-variable, too-few-public-methods, superfluous-parens, no-else-raise\n\ntry:\n    1 / 0\nexcept:\n    raise ValueError('Invalid integer')  # [raise-missing-from]\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    # +1: [raise-missing-from]\n    raise KeyError\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    # Our algorithm doesn't have to be careful about the complicated expression below,\n    # because the exception above wasn't bound to a name. # +1: [raise-missing-from]\n    raise (foo + bar).baz\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError\nelse:\n    pass\nfinally:\n    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    if 1:\n        if 1:\n            with whatever:\n                try:\n                    # +1: [raise-missing-from]\n                    raise KeyError\n                except:\n                    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError()\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError(whatever, whatever=whatever)\n\n\ntry:\n    1 / 0\nexcept (ZeroDivisionError, ValueError, KeyError):\n    if 1:\n        if 2:\n            pass\n        else:\n            with whatever:\n                # +1: [raise-missing-from]\n                raise KeyError(whatever, whatever=whatever)\n    else:\n        # +1: [raise-missing-from]\n        raise KeyError(whatever, overever=12)\n\ntry:\n    # Taken from https://github.com/python/cpython/blob/3.10/Lib/plistlib.py#L459\n    pass\nexcept (OSError, IndexError, struct.error, OverflowError,\n        ValueError):\n    raise InvalidFileException()  # [raise-missing-from]\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    raise KeyError from foo\n\ntry:\n    1 / 0\nexcept "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "raise_missing_from.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " [raise-missing-from]\n                    raise KeyError\n                except:\n                    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError()\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    # +1: [raise-missing-from]\n    raise KeyError(whatever, whatever=whatever)\n\n\ntry:\n    1 / 0\nexcept (ZeroDivisionError, ValueError, KeyError):\n    if 1:\n        if 2:\n            pass\n        else:\n            with whatever:\n                # +1: [raise-missing-from]\n                raise KeyError(whatever, whatever=whatever)\n    else:\n        # +1: [raise-missing-from]\n        raise KeyError(whatever, overever=12)\n\ntry:\n    # Taken from https://github.com/python/cpython/blob/3.10/Lib/plistlib.py#L459\n    pass\nexcept (OSError, IndexError, struct.error, OverflowError,\n        ValueError):\n    raise InvalidFileException()  # [raise-missing-from]\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    raise KeyError from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    raise (foo + bar).baz from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError from foo\nelse:\n    pass\nfinally:\n    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    if 1:\n        if 1:\n            with whatever:\n                try:\n                    raise KeyError from foo\n                except:\n                    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError() from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError(whatever, whatever=whatever) from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    raise\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise e\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    if 1:\n        if 1:\n            if 1:\n                raise e\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise e.with_traceback(e.__traceback__"}, {"start_line": 2000, "end_line": 3235, "belongs_to": {"file_name": "raise_missing_from.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ZeroDivisionError:\n    raise (foo + bar).baz from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError from foo\nelse:\n    pass\nfinally:\n    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    if 1:\n        if 1:\n            with whatever:\n                try:\n                    raise KeyError from foo\n                except:\n                    pass\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError() from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise KeyError(whatever, whatever=whatever) from foo\n\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    raise\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise e\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    if 1:\n        if 1:\n            if 1:\n                raise e\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise e.with_traceback(e.__traceback__)\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise (e + 7)\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    def f():\n        raise KeyError\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    class Foo:\n        raise KeyError\n"}, {"start_line": 0, "end_line": 167, "belongs_to": {"file_name": "specialized_exception.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/t/try-except-raise/good", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Another more detailed exception can be raised:\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise ValueError(\"The area of the rectangle cannot be zero\") from e\n"}, {"start_line": 0, "end_line": 947, "belongs_to": {"file_name": "bad_exception_cause.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/b", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check that raise ... from .. uses a proper exception cause \"\"\"\n\n# pylint: disable=unreachable, import-error, multiple-imports\n\nimport socket, unknown\n\n\nclass ExceptionSubclass(Exception):\n    \"\"\" subclass \"\"\"\n\ndef test():\n    \"\"\" docstring \"\"\"\n    raise IndexError from 1 # [bad-exception-cause]\n    raise IndexError from None\n    raise IndexError from ZeroDivisionError\n    raise IndexError from object() # [bad-exception-cause]\n    raise IndexError from ExceptionSubclass\n    raise IndexError from socket.error\n    raise IndexError() from None\n    raise IndexError() from ZeroDivisionError\n    raise IndexError() from ZeroDivisionError()\n    raise IndexError() from object() # [bad-exception-cause]\n    raise IndexError() from unknown\n\ndef function():\n    \"\"\"Function to be passed as exception\"\"\"\n\ntry:\n    pass\nexcept function as exc:  # [catching-non-exception]\n    raise Exception from exc  # [bad-exception-cause, broad-exception-raised]\n"}, {"start_line": 0, "end_line": 1231, "belongs_to": {"file_name": "broad_exception_raised.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/b/broad_exception", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring, unreachable\n\nExceptionAlias = Exception\n\nclass CustomBroadException(Exception):\n    pass\n\n\nclass CustomNarrowException(CustomBroadException):\n    pass\n\n\ndef exploding_apple(apple):\n    print(f\"{apple} is about to explode\")\n    raise Exception(\"{apple} exploded !\")  # [broad-exception-raised]\n\n\ndef raise_and_catch():\n    try:\n        raise Exception(\"Oh No!!\")  # [broad-exception-raised]\n    except Exception as ex:  # [broad-exception-caught]\n        print(ex)\n\n\ndef raise_catch_reraise():\n    try:\n        exploding_apple(\"apple\")\n    except Exception as ex:\n        print(ex)\n        raise ex\n\n\ndef raise_catch_raise():\n    try:\n        exploding_apple(\"apple\")\n    except Exception as ex:\n        print(ex)\n        raise Exception() from None  # [broad-exception-raised]\n\n\ndef raise_catch_raise_using_alias():\n    try:\n        exploding_apple(\"apple\")\n    except Exception as ex:\n        print(ex)\n        raise ExceptionAlias() from None  # [broad-exception-raised]\n\nraise Exception()  # [broad-exception-raised]\nraise BaseException()  # [broad-exception-raised]\nraise CustomBroadException()  # [broad-exception-raised]\nraise IndexError from None\nraise CustomNarrowException() from None\n"}, {"start_line": 0, "end_line": 78, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/t/try-except-raise", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try:\n    1 / 0\nexcept ZeroDivisionError as e:  # [try-except-raise]\n    raise\n"}, {"start_line": 0, "end_line": 378, "belongs_to": {"file_name": "raising_non_exception.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/raising", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"The following code should emit a raising-non-exception.\n\nPreviously, it didn't, due to a bug in the check for bad-exception-cause,\nwhich prevented further checking on the Raise node.\n\"\"\"\n# pylint: disable=import-error, too-few-public-methods\n\nfrom missing_module import missing\n\nclass Exc:\n    \"\"\"Not an actual exception.\"\"\"\n\nraise Exc from missing # [raising-non-exception]\n"}, {"start_line": 0, "end_line": 124, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/r/raise-missing-from", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try:\n    1 / 0\nexcept ZeroDivisionError as e:\n    raise ValueError(\"Rectangle Area cannot be zero\")  # [raise-missing-from]\n"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "exceptions.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=node, confidence=INFERENCE)\n\n    def _check_raise_missing_from(self, node: nodes.Raise) -> None:\n        if node.exc is None:\n            # This is a plain `raise`, raising the previously-caught exception. No need for a\n            # cause.\n            return\n        # We'd like to check whether we're inside an `except` clause:\n        containing_except_node = utils.find_except_wrapper_node_in_scope(node)\n        if not containing_except_node:\n            return\n        # We found a surrounding `except`! We're almost done proving there's a\n        # `raise-missing-from` here. The only thing we need to protect against is that maybe\n        # the `raise` is raising the exception that was caught, possibly with some shenanigans\n        # like `exc.with_traceback(whatever)`. We won't analyze these, we'll just assume\n        # there's a violation on two simple cases: `raise SomeException(whatever)` and `raise\n        # SomeException`.\n        if containing_except_node.name is None:\n            # The `except` doesn't have an `as exception:` part, meaning there's no way that\n            # the `raise` is raising the same exception.\n            class_of_old_error = \"Exception\"\n            if isinstance(containing_except_node.type, (nodes.Name, nodes.Tuple)):\n                # 'except ZeroDivisionError' or 'except (ZeroDivisionError, ValueError)'\n                class_of_old_error = containing_except_node.type.as_string()\n            self.add_message(\n                \"raise-missing-from\",\n                node=node,\n                args=(\n                    f\"'except {class_of_old_error} as exc' and \",\n                    node.as_string(),\n                    \"exc\",\n                ),\n                confidence=HIGH,\n            )\n        elif (\n            isinstance(node.exc, nodes.Call) and isinstance(node.exc.func, nodes.Name)\n        ) or (\n            isinstance(node.exc, nodes.Name)\n            and node.exc.name != containing_except_node.name.name\n        ):\n          "}], "retrieved_count": 10, "cost_time": 1.0527865886688232}
{"question": "What architectural decision in the while-loop refactoring checker requires a control flow tracking flag when traversing nested if-else chains to identify break statements and prevent false positives?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gs = {\n        \"R3501\": (\n            \"Consider using 'while %s' instead of 'while %s:' an 'if', and a 'break'\",\n            \"consider-refactoring-into-while-condition\",\n            \"Emitted when `while True:` loop is used and the first statement is a break condition. \"\n            \"The ``if / break`` construct can be removed if the check is inverted and moved to \"\n            \"the ``while`` statement.\",\n        ),\n    }\n\n    @utils.only_required_for_messages(\"consider-refactoring-into-while-condition\")\n    def visit_while(self, node: nodes.While) -> None:\n        self._check_breaking_after_while_true(node)\n\n    def _check_breaking_after_while_true(self, node: nodes.While) -> None:\n        \"\"\"Check that any loop with an ``if`` clause has a break statement.\"\"\"\n        if not isinstance(node.test, nodes.Const) or not node.test.bool_value():\n            return\n        pri_candidates: list[nodes.If] = []\n        for n in node.body:\n            if not isinstance(n, nodes.If):\n                break\n            pri_candidates.append(n)\n        candidates = []\n        tainted = False\n        for c in pri_candidates:\n            if tainted or not isinstance(c.body[0], nodes.Break):\n                break\n            candidates.append(c)\n            orelse = c.orelse\n            while orelse:\n                orelse_node = orelse[0]\n                if not isinstance(orelse_node, nodes.If):\n                    tainted = True\n                else:\n                    candidates.append(orelse_node)\n                if not isinstance(orelse_node, nodes.If):\n                    break\n                orelse = orelse_node.orelse\n\n        candidates = [n for n in candidates if isinstance(n.body[0], nodes.Break)]\n        msg = \" and \".join(\n            [f\"({utils.not_condition_as_string(c.test)})\" for c in candidates]\n        )\n        if len(candidates) == 1:\n            msg = utils.not_condition_as_string(candidates[0].test)\n        if not msg:\n            return\n\n        self.add_mess"}, {"start_line": 2000, "end_line": 3322, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  break\n            pri_candidates.append(n)\n        candidates = []\n        tainted = False\n        for c in pri_candidates:\n            if tainted or not isinstance(c.body[0], nodes.Break):\n                break\n            candidates.append(c)\n            orelse = c.orelse\n            while orelse:\n                orelse_node = orelse[0]\n                if not isinstance(orelse_node, nodes.If):\n                    tainted = True\n                else:\n                    candidates.append(orelse_node)\n                if not isinstance(orelse_node, nodes.If):\n                    break\n                orelse = orelse_node.orelse\n\n        candidates = [n for n in candidates if isinstance(n.body[0], nodes.Break)]\n        msg = \" and \".join(\n            [f\"({utils.not_condition_as_string(c.test)})\" for c in candidates]\n        )\n        if len(candidates) == 1:\n            msg = utils.not_condition_as_string(candidates[0].test)\n        if not msg:\n            return\n\n        self.add_message(\n            \"consider-refactoring-into-while-condition\",\n            node=node,\n            line=node.lineno,\n            args=(msg, node.test.as_string()),\n            confidence=HIGH,\n        )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ConsiderRefactorIntoWhileConditionChecker(linter))\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s should chain conditions into\n        # While (x == 0) and (x >= 0) and (x != 0):\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x > 0:\n                x -= 1\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            x -= 10\n\n    def test_multi_break_condition_2(self):\n        x = 0\n        # This should chain both conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            if x == 0:\n                break\n            x -= 10\n\n    def test_multi_break_condition_3(self):\n        x = 0\n        # This should chain all conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            if x != 100:\n                break\n            if x == 1000:\n                break\n            x -= 10\n\n    def test_multi_break_condition_4(self):\n        x = 0\n        # This should chain all conditions except last 2.\n        # The else clause taints the first if-elif-else block by introducing mutation\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            else:\n                x += 1\n            if x != 100:\n                break\n            if x == 1000:\n                break\n            x -= 10\n\n    def falsy_1(self):\n        x = 0\n        while []:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_2(self):\n        x = 0\n        while ():\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_3(self):\n        x = 0\n        while {}:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_4(se"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Looks for try/except statements with too much code in the try clause.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint import checkers\nfrom pylint.checkers import utils\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass ConsiderRefactorIntoWhileConditionChecker(checkers.BaseChecker):\n    \"\"\"Checks for instances where while loops are implemented with a constant condition\n    which.\n\n    always evaluates to truthy and the first statement(s) is/are if statements which, when\n    evaluated.\n\n    to True, breaks out of the loop.\n\n    The if statement(s) can be refactored into the while loop.\n    \"\"\"\n\n    name = \"consider_refactoring_into_while\"\n    msgs = {\n        \"R3501\": (\n            \"Consider using 'while %s' instead of 'while %s:' an 'if', and a 'break'\",\n            \"consider-refactoring-into-while-condition\",\n            \"Emitted when `while True:` loop is used and the first statement is a break condition. \"\n            \"The ``if / break`` construct can be removed if the check is inverted and moved to \"\n            \"the ``while`` statement.\",\n        ),\n    }\n\n    @utils.only_required_for_messages(\"consider-refactoring-into-while-condition\")\n    def visit_while(self, node: nodes.While) -> None:\n        self._check_breaking_after_while_true(node)\n\n    def _check_breaking_after_while_true(self, node: nodes.While) -> None:\n        \"\"\"Check that any loop with an ``if`` clause has a break statement.\"\"\"\n        if not isinstance(node.test, nodes.Const) or not node.test.bool_value():\n            return\n        pri_candidates: list[nodes.If] = []\n        for n in node.body:\n            if not isinstance(n, nodes.If):\n              "}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ment is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n            return False\n        for inner_else_statement in other_node_try_except.orelse:\n            if isinstance(inner_else_statement, nodes.Break):\n                break_stmt = inner_else_statement\n                break\n        else:\n            # No break statement\n            return False\n\n        def _try_in_loop_body(\n            other_node_try_except: nodes.Try,\n            loop: nodes.For | nodes.While,\n        ) -> bool:\n            \"\"\"Return True if `other_node_try_except` is a descendant of `loop`.\"\"\"\n            return any(\n                loop_body_statement is other_node_try_except\n                or loop_body_statement.parent_of(other_node_try_except)\n                for loop_body_statement in loop.body\n            )\n\n        if not _try_in_loop_body(other_node_try_except, closest_loop):\n            for ancestor in closest_loop.node_ancestors():\n                if isinstance(ancestor, (nodes.For, nodes.While)):\n                    if _try_in_loop_body(other_node_try_except, ancestor):\n                        break\n            else:\n                # `other_node_try_except` didn't have a shared ancestor loop\n                return False\n\n        for loop_stmt in closest_loop.body:\n            if NamesConsumer._recursive_search_for_continue_before_break(\n                loop_stmt, break_stmt\n            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n    @staticmethod\n    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement,\n        break_stmt: nodes.Break,\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n "}, {"start_line": 7000, "end_line": 8957, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " if x == 1000:\n                break\n            x -= 10\n\n    def test_multi_break_condition_4(self):\n        x = 0\n        # This should chain all conditions except last 2.\n        # The else clause taints the first if-elif-else block by introducing mutation\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            else:\n                x += 1\n            if x != 100:\n                break\n            if x == 1000:\n                break\n            x -= 10\n\n    def falsy_1(self):\n        x = 0\n        while []:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_2(self):\n        x = 0\n        while ():\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_3(self):\n        x = 0\n        while {}:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_4(self):\n        x = 0\n        while set():\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_5(self):\n        x = 0\n        while \"\":\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_6(self):\n        x = 0\n        while range(0):\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_7(self):\n        x = 0\n        while 0:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_8(self):\n        x = 0\n        while 0.0:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_9(self):\n        x = 0\n        while 0j:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_10(self):\n        x = 0\n        while None:\n            if x > 10:\n                break\n            x += 1\n\n    def falsy_11(self):\n        x = 0\n        while False:\n            if x > 10:\n                break\n            x += 1\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/consider_refactoring_into_while_condition", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "):\n                break\n            break\n\n    def test_error_message_17(self):\n        a = True\n        b = False\n        c = True\n        d = False\n        while True:  # [consider-refactoring-into-while-condition]\n            if (a or b) == (c and d):\n                break\n            a = not a if random.randint(0,1) == 1 else a\n            b = not b if random.randint(0,1) == 1 else b\n            c = not c if random.randint(0,1) == 1 else c\n            d = not d if random.randint(0,1) == 1 else d\n\n        while True:  # [consider-refactoring-into-while-condition]\n            if (not a) == (not d):\n                break\n            a = not a if random.randint(0,1) == 1 else a\n            d = not d if random.randint(0,1) == 1 else d\n\n    def test_error_message_18(self):\n        x = 0\n        while True:  # [consider-refactoring-into-while-condition]\n            if x ** 2:\n                break\n            x += 1\n\n    def test_multi_break_condition_1(self):\n        x = 0\n        # This should chain conditions into\n        # While (x == 0) and (x >= 0) and (x != 0):\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x > 0:\n                x -= 1\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            x -= 10\n\n    def test_multi_break_condition_2(self):\n        x = 0\n        # This should chain both conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            if x == 0:\n                break\n            x -= 10\n\n    def test_multi_break_condition_3(self):\n        x = 0\n        # This should chain all conditions\n        while True:  # [consider-refactoring-into-while-condition]\n            if x != 0:\n                break\n            elif x < 0:\n                break\n            elif x == 0:\n                break\n            if x != 100:\n                break\n           "}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ode: nodes.NodeNG,\n        other_node_try_except: nodes.Try,\n    ) -> bool:\n        \"\"\"Check for a specific control flow scenario.\n\n        Described in https://github.com/pylint-dev/pylint/issues/5683.\n\n        A scenario where the only non-break exit from a loop consists of the very\n        except handler we are examining, such that code in the `else` branch of\n        the loop can depend on it being assigned.\n\n        Example:\n        for _ in range(3):\n            try:\n                do_something()\n            except:\n                name = 1  <-- only non-break exit from loop\n            else:\n                break\n        else:\n            print(name)\n        \"\"\"\n        if not other_node_try_except.orelse:\n            return False\n        closest_loop: None | (nodes.For | nodes.While) = (\n            utils.get_node_first_ancestor_of_type(node, (nodes.For, nodes.While))\n        )\n        if closest_loop is None:\n            return False\n        if not any(\n            else_statement is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n            return False\n        for inner_else_statement in other_node_try_except.orelse:\n            if isinstance(inner_else_statement, nodes.Break):\n                break_stmt = inner_else_statement\n                break\n        else:\n            # No break statement\n            return False\n\n        def _try_in_loop_body(\n            other_node_try_except: nodes.Try,\n            loop: nodes.For | nodes.While,\n        ) -> bool:\n            \"\"\"Return True if `other_node_try_except` is a descendant of `loop`.\"\"\"\n            return any(\n                loop_body_statement is other_node_try_except\n                or loop_body_statement.parent_of(other_node_try_except)\n                for loop_body_statement in loop.body\n            )\n\n        if not _try_in_loop_body(other_node_try_except, closest_loop):\n            for ancestor in "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eak): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    parent = break_node.parent\n    while not isinstance(parent, loop_nodes) or break_node in getattr(\n        parent, \"orelse\", []\n    ):\n        break_node = parent\n        parent = parent.parent\n        if parent is None:\n            break\n    return parent\n\n\ndef _loop_exits_early(loop: nodes.For | nodes.While) -> bool:\n    \"\"\"Returns true if a loop may end with a break statement.\n\n    Args:\n        loop (astroid.For, astroid.While): the loop node inspected.\n\n    Returns:\n        bool: True if the loop may end with a break statement, False otherwise.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    definition_nodes = (nodes.FunctionDef, nodes.ClassDef)\n    inner_loop_nodes: list[nodes.For | nodes.While] = [\n        _node\n        for _node in loop.nodes_of_class(loop_nodes, skip_klass=definition_nodes)\n        if _node != loop\n    ]\n    return any(\n        _node\n        for _node in loop.nodes_of_class(nodes.Break, skip_klass=definition_nodes)\n        if _get_break_loop_node(_node) not in inner_loop_nodes\n    )\n\n\ndef _has_abstract_methods(node: nodes.ClassDef) -> bool:\n    \"\"\"Determine if the given `node` has abstract methods.\n\n    The methods should be made abstract by decorating them\n    with `abc` decorators.\n    \"\"\"\n    return len(utils.unimplemented_abstract_methods(node)) > 0\n\n\ndef redefined_by_decorator(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return True if the object is a method redefined via decorator.\n\n    For example:\n        @property\n        def x(self): return self._x\n        @x.setter\n        def x(self, value): self._x = value\n    \"\"\"\n    if node.decorators:\n        for decorator in node.decorators.nodes:\n            if (\n                isinstance(decorator, nodes.Attribute)\n                and getattr(decorator.expr, \"name\", None) == node.name\n            ):\n            "}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "closest_loop.node_ancestors():\n                if isinstance(ancestor, (nodes.For, nodes.While)):\n                    if _try_in_loop_body(other_node_try_except, ancestor):\n                        break\n            else:\n                # `other_node_try_except` didn't have a shared ancestor loop\n                return False\n\n        for loop_stmt in closest_loop.body:\n            if NamesConsumer._recursive_search_for_continue_before_break(\n                loop_stmt, break_stmt\n            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n    @staticmethod\n    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement,\n        break_stmt: nodes.Break,\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n            return False\n        if isinstance(stmt, nodes.Continue):\n            return True\n        for child in stmt.get_children():\n            if isinstance(stmt, (nodes.For, nodes.While)):\n                continue\n            if NamesConsumer._recursive_search_for_continue_before_break(\n                child, break_stmt\n            ):\n                return True\n        return False\n\n    @staticmethod\n    def _uncertain_nodes_in_try_blocks_when_evaluating_except_blocks(\n        found_nodes: list[nodes.NodeNG],\n        node_statement: _base_nodes.Statement,\n    ) -> list[nodes.NodeNG]:\n        \"\"\"Return any nodes in ``found_nodes`` that should be treated as uncertain.\n\n        Nodes are uncertain when they are in a try block and the ``node_statement``\n        being evaluated is in one of its except handlers.\n        \"\"\"\n        uncertain_nodes: list[nodes.NodeNG] = []\n        closest_except_handler = utils.get_node_first_ancestor_of_type(\n            node_statement, nodes.ExceptHan"}], "retrieved_count": 10, "cost_time": 1.0628552436828613}
{"question": "How does the test class that extends parent slots using augmentation assignment interact with ancestor slot definitions in the class checker?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def __setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n "}, {"start_line": 62000, "end_line": 64000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_slot_value = getattr(inferred_slot, \"value\", None)\n                if isinstance(inferred_slot_value, str):\n                    slots_names.append(inferred_slot_value)\n        return slots_names\n\n    def _check_redefined_slots(\n        self,\n        node: nodes.ClassDef,\n        slots_node: nodes.NodeNG,\n        slots_list: list[nodes.NodeNG],\n    ) -> None:\n        \"\"\"Check if `node` redefines a slot which is defined in an ancestor class.\"\"\"\n        slots_names: list[str] = self._get_slots_names(slots_list)\n\n        # Slots of all parent classes\n        ancestors_slots_names = {\n            slot.value\n            for ancestor in node.local_attr_ancestors(\"__slots__\")\n            for slot in ancestor.slots() or []\n        }\n\n        # Slots which are common to `node` and its parent classes\n        redefined_slots = ancestors_slots_names.intersection(slots_names)\n\n        if redefined_slots:\n            self.add_message(\n                \"redefined-slots-in-subclass\",\n                args=([name for name in slots_names if name in redefined_slots],),\n                node=slots_node,\n            )\n\n    def _check_slots_elt(\n        self, elt: SuccessfulInferenceResult, node: nodes.ClassDef\n    ) -> None:\n        for inferred in elt.infer():\n            if isinstance(inferred, util.UninferableBase):\n                continue\n            if not isinstance(inferred, nodes.Const) or not isinstance(\n                inferred.value, str\n            ):\n                self.add_message(\n                    \"invalid-slots-object\",\n                    args=elt.as_string(),\n                    node=elt,\n                    confidence=INFERENCE,\n                )\n                continue\n            if not inferred.value:\n                self.add_message(\n                    \"invalid-slots-object\",\n                    args=elt.as_string(),\n                    node=elt,\n                    confidence=INFERENCE,\n                )\n\n            # Check if we have a conflict with a class"}, {"start_line": 0, "end_line": 123, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/r/redefined-slots-in-subclass", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = (\"a\", \"d\")  # [redefined-slots-in-subclass]\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def _"}, {"start_line": 0, "end_line": 217, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/a/assigning-non-slot", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Student:\n    __slots__ = (\"name\",)\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n\n    def setup(self):\n        pass\n"}, {"start_line": 4000, "end_line": 5061, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n    __slots__ = ()\n\n\nrepro = Repro()\nrepro.attr2 = \"anything\"\n"}, {"start_line": 61000, "end_line": 63000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "enceError:\n                    continue\n            self._check_redefined_slots(node, slots, values)\n\n    def _get_classdef_slots_names(self, node: nodes.ClassDef) -> list[str]:\n\n        slots_names: list[str] = []\n        try:\n            inferred_slots = tuple(node.ilookup(\"__slots__\"))\n        except astroid.InferenceError:  # pragma: no cover\n            return slots_names\n        for slots in inferred_slots:\n            if isinstance(slots, nodes.Dict):\n                values = [item[0] for item in slots.items]\n            else:\n                values = slots.itered()\n            slots_names.extend(self._get_slots_names(values))\n\n        return slots_names\n\n    def _get_slots_names(self, slots_list: list[nodes.NodeNG]) -> list[str]:\n        slots_names: list[str] = []\n        for slot in slots_list:\n            if isinstance(slot, nodes.Const):\n                slots_names.append(slot.value)\n            else:\n                inferred_slot = safe_infer(slot)\n                inferred_slot_value = getattr(inferred_slot, \"value\", None)\n                if isinstance(inferred_slot_value, str):\n                    slots_names.append(inferred_slot_value)\n        return slots_names\n\n    def _check_redefined_slots(\n        self,\n        node: nodes.ClassDef,\n        slots_node: nodes.NodeNG,\n        slots_list: list[nodes.NodeNG],\n    ) -> None:\n        \"\"\"Check if `node` redefines a slot which is defined in an ancestor class.\"\"\"\n        slots_names: list[str] = self._get_slots_names(slots_list)\n\n        # Slots of all parent classes\n        ancestors_slots_names = {\n            slot.value\n            for ancestor in node.local_attr_ancestors(\"__slots__\")\n            for slot in ancestor.slots() or []\n        }\n\n        # Slots which are common to `node` and its parent classes\n        redefined_slots = ancestors_slots_names.intersection(slots_names)\n\n        if redefined_slots:\n            self.add_message(\n                \"redefined-slots-in-subclass\",\n                ar"}, {"start_line": 67000, "end_line": 69000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          if hasattr(elt, \"attrname\") and elt.attrname == \"__class__\":\n                    class_index = i\n            if class_index == -1:\n                # This should not happen because we checked that the node name\n                # is '__class__' earlier, but let's not be too confident here\n                return  # pragma: no cover\n            inferred = safe_infer(node.parent.parent.value.elts[class_index])\n        else:\n            inferred = safe_infer(node.parent.value)\n        if (\n            isinstance(inferred, (nodes.ClassDef, util.UninferableBase))\n            or inferred is None\n        ):\n            # If is uninferable, we allow it to prevent false positives\n            return\n        self.add_message(\n            \"invalid-class-object\",\n            node=node,\n            args=inferred.__class__.__name__,\n            confidence=INFERENCE,\n        )\n\n    def _check_in_slots(self, node: nodes.AssignAttr) -> None:\n        \"\"\"Check that the given AssignAttr node\n        is defined in the class slots.\n        \"\"\"\n        inferred = safe_infer(node.expr)\n        if not isinstance(inferred, astroid.Instance):\n            return\n\n        klass = inferred._proxied\n        if not has_known_bases(klass):\n            return\n        if \"__slots__\" not in klass.locals:\n            return\n        # If `__setattr__` is defined on the class, then we can't reason about\n        # what will happen when assigning to an attribute.\n        if any(\n            base.locals.get(\"__setattr__\")\n            for base in klass.mro()\n            if base.qname() != \"builtins.object\"\n        ):\n            return\n\n        # If 'typing.Generic' is a base of bases of klass, the cached version\n        # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.\n        if any(base.qname() == \"typing.Generic\" for base in klass.mro()):\n            cache = getattr(klass, \"__cache\", None)\n            if cache and cache.get(klass.slots) is not None:\n                del"}, {"start_line": 0, "end_line": 481, "belongs_to": {"file_name": "assigning_non_slot_4509.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=invalid-name,missing-docstring,too-few-public-methods\n\n# Slots with base that inherits from 'Generic'\n# https://github.com/pylint-dev/pylint/issues/4509\n# https://github.com/pylint-dev/astroid/issues/999\n\nfrom typing import Generic, TypeVar\nT = TypeVar(\"T\")\n\nclass Base(Generic[T]):\n    __slots__ = ()\n\nclass Foo(Base[T]):\n    __slots__ = ['_value']\n\n    def __init__(self, value: T):\n        self._value = value\n        self._bar = value  # [assigning-non-slot]\n"}, {"start_line": 0, "end_line": 1165, "belongs_to": {"file_name": "redefined_slots.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/redefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Checks that a subclass does not redefine a slot which has been defined in a parent class.\"\"\"\n\n# pylint: disable=too-few-public-methods, invalid-slots-object\n\nfrom collections import deque\n\n\nclass Base:\n    \"\"\"Class defining the `a`, `b` & `deque.__name__` slots\"\"\"\n    __slots__ = (\"a\", \"b\", deque.__name__)\n\n\nclass Subclass1(Base):\n    \"\"\"Redefining the `a` & `deque.__name__` slots & adding the `d` & `e` slots\"\"\"\n    __slots__ = (\"a\", deque.__name__, \"d\", \"e\")  # [redefined-slots-in-subclass]\n\n\nclass Subclass2(Base):\n    \"\"\"Adding the `f`, `g` & `h` slots\"\"\"\n    __slots__ = (\"f\", \"g\", \"h\")\n\n\nclass Base2:\n    \"\"\"Class defining the `i`, `j` & `k` slots\"\"\"\n    __slots__ = (\"i\", \"j\", \"k\")\n\n\nclass Subclass3(Base, Base2):\n    \"\"\"Adding the `l`, `m`, `n` slots\n       Redefining the `a`, `b`, & `c` slot already defined in `Base`\n       Redefining the `i`, `j`, `k` slot already defined in `Base2`\n    \"\"\"\n    __slots__ = (\"a\", \"b\", \"c\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\")  # [redefined-slots-in-subclass]\n\n\n# https://github.com/pylint-dev/pylint/issues/6100\nclass MyClass:\n    \"\"\"No crash when the type of the slot is not a Const or a str\"\"\"\n    __slots__ = [str]\n"}], "retrieved_count": 10, "cost_time": 1.0495471954345703}
{"question": "What is the lazy initialization pattern using a boolean flag in the private import checker that prevents redundant type annotation scanning across multiple import statements?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  def __init__(self, linter: PyLinter) -> None:\n        BaseChecker.__init__(self, linter)\n\n        # A mapping of private names used as a type annotation to whether it is an acceptable import\n        self.all_used_type_annotations: dict[str, bool] = {}\n        self.populated_annotations = False\n\n    @utils.only_required_for_messages(\"import-private-name\")\n    def visit_import(self, node: nodes.Import) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        names = [name[0] for name in node.names]\n        private_names = self._get_private_imports(names)\n        private_names = self._get_type_annotation_names(node, private_names)\n        if private_names:\n            imported_identifier = \"modules\" if len(private_names) > 1 else \"module\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n                confidence=HIGH,\n            )\n\n    @utils.only_required_for_messages(\"import-private-name\")\n    def visit_importfrom(self, node: nodes.ImportFrom) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        # Only check imported names if the module is external\n        if self.same_root_dir(node, node.modname):\n            return\n\n        names = [n[0] for n in node.names]\n\n        # Check the imported objects first. If they are all valid type annotations,\n        # the package can be private\n        private_names = self._get_type_annotation_names(node, names)\n        if not private_names:\n            return\n\n        # There are invalid imported objects, so check the name of the package\n        private_module_imports = self._get_private_imports([node.modname])\n        private_module_imports = self._get_type_annotation_names(\n            node, private_module_imports\n        )\n        if private_module_imports:\n            self.add_message(\n              "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Check for imports on private external modules and names.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\nclass PrivateImportChecker(BaseChecker):\n    name = \"import-private-name\"\n    msgs = {\n        \"C2701\": (\n            \"Imported private %s (%s)\",\n            \"import-private-name\",\n            \"Used when a private module or object prefixed with _ is imported. \"\n            \"PEP8 guidance on Naming Conventions states that public attributes with \"\n            \"leading underscores should be considered private.\",\n        ),\n    }\n\n    def __init__(self, linter: PyLinter) -> None:\n        BaseChecker.__init__(self, linter)\n\n        # A mapping of private names used as a type annotation to whether it is an acceptable import\n        self.all_used_type_annotations: dict[str, bool] = {}\n        self.populated_annotations = False\n\n    @utils.only_required_for_messages(\"import-private-name\")\n    def visit_import(self, node: nodes.Import) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        names = [name[0] for name in node.names]\n        private_names = self._get_private_imports(names)\n        private_names = self._get_type_annotation_names(node, private_names)\n        if private_names:\n            imported_identifier = \"modules\" if len(private_names) > 1 else \"module\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n      "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  \"import-private-name\",\n                node=node,\n                args=(\"module\", private_module_imports[0]),\n                confidence=HIGH,\n            )\n            return  # Do not emit messages on the objects if the package is private\n\n        private_names = self._get_private_imports(private_names)\n\n        if private_names:\n            imported_identifier = \"objects\" if len(private_names) > 1 else \"object\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n                confidence=HIGH,\n            )\n\n    def _get_private_imports(self, names: list[str]) -> list[str]:\n        \"\"\"Returns the private names from input names by a simple string check.\"\"\"\n        return [name for name in names if self._name_is_private(name)]\n\n    @staticmethod\n    def _name_is_private(name: str) -> bool:\n        \"\"\"Returns true if the name exists, starts with `_`, and if len(name) > 4\n        it is not a dunder, i.e. it does not begin and end with two underscores.\n        \"\"\"\n        return (\n            bool(name)\n            and name[0] == \"_\"\n            and (len(name) <= 4 or name[1] != \"_\" or name[-2:] != \"__\")\n        )\n\n    def _get_type_annotation_names(\n        self, node: nodes.Import | nodes.ImportFrom, names: list[str]\n    ) -> list[str]:\n        \"\"\"Removes from names any names that are used as type annotations with no other\n        illegal usages.\n        \"\"\"\n        if names and not self.populated_annotations:\n            self._populate_type_annotations(node.root(), self.all_used_type_annotations)\n            self.populated_annotations = True\n\n        return [\n            n\n            for n in names\n            if n not in self.all_used_type_annotations\n            or (\n                n in self.all_used_type_annotations\n                and not self.all_used_type_annotations[n]\n            )\n     "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          confidence=HIGH,\n            )\n\n    @utils.only_required_for_messages(\"import-private-name\")\n    def visit_importfrom(self, node: nodes.ImportFrom) -> None:\n        if utils.in_type_checking_block(node):\n            return\n        # Only check imported names if the module is external\n        if self.same_root_dir(node, node.modname):\n            return\n\n        names = [n[0] for n in node.names]\n\n        # Check the imported objects first. If they are all valid type annotations,\n        # the package can be private\n        private_names = self._get_type_annotation_names(node, names)\n        if not private_names:\n            return\n\n        # There are invalid imported objects, so check the name of the package\n        private_module_imports = self._get_private_imports([node.modname])\n        private_module_imports = self._get_type_annotation_names(\n            node, private_module_imports\n        )\n        if private_module_imports:\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(\"module\", private_module_imports[0]),\n                confidence=HIGH,\n            )\n            return  # Do not emit messages on the objects if the package is private\n\n        private_names = self._get_private_imports(private_names)\n\n        if private_names:\n            imported_identifier = \"objects\" if len(private_names) > 1 else \"object\"\n            private_name_string = \", \".join(private_names)\n            self.add_message(\n                \"import-private-name\",\n                node=node,\n                args=(imported_identifier, private_name_string),\n                confidence=HIGH,\n            )\n\n    def _get_private_imports(self, names: list[str]) -> list[str]:\n        \"\"\"Returns the private names from input names by a simple string check.\"\"\"\n        return [name for name in names if self._name_is_private(name)]\n\n    @staticmethod\n    def _name_is_private(name: str) -> bool:\n        \"\"\"Returns true if "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ute\n            return self._populate_type_annotations_annotation(\n                node.expr, all_used_type_annotations\n            )\n        return None\n\n    @staticmethod\n    def _assignments_call_private_name(\n        assignments: list[nodes.AnnAssign | nodes.Assign], private_name: str\n    ) -> bool:\n        \"\"\"Returns True if no assignments involve accessing `private_name`.\"\"\"\n        if all(not assignment.value for assignment in assignments):\n            # Variable annotated but unassigned is not allowed because there may be\n            # possible illegal access elsewhere\n            return False\n        for assignment in assignments:\n            current_attribute = None\n            if isinstance(assignment.value, nodes.Call):\n                current_attribute = assignment.value.func\n            elif isinstance(assignment.value, nodes.Attribute):\n                current_attribute = assignment.value\n            elif isinstance(assignment.value, nodes.Name):\n                current_attribute = assignment.value.name\n            if not current_attribute:\n                continue\n            while isinstance(current_attribute, (nodes.Attribute, nodes.Call)):\n                if isinstance(current_attribute, nodes.Call):\n                    current_attribute = current_attribute.func\n                if not isinstance(current_attribute, nodes.Name):\n                    current_attribute = current_attribute.expr\n            if (\n                isinstance(current_attribute, nodes.Name)\n                and current_attribute.name == private_name\n            ):\n                return False\n        return True\n\n    @staticmethod\n    def same_root_dir(\n        node: nodes.Import | nodes.ImportFrom, import_mod_name: str\n    ) -> bool:\n        \"\"\"Does the node's file's path contain the base name of `import_mod_name`?\"\"\"\n        if not import_mod_name:  # from . import ...\n            return True\n        if node.level:  # from .foo import ..., from ..bar import ...\n            r"}, {"start_line": 3000, "end_line": 4721, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/private_import", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ame]\nextra2: TypeExtra2\n\n# Try many cases to ensure that type annotation usages of a private import\n# do not mask other illegal usages of the import\nimport _private_module # [import-private-name]\nmy_var: _private_module.Thing = _private_module.Thing()\n\nimport _private_module2 # [import-private-name]\nmy_var2: _private_module2.Thing2\nmy_var2 = _private_module2.Thing2()\n\nimport _private_module3 # [import-private-name]\nmy_var3: _private_module3.Thing3\nmy_var3 = _private_module3.Thing3\nmy_var3_2: _private_module3.Thing3\n\nimport _private_module4 # [import-private-name]\nmy_var4: _private_module4.Thing4\nmy_var4 = _private_module4.get_callers().get_thing4()\n\nfrom _private_module5 import PrivateClass # [import-private-name]\nmy_var5: PrivateClass\nmy_var5 = PrivateClass()\n\nfrom _private_module6 import PrivateClass2 # [import-private-name]\nmy_var6: PrivateClass2 = PrivateClass2()\n\nfrom public_module import _PrivateClass3 # [import-private-name]\nmy_var7: _PrivateClass3 = _PrivateClass3()\n\n# Even though we do not see the private call, the type check does not keep us from emitting\n# because we do not use that variable\nimport _private_module_unreachable # [import-private-name]\nmy_var8: _private_module_unreachable.Thing8\n_private_module_unreachable.Thing8()\n\n\n# pylint: disable=too-few-public-methods\nclass Regression6624:\n    \"\"\"Ensure that an import statement precedes this case.\"\"\"\n    def get_example(self):\n        example: Example = Example().save()\n        return example\n\n\nclass Example:\n    def save(self):\n        return self\n\n\n# Treat relative imports as internal\nfrom .other_file import _private\nfrom ..parent import _private\n\nfrom _private_module_x import some_name # [import-private-name]\nVAR = some_name\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "the name exists, starts with `_`, and if len(name) > 4\n        it is not a dunder, i.e. it does not begin and end with two underscores.\n        \"\"\"\n        return (\n            bool(name)\n            and name[0] == \"_\"\n            and (len(name) <= 4 or name[1] != \"_\" or name[-2:] != \"__\")\n        )\n\n    def _get_type_annotation_names(\n        self, node: nodes.Import | nodes.ImportFrom, names: list[str]\n    ) -> list[str]:\n        \"\"\"Removes from names any names that are used as type annotations with no other\n        illegal usages.\n        \"\"\"\n        if names and not self.populated_annotations:\n            self._populate_type_annotations(node.root(), self.all_used_type_annotations)\n            self.populated_annotations = True\n\n        return [\n            n\n            for n in names\n            if n not in self.all_used_type_annotations\n            or (\n                n in self.all_used_type_annotations\n                and not self.all_used_type_annotations[n]\n            )\n        ]\n\n    def _populate_type_annotations(\n        self, node: nodes.LocalsDictNodeNG, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds to `all_used_type_annotations` all names ever used as a type annotation\n        in the node's (nested) scopes and whether they are only used as annotation.\n        \"\"\"\n        for name in node.locals:\n            # If we find a private type annotation, make sure we do not mask illegal usages\n            private_name = None\n            # All the assignments using this variable that we might have to check for\n            # illegal usages later\n            name_assignments = []\n            for usage_node in node.locals[name]:\n                if isinstance(usage_node, nodes.AssignName) and isinstance(\n                    usage_node.parent, (nodes.AnnAssign, nodes.Assign)\n                ):\n                    assign_parent = usage_node.parent\n                    if isinstance(assign_parent, nodes.AnnAssign):\n                        "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/private_import", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "path of the file being linted to\n# the name of the module we are importing from. The use of `__init__.py` to indicate Python modules\n# is deprecated so this is a heuristic solution.\n# If we were importing from `pylint`, it would be counted as a valid internal private import\n# and not emit a message as long as this file has a parent directory called `pylint`, even though\n# we are not importing from that directory. (We would be importing from `pylint/pylint`.)\nfrom private_import import _private  # pylint: disable=import-self\nfrom private_import.other_file import _private\nfrom . import _private\nfrom astroid import _private  # [import-private-name]\nfrom sys import _private  # [import-private-name]\n\n# Ignore typecheck\nfrom typing import TYPE_CHECKING, List, Optional\n\nif TYPE_CHECKING:\n    import _TreeType\n    from types import _TreeType\n    from _types import TreeType\n    from _types import _TreeType\n\n# No error since imports are used as type annotations\nfrom classes import _PrivateClassA, safe_get_A\nfrom classes import _PrivateClassB\nfrom classes import _PrivateClassC\n\na_var: _PrivateClassA = safe_get_A()\n\ndef b_func(class_b: _PrivateClassB):\n    print(class_b)\n\ndef c_func() -> _PrivateClassC:\n    return None\n\n# Used as typing in slices\nfrom classes import _SubScriptA\nfrom classes import _SubScriptB\n\na: Optional[_SubScriptA]\nb: Optional[_SubScriptB[List]]\n\nimport _TypeContainerA\nimport _TypeContainerB\nimport _TypeContainerC\n\nimport SafeContainerA\na2: _TypeContainerA.A = SafeContainerA.safe_get_a()\n\ndef b_func2(class_b2: _TypeContainerB.B):\n    print(class_b2)\n\ndef c2_func() -> _TypeContainerC.C:\n    return None\n\n# This is allowed since all the imports are used for typing\nfrom _TypeContainerExtra import TypeExtraA, TypeExtraB\nfrom MakerContainerExtra import GetA, GetB\nextra_a: TypeExtraA = GetA()\nextra_b: TypeExtraB = GetB()\n\n# This is not allowed because there is an import not used for typing\nfrom _TypeContainerExtra2 import TypeExtra2, NotTypeExtra # [import-private-n"}, {"start_line": 130000, "end_line": 132000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t = (\n                    imported_name in self._type_annotation_names\n                    or as_name in self._type_annotation_names\n                )\n\n                is_dummy_import = (\n                    as_name\n                    and self.linter.config.dummy_variables_rgx\n                    and self.linter.config.dummy_variables_rgx.match(as_name)\n                )\n\n                if isinstance(stmt, nodes.Import) or (\n                    isinstance(stmt, nodes.ImportFrom) and not stmt.modname\n                ):\n                    if isinstance(stmt, nodes.ImportFrom) and SPECIAL_OBJ.search(\n                        imported_name\n                    ):\n                        # Filter special objects (__doc__, __all__) etc.,\n                        # because they can be imported for exporting.\n                        continue\n\n                    if is_type_annotation_import or is_dummy_import:\n                        # Most likely a typing import if it wasn't used so far.\n                        # Also filter dummy variables.\n                        continue\n\n                    if as_name is None:\n                        msg = f\"import {imported_name}\"\n                    else:\n                        msg = f\"{imported_name} imported as {as_name}\"\n                    if not in_type_checking_block(stmt):\n                        self.add_message(\"unused-import\", args=msg, node=stmt)\n                elif isinstance(stmt, nodes.ImportFrom) and stmt.modname != FUTURE:\n                    if SPECIAL_OBJ.search(imported_name):\n                        # Filter special objects (__doc__, __all__) etc.,\n                        # because they can be imported for exporting.\n                        continue\n\n                    if _is_from_future_import(stmt, name):\n                        # Check if the name is in fact loaded from a\n                        # __future__ import in another module.\n                        continue\n\n                    if is_type_annotation"}, {"start_line": 129000, "end_line": 131000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s():\n            for node in node_lst:\n                if in_type_checking_block(node):\n                    continue\n                self.add_message(\"unused-variable\", args=(name,), node=node)\n\n    # pylint: disable = too-many-branches\n    def _check_imports(self, not_consumed: Consumption) -> None:\n        local_names = _fix_dot_imports(not_consumed)\n        checked = set()\n        unused_wildcard_imports: defaultdict[\n            tuple[str, nodes.ImportFrom],\n            list[str],\n        ] = defaultdict(list)\n        for name, stmt in local_names:\n            for imports in stmt.names:\n                real_name = imported_name = imports[0]\n                if imported_name == \"*\":\n                    real_name = name\n                as_name = imports[1]\n                if real_name in checked:\n                    continue\n                if name not in (real_name, as_name):\n                    continue\n                checked.add(real_name)\n\n                is_type_annotation_import = (\n                    imported_name in self._type_annotation_names\n                    or as_name in self._type_annotation_names\n                )\n\n                is_dummy_import = (\n                    as_name\n                    and self.linter.config.dummy_variables_rgx\n                    and self.linter.config.dummy_variables_rgx.match(as_name)\n                )\n\n                if isinstance(stmt, nodes.Import) or (\n                    isinstance(stmt, nodes.ImportFrom) and not stmt.modname\n                ):\n                    if isinstance(stmt, nodes.ImportFrom) and SPECIAL_OBJ.search(\n                        imported_name\n                    ):\n                        # Filter special objects (__doc__, __all__) etc.,\n                        # because they can be imported for exporting.\n                        continue\n\n                    if is_type_annotation_import or is_dummy_import:\n                        # Most likely a typing import if it wasn't used so far.\n    "}], "retrieved_count": 10, "cost_time": 1.0851292610168457}
{"question": "What is the scope resolution chain for the namedtuple class attribute used as return type annotation in the nested class that affects static type checking in importing modules?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "undefined_variable_classes.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for undefined-variable related to classes\"\"\"\n# pylint: disable=missing-function-docstring, missing-class-docstring, too-few-public-methods\n\n# Test that list comprehensions in base classes are scoped correctly\n# Regression reported in https://github.com/pylint-dev/pylint/issues/3434\n\nimport collections\n\nL = [\"a\", \"b\", \"c\"]\n\n\nclass Foo(collections.namedtuple(\"Foo\", [x + \"_foo\" for x in L])):\n    pass\n\n\n# Test that class attributes are in scope for return type annotations.\n# Regression reported in https://github.com/pylint-dev/pylint/issues/1976\nclass MyObject:\n    class MyType:\n        pass\n\n    def my_method(self) -> MyType:\n        pass\n"}, {"start_line": 2000, "end_line": 3209, "belongs_to": {"file_name": "used_before_assignment_type_annotations.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gned with a tuple assignment\"\"\"\n    var_one: int\n    var_two: int\n    var_one, var_two = 1, 1\n    print(var_one)\n    print(var_two)\n\n\ndef nested_class_as_return_annotation():\n    \"\"\"A namedtuple as a class attribute is used as a return annotation\n\n    Taken from https://github.com/pylint-dev/pylint/issues/5568\"\"\"\n    class MyObject:\n        \"\"\"namedtuple as class attribute\"\"\"\n        Coords = namedtuple('Point', ['x', 'y'])\n\n        def my_method(self) -> Coords:\n            \"\"\"Return annotation is valid\"\"\"\n            # pylint: disable=unnecessary-pass\n            pass\n\n    print(MyObject)\n\n\ndef conditional_annotated_assignment():\n    \"\"\"Variable is conditionally defined but later used in a type-annotated assignment.\"\"\"\n    if object() is None:\n        data={\"cat\": \"harf\"}\n    token: str = data.get(\"cat\")  # [possibly-used-before-assignment]\n    print(token)\n\n\ndef loop_conditional_annotated_assignment():\n    \"\"\"Variable is conditionally defined inside a for-loop but later used\n    in a type-annotated assignment.\n    \"\"\"\n    for _ in range(3):\n        if object() is None:\n            data={\"cat\": \"harf\"}\n    token: str = data.get(\"cat\")  # [possibly-used-before-assignment]\n    print(token)\n"}, {"start_line": 1000, "end_line": 2862, "belongs_to": {"file_name": "unused_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ions\nif TYPE_CHECKING:\n    import itertools\nif t.TYPE_CHECKING:\n    import xml\n\n\nEXAMPLE: t.Annotated[str, \"Path\"] = \"/foo/bar\"\n\ndef get_ordered_dict() -> \"collections.OrderedDict\":\n    return []\n\n\ndef get_itertools_obj() -> \"itertools.count\":\n    return []\n\n\ndef use_html_parser() -> \"html.parser.HTMLParser\":\n    return html.parser.HTMLParser\n\n\nimport os  # [unused-import]\nimport sys\n\n\nclass NonRegr:\n    \"\"\"???\"\"\"\n\n    def __init__(self):\n        print(\"initialized\")\n\n    def sys(self):\n        \"\"\"should not get sys from there...\"\"\"\n        print(self, sys)\n\n    def dummy(self, truc):\n        \"\"\"yo\"\"\"\n        return self, truc\n\n    def blop(self):\n        \"\"\"yo\"\"\"\n        print(self, \"blip\")\n\n\nif TYPE_CHECKING:\n    if sys.version_info >= (3, 6, 2):\n        from typing import NoReturn\n\n# Pathological cases\nfrom io import TYPE_CHECKING  # pylint: disable=no-name-in-module\nimport trace as t\nimport astroid as typing  # pylint: disable=shadowed-import\n\nTYPE_CHECKING = \"red herring\"  # pylint: disable=invalid-name\n\nif TYPE_CHECKING:\n    import unittest  # [unused-import]\nif t.TYPE_CHECKING:  # pylint: disable=no-member\n    import uuid  # [unused-import]\nif typing.TYPE_CHECKING:  # pylint: disable=no-member\n    import warnings  # [unused-import]\nif typing.TYPE_CHECKING_WITH_MAGIC:  # pylint: disable=no-member\n    import compileall  # [unused-import]\n\nTYPE_CHECKING = False  # pylint: disable=invalid-name\nif TYPE_CHECKING:\n    import zoneinfo\n\n\nclass WithMetaclass(six.with_metaclass(ABCMeta)):\n    \"\"\"Regression test for https://github.com/pylint-dev/pylint/issues/7506.\n\n    Requires six.\"\"\"\n\n\n# Regression test for https://github.com/pylint-dev/pylint/issues/3765\n# `unused-import` should not be emitted when a type annotation uses quotation marks\nfrom typing import List\n\n\nclass Bee:\n    def get_all_classes(self) -> \"List[Bee]\":\n        pass\n"}, {"start_line": 0, "end_line": 1187, "belongs_to": {"file_name": "used_before_assignment_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for used-before-assignment with functions added in python 3.7\"\"\"\n# pylint: disable=missing-function-docstring\nfrom __future__ import annotations\nfrom collections import namedtuple\nfrom typing import List\n\n\nclass MyClass:\n    \"\"\"With the future import only default values can't refer to the base class\"\"\"\n\n    def correct_typing_method(self, other: MyClass) -> bool:\n        return self == other\n\n    def second_correct_typing_method(self, other: List[MyClass]) -> bool:\n        return self == other[0]\n\n    def incorrect_default_method(\n        self, other=MyClass() # [undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def correct_string_typing_method(self, other: \"MyClass\") -> bool:\n        return self == other\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyClass())\n\n\nclass NamedTupleSubclass(namedtuple(\"NamedTupleSubclass\", [])):\n    \"\"\"Taken from https://github.com/pylint-dev/pylint/issues/5982\"\"\"\n    def method(self) -> NamedTupleSubclass:\n        \"\"\"Variables checker crashed when astroid did not supply a lineno\"\"\"\n"}, {"start_line": 0, "end_line": 98, "belongs_to": {"file_name": "no_member_nested_namedtuple.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/no", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from typing import NamedTuple\n\nclass Ax(NamedTuple):\n    class Bx:\n        b = 0\n\n\nprint(Ax.Bx.b)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "YPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n_BadNamesTuple = tuple[nodes.NodeNG, str, str, interfaces.Confidence]\n\n# Default patterns for name types that do not have styles\nDEFAULT_PATTERNS = {\n    \"typevar\": re.compile(\n        r\"^_{0,2}(?!T[A-Z])(?:[A-Z]+|(?:[A-Z]+[a-z]+)+T?(?<!Type))(?:_co(?:ntra)?)?$\"\n    ),\n    \"typealias\": re.compile(\n        r\"^_{0,2}(?!T[A-Z]|Type)[A-Z]+[a-z0-9]+(?:[A-Z][a-z0-9]+)*$\"\n    ),\n}\n\nBUILTIN_PROPERTY = \"builtins.property\"\nTYPE_VAR_QNAME = frozenset(\n    (\n        \"typing.TypeVar\",\n        \"typing_extensions.TypeVar\",\n    )\n)\n\n\nclass TypeVarVariance(Enum):\n    invariant = auto()\n    covariant = auto()\n    contravariant = auto()\n    double_variant = auto()\n    inferred = auto()\n\n\ndef _get_properties(config: argparse.Namespace) -> tuple[set[str], set[str]]:\n    \"\"\"Returns a tuple of property classes and names.\n\n    Property classes are fully qualified, such as 'abc.abstractproperty' and\n    property names are the actual names, such as 'abstract_property'.\n    \"\"\"\n    property_classes = {BUILTIN_PROPERTY}\n    property_names: set[str] = set()  # Not returning 'property', it has its own check.\n    if config is not None:\n        property_classes.update(config.property_classes)\n        property_names.update(\n            prop.rsplit(\".\", 1)[-1] for prop in config.property_classes\n        )\n    return property_classes, property_names\n\n\ndef _redefines_import(node: nodes.AssignName) -> bool:\n    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n        current = current.parent\n    if not current or not utils.error_of_type(current.parent, ImportError):\n        return False\n    try_block = current.parent.parent\n    for import_node in try_block.nodes_of_class((nodes.ImportFrom, nodes.Imp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "used_before_assignment_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for used-before-assignment for typing related issues\"\"\"\n# pylint: disable=missing-function-docstring,ungrouped-imports,invalid-name\n# pylint: disable=line-too-long\n\nfrom typing import List, NamedTuple, Optional, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    if True:  # pylint: disable=using-constant-test\n        import math\n    import dbm\n    print(dbm)  # no error when defined and used in the same false branch\n    from urllib.request import urlopen\n    import array\n    import base64\n    import binascii\n    import calendar\n    import collections\n    import copy\n    import datetime\n    import email\n    import heapq\n    import json\n    import mailbox\n    import mimetypes\n    import numbers\n    import pprint\n    import types\n    import zoneinfo\nelif input():\n    import calendar, bisect  # pylint: disable=multiple-imports\n    if input() + 1:\n        import heapq\n    else:\n        import heapq\nelif input():\n    try:\n        numbers = None if input() else 1\n        import array\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        import types\n    finally:\n        copy = None\nelif input():\n    for i in range(1,2):\n        email = None\n    else:  # pylint: disable=useless-else-on-loop\n        json = None\n    while input():\n        import mailbox\n    else:  # pylint: disable=useless-else-on-loop\n        mimetypes = None\nelif input():\n    with input() as base64:\n        pass\n    with input() as temp:\n        import binascii\nelse:\n    from urllib.request import urlopen\n    zoneinfo: str = ''\n    def pprint():\n        pass\n    class collections:  # pylint: disable=too-few-public-methods,missing-class-docstring\n        pass\n\nclass MyClass:\n    \"\"\"Type annotation or default values for first level methods can't refer to their own class\"\"\"\n\n    def incorrect_typing_method(\n        self, other: MyClass  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def incorrect_nested_typing_method(\n        self, other: List[MyClass]  # <3.14:"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unused_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"unused import\"\"\"\n# pylint: disable=undefined-all-variable, import-error, too-few-public-methods, missing-docstring,wrong-import-position, multiple-imports\nimport xml.etree  # [unused-import]\nimport xml.sax  # [unused-import]\nimport os.path as test  # [unused-import]\nfrom abc import ABCMeta\nfrom sys import argv as test2  # [unused-import]\nfrom sys import flags  # [unused-import]\n\n# +1:[unused-import,unused-import]\nfrom collections import deque, OrderedDict, Counter\nimport re, html.parser  # [unused-import]\nimport six\n\nDATA = Counter()\n# pylint: disable=self-assigning-variable\nfrom fake import SomeName, SomeOtherName  # [unused-import]\n\n\nclass SomeClass:\n    SomeName = SomeName  # https://bitbucket.org/logilab/pylint/issue/475\n    SomeOtherName = 1\n    SomeOtherName = SomeOtherName\n\n\nfrom never import __all__\n\n# pylint: disable=wrong-import-order,ungrouped-imports,reimported\nimport typing\nfrom typing import TYPE_CHECKING\nimport typing as t\n\n\nif typing.TYPE_CHECKING:\n    import collections\nif TYPE_CHECKING:\n    import itertools\nif t.TYPE_CHECKING:\n    import xml\n\n\nEXAMPLE: t.Annotated[str, \"Path\"] = \"/foo/bar\"\n\ndef get_ordered_dict() -> \"collections.OrderedDict\":\n    return []\n\n\ndef get_itertools_obj() -> \"itertools.count\":\n    return []\n\n\ndef use_html_parser() -> \"html.parser.HTMLParser\":\n    return html.parser.HTMLParser\n\n\nimport os  # [unused-import]\nimport sys\n\n\nclass NonRegr:\n    \"\"\"???\"\"\"\n\n    def __init__(self):\n        print(\"initialized\")\n\n    def sys(self):\n        \"\"\"should not get sys from there...\"\"\"\n        print(self, sys)\n\n    def dummy(self, truc):\n        \"\"\"yo\"\"\"\n        return self, truc\n\n    def blop(self):\n        \"\"\"yo\"\"\"\n        print(self, \"blip\")\n\n\nif TYPE_CHECKING:\n    if sys.version_info >= (3, 6, 2):\n        from typing import NoReturn\n\n# Pathological cases\nfrom io import TYPE_CHECKING  # pylint: disable=no-name-in-module\nimport trace as t\nimport astroid as typing  # pylint: disable=shadowed-import\n\nTYPE_CHECKING = \"red herring\"  # pylin"}, {"start_line": 0, "end_line": 925, "belongs_to": {"file_name": "unused_name_in_string_literal_type_annotation.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test if pylint sees names inside string literal type annotations. #3299\"\"\"\n# pylint: disable=too-few-public-methods\n\nfrom argparse import ArgumentParser, Namespace\nimport os\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import NoReturn, Set\n\n# unused-import shouldn't be emitted for Path\nexample1: Set[\"Path\"] = set()\n\ndef example2(_: \"ArgumentParser\") -> \"NoReturn\":\n    \"\"\"unused-import shouldn't be emitted for ArgumentParser or NoReturn.\"\"\"\n    while True:\n        pass\n\ndef example3(_: \"os.PathLike[str]\") -> None:\n    \"\"\"unused-import shouldn't be emitted for os.\"\"\"\n\ndef example4(_: \"PathLike[str]\") -> None:\n    \"\"\"unused-import shouldn't be emitted for PathLike.\"\"\"\n\n# pylint shouldn't crash with the following strings in a type annotation context\nexample5: Set[\"\"]\nexample6: Set[\" \"]\nexample7: Set[\"?\"]\n\nclass Class:\n    \"\"\"unused-import shouldn't be emitted for Namespace\"\"\"\n    cls: \"Namespace\"\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "undefined_variable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         print(i)\n    i = 0\n    fig = plt.figure()\n    fig.canvas.mpl_connect('button_press_event', onclick)\n    plt.show(block=True)\n\n\n\nif TYPE_CHECKING:\n    from datetime import datetime\n\n\ndef func_should_fail(_dt: datetime):  # <3.14:[used-before-assignment]\n    pass\n\n\n# The following should not emit an error.\n# pylint: disable=invalid-name\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n    AllowedValues = Literal['hello', 'world']\n\n\nif TYPE_CHECKING:\n    from collections import Counter\n    from collections import OrderedDict\n    from collections import defaultdict\n    from collections import UserDict\nelse:\n    Counter = object\n    OrderedDict = object\n    def defaultdict():\n        return {}\n    class UserDict(dict):\n        pass\n\n\ndef tick(counter: Counter, name: str, dictionary: OrderedDict) -> OrderedDict:\n    counter[name] += 1\n    return dictionary\n\ndefaultdict()\n\nUserDict()\n\n# pylint: disable=unused-argument\ndef not_using_loop_variable_accordingly(iterator):\n    for iteree in iteree: # [undefined-variable]\n        yield iteree\n# pylint: enable=unused-argument\n\n\nclass DunderClass:\n    def method(self):\n        # This name is not defined in the AST but it's present at runtime\n        return __class__\n\n    # It is also present in inner methods\n    def method_two(self):\n        def inner_method():\n            return __class__\n\n        inner_method()\n\ndef undefined_annotation(a:x): # [undefined-variable]\n    if x == 2: # [used-before-assignment]\n        for x in [1, 2]:\n            pass\n    return a\n\n\n# #3711's comment regression test\nlst = []\nlst2 = [1, 2, 3]\n\nfor item in lst:\n    pass\n\nbigger = [\n    [\n        x for x in lst2 if x > item\n    ]\n    for item in lst\n]\n\n\n# 3791\n@decorator(x for x in range(3))\ndef decorated1(x):\n    print(x)\n\n@decorator(x * x for x in range(3))\ndef decorated2(x):\n    print(x)\n\n@decorator(x)  # [undefined-variable]\n@decorator(x * x for x in range(3))\ndef decorated3(x):\n    print(x)\n\n@decorator(x * x * y for x in range"}], "retrieved_count": 10, "cost_time": 1.071035385131836}
{"question": "What architectural design flaw exists in the string formatting conversion method checker that violates the contract-based responsibility separation between type inference layers and their callers?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h.append(f\".{specifier}\")\n        else:\n            path.append(f\"[{specifier!r}]\")\n    return str(key) + \"\".join(path)\n\n\ndef arg_matches_format_type(\n    arg_type: SuccessfulInferenceResult, format_type: str\n) -> bool:\n    if format_type in \"sr\":\n        # All types can be printed with %s and %r\n        return True\n    if isinstance(arg_type, astroid.Instance):\n        arg_type = arg_type.pytype()\n        if arg_type == \"builtins.str\":\n            return format_type == \"c\"\n        if arg_type == \"builtins.float\":\n            return format_type in \"deEfFgGn%\"\n        if arg_type == \"builtins.int\":\n            # Integers allow all types\n            return True\n        return False\n    return True\n\n\nclass StringFormatChecker(BaseChecker):\n    \"\"\"Checks string formatting operations to ensure that the format string\n    is valid and the arguments match the format string.\n    \"\"\"\n\n    name = \"string\"\n    msgs = MSGS\n\n    # pylint: disable = too-many-branches, too-many-locals, too-many-statements\n    @only_required_for_messages(\n        \"bad-format-character\",\n        \"truncated-format-string\",\n        \"mixed-format-string\",\n        \"bad-format-string-key\",\n        \"missing-format-string-key\",\n        \"unused-format-string-key\",\n        \"bad-string-format-type\",\n        \"format-needs-mapping\",\n        \"too-many-format-args\",\n        \"too-few-format-args\",\n        \"format-string-without-interpolation\",\n    )\n    def visit_binop(self, node: nodes.BinOp) -> None:\n        if node.op != \"%\":\n            return\n        left = node.left\n        args = node.right\n\n        if not (isinstance(left, nodes.Const) and isinstance(left.value, str)):\n            return\n        format_string = left.value\n        try:\n            (\n                required_keys,\n                required_num_args,\n                required_key_types,\n                required_arg_types,\n            ) = utils.parse_format_string(format_string)\n        except utils.UnsupportedFormatCharacter as exc:\n            "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  self.add_message(\n                        \"bad-str-strip-call\",\n                        node=node,\n                        args=(func.bound.name, func.name),\n                    )\n            elif func.name == \"format\":\n                self._check_new_format(node, func)\n\n    def _detect_vacuous_formatting(\n        self, node: nodes.Call, positional_arguments: list[SuccessfulInferenceResult]\n    ) -> None:\n        counter = collections.Counter(\n            arg.name for arg in positional_arguments if isinstance(arg, nodes.Name)\n        )\n        for name, count in counter.items():\n            if count == 1:\n                continue\n            self.add_message(\n                \"duplicate-string-formatting-argument\", node=node, args=(name,)\n            )\n\n    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -> None:\n        \"\"\"Check the new string formatting.\"\"\"\n        # Skip format nodes which don't have an explicit string on the\n        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n        ):\n            return\n        if node.starargs or node.kwargs:\n            return\n        try:\n            strnode = next(func.bound.infer())\n        except astroid.InferenceError:\n            return\n        if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):\n            return\n        try:\n            call_site = astroid.arguments.CallSite.from_call(node)\n        except astroid.InferenceError:\n            return\n\n        try:\n            fields, num_args, manual_pos = utils.parse_forma"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        \"Used when we detect an f-string that does not use any interpolation variables, \"\n            \"in which case it can be either a normal string or a bug in the code.\",\n        ),\n        \"W1310\": (\n            \"Using formatting for a string that does not have any interpolated variables\",\n            \"format-string-without-interpolation\",\n            \"Used when we detect a string that does not have any interpolation variables, \"\n            \"in which case it can be either a normal string without formatting or a bug in the code.\",\n        ),\n    }\n)\n\nOTHER_NODES = (\n    nodes.Const,\n    nodes.List,\n    nodes.Lambda,\n    nodes.FunctionDef,\n    nodes.ListComp,\n    nodes.SetComp,\n    nodes.GeneratorExp,\n)\n\n\ndef get_access_path(key: str | Literal[0], parts: list[tuple[bool, str]]) -> str:\n    \"\"\"Given a list of format specifiers, returns\n    the final access path (e.g. a.b.c[0][1]).\n    \"\"\"\n    path = []\n    for is_attribute, specifier in parts:\n        if is_attribute:\n            path.append(f\".{specifier}\")\n        else:\n            path.append(f\"[{specifier!r}]\")\n    return str(key) + \"\".join(path)\n\n\ndef arg_matches_format_type(\n    arg_type: SuccessfulInferenceResult, format_type: str\n) -> bool:\n    if format_type in \"sr\":\n        # All types can be printed with %s and %r\n        return True\n    if isinstance(arg_type, astroid.Instance):\n        arg_type = arg_type.pytype()\n        if arg_type == \"builtins.str\":\n            return format_type == \"c\"\n        if arg_type == \"builtins.float\":\n            return format_type in \"deEfFgGn%\"\n        if arg_type == \"builtins.int\":\n            # Integers allow all types\n            return True\n        return False\n    return True\n\n\nclass StringFormatChecker(BaseChecker):\n    \"\"\"Checks string formatting operations to ensure that the format string\n    is valid and the arguments match the format string.\n    \"\"\"\n\n    name = \"string\"\n    msgs = MSGS\n\n    # pylint: disable = too-many-branches, too-many-locals, too-many-statem"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Checker for string formatting operations.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport re\nimport sys\nimport tokenize\nfrom collections import Counter\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Literal\n\nimport astroid\nfrom astroid import bases, nodes, util\nfrom astroid.typing import SuccessfulInferenceResult\n\nfrom pylint.checkers import BaseChecker, BaseRawFileChecker, BaseTokenChecker, utils\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.interfaces import HIGH\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n_AST_NODE_STR_TYPES = (\"__builtin__.unicode\", \"__builtin__.str\", \"builtins.str\")\n# Prefixes for both strings and bytes literals per\n# https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n_PREFIXES = {\n    \"r\",\n    \"u\",\n    \"R\",\n    \"U\",\n    \"f\",\n    \"F\",\n    \"fr\",\n    \"Fr\",\n    \"fR\",\n    \"FR\",\n    \"rf\",\n    \"rF\",\n    \"Rf\",\n    \"RF\",\n    \"b\",\n    \"B\",\n    \"br\",\n    \"Br\",\n    \"bR\",\n    \"BR\",\n    \"rb\",\n    \"rB\",\n    \"Rb\",\n    \"RB\",\n}\n_PAREN_IGNORE_TOKEN_TYPES = (\n    tokenize.NEWLINE,\n    tokenize.NL,\n    tokenize.COMMENT,\n)\nSINGLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?'''\")\nDOUBLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?\\\"\\\"\\\"\")\nQUOTE_DELIMITER_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?(\\\"|')\", re.DOTALL)\n\nMSGS: dict[str, MessageDefinitionTuple] = (\n    {  # pylint: disable=consider-using-namedtuple-or-dataclass\n        \"E1300\": (\n            \"Unsupported format character %r (%#02x) at index %d\",\n            \"bad-format-character\",\n            \"Used when an unsupported format character is used in a format string.\",\n        ),\n        \""}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s_path(key, parsed)\n                        self.add_message(\n                            \"missing-format-attribute\",\n                            args=(specifier, path),\n                            node=node,\n                        )\n                        break\n                else:\n                    warn_error = False\n                    if hasattr(previous, \"getitem\"):\n                        try:\n                            previous = previous.getitem(nodes.Const(specifier))\n                        except (\n                            astroid.AstroidIndexError,\n                            astroid.AstroidTypeError,\n                            astroid.AttributeInferenceError,\n                        ):\n                            warn_error = True\n                        except astroid.InferenceError:\n                            break\n                        if isinstance(previous, util.UninferableBase):\n                            break\n                    else:\n                        try:\n                            # Lookup __getitem__ in the current node,\n                            # but skip further checks, because we can't\n                            # retrieve the looked object\n                            previous.getattr(\"__getitem__\")\n                            break\n                        except astroid.NotFoundError:\n                            warn_error = True\n                    if warn_error:\n                        path = get_access_path(key, parsed)\n                        self.add_message(\n                            \"invalid-format-index\", args=(specifier, path), node=node\n                        )\n                        break\n\n                try:\n                    previous = next(previous.infer())\n                except astroid.InferenceError:\n                    # can't check further if we can't infer it\n                    break\n\n\nclass StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):\n    \"\"\"Check string literals.\"\"\"\n\n"}, {"start_line": 0, "end_line": 214, "belongs_to": {"file_name": "string_formatting_failed_inference.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/string", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Testing string format with a failed inference. This should not crash. \"\"\"\n# pylint: disable=using-constant-test, consider-using-f-string\nimport collections\n\"{dict[0]}\".format(dict=collections.defaultdict(int))\n"}, {"start_line": 0, "end_line": 278, "belongs_to": {"file_name": "string_formatting_failed_inference_py35.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/string", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Testing string format with a failed inference. This should not crash. \"\"\"\n# pylint: disable=using-constant-test, consider-using-f-string\nimport collections\n\"{dict[0]}\".format(dict=collections.defaultdict(int))\n\nCOMMENT = \"message %s %s %s\" % (0, *(1 if \"cond\" else 2,) * 2)\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             if num_args > required_num_args:\n                    self.add_message(\"too-many-format-args\", node=node)\n                elif num_args < required_num_args:\n                    self.add_message(\"too-few-format-args\", node=node)\n                for arg, format_type in zip(args_elts, required_arg_types):\n                    if not arg:\n                        continue\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        arg_type\n                        and not isinstance(arg_type, util.UninferableBase)\n                        and not arg_matches_format_type(arg_type, format_type)\n                    ):\n                        self.add_message(\n                            \"bad-string-format-type\",\n                            node=node,\n                            args=(arg_type.pytype(), format_type),\n                        )\n\n    @only_required_for_messages(\"f-string-without-interpolation\")\n    def visit_joinedstr(self, node: nodes.JoinedStr) -> None:\n        self._check_interpolation(node)\n\n    def _check_interpolation(self, node: nodes.JoinedStr) -> None:\n        if isinstance(node.parent, nodes.FormattedValue):\n            return\n        for value in node.values:\n            if isinstance(value, nodes.FormattedValue):\n                return\n        self.add_message(\"f-string-without-interpolation\", node=node)\n\n    def visit_call(self, node: nodes.Call) -> None:\n        func = utils.safe_infer(node.func)\n        if (\n            isinstance(func, astroid.BoundMethod)\n            and isinstance(func.bound, astroid.Instance)\n            and func.bound.name in {\"str\", \"unicode\", \"bytes\"}\n        ):\n            if func.name in {\"strip\", \"lstrip\", \"rstrip\"} and node.args:\n                arg = utils.safe_infer(node.args[0])\n                if not isinstance(arg, nodes.Const) or not isinstance(arg.value, str):\n                    return\n                if len(arg.value) != len(set(arg.value)):\n                  "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "logging.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ode, format_pos)\n        elif isinstance(format_arg, nodes.JoinedStr):\n            if str_formatting_in_f_string(format_arg):\n                return\n            self.add_message(\n                \"logging-fstring-interpolation\",\n                node=node,\n                args=(self._helper_string(node),),\n            )\n\n    def _helper_string(self, node: nodes.Call) -> str:\n        \"\"\"Create a string that lists the valid types of formatting for this node.\"\"\"\n        valid_types = [\"lazy %\"]\n\n        if not self.linter.is_message_enabled(\n            \"logging-fstring-formatting\", node.fromlineno\n        ):\n            valid_types.append(\"fstring\")\n        if not self.linter.is_message_enabled(\n            \"logging-format-interpolation\", node.fromlineno\n        ):\n            valid_types.append(\".format()\")\n        if not self.linter.is_message_enabled(\"logging-not-lazy\", node.fromlineno):\n            valid_types.append(\"%\")\n\n        return \" or \".join(valid_types)\n\n    @staticmethod\n    def _is_operand_literal_str(operand: InferenceResult | None) -> bool:\n        \"\"\"Return True if the operand in argument is a literal string.\"\"\"\n        return isinstance(operand, nodes.Const) and operand.name == \"str\"\n\n    @staticmethod\n    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node represents an explicitly concatenated string.\"\"\"\n        if not isinstance(node, nodes.BinOp):\n            return False\n        return (\n            LoggingChecker._is_operand_literal_str(node.left)\n            or LoggingChecker._is_node_explicit_str_concatenation(node.left)\n        ) and (\n            LoggingChecker._is_operand_literal_str(node.right)\n            or LoggingChecker._is_node_explicit_str_concatenation(node.right)\n        )\n\n    def _check_call_func(self, node: nodes.Call) -> None:\n        \"\"\"Checks that function call is not format_string.format().\"\"\"\n        func = utils.safe_infer(node.func)\n        types = (\"str\", \"unicode\")\n    "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             \"missing-format-string-key\", node=node, args=key\n                            )\n                for key in keys:\n                    if key not in required_keys:\n                        self.add_message(\n                            \"unused-format-string-key\", node=node, args=key\n                        )\n                for key, arg in args.items:\n                    if not isinstance(key, nodes.Const):\n                        continue\n                    format_type = required_key_types.get(key.value, None)\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        format_type is not None\n                        and arg_type\n                        and not isinstance(arg_type, util.UninferableBase)\n                        and not arg_matches_format_type(arg_type, format_type)\n                    ):\n                        self.add_message(\n                            \"bad-string-format-type\",\n                            node=node,\n                            args=(arg_type.pytype(), format_type),\n                        )\n            elif isinstance(args, (OTHER_NODES, nodes.Tuple)):\n                type_name = type(args).__name__\n                self.add_message(\"format-needs-mapping\", node=node, args=type_name)\n            # else:\n            # The RHS of the format specifier is a name or\n            # expression.  It may be a mapping object, so\n            # there's nothing we can check.\n        else:\n            # The format string uses only unnamed format specifiers.\n            # Check that the number of arguments passed to the RHS of\n            # the % operator matches the number required by the format\n            # string.\n            args_elts = []\n            if isinstance(args, nodes.Tuple):\n                rhs_tuple = utils.safe_infer(args)\n                num_args = None\n                if isinstance(rhs_tuple, nodes.BaseContainer):\n                    args_elts = rhs_tuple.elts\n                  "}], "retrieved_count": 10, "cost_time": 1.0872128009796143}
{"question": "What is the semantic relationship between input arguments and return values when the functools cache decorator is applied?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 195, "belongs_to": {"file_name": "too_many_arguments_issue_1045.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/t/too", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\n\n# pylint: disable=unused-import, undefined-variable; false positives :-(\n\nimport functools\n\n\n@functools.lru_cache()\ndef func():\n    pass\n\n\nfunc.cache_clear()\n"}, {"start_line": 0, "end_line": 450, "belongs_to": {"file_name": "no_member_decorator.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/no", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Attributes supplied by a decorator.\"\"\"\n\nfrom functools import lru_cache\n\n\nclass SomeClass:  # pylint: disable=too-few-public-methods\n    \"\"\"https://github.com/pylint-dev/pylint/issues/9246\"\"\"\n    @classmethod\n    @lru_cache\n    def __cached_fun(cls, arg: int) -> str:\n        return str(arg)\n\n    @classmethod\n    def cache_clear(cls):\n        \"\"\"__cached_fun()'s @cache decorator supplies cache_clear().\"\"\"\n        cls.__cached_fun.cache_clear()\n"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "stdlib.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e, \"maxsize\")\n\n                        if not isinstance(arg, nodes.Const) or arg.value is not None:\n                            break\n\n                        lru_cache_nodes.append(d_node)\n                        break\n\n                    if q_name == \"functools.cache\":\n                        lru_cache_nodes.append(d_node)\n                        break\n            except astroid.InferenceError:\n                pass\n        for lru_cache_node in lru_cache_nodes:\n            self.add_message(\n                \"method-cache-max-size-none\",\n                node=lru_cache_node,\n                confidence=interfaces.INFERENCE,\n            )\n\n    def _check_dispatch_decorators(self, node: nodes.FunctionDef) -> None:\n        decorators_map: dict[str, tuple[nodes.NodeNG, interfaces.Confidence]] = {}\n\n        for decorator in node.decorators.nodes:\n            if isinstance(decorator, nodes.Name) and decorator.name:\n                decorators_map[decorator.name] = (decorator, interfaces.HIGH)\n            elif utils.is_registered_in_singledispatch_function(node):\n                decorators_map[\"singledispatch\"] = (decorator, interfaces.INFERENCE)\n            elif utils.is_registered_in_singledispatchmethod_function(node):\n                decorators_map[\"singledispatchmethod\"] = (\n                    decorator,\n                    interfaces.INFERENCE,\n                )\n\n        if node.is_method():\n            if \"singledispatch\" in decorators_map:\n                self.add_message(\n                    \"singledispatch-method\",\n                    node=decorators_map[\"singledispatch\"][0],\n                    confidence=decorators_map[\"singledispatch\"][1],\n                )\n        elif \"singledispatchmethod\" in decorators_map:\n            self.add_message(\n                \"singledispatchmethod-function\",\n                node=decorators_map[\"singledispatchmethod\"][0],\n                confidence=decorators_map[\"singledispatchmethod\"][1],\n            )\n\n    def _check_redundant_"}, {"start_line": 1000, "end_line": 2289, "belongs_to": {"file_name": "method_cache_max_size_none.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "c(self, param):\n        return param + 1\n\n    # Check double decorating to check robustness of checker itself\n    @aliased_cache(None)  # [method-cache-max-size-none]\n    @aliased_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    maxsizeKwarg = {\"maxsize\": None}\n    @lru_cache(**maxsizeKwarg)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n\nclass MyClassWithMethodsAndMaxSize:\n    @lru_cache(maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True, maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True, maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True, maxsize=None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n\n@lru_cache(maxsize=None)\ndef my_func(param):\n    return param + 1\n\n\nclass Class(Enum):\n    A = 1\n\n    @lru_cache(maxsize=None)\n    def func(self) -> None:\n        pass\n"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "stdlib.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f(self, node: nodes.If) -> None:\n        self._check_datetime(node.test)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_ifexp(self, node: nodes.IfExp) -> None:\n        self._check_datetime(node.test)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_boolop(self, node: nodes.BoolOp) -> None:\n        for value in node.values:\n            self._check_datetime(value)\n\n    @utils.only_required_for_messages(\n        \"method-cache-max-size-none\",\n        \"singledispatch-method\",\n        \"singledispatchmethod-function\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if node.decorators:\n            if isinstance(node.parent, nodes.ClassDef):\n                self._check_lru_cache_decorators(node)\n            self._check_dispatch_decorators(node)\n\n    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check if instance methods are decorated with functools.lru_cache.\"\"\"\n        if any(utils.is_enum(ancestor) for ancestor in node.parent.ancestors()):\n            # method of class inheriting from Enum is exempt from this check.\n            return\n\n        lru_cache_nodes: list[nodes.NodeNG] = []\n        for d_node in node.decorators.nodes:\n            # pylint: disable = too-many-try-statements\n            try:\n                for infered_node in d_node.infer():\n                    q_name = infered_node.qname()\n                    if q_name in NON_INSTANCE_METHODS:\n                        return\n\n                    # Check if there is a maxsize argument set to None in the call\n                    if q_name in LRU_CACHE and isinstance(d_node, nodes.Call):\n                        try:\n                            arg = utils.get_argument_from_call(\n                                d_node, position=0, keyword=\"maxsize\"\n                            )\n                        except utils.NoSuchArgumentError:\n                            arg = utils.infer_kwarg_from_call(d_nod"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "stdlib.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_thread_instantiation(node)\n                elif inferred.qname() == SUBPROCESS_POPEN:\n                    self._check_for_preexec_fn_in_popen(node)\n            elif isinstance(inferred, nodes.FunctionDef):\n                name = inferred.qname()\n                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n                elif name in DEBUG_BREAKPOINTS:\n                    self.add_message(\"forgotten-debug-statement\", node=node)\n            self.check_deprecated_method(node, inferred)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_unaryop(self, node: nodes.UnaryOp) -> None:\n        if node.op == \"not\":\n            self._check_datetime(node.operand)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_if(self, node: nodes.If) -> None:\n        self._check_datetime(node.test)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_ifexp(self, node: nodes.IfExp) -> None:\n        self._check_datetime(node.test)\n\n    @utils.only_required_for_messages(\"boolean-datetime\")\n    def visit_boolop(self, node: nodes.BoolOp) -> None:\n        for value in node.values:\n            self._check_datetime(value)\n\n    @utils.only_required_for_messages(\n        \"method-cache-max-size-none\",\n        \"singledispatch-method\",\n        \"singledispatchmethod-function\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if node.decorators:\n            if isinstance(node.parent, nodes.ClassDef):\n                self._check_lru_cache_decorators(node)\n            self._check_dispatch_decorators(node)\n\n    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check if instance methods are decorated with functools.lru_cache.\"\"\"\n        if any("}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "method_cache_max_size_none.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for method-cache-max-size-none\"\"\"\n# pylint: disable=missing-function-docstring, reimported, too-few-public-methods\n# pylint: disable=missing-class-docstring, function-redefined\n\nimport functools\nimport functools as aliased_functools\nfrom functools import lru_cache\nfrom functools import lru_cache as aliased_cache\nfrom enum import Enum\n\n\n@lru_cache\ndef my_func(param):\n    return param + 1\n\n\nclass MyClassWithMethods:\n    @lru_cache()\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    @functools.lru_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    @aliased_functools.lru_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    @aliased_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    # Check double decorating to check robustness of checker itself\n    @aliased_cache(None)  # [method-cache-max-size-none]\n    @aliased_cache(None)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n    maxsizeKwarg = {\"maxsize\": None}\n    @lru_cache(**maxsizeKwarg)  # [method-cache-max-size-none]\n    def my_func(self, param):\n        return param + 1\n\n\nclass MyClassWithMethodsAndMaxSize:\n    @lru_cache(maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True, maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_cache(typed=True, maxsize=1)\n    def my_func(self, param):\n        return param + 1\n\n    @lru_"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "arguments.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "return set((arg, ))\n\ndef find_problems2(prob_dates):\n    for fff in range(10):\n        prob_dates |= compare_prices(fff)\n\n\nfrom collections import namedtuple\n\n\ndef namedtuple_replace_issue_1036():\n    cls = namedtuple('cls', 'a b c')\n    new_instance = cls(1, 2, 3)._replace(\n        a=24,\n        b=24,\n        c=42\n    )\n    # +1:[unexpected-keyword-arg,unexpected-keyword-arg]\n    new_bad_instance = cls(1, 2, 3)._replace(d=24, e=32)\n    return new_instance, new_bad_instance\n\n\nfrom functools import partial\n\ndef some_func(first, second, third):\n    return first + second + third\n\n\npartial(some_func, 1, 2)(3)\npartial(some_func, third=1, second=2)(3)\npartial(some_func, 1, third=2)(second=3)\npartial(some_func, 1)(1)  # [no-value-for-parameter]\npartial(some_func, 1)(third=1)  # [no-value-for-parameter]\npartial(some_func, 1, 2)(third=1, fourth=4)  # [unexpected-keyword-arg]\n\n\ndef mutation_decorator(fun):\n    \"\"\"Decorator that changes a function's signature.\"\"\"\n    def wrapper(*args, do_something=True, **kwargs):\n        if do_something:\n            return fun(*args, **kwargs)\n\n        return None\n\n    return wrapper\n\n\ndef other_mutation_decorator(fun):\n    \"\"\"Another decorator that changes a function's signature\"\"\"\n    def wrapper(*args, do_something=True, **kwargs):\n        if do_something:\n            return fun(*args, **kwargs)\n\n        return None\n\n    return wrapper\n\n\n@mutation_decorator\ndef mutated_function(arg):\n    return arg\n\n\n@other_mutation_decorator\ndef mutated(arg):\n    return arg\n\n\nmutated_function(do_something=False)\nmutated_function()\n\nmutated(do_something=True)\n\n\ndef func(one, two, three):\n    return one + two + three\n\n\ncall = lambda *args: func(*args)\n\n\n# Ensure `too-many-function-args` is not emitted when a function call is assigned\n# to a class attribute inside the class where the function is defined.\n# Reference: https://github.com/pylint-dev/pylint/issues/6592\nclass FruitPicker:\n    def _pick_fruit(fruit):\n        def _print_selection(self):\n          "}, {"start_line": 64000, "end_line": 66000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           # We only check arguments of function decorators\n            if not isinstance(inferred, nodes.FunctionDef):\n                return False\n\n            for return_value in inferred.infer_call_result(caller=None):\n                # infer_call_result() returns nodes.Const.None for None return values\n                # so this also catches non-returning decorators\n                if not isinstance(return_value, nodes.FunctionDef):\n                    return False\n\n                # If the return value uses a kwarg the keyword will be consumed\n                if return_value.args.kwarg:\n                    continue\n\n                # Check if the keyword is another type of argument\n                if return_value.args.is_argument(keyword):\n                    continue\n\n                return False\n\n        return True\n\n    def _check_invalid_sequence_index(self, subscript: nodes.Subscript) -> None:\n        # Look for index operations where the parent is a sequence type.\n        # If the types can be determined, only allow indices to be int,\n        # slice or instances with __index__.\n        parent_type = safe_infer(subscript.value)\n        if not isinstance(\n            parent_type, (nodes.ClassDef, astroid.Instance)\n        ) or not has_known_bases(parent_type):\n            return None\n\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n        elif subscript.ctx is astroid.Context.Del:\n            methodname = \"__delitem__\"\n        else:\n            methodname = \"__getitem__\"\n\n        # Check if this instance's __getitem__, __setitem__, or __delitem__, as\n        # appropriate to the statement, is implemented in a builtin sequence\n        # type. This way we catch subclasses of sequence types but ski"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ce(value, nodes.Const)\n                and inferred.value != value.value\n            ):\n                return None\n            if (\n                isinstance(inferred, nodes.FunctionDef)\n                and isinstance(value, nodes.FunctionDef)\n                and function_arguments_are_ambiguous(inferred, value)\n            ):\n                return None\n            if (\n                compare_constructors\n                and isinstance(inferred, nodes.ClassDef)\n                and isinstance(value, nodes.ClassDef)\n                and class_constructors_are_ambiguous(inferred, value)\n            ):\n                return None\n    except astroid.InferenceError:\n        return None  # There is some kind of ambiguity\n    except StopIteration:\n        return value\n    except Exception as e:  # pragma: no cover\n        raise AstroidError from e\n    return value if len(inferred_types) <= 1 else None\n\n\n@lru_cache(maxsize=512)\ndef infer_all(\n    node: nodes.NodeNG, context: InferenceContext | None = None\n) -> list[InferenceResult]:\n    try:\n        return list(node.infer(context=context))\n    except astroid.InferenceError:\n        return []\n    except Exception as e:  # pragma: no cover\n        raise AstroidError from e\n\n\ndef function_arguments_are_ambiguous(\n    func1: nodes.FunctionDef, func2: nodes.FunctionDef\n) -> bool:\n    if func1.argnames() != func2.argnames():\n        return True\n    # Check ambiguity among function default values\n    pairs_of_defaults = [\n        (func1.args.defaults, func2.args.defaults),\n        (func1.args.kw_defaults, func2.args.kw_defaults),\n    ]\n    for zippable_default in pairs_of_defaults:\n        if None in zippable_default:\n            continue\n        if len(zippable_default[0]) != len(zippable_default[1]):\n            return True\n        for default1, default2 in zip(*zippable_default):\n            if isinstance(default1, nodes.Const) and isinstance(default2, nodes.Const):\n                if default1.value != default2.value:\n       "}], "retrieved_count": 10, "cost_time": 1.0846226215362549}
{"question": "How does a deep copying hook method with an extra parameter violate the protocol that Python's copy module expects?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 2723, "belongs_to": {"file_name": "invalid_getnewargs_ex_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self._bar = far\n        self._hoo = hoo\n        self._haha = haha\n\n    def __getnewargs_ex__(self):\n        args = (self._foo, self._bar)\n        kwargs = {'hoo': self._hoo,\n                  'haha': self._haha}\n        return args, kwargs\n\n\nclass FirstBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns an integer \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return 1\n\n\nclass SecondBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n\n\nclass ThirdBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for first arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n\n\nclass FourthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for second arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n\n\nclass FifthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for both args \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ({'x': 'y'}, (2,))\n\n\nclass SixthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n\n\nclass AmbigousGetNewArgsEx:\n    \"\"\" Uninferable return value \"\"\"\n\n    __getnewargs_ex__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgsEx:\n    \"\"\"Potential uninferable return value\"\"\"\n\n    def __getnewargs_ex__(self):\n        return tuple(Missing)\n"}, {"start_line": 0, "end_line": 96, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/p/property-with-parameters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Worm:\n    @property\n    def bore(self, depth):  # [property-with-parameters]\n        pass\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "special_methods_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         \"Used when a __hash__ method returns something which is not an integer\",\n        ),\n        \"E0310\": (\n            \"__length_hint__ does not return non-negative integer\",\n            \"invalid-length-hint-returned\",\n            \"Used when a __length_hint__ method returns something which is not a \"\n            \"non-negative integer\",\n        ),\n        \"E0311\": (\n            \"__format__ does not return str\",\n            \"invalid-format-returned\",\n            \"Used when a __format__ method returns something which is not a string\",\n        ),\n        \"E0312\": (\n            \"__getnewargs__ does not return a tuple\",\n            \"invalid-getnewargs-returned\",\n            \"Used when a __getnewargs__ method returns something which is not \"\n            \"a tuple\",\n        ),\n        \"E0313\": (\n            \"__getnewargs_ex__ does not return a tuple containing (tuple, dict)\",\n            \"invalid-getnewargs-ex-returned\",\n            \"Used when a __getnewargs_ex__ method returns something which is not \"\n            \"of the form tuple(tuple, dict)\",\n        ),\n    }\n\n    def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._protocol_map: dict[\n            str, Callable[[nodes.FunctionDef, InferenceResult], None]\n        ] = {\n            \"__iter__\": self._check_iter,\n            \"__len__\": self._check_len,\n            \"__bool__\": self._check_bool,\n            \"__index__\": self._check_index,\n            \"__repr__\": self._check_repr,\n            \"__str__\": self._check_str,\n            \"__bytes__\": self._check_bytes,\n            \"__hash__\": self._check_hash,\n            \"__length_hint__\": self._check_length_hint,\n            \"__format__\": self._check_format,\n            \"__getnewargs__\": self._check_getnewargs,\n            \"__getnewargs_ex__\": self._check_getnewargs_ex,\n        }\n\n    @only_required_for_messages(\n        \"unexpected-special-method-signature\",\n        \"non-iterator-returned\",\n        \"invalid-length-returned\",\n        \"i"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "invalid_getnewargs_ex_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __getnewargs_ex__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,use-dict-literal,unnecessary-lambda-assignment,use-dict-literal\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodGetNewArgsEx:\n    \"\"\"__getnewargs_ex__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs_ex__(self):\n        return ((1,), {\"2\": \"2\"})\n\n\nclass SecondGoodGetNewArgsEx:\n    \"\"\"__getnewargs_ex__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs_ex__(self):\n        return (tuple(), dict())\n\n\nclass GetNewArgsExMetaclass(type):\n    def __getnewargs_ex__(cls):\n        return ((1,), {\"2\": \"2\"})\n\n\n@six.add_metaclass(GetNewArgsExMetaclass)\nclass ThirdGoodGetNewArgsEx:\n    \"\"\"GetNewArgsEx through the metaclass.\"\"\"\n\n\nclass FourthGoodGetNewArgsEx:\n    \"\"\"Test that `args` and `kwargs` (`Name` nodes) are inferred as tuples.\n\n    https://github.com/pylint-dev/pylint/issues/10208\n    \"\"\"\n    def __init__(self, boo, far, *, hoo, haha):\n        self._foo = boo\n        self._bar = far\n        self._hoo = hoo\n        self._haha = haha\n\n    def __getnewargs_ex__(self):\n        args = (self._foo, self._bar)\n        kwargs = {'hoo': self._hoo,\n                  'haha': self._haha}\n        return args, kwargs\n\n\nclass FirstBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns an integer \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return 1\n\n\nclass SecondBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n\n\nclass ThirdBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for first arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n\n\nclass FourthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for second arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unexpected_special_method_signature.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test for special methods implemented incorrectly.\"\"\"\n\n# pylint: disable=missing-docstring, unused-argument, too-few-public-methods\n# pylint: disable=invalid-name,too-many-arguments,bad-staticmethod-argument\n\nclass Invalid:\n\n    def __enter__(self, other): # [unexpected-special-method-signature]\n        pass\n\n    def __del__(self, other): # [unexpected-special-method-signature]\n        pass\n\n    def __format__(self, other, other2): # [unexpected-special-method-signature]\n        pass\n\n    def __setattr__(self): # [unexpected-special-method-signature]\n        pass\n\n    def __round__(self, invalid, args): # [unexpected-special-method-signature]\n        pass\n\n    def __deepcopy__(self, memo, other): # [unexpected-special-method-signature]\n        pass\n\n    def __iter__(): # [no-method-argument]\n        pass\n\n    @staticmethod\n    def __getattr__(self, nanana): # [unexpected-special-method-signature]\n        pass\n\n    def __subclasses__(self, blabla):  # [unexpected-special-method-signature]\n        pass\n\n\nclass FirstBadContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type): # [unexpected-special-method-signature]\n        pass\n\nclass SecondBadContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, value, tb, stack): # [unexpected-special-method-signature]\n        pass\n\nclass ThirdBadContextManager:\n    def __enter__(self):\n        return self\n\n    # +1: [unexpected-special-method-signature]\n    def __exit__(self, exc_type, value, tb, stack, *args):\n        pass\n\n\nclass Async:\n\n    def __aiter__(self, extra): # [unexpected-special-method-signature]\n        pass\n    def __anext__(self, extra, argument): # [unexpected-special-method-signature]\n        pass\n    def __await__(self, param): # [unexpected-special-method-signature]\n        pass\n    def __aenter__(self, first): # [unexpected-special-method-signature]\n        pass\n    def __aexit__(self): # [unexpected-special-method-signature]\n       "}, {"start_line": 0, "end_line": 348, "belongs_to": {"file_name": "regression_4891.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-module-docstring\n# pylint: disable=too-few-public-methods\nimport copy\n\nclass MyData:\n    '''\n    class docstring\n    '''\n    def __init__(self):\n        self.data = {}\n\n    def process(self):\n        '''\n        another method is responsible for putting \"static_key\"\n        '''\n        copy.copy(self.data['static_key'])\n"}, {"start_line": 0, "end_line": 1447, "belongs_to": {"file_name": "invalid_getnewargs_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __getnewargs__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,unnecessary-lambda-assignment,use-dict-literal\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return (1, \"2\", 3)\n\n\nclass SecondGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return tuple()\n\n\nclass GetNewArgsMetaclass(type):\n    def __getnewargs__(cls):\n        return (1, 2, 3)\n\n\n@six.add_metaclass(GetNewArgsMetaclass)\nclass ThirdGoodGetNewArgs:\n    \"\"\"GetNewArgs through the metaclass.\"\"\"\n\n\nclass FirstBadGetNewArgs:\n    \"\"\" __getnewargs__ returns an integer \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return 1\n\n\nclass SecondBadGetNewArgs:\n    \"\"\" __getnewargs__ returns str \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return \"(1, 2, 3)\"\n\n\nclass ThirdBadGetNewArgs:\n    \"\"\" __getnewargs__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return lambda: tuple(1, 2)\n\n\nclass AmbigousGetNewArgs:\n    \"\"\" Uninferable return value \"\"\"\n    __getnewargs__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgs:\n    \"\"\"Potential uninferable return value\"\"\"\n    def __getnewargs__(self):\n        return tuple(Missing)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "special_methods_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nvalid-bool-returned\",\n        \"invalid-index-returned\",\n        \"invalid-repr-returned\",\n        \"invalid-str-returned\",\n        \"invalid-bytes-returned\",\n        \"invalid-hash-returned\",\n        \"invalid-length-hint-returned\",\n        \"invalid-format-returned\",\n        \"invalid-getnewargs-returned\",\n        \"invalid-getnewargs-ex-returned\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if not node.is_method():\n            return\n\n        inferred = _safe_infer_call_result(node, node)\n        # Only want to check types that we are able to infer\n        if (\n            inferred\n            and node.name in self._protocol_map\n            and not is_function_body_ellipsis(node)\n        ):\n            self._protocol_map[node.name](node, inferred)\n\n        if node.name in PYMETHODS:\n            self._check_unexpected_method_signature(node)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_unexpected_method_signature(self, node: nodes.FunctionDef) -> None:\n        expected_params = SPECIAL_METHODS_PARAMS[node.name]\n\n        if expected_params is None:\n            # This can support a variable number of parameters.\n            return\n        if not node.args.args and not node.args.vararg:\n            # Method has no parameter, will be caught\n            # by no-method-argument.\n            return\n\n        if decorated_with(node, [\"builtins.staticmethod\"]):\n            # We expect to not take in consideration self.\n            all_args = node.args.args\n        else:\n            all_args = node.args.args[1:]\n        mandatory = len(all_args) - len(node.args.defaults)\n        optional = len(node.args.defaults)\n        current_params = mandatory + optional\n\n        emit = False  # If we don't know we choose a false negative\n        if isinstance(expected_params, tuple):\n            # The expected number of parameters can be any value from this\n            # tuple, although the user should implement the method\n            # to t"}, {"start_line": 2000, "end_line": 3550, "belongs_to": {"file_name": "unexpected_special_method_signature.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " pass\n\n\nclass Valid:\n\n    def __new__(cls, test, multiple, args):\n        pass\n\n    # pylint: disable-next=too-many-positional-arguments\n    def __init__(self, this, can, have, multiple, args, as_well):\n        pass\n\n    def __call__(self, also, trv, for_this):\n        pass\n\n    def __round__(self, n):\n        pass\n\n    def __index__(self, n=42):\n        \"\"\"Expects 0 args, but we are taking in account arguments with defaults.\"\"\"\n\n    def __deepcopy__(self, memo):\n        pass\n\n    def __format__(self, format_specification=''):\n        pass\n\n    def __copy__(self, this=None, is_not=None, necessary=None):\n        pass\n\n    @staticmethod\n    def __enter__():\n        pass\n\n    @staticmethod\n    def __getitem__(index):\n        pass\n\n    @classmethod\n    def __init_subclass__(cls, blabla):\n        pass\n\n\nclass FirstGoodContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, value, tb):\n        pass\n\nclass SecondGoodContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type=None, value=None, tb=None):\n        pass\n\nclass ThirdGoodContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, *args):\n        pass\n\n\n# unexpected-special-method-signature\n# https://github.com/pylint-dev/pylint/issues/6644\nclass Philosopher:\n    def __init_subclass__(cls, default_name, **kwargs):\n        super().__init_subclass__(**kwargs)\n        cls.default_name = default_name\n\nclass AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n    pass\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "special_methods_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hich is not \"\n            \"of the form tuple(tuple, dict)\",\n        ),\n    }\n\n    def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._protocol_map: dict[\n            str, Callable[[nodes.FunctionDef, InferenceResult], None]\n        ] = {\n            \"__iter__\": self._check_iter,\n            \"__len__\": self._check_len,\n            \"__bool__\": self._check_bool,\n            \"__index__\": self._check_index,\n            \"__repr__\": self._check_repr,\n            \"__str__\": self._check_str,\n            \"__bytes__\": self._check_bytes,\n            \"__hash__\": self._check_hash,\n            \"__length_hint__\": self._check_length_hint,\n            \"__format__\": self._check_format,\n            \"__getnewargs__\": self._check_getnewargs,\n            \"__getnewargs_ex__\": self._check_getnewargs_ex,\n        }\n\n    @only_required_for_messages(\n        \"unexpected-special-method-signature\",\n        \"non-iterator-returned\",\n        \"invalid-length-returned\",\n        \"invalid-bool-returned\",\n        \"invalid-index-returned\",\n        \"invalid-repr-returned\",\n        \"invalid-str-returned\",\n        \"invalid-bytes-returned\",\n        \"invalid-hash-returned\",\n        \"invalid-length-hint-returned\",\n        \"invalid-format-returned\",\n        \"invalid-getnewargs-returned\",\n        \"invalid-getnewargs-ex-returned\",\n    )\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if not node.is_method():\n            return\n\n        inferred = _safe_infer_call_result(node, node)\n        # Only want to check types that we are able to infer\n        if (\n            inferred\n            and node.name in self._protocol_map\n            and not is_function_body_ellipsis(node)\n        ):\n            self._protocol_map[node.name](node, inferred)\n\n        if node.name in PYMETHODS:\n            self._check_unexpected_method_signature(node)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_unexpected_method_signature(self, node: nodes.Functio"}], "retrieved_count": 10, "cost_time": 1.0815939903259277}
{"question": "How does the filter class that skips Sphinx documentation directive patterns inherit its pattern-based filtering mechanism from the base filter class that provides pattern-based word skipping, enabling the spelling validation system to dynamically compose multiple word filtering components without modifying the external tokenization library interface?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  # type: ignore[misc]\n    \"\"\"Parent class for filters using regular expressions.\n\n    This filter skips any words the match the expression\n    assigned to the class attribute ``_pattern``.\n    \"\"\"\n\n    _pattern: Pattern[str]\n\n    def _skip(self, word: str) -> bool:\n        return bool(self._pattern.match(word))\n\n\nclass CamelCasedWord(RegExFilter):\n    r\"\"\"Filter skipping over camelCasedWords.\n    This filter skips any words matching the following regular expression:\n\n           ^([a-z]\\w+[A-Z]+\\w+)\n\n    That is, any words that are camelCasedWords.\n    \"\"\"\n\n    _pattern = re.compile(r\"^([a-z]+(\\d|[A-Z])(?:\\w+)?)\")\n\n\nclass SphinxDirectives(RegExFilter):\n    r\"\"\"Filter skipping over Sphinx Directives.\n    This filter skips any words matching the following regular expression:\n\n           ^(:([a-z]+)){1,2}:`([^`]+)(`)?\n\n    That is, for example, :class:`BaseQuery`\n    \"\"\"\n\n    # The final ` in the pattern is optional because enchant strips it out\n    _pattern = re.compile(r\"^(:([a-z]+)){1,2}:`([^`]+)(`)?\")\n\n\nclass ForwardSlashChunker(Chunker):  # type: ignore[misc]\n    \"\"\"This chunker allows splitting words like 'before/after' into 'before' and\n    'after'.\n    \"\"\"\n\n    _text: str\n\n    def next(self) -> tuple[str, int]:\n        while True:\n            if not self._text:\n                raise StopIteration()\n            if \"/\" not in self._text:\n                text = self._text\n                self._offset = 0\n                self._text = \"\"\n                return text, 0\n            pre_text, post_text = self._text.split(\"/\", 1)\n            self._text = post_text\n            self._offset = 0\n            if (\n                not pre_text\n                or not post_text\n                or not pre_text[-1].isalpha()\n                or not post_text[0].isalpha()\n            ):\n                self._text = \"\"\n                self._offset = 0\n                return f\"{pre_text}/{post_text}\", 0\n            return pre_text, 0\n\n    def _next(self) -> tuple[str, Literal[0]]:\n  "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  pyenchant_available: bool,\n) -> str:\n    if inner_enchant_dicts:\n        dict_as_str = [f\"{d[0]} ({d[1].name})\" for d in inner_enchant_dicts]\n        enchant_help = f\"Available dictionaries: {', '.join(dict_as_str)}\"\n    else:\n        enchant_help = \"No available dictionaries : You need to install \"\n        if not pyenchant_available:\n            enchant_help += \"both the python package and \"\n        enchant_help += \"the system dependency for enchant to work\"\n    return f\"Spelling dictionary name. {enchant_help}.\"\n\n\nenchant_dicts = _get_enchant_dicts()\n\n\nclass WordsWithDigitsFilter(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with digits.\"\"\"\n\n    def _skip(self, word: str) -> bool:\n        return any(char.isdigit() for char in word)\n\n\nclass WordsWithUnderscores(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with underscores.\n\n    They are probably function parameter names.\n    \"\"\"\n\n    def _skip(self, word: str) -> bool:\n        return \"_\" in word\n\n\nclass RegExFilter(Filter):  # type: ignore[misc]\n    \"\"\"Parent class for filters using regular expressions.\n\n    This filter skips any words the match the expression\n    assigned to the class attribute ``_pattern``.\n    \"\"\"\n\n    _pattern: Pattern[str]\n\n    def _skip(self, word: str) -> bool:\n        return bool(self._pattern.match(word))\n\n\nclass CamelCasedWord(RegExFilter):\n    r\"\"\"Filter skipping over camelCasedWords.\n    This filter skips any words matching the following regular expression:\n\n           ^([a-z]\\w+[A-Z]+\\w+)\n\n    That is, any words that are camelCasedWords.\n    \"\"\"\n\n    _pattern = re.compile(r\"^([a-z]+(\\d|[A-Z])(?:\\w+)?)\")\n\n\nclass SphinxDirectives(RegExFilter):\n    r\"\"\"Filter skipping over Sphinx Directives.\n    This filter skips any words matching the following regular expression:\n\n           ^(:([a-z]+)){1,2}:`([^`]+)(`)?\n\n    That is, for example, :class:`BaseQuery`\n    \"\"\"\n\n    # The final ` in the pattern is optional because enchant strips it out\n    _pattern = re.compile(r\"^(:([a-z]+)){1,"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "RLFilter:  # type: ignore[no-redef]\n        ...\n\n    class WikiWordFilter:  # type: ignore[no-redef]\n        ...\n\n    class Filter:  # type: ignore[no-redef]\n        def _skip(self, word: str) -> bool:\n            raise NotImplementedError\n\n    class Chunker:  # type: ignore[no-redef]\n        pass\n\n    def get_tokenizer(\n        tag: str | None = None,  # pylint: disable=unused-argument\n        chunkers: list[Chunker] | None = None,  # pylint: disable=unused-argument\n        filters: list[Filter] | None = None,  # pylint: disable=unused-argument\n    ) -> Filter:\n        return Filter()\n\n\ndef _get_enchant_dicts() -> list[tuple[Any, enchant.ProviderDesc]]:\n    return enchant.Broker().list_dicts() if PYENCHANT_AVAILABLE else []\n\n\ndef _get_enchant_dict_choices(\n    inner_enchant_dicts: list[tuple[Any, enchant.ProviderDesc]],\n) -> list[str]:\n    return [\"\"] + [d[0] for d in inner_enchant_dicts]\n\n\ndef _get_enchant_dict_help(\n    inner_enchant_dicts: list[tuple[Any, enchant.ProviderDesc]],\n    pyenchant_available: bool,\n) -> str:\n    if inner_enchant_dicts:\n        dict_as_str = [f\"{d[0]} ({d[1].name})\" for d in inner_enchant_dicts]\n        enchant_help = f\"Available dictionaries: {', '.join(dict_as_str)}\"\n    else:\n        enchant_help = \"No available dictionaries : You need to install \"\n        if not pyenchant_available:\n            enchant_help += \"both the python package and \"\n        enchant_help += \"the system dependency for enchant to work\"\n    return f\"Spelling dictionary name. {enchant_help}.\"\n\n\nenchant_dicts = _get_enchant_dicts()\n\n\nclass WordsWithDigitsFilter(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with digits.\"\"\"\n\n    def _skip(self, word: str) -> bool:\n        return any(char.isdigit() for char in word)\n\n\nclass WordsWithUnderscores(Filter):  # type: ignore[misc]\n    \"\"\"Skips words with underscores.\n\n    They are probably function parameter names.\n    \"\"\"\n\n    def _skip(self, word: str) -> bool:\n        return \"_\" in word\n\n\nclass RegExFilter(Filter):"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "unittest_spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        # when analyzed with mypy 1.02\n            \"# type: ignore[attr-defined] NotAWord\",\n        ],\n    )\n    def test_skip_type_comments(self, type_comment: str) -> None:\n        self.checker.process_tokens(_tokenize_str(type_comment))\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_sphinx_directives(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :class:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :class:`ComentAbc` with a bad coment\",\n                    \"                                      ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_sphinx_directives_2(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :py:attr:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :py:attr:`ComentAbc` with a bad coment\",\n                    \"                                        ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    @pytest.mark.parametrize(\n        \"prefix,suffix\",\n        (\n            pytest.param(\"fmt\", \": on\", id=\"black direc"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "unittest_spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et_config(spelling_dict=spell_dict)\n    def test_skip_email_address(self) -> None:\n        self.checker.process_tokens(_tokenize_str(\"# uname@domain.tld\"))\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_urls(self) -> None:\n        self.checker.process_tokens(_tokenize_str(\"# https://github.com/rfk/pyenchant\"))\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    @pytest.mark.parametrize(\n        \"type_comment\",\n        [\n            \"# type: (NotAWord) -> NotAWord\",\n            \"# type: List[NotAWord] -> List[NotAWord]\",\n            \"# type: Dict[NotAWord] -> Dict[NotAWord]\",\n            \"# type: NotAWord\",\n            \"# type: List[NotAWord]\",\n            \"# type: Dict[NotAWord]\",\n            \"# type: ImmutableList[Manager]\",\n            # will result in error: Invalid \"type: ignore\" comment  [syntax]\n            # when analyzed with mypy 1.02\n            \"# type: ignore[attr-defined] NotAWord\",\n        ],\n    )\n    def test_skip_type_comments(self, type_comment: str) -> None:\n        self.checker.process_tokens(_tokenize_str(type_comment))\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_sphinx_directives(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :class:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :class:`ComentAbc` with a bad coment\",\n                    \"                                      ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n     "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      while True:\n            if \"/\" not in self._text:\n                return self._text, 0\n            pre_text, post_text = self._text.split(\"/\", 1)\n            if not pre_text or not post_text:\n                break\n            if not pre_text[-1].isalpha() or not post_text[0].isalpha():\n                raise StopIteration()\n            self._text = pre_text + \" \" + post_text\n        raise StopIteration()\n\n\nCODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r\"(\\s|^)(`{1,2})([^`]+)(\\2)([^`]|$)\")\n\n\ndef _strip_code_flanked_in_backticks(line: str) -> str:\n    \"\"\"Alter line so code flanked in back-ticks is ignored.\n\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n        return match_obj.group(1) + match_obj.group(5)\n\n    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(\n        replace_code_but_leave_surrounding_characters, line\n    )\n\n\nclass SpellingChecker(BaseTokenChecker):\n    \"\"\"Check spelling in comments and docstrings.\"\"\"\n\n    name = \"spelling\"\n    msgs = {\n        \"C0401\": (\n            \"Wrong spelling of a word '%s' in a comment:\\n%s\\n\"\n            \"%s\\nDid you mean: '%s'?\",\n            \"wrong-spelling-in-comment\",\n            \"Used when a word in comment is not spelled correctly.\",\n        ),\n        \"C0402\": (\n            \"Wrong spelling of a word '%s' in a docstring:\\n%s\\n\"\n            \"%s\\nDid you mean: '%s'?\",\n            \"wrong-spelling-in-docstring\",\n            \"Used when a word in docstring is not spelled correctly.\",\n        ),\n        \"C0403\": (\n            \"Invalid characters %r in a docstring\",\n            \"invalid-characters-in-docstring\",\n            \"Used when a word in docstring cannot be checked by enchant.\",\n        ),\n    }\n    options = (\n        (\n            \"spelling-dict\",\n            {\n                \"default\": \"\",\n                \"type\": \"choice\",\n                \"metavar"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "unittest_spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  MessageTest(\n                \"wrong-spelling-in-comment\",\n                line=1,\n                args=(\n                    \"qsize\",\n                    full_comment,\n                    \"                 ^^^^^\",\n                    self._get_msg_suggestions(\"qsize\"),\n                ),\n            )\n        ):\n            self.checker.process_tokens(_tokenize_str(full_comment))\n\n    @skip_on_missing_package_or_dict\n    @set_config(\n        spelling_dict=spell_dict,\n        spelling_ignore_comment_directives=\"newdirective:,noqa\",\n    )\n    def test_skip_directives_specified_in_pylintrc(self) -> None:\n        full_comment = \"# newdirective: do this newdirective\"\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-comment\",\n                line=1,\n                args=(\n                    \"newdirective\",\n                    full_comment,\n                    \"          ^^^^^^^^^^^^\",\n                    self._get_msg_suggestions(\"newdirective\"),\n                ),\n            )\n        ):\n            self.checker.process_tokens(_tokenize_str(full_comment))\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_handle_words_joined_by_forward_slash(self) -> None:\n        stmt = astroid.extract_node(\n            '''\n        class ComentAbc(object):\n            \"\"\"This is Comment/Abcz with a bad comment\"\"\"\n            pass\n        '''\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=3,\n                args=(\n                    \"Abcz\",\n                    \"This is Comment/Abcz with a bad comment\",\n                    \"                ^^^^\",\n                    self._get_msg_suggestions(\"Abcz\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_more_than_one_error_in"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2}:`([^`]+)(`)?\")\n\n\nclass ForwardSlashChunker(Chunker):  # type: ignore[misc]\n    \"\"\"This chunker allows splitting words like 'before/after' into 'before' and\n    'after'.\n    \"\"\"\n\n    _text: str\n\n    def next(self) -> tuple[str, int]:\n        while True:\n            if not self._text:\n                raise StopIteration()\n            if \"/\" not in self._text:\n                text = self._text\n                self._offset = 0\n                self._text = \"\"\n                return text, 0\n            pre_text, post_text = self._text.split(\"/\", 1)\n            self._text = post_text\n            self._offset = 0\n            if (\n                not pre_text\n                or not post_text\n                or not pre_text[-1].isalpha()\n                or not post_text[0].isalpha()\n            ):\n                self._text = \"\"\n                self._offset = 0\n                return f\"{pre_text}/{post_text}\", 0\n            return pre_text, 0\n\n    def _next(self) -> tuple[str, Literal[0]]:\n        while True:\n            if \"/\" not in self._text:\n                return self._text, 0\n            pre_text, post_text = self._text.split(\"/\", 1)\n            if not pre_text or not post_text:\n                break\n            if not pre_text[-1].isalpha() or not post_text[0].isalpha():\n                raise StopIteration()\n            self._text = pre_text + \" \" + post_text\n        raise StopIteration()\n\n\nCODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r\"(\\s|^)(`{1,2})([^`]+)(\\2)([^`]|$)\")\n\n\ndef _strip_code_flanked_in_backticks(line: str) -> str:\n    \"\"\"Alter line so code flanked in back-ticks is ignored.\n\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n        return match_obj.group(1) + match_obj.group(5)\n\n    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(\n        replace_code_but_leave_surrounding_characters, lin"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "unittest_spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_sphinx_directives_2(self) -> None:\n        stmt = astroid.extract_node(\n            'class ComentAbc(object):\\n   \"\"\"This is :py:attr:`ComentAbc` with a bad coment\"\"\"\\n   pass'\n        )\n        with self.assertAddsMessages(\n            MessageTest(\n                \"wrong-spelling-in-docstring\",\n                line=2,\n                args=(\n                    \"coment\",\n                    \"This is :py:attr:`ComentAbc` with a bad coment\",\n                    \"                                        ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    @pytest.mark.parametrize(\n        \"prefix,suffix\",\n        (\n            pytest.param(\"fmt\", \": on\", id=\"black directive to turn on formatting\"),\n            pytest.param(\"fmt\", \": off\", id=\"black directive to turn off formatting\"),\n            pytest.param(\"noqa\", \"\", id=\"pycharm directive\"),\n            pytest.param(\"noqa\", \":\", id=\"flake8 / zimports directive\"),\n            pytest.param(\"nosec\", \"\", id=\"bandit directive\"),\n            pytest.param(\"isort\", \":skip\", id=\"isort directive\"),\n            pytest.param(\"mypy\", \":\", id=\"mypy top of file directive\"),\n        ),\n    )\n    def test_tool_directives_handling(self, prefix: str, suffix: str) -> None:\n        \"\"\"We're not raising when the directive is at the beginning of comments,\n        but we raise if a directive appears later in comment.\n        \"\"\"\n        full_comment = f\"# {prefix}{suffix} {prefix}\"\n        args = (\n            prefix,\n            full_comment,\n            f\"  {'^' * len(prefix)}\",\n            self._get_msg_suggestions(prefix),\n        )\n        with self.assertAddsMessages(\n            MessageTest(\"wrong-spelling-in-comm"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "unittest_spelling.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       \"coment\",\n                    \"bad coment\",\n                    \"    ^^^^^^\",\n                    self._get_msg_suggestions(\"coment\"),\n                ),\n            )\n        ):\n            self.checker.visit_classdef(stmt)\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_shebangs(self) -> None:\n        self.checker.process_tokens(_tokenize_str(\"#!/usr/bin/env python\"))\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_python_coding_comments(self) -> None:\n        self.checker.process_tokens(_tokenize_str(\"# -*- coding: utf-8 -*-\"))\n        assert not self.linter.release_messages()\n        self.checker.process_tokens(_tokenize_str(\"# coding=utf-8\"))\n        assert not self.linter.release_messages()\n        self.checker.process_tokens(_tokenize_str(\"# vim: set fileencoding=utf-8 :\"))\n        assert not self.linter.release_messages()\n        # Now with a shebang first\n        self.checker.process_tokens(\n            _tokenize_str(\"#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\")\n        )\n        assert not self.linter.release_messages()\n        self.checker.process_tokens(\n            _tokenize_str(\"#!/usr/bin/env python\\n# coding=utf-8\")\n        )\n        assert not self.linter.release_messages()\n        self.checker.process_tokens(\n            _tokenize_str(\"#!/usr/bin/env python\\n# vim: set fileencoding=utf-8 :\")\n        )\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_top_level_pylint_enable_disable_comments(self) -> None:\n        self.checker.process_tokens(\n            _tokenize_str(\"# Line 1\\n Line 2\\n# pylint: disable=ungrouped-imports\")\n        )\n        assert not self.linter.release_messages()\n\n    @skip_on_missing_package_or_dict\n    @set_config(spelling_dict=spell_dict)\n    def test_skip_words_with_numb"}], "retrieved_count": 10, "cost_time": 1.0909218788146973}
{"question": "Why does the test framework use a metaclass that assigns a lambda with an incorrect signature to __or__ for a test class in the alternative union syntax validation tests?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 77000, "end_line": 79000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sinstance(parent_node, nodes.Module):\n                        break\n            if not allowed_nested_syntax:\n                self._check_unsupported_alternative_union_syntax(node)\n\n    def _includes_version_compatible_overload(self, attrs: list[nodes.NodeNG]) -> bool:\n        \"\"\"Check if a set of overloads of an operator includes one that\n        can be relied upon for our configured Python version.\n\n        If we are running under a Python 3.10+ runtime but configured for\n        pre-3.10 compatibility then Astroid will have inferred the\n        existence of __or__ / __ror__ on builtins.type, but these aren't\n        available in the configured version of Python.\n        \"\"\"\n        is_py310_builtin = all(\n            isinstance(attr, (nodes.FunctionDef, astroid.BoundMethod))\n            and attr.parent.qname() == \"builtins.type\"\n            for attr in attrs\n        )\n        return not is_py310_builtin or self._py310_plus\n\n    def _recursive_search_for_classdef_type(\n        self, node: nodes.ClassDef, operation: Literal[\"__or__\", \"__ror__\"]\n    ) -> bool | VERSION_COMPATIBLE_OVERLOAD:\n        if not isinstance(node, nodes.ClassDef):\n            return False\n        try:\n            attrs = node.getattr(operation)\n        except astroid.NotFoundError:\n            return True\n        if self._includes_version_compatible_overload(attrs):\n            return VERSION_COMPATIBLE_OVERLOAD_SENTINEL\n        return True\n\n    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -> None:\n        \"\"\"Check if left or right node is of type `type`.\n\n        If either is, and doesn't support an or operator via a metaclass,\n        infer that this is a mistaken attempt to use alternative union\n        syntax when not supported.\n        \"\"\"\n        msg = \"unsupported operand type(s) for |\"\n        left_obj = astroid.helpers.object_type(node.left)\n        right_obj = astroid.helpers.object_type(node.right)\n        left_is_type = self._recursive_search_for_classd"}, {"start_line": 78000, "end_line": 80000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "node: nodes.ClassDef, operation: Literal[\"__or__\", \"__ror__\"]\n    ) -> bool | VERSION_COMPATIBLE_OVERLOAD:\n        if not isinstance(node, nodes.ClassDef):\n            return False\n        try:\n            attrs = node.getattr(operation)\n        except astroid.NotFoundError:\n            return True\n        if self._includes_version_compatible_overload(attrs):\n            return VERSION_COMPATIBLE_OVERLOAD_SENTINEL\n        return True\n\n    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -> None:\n        \"\"\"Check if left or right node is of type `type`.\n\n        If either is, and doesn't support an or operator via a metaclass,\n        infer that this is a mistaken attempt to use alternative union\n        syntax when not supported.\n        \"\"\"\n        msg = \"unsupported operand type(s) for |\"\n        left_obj = astroid.helpers.object_type(node.left)\n        right_obj = astroid.helpers.object_type(node.right)\n        left_is_type = self._recursive_search_for_classdef_type(left_obj, \"__or__\")\n        if left_is_type is VERSION_COMPATIBLE_OVERLOAD_SENTINEL:\n            return\n        right_is_type = self._recursive_search_for_classdef_type(right_obj, \"__ror__\")\n        if right_is_type is VERSION_COMPATIBLE_OVERLOAD_SENTINEL:\n            return\n\n        if left_is_type or right_is_type:\n            self.add_message(\n                \"unsupported-binary-operation\",\n                args=msg,\n                node=node,\n                confidence=INFERENCE,\n            )\n\n    # TODO: This check was disabled (by adding the leading underscore)\n    # due to false positives several years ago - can we re-enable it?\n    # https://github.com/pylint-dev/pylint/issues/6359\n    @only_required_for_messages(\"unsupported-binary-operation\")\n    def _visit_binop(self, node: nodes.BinOp) -> None:\n        \"\"\"Detect TypeErrors for binary arithmetic operands.\"\"\"\n        self._check_binop_errors(node)\n\n    # TODO: This check was disabled (by adding the leading underscore)"}, {"start_line": 76000, "end_line": 78000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " is enabled.\n            self._check_unsupported_alternative_union_syntax(node)\n\n        if isinstance(\n            node.parent,\n            (\n                nodes.Assign,\n                nodes.Call,\n                nodes.Keyword,\n                nodes.Dict,\n                nodes.Tuple,\n                nodes.Set,\n                nodes.List,\n                nodes.BinOp,\n            ),\n        ):\n            # Check other contexts the syntax might appear, but are invalid.\n            # Make sure to filter context if postponed evaluation is enabled\n            # and parent is allowed node type.\n            allowed_nested_syntax = False\n            if self._postponed_evaluation_enabled:\n                parent_node = node.parent\n                while True:\n                    if isinstance(parent_node, TYPE_ANNOTATION_NODES_TYPES):\n                        allowed_nested_syntax = True\n                        break\n                    parent_node = parent_node.parent\n                    if isinstance(parent_node, nodes.Module):\n                        break\n            if not allowed_nested_syntax:\n                self._check_unsupported_alternative_union_syntax(node)\n\n    def _includes_version_compatible_overload(self, attrs: list[nodes.NodeNG]) -> bool:\n        \"\"\"Check if a set of overloads of an operator includes one that\n        can be relied upon for our configured Python version.\n\n        If we are running under a Python 3.10+ runtime but configured for\n        pre-3.10 compatibility then Astroid will have inferred the\n        existence of __or__ / __ror__ on builtins.type, but these aren't\n        available in the configured version of Python.\n        \"\"\"\n        is_py310_builtin = all(\n            isinstance(attr, (nodes.FunctionDef, astroid.BoundMethod))\n            and attr.parent.qname() == \"builtins.type\"\n            for attr in attrs\n        )\n        return not is_py310_builtin or self._py310_plus\n\n    def _recursive_search_for_classdef_type(\n        self, "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,unnecessary-direct-lambda-call,superfluous-parens\n\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\nAlias = str | list[int]\nlst = [typing.Dict[str, int] | None,]\n\nvar1: typing.Dict[str, int | None]\nvar2: int | str | None\nvar3: int | list[str | int]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)\n\nT = typing.TypeVar(\"T\", int | str, bool)\n\n(lambda x: 2)(int | str)\n\nvar: str | int\n\ndef func(arg: int | str):\n    pass\n\ndef func2() -> int | str:\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=(int | str))\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: int | str\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: int | str\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: int | str\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: int | str\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: int | str\n\nclass ForwardMetaclass(type):\n    def __or__(cls, other):\n        return True\n\nclass ReverseMetaclass(type):\n    def __ror__(cls, other):\n        return True\n\nclass WithForward(metaclass=ForwardMetaclass):\n "}, {"start_line": 2000, "end_line": 3947, "belongs_to": {"file_name": "alternative_union_syntax_error.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "):\n    my_var: int | str  # [unsupported-binary-operation]\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=int | str)  # [unsupported-binary-operation]\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})  # [unsupported-binary-operation]\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str  # [unsupported-binary-operation]\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: int | str  # [unsupported-binary-operation]\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: int | str  # [unsupported-binary-operation]\n\n# Not an error if the metaclass implements __or__\n\nclass ForwardMetaclass(type):\n    def __or__(cls, other):\n        return True\n\nclass ReverseMetaclass(type):\n    def __ror__(cls, other):\n        return True\n\nclass WithForward(metaclass=ForwardMetaclass):\n    pass\n\nclass WithReverse(metaclass=ReverseMetaclass):\n    pass\n\nclass DefaultMetaclass:\n    pass\n\nclass_list = [WithForward | DefaultMetaclass]\nclass_list_reversed_invalid = [WithReverse | DefaultMetaclass] # [unsupported-binary-operation]\nclass_list_reversed_valid = [DefaultMetaclass | WithReverse]\n\n\n# Pathological cases\nclass HorribleMetaclass(type):\n    __or__ = lambda x: x\n\nclass WithHorrible(metaclass=HorribleMetaclass):\n    pass\n\nclass_list = [WithHorrible | DefaultMetaclass]\n\nclass SecondLevelMetaclass(ForwardMetaclass):\n    pass\n\nclass WithSecondLevel(metaclass=SecondLevelMetaclass):\n    pass\n\nclass_list_with_second_level = [WithSecondLevel | DefaultMetaclass]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax_error.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax with postponed evaluation of\nannotations enabled.\n\nFor Python 3.7 - 3.9: Everything should fail.\nTesting only 3.8/3.9 to support TypedDict.\n\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,line-too-long,unnecessary-direct-lambda-call\n# pylint: disable=unnecessary-lambda-assignment\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\n\nAlias = str | typing.List[int]  # [unsupported-binary-operation]\nlst = [typing.Dict[str, int] | None,]  # [unsupported-binary-operation]\n\nvar1: typing.Dict[str, int | None]  # [unsupported-binary-operation]\n# var2: int | str | None  # false-negative: unsupported-binary-operation, unsupported-binary-operation\nvar3: int | typing.List[str | int]  # [unsupported-binary-operation]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]  # [unsupported-binary-operation]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int  # [unsupported-binary-operation]\n\ndef func(arg: int | str):  # [unsupported-binary-operation]\n    pass\n\ndef func2() -> int | str:  # [unsupported-binary-operation]\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str  # [unsupported-binary-operation]\n\nclass CustomNamedTuple3(typing.NamedTuple"}, {"start_line": 0, "end_line": 317, "belongs_to": {"file_name": "none_dunder_protocols_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods,expression-not-assigned\nclass MetaContainer(type):\n    __contains__ = None\n\n\nclass NamedExpressionClass(metaclass=MetaContainer):\n    if (__iter__ := lambda x: x):  # [unnecessary-lambda-assignment]\n        pass\n\n\ndef test():\n    1 in NamedExpressionClass()\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax with postponed evaluation of\nannotations enabled.\n\nFor Python 3.7 - 3.9: Most things should work.\nTesting only 3.8/3.9 to support TypedDict.\n\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,line-too-long,unnecessary-direct-lambda-call\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nfrom __future__ import annotations\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\n\nAlias = str | typing.List[int]  # [unsupported-binary-operation]\nlst = [typing.Dict[str, int] | None,]  # [unsupported-binary-operation]\n\nvar1: typing.Dict[str, int | None]\nvar2: int | str | None\nvar3: int | list[str | int]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int\n\ndef func(arg: int | str):\n    pass\n\ndef func2() -> int | str:\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=int | str)  # [unsupported-binary-operation]\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})  # [unsupported-binary-operation]\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str\n\nclass CustomTypedDic"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e,\n                confidence=HIGH,\n            )\n\n    @staticmethod\n    def _is_deprecated_union_annotation(\n        annotation: nodes.NodeNG, union_name: str\n    ) -> bool:\n        return (\n            isinstance(annotation, nodes.Subscript)\n            and isinstance(annotation.value, nodes.Name)\n            and annotation.value.name == union_name\n        )\n\n    def _is_binop_union_annotation(self, annotation: nodes.NodeNG) -> bool:\n        return self._should_check_alternative_union_syntax and isinstance(\n            annotation, nodes.BinOp\n        )\n\n    @staticmethod\n    def _is_optional_none_annotation(annotation: nodes.Subscript) -> bool:\n        return (\n            isinstance(annotation.slice, nodes.Const) and annotation.slice.value is None\n        )\n\n    def _parse_binops_typehints(\n        self, binop_node: nodes.BinOp, typehints_list: list[nodes.NodeNG] | None = None\n    ) -> list[nodes.NodeNG]:\n        typehints_list = typehints_list or []\n        if isinstance(binop_node.left, nodes.BinOp):\n            typehints_list.extend(\n                self._parse_binops_typehints(binop_node.left, typehints_list)\n            )\n        else:\n            typehints_list.append(binop_node.left)\n        typehints_list.append(binop_node.right)\n        return typehints_list\n\n    def _check_union_types(\n        self, types: list[nodes.NodeNG], annotation: nodes.NodeNG\n    ) -> None:\n        types_set = set()\n        for typehint in types:\n            typehint_str = typehint.as_string()\n            if typehint_str in types_set:\n                self.add_message(\n                    \"redundant-typehint-argument\",\n                    node=annotation,\n                    args=(typehint_str),\n                    confidence=HIGH,\n                )\n            else:\n                types_set.add(typehint_str)\n\n    def _check_for_alternative_union_syntax(\n        self,\n        node: nodes.Name | nodes.Attribute,\n        name: str,\n    ) -> None:\n        \"\"\"Check if alternative un"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".left, nodes.BinOp):\n            typehints_list.extend(\n                self._parse_binops_typehints(binop_node.left, typehints_list)\n            )\n        else:\n            typehints_list.append(binop_node.left)\n        typehints_list.append(binop_node.right)\n        return typehints_list\n\n    def _check_union_types(\n        self, types: list[nodes.NodeNG], annotation: nodes.NodeNG\n    ) -> None:\n        types_set = set()\n        for typehint in types:\n            typehint_str = typehint.as_string()\n            if typehint_str in types_set:\n                self.add_message(\n                    \"redundant-typehint-argument\",\n                    node=annotation,\n                    args=(typehint_str),\n                    confidence=HIGH,\n                )\n            else:\n                types_set.add(typehint_str)\n\n    def _check_for_alternative_union_syntax(\n        self,\n        node: nodes.Name | nodes.Attribute,\n        name: str,\n    ) -> None:\n        \"\"\"Check if alternative union syntax could be used.\n\n        Requires\n        - Python 3.10\n        - OR: Python 3.7+ with postponed evaluation in\n              a type annotation context\n        \"\"\"\n        inferred = safe_infer(node)\n        if not (\n            (\n                isinstance(inferred, (nodes.FunctionDef, nodes.ClassDef))\n                and inferred.qname() in {\"typing.Optional\", \"typing.Union\"}\n            )\n            or (\n                isinstance(inferred, astroid.bases.Instance)\n                and inferred.qname() == \"typing._SpecialForm\"\n            )\n        ):\n            return\n        if not (self._py310_plus or is_node_in_type_annotation_context(node)):\n            return\n        self.add_message(\n            \"consider-alternative-union-syntax\",\n            node=node,\n            args=(name, self._msg_postponed_eval_hint(node)),\n            confidence=INFERENCE,\n        )\n\n    def _check_for_typing_alias(\n        self,\n        node: nodes.Name | nodes.Attribute,\n    ) -> None:\n   "}], "retrieved_count": 10, "cost_time": 1.0670294761657715}
{"question": "How does the descriptor protocol implementation in the test descriptor class's get method interact with Python's attribute resolution mechanism when accessed through different ownership contexts?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 5061, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n    __slots__ = ()\n\n\nrepro = Repro()\nrepro.attr2 = \"anything\"\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def __setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "not_callable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "1, 2)\n\n\n# NamedTuple is callable, even if it aliased to an attribute\n# See https://github.com/pylint-dev/pylint/issues/1730\nclass TestNamedTuple:\n    def __init__(self, field: str) -> None:\n        self.my_tuple = typing.NamedTuple(\"Tuple\", [(field, int)])\n        self.item: self.my_tuple\n\n    def set_item(self, item: int) -> None:\n        self.item = self.my_tuple(item)\n\n\n# Test descriptor call\ndef func():\n    pass\n\n\nclass ADescriptor:\n    def __get__(self, instance, owner):\n        return func\n\n\nclass AggregateCls:\n    a = ADescriptor()\n\n\nAggregateCls().a()\n\n\n# Make sure not-callable isn't raised for descriptors\n\n# astroid can't process descriptors correctly so\n# pylint needs to ignore not-callable for them\n# right now\n\n# Test for https://github.com/pylint-dev/pylint/issues/1699\n\nimport multiprocessing\n\nmultiprocessing.current_process()\n\n# Make sure not-callable isn't raised for uninferable properties\nclass MyClass:\n    @property\n    def call(self):\n        return undefined\n\n\na = A()\na.call()\n\n# Make sure the callable check does not crash when a node's parent cannot be determined.\ndef get_number(arg):\n    return 2 * arg\n\n\nget_number(10)()  # [not-callable]\n\nclass Klass:\n    def __init__(self):\n        self._x = None\n\n    @property\n    def myproperty(self):\n        if self._x is None:\n            self._x = lambda: None\n        return self._x\n\nMY_OBJECT = Klass()\nMY_OBJECT.myproperty()\n\nclass Klass2:\n    @property\n    def something(self):\n        if __file__.startswith('s'):\n            return str\n\n        return 'abcd'\n\nOBJ_2 = Klass2()\nOBJ_2.something()\n\n\n# Regression test for https://github.com/pylint-dev/pylint/issues/7109\ninstance_or_cls = MyClass  # pylint:disable=invalid-name\ninstance_or_cls = MyClass()\nif not isinstance(instance_or_cls, MyClass):\n    NEW = MyClass.__new__(instance_or_cls)\n    NEW()\n\n\n# Regression test for https://github.com/pylint-dev/pylint/issues/5113.\n# Do not emit `not-callable`.\nATTRIBUTES = {\n    'DOMAIN': (\"domain\", str),\n    'IMAGE':"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "member_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m/member", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e provider's method\"\"\"\n        self._prov.hophop()\n        self._prov.hophophop()  # [no-member]\n\n    def use_attr(self):\n        \"\"\"use provider's attr\"\"\"\n        print(self._prov.attr)\n        print(self._prov.attribute)  # [no-member]\n\n    def debug(self):\n        \"\"\"print debug information\"\"\"\n        print(self.__class__.__name__)\n        print(self.__doc__)\n        print(self.__dict__)\n        print(self.__module__)\n\n    def test_bt_types(self):\n        \"\"\"test access to unexistant member of builtin types\"\"\"\n        lis = []\n        lis.apppend(self)  # [no-member]\n        dic = {}\n        dic.set(self)  # [no-member]\n        tup = ()\n        tup.append(self)  # [no-member]\n        string = 'toto'\n        print(string.loower())  # [no-member]\n        integer = 1\n        print(integer.whatever)  # [no-member]\n\n    def test_no_false_positives(self):\n        none = None\n        print(none.whatever)\n        # No misssing in the parents.\n        super().misssing() # [no-member]\n\n\nclass Mixin:\n    \"\"\"No no-member should be emitted for mixins.\"\"\"\n\nclass Getattr:\n    \"\"\"no-member shouldn't be emitted for classes with dunder getattr.\"\"\"\n\n    def __getattr__(self, attr):\n        return self.__dict__[attr]\n\n\nclass Getattribute:\n    \"\"\"no-member shouldn't be emitted for classes with dunder getattribute.\"\"\"\n\n    def __getattribute__(self, attr):\n        return 42\n\nprint(object.__init__)\nprint(property.__init__)\nprint(Client().set_later.lower())\nprint(Mixin().nanana())\nprint(Getattr().nananan())\nprint(Getattribute().batman())\n\ntry:\n    Client().missing_method()\nexcept AttributeError:\n    pass\n\ntry:\n    Client().indeed() # [no-member]\nexcept ImportError:\n    pass\n\ntry:\n    Client.missing()\nexcept AttributeError:\n    Client.missing() # [no-member]\n\ntry:\n    Client.missing()\nexcept AttributeError:\n    try:\n        Client.missing() # [no-member]\n    except ValueError:\n        pass\n\ntry:\n    if Client:\n        Client().missing()\nexcept AttributeError:\n    pass\n\ntry:\n    Client()."}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def _"}, {"start_line": 8000, "end_line": 9683, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "__defaults_set = False\n\n    def __init__(self, value):\n        self.value = value\n\n    def __init_defaults(self):  # [unused-private-member]\n        if not self.__defaults_set:\n            type(self).__defaults = { \"fur\": \"pink\" }\n            type(self).__defaults_set = True\n\n    def __get_fur_color(self):  # [unused-private-member]\n        color = lookup_attribute(self.__defaults, \"fur\")\n        return color\n\n\ndef lookup_attribute(mapping, key):\n    return mapping[key]\n\n\n# Test for regression on checking __class__ attribute\n# See: https://github.com/pylint-dev/pylint/issues/5261\nclass Foo:\n    __ham = 1\n\n    def method(self):\n        print(self.__class__.__ham)\n\n\n# https://github.com/pylint-dev/pylint/issues/4756\n# Check for false positives emitted when private functions are not referenced in the class body\n# with standard calls but passed as arguments to other functions.\nclass FalsePositive4756a:\n    def __bar(self, x):\n        print(x)\n    fizz = partialmethod(__bar, 'fizz')\ntest = FalsePositive4756a()\ntest.fizz()\n\nclass FalsePositive4756b:\n    def __get_prop(self):\n        pass\n\n    def __set_prop(self, value):\n        pass\n\n    def __del_prop(self):\n        pass\n\n    prop = property(__get_prop, __set_prop, __del_prop)\n\n\nclass TypeSelfCallInMethod:\n    \"\"\"Regression test for issue 5569\"\"\"\n    @classmethod\n    def b(cls) -> None:\n        cls.__a = ''  # [unused-private-member]\n\n    def a(self):\n        return type(self).__a\n\n\nclass Item:\n    \"\"\"Regression test for https://github.com/pylint-dev/pylint/issues/6709\"\"\"\n    def __init__(self, parent):\n        self.__parent: Item = parent\n        self.__item = self.__parent.__item  # [unused-private-member]\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Empty doesn't\n    specify __slots__.\n    \"\"\"\n    __slots__ = ['a']\n\n    def __init__(self):\n        self.missing = 42\n\nclass Good2:\n    \"\"\" Using __dict__ in slots will be safe. \"\"\"\n\n    __slots__ = ['__dict__', 'comp']\n\n    def __init__(self):\n        self.comp = 4\n        self.missing = 5\n\nclass PropertyGood:\n    \"\"\" Using properties is safe. \"\"\"\n\n    __slots__ = ['tmp', '_value']\n\n    @property\n    def test(self):\n        return self._value\n\n    @test.setter\n    def test(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    def __init__(self):\n        self.test = 42\n\nclass PropertyGood2:\n    \"\"\" Using properties in the body of the class is safe. \"\"\"\n    __slots__ = ['_value']\n\n    def _getter(self):\n        return self._value\n\n    def _setter(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    test = property(_getter, _setter)\n\n    def __init__(self):\n        self.test = 24\n\nclass UnicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descri"}, {"start_line": 0, "end_line": 514, "belongs_to": {"file_name": "regression_protected_access.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test for the regression on (outer)-class traversal for private methods\nMyClass does not have an outerclass which previously crashed the protected-access check\n\"\"\"\n# pylint: disable=too-few-public-methods\n\n\nclass MyClass:\n    \"\"\"Test class\"\"\"\n\n    @staticmethod\n    def _a_private_method():\n        \"\"\"Private method that references the class itself\"\"\"\n        return MySecondClass.MyClass._a_private_method()  # [protected-access]\n\n\nclass MySecondClass:\n    \"\"\"Class that uses MyClass\"\"\"\n\n    MyClass = MyClass\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    def attr_a(self):\n        \"\"\"Get a.\"\"\"\n        return self.__attr_a\n\n    @property\n    def attr_b(self):\n        \"\"\"Get b.\"\"\"\n        return self.__attr_b\n\n    # Test cases where we assign self.attr, but try to\n    # access cls.attr\n\n    def __init__(self):\n        self.__attr_c = \"this is an unused private instance attribute\"  # [unused-private-member]\n\n    @property\n    def attr_c(self):\n        \"\"\"Get c.\"\"\"\n        return cls.__attr_c  # [undefined-variable]\n\n\n# https://github.com/pylint-dev/pylint/issues/4668\n# Attributes assigned within __new__() has to be processed as part of the class\nclass FalsePositive4668:\n    # pylint: disable=protected-access, no-member, unreachable\n\n    def __new__(cls, func, *args):\n        if args:\n            true_obj = super(FalsePositive4668, cls).__new__(cls)\n            true_obj.func = func\n            true_obj.__args = args  # Do not emit message here\n            return true_obj\n\n        false_obj = super(FalsePositive4668, cls).__new__(cls)\n        false_obj.func = func\n        false_obj.__args = args  # Do not emit message here\n        false_obj.__secret_bool = False\n        false_obj.__unused = None  # [unused-private-member]\n        return false_obj\n        # unreachable but non-Name return value\n        return 3+4\n\n    def exec(self):\n        print(self.__secret_bool)\n        return self.func(*self.__args)\n\n\n# https://github.com/pylint-dev/pylint/issues/4673\n# Nested functions shouldn't cause a false positive if they are properly used\nclass FalsePositive4673:\n    \"\"\" The testing class \"\"\"\n\n    def __init__(self, in_thing):\n        self.thing = False\n        self.do_thing(in_thing)\n\n    def do_thing(self, in_thing):\n        \"\"\" Checks the false-positive condition, sets a property. \"\"\"\n        def __false_positive(in_thing):\n            print(in_thing)\n\n        def __true_positive(in_thing):  # [unused-private-member]\n            print(in_thing)\n\n        __false_positive(in_thing)\n        self.thing = True\n\n    def undo_t"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ame):\n        return False\n    if isinstance(owner, nodes.FunctionDef) and (\n        owner.decorators or owner.is_abstract()\n    ):\n        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n            pass\n        else:\n            # Renamed in Python 3.10 to `EnumType`\n            if metaclass and metaclass.qname() in {\"enum.EnumMeta\", \"enum.EnumType\"}:\n                return not _enum_has_attribute(owner, node)\n        if owner.has_dynamic_getattr():\n            return False\n        if not has_known_bases(owner):\n            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n        # Verify if we are dealing with an invalid Super object.\n        # If it is invalid, then there's no point in checking that\n        # it has the required attribute. Also, don't fail if the\n        # MRO is invalid.\n        try:\n            owner.super_mro()\n        except (astroid.MroError, astroid.SuperError):\n            return False\n        if not all(has_known_bases(base) for base in owner.type.mro()):\n            return False\n    if isinstance(owner, nodes.Module):\n        try:\n            owner.getattr(\"__getattr__\")\n            return False\n        except astroid.NotFoundError:\n            pass\n    if owner_name and node.attrname.startswith(\"_\" + owner_name):\n        # Test if an attribute has been mangled ('private' attribute)\n        unmangled_name = node.attrname.split(\"_\" + owner_name)[-1]\n        try:\n            if owner.getattr(unmangled_name, context=None) is not None:\n                return False\n        except"}], "retrieved_count": 10, "cost_time": 1.0873329639434814}
{"question": "How should a class-creating type design iteration protocol methods to separate construction logic from iteration behavior while allowing inheriting classes to override either independently?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "iterable_context.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-an-iterable]\n    pass\n\n# check for custom iterators\nclass A:\n    pass\n\nclass B:\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return 1\n\n    def next(self):\n        return 1\n\nclass C:\n    \"old-style iterator\"\n    def __getitem__(self, k):\n        if k > 10:\n            raise IndexError\n        return k + 1\n\n    def __len__(self):\n        return 10\n\nfor i in C():\n    print(i)\n\n\ndef test(*args):\n    print(args)\n\n\ntest(*A())  # [not-an-iterable]\ntest(*B())\ntest(*B)  # [not-an-iterable]\nfor i in A():  # [not-an-iterable]\n    pass\nfor i in B():\n    pass\nfor i in B:  # [not-an-iterable]\n    pass\n\nfor i in range:  # [not-an-iterable]\n    pass\n\n# check that primitive non-iterable types are caught\nfor i in True:  # [not-an-iterable]\n    pass\n\nfor i in None:  # [not-an-iterable]\n    pass\n\nfor i in 8.5:  # [not-an-iterable]\n    pass\n\nfor i in 10:  # [not-an-iterable]\n    pass\n\n# skip uninferable bases\nfrom some_missing_module import Iterable\n\nclass MyClass(Iterable):\n    pass\n\nm = MyClass()\nfor i in m:\n    print(i)\n\n# skip uninferable instances\nambiguous = range(i) or range(i)\nfor j in ambiguous:\n    print(j)\n\n# skip checks if statement is inside mixin/base/abstract class\nclass ManagedAccessViewMixin:\n    access_requirements = None\n\n    def get_access_requirements(self):\n        return self.access_requirements\n\n    def dispatch(self, *_args, **_kwargs):\n        classes = self.get_access_requirements()\n\n        # no error should be emitted here\n        for requirement in classes:\n            print(requirement)\n\nclass BaseType:\n    valid_values = None\n\n    def validate(self, value):\n        if self.valid_values is None:\n            return True\n        else:\n            # error should not be emitted here\n            for v in self.valid_values:\n                if value == v:\n                    return True\n            return False\n\nclass AbstractUrlMarkManager:\n    def __init__(self):\n        self._lineparser = None\n        self._init_lineparser()\n  "}, {"start_line": 1000, "end_line": 2360, "belongs_to": {"file_name": "non_iterator_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/non", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "turn 2\n\n\nclass IteratorClass(metaclass=IteratorMetaclass):\n    \"\"\"Iterable through the metaclass.\"\"\"\n\n\nclass FifthGoodIterator:\n    \"\"\"__iter__ returns a class which uses an iterator-metaclass.\"\"\"\n\n    def __iter__(self):\n        return IteratorClass\n\n\nclass FileBasedIterator:\n    def __init__(self, path):\n        self.path = path\n        self.file = None\n\n    def __iter__(self):\n        if self.file is not None:\n            self.file.close()\n        self.file = open(self.path, encoding=\"utf-8\")\n        # self file has two inferred values: None and <instance of 'file'>\n        # we don't want to emit error in this case\n        return self.file\n\n\nclass FirstBadIterator:\n    \"\"\" __iter__ returns a list \"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return []\n\n\nclass SecondBadIterator:\n    \"\"\" __iter__ without next \"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return self\n\n\nclass ThirdBadIterator:\n    \"\"\" __iter__ returns an instance of another non-iterator \"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return SecondBadIterator()\n\n\nclass FourthBadIterator:\n    \"\"\"__iter__ returns a class.\"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return ThirdBadIterator\n\nclass SixthGoodIterator:\n    \"\"\"__iter__ returns Uninferable.\"\"\"\n\n    def __iter__(self):\n        return UNINFERABLE\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unpacking_non_sequence.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unpacking", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass that makes classes that use it iterables\"\n    def __iter__(cls):\n        return iter((1, 2))\n\nclass IterClass(metaclass=MetaIter):\n    \"class that is iterable (and unpackable)\"\n\nclass AbstrClass:\n    \"abstract class\"\n    pair = None\n\n    def setup_pair(self):\n        \"abstract method\"\n        raise NotImplementedError\n\n    def __init__(self):\n        \"error should not be emitted because setup_pair is abstract\"\n        self.setup_pair()\n        x, y = self.pair\n\na, b = [1, 2]\na, b = (1, 2)\na, b = set([1, 2])\na, b = {1: 2, 2: 3}\na, b = \"xy\"\na, b = Seq()\na, b = Iter()\na, b = (number for number in range(2))\na, b = good_unpacking()\na, b = good_unpacking2()\na, b = IterClass\n\n# Not working\nclass NonSeq:\n    \"\"\" does nothing \"\"\"\n\na, b = NonSeq() # [unpacking-non-sequence]\na, b = ValueError # [unpacking-non-sequence]\na, b = None # [unpacking-non-sequence]\na, b = 1 # [unpacking-non-sequence]\na, b = nonseq # [unpacking-non-sequence]\na, b = nonseq() # [unpacking-non-sequence]\na, b = nonseq_func # [unpacking-non-sequence]\n\nclass ClassUnpacking:\n    \"\"\" Check unpacking as instance attributes. \"\"\"\n\n    def test(self):\n        \"\"\" test unpacking in instance attributes. \"\"\"\n\n        self.a, self.b = 1, 2\n        self.a, self.b = {1: 2, 2: 3}\n        self.a, self.b = \"xy\"\n        self.a, c = \"xy\"\n        c, self.a = good_unpacking()\n        self.a, self.b = Iter()\n\n        self.a, self.b = NonSeq() # [unpacking-non-sequence]\n        self.a, self.b = ValueError # [unpacking-non-sequence]\n        self.a, c = nonseq_func # [unpacking-non-sequence]\n\nclass TestBase:\n    'base class with `test` method implementation'\n    @staticmethod\n    def test(data):\n        'default implementation'\n        return data\n\nclass Test(TestBase):\n    'child class that overrides `test` method'\n    def __init__(self):\n        # no error should be emitted here as `test` is overridden in this class\n        (self.aaa, self.bbb, self.ccc) = self.test(None)\n\n    @staticmethod\n    def test(data):\n        'overr"}, {"start_line": 1000, "end_line": 2294, "belongs_to": {"file_name": "abstract_method.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " explicit metaclass.\n    \"\"\"\n\n\nclass Concrete(Abstract): # [abstract-method]\n    \"\"\"Concrete class\"\"\"\n\n    def aaaa(self):\n        \"\"\"overridden form Abstract\"\"\"\n\n\nclass Structure(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __iter__(self):\n        pass\n    @abc.abstractmethod\n    def __len__(self):\n        pass\n    @abc.abstractmethod\n    def __contains__(self, _):\n        pass\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Container(Structure):\n    def __contains__(self, _):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Sizable(Structure):\n    def __len__(self):\n        return 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Hashable(Structure):\n    __hash__ = 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Iterator(Structure):\n    def keys(self):\n        return iter([1, 2, 3])\n\n    __iter__ = keys\n\n\nclass AbstractSizable(Structure):\n    @abc.abstractmethod\n    def length(self):\n        pass\n    __len__ = length\n\n\nclass GoodComplexMRO(Container, Iterator, Sizable, Hashable):\n    pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass BadComplexMro(Container, Iterator, AbstractSizable):\n    pass\n"}, {"start_line": 0, "end_line": 440, "belongs_to": {"file_name": "iterable_context_py3.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nChecks that iterable metaclasses are recognized by pylint.\n\"\"\"\n# pylint: disable=missing-docstring,too-few-public-methods,unused-argument,bad-mcs-method-argument\n# pylint: disable=wrong-import-position\n# metaclasses as iterables\nclass Meta(type):\n    def __iter__(self):\n        return iter((1, 2, 3))\n\nclass SomeClass(metaclass=Meta):\n    pass\n\n\nfor i in SomeClass:\n    print(i)\nfor i in SomeClass():  # [not-an-iterable]\n    print(i)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "non_iterator_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/non", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check non-iterators returned by __iter__ \"\"\"\n\n# pylint: disable=too-few-public-methods, missing-docstring, consider-using-with, import-error, use-yield-from\nfrom uninferable import UNINFERABLE\n\nclass FirstGoodIterator:\n    \"\"\" yields in iterator. \"\"\"\n\n    def __iter__(self):\n        for index in range(10):\n            yield index\n\n\nclass SecondGoodIterator:\n    \"\"\" __iter__ and next \"\"\"\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        \"\"\" Infinite iterator, but still an iterator \"\"\"\n        return 1\n\n    def next(self):\n        \"\"\"Same as __next__, but for Python 2.\"\"\"\n        return 1\n\n\nclass ThirdGoodIterator:\n    \"\"\" Returns other iterator, not the current instance \"\"\"\n\n    def __iter__(self):\n        return SecondGoodIterator()\n\n\nclass FourthGoodIterator:\n    \"\"\" __iter__ returns iter(...) \"\"\"\n\n    def __iter__(self):\n        return iter(range(10))\n\n\nclass IteratorMetaclass(type):\n    def __next__(cls):\n        return 1\n\n    def next(cls):\n        return 2\n\n\nclass IteratorClass(metaclass=IteratorMetaclass):\n    \"\"\"Iterable through the metaclass.\"\"\"\n\n\nclass FifthGoodIterator:\n    \"\"\"__iter__ returns a class which uses an iterator-metaclass.\"\"\"\n\n    def __iter__(self):\n        return IteratorClass\n\n\nclass FileBasedIterator:\n    def __init__(self, path):\n        self.path = path\n        self.file = None\n\n    def __iter__(self):\n        if self.file is not None:\n            self.file.close()\n        self.file = open(self.path, encoding=\"utf-8\")\n        # self file has two inferred values: None and <instance of 'file'>\n        # we don't want to emit error in this case\n        return self.file\n\n\nclass FirstBadIterator:\n    \"\"\" __iter__ returns a list \"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return []\n\n\nclass SecondBadIterator:\n    \"\"\" __iter__ without next \"\"\"\n\n    def __iter__(self):  # [non-iterator-returned]\n        return self\n\n\nclass ThirdBadIterator:\n    \"\"\" __iter__ returns an instance of another non-itera"}, {"start_line": 2000, "end_line": 3848, "belongs_to": {"file_name": "iterable_context.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n    pass\n\nm = MyClass()\nfor i in m:\n    print(i)\n\n# skip uninferable instances\nambiguous = range(i) or range(i)\nfor j in ambiguous:\n    print(j)\n\n# skip checks if statement is inside mixin/base/abstract class\nclass ManagedAccessViewMixin:\n    access_requirements = None\n\n    def get_access_requirements(self):\n        return self.access_requirements\n\n    def dispatch(self, *_args, **_kwargs):\n        classes = self.get_access_requirements()\n\n        # no error should be emitted here\n        for requirement in classes:\n            print(requirement)\n\nclass BaseType:\n    valid_values = None\n\n    def validate(self, value):\n        if self.valid_values is None:\n            return True\n        else:\n            # error should not be emitted here\n            for v in self.valid_values:\n                if value == v:\n                    return True\n            return False\n\nclass AbstractUrlMarkManager:\n    def __init__(self):\n        self._lineparser = None\n        self._init_lineparser()\n        # error should not be emitted here\n        for line in self._lineparser:\n            print(line)\n\n    def _init_lineparser(self):\n        raise NotImplementedError\n\n# class is not named as abstract\n# but still is deduceably abstract\nclass UrlMarkManager:\n    def __init__(self):\n        self._lineparser = None\n        self._init_lineparser()\n        # error should not be emitted here\n        for line in self._lineparser:\n            print(line)\n\n    def _init_lineparser(self):\n        raise NotImplementedError\n\n\nclass HasDynamicGetattr:\n\n    def __init__(self):\n        self._obj = []\n\n    def __getattr__(self, attr):\n        return getattr(self._obj, attr)\n\n\nfor elem in HasDynamicGetattr():\n    pass\n\n\n# Regression test for https://github.com/pylint-dev/pylint/issues/6372\nstring_twos = \"\".join(str(*y) for _, *y in [[1, 2], [1, 2]])\n"}, {"start_line": 0, "end_line": 819, "belongs_to": {"file_name": "regression_properties_in_class_context.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods\n\nclass Meta(type):\n    @property\n    def values(cls):\n        return ['foo', 'bar']\n\n\nclass Parent(metaclass=Meta):\n    pass\n\n\nassert 'foo' in Parent.values  # no warning\nfor value in Parent.values:  # no warning\n    print(value)\n\n\nclass Child(Parent):\n    pass\n\n\nassert 'foo' in Child.values  # false-positive: unsupported-membership-test\nfor value in Child.values:  # false-positive: not-an-iterable\n    print(value)\n\n\nclass Meta2(type):\n    def a_method(cls):\n        return [123]\n\n\nclass Parent2(metaclass=Meta2):\n    @property\n    def a_method(self):\n        return \"actually a property\"\n\n\nclass Child2(Parent2):\n    pass\n\n\nassert 123 in Child2.a_method  # [unsupported-membership-test]\nfor value in Child2.a_method:  # [not-an-iterable]\n    print(value)\n"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "value, AITER_METHOD)\n\n\ndef _supports_getitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, GETITEM_METHOD)\n\n\ndef _supports_setitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, SETITEM_METHOD)\n\n\ndef _supports_delitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, DELITEM_METHOD)\n\n\ndef _is_abstract_class_name(name: str) -> bool:\n    lname = name.lower()\n    is_mixin = lname.endswith(\"mixin\")\n    is_abstract = lname.startswith(\"abstract\")\n    is_base = lname.startswith(\"base\") or lname.endswith(\"base\")\n    return is_mixin or is_abstract or is_base\n\n\ndef is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False\n\n\ndef _supports_protocol(\n    value: nodes.NodeNG, protocol_callback: Callable[[nodes.NodeNG], bool]\n) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if not has_known_bases(value):\n            return True\n        # classobj can only be iterable if it has an iterable metaclass\n        meta = value.metaclass()\n        if meta is not None:\n            if protocol_callback(meta):\n                return True\n    if isinstance(value, astroid.BaseInstance):\n        if not has_known_bases(value):\n            return True\n        if value.has_dynamic_getattr():\n            return True\n        if protocol_callback(value):\n            return True\n\n    if isinstance(value, nodes.ComprehensionScope):\n        return True\n\n    if (\n        isinstance(value, astroid.bases.Proxy)\n        and isinstance(value._proxied, astroid.BaseInstance)\n        and has_known_bases(value._proxied)\n    ):\n        value = value._proxied\n        return protocol"}, {"start_line": 0, "end_line": 546, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/n/non-iterator-returned", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import random\n\n\nclass GenericAstrology:\n    def __init__(self, signs, predictions):\n        self.signs = signs\n        self.predictions = predictions\n\n    def __iter__(self):  # [non-iterator-returned]\n        self.index = 0\n        self.number_of_prediction = len(self.predictions)\n        return self\n\n\nSIGNS = [\"Aries\", \"Taurus\", \"Gemini\", \"Cancer\", \"Leo\", \"Virgo\", \"Libra\"]\nPREDICTIONS = [\"good things\", \"bad thing\", \"existential dread\"]\nfor sign, prediction in GenericAstrology(SIGNS, PREDICTIONS):\n    print(f\"{sign} : {prediction} today\")\n"}], "retrieved_count": 10, "cost_time": 1.092115879058838}
{"question": "Why does the current implementation of the method that checks class subscriptability for generic type annotations cause performance overhead when the same class is checked repeatedly during static analysis?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 395, "belongs_to": {"file_name": "unsubscriptable_value_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-class-docstring,too-few-public-methods,pointless-statement,expression-not-assigned\n\"\"\"\nChecks that class used in a subscript supports subscription\n(i.e. defines __class_getitem__ method).\n\"\"\"\nimport typing\n\n\nclass Subscriptable:\n\n    def __class_getitem__(cls, params):\n        pass\n\nSubscriptable[0]\nSubscriptable()[0]  # [unsubscriptable-object]\n\na: typing.List[int]\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       end_col_offset=18,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def typing_objects_are_subscriptable(self, generic: str) -> None:\n        module = astroid.parse(\n            f\"\"\"\n        import typing\n        test = typing.{generic}[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_subscriptable_then_unsubscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Unsubscriptable\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=18,\n                col_offset=7,\n                end_line=18,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_unsubscriptable_then_subscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.as"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Final\", \"Literal\":\n            self.typing_objects_are_subscriptable(generic)\n\n        self.getitem_on_modules()\n        self.decorated_by_a_subscriptable_class(decorators)\n        self.decorated_by_an_unsubscriptable_class(decorators)\n\n        self.decorated_by_subscriptable_then_unsubscriptable_class(decorators)\n        self.decorated_by_unsubscriptable_then_subscriptable_class(decorators)\n\n    def getitem_on_modules(self) -> None:\n        \"\"\"Mainly validate the code won't crash if we're not having a function.\"\"\"\n        module = astroid.parse(\n            \"\"\"\n        import collections\n        test = collections[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"collections\",\n                confidence=UNDEFINED,\n                line=3,\n                col_offset=7,\n                end_line=3,\n                end_col_offset=18,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def typing_objects_are_subscriptable(self, generic: str) -> None:\n        module = astroid.parse(\n            f\"\"\"\n        import typing\n        test = typing.{generic}[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_subscriptable_then_unsubscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n "}, {"start_line": 0, "end_line": 1240, "belongs_to": {"file_name": "generic_alias_related_py39.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/g/generic_alias", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test related function for generic alias.\n\nAny solution should not change the behavior of\n- `__getitem__`\n- `__class_getitem__`\n- `metaclass=ABCMeta`\n\"\"\"\n# flake8: noqa\n# pylint: disable=missing-docstring,pointless-statement,expression-not-assigned\n# pylint: disable=too-few-public-methods,multiple-statements,line-too-long\nfrom abc import ABCMeta, abstractmethod\nimport typing\n\nGenericAlias = type(list[int])\n\n\nclass ClsUnsubscriptable:\n    def __init__(self):\n        pass\n\nclass ClsGetItem:\n    def __init__(self):\n        self.var = [1, 2, 3, 4]\n    def __getitem__(self, item):\n        return self.var[item]\n\nclass ClsClassGetItem:\n    def __init__(self):\n        pass\n    __class_getitem__ = classmethod(GenericAlias)\n\nclass ClsList(typing.List):\n    pass\n\n\nClsUnsubscriptable()[1]  # [unsubscriptable-object]\nClsUnsubscriptable[int]  # [unsubscriptable-object]\n\nClsGetItem()[1]\nClsGetItem[int]  # [unsubscriptable-object]\n\nClsClassGetItem()[1]  # [unsubscriptable-object]\nClsClassGetItem[int]\n\n# subscriptable because of inheritance\nClsList([0, 1, 2])[1]\nClsList[int]\n\n\nclass ClsAbstract(metaclass=ABCMeta):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass Derived(ClsAbstract):  # [abstract-method]\n    pass\n"}, {"start_line": 0, "end_line": 1233, "belongs_to": {"file_name": "generic_alias_related.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/g/generic_alias", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test related function for generic alias.\n\nAny solution should not change the behavior of\n- `__getitem__`\n- `__class_getitem__`\n- `metaclass=ABCMeta`\n\"\"\"\n# flake8: noqa\n# pylint: disable=missing-docstring,pointless-statement,expression-not-assigned\n# pylint: disable=too-few-public-methods,multiple-statements,line-too-long, unnecessary-lambda-assignment\nfrom abc import ABCMeta, abstractmethod\nimport typing\n\n\nclass ClsUnsubscriptable:\n    def __init__(self):\n        pass\n\nclass ClsGetItem:\n    def __init__(self):\n        self.var = [1, 2, 3, 4]\n    def __getitem__(self, item):\n        return self.var[item]\n\nclass ClsClassGetItem:\n    def __init__(self):\n        pass\n    __class_getitem__ = lambda cls, x: None\n\nclass ClsList(typing.List):\n    pass\n\n\nClsUnsubscriptable()[1]  # [unsubscriptable-object]\nClsUnsubscriptable[int]  # [unsubscriptable-object]\n\nClsGetItem()[1]\nClsGetItem[int]  # [unsubscriptable-object]\n\nClsClassGetItem()[1]  # [unsubscriptable-object]\nClsClassGetItem[int]\n\n# subscriptable because of inheritance\nClsList([0, 1, 2])[1]\nClsList[int]\n\n\nclass ClsAbstract(metaclass=ABCMeta):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass Derived(ClsAbstract):  # [abstract-method]\n    pass\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unsubscriptable_value.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nChecks that value used in a subscript supports subscription\n(i.e. defines __getitem__ method).\n\"\"\"\n# pylint: disable=missing-docstring,pointless-statement,expression-not-assigned,wrong-import-position, unnecessary-comprehension\n# pylint: disable=too-few-public-methods,import-error,invalid-name,wrong-import-order, redundant-u-string-prefix\n# pylint: disable=use-dict-literal\n\n# primitives\nnumbers = [1, 2, 3]\nnumbers[0]\n\"123\"[0]\nu\"123\"[0]\nb\"123\"[0]\nbytearray(b\"123\")[0]\ndict(a=1, b=2)['a']\n(1, 2, 3)[0]\n\n# list/dict comprehensions are fine\n[x for x in range(10)][0]\n{x: 10 - x for x in range(10)}[0]\n\n\n# instances\nclass NonSubscriptable:\n    pass\n\nclass Subscriptable:\n    def __getitem__(self, key):\n        return key + key\n\nNonSubscriptable()[0]  # [unsubscriptable-object]\nNonSubscriptable[0]  # [unsubscriptable-object]\nSubscriptable()[0]\nSubscriptable[0]  # [unsubscriptable-object]\n\n# generators are not subscriptable\ndef powers_of_two():\n    k = 0\n    while k < 10:\n        yield 2 ** k\n        k += 1\n\npowers_of_two()[0]  # [unsubscriptable-object]\npowers_of_two[0]  # [unsubscriptable-object]\n\n\n# check that primitive non subscriptable types are caught\nTrue[0]  # [unsubscriptable-object]\nNone[0]  # [unsubscriptable-object]\n8.5[0]  # [unsubscriptable-object]\n10[0]  # [unsubscriptable-object]\n\n# sets are not subscriptable\n{x ** 2 for x in range(10)}[0]  # [unsubscriptable-object]\nset(numbers)[0]  # [unsubscriptable-object]\nfrozenset(numbers)[0]  # [unsubscriptable-object]\n\n# skip instances with unknown base classes\nfrom some_missing_module import LibSubscriptable\n\nclass MaybeSubscriptable(LibSubscriptable):\n    pass\n\nMaybeSubscriptable()[0]\n\n# subscriptable classes (through metaclasses)\n\nclass MetaSubscriptable(type):\n    def __getitem__(cls, key):\n        return key + key\n\nclass SubscriptableClass(metaclass=MetaSubscriptable):\n    pass\n\nSubscriptableClass[0]\nSubscriptableClass()[0]  # [unsubscriptable-object]\n\n# functions are not subscriptable\ndef test(*args, **kwargs):"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r.CTracer  #@\n        \"\"\"\n        )\n        message = MessageTest(\n            \"c-extension-no-member\",\n            node=node,\n            args=(\"Module\", \"coverage.tracer\", \"CTracer\", \"\"),\n            confidence=INFERENCE,\n            line=3,\n            col_offset=0,\n            end_line=3,\n            end_col_offset=14,\n        )\n        with self.assertAddsMessages(message):\n            self.checker.visit_attribute(node)\n\n\nclass TestTypeCheckerOnDecorators(CheckerTestCase):\n    \"\"\"Tests for pylint.checkers.typecheck on decorated functions.\"\"\"\n\n    CHECKER_CLASS = typecheck.TypeChecker\n\n    def test_issue3882_class_decorators(self) -> None:\n        decorators = \"\"\"\n        class Unsubscriptable:\n            def __init__(self, f):\n                self.f = f\n\n        class Subscriptable:\n            def __init__(self, f):\n                self.f = f\n\n            def __getitem__(self, item):\n                return item\n        \"\"\"\n        for generic in \"Optional\", \"List\", \"ClassVar\", \"Final\", \"Literal\":\n            self.typing_objects_are_subscriptable(generic)\n\n        self.getitem_on_modules()\n        self.decorated_by_a_subscriptable_class(decorators)\n        self.decorated_by_an_unsubscriptable_class(decorators)\n\n        self.decorated_by_subscriptable_then_unsubscriptable_class(decorators)\n        self.decorated_by_unsubscriptable_then_subscriptable_class(decorators)\n\n    def getitem_on_modules(self) -> None:\n        \"\"\"Mainly validate the code won't crash if we're not having a function.\"\"\"\n        module = astroid.parse(\n            \"\"\"\n        import collections\n        test = collections[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"collections\",\n                confidence=UNDEFINED,\n                line=3,\n                col_offset=7,\n                end_line=3,\n         "}, {"start_line": 1000, "end_line": 2913, "belongs_to": {"file_name": "unsubscriptable_value.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        k += 1\n\npowers_of_two()[0]  # [unsubscriptable-object]\npowers_of_two[0]  # [unsubscriptable-object]\n\n\n# check that primitive non subscriptable types are caught\nTrue[0]  # [unsubscriptable-object]\nNone[0]  # [unsubscriptable-object]\n8.5[0]  # [unsubscriptable-object]\n10[0]  # [unsubscriptable-object]\n\n# sets are not subscriptable\n{x ** 2 for x in range(10)}[0]  # [unsubscriptable-object]\nset(numbers)[0]  # [unsubscriptable-object]\nfrozenset(numbers)[0]  # [unsubscriptable-object]\n\n# skip instances with unknown base classes\nfrom some_missing_module import LibSubscriptable\n\nclass MaybeSubscriptable(LibSubscriptable):\n    pass\n\nMaybeSubscriptable()[0]\n\n# subscriptable classes (through metaclasses)\n\nclass MetaSubscriptable(type):\n    def __getitem__(cls, key):\n        return key + key\n\nclass SubscriptableClass(metaclass=MetaSubscriptable):\n    pass\n\nSubscriptableClass[0]\nSubscriptableClass()[0]  # [unsubscriptable-object]\n\n# functions are not subscriptable\ndef test(*args, **kwargs):\n    return args, kwargs\n\ntest()[0]\ntest[0]  # [unsubscriptable-object]\n\n# deque\nfrom collections import deque\ndeq = deque(maxlen=10)\ndeq.append(42)\ndeq[0]\n\n\nclass AbstractClass:\n\n    def __init__(self):\n        self.ala = {i for i in range(10)}\n        self.bala = [i for i in range(10)]\n        self.portocala = None\n\n    def test_unsubscriptable(self):\n        self.bala[0]\n        self.portocala[0]\n\n\nclass ClassMixin:\n\n    def __init__(self):\n        self.ala = {i for i in range(10)}\n        self.bala = [i for i in range(10)]\n        self.portocala = None\n\n    def test_unsubscriptable(self):\n        self.bala[0]\n        self.portocala[0]\n\n\ndef return_an_int(param):\n    \"\"\"Returns an int\"\"\"\n    if param == 0:\n        return 1\n    return 0\n\n\ndef test_one(param):\n    \"\"\"Should complain about var_one[0], but doesn't\"\"\"\n    var_one = return_an_int(param)\n    return var_one[0]  # [unsubscriptable-object]\n"}, {"start_line": 65000, "end_line": 67000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "If the types can be determined, only allow indices to be int,\n        # slice or instances with __index__.\n        parent_type = safe_infer(subscript.value)\n        if not isinstance(\n            parent_type, (nodes.ClassDef, astroid.Instance)\n        ) or not has_known_bases(parent_type):\n            return None\n\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n        elif subscript.ctx is astroid.Context.Del:\n            methodname = \"__delitem__\"\n        else:\n            methodname = \"__getitem__\"\n\n        # Check if this instance's __getitem__, __setitem__, or __delitem__, as\n        # appropriate to the statement, is implemented in a builtin sequence\n        # type. This way we catch subclasses of sequence types but skip classes\n        # that override __getitem__ and which may allow non-integer indices.\n        try:\n            methods = astroid.interpreter.dunder_lookup.lookup(parent_type, methodname)\n            if isinstance(methods, util.UninferableBase):\n                return None\n            itemmethod = methods[0]\n        except (\n            astroid.AttributeInferenceError,\n            IndexError,\n        ):\n            return None\n        if (\n            not isinstance(itemmethod, nodes.FunctionDef)\n            or itemmethod.root().name != \"builtins\"\n            or not itemmethod.parent\n            or itemmethod.parent.frame().name not in SEQUENCE_TYPES\n        ):\n            return None\n\n        index_type = safe_infer(subscript.slice)\n        if index_type is None or isinstance(index_type, util.UninferableBase):\n            return None\n        # Constants must be of type int\n        if isinstance(index_type, nodes.Const):\n            if isinstance(index_type.value, int):\n               "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           + \"\"\"\n        @Unsubscriptable\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=18,\n                col_offset=7,\n                end_line=18,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_unsubscriptable_then_subscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_an_unsubscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=17,\n                col_offset=7,\n                end_line=17,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n\nclass TestTypeCheckerStringDistance:\n    \"\"\"Tests for the _string_distance helper in pylint.checkers.typecheck.\"\"\"\n\n    def test_string_distance_identical_strings(self) -> None:\n        seq1 = \"hi\"\n     "}], "retrieved_count": 10, "cost_time": 1.093160629272461}
{"question": "How would you refactor the configuration option value formatter to implement parameter validation and type checking while maintaining backward compatibility with existing callers that pass arbitrary object types?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "se \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n    return str(value)\n\n\ndef format_section(\n    stream: TextIO,\n    section: str,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> None:\n    \"\"\"Format an option's section using the INI format.\"\"\"\n    warnings.warn(\n        \"format_section has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if doc:\n        print(_comment(doc), file=stream)\n    print(f\"[{section}]\", file=stream)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        _ini_format(stream, options)\n\n\ndef _ini_format(stream: TextIO, options: list[tuple[str, OptionDict, Any]]) -> None:\n    \"\"\"Format options using the INI format.\"\"\"\n    warnings.warn(\n        \"_ini_format has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    for optname, optdict, value in options:\n        # Skip deprecated option\n        if \"kwargs\" in optdict:\n            assert isinstance(optdict[\"kwargs\"], dict)\n            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n            print(file=stream)\n            print(help_opt, file=stream)\n        else:\n            print(file=stream)\n        if value in {\"None\", \"False\"}:\n            print(f\"#{optname}=\", file=stream)\n        else:\n            value = str(value).strip()\n            if re.match(r\"^([\\w-]+,)+[\\w-]+$\", str(value)):\n                separator = \"\\n \" + \" \" * len(optname)\n                value = separator.join(x + \",\" for x in str(value).split(\",\"))\n                # remove trailing ',' from last element of the list\n                value = val"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       yield from (\"\".join(regexp).strip() for regexp in regexps if regexp is not None)\n\n\ndef _comment(string: str) -> str:\n    \"\"\"Return string as a comment.\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    sep = \"\\n\"\n    return \"# \" + f\"{sep}# \".join(lines)\n\n\ndef _format_option_value(optdict: OptionDict, value: Any) -> str:\n    \"\"\"Return the user input's value from a 'compiled' value.\n\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value else \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n    return str(value)\n\n\ndef format_section(\n    stream: TextIO,\n    section: str,\n    options: list[tuple[str, OptionDict, Any]],\n    doc: str | None = None,\n) -> None:\n    \"\"\"Format an option's section using the INI format.\"\"\"\n    warnings.warn(\n        \"format_section has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if doc:\n        print(_comment(doc), file=stream)\n    print(f\"[{section}]\", file=stream)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        _ini_format(stream, options)\n\n\ndef _ini_format(stream: TextIO, options: list[tuple[str, OptionDict, Any]]) -> None:\n    \"\"\"Format options using the INI format.\"\"\"\n    warnings.warn(\n        \"_ini_format has been deprecated. It will be removed in pylint 4.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n  "}, {"start_line": 13000, "end_line": 14798, "belongs_to": {"file_name": "arguments_manager.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "               group_table.add(tomlkit.comment(f\"{optname} =\"))\n                        group_table.add(tomlkit.nl())\n                    continue\n\n                # Skip deprecated options\n                if \"kwargs\" in optdict:\n                    assert isinstance(optdict[\"kwargs\"], dict)\n                    if \"new_names\" in optdict[\"kwargs\"]:\n                        continue\n\n                # Tomlkit doesn't support regular expressions\n                if isinstance(value, re.Pattern):\n                    value = value.pattern\n                elif isinstance(value, (list, tuple)) and isinstance(\n                    value[0], re.Pattern\n                ):\n                    value = [i.pattern for i in value]\n\n                # Handle tuples that should be strings\n                if optdict.get(\"type\") == \"py_version\":\n                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n                if minimal and value == optdict.get(\"default\"):\n                    continue\n\n                # Add to table\n                group_table.add(optname, value)\n                group_table.add(tomlkit.nl())\n\n            assert group.title\n            if group_table:\n                pylint_tool_table.add(group.title.lower(), group_table)\n\n        toml_string = tomlkit.dumps(toml_doc)\n\n        # Make sure the string we produce is valid toml and can be parsed\n        tomllib.loads(toml_string)\n\n        return str(toml_string)\n\n    def set_option(self, optname: str, value: Any) -> None:\n        \"\"\"Set an option on the namespace object.\"\"\"\n        self.config = self._arg_parser.parse_known_args(\n            [f\"--{optname.replace('_', '-')}\", _parse_rich_type_value(value)],\n            self.config,\n        )[0]\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t[str] | tuple[str] | str) -> Sequence[str]:\n    if isinstance(value, (list, tuple)):\n        return value\n    return _splitstrip(value)\n\n\ndef _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n    r\"\"\"Split a comma-separated list of regexps, taking care to avoid splitting\n    a regex employing a comma as quantifier, as in `\\d{1,2}`.\n    \"\"\"\n    if isinstance(value, (list, tuple)):\n        yield from value\n    else:\n        # None is a sentinel value here\n        regexps: deque[deque[str] | None] = deque([None])\n        open_braces = False\n        for char in value:\n            if char == \"{\":\n                open_braces = True\n            elif char == \"}\" and open_braces:\n                open_braces = False\n\n            if char == \",\" and not open_braces:\n                regexps.append(None)\n            elif regexps[-1] is None:\n                regexps.pop()\n                regexps.append(deque([char]))\n            else:\n                regexps[-1].append(char)\n        yield from (\"\".join(regexp).strip() for regexp in regexps if regexp is not None)\n\n\ndef _comment(string: str) -> str:\n    \"\"\"Return string as a comment.\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    sep = \"\\n\"\n    return \"# \" + f\"{sep}# \".join(lines)\n\n\ndef _format_option_value(optdict: OptionDict, value: Any) -> str:\n    \"\"\"Return the user input's value from a 'compiled' value.\n\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value el"}, {"start_line": 1000, "end_line": 2392, "belongs_to": {"file_name": "arguments_provider.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ded.\"\"\"\n\n        self._arguments_manager._register_options_provider(self)\n\n    def _option_value(self, opt: str) -> Any:\n        \"\"\"Get the current value for the given option.\"\"\"\n        return getattr(self._arguments_manager.config, opt.replace(\"-\", \"_\"), None)\n\n    def _options_by_section(\n        self,\n    ) -> Iterator[\n        tuple[str, list[tuple[str, OptionDict, Any]]]\n        | tuple[None, dict[str, list[tuple[str, OptionDict, Any]]]]\n    ]:\n        \"\"\"Return an iterator on options grouped by section.\n\n        (section, [list of (optname, optdict, optvalue)])\n        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n            yield None, sections.pop(None)  # type: ignore[call-overload]\n        for section, options in sorted(sections.items()):\n            yield section.upper(), options\n\n    def _options_and_values(\n        self, options: Options | None = None\n    ) -> Iterator[tuple[str, OptionDict, Any]]:\n        \"\"\"DEPRECATED.\"\"\"\n        if options is None:\n            options = self.options\n        for optname, optdict in options:\n            yield optname, optdict, self._option_value(optname)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " handles InvalidUserInput exceptions and retries.\"\"\"\n\n    def inner_function(*args: _P.args, **kwargs: _P.kwargs) -> _ReturnValueT:\n        called_once = False\n        while True:\n            try:\n                return func(*args, **kwargs)\n            except InvalidUserInput as exc:\n                if called_once and exc.input == \"exit()\":\n                    print(\"Stopping 'pylint-config'.\")\n                    sys.exit()\n                print(f\"Answer should be one of {exc.valid}.\")\n                print(\"Type 'exit()' if you want to exit the program.\")\n                called_once = True\n\n    return inner_function\n\n\n@should_retry_after_invalid_input\ndef get_and_validate_format() -> Literal[\"toml\", \"ini\"]:\n    \"\"\"Make sure that the output format is either .toml or .ini.\"\"\"\n    # pylint: disable-next=bad-builtin\n    format_type = input(\n        \"Please choose the format of configuration, (T)oml or (I)ni (.cfg): \"\n    ).lower()\n\n    if format_type not in SUPPORTED_FORMATS:\n        raise InvalidUserInput(\", \".join(sorted(SUPPORTED_FORMATS)), format_type)\n\n    if format_type.startswith(\"t\"):\n        return \"toml\"\n    return \"ini\"\n\n\n@should_retry_after_invalid_input\ndef validate_yes_no(question: str, default: Literal[\"yes\", \"no\"] | None) -> bool:\n    \"\"\"Validate that a yes or no answer is correct.\"\"\"\n    question = f\"{question} (y)es or (n)o \"\n    if default:\n        question += f\" (default={default}) \"\n    # pylint: disable-next=bad-builtin\n    answer = input(question).lower()\n\n    if not answer and default:\n        answer = default\n\n    if answer not in YES_NO_ANSWERS:\n        raise InvalidUserInput(\", \".join(sorted(YES_NO_ANSWERS)), answer)\n\n    return answer.startswith(\"y\")\n\n\ndef get_minimal_setting() -> bool:\n    \"\"\"Ask the user if they want to use the minimal setting.\"\"\"\n    return validate_yes_no(\n        \"Do you want a minimal configuration without comments or default values?\", \"no\"\n    )\n\n\ndef get_and_validate_output_file() -> tuple[bool, Path]:\n    \"\"\"Make "}, {"start_line": 2000, "end_line": 3558, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ise InvalidUserInput(\", \".join(sorted(SUPPORTED_FORMATS)), format_type)\n\n    if format_type.startswith(\"t\"):\n        return \"toml\"\n    return \"ini\"\n\n\n@should_retry_after_invalid_input\ndef validate_yes_no(question: str, default: Literal[\"yes\", \"no\"] | None) -> bool:\n    \"\"\"Validate that a yes or no answer is correct.\"\"\"\n    question = f\"{question} (y)es or (n)o \"\n    if default:\n        question += f\" (default={default}) \"\n    # pylint: disable-next=bad-builtin\n    answer = input(question).lower()\n\n    if not answer and default:\n        answer = default\n\n    if answer not in YES_NO_ANSWERS:\n        raise InvalidUserInput(\", \".join(sorted(YES_NO_ANSWERS)), answer)\n\n    return answer.startswith(\"y\")\n\n\ndef get_minimal_setting() -> bool:\n    \"\"\"Ask the user if they want to use the minimal setting.\"\"\"\n    return validate_yes_no(\n        \"Do you want a minimal configuration without comments or default values?\", \"no\"\n    )\n\n\ndef get_and_validate_output_file() -> tuple[bool, Path]:\n    \"\"\"Make sure that the output file is correct.\"\"\"\n    to_file = validate_yes_no(\"Do you want to write the output to a file?\", \"no\")\n\n    if not to_file:\n        return False, Path()\n\n    # pylint: disable-next=bad-builtin\n    file_name = Path(input(\"What should the file be called: \"))\n    if file_name.exists():\n        overwrite = validate_yes_no(\n            f\"{file_name} already exists. Are you sure you want to overwrite?\", \"no\"\n        )\n\n        if not overwrite:\n            return False, file_name\n        return True, file_name\n\n    return True, file_name\n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  for optname, optdict, value in options:\n        # Skip deprecated option\n        if \"kwargs\" in optdict:\n            assert isinstance(optdict[\"kwargs\"], dict)\n            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n            print(file=stream)\n            print(help_opt, file=stream)\n        else:\n            print(file=stream)\n        if value in {\"None\", \"False\"}:\n            print(f\"#{optname}=\", file=stream)\n        else:\n            value = str(value).strip()\n            if re.match(r\"^([\\w-]+,)+[\\w-]+$\", str(value)):\n                separator = \"\\n \" + \" \" * len(optname)\n                value = separator.join(x + \",\" for x in str(value).split(\",\"))\n                # remove trailing ',' from last element of the list\n                value = value[:-1]\n            print(f\"{optname}={value}\", file=stream)\n\n\nclass IsortDriver:\n    \"\"\"A wrapper around isort API that changed between versions 4 and 5.\"\"\"\n\n    def __init__(self, config: argparse.Namespace) -> None:\n        if HAS_ISORT_5:\n            self.isort5_config = isort.settings.Config(\n                # There is no typo here. EXTRA_standard_library is\n                # what most users want. The option has been named\n                # KNOWN_standard_library for ages in pylint, and we\n                # don't want to break compatibility.\n                extra_standard_library=config.known_standard_library,\n                known_third_party=config.known_third_party,\n            )\n        else:\n            # pylint: disable-next=no-member\n            self.isort4_obj = isort.SortImports(  # type: ignore[attr-defined]\n                file_contents=\"\",\n                known_standard_library=config.known_standard_library,\n                known_third_party=config.known_third_party,\n "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/config/_pylint_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Utils for the 'pylint-config' command.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Literal, ParamSpec, TypeVar\n\n_P = ParamSpec(\"_P\")\n_ReturnValueT = TypeVar(\"_ReturnValueT\", bool, str)\n\nSUPPORTED_FORMATS = {\"t\", \"toml\", \"i\", \"ini\"}\nYES_NO_ANSWERS = {\"y\", \"yes\", \"n\", \"no\"}\n\n\nclass InvalidUserInput(Exception):\n    \"\"\"Raised whenever a user input is invalid.\"\"\"\n\n    def __init__(self, valid_input: str, input_value: str, *args: object) -> None:\n        self.valid = valid_input\n        self.input = input_value\n        super().__init__(*args)\n\n\ndef should_retry_after_invalid_input(\n    func: Callable[_P, _ReturnValueT],\n) -> Callable[_P, _ReturnValueT]:\n    \"\"\"Decorator that handles InvalidUserInput exceptions and retries.\"\"\"\n\n    def inner_function(*args: _P.args, **kwargs: _P.kwargs) -> _ReturnValueT:\n        called_once = False\n        while True:\n            try:\n                return func(*args, **kwargs)\n            except InvalidUserInput as exc:\n                if called_once and exc.input == \"exit()\":\n                    print(\"Stopping 'pylint-config'.\")\n                    sys.exit()\n                print(f\"Answer should be one of {exc.valid}.\")\n                print(\"Type 'exit()' if you want to exit the program.\")\n                called_once = True\n\n    return inner_function\n\n\n@should_retry_after_invalid_input\ndef get_and_validate_format() -> Literal[\"toml\", \"ini\"]:\n    \"\"\"Make sure that the output format is either .toml or .ini.\"\"\"\n    # pylint: disable-next=bad-builtin\n    format_type = input(\n        \"Please choose the format of configuration, (T)oml or (I)ni (.cfg): \"\n    ).lower()\n\n    if format_type not in SUPPORTED_FORMATS:\n        ra"}, {"start_line": 0, "end_line": 1262, "belongs_to": {"file_name": "decorator.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport functools\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom pylint.testutils.checker_test_case import CheckerTestCase\n\n\ndef set_config(**kwargs: Any) -> Callable[[Callable[..., None]], Callable[..., None]]:\n    \"\"\"Decorator for setting an option on the linter.\n\n    Passing the args and kwargs back to the test function itself\n    allows this decorator to be used on parameterized test cases.\n    \"\"\"\n\n    def _wrapper(fun: Callable[..., None]) -> Callable[..., None]:\n        @functools.wraps(fun)\n        def _forward(\n            self: CheckerTestCase, *args: Any, **test_function_kwargs: Any\n        ) -> None:\n            \"\"\"Set option via argparse.\"\"\"\n            for key, value in kwargs.items():\n                self.linter.set_option(key, value)\n\n            # Reopen checker in case, it may be interested in configuration change\n            self.checker.open()\n\n            fun(self, *args, **test_function_kwargs)\n\n        return _forward\n\n    return _wrapper\n"}], "retrieved_count": 10, "cost_time": 1.120990514755249}
{"question": "How does a custom metaclass implementing a property affect class attribute resolution compared to standard Python class creation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 396, "belongs_to": {"file_name": "regression_property_slots_2439.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,invalid-name,too-few-public-methods\n# https://github.com/pylint-dev/pylint/issues/2439\nclass TestClass:\n    __slots__ = [\"_i\"]\n\n    def __init__(self):\n        self._i = 0\n\n    @property\n    def i(self):\n        return self._i\n\n    @i.setter\n    def i(self, v):\n        self._i = v\n\n    other = i\n\n\ninstance = TestClass()\ninstance.other = 42\nprint(instance.i)\n"}, {"start_line": 0, "end_line": 819, "belongs_to": {"file_name": "regression_properties_in_class_context.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods\n\nclass Meta(type):\n    @property\n    def values(cls):\n        return ['foo', 'bar']\n\n\nclass Parent(metaclass=Meta):\n    pass\n\n\nassert 'foo' in Parent.values  # no warning\nfor value in Parent.values:  # no warning\n    print(value)\n\n\nclass Child(Parent):\n    pass\n\n\nassert 'foo' in Child.values  # false-positive: unsupported-membership-test\nfor value in Child.values:  # false-positive: not-an-iterable\n    print(value)\n\n\nclass Meta2(type):\n    def a_method(cls):\n        return [123]\n\n\nclass Parent2(metaclass=Meta2):\n    @property\n    def a_method(self):\n        return \"actually a property\"\n\n\nclass Child2(Parent2):\n    pass\n\n\nassert 123 in Child2.a_method  # [unsupported-membership-test]\nfor value in Child2.a_method:  # [not-an-iterable]\n    print(value)\n"}, {"start_line": 0, "end_line": 66, "belongs_to": {"file_name": "good.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/b/bad-mcs-classmethod-argument", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Meta(type):\n    @classmethod\n    def foo(mcs):\n        pass\n"}, {"start_line": 0, "end_line": 441, "belongs_to": {"file_name": "regression_property_no_member_3269.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Calling a super property\"\"\"\n# pylint: disable=too-few-public-methods,invalid-name\n\nclass A:\n    \"\"\"A parent class\"\"\"\n\n    @property\n    def test(self):\n        \"\"\"A property\"\"\"\n        return \"test\"\n\n\nclass B:\n    \"\"\"A child class\"\"\"\n\n    @property\n    def test(self):\n        \"\"\"Overriding implementation of prop which calls the parent\"\"\"\n        return A.test.fget(self) + \" overridden\"\n\n\nif __name__ == \"__main__\":\n    print(B().test)\n"}, {"start_line": 0, "end_line": 745, "belongs_to": {"file_name": "regression_node_statement_two.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test to see we don't crash on this code in pandas.\nSee: https://github.com/pandas-dev/pandas/blob/main/pandas/core/indexes/period.py\nReported in https://github.com/pylint-dev/pylint/issues/5382\n\"\"\"\n# pylint: disable=missing-function-docstring, missing-class-docstring, unused-argument\n# pylint: disable=too-few-public-methods, no-method-argument, invalid-name\n\n\ndef my_decorator(*params):\n    def decorator(decorated):\n        return decorated\n\n    return decorator\n\n\nclass ClassWithProperty:\n    def f():\n        return \"string\"\n\n    f.__name__ = \"name\"\n    f.__doc__ = \"docstring\"\n\n    hour = property(f)\n\n\nclass ClassWithDecorator:\n    @my_decorator(ClassWithProperty.hour.fget)\n    def my_property(self) -> str:\n        return \"a string\"\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "not_callable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " test(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @test.setter\n    def test(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\n    @MyProperty\n    def custom(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @custom.setter\n    def custom(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\nPROP = PropertyTest()\nPROP.test(40) # [not-callable]\nPROP.custom() # [not-callable]\n\n# Safe from not-callable when using properties.\n\nclass SafeProperty:\n    @property\n    def static(self):\n        return staticmethod\n\n    @property\n    def klass(self):\n        return classmethod\n\n    @property\n    def get_lambda(self):\n        return lambda: None\n\n    @property\n    def other_function(self):\n        def function(arg):\n            return arg\n        return function\n\n    @property\n    def dict_builtin(self):\n        return dict\n\n    @property\n    def range_builtin(self):\n        return range\n\n    @property\n    def instance(self):\n        class Empty:\n            def __call__(self):\n                return 42\n        return Empty()\n\n    @property\n    def does_not_make_sense(self):\n        raise NotImplementedError\n\nPROP1 = SafeProperty()\nPROP1.static(2)\nPROP1.klass(2)\nPROP1.get_lambda()\nPROP1.other_function(4)\nPROP1.dict_builtin()\nPROP1.range_builtin(4)\nPROP1.instance()\nPROP1.does_not_make_sense()\n\n\nimport missing  # pylint: disable=import-error\n\n\nclass UnknownBaseCallable(missing.Blah):\n    pass\n\nUnknownBaseCallable()()\n\n# Regression test for #4426\n# If property is inferable we shouldn't double emit the message\n# See: https://github.com/pylint-dev/pylint/issues/4426\nclass ClassWithProperty:\n    @property\n    def value(self):\n        return 42\n\nCLASS_WITH_PROP = ClassWithProperty().value()  # [not-callable]\n\n# Test typing.Namedtuple is callable\n# See: https://github.com/pylint-dev/pylint/issues/1295\nimport typing\n\nNamed = typing.NamedTuple(\"Named\", [(\"foo\", int), (\"bar\", int)])\nNAMED = Named("}, {"start_line": 0, "end_line": 393, "belongs_to": {"file_name": "regression_property_no_member_844.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods,invalid-overridden-method\n# https://github.com/pylint-dev/pylint/issues/844\nclass Parent:\n    def __init__(self):\n        self.__thing = 'foo'\n\n    @property\n    def thing(self):\n        return self.__thing\n\n\nclass Child(Parent):\n    @Parent.thing.getter\n    def thing(self):\n        return super().thing + '!'\n\n\nprint(Child().thing)\n"}, {"start_line": 0, "end_line": 460, "belongs_to": {"file_name": "metaclass_attr_access.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"test attribute access on metaclass\"\"\"\n\n\nclass Meta(type):\n    \"\"\"the meta class\"\"\"\n    def __init__(cls, name, bases, dictionary):\n        super(Meta, cls).__init__(name, bases, dictionary)\n        print(cls, cls._meta_args)\n        delattr(cls, '_meta_args')\n\n\nclass Test:\n    \"\"\"metaclassed class\"\"\"\n    __metaclass__ = Meta\n    _meta_args = ('foo', 'bar')\n\n    def __init__(self):\n        print('__init__', self)\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "= func_obj._proxied\n                if func_obj.name == func.name:\n                    return True\n    return False\n\n\ndef _is_attribute_property(name: str, klass: nodes.ClassDef) -> bool:\n    \"\"\"Check if the given attribute *name* is a property in the given *klass*.\n\n    It will look for `property` calls or for functions\n    with the given name, decorated by `property` or `property`\n    subclasses.\n    Returns ``True`` if the name is a property in the given klass,\n    ``False`` otherwise.\n    \"\"\"\n    try:\n        attributes = klass.getattr(name)\n    except astroid.NotFoundError:\n        return False\n    property_name = \"builtins.property\"\n    for attr in attributes:\n        if isinstance(attr, util.UninferableBase):\n            continue\n        try:\n            inferred = next(attr.infer())\n        except astroid.InferenceError:\n            continue\n        if isinstance(inferred, nodes.FunctionDef) and decorated_with_property(\n            inferred\n        ):\n            return True\n        if inferred.pytype() == property_name:\n            return True\n    return False\n\n\ndef _has_same_layout_slots(\n    slots: list[nodes.Const | None], assigned_value: nodes.Name\n) -> bool:\n    inferred = next(assigned_value.infer())\n    if isinstance(inferred, nodes.ClassDef):\n        other_slots = inferred.slots()\n        if all(\n            first_slot and second_slot and first_slot.value == second_slot.value\n            for (first_slot, second_slot) in zip_longest(slots, other_slots)\n        ):\n            return True\n    return False\n\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"F0202\": (\n        \"Unable to check methods signature (%s / %s)\",\n        \"method-check-failed\",\n        \"Used when Pylint has been unable to check methods signature \"\n        \"compatibility for an unexpected reason. Please report this kind \"\n        \"if you don't make sense of it.\",\n    ),\n    \"E0202\": (\n        \"An attribute defined in %s line %s hides this method\",\n        \"method-hidden\",\n        \""}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "not_callable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods,wrong-import-position,use-dict-literal\n# pylint: disable=wrong-import-order, undefined-variable\n\nrevision = None\n\nrevision() # [not-callable]\n\ndef correct():\n    return 1\n\nrevision = correct()\n\nclass Correct:\n    \"\"\"callable object\"\"\"\n\nclass MetaCorrect:\n    \"\"\"callable object\"\"\"\n    def __call__(self):\n        return self\n\nINSTANCE = Correct()\nCALLABLE_INSTANCE = MetaCorrect()\nCORRECT = CALLABLE_INSTANCE()\nincorrect = INSTANCE() # [not-callable]\nLIST = []\nincorrect = LIST() # [not-callable]\nDICT = {}\nincorrect = DICT() # [not-callable]\nTUPLE = ()\nincorrect = TUPLE() # [not-callable]\nINT = 1\nincorrect = INT() # [not-callable]\n\n# Test calling properties. Pylint can detect when using only the\n# getter, but it doesn't infer properly when having a getter\n# and a setter.\nclass MyProperty(property):\n    \"\"\" test subclasses \"\"\"\n\nclass PropertyTest:\n    \"\"\" class \"\"\"\n\n    def __init__(self):\n        self.attr = 4\n\n    @property\n    def test(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @test.setter\n    def test(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\n    @MyProperty\n    def custom(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @custom.setter\n    def custom(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\nPROP = PropertyTest()\nPROP.test(40) # [not-callable]\nPROP.custom() # [not-callable]\n\n# Safe from not-callable when using properties.\n\nclass SafeProperty:\n    @property\n    def static(self):\n        return staticmethod\n\n    @property\n    def klass(self):\n        return classmethod\n\n    @property\n    def get_lambda(self):\n        return lambda: None\n\n    @property\n    def other_function(self):\n        def function(arg):\n            return arg\n        return function\n\n    @property\n    def dict_builtin(self):\n        return dict\n\n    @property\n    def range_builtin(self):\n        return range\n\n    @property\n   "}], "retrieved_count": 10, "cost_time": 1.1284193992614746}
{"question": "How should the custom string class architecture be redesigned to separate parameter validation from formatting operations while maintaining backward compatibility with the built-in str interface?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h.append(f\".{specifier}\")\n        else:\n            path.append(f\"[{specifier!r}]\")\n    return str(key) + \"\".join(path)\n\n\ndef arg_matches_format_type(\n    arg_type: SuccessfulInferenceResult, format_type: str\n) -> bool:\n    if format_type in \"sr\":\n        # All types can be printed with %s and %r\n        return True\n    if isinstance(arg_type, astroid.Instance):\n        arg_type = arg_type.pytype()\n        if arg_type == \"builtins.str\":\n            return format_type == \"c\"\n        if arg_type == \"builtins.float\":\n            return format_type in \"deEfFgGn%\"\n        if arg_type == \"builtins.int\":\n            # Integers allow all types\n            return True\n        return False\n    return True\n\n\nclass StringFormatChecker(BaseChecker):\n    \"\"\"Checks string formatting operations to ensure that the format string\n    is valid and the arguments match the format string.\n    \"\"\"\n\n    name = \"string\"\n    msgs = MSGS\n\n    # pylint: disable = too-many-branches, too-many-locals, too-many-statements\n    @only_required_for_messages(\n        \"bad-format-character\",\n        \"truncated-format-string\",\n        \"mixed-format-string\",\n        \"bad-format-string-key\",\n        \"missing-format-string-key\",\n        \"unused-format-string-key\",\n        \"bad-string-format-type\",\n        \"format-needs-mapping\",\n        \"too-many-format-args\",\n        \"too-few-format-args\",\n        \"format-string-without-interpolation\",\n    )\n    def visit_binop(self, node: nodes.BinOp) -> None:\n        if node.op != \"%\":\n            return\n        left = node.left\n        args = node.right\n\n        if not (isinstance(left, nodes.Const) and isinstance(left.value, str)):\n            return\n        format_string = left.value\n        try:\n            (\n                required_keys,\n                required_num_args,\n                required_key_types,\n                required_arg_types,\n            ) = utils.parse_format_string(format_string)\n        except utils.UnsupportedFormatCharacter as exc:\n            "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  self.add_message(\n                        \"bad-str-strip-call\",\n                        node=node,\n                        args=(func.bound.name, func.name),\n                    )\n            elif func.name == \"format\":\n                self._check_new_format(node, func)\n\n    def _detect_vacuous_formatting(\n        self, node: nodes.Call, positional_arguments: list[SuccessfulInferenceResult]\n    ) -> None:\n        counter = collections.Counter(\n            arg.name for arg in positional_arguments if isinstance(arg, nodes.Name)\n        )\n        for name, count in counter.items():\n            if count == 1:\n                continue\n            self.add_message(\n                \"duplicate-string-formatting-argument\", node=node, args=(name,)\n            )\n\n    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -> None:\n        \"\"\"Check the new string formatting.\"\"\"\n        # Skip format nodes which don't have an explicit string on the\n        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n        ):\n            return\n        if node.starargs or node.kwargs:\n            return\n        try:\n            strnode = next(func.bound.infer())\n        except astroid.InferenceError:\n            return\n        if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):\n            return\n        try:\n            call_site = astroid.arguments.CallSite.from_call(node)\n        except astroid.InferenceError:\n            return\n\n        try:\n            fields, num_args, manual_pos = utils.parse_forma"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             if num_args > required_num_args:\n                    self.add_message(\"too-many-format-args\", node=node)\n                elif num_args < required_num_args:\n                    self.add_message(\"too-few-format-args\", node=node)\n                for arg, format_type in zip(args_elts, required_arg_types):\n                    if not arg:\n                        continue\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        arg_type\n                        and not isinstance(arg_type, util.UninferableBase)\n                        and not arg_matches_format_type(arg_type, format_type)\n                    ):\n                        self.add_message(\n                            \"bad-string-format-type\",\n                            node=node,\n                            args=(arg_type.pytype(), format_type),\n                        )\n\n    @only_required_for_messages(\"f-string-without-interpolation\")\n    def visit_joinedstr(self, node: nodes.JoinedStr) -> None:\n        self._check_interpolation(node)\n\n    def _check_interpolation(self, node: nodes.JoinedStr) -> None:\n        if isinstance(node.parent, nodes.FormattedValue):\n            return\n        for value in node.values:\n            if isinstance(value, nodes.FormattedValue):\n                return\n        self.add_message(\"f-string-without-interpolation\", node=node)\n\n    def visit_call(self, node: nodes.Call) -> None:\n        func = utils.safe_infer(node.func)\n        if (\n            isinstance(func, astroid.BoundMethod)\n            and isinstance(func.bound, astroid.Instance)\n            and func.bound.name in {\"str\", \"unicode\", \"bytes\"}\n        ):\n            if func.name in {\"strip\", \"lstrip\", \"rstrip\"} and node.args:\n                arg = utils.safe_infer(node.args[0])\n                if not isinstance(arg, nodes.Const) or not isinstance(arg.value, str):\n                    return\n                if len(arg.value) != len(set(arg.value)):\n                  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Checker for string formatting operations.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections\nimport re\nimport sys\nimport tokenize\nfrom collections import Counter\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Literal\n\nimport astroid\nfrom astroid import bases, nodes, util\nfrom astroid.typing import SuccessfulInferenceResult\n\nfrom pylint.checkers import BaseChecker, BaseRawFileChecker, BaseTokenChecker, utils\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.interfaces import HIGH\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\n_AST_NODE_STR_TYPES = (\"__builtin__.unicode\", \"__builtin__.str\", \"builtins.str\")\n# Prefixes for both strings and bytes literals per\n# https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals\n_PREFIXES = {\n    \"r\",\n    \"u\",\n    \"R\",\n    \"U\",\n    \"f\",\n    \"F\",\n    \"fr\",\n    \"Fr\",\n    \"fR\",\n    \"FR\",\n    \"rf\",\n    \"rF\",\n    \"Rf\",\n    \"RF\",\n    \"b\",\n    \"B\",\n    \"br\",\n    \"Br\",\n    \"bR\",\n    \"BR\",\n    \"rb\",\n    \"rB\",\n    \"Rb\",\n    \"RB\",\n}\n_PAREN_IGNORE_TOKEN_TYPES = (\n    tokenize.NEWLINE,\n    tokenize.NL,\n    tokenize.COMMENT,\n)\nSINGLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?'''\")\nDOUBLE_QUOTED_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?\\\"\\\"\\\"\")\nQUOTE_DELIMITER_REGEX = re.compile(f\"({'|'.join(_PREFIXES)})?(\\\"|')\", re.DOTALL)\n\nMSGS: dict[str, MessageDefinitionTuple] = (\n    {  # pylint: disable=consider-using-namedtuple-or-dataclass\n        \"E1300\": (\n            \"Unsupported format character %r (%#02x) at index %d\",\n            \"bad-format-character\",\n            \"Used when an unsupported format character is used in a format string.\",\n        ),\n        \""}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rmatter()\n    # pylint: disable = too-many-try-statements\n    try:\n        parseiterator = formatter.parse(format_string)\n        for result in parseiterator:\n            if all(item is None for item in result[1:]):\n                # not a replacement format\n                continue\n            name = result[1]\n            nested = result[2]\n            yield name\n            if nested:\n                yield from collect_string_fields(nested)\n    except ValueError as exc:\n        # Probably the format string is invalid.\n        if exc.args[0].startswith(\"cannot switch from manual\"):\n            # On Jython, parsing a string with both manual\n            # and automatic positions will fail with a ValueError,\n            # while on CPython it will simply return the fields,\n            # the validation being done in the interpreter (?).\n            # We're just returning two mixed fields in order\n            # to trigger the format-combined-specification check.\n            yield \"\"\n            yield \"1\"\n            return\n        raise IncompleteFormatString(format_string) from exc\n\n\ndef parse_format_method_string(\n    format_string: str,\n) -> tuple[list[tuple[str, list[tuple[bool, str]]]], int, int]:\n    \"\"\"Parses a PEP 3101 format string, returning a tuple of\n    (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args).\n\n    keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt\n    is the number of arguments required by the format string and\n    explicit_pos_args is the number of arguments passed with the position.\n    \"\"\"\n    keyword_arguments = []\n    implicit_pos_args_cnt = 0\n    explicit_pos_args = set()\n    for name in collect_string_fields(format_string):\n        if name and str(name).isdigit():\n            explicit_pos_args.add(str(name))\n        elif name:\n            keyname, fielditerator = split_format_field_names(name)\n            if isinstance(keyname, numbers.Number):\n                explicit_pos_args.add(str(keyna"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nodes.JoinedStr) -> None:\n        self._check_interpolation(node)\n\n    def _check_interpolation(self, node: nodes.JoinedStr) -> None:\n        if isinstance(node.parent, nodes.FormattedValue):\n            return\n        for value in node.values:\n            if isinstance(value, nodes.FormattedValue):\n                return\n        self.add_message(\"f-string-without-interpolation\", node=node)\n\n    def visit_call(self, node: nodes.Call) -> None:\n        func = utils.safe_infer(node.func)\n        if (\n            isinstance(func, astroid.BoundMethod)\n            and isinstance(func.bound, astroid.Instance)\n            and func.bound.name in {\"str\", \"unicode\", \"bytes\"}\n        ):\n            if func.name in {\"strip\", \"lstrip\", \"rstrip\"} and node.args:\n                arg = utils.safe_infer(node.args[0])\n                if not isinstance(arg, nodes.Const) or not isinstance(arg.value, str):\n                    return\n                if len(arg.value) != len(set(arg.value)):\n                    self.add_message(\n                        \"bad-str-strip-call\",\n                        node=node,\n                        args=(func.bound.name, func.name),\n                    )\n            elif func.name == \"format\":\n                self._check_new_format(node, func)\n\n    def _detect_vacuous_formatting(\n        self, node: nodes.Call, positional_arguments: list[SuccessfulInferenceResult]\n    ) -> None:\n        counter = collections.Counter(\n            arg.name for arg in positional_arguments if isinstance(arg, nodes.Name)\n        )\n        for name, count in counter.items():\n            if count == 1:\n                continue\n            self.add_message(\n                \"duplicate-string-formatting-argument\", node=node, args=(name,)\n            )\n\n    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -> None:\n        \"\"\"Check the new string formatting.\"\"\"\n        # Skip format nodes which don't have an explicit string on the\n        # left side of the format"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "string_formatting.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/string", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ormat(123) # [too-few-format-args]\n\n\ndef issue338():\n    \"\"\"\n    Check that using a namedtuple subclass doesn't crash when\n    trying to infer EmptyNodes (resulted after mocking the\n    members of namedtuples).\n    \"\"\"\n    from collections import namedtuple # pylint: disable=import-outside-toplevel\n\n    class Crash(namedtuple(\"C\", \"foo bar\")):\n        \"\"\" Looking for attributes in __str__ will crash,\n        because EmptyNodes can't be inferred.\n        \"\"\"\n        def __str__(self):\n            return \"{0.foo}: {0.bar}\".format(self)\n    return Crash\n\n\ndef issue351():\n    \"\"\"\n    Check that the format method can be assigned to a variable, ie:\n    \"\"\"\n    fmt = 'test {} {}'.format\n    fmt('arg1') # [too-few-format-args]\n    fmt('arg1', 'arg2')\n    fmt('arg1', 'arg2', 'arg3') # [too-many-format-args]\n\n\ndef issue373():\n    \"\"\"\n    Ignore any object coming from an argument.\n    \"\"\"\n    class SomeClass:\n        \"\"\" empty docstring. \"\"\"\n        def __init__(self, opts=None):\n            self.opts = opts\n\n        def dunc(self, arg):\n            \"\"\"Don't try to analyze this.\"\"\"\n            return \"A{0}{1}\".format(arg, self.opts)\n\n        def func(self):\n            \"\"\"Don't try to analyze the following string.\"\"\"\n            return 'AAA{0[iface]}BBB{0[port]}'.format(self.opts)\n\n    return SomeClass\n\n\ndef issue_463():\n    \"\"\"\n    Mix positional arguments, `{0}`, with positional\n    arguments with attribute access, `{0.__x__}`.\n    \"\"\"\n    data = \"{0.__class__.__name__}: {0}\".format(42)\n    data2 = \"{0[0]}: {0}\".format([1])\n    return (data, data2)\n\n\ndef avoid_empty_attribute():\n    \"\"\"The following string is invalid, avoid crashing.\"\"\"\n\n    return \"There are {.:2f} undiscovered errors.\".format(1) # [bad-format-string]\n\n\ndef invalid_format_index_on_inference_ambiguity():\n    \"\"\"Test inference bug for invalid-format-index\"\"\"\n    if len(sys.argv) > 1:\n        options = [[\"Woof!\"]]\n    else:\n        options = [[\"Barf!\"]]\n    return 'Why is this bad? {options[0][0]}'.format(opti"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "strings.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_method_string(\n                strnode.value\n            )\n        except utils.IncompleteFormatString:\n            self.add_message(\"bad-format-string\", node=node)\n            return\n\n        positional_arguments = call_site.positional_arguments\n        named_arguments = call_site.keyword_arguments\n        named_fields = {field[0] for field in fields if isinstance(field[0], str)}\n        if num_args and manual_pos:\n            self.add_message(\"format-combined-specification\", node=node)\n            return\n\n        check_args = False\n        # Consider \"{[0]} {[1]}\" as num_args.\n        num_args += sum(1 for field in named_fields if not field)\n        if named_fields:\n            for field in named_fields:\n                if field and field not in named_arguments:\n                    self.add_message(\n                        \"missing-format-argument-key\", node=node, args=(field,)\n                    )\n            for field in named_arguments:\n                if field not in named_fields:\n                    self.add_message(\n                        \"unused-format-string-argument\", node=node, args=(field,)\n                    )\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if positional_arguments or num_args:\n                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n                    check_args = True\n        else:\n            check_args = True\n        if check_args:\n            # num_args can be 0 if manual_pos is not.\n            num_args = num_args or manual_pos\n            if not num_args:\n        "}, {"start_line": 0, "end_line": 1418, "belongs_to": {"file_name": "invalid_format_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __format__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,unnecessary-lambda-assignment\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodFormat:\n    \"\"\"__format__ returns <type 'str'>\"\"\"\n\n    def __format__(self, format_spec):\n        return \"some format\"\n\n\nclass SecondGoodFormat:\n    \"\"\"__format__ returns <type 'str'>\"\"\"\n\n    def __format__(self, format_spec):\n        return str(123)\n\n\nclass FormatMetaclass(type):\n    def __format__(cls, format_spec):\n        return \"some format\"\n\n\n@six.add_metaclass(FormatMetaclass)\nclass ThirdGoodFormat:\n    \"\"\"Format through the metaclass.\"\"\"\n\n\nclass FirstBadFormat:\n    \"\"\" __format__ returns bytes \"\"\"\n\n    def __format__(self, format_spec):  # [invalid-format-returned]\n        return b\"123\"\n\n\nclass SecondBadFormat:\n    \"\"\" __format__ returns int \"\"\"\n\n    def __format__(self, format_spec):  # [invalid-format-returned]\n        return 1\n\n\nclass ThirdBadFormat:\n    \"\"\" __format__ returns node which does not have 'value' in AST \"\"\"\n\n    def __format__(self, format_spec):  # [invalid-format-returned]\n        return lambda: \"some format\"\n\n\nclass AmbiguousFormat:\n    \"\"\" Uninferable return value \"\"\"\n\n    __format__ = lambda self, format_spec: Missing\n\n\nclass AnotherAmbiguousFormat:\n    \"\"\"Potential uninferable return value\"\"\"\n\n    def __format__(self, format_spec):\n        return str(Missing)\n"}, {"start_line": 5000, "end_line": 6091, "belongs_to": {"file_name": "consider_using_f_string.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c/consider", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " b = \"String {}\".format(PARAM_1)  # [consider-using-f-string]\n    c = \"String {Param_1}\".format(Param_1=PARAM_1)  # [consider-using-f-string]\n    d = \"{} {}\".format(PARAM_1, PARAM_2)  # [consider-using-f-string]\n    e = \"{Par_1}{Par_2}\".format(Par_1=PARAM_1, Par_2=PARAM_2)  # [consider-using-f-string]\n    f = \"{Param_1}\".format(*PARAM_LIST_SINGLE)  # [consider-using-f-string]\n    g = \"{Param_1}\".format(**PARAM_DICT_SINGLE)  # [consider-using-f-string]\n    h = \"String %s\" % (PARAM_1)  # [consider-using-f-string]\n    i = \"String %s %s\" % (PARAM_1, PARAM_2)  # [consider-using-f-string]\n    j = \"String %s\" % (PARAM_LIST_SINGLE)  # [consider-using-f-string]\n\n\ndef regression_tests():\n    # Referencing .format in a kwarg should not be warned\n    def wrap_print(value):\n        print(value)\n\n    wrap_print(value=\"{}\".format)\n\n\ndef invalid_format_string_good():\n    \"\"\"Should not raise message when `.format` is called with an invalid format string.\"\"\"\n    # pylint: disable=bad-format-string\n    print(\"{a[0] + a[1]}\".format(a=[0, 1]))\n    print(\"{\".format(a=1))\n    print(\"{\".format(1))\n"}], "retrieved_count": 10, "cost_time": 1.1219825744628906}
{"question": "How should the regex pattern compilation logic in the initialization method that configures fixme detection patterns in the encoding validation checker be refactored to separate pattern construction from compilation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "unicode.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"A cached version of encode used for search pattern.\"\"\"\n    return _encode_without_bom(string, encoding)\n\n\ndef _fix_utf16_32_line_stream(steam: Iterable[bytes], codec: str) -> Iterable[bytes]:\n    r\"\"\"Handle line ending for UTF16 and UTF32 correctly.\n\n    Currently, Python simply strips the required zeros after \\n after the\n    line ending. Leading to lines that can't be decoded properly\n    \"\"\"\n    if not codec.startswith(\"utf-16\") and not codec.startswith(\"utf-32\"):\n        yield from steam\n    else:\n        # First we get all the bytes in memory\n        content = b\"\".join(line for line in steam)\n\n        new_line = _cached_encode_search(\"\\n\", codec)\n\n        # Now we split the line by the real new line in the correct encoding\n        # we can't use split as it would strip the \\n that we need\n        start = 0\n        while True:\n            pos = content.find(new_line, start)\n            if pos >= 0:\n                yield content[start : pos + len(new_line)]\n            else:\n                # Yield the rest and finish\n                if content[start:]:\n                    yield content[start:]\n                break\n\n            start = pos + len(new_line)\n\n\ndef extract_codec_from_bom(first_line: bytes) -> str:\n    \"\"\"Try to extract the codec (unicode only) by checking for the BOM.\n\n    For details about BOM see https://unicode.org/faq/utf_bom.html#BOM\n\n    Args:\n        first_line: the first line of a file\n\n    Returns:\n        a codec name\n\n    Raises:\n        ValueError: if no codec was found\n    \"\"\"\n    for bom, codec in BOM_SORTED_TO_CODEC.items():\n        if first_line.startswith(bom):\n            return codec\n\n    raise ValueError(\"No BOM found. Could not detect Unicode codec.\")\n\n\nclass UnicodeChecker(checkers.BaseRawFileChecker):\n    \"\"\"Check characters that could be used to hide bad code to humans.\n\n    This includes:\n\n    - Bidirectional Unicode (see https://trojansource.codes/)\n\n    - Bad ASCII characters (see PEP672)\n\n        If a programmer requir"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es.\n    \"\"\"\n\n    # configuration section name\n    name = \"miscellaneous\"\n    msgs = {\n        \"W0511\": (\n            \"%s\",\n            \"fixme\",\n            \"Used when a warning note as FIXME or XXX is detected.\",\n        )\n    }\n\n    options = (\n        (\n            \"notes\",\n            {\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated values>\",\n                \"default\": (\"FIXME\", \"XXX\", \"TODO\"),\n                \"help\": (\n                    \"List of note tags to take in consideration, \"\n                    \"separated by a comma.\"\n                ),\n            },\n        ),\n        (\n            \"notes-rgx\",\n            {\n                \"type\": \"string\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"Regular expression of note tags to take in consideration.\",\n                \"default\": \"\",\n            },\n        ),\n        (\n            \"check-fixme-in-docstring\",\n            {\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"default\": False,\n                \"help\": \"Whether or not to search for fixme's in docstrings.\",\n            },\n        ),\n    )\n\n    def open(self) -> None:\n        super().open()\n\n        notes = \"|\".join(re.escape(note) for note in self.linter.config.notes)\n        if self.linter.config.notes_rgx:\n            notes += f\"|{self.linter.config.notes_rgx}\"\n\n        comment_regex = rf\"#\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?$)\"\n        self._comment_fixme_pattern = re.compile(comment_regex, re.I)\n\n        # single line docstring like '''this''' or \"\"\"this\"\"\"\n        docstring_regex = rf\"((\\\"\\\"\\\")|(\\'\\'\\'))\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?)((\\\"\\\"\\\")|(\\'\\'\\'))\"\n        self._docstring_fixme_pattern = re.compile(docstring_regex, re.I)\n\n        # multiline docstrings which will be split into newlines\n        # so we do not need to look for quotes/double-quotes\n        multiline_docstring_regex = rf\"^\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*$)\"\n        self._multiline_docst"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Tests for the misc checker.\"\"\"\n\nfrom pylint.checkers import misc\nfrom pylint.testutils import CheckerTestCase, MessageTest, _tokenize_str, set_config\n\n\nclass TestFixme(CheckerTestCase):\n    CHECKER_CLASS = misc.EncodingChecker\n\n    def test_fixme_with_message(self) -> None:\n        code = \"\"\"a = 1\n                # FIXME message\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"FIXME message\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_todo_without_message(self) -> None:\n        code = \"\"\"a = 1\n                # TODO\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"TODO\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_xxx_without_space(self) -> None:\n        code = \"\"\"a = 1\n                #XXX\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"XXX\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_xxx_middle(self) -> None:\n        code = \"\"\"a = 1\n                # middle XXX\n                \"\"\"\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_without_space_fixme(self) -> None:\n        code = \"\"\"a = 1\n                #FIXME\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"FIXME\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[\"???\"])\n    def test_non_alphanumeric_codetag(self) -> None:\n        code = \"\"\"a"}, {"start_line": 6000, "end_line": 7059, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self.add_message(\n                                \"fixme\",\n                                col_offset=token_info.start[1] + 1,\n                                args=match.group(\"msg\"),\n                                line=token_info.start[0] + line_no,\n                            )\n                elif match := self._docstring_fixme_pattern.match(token_info.string):\n                    self.add_message(\n                        \"fixme\",\n                        col_offset=token_info.start[1] + 1,\n                        args=match.group(\"msg\"),\n                        line=token_info.start[0],\n                    )\n\n    def _is_multiline_docstring(self, token_info: tokenize.TokenInfo) -> bool:\n        return (\n            token_info.type == tokenize.STRING\n            and (token_info.line.lstrip().startswith(('\"\"\"', \"'''\")))\n            and \"\\n\" in token_info.line.rstrip()\n        )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(EncodingChecker(linter))\n    linter.register_checker(ByIdManagedMessagesChecker(linter))\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unittest_misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_xxx_without_space(self) -> None:\n        code = \"\"\"a = 1\n                #XXX\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"XXX\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_xxx_middle(self) -> None:\n        code = \"\"\"a = 1\n                # middle XXX\n                \"\"\"\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_without_space_fixme(self) -> None:\n        code = \"\"\"a = 1\n                #FIXME\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"FIXME\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[\"???\"])\n    def test_non_alphanumeric_codetag(self) -> None:\n        code = \"\"\"a = 1\n                #???\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[])\n    def test_absent_codetag(self) -> None:\n        code = \"\"\"a = 1\n                # FIXME\t                # FIXME\n                # TODO\t                # TODO\n                # XXX\t                # XXX\n                \"\"\"\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[\"CODETAG\"])\n    def test_other_present_codetag(self) -> None:\n        code = \"\"\"a = 1\n                # CODETAG\n                # FIXME\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"CODETAG\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_issue_2321_should_not_trigger(self)"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ring_fixme_pattern = re.compile(\n            multiline_docstring_regex, re.I\n        )\n\n    def _check_encoding(\n        self, lineno: int, line: bytes, file_encoding: str\n    ) -> str | None:\n        try:\n            return line.decode(file_encoding)\n        except UnicodeDecodeError:\n            pass\n        except LookupError:\n            if (\n                line.startswith(b\"#\")\n                and \"coding\" in str(line)\n                and file_encoding in str(line)\n            ):\n                msg = f\"Cannot decode using encoding '{file_encoding}', bad encoding\"\n                self.add_message(\"syntax-error\", line=lineno, args=msg)\n        return None\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find encoding problem.\"\"\"\n        encoding = node.file_encoding if node.file_encoding else \"ascii\"\n\n        with node.stream() as stream:\n            for lineno, line in enumerate(stream):\n                self._check_encoding(lineno + 1, line, encoding)\n\n    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:\n        \"\"\"Inspect the source to find fixme problems.\"\"\"\n        if not self.linter.config.notes:\n            return\n        for token_info in tokens:\n            if token_info.type == tokenize.COMMENT:\n                if match := self._comment_fixme_pattern.match(token_info.string):\n                    self.add_message(\n                        \"fixme\",\n                        col_offset=token_info.start[1] + 1,\n                        args=match.group(\"msg\"),\n                        line=token_info.start[0],\n                    )\n            elif self.linter.config.check_fixme_in_docstring:\n                if self._is_multiline_docstring(token_info):\n                    docstring_lines = token_info.string.split(\"\\n\")\n                    for line_no, line in enumerate(docstring_lines):\n                        if match := self._multiline_docstring_fixme_pattern.match(line):\n                     "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " or n>\",\n                \"default\": False,\n                \"help\": \"Whether or not to search for fixme's in docstrings.\",\n            },\n        ),\n    )\n\n    def open(self) -> None:\n        super().open()\n\n        notes = \"|\".join(re.escape(note) for note in self.linter.config.notes)\n        if self.linter.config.notes_rgx:\n            notes += f\"|{self.linter.config.notes_rgx}\"\n\n        comment_regex = rf\"#\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?$)\"\n        self._comment_fixme_pattern = re.compile(comment_regex, re.I)\n\n        # single line docstring like '''this''' or \"\"\"this\"\"\"\n        docstring_regex = rf\"((\\\"\\\"\\\")|(\\'\\'\\'))\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*?)((\\\"\\\"\\\")|(\\'\\'\\'))\"\n        self._docstring_fixme_pattern = re.compile(docstring_regex, re.I)\n\n        # multiline docstrings which will be split into newlines\n        # so we do not need to look for quotes/double-quotes\n        multiline_docstring_regex = rf\"^\\s*(?P<msg>({notes})(?=(:|\\s|\\Z)).*$)\"\n        self._multiline_docstring_fixme_pattern = re.compile(\n            multiline_docstring_regex, re.I\n        )\n\n    def _check_encoding(\n        self, lineno: int, line: bytes, file_encoding: str\n    ) -> str | None:\n        try:\n            return line.decode(file_encoding)\n        except UnicodeDecodeError:\n            pass\n        except LookupError:\n            if (\n                line.startswith(b\"#\")\n                and \"coding\" in str(line)\n                and file_encoding in str(line)\n            ):\n                msg = f\"Cannot decode using encoding '{file_encoding}', bad encoding\"\n                self.add_message(\"syntax-error\", line=lineno, args=msg)\n        return None\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find encoding problem.\"\"\"\n        encoding = node.file_encoding if node.file_encoding else \"ascii\"\n\n        with node.stream() as stream:\n            for lineno, line in enumerate(stream):\n                self._check_encoding(lineno +"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "unittest_misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = 1\n                #???\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[])\n    def test_absent_codetag(self) -> None:\n        code = \"\"\"a = 1\n                # FIXME\t                # FIXME\n                # TODO\t                # TODO\n                # XXX\t                # XXX\n                \"\"\"\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n\n    @set_config(notes=[\"CODETAG\"])\n    def test_other_present_codetag(self) -> None:\n        code = \"\"\"a = 1\n                # CODETAG\n                # FIXME\n                \"\"\"\n        with self.assertAddsMessages(\n            MessageTest(msg_id=\"fixme\", line=2, args=\"CODETAG\", col_offset=17)\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_issue_2321_should_not_trigger(self) -> None:\n        code = 'print(\"# TODO this should not trigger a fixme\")'\n        with self.assertNoMessages():\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_issue_2321_should_trigger(self) -> None:\n        code = \"# TODO this should not trigger a fixme\"\n        with self.assertAddsMessages(\n            MessageTest(\n                msg_id=\"fixme\",\n                line=1,\n                args=\"TODO this should not trigger a fixme\",\n                col_offset=1,\n            )\n        ):\n            self.checker.process_tokens(_tokenize_str(code))\n\n    def test_dont_trigger_on_todoist(self) -> None:\n        code = \"\"\"\n        # Todoist API: What is this task about?\n        # Todoist API: Look up a task's due date\n        # Todoist API: Look up a Project/Label/Task ID\n        # Todoist API: Fetch all labels\n        # Todoist API: \"Name\" value\n        # Todoist API: Get a task's priority\n        # Todoist API: Look up the Project ID a Task belongs to\n        # "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "unicode.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s/102205/ \"\n                \"for some possible problems when using UTF-16 for instance.\"\n            ),\n        ),\n        \"E2502\": (\n            (\n                \"Contains control characters that can permit obfuscated code \"\n                \"executed differently than displayed\"\n            ),\n            \"bidirectional-unicode\",\n            (\n                \"bidirectional unicode are typically not displayed characters required \"\n                \"to display right-to-left (RTL) script \"\n                \"(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. \"\n                \"So can you trust this code? \"\n                \"Are you sure it displayed correctly in all editors? \"\n                \"If you did not write it or your language is not RTL,\"\n                \" remove the special characters, as they could be used to trick you into \"\n                \"executing code, \"\n                \"that does something else than what it looks like.\\n\"\n                \"More Information:\\n\"\n                \"https://en.wikipedia.org/wiki/Bidirectional_text\\n\"\n                \"https://trojansource.codes/\"\n            ),\n        ),\n        \"C2503\": (\n            \"PEP8 recommends UTF-8 as encoding for Python files\",\n            \"bad-file-encoding\",\n            (\n                \"PEP8 recommends UTF-8 default encoding for Python files. See \"\n                \"https://peps.python.org/pep-0008/#source-file-encoding\"\n            ),\n        ),\n        **{\n            bad_char.code: (\n                bad_char.description(),\n                bad_char.human_code(),\n                bad_char.help_text,\n            )\n            for bad_char in BAD_CHARS\n        },\n    }\n\n    @staticmethod\n    def _is_invalid_codec(codec: str) -> bool:\n        return codec.startswith((\"utf-16\", \"utf-32\"))\n\n    @staticmethod\n    def _is_unicode(codec: str) -> bool:\n        return codec.startswith(\"utf\")\n\n    @classmethod\n    def _find_line_matches(cls, line: bytes, codec: str) -> dict[int, _BadChar]:\n        \"\"\"Fi"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "misc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 1, line, encoding)\n\n    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:\n        \"\"\"Inspect the source to find fixme problems.\"\"\"\n        if not self.linter.config.notes:\n            return\n        for token_info in tokens:\n            if token_info.type == tokenize.COMMENT:\n                if match := self._comment_fixme_pattern.match(token_info.string):\n                    self.add_message(\n                        \"fixme\",\n                        col_offset=token_info.start[1] + 1,\n                        args=match.group(\"msg\"),\n                        line=token_info.start[0],\n                    )\n            elif self.linter.config.check_fixme_in_docstring:\n                if self._is_multiline_docstring(token_info):\n                    docstring_lines = token_info.string.split(\"\\n\")\n                    for line_no, line in enumerate(docstring_lines):\n                        if match := self._multiline_docstring_fixme_pattern.match(line):\n                            self.add_message(\n                                \"fixme\",\n                                col_offset=token_info.start[1] + 1,\n                                args=match.group(\"msg\"),\n                                line=token_info.start[0] + line_no,\n                            )\n                elif match := self._docstring_fixme_pattern.match(token_info.string):\n                    self.add_message(\n                        \"fixme\",\n                        col_offset=token_info.start[1] + 1,\n                        args=match.group(\"msg\"),\n                        line=token_info.start[0],\n                    )\n\n    def _is_multiline_docstring(self, token_info: tokenize.TokenInfo) -> bool:\n        return (\n            token_info.type == tokenize.STRING\n            and (token_info.line.lstrip().startswith(('\"\"\"', \"'''\")))\n            and \"\\n\" in token_info.line.rstrip()\n        )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(EncodingChecker(linter))\n    l"}], "retrieved_count": 10, "cost_time": 1.1294755935668945}
{"question": "Why does the assignment name processing method defer frame node visitation until the local variable type attribute is accessed rather than visiting frames upfront?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          node.uid = self.generate_id()\n        # resolve ancestors\n        for baseobj in node.ancestors(recurs=False):\n            specializations = getattr(baseobj, \"specializations\", [])\n            specializations.append(node)\n            baseobj.specializations = specializations\n        # resolve instance attributes\n        node.instance_attrs_type = collections.defaultdict(list)\n        node.aggregations_type = collections.defaultdict(list)\n        node.associations_type = collections.defaultdict(list)\n        for assignattrs in tuple(node.instance_attrs.values()):\n            for assignattr in assignattrs:\n                if not isinstance(assignattr, nodes.Unknown):\n                    self.associations_handler.handle(assignattr, node)\n                    self.handle_assignattr_type(assignattr, node)\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Visit an astroid.Function node.\n\n        * set the locals_type mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n        node.locals_type = collections.defaultdict(list)\n        if self.tag:\n            node.uid = self.generate_id()\n\n    def visit_assignname(self, node: nodes.AssignName) -> None:\n        \"\"\"Visit an astroid.AssignName node.\n\n        handle locals_type\n        \"\"\"\n        # avoid double parsing done by different Linkers.visit\n        # running over the same project:\n        if hasattr(node, \"_handled\"):\n            return\n        node._handled = True\n        if node.name in node.frame():\n            frame = node.frame()\n        else:\n            # the name has been defined as 'global' in the frame and belongs\n            # there.\n            frame = node.root()\n        if not hasattr(frame, \"locals_type\"):\n            # If the frame doesn't have a locals_type yet,\n            # it means it wasn't yet visited. Visit it now\n            # to add what's missing from it.\n            if isinstan"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          self._check_name(\"typevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeAlias):\n            self._check_name(\"typealias\", node.name, node)\n\n        # Check names defined in module scope\n        elif isinstance(frame, nodes.Module):\n            # Check names defined in AnnAssign nodes\n            if isinstance(assign_type, nodes.AnnAssign) and self._assigns_typealias(\n                assign_type.annotation\n            ):\n                self._check_name(\"typealias\", node.name, node)\n\n            # Check names defined in Assign nodes\n            elif isinstance(assign_type, (nodes.Assign, nodes.AnnAssign)):\n                inferred_assign_type = (\n                    utils.safe_infer(assign_type.value) if assign_type.value else None\n                )\n\n                # Check TypeVar's and TypeAliases assigned alone or in tuple assignment\n                if isinstance(node.parent, nodes.Assign):\n                    if self._assigns_typevar(assign_type.value):\n                        self._check_name(\"typevar\", assign_type.targets[0].name, node)\n                        return\n                    if self._assigns_typealias(assign_type.value):\n                        self._check_name(\"typealias\", assign_type.targets[0].name, node)\n                        return\n\n                if (\n                    isinstance(node.parent, nodes.Tuple)\n                    and isinstance(assign_type.value, nodes.Tuple)\n                    # protect against unbalanced tuple unpacking\n                    and node.parent.elts.index(node) < len(assign_type.value.elts)\n                ):\n                    assigner = assign_type.value.elts[node.parent.elts.index(node)]\n                    if self._assigns_typevar(assigner):\n                        self._check_name(\n                            \"typevar\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n         "}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                        and astroid.are_exclusive(*iattrs)\n                    ):\n                        node_type = \"const\"\n                    self._check_name(\n                        node_type,\n                        node.name,\n                        node,\n                        disallowed_check_only=redefines_import,\n                    )\n\n        # Check names defined in function scopes\n        elif isinstance(frame, nodes.FunctionDef):\n            # global introduced variable aren't in the function locals\n            if node.name in frame and node.name not in frame.argnames():\n                if not _redefines_import(node):\n                    if isinstance(\n                        assign_type, nodes.AnnAssign\n                    ) and self._assigns_typealias(assign_type.annotation):\n                        self._check_name(\"typealias\", node.name, node)\n                    else:\n                        self._check_name(\"variable\", node.name, node)\n\n        # Check names defined in class scop"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "inspector.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ode with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n        node.locals_type = collections.defaultdict(list)\n        if self.tag:\n            node.uid = self.generate_id()\n\n    def visit_assignname(self, node: nodes.AssignName) -> None:\n        \"\"\"Visit an astroid.AssignName node.\n\n        handle locals_type\n        \"\"\"\n        # avoid double parsing done by different Linkers.visit\n        # running over the same project:\n        if hasattr(node, \"_handled\"):\n            return\n        node._handled = True\n        if node.name in node.frame():\n            frame = node.frame()\n        else:\n            # the name has been defined as 'global' in the frame and belongs\n            # there.\n            frame = node.root()\n        if not hasattr(frame, \"locals_type\"):\n            # If the frame doesn't have a locals_type yet,\n            # it means it wasn't yet visited. Visit it now\n            # to add what's missing from it.\n            if isinstance(frame, nodes.ClassDef):\n                self.visit_classdef(frame)\n            elif isinstance(frame, nodes.FunctionDef):\n                self.visit_functiondef(frame)\n            else:\n                self.visit_module(frame)\n\n        current = frame.locals_type[node.name]\n        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))\n\n    @staticmethod\n    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:\n        \"\"\"Handle an astroid.assignattr node.\n\n        handle instance_attrs_type\n        \"\"\"\n        current = set(parent.instance_attrs_type[node.attrname])\n        parent.instance_attrs_type[node.attrname] = list(\n            current | utils.infer_node(node)\n        )\n\n    def visit_import(self, node: nodes.Import) -> None:\n        \"\"\"Visit an astroid.Import node.\n\n        resolve module dependencies\n        \"\"\"\n        context_file = node.root().file\n        for name in node.names:\n            relative = astroid.modutils.i"}, {"start_line": 75000, "end_line": 77000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._postponed_evaluation_enabled\n                    and isinstance(stmt, (nodes.AnnAssign, nodes.FunctionDef))\n                ) and not (\n                    isinstance(stmt, nodes.AnnAssign)\n                    and utils.get_node_first_ancestor_of_type(stmt, nodes.FunctionDef)\n                ):\n                    self.add_message(\n                        \"used-before-assignment\",\n                        args=node.name,\n                        node=node,\n                        confidence=HIGH,\n                    )\n                    return (VariableVisitConsumerAction.RETURN, found_nodes)\n\n            elif base_scope_type == \"lambda\":\n                # E0601 can occur in class-level scope in lambdas, as in\n                # the following example:\n                #   class A:\n                #      x = lambda attr: f + attr\n                #      f = 42\n                # We check lineno because doing the following is fine:\n                #   class A:\n                #      x = 42\n                #      y = lambda attr: x + attr\n                if (\n                    isinstance(frame, nodes.ClassDef)\n                    and node.name in frame.locals\n                    and stmt.fromlineno <= defstmt.fromlineno\n                ):\n                    self.add_message(\n                        \"used-before-assignment\",\n                        args=node.name,\n                        node=node,\n                        confidence=HIGH,\n                    )\n\n        elif not self._is_builtin(node.name) and self._is_only_type_assignment(\n            node, defstmt\n        ):\n            if node.scope().locals.get(node.name):\n                self.add_message(\n                    \"used-before-assignment\", args=node.name, node=node, confidence=HIGH\n                )\n            else:\n                self.add_message(\n                    \"undefined-variable\", args=node.name, node=node, confidence=HIGH\n                )\n            return (VariableVisitConsumerAction.RE"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                   node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_import := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                 "}, {"start_line": 90000, "end_line": 92000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_parent := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n     "}, {"start_line": 89000, "end_line": 91000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n            #\n            # bar = None\n            # foo = lambda bar=bar: bar\n            #\n            # In this case, maybe_before_assign should be False, otherwise\n            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n            frame, nodes.FunctionDef\n        ):\n            # Special rules for function return annotations.\n            if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_paren"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n                        self._check_name(\"typevar\", assign_type.targets[0].name, node)\n                        return\n                    if self._assigns_typealias(assign_type.value):\n                        self._check_name(\"typealias\", assign_type.targets[0].name, node)\n                        return\n\n                if (\n                    isinstance(node.parent, nodes.Tuple)\n                    and isinstance(assign_type.value, nodes.Tuple)\n                    # protect against unbalanced tuple unpacking\n                    and node.parent.elts.index(node) < len(assign_type.value.elts)\n                ):\n                    assigner = assign_type.value.elts[node.parent.elts.index(node)]\n                    if self._assigns_typevar(assigner):\n                        self._check_name(\n                            \"typevar\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_impor"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\n            _determine_function_name_type(node, config=self.linter.config),\n            node.name,\n            node,\n            confidence,\n        )\n        # Check argument names\n        args = node.args.args\n        if args is not None:\n            self._recursive_check_names(args)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    @utils.only_required_for_messages(\n        \"disallowed-name\",\n        \"invalid-name\",\n        \"typevar-name-incorrect-variance\",\n        \"typevar-double-variance\",\n        \"typevar-name-mismatch\",\n    )\n    def visit_assignname(  # pylint: disable=too-many-branches\n        self, node: nodes.AssignName\n    ) -> None:\n        \"\"\"Check module level assigned names.\"\"\"\n        frame = node.frame()\n        assign_type = node.assign_type()\n\n        # Check names defined in comprehensions\n        if isinstance(assign_type, nodes.Comprehension):\n            self._check_name(\"inlinevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeVar):\n            self._check_name(\"typevar\", node.name, node)\n\n        elif isinstance(assign_type, nodes.TypeAlias):\n            self._check_name(\"typealias\", node.name, node)\n\n        # Check names defined in module scope\n        elif isinstance(frame, nodes.Module):\n            # Check names defined in AnnAssign nodes\n            if isinstance(assign_type, nodes.AnnAssign) and self._assigns_typealias(\n                assign_type.annotation\n            ):\n                self._check_name(\"typealias\", node.name, node)\n\n            # Check names defined in Assign nodes\n            elif isinstance(assign_type, (nodes.Assign, nodes.AnnAssign)):\n                inferred_assign_type = (\n                    utils.safe_infer(assign_type.value) if assign_type.value else None\n                )\n\n                # Check TypeVar's and TypeAliases assigned alone or in tuple assignment\n                if isinstance(node.parent, nodes.Assign):\n                    if self._assigns_typevar(assign_type.value)"}], "retrieved_count": 10, "cost_time": 1.1185033321380615}
{"question": "Why does the test class that intentionally violates the protocol by returning a three-element tuple instead of the required two-element tuple exist alongside correct implementations in the same test module?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 2723, "belongs_to": {"file_name": "invalid_getnewargs_ex_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self._bar = far\n        self._hoo = hoo\n        self._haha = haha\n\n    def __getnewargs_ex__(self):\n        args = (self._foo, self._bar)\n        kwargs = {'hoo': self._hoo,\n                  'haha': self._haha}\n        return args, kwargs\n\n\nclass FirstBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns an integer \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return 1\n\n\nclass SecondBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n\n\nclass ThirdBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for first arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n\n\nclass FourthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for second arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n\n\nclass FifthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for both args \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ({'x': 'y'}, (2,))\n\n\nclass SixthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n\n\nclass AmbigousGetNewArgsEx:\n    \"\"\" Uninferable return value \"\"\"\n\n    __getnewargs_ex__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgsEx:\n    \"\"\"Potential uninferable return value\"\"\"\n\n    def __getnewargs_ex__(self):\n        return tuple(Missing)\n"}, {"start_line": 0, "end_line": 206, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/i/invalid-getnewargs-ex-returned", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class CustomGetNewArgsEx:\n    \"\"\"__getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "invalid_getnewargs_ex_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __getnewargs_ex__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,use-dict-literal,unnecessary-lambda-assignment,use-dict-literal\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodGetNewArgsEx:\n    \"\"\"__getnewargs_ex__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs_ex__(self):\n        return ((1,), {\"2\": \"2\"})\n\n\nclass SecondGoodGetNewArgsEx:\n    \"\"\"__getnewargs_ex__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs_ex__(self):\n        return (tuple(), dict())\n\n\nclass GetNewArgsExMetaclass(type):\n    def __getnewargs_ex__(cls):\n        return ((1,), {\"2\": \"2\"})\n\n\n@six.add_metaclass(GetNewArgsExMetaclass)\nclass ThirdGoodGetNewArgsEx:\n    \"\"\"GetNewArgsEx through the metaclass.\"\"\"\n\n\nclass FourthGoodGetNewArgsEx:\n    \"\"\"Test that `args` and `kwargs` (`Name` nodes) are inferred as tuples.\n\n    https://github.com/pylint-dev/pylint/issues/10208\n    \"\"\"\n    def __init__(self, boo, far, *, hoo, haha):\n        self._foo = boo\n        self._bar = far\n        self._hoo = hoo\n        self._haha = haha\n\n    def __getnewargs_ex__(self):\n        args = (self._foo, self._bar)\n        kwargs = {'hoo': self._hoo,\n                  'haha': self._haha}\n        return args, kwargs\n\n\nclass FirstBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns an integer \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return 1\n\n\nclass SecondBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n\n\nclass ThirdBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for first arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n\n\nclass FourthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for second arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewa"}, {"start_line": 0, "end_line": 1447, "belongs_to": {"file_name": "invalid_getnewargs_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __getnewargs__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,unnecessary-lambda-assignment,use-dict-literal\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return (1, \"2\", 3)\n\n\nclass SecondGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return tuple()\n\n\nclass GetNewArgsMetaclass(type):\n    def __getnewargs__(cls):\n        return (1, 2, 3)\n\n\n@six.add_metaclass(GetNewArgsMetaclass)\nclass ThirdGoodGetNewArgs:\n    \"\"\"GetNewArgs through the metaclass.\"\"\"\n\n\nclass FirstBadGetNewArgs:\n    \"\"\" __getnewargs__ returns an integer \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return 1\n\n\nclass SecondBadGetNewArgs:\n    \"\"\" __getnewargs__ returns str \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return \"(1, 2, 3)\"\n\n\nclass ThirdBadGetNewArgs:\n    \"\"\" __getnewargs__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return lambda: tuple(1, 2)\n\n\nclass AmbigousGetNewArgs:\n    \"\"\" Uninferable return value \"\"\"\n    __getnewargs__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgs:\n    \"\"\"Potential uninferable return value\"\"\"\n    def __getnewargs__(self):\n        return tuple(Missing)\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unbalanced_tuple_unpacking.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unbalanced", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ond\n\n\ndef do_stuff6():\n    \"\"\"This is right\"\"\"\n    (first, second) = (1, 2)\n    return first + second\n\n\ndef temp():\n    \"\"\"This is not weird\"\"\"\n    if True:\n        return [1, 2]\n    return [2, 3, 4]\n\n\ndef do_stuff7():\n    \"\"\"This is not right, but we're not sure\"\"\"\n    first, second = temp()\n    return first + second\n\n\ndef temp2():\n    \"\"\"This is weird, but correct\"\"\"\n    if True:\n        return (1, 2)\n\n    if True:\n        return (2, 3)\n    return (4, 5)\n\n\ndef do_stuff8():\n    \"\"\"This is correct\"\"\"\n    first, second = temp2()\n    return first + second\n\n\ndef do_stuff9():\n    \"\"\"This is not correct\"\"\"\n    first, second = unpack()  # [unbalanced-tuple-unpacking]\n    return first + second\n\n\nclass UnbalancedUnpacking:\n    \"\"\"Test unbalanced tuple unpacking in instance attributes.\"\"\"\n\n    # pylint: disable=attribute-defined-outside-init, invalid-name, too-few-public-methods\n    def test(self):\n        \"\"\"unpacking in instance attributes\"\"\"\n        # we're not sure if temp() returns two or three values\n        # so we shouldn't emit an error\n        self.a, self.b = temp()\n        self.a, self.b = temp2()\n        self.a, self.b = unpack()  # [unbalanced-tuple-unpacking]\n\n\ndef issue329(*args):\n    \"\"\"Don't emit unbalanced tuple unpacking if the\n    rhs of the assignment is a variable-length argument,\n    because we don't know the actual length of the tuple.\n    \"\"\"\n    first, second, third = args\n    return first, second, third\n\n\ndef test_decimal():\n    \"\"\"Test a false positive with decimal.Decimal.as_tuple\n\n    See astroid https://bitbucket.org/logilab/astroid/issues/92/\n    \"\"\"\n    from decimal import Decimal\n\n    dec = Decimal(2)\n    first, second, third = dec.as_tuple()\n    return first, second, third\n\n\ndef test_issue_559():\n    \"\"\"Test that we don't have a false positive wrt to issue #559.\"\"\"\n    from ctypes import c_int\n\n    root_x, root_y, win_x, win_y = [c_int()] * 4\n    return root_x, root_y, win_x, win_y\n\n\nclass MyClass(NamedTuple):\n    first: float\n    second: "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unexpected_special_method_signature.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test for special methods implemented incorrectly.\"\"\"\n\n# pylint: disable=missing-docstring, unused-argument, too-few-public-methods\n# pylint: disable=invalid-name,too-many-arguments,bad-staticmethod-argument\n\nclass Invalid:\n\n    def __enter__(self, other): # [unexpected-special-method-signature]\n        pass\n\n    def __del__(self, other): # [unexpected-special-method-signature]\n        pass\n\n    def __format__(self, other, other2): # [unexpected-special-method-signature]\n        pass\n\n    def __setattr__(self): # [unexpected-special-method-signature]\n        pass\n\n    def __round__(self, invalid, args): # [unexpected-special-method-signature]\n        pass\n\n    def __deepcopy__(self, memo, other): # [unexpected-special-method-signature]\n        pass\n\n    def __iter__(): # [no-method-argument]\n        pass\n\n    @staticmethod\n    def __getattr__(self, nanana): # [unexpected-special-method-signature]\n        pass\n\n    def __subclasses__(self, blabla):  # [unexpected-special-method-signature]\n        pass\n\n\nclass FirstBadContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type): # [unexpected-special-method-signature]\n        pass\n\nclass SecondBadContextManager:\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, value, tb, stack): # [unexpected-special-method-signature]\n        pass\n\nclass ThirdBadContextManager:\n    def __enter__(self):\n        return self\n\n    # +1: [unexpected-special-method-signature]\n    def __exit__(self, exc_type, value, tb, stack, *args):\n        pass\n\n\nclass Async:\n\n    def __aiter__(self, extra): # [unexpected-special-method-signature]\n        pass\n    def __anext__(self, extra, argument): # [unexpected-special-method-signature]\n        pass\n    def __await__(self, param): # [unexpected-special-method-signature]\n        pass\n    def __aenter__(self, first): # [unexpected-special-method-signature]\n        pass\n    def __aexit__(self): # [unexpected-special-method-signature]\n       "}, {"start_line": 0, "end_line": 922, "belongs_to": {"file_name": "class_protocol_ellipsis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\"Tests for return type checkers for protocol methods with ellipsis function body\"\"\"\n# pylint: disable=missing-class-docstring\nfrom typing import Any, Iterator\n\n\nclass MyClass:\n    \"\"\"The \"invalid-*-returned\" messages shouldn't be emitted for stub functions\n    Original issue: https://github.com/pylint-dev/pylint/issues/4736\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __hash__(self) -> int:\n        ...\n\n    def __index__(self) -> int:\n        ...\n\n    def __iter__(self) -> Iterator[Any]:\n        ...\n\n    def __bool__(self) -> bool:\n        ...\n\n    def __repr__(self) -> object:\n        ...\n\n    def __str__(self) -> str:\n        ...\n\n    def __bytes__(self) -> bytes:\n        ...\n\n    def __length_hint__(self) -> int:\n        ...\n\n    def __format__(self, format_spec: str) -> str:\n        ...\n\n    def __getnewargs__(self) -> tuple:\n        ...\n\n    def __getnewargs_ex__(self) -> tuple:\n        ...\n"}, {"start_line": 0, "end_line": 234, "belongs_to": {"file_name": "unpacking.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unpacking", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Code for checking the display of the module\nfor unbalanced-tuple-unpacking and unpacking-non-sequence\n\"\"\"\n\ndef unpack():\n    \"\"\" Return something\"\"\"\n    return (1, 2, 3)\n\ndef nonseq():\n    \"\"\" Return non sequence \"\"\"\n    return 1\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unbalanced_tuple_unpacking.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unbalanced", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check possible unbalanced tuple unpacking \"\"\"\nfrom __future__ import absolute_import\n\nimport sys\nfrom typing import NamedTuple\nfrom functional.u.unpacking.unpacking import unpack\n\n# pylint: disable=missing-class-docstring, missing-function-docstring, using-constant-test, import-outside-toplevel\n\n\ndef do_stuff():\n    \"\"\"This is not right.\"\"\"\n    first, second = 1, 2, 3  # [unbalanced-tuple-unpacking]\n    return first + second\n\n\ndef do_stuff1():\n    \"\"\"This is not right.\"\"\"\n    first, second = [1, 2, 3]  # [unbalanced-tuple-unpacking]\n    return first + second\n\n\ndef do_stuff2():\n    \"\"\"This is not right.\"\"\"\n    (first, second) = 1, 2, 3  # [unbalanced-tuple-unpacking]\n    return first + second\n\n\ndef do_stuff3():\n    \"\"\"This is not right.\"\"\"\n    first, second = range(100)\n    return first + second\n\n\ndef do_stuff4():\n    \"\"\"This is right\"\"\"\n    first, second = 1, 2\n    return first + second\n\n\ndef do_stuff5():\n    \"\"\"This is also right\"\"\"\n    first, second = (1, 2)\n    return first + second\n\n\ndef do_stuff6():\n    \"\"\"This is right\"\"\"\n    (first, second) = (1, 2)\n    return first + second\n\n\ndef temp():\n    \"\"\"This is not weird\"\"\"\n    if True:\n        return [1, 2]\n    return [2, 3, 4]\n\n\ndef do_stuff7():\n    \"\"\"This is not right, but we're not sure\"\"\"\n    first, second = temp()\n    return first + second\n\n\ndef temp2():\n    \"\"\"This is weird, but correct\"\"\"\n    if True:\n        return (1, 2)\n\n    if True:\n        return (2, 3)\n    return (4, 5)\n\n\ndef do_stuff8():\n    \"\"\"This is correct\"\"\"\n    first, second = temp2()\n    return first + second\n\n\ndef do_stuff9():\n    \"\"\"This is not correct\"\"\"\n    first, second = unpack()  # [unbalanced-tuple-unpacking]\n    return first + second\n\n\nclass UnbalancedUnpacking:\n    \"\"\"Test unbalanced tuple unpacking in instance attributes.\"\"\"\n\n    # pylint: disable=attribute-defined-outside-init, invalid-name, too-few-public-methods\n    def test(self):\n        \"\"\"unpacking in instance attributes\"\"\"\n        # we're not sure if temp() returns two or "}, {"start_line": 2000, "end_line": 3468, "belongs_to": {"file_name": "no_self_use.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/no_self_use", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "and they can be part of an\n        API specification.\n        \"\"\"\n        return 42\n\n\nclass A:\n    def __init__(self):\n        self.store = {}\n\n    def get(self, key, default=None):\n        return self.store.get(key, default)\n\nclass B(A):\n    def get_memo(self, obj):\n        return super().get(obj)\n\n\nclass C:\n    def a(self, /):  # [no-self-use]\n        ...\n\n    # Disable with old error code\n    # pylint: disable=use-symbolic-message-instead\n    def b(self, /):  # pylint: disable=R0201\n        ...\n\n\ndef func_a(self):  # pylint: disable=unused-argument\n    pass\n\n\nclass Foo1(ABC):\n    \"\"\"Don't emit no-self-use for abstract methods.\"\"\"\n\n    @abstractmethod\n    def a(self):\n        pass\n\n    def b(self):\n        raise NotImplementedError\n\n    def c(self):\n        pass  # pass counts as abstract\n\n\nclass Foo2(Protocol):\n    \"\"\"Don't emit no-self-use for methods in Protocol classes.\"\"\"\n\n    def a(self):\n        ...\n\nclass Foo3:\n    \"\"\"Don't emit no-self-use for overload methods.\"\"\"\n\n    @overload\n    def a(self, var): ...\n\n    @overload\n    def a(self, var): ...\n\n    def a(self, var):\n        pass\n\n\nclass Foo4:\n    \"\"\"Other false positive cases.\"\"\"\n\n    @staticmethod\n    def a(self):  # pylint: disable=unused-argument,bad-staticmethod-argument\n        ...\n\n    @staticmethod\n    def b():\n        ...\n\n    @classmethod\n    def c(self):  # pylint: disable=bad-classmethod-argument\n        ...\n\n    def d():  # pylint: disable=no-method-argument\n        ...\n"}], "retrieved_count": 10, "cost_time": 1.1294357776641846}
{"question": "Why does the NamedTuple test class in the PEP 604 alternative union syntax test module use pipe operator syntax instead of typing.Union?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,unnecessary-direct-lambda-call,superfluous-parens\n\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\nAlias = str | list[int]\nlst = [typing.Dict[str, int] | None,]\n\nvar1: typing.Dict[str, int | None]\nvar2: int | str | None\nvar3: int | list[str | int]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)\n\nT = typing.TypeVar(\"T\", int | str, bool)\n\n(lambda x: 2)(int | str)\n\nvar: str | int\n\ndef func(arg: int | str):\n    pass\n\ndef func2() -> int | str:\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=(int | str))\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: int | str\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: int | str\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: int | str\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: int | str\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: int | str\n\nclass ForwardMetaclass(type):\n    def __or__(cls, other):\n        return True\n\nclass ReverseMetaclass(type):\n    def __ror__(cls, other):\n        return True\n\nclass WithForward(metaclass=ForwardMetaclass):\n "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax_error.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax with postponed evaluation of\nannotations enabled.\n\nFor Python 3.7 - 3.9: Everything should fail.\nTesting only 3.8/3.9 to support TypedDict.\n\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,line-too-long,unnecessary-direct-lambda-call\n# pylint: disable=unnecessary-lambda-assignment\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\n\nAlias = str | typing.List[int]  # [unsupported-binary-operation]\nlst = [typing.Dict[str, int] | None,]  # [unsupported-binary-operation]\n\nvar1: typing.Dict[str, int | None]  # [unsupported-binary-operation]\n# var2: int | str | None  # false-negative: unsupported-binary-operation, unsupported-binary-operation\nvar3: int | typing.List[str | int]  # [unsupported-binary-operation]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]  # [unsupported-binary-operation]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int  # [unsupported-binary-operation]\n\ndef func(arg: int | str):  # [unsupported-binary-operation]\n    pass\n\ndef func2() -> int | str:  # [unsupported-binary-operation]\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str  # [unsupported-binary-operation]\n\nclass CustomNamedTuple3(typing.NamedTuple"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "alternative_union_syntax_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 604 - Alternative Union syntax with postponed evaluation of\nannotations enabled.\n\nFor Python 3.7 - 3.9: Most things should work.\nTesting only 3.8/3.9 to support TypedDict.\n\"\"\"\n\n# pylint: disable=missing-function-docstring,unused-argument,invalid-name,missing-class-docstring\n# pylint: disable=inherit-non-class,too-few-public-methods,line-too-long,unnecessary-direct-lambda-call\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nfrom __future__ import annotations\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import NamedTuple, TypedDict\n\n\nAlias = str | typing.List[int]  # [unsupported-binary-operation]\nlst = [typing.Dict[str, int] | None,]  # [unsupported-binary-operation]\n\nvar1: typing.Dict[str, int | None]\nvar2: int | str | None\nvar3: int | list[str | int]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int\n\ndef func(arg: int | str):\n    pass\n\ndef func2() -> int | str:\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=int | str)  # [unsupported-binary-operation]\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})  # [unsupported-binary-operation]\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str\n\nclass CustomTypedDic"}, {"start_line": 0, "end_line": 1880, "belongs_to": {"file_name": "typing_consider_using_union_py310.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/typing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test pylint.extension.typing - consider-alternative-union-syntax\n\n'py-version' needs to be set to >= '3.10'.\n\"\"\"\n# pylint: disable=missing-docstring,invalid-name,unused-argument,line-too-long\n# pylint: disable=deprecated-typing-alias,unnecessary-direct-lambda-call\nfrom dataclasses import dataclass\nimport typing\nfrom typing import Dict, List, Optional, Union, TypedDict\n\nvar1: Union[int, str]  # [consider-alternative-union-syntax]\nvar2: List[Union[int, None]]  # [consider-alternative-union-syntax]\nvar3: Dict[str, typing.Union[int, str]]  # [consider-alternative-union-syntax]\nvar4: Optional[int]  # [consider-alternative-union-syntax]\n\nAlias1 = Union[int, str]  # [consider-alternative-union-syntax]\nAlias2 = List[Union[int, None]]  # [consider-alternative-union-syntax]\nAlias3 = Dict[str, typing.Union[int, str]]  # [consider-alternative-union-syntax]\nAlias4 = Optional[int]  # [consider-alternative-union-syntax]\n\ndef func1(\n    arg1: Optional[int],  # [consider-alternative-union-syntax]\n    **kwargs: Dict[str, Union[int, str]]  # [consider-alternative-union-syntax]\n) -> Union[str, None]:  # [consider-alternative-union-syntax]\n    pass\n\nclass Custom1(List[Union[str, int]]):  # [consider-alternative-union-syntax]\n    pass\n\ncast_variable = [1, 2, 3]\ncast_variable = typing.cast(Union[List[int], None], cast_variable)  # [consider-alternative-union-syntax]\n\n(lambda x: 2)(Optional[int])  # [consider-alternative-union-syntax]\n\nclass CustomNamedTuple(typing.NamedTuple):\n    my_var: Union[int, str]  # [consider-alternative-union-syntax]\n\nCustomTypedDict1 = TypedDict(\"CustomTypedDict1\", my_var=Optional[int])  # [consider-alternative-union-syntax]\n\nclass CustomTypedDict2(TypedDict):\n    my_var: Dict[str, List[Union[str, int]]]  # [consider-alternative-union-syntax]\n\n@dataclass\nclass CustomDataClass:\n    my_var: Optional[int]  # [consider-alternative-union-syntax]\n"}, {"start_line": 0, "end_line": 1748, "belongs_to": {"file_name": "typing_consider_using_union_without_future.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/typing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test pylint.extension.typing - consider-alternative-union-syntax\n\n'py-version' needs to be set to >= '3.7' and 'runtime-typing=no'.\n\"\"\"\n\n# pylint: disable=missing-docstring,invalid-name,unused-argument,line-too-long,unnecessary-direct-lambda-call\n# pylint: disable=consider-using-alias\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nfrom dataclasses import dataclass\nimport typing\nfrom typing import Dict, List, Optional, Union, TypedDict\n\nvar1: Union[int, str]  # [consider-alternative-union-syntax]\nvar2: List[Union[int, None]]  # [consider-alternative-union-syntax]\nvar3: Dict[str, typing.Union[int, str]]  # [consider-alternative-union-syntax]\nvar4: Optional[int]  # [consider-alternative-union-syntax]\n\nAlias1 = Union[int, str]\nAlias2 = List[Union[int, None]]\nAlias3 = Dict[str, typing.Union[int, str]]\nAlias4 = Optional[int]\n\ndef func1(\n    arg1: Optional[int],  # [consider-alternative-union-syntax]\n    **kwargs: Dict[str, Union[int, str]]  # [consider-alternative-union-syntax]\n) -> Union[str, None]:  # [consider-alternative-union-syntax]\n    pass\n\nclass Custom1(List[Union[str, int]]):\n    pass\n\ncast_variable = [1, 2, 3]\ncast_variable = typing.cast(Union[List[int], None], cast_variable)\n\n(lambda x: 2)(Optional[int])\n\nclass CustomNamedTuple(typing.NamedTuple):\n    my_var: Union[int, str]  # [consider-alternative-union-syntax]\n\nCustomTypedDict1 = TypedDict(\"CustomTypedDict1\", my_var=Optional[int])\n\nclass CustomTypedDict2(TypedDict):\n    my_var: Dict[str, List[Union[str, int]]]  # [consider-alternative-union-syntax]\n\n@dataclass\nclass CustomDataClass:\n    my_var: Optional[int]  # [consider-alternative-union-syntax]\n"}, {"start_line": 0, "end_line": 1834, "belongs_to": {"file_name": "typing_consider_using_union.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/typing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test pylint.extension.typing - consider-alternative-union-syntax\n\n'py-version' needs to be set to >= '3.7' and 'runtime-typing=no'.\nWith 'from __future__ import annotations' present.\n\"\"\"\n\n# pylint: disable=missing-docstring,invalid-name,unused-argument,line-too-long\n# pylint: disable=consider-using-alias,unnecessary-direct-lambda-call\n\n# Disabled because of a bug with pypy 3.8 see\n# https://github.com/pylint-dev/pylint/pull/7918#issuecomment-1352737369\n# pylint: disable=multiple-statements\n\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nimport typing\nfrom typing import Dict, List, Optional, Union, TypedDict\n\nvar1: Union[int, str]  # [consider-alternative-union-syntax]\nvar2: List[Union[int, None]]  # [consider-alternative-union-syntax]\nvar3: Dict[str, typing.Union[int, str]]  # [consider-alternative-union-syntax]\nvar4: Optional[int]  # [consider-alternative-union-syntax]\n\nAlias1 = Union[int, str]\nAlias2 = List[Union[int, None]]\nAlias3 = Dict[str, typing.Union[int, str]]\nAlias4 = Optional[int]\n\ndef func1(\n    arg1: Optional[int],  # [consider-alternative-union-syntax]\n    **kwargs: Dict[str, Union[int, str]]  # [consider-alternative-union-syntax]\n) -> Union[str, None]:  # [consider-alternative-union-syntax]\n    pass\n\nclass Custom1(List[Union[str, int]]):\n    pass\n\ncast_variable = [1, 2, 3]\ncast_variable = typing.cast(Union[List[int], None], cast_variable)\n\n(lambda x: 2)(Optional[int])\n\nclass CustomNamedTuple(typing.NamedTuple):\n    my_var: Union[int, str]  # [consider-alternative-union-syntax]\n\nCustomTypedDict1 = TypedDict(\"CustomTypedDict1\", my_var=Optional[int])\n\nclass CustomTypedDict2(TypedDict):\n    my_var: Dict[str, List[Union[str, int]]]  # [consider-alternative-union-syntax]\n\n@dataclass\nclass CustomDataClass:\n    my_var: Optional[int]  # [consider-alternative-union-syntax]\n"}, {"start_line": 1000, "end_line": 2434, "belongs_to": {"file_name": "alternative_union_syntax_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ping.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int\n\ndef func(arg: int | str):\n    pass\n\ndef func2() -> int | str:\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=int | str)  # [unsupported-binary-operation]\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})  # [unsupported-binary-operation]\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: int | str\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: int | str\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: int | str\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: int | str\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: int | str\n"}, {"start_line": 0, "end_line": 686, "belongs_to": {"file_name": "alternative_union_syntax_regession_8119.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Regression test for alternative Union syntax in runtime contexts.\nSyntax support was added in Python 3.10.\n\nThe code snipped should not raise any errors.\nhttps://github.com/pylint-dev/pylint/issues/8119\n\"\"\"\n# pylint: disable=missing-docstring,too-few-public-methods\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass Coordinator(Generic[T]):\n    def __init__(self, update_interval=None) -> None:\n        self.update_interval = update_interval\n\n\nclass Child(Coordinator[int | str]):\n    def __init__(self) -> None:\n        Coordinator.__init__(self, update_interval=2)\n\n    def _async_update_data(self):\n        assert self.update_interval\n        self.update_interval = 1\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "alternative_union_syntax_error.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/alternative", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "binary-operation\nvar3: int | typing.List[str | int]  # [unsupported-binary-operation]\nvar4: typing.Dict[typing.Tuple[int, int] | int, None]  # [unsupported-binary-operation]\n\ncast_var = 1\ncast_var = typing.cast(str | int, cast_var)  # [unsupported-binary-operation]\n\nT = typing.TypeVar(\"T\", int | str, bool)  # [unsupported-binary-operation]\n\n(lambda x: 2)(int | str)  # [unsupported-binary-operation]\n\nvar: str | int  # [unsupported-binary-operation]\n\ndef func(arg: int | str):  # [unsupported-binary-operation]\n    pass\n\ndef func2() -> int | str:  # [unsupported-binary-operation]\n    pass\n\nclass CustomCls(int):\n    pass\n\nAlias2 = CustomCls |  str  # [unsupported-binary-operation]\n\nvar2 = CustomCls(1) | int(2)\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", int | str)])  # [unsupported-binary-operation]\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: int | str  # [unsupported-binary-operation]\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: int | str  # [unsupported-binary-operation]\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=int | str)  # [unsupported-binary-operation]\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": int | str})  # [unsupported-binary-operation]\n\nclass CustomTypedDict3(TypedDict):\n    my_var: int | str  # [unsupported-binary-operation]\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: int | str  # [unsupported-binary-operation]\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: int | str  # [unsupported-binary-operation]\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: int | str  # [unsupported-binary-op"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "postponed_evaluation_pep585.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/p/postponed", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test PEP 585 works as expected, starting with Python 3.9\"\"\"\n# pylint: disable=missing-docstring,unused-argument,unused-import,too-few-public-methods,invalid-name,inherit-non-class,unsupported-binary-operation,wrong-import-position,ungrouped-imports,unused-variable,unnecessary-direct-lambda-call\nimport collections\nimport dataclasses\nimport typing\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, NamedTuple, TypedDict, Union, Tuple\n\n\nAliasValid = list[int]\n\nclass CustomIntList(typing.List[int]):\n    pass\n\nclass CustomIntListError(list[int]):\n    pass\n\ncast_variable = [1, 2, 3]\ncast_variable = typing.cast(list[int], cast_variable)\n\nT = typing.TypeVar(\"T\", list[int], str)\n\n(lambda x: 2)(list[int])\n\n\n# Check typing.NamedTuple\nCustomNamedTuple = typing.NamedTuple(\n    \"CustomNamedTuple\", [(\"my_var\", list[int])])\n\nclass CustomNamedTuple2(NamedTuple):\n    my_var: list[int]\n\nclass CustomNamedTuple3(typing.NamedTuple):\n    my_var: list[int]\n\n\n# Check typing.TypedDict\nCustomTypedDict = TypedDict(\"CustomTypedDict\", my_var=list[int])\n\nCustomTypedDict2 = TypedDict(\"CustomTypedDict2\", {\"my_var\": list[int]})\n\nclass CustomTypedDict3(TypedDict):\n    my_var: list[int]\n\nclass CustomTypedDict4(typing.TypedDict):\n    my_var: list[int]\n\n\n# Check dataclasses\ndef my_decorator(*args, **kwargs):\n    def wraps(*args, **kwargs):\n        pass\n    return wraps\n\n@dataclass\nclass CustomDataClass:\n    my_var: list[int]\n\n@dataclasses.dataclass\nclass CustomDataClass2:\n    my_var: list[int]\n\n@dataclass()\nclass CustomDataClass3:\n    my_var: list[int]\n\n@my_decorator\n@dataclasses.dataclass\nclass CustomDataClass4:\n    my_var: list[int]\n\n\nvar1: set[int]\nvar2: collections.OrderedDict[str, int]\nvar3: dict[str, list[int]]\nvar4: Dict[str, list[int]]\nvar5: dict[tuple[int, int], str]\nvar6: Dict[tuple[int, int], str]\nvar7: list[list[int]]\nvar8: tuple[list[int]]\nvar9: int | list[str | int]\nvar10: Union[list[str], None]\nvar11: Union[Union[list[int], int]]\n\ndef func(arg: list[int]):\n    pass\n\ndef fun"}], "retrieved_count": 10, "cost_time": 1.1293752193450928}
{"question": "How should the termination predicate evaluation within the iteration loop be decoupled from the iterable consumption mechanism to enable independent testing of the termination predicate evaluation and the alternative path value emission?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 106000, "end_line": 108000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "stance(inferred_func, nodes.FunctionDef)\n                    and inferred_func.returns\n                ):\n                    inferred_return = utils.safe_infer(inferred_func.returns)\n                    if isinstance(\n                        inferred_return, nodes.FunctionDef\n                    ) and inferred_return.qname() in {\n                        *TYPING_NORETURN,\n                        *TYPING_NEVER,\n                        \"typing._SpecialForm\",\n                    }:\n                        return\n                    # typing_extensions.NoReturn returns a _SpecialForm\n                    if (\n                        isinstance(inferred_return, bases.Instance)\n                        and inferred_return.qname() == \"typing._SpecialForm\"\n                    ):\n                        return\n\n        maybe_walrus = utils.get_node_first_ancestor_of_type(node, nodes.NamedExpr)\n        if maybe_walrus:\n            maybe_comprehension = utils.get_node_first_ancestor_of_type(\n                maybe_walrus, nodes.Comprehension\n            )\n            if maybe_comprehension:\n                comprehension_scope = utils.get_node_first_ancestor_of_type(\n                    maybe_comprehension, nodes.ComprehensionScope\n                )\n                if comprehension_scope is None:\n                    # Should not be possible.\n                    pass\n                elif (\n                    comprehension_scope.parent.scope() is scope\n                    and node.name in comprehension_scope.locals\n                ):\n                    return\n\n        # For functions we can do more by inferring the length of the itered object\n        try:\n            inferred = next(assign.iter.infer())\n            # Prefer the target of enumerate() rather than the enumerate object itself\n            if (\n                isinstance(inferred, astroid.Instance)\n                and inferred.qname() == \"builtins.enumerate\"\n            ):\n                likely_call = assign.iter\n     "}, {"start_line": 0, "end_line": 676, "belongs_to": {"file_name": "two_good_fruit_generator.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/s/stop-iteration-return/good", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def two_good_fruits_generator(fruits):\n    \"\"\"A return can be used to end the iterator early, but not a StopIteration.\"\"\"\n    for fruit in fruits:\n        if not fruit.is_tasty():\n            continue\n        while True:\n            next_fruit = next(fruits, None)\n            if next_fruit is None:\n                print(\"Sorry there is only one fruit left.\")\n                yield fruit, None\n                # We reached the end of the 'fruits' generator but raising a\n                # StopIteration instead of returning would create a RuntimeError\n                return\n            if next_fruit.is_tasty():\n                yield fruit, next_fruit\n                break\n"}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ment is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n            return False\n        for inner_else_statement in other_node_try_except.orelse:\n            if isinstance(inner_else_statement, nodes.Break):\n                break_stmt = inner_else_statement\n                break\n        else:\n            # No break statement\n            return False\n\n        def _try_in_loop_body(\n            other_node_try_except: nodes.Try,\n            loop: nodes.For | nodes.While,\n        ) -> bool:\n            \"\"\"Return True if `other_node_try_except` is a descendant of `loop`.\"\"\"\n            return any(\n                loop_body_statement is other_node_try_except\n                or loop_body_statement.parent_of(other_node_try_except)\n                for loop_body_statement in loop.body\n            )\n\n        if not _try_in_loop_body(other_node_try_except, closest_loop):\n            for ancestor in closest_loop.node_ancestors():\n                if isinstance(ancestor, (nodes.For, nodes.While)):\n                    if _try_in_loop_body(other_node_try_except, ancestor):\n                        break\n            else:\n                # `other_node_try_except` didn't have a shared ancestor loop\n                return False\n\n        for loop_stmt in closest_loop.body:\n            if NamesConsumer._recursive_search_for_continue_before_break(\n                loop_stmt, break_stmt\n            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n    @staticmethod\n    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement,\n        break_stmt: nodes.Break,\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = any(\n                isinstance(try_statement, nodes.Return)\n                for try_statement in closest_try_except.body\n            )\n            else_block_returns = any(\n                isinstance(else_statement, nodes.Return)\n                for else_statement in closest_try_except.orelse\n            )\n            else_block_exits = any(\n                isinstance(else_statement, nodes.Expr)\n                and isinstance(else_statement.value, nodes.Call)\n                and utils.is_terminating_func(else_statement.value)\n                for else_statement in closest_try_except.orelse\n            )\n            else_block_continues = any(\n                isinstance(else_statement, nodes.Continue)\n                for else_statement in closest_try_except.orelse\n            )\n            if (\n                else_block_continues\n                and isinstance(node_statement.parent, (nodes.For, nodes.While))\n                and closest_try_except.parent.parent_of(node_statement)\n            ):\n                continue\n\n            if try_block_returns or else_block_returns or else_block_exits:\n                # Exception: if this node is in the final block of the other_node_statement,\n                # it will execute before returning. Assume the except statements are uncertain.\n                if (\n                    isinstance(node_statement.parent, nodes.Try)\n                    and node_statement in node_statement.parent.finalbody\n                    and closest_try_except.parent.parent_of(node_statement)\n                ):\n                    uncertain_nodes.append(other_node)\n                # Or the node_statement is in the else block of the relevant Try\n                elif (\n                    isinstance(node_statement.parent, nodes.Try)\n                    and node_statement in node_statement.parent.orelse\n                    and closest_try_except.parent.parent_of(node_statement)\n                ):\n                    uncertain_nodes.append(other_nod"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "mccabe.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s.Break\n    | nodes.Global\n    | nodes.Return\n    | nodes.Expr\n    | nodes.Await\n)\n\n_SubGraphNodes: TypeAlias = nodes.If | nodes.Try | nodes.For | nodes.While\n_AppendableNodeT = TypeVar(\n    \"_AppendableNodeT\", bound=_StatementNodes | nodes.While | nodes.FunctionDef\n)\n\n\nclass PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n        super().__init__()\n        self._bottom_counter = 0\n        self.graph: PathGraph | None = None\n\n    def default(self, node: nodes.NodeNG, *args: Any) -> None:\n        for child in node.get_children():\n            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n            meth = getattr(self.visitor, \"visit\" + class_name, self.default)\n            self._cache[klass] = meth\n        return meth(node, *args)\n\n    def visitFunctionDef(self, node: nodes.FunctionDef) -> None:\n        if self.graph is not None:\n            # closure\n            pathnode = self._append_node(node)\n            self.tail = pathnode\n            self.dispatch_list(node.body)\n            bottom = f\"{self._bottom_counter}\"\n            self._bottom_counter += 1\n            self.graph.connect(self.tail, bottom)\n            self.graph.connect(node, bottom)\n            self.tail = bottom\n        else:\n            self.graph = PathGraph(node)\n            self.tail = node\n            self.dispatch_list(node.body)\n            self.graphs[f\"{self.classname}{node.name}\"] = self.graph\n            self.reset()\n\n    visitAsyncFunctionDef = visitFunctionDef\n\n    def visitSimpleStatement(self, node: _StatementNodes) -> None"}, {"start_line": 6000, "end_line": 7349, "belongs_to": {"file_name": "for_any_all.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/for_any_all", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "num)\n            potential_line_length_warning = True\n    return potential_line_length_warning\n\ns = [\"hi\", \"hello\", \"goodbye\", None]\n\nflag = True\nfor i, elem in enumerate(s):\n    if elem is None:\n        continue\n    cnt_s = cnt_t = 0\n    for j in range(i, len(s)):\n        if s[j] == elem:\n            cnt_s += 1\n            s[j] = None\n            Flag = False\n\ndef with_elif(split_lines, max_chars):\n    \"\"\"\n    Do not raise consider-using-any-or-all because the intent in this code\n    is to iterate over all the lines (not short-circuit) and see what\n    the last value would be.\n    \"\"\"\n    last_longest_line = False\n    for line in split_lines:\n        if len(line) > max_chars:\n            last_longest_line = True\n        elif len(line) == max_chars:\n            last_longest_line = False\n    return last_longest_line\n\ndef first_even(items):\n    \"\"\"Return first even number\"\"\"\n    for item in items:\n        if item % 2 == 0:\n            return item\n    return None\n\ndef even(items):\n    for item in items:\n        if item % 2 == 0:\n            return True\n    return None\n\ndef iterate_leaves(leaves, current_node):\n    results = []\n\n    current_node.was_checked = True\n    for leaf in leaves:\n        if isinstance(leaf, bool):\n            current_node.was_checked = False\n        else:\n            results.append(leaf)\n    return results\n"}, {"start_line": 2000, "end_line": 3322, "belongs_to": {"file_name": "consider_refactoring_into_while_condition.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  break\n            pri_candidates.append(n)\n        candidates = []\n        tainted = False\n        for c in pri_candidates:\n            if tainted or not isinstance(c.body[0], nodes.Break):\n                break\n            candidates.append(c)\n            orelse = c.orelse\n            while orelse:\n                orelse_node = orelse[0]\n                if not isinstance(orelse_node, nodes.If):\n                    tainted = True\n                else:\n                    candidates.append(orelse_node)\n                if not isinstance(orelse_node, nodes.If):\n                    break\n                orelse = orelse_node.orelse\n\n        candidates = [n for n in candidates if isinstance(n.body[0], nodes.Break)]\n        msg = \" and \".join(\n            [f\"({utils.not_condition_as_string(c.test)})\" for c in candidates]\n        )\n        if len(candidates) == 1:\n            msg = utils.not_condition_as_string(candidates[0].test)\n        if not msg:\n            return\n\n        self.add_message(\n            \"consider-refactoring-into-while-condition\",\n            node=node,\n            line=node.lineno,\n            args=(msg, node.test.as_string()),\n            confidence=HIGH,\n        )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(ConsiderRefactorIntoWhileConditionChecker(linter))\n"}, {"start_line": 3000, "end_line": 4505, "belongs_to": {"file_name": "stop_iteration_inside_generator.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cle():\n    counter = cycle('ABCD')\n    val = next(counter)\n    yield val\n\n\n# pylint: disable=too-few-public-methods\nclass SomeClassWithNext:\n    def next(self):\n        return iter([1, 2, 3])\n\n    def some_gen(self):\n        for value in self.next():\n            yield value\n\n\nSomeClassWithNext().some_gen()\n\n\ndef something_invalid():\n    raise Exception(\"cannot iterate this\")\n\n\ndef invalid_object_passed_to_next():\n    yield next(something_invalid())  # [stop-iteration-return]\n\n\n# pylint: disable=redefined-builtin,too-many-function-args\ndef safeiter(it):\n    \"\"\"Regression test for issue #7610 when ``next`` builtin is redefined\"\"\"\n\n    def next():\n        while True:\n            try:\n                return next(it)\n            except StopIteration:\n                raise\n\n    it = iter(it)\n    while True:\n        yield next()\n\ndef other_safeiter(it):\n    \"\"\"Regression test for issue #7610 when ``next`` builtin is redefined\"\"\"\n\n    def next(*things):\n        print(*things)\n        while True:\n            try:\n                return next(it)\n            except StopIteration:\n                raise\n\n    it = iter(it)\n    while True:\n        yield next(1, 2)\n\ndef data(filename):\n    \"\"\"\n    Ensure pylint doesn't crash if `next` is incorrectly called without args\n    See https://github.com/pylint-dev/pylint/issues/7828\n    \"\"\"\n    with open(filename, encoding=\"utf8\") as file:\n        next() # attempt to skip header but this is incorrect code\n        for line in file:\n            yield line\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "for_any_all.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/for_any_all", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ame in (\"Exception\", \"BaseException\")\n            and ancestor.root().name == \"Exception\"\n        ):\n            return True\n    return False\n\ndef no_suggestion_if_not_if():\n    \"\"\"Do not emit if the for loop does not have the pattern we are looking for\"\"\"\n    for val in range(1):\n        var = val\n        return var\n\ndef no_suggestion_if_not_bool(item):\n    \"\"\"Do not emit if the if-statement does not return a bool\"\"\"\n    for parent in item.parents():\n        if isinstance(parent, str):\n            return \"True\"\n    return \"False\"\n\ndef print_items(items):\n    \"\"\"Do not emit if there is no If condition in the for loop.\"\"\"\n    for item in items:\n        print(item)\n    return True\n\ndef print_items2(items):\n    \"\"\"Do not emit if anything besides a boolean is returned.\"\"\"\n    for item in items:\n        return item\n    return True\n\ndef print_items3(items):\n    \"\"\"Do not emit if anything besides a boolean is returned.\"\"\"\n    for _ in items:\n        return False\n    return items\n\ndef print_items4(items):\n    \"\"\"Do not emit if there is more logic which can cause side effects\n    or become less readable in a list comprehension.\n    \"\"\"\n    for item in items:\n        if isinstance(item, str):\n            print(item)\n            return False\n    return True\n\ndef is_from_decorator(node):\n    \"\"\"Do not emit if the if has an else condition. Generally implies more complicated logic.\"\"\"\n    for parent in node.node_ancestors():\n        if isinstance(parent, str): # pylint: disable=no-else-return\n            return True\n        else:\n            if parent in parent.selected_annotations:\n                return False\n            return False\n\ndef optimized_any_with_break(split_lines, max_chars):\n    \"\"\"False negative found in https://github.com/pylint-dev/pylint/pull/7697\"\"\"\n    potential_line_length_warning = False\n    for line in split_lines:  # [consider-using-any-or-all]\n        if len(line) > max_chars:\n            potential_line_length_warning = True\n            break\n    return "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "True\n        node = node.parent\n    return False\n\n\ndef _supports_protocol(\n    value: nodes.NodeNG, protocol_callback: Callable[[nodes.NodeNG], bool]\n) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if not has_known_bases(value):\n            return True\n        # classobj can only be iterable if it has an iterable metaclass\n        meta = value.metaclass()\n        if meta is not None:\n            if protocol_callback(meta):\n                return True\n    if isinstance(value, astroid.BaseInstance):\n        if not has_known_bases(value):\n            return True\n        if value.has_dynamic_getattr():\n            return True\n        if protocol_callback(value):\n            return True\n\n    if isinstance(value, nodes.ComprehensionScope):\n        return True\n\n    if (\n        isinstance(value, astroid.bases.Proxy)\n        and isinstance(value._proxied, astroid.BaseInstance)\n        and has_known_bases(value._proxied)\n    ):\n        value = value._proxied\n        return protocol_callback(value)\n\n    return False\n\n\ndef is_iterable(value: nodes.NodeNG, check_async: bool = False) -> bool:\n    if check_async:\n        protocol_check = _supports_async_iteration_protocol\n    else:\n        protocol_check = _supports_iteration_protocol\n    return _supports_protocol(value, protocol_check)\n\n\ndef is_mapping(value: nodes.NodeNG) -> bool:\n    return _supports_protocol(value, _supports_mapping_protocol)\n\n\ndef supports_membership_test(value: nodes.NodeNG) -> bool:\n    supported = _supports_protocol(value, _supports_membership_test_protocol)\n    return supported or is_iterable(value)\n\n\ndef supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getit"}], "retrieved_count": 10, "cost_time": 1.215561866760254}
{"question": "Why does the example function's docstring structure that starts with a blank line relate to the empty first line validation rule in the docstring style checker extension module?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 486, "belongs_to": {"file_name": "docstyle_first_line_empty.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docstyle", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Checks of Dosctrings 'docstring-first-line-empty'\"\"\"\n# pylint: disable=too-few-public-methods,bad-docstring-quotes\n\ndef check_messages(*messages):  # [docstring-first-line-empty]\n    \"\"\"\n    docstring\"\"\"\n    return messages\n\n\ndef function2():\n    \"\"\"Test Ok\"\"\"\n\n\nclass FFFF:  # [docstring-first-line-empty]\n    \"\"\"\n    Test Docstring First Line Empty\n    \"\"\"\n\n    def method1(self):  # [docstring-first-line-empty]\n        '''\n        Test Triple Single Quotes docstring\n        '''\n"}, {"start_line": 0, "end_line": 325, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/d/docstring-first-line-empty", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def foo():  # [docstring-first-line-empty]\n    \"\"\"\n    Lorem Ipsum is simply dummy text of the printing and typesetting\n    industry.\n\n    Lorem Ipsum has been the industry's standard dummy text ever since the\n    1500s, when an unknown printer took a galley of type and scrambled it\n    to make a type specimen book\n    \"\"\"\n"}, {"start_line": 1000, "end_line": 2953, "belongs_to": {"file_name": "docstyle.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Used when a blank line is found at the beginning of a docstring.\",\n        ),\n    }\n\n    @only_required_for_messages(\"docstring-first-line-empty\", \"bad-docstring-quotes\")\n    def visit_module(self, node: nodes.Module) -> None:\n        self._check_docstring(\"module\", node)\n\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        self._check_docstring(\"class\", node)\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        ftype = \"method\" if node.is_method() else \"function\"\n        self._check_docstring(ftype, node)\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_docstring(\n        self, node_type: str, node: nodes.Module | nodes.ClassDef | nodes.FunctionDef\n    ) -> None:\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring and docstring[0] == \"\\n\":\n            self.add_message(\n                \"docstring-first-line-empty\",\n                node=node,\n                args=(node_type,),\n                confidence=HIGH,\n            )\n\n        # Use \"linecache\", instead of node.as_string(), because the latter\n        # looses the original form of the docstrings.\n\n        if docstring:\n            lineno = node.fromlineno + 1\n            line = linecache.getline(node.root().file, lineno).lstrip()\n            if line and line.find('\"\"\"') == 0:\n                return\n            if line and \"'''\" in line:\n                quotes = \"'''\"\n            elif line and line[0] == '\"':\n                quotes = '\"'\n            elif line and line[0] == \"'\":\n                quotes = \"'\"\n            else:\n                quotes = \"\"\n            if quotes:\n                self.add_message(\n                    \"bad-docstring-quotes\",\n                    node=node,\n                    args=(node_type, quotes),\n                    confidence=HIGH,\n                )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(DocStringStyleChecker(linter))\n"}, {"start_line": 0, "end_line": 43, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/e/empty-docstring", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def foo():  # [empty-docstring]\n    \"\"\"\"\"\"\n"}, {"start_line": 0, "end_line": 914, "belongs_to": {"file_name": "trailing_whitespaces.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/t", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Regression test for trailing-whitespace (C0303).\"\"\"\n# pylint: disable=mixed-line-endings,pointless-string-statement\n\n# +1: [trailing-whitespace]\nprint('some trailing whitespace')   \n# +1: [trailing-whitespace]\nprint('trailing whitespace does not count towards the line length limit')                   \nprint('windows line ends are ok')\n# +1: [trailing-whitespace]\nprint('but trailing whitespace on win is not')   \n\n# Regression test for https://github.com/pylint-dev/pylint/issues/6936\n# +2: [trailing-whitespace]\n\"\"\" This module has the Board class.\n\"\"\" \n\n# +3: [trailing-whitespace]\n\"\"\" This module has the Board class.\nIt's a very nice Board.\n\"\"\" \n\n# Regression test for https://github.com/pylint-dev/pylint/issues/3822\ndef example(*args):\n    \"\"\"Example function.\"\"\"\n    print(*args)\n\n\nexample(\n    \"bob\", \"\"\"\n    foobar \n    more text\n\"\"\",\n)\n\nexample(\n    \"bob\",\n    \"\"\"\n    foobar2 \n    more text\n\"\"\",\n)\n"}, {"start_line": 0, "end_line": 268, "belongs_to": {"file_name": "empty_docstring.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/e", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'''''' # [empty-docstring]\n\n# pylint: disable=missing-module-docstring, missing-class-docstring, too-few-public-methods, pointless-string-statement\n\"\"\"Tests for empty-docstring\"\"\"\n\n\nclass MyClass:\n    def __init__(self, my_param: int) -> None:\n        '''\n        '''\n"}, {"start_line": 0, "end_line": 381, "belongs_to": {"file_name": "missing_param_doc_required_no_doc_rgx_default.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-param-doc and missing-type-doc for non-specified style docstrings\nwith accept-no-param-doc = no and the default value of no-docstring-rgx\n\"\"\"\n# pylint: disable=invalid-name, unused-argument\n\n\ndef _test_skip_no_docstring_rgx(x, y):\n    \"\"\"Example of a function that matches the default 'no-docstring-rgx' config option\n\n    No error message is emitted.\n    \"\"\"\n"}, {"start_line": 0, "end_line": 116, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/p/pointless-string-statement", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"This is a docstring which describes the module\"\"\"\n\n\"\"\"This is not a docstring\"\"\"  # [pointless-string-statement]\n"}, {"start_line": 0, "end_line": 421, "belongs_to": {"file_name": "missing_raises_doc_required_min_length.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/raise", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-raises-doc for non-specified style docstrings\nwith accept-no-raise-doc = no and docstring-min-length = 3\n\"\"\"\n# pylint: disable=invalid-name, broad-exception-raised\n\n# Example of a function that is less than 'docstring-min-length' config option\n# No error message is emitted.\ndef test_skip_docstring_min_length():\n    \"\"\"function is too short and is missing raise documentation\"\"\"\n    raise Exception\n"}, {"start_line": 0, "end_line": 330, "belongs_to": {"file_name": "missing_return_doc.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/return", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-return-doc and missing-return-type-doc\"\"\"\n# pylint: disable=function-redefined, invalid-name, undefined-variable, missing-function-docstring\n# pylint: disable=unused-argument\n\n\ndef ignores_no_docstring(self):\n    return False\n\n\ndef ignores_unknown_style(self):\n    \"\"\"This is a docstring.\"\"\"\n    return False\n"}], "retrieved_count": 10, "cost_time": 1.1930253505706787}
{"question": "Why does the inheritance chain from the base role class through the statement role class impact method resolution order computation performance when processing large batches of database query statement instances?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1072, "belongs_to": {"file_name": "roles.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes/nodes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class SQLRole(object):\n    ...\n\n\nclass UsesInspection(object):\n    ...\n\n\nclass AllowsLambdaRole(object):\n    ...\n\n\nclass ColumnArgumentRole(SQLRole):\n    ...\n\n\nclass ColumnArgumentOrKeyRole(ColumnArgumentRole):\n    ...\n\n\nclass ColumnListRole(SQLRole):\n    ...\n\n\nclass ColumnsClauseRole(AllowsLambdaRole, UsesInspection, ColumnListRole):\n    ...\n\n\nclass LimitOffsetRole(SQLRole):\n    ...\n\n\nclass ByOfRole(ColumnListRole):\n    ...\n\n\nclass OrderByRole(AllowsLambdaRole, ByOfRole):\n    ...\n\n\nclass StructuralRole(SQLRole):\n    ...\n\n\nclass ExpressionElementRole(SQLRole):\n    ...\n\n\nclass BinaryElementRole(ExpressionElementRole):\n    ...\n\n\nclass JoinTargetRole(AllowsLambdaRole, UsesInspection, StructuralRole):\n    ...\n\n\nclass FromClauseRole(ColumnsClauseRole, JoinTargetRole):\n    ...\n\n\nclass StrictFromClauseRole(FromClauseRole):\n    ...\n\n\nclass AnonymizedFromClauseRole(StrictFromClauseRole):\n    ...\n\n\nclass ReturnsRowsRole(SQLRole):\n    ...\n\n\nclass StatementRole(SQLRole):\n    ...\n\n\nclass DMLColumnRole(SQLRole):\n    ...\n\n\nclass DDLConstraintColumnRole(SQLRole):\n    ...\n"}, {"start_line": 0, "end_line": 667, "belongs_to": {"file_name": "main.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"This example is based on sqlalchemy.\n\nSee https://github.com/pylint-dev/pylint/issues/5679\n\"\"\"\nfrom other_funcs import FromClause\n\nfrom .nodes import roles\n\n\nclass HasMemoized(object):\n    ...\n\n\nclass Generative(HasMemoized):\n    ...\n\n\nclass ColumnElement(\n    roles.ColumnArgumentOrKeyRole,\n    roles.BinaryElementRole,\n    roles.OrderByRole,\n    roles.ColumnsClauseRole,\n    roles.LimitOffsetRole,\n    roles.DMLColumnRole,\n    roles.DDLConstraintColumnRole,\n    roles.StatementRole,\n    Generative,\n):\n    ...\n\n\nclass FunctionElement(ColumnElement, FromClause):\n    ...\n\n\nclass months_between(FunctionElement):\n    def __init__(self):\n        super().__init__()\n"}, {"start_line": 0, "end_line": 459, "belongs_to": {"file_name": "other_funcs.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/regrtest_data/max_inferable_limit_for_classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from operator import attrgetter\n\nfrom .nodes import roles\n\n\nclass HasCacheKey(object):\n    ...\n\n\nclass HasMemoized(object):\n    ...\n\n\nclass MemoizedHasCacheKey(HasCacheKey, HasMemoized):\n    ...\n\n\nclass ClauseElement(MemoizedHasCacheKey):\n    ...\n\n\nclass ReturnsRows(roles.ReturnsRowsRole, ClauseElement):\n    ...\n\n\nclass Selectable(ReturnsRows):\n    ...\n\n\nclass FromClause(roles.AnonymizedFromClauseRole, Selectable):\n    c = property(attrgetter(\"columns\"))\n"}, {"start_line": 0, "end_line": 462, "belongs_to": {"file_name": "object_as_class_attribute.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/o", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"Test case for the problem described below :\n - A class extends 'object'\n - This class defines its own __init__()\n   * pylint will therefore check that baseclasses' init()\n     are called\n - If this class defines an 'object' attribute, then pylint\n   will use this new definition when trying to retrieve\n   object.__init__()\n\"\"\"\n\n\nclass Statement:\n    \"\"\" ... \"\"\"\n    def __init__(self):\n        pass\n    object = None\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r)\n        else:\n            nb_bool_expr += 1\n    return nb_bool_expr\n\n\ndef _count_methods_in_class(node: nodes.ClassDef) -> int:\n    all_methods = sum(1 for method in node.methods() if not method.name.startswith(\"_\"))\n    # Special methods count towards the number of public methods,\n    # but don't count towards there being too many methods.\n    for method in node.mymethods():\n        if SPECIAL_OBJ.search(method.name) and method.name != \"__init__\":\n            all_methods += 1\n    return all_methods\n\n\ndef _get_parents_iter(\n    node: nodes.ClassDef, ignored_parents: frozenset[str]\n) -> Iterator[nodes.ClassDef]:\n    r\"\"\"Get parents of ``node``, excluding ancestors of ``ignored_parents``.\n\n    If we have the following inheritance diagram:\n\n             F\n            /\n        D  E\n         \\/\n          B  C\n           \\/\n            A      # class A(B, C): ...\n\n    And ``ignored_parents`` is ``{\"E\"}``, then this function will return\n    ``{A, B, C, D}`` -- both ``E`` and its ancestors are excluded.\n    \"\"\"\n    parents: set[nodes.ClassDef] = set()\n    to_explore = list(node.ancestors(recurs=False))\n    while to_explore:\n        parent = to_explore.pop()\n        if parent.qname() in ignored_parents:\n            continue\n        if parent not in parents:\n            # This guard might appear to be performing the same function as\n            # adding the resolved parents to a set to eliminate duplicates\n            # (legitimate due to diamond inheritance patterns), but its\n            # additional purpose is to prevent cycles (not normally possible,\n            # but potential due to inference) and thus guarantee termination\n            # of the while-loop\n            yield parent\n            parents.add(parent)\n            to_explore.extend(parent.ancestors(recurs=False))\n\n\ndef _get_parents(\n    node: nodes.ClassDef, ignored_parents: frozenset[str]\n) -> set[nodes.ClassDef]:\n    return set(_get_parents_iter(node, ignored_parents))\n\n\nclass MisdesignChecker(BaseChecker)"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   (\n            \"max-public-methods\",\n            {\n                \"default\": 20,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of public methods for a class \\\n(see R0904).\",\n            },\n        ),\n        (\n            \"max-bool-expr\",\n            {\n                \"default\": 5,\n                \"type\": \"int\",\n                \"metavar\": \"<num>\",\n                \"help\": \"Maximum number of boolean expressions in an if \"\n                \"statement (see R0916).\",\n            },\n        ),\n        (\n            \"exclude-too-few-public-methods\",\n            {\n                \"default\": [],\n                \"type\": \"regexp_csv\",\n                \"metavar\": \"<pattern>[,<pattern>...]\",\n                \"help\": \"List of regular expressions of class ancestor names \"\n                \"to ignore when counting public methods (see R0903)\",\n            },\n        ),\n    )\n\n    def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._returns: list[int]\n        self._branches: defaultdict[nodes.LocalsDictNodeNG, int]\n        self._stmts: list[int]\n\n    def open(self) -> None:\n        \"\"\"Initialize visit variables.\"\"\"\n        self.linter.stats.reset_node_count()\n        self._returns = []\n        self._branches = defaultdict(int)\n        self._stmts = []\n        self._exclude_too_few_public_methods = (\n            self.linter.config.exclude_too_few_public_methods\n        )\n\n    def _inc_all_stmts(self, amount: int) -> None:\n        for i, _ in enumerate(self._stmts):\n            self._stmts[i] += amount\n\n    @only_required_for_messages(\n        \"too-many-ancestors\",\n        \"too-many-instance-attributes\",\n        \"too-few-public-methods\",\n        \"too-many-public-methods\",\n    )\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check size of inheritance hierarchy and number of instance attributes.\"\"\"\n        parents = _get_parents(\n            node,\n            STDLIB"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "design_analysis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "init__(linter)\n        self._returns: list[int]\n        self._branches: defaultdict[nodes.LocalsDictNodeNG, int]\n        self._stmts: list[int]\n\n    def open(self) -> None:\n        \"\"\"Initialize visit variables.\"\"\"\n        self.linter.stats.reset_node_count()\n        self._returns = []\n        self._branches = defaultdict(int)\n        self._stmts = []\n        self._exclude_too_few_public_methods = (\n            self.linter.config.exclude_too_few_public_methods\n        )\n\n    def _inc_all_stmts(self, amount: int) -> None:\n        for i, _ in enumerate(self._stmts):\n            self._stmts[i] += amount\n\n    @only_required_for_messages(\n        \"too-many-ancestors\",\n        \"too-many-instance-attributes\",\n        \"too-few-public-methods\",\n        \"too-many-public-methods\",\n    )\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check size of inheritance hierarchy and number of instance attributes.\"\"\"\n        parents = _get_parents(\n            node,\n            STDLIB_CLASSES_IGNORE_ANCESTOR.union(self.linter.config.ignored_parents),\n        )\n        nb_parents = len(parents)\n        if nb_parents > self.linter.config.max_parents:\n            self.add_message(\n                \"too-many-ancestors\",\n                node=node,\n                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n        # https://github.com/pylint-dev/astroid/issues/2273\n        root = node.root()\n        filtered_attrs = [\n            k for (k, v) in node.instance_attrs.items() if v[0].root() is root\n        ]\n        if len(filtered_attrs) > self.linter.config.max_attributes:\n            self.add_message(\n                \"too-many-instance-attributes\",\n                node=node,\n"}, {"start_line": 0, "end_line": 1698, "belongs_to": {"file_name": "init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods, import-error, missing-docstring, wrong-import-position\n# pylint: disable=useless-super-delegation, unnecessary-pass\n\n\nfrom typing import overload\n\nfrom missing import Missing\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass BBBB:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass CCCC:\n    \"\"\"ancestor 3\"\"\"\n\n\nclass ZZZZ(AAAA, BBBB, CCCC):\n    \"\"\"derived class\"\"\"\n\n    def __init__(self):  # [super-init-not-called]\n        AAAA.__init__(self)\n\n\nclass NewStyleA:\n    \"\"\"new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        print(\"init\", self)\n\n\nclass NewStyleB(NewStyleA):\n    \"\"\"derived new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n\nclass NewStyleC:\n    \"\"\"__init__ defined by assignment.\"\"\"\n\n    def xx_init(self):\n        \"\"\"Initializer.\"\"\"\n        pass\n\n    __init__ = xx_init\n\n\nclass AssignedInit(NewStyleC):\n    \"\"\"No init called, but abstract so that is fine.\"\"\"\n\n    def __init__(self):\n        self.arg = 0\n\n\nclass UnknownBases(Missing):\n    \"\"\"No false positives if the bases aren't known.\"\"\"\n\n\nclass Parent:\n    def __init__(self, num: int):\n        self.number = num\n\n\nclass Child(Parent):\n    @overload\n    def __init__(self, num: int):\n        ...\n\n    @overload\n    def __init__(self, num: float):\n        ...\n\n    def __init__(self, num):\n        super().__init__(round(num))\n\n\n# https://github.com/pylint-dev/pylint/issues/7742\n# Crash when parent class has a class attribute named `__init__`\nclass NoInitMethod:\n    __init__ = 42\n\n\nclass ChildNoInitMethod(NoInitMethod):\n    def __init__(self):\n        ...\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nsion,\n    is_iterable,\n    is_property_setter,\n    is_property_setter_or_deleter,\n    node_frame_class,\n    only_required_for_messages,\n    safe_infer,\n    unimplemented_abstract_methods,\n    uninferable_final_decorators,\n)\nfrom pylint.interfaces import HIGH, INFERENCE\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\n_AccessNodes: TypeAlias = nodes.Attribute | nodes.AssignAttr\n\nINVALID_BASE_CLASSES = {\"bool\", \"range\", \"slice\", \"memoryview\"}\nALLOWED_PROPERTIES = {\"bultins.property\", \"functools.cached_property\"}\nBUILTIN_DECORATORS = {\"builtins.property\", \"builtins.classmethod\"}\nASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),\n}\n\n# Dealing with useless override detection, with regard\n# to parameters vs arguments\n\n\nclass _CallSignature(NamedTuple):\n    args: list[str | None]\n    kws: dict[str | None, str | None]\n    starred_args: list[str]\n    starred_kws: list[str]\n\n\nclass _ParameterSignature(NamedTuple):\n    args: list[str]\n    kwonlyargs: list[str]\n    varargs: str\n    kwargs: str\n\n\ndef _signature_from_call(call: nodes.Call) -> _CallSignature:\n    kws = {}\n    args = []\n    starred_kws = []\n    starred_args = []\n    for keyword in call.keywords or []:\n        arg, value = keyword.arg, keyword.value\n        if arg is None and isinstance(value, nodes.Name):\n            # Starred node, and we are interested only in names,\n            # otherwise some transformation might occur for the parameter.\n            starred_kws.append(value.name)\n        elif isinstance(value, nodes.Name):\n            kws[arg] = value.name\n        else:\n            kws[arg] = None\n\n    for arg in call.args:\n        if isinstance(arg, nodes.Star"}, {"start_line": 3000, "end_line": 4523, "belongs_to": {"file_name": "super_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "or pylint-dev/pylint/issues/773\nimport subprocess\n\n# The problem was related to astroid not filtering statements\n# at scope level properly, basically not doing strong updates.\ntry:\n    TimeoutExpired = subprocess.TimeoutExpired\nexcept AttributeError:\n    class TimeoutExpired(subprocess.CalledProcessError):\n        def __init__(self):\n            returncode = -1\n            self.timeout = -1\n            super(TimeoutExpired, self).__init__(\"\", returncode)\n\n\nclass SuperWithType:\n    \"\"\"type(self) may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(type(self), self).__init__() # [bad-super-call]\n\nclass SuperWithSelfClass:\n    \"\"\"self.__class__ may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(self.__class__, self).__init__() # [bad-super-call]\n\n\n# Reported in https://github.com/pylint-dev/pylint/issues/2903\nclass Parent:\n    def method(self):\n        print()\n\n\nclass Child(Parent):\n    def method(self):\n        print(\"Child\")\n        super().method()\n\nclass Niece(Parent):\n    def method(self):\n        print(\"Niece\")\n        super().method()\n\nclass GrandChild(Child):\n    def method(self):\n        print(\"Grandchild\")\n        super(GrandChild, self).method()\n        super(Child, self).method()\n        super(Niece, self).method()  # [bad-super-call]\n\n\n# Reported in https://github.com/pylint-dev/pylint/issues/4922\nclass AlabamaCousin(Child, Niece):\n    def method(self):\n        print(\"AlabamaCousin\")\n        super(Child, self).method()\n"}], "retrieved_count": 10, "cost_time": 1.2219254970550537}
{"question": "Why does the function that yields values in the assignment-from-no-return test use yield instead of return to validate exclusion from the no-return checker?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1780, "belongs_to": {"file_name": "assignment_from_no_return_2.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assignment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=useless-return, condition-evals-to-constant, invalid-name\n\"\"\"check assignment to function call where the function doesn't return\n\n    'E1111': ('Assigning to function call which doesn\\'t return',\n              'Used when an assignment is done on a function call but the \\\n              inferred function doesn\\'t return anything.'),\n    'W1111': ('Assigning to function call which only returns None',\n              'Used when an assignment is done on a function call but the \\\n              inferred function returns nothing but None.'),\n\n\"\"\"\n\ndef func_no_return():\n    \"\"\"function without return\"\"\"\n    print('dougloup')\n\nA = func_no_return()  # [assignment-from-no-return]\n\n\ndef func_return_none():\n    \"\"\"function returning none\"\"\"\n    print('dougloup')\n    return None\n\nA = func_return_none()  # [assignment-from-none]\n\n\ndef func_implicit_return_none():\n    \"\"\"Function returning None from bare return statement.\"\"\"\n    return\n\nA = func_implicit_return_none()  # [assignment-from-none]\n\nlst = [3, 2]\nA = lst.sort()  # [assignment-from-no-return]\nmy_dict = {3: 2}\nB = my_dict.update({2: 1})  # [assignment-from-no-return]\nmy_set = set()\nC = my_set.symmetric_difference_update([6])  # [assignment-from-no-return]\n\ndef func_return_none_and_smth():\n    \"\"\"function returning none and something else\"\"\"\n    print('dougloup')\n    if 2 or 3:\n        return None\n    return 3\n\nA = func_return_none_and_smth()\n\ndef generator():\n    \"\"\"no problemo\"\"\"\n    yield 2\n\nA = generator()\n\nclass Abstract:\n    \"\"\"bla bla\"\"\"\n\n    def abstract_method(self):\n        \"\"\"use to return something in concrete implementation\"\"\"\n        raise NotImplementedError\n\n    def use_abstract(self):\n        \"\"\"should not issue E1111\"\"\"\n        var = self.abstract_method()\n        print(var)\n"}, {"start_line": 0, "end_line": 75, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/a/assignment-from-none", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def function():\n    return None\n\n\nf = function()  # [assignment-from-none]\n"}, {"start_line": 0, "end_line": 383, "belongs_to": {"file_name": "yield_assign.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/y", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=use-yield-from\n\"\"\"https://www.logilab.org/ticket/8771\"\"\"\n\n\ndef generator():\n    \"\"\"yield as assignment\"\"\"\n    yield 45\n    xxxx = yield 123\n    print(xxxx)\n\ndef generator_fp1(seq):\n    \"\"\"W0631 false positive\"\"\"\n    for val in seq:\n        pass\n    for val in seq:\n        yield val\n\ndef generator_fp2():\n    \"\"\"E0601 false positive\"\"\"\n    xxxx = 12\n    yield xxxx\n"}, {"start_line": 0, "end_line": 210, "belongs_to": {"file_name": "yield_from_outside_func.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/y", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"This is grammatically correct, but it's still a SyntaxError\"\"\"\n# pylint: disable=unnecessary-lambda-assignment\n\nyield from [1, 2]  # [yield-outside-function]\n\nlambda_with_yield = lambda: (yield from [1, 2])\n"}, {"start_line": 0, "end_line": 483, "belongs_to": {"file_name": "missing_yield_doc_required.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/yield", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-yield-doc and missing-yield-type-doc with accept-no-yields-doc = no\"\"\"\n# pylint: disable=missing-function-docstring, unused-argument, function-redefined\n\nfrom typing import Iterator\n\n\n# Test missing docstring\ndef my_func(self):  # [missing-yield-doc, missing-yield-type-doc]\n    yield False\n\n\n# This function doesn't require a docstring, because its name starts\n# with an '_' (no-docstring-rgx):\ndef _function(some_arg: int) -> Iterator[int]:\n    yield some_arg\n"}, {"start_line": 0, "end_line": 75, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/y/yield-inside-async-function", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "async def foo():\n    yield from [1, 2, 3]  # [yield-inside-async-function]\n"}, {"start_line": 0, "end_line": 151, "belongs_to": {"file_name": "yield_from_iterable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/y", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nCheck that `yield from`-statement takes an iterable.\n\"\"\"\n# pylint: disable=missing-docstring\n\ndef to_ten():\n    yield from 10  # [not-an-iterable]\n"}, {"start_line": 0, "end_line": 100, "belongs_to": {"file_name": "good.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/y/yield-inside-async-function", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "async def foo():\n    def _inner_foo():\n        yield from [1, 2, 3]\n\n\nasync def foo():\n    yield 42\n"}, {"start_line": 0, "end_line": 60, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/y/yield-outside-function", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "for i in range(10):\n    yield i  # [yield-outside-function]\n"}, {"start_line": 0, "end_line": 823, "belongs_to": {"file_name": "too_many_return_statements.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/t/too", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\n\ndef stupid_function(arg): # [too-many-return-statements]\n    if arg == 1:\n        return 1\n    if arg == 2:\n        return 2\n    if arg == 3:\n        return 3\n    if arg == 4:\n        return 4\n    if arg == 5:\n        return 5\n    if arg == 6:\n        return 6\n    if arg == 7:\n        return 7\n    if arg == 8:\n        return 8\n    if arg == 9:\n        return 9\n    if arg == 10:\n        return 10\n    return None\n\n\ndef many_yield(text):\n    \"\"\"Not a problem\"\"\"\n    if text:\n        yield f\"    line 1: {text}\\n\"\n        yield \"    line 2\\n\"\n        yield \"    line 3\\n\"\n        yield \"    line 4\\n\"\n        yield \"    line 5\\n\"\n    else:\n        yield \"    line 6\\n\"\n        yield \"    line 7\\n\"\n        yield \"    line 8\\n\"\n        yield \"    line 9\\n\"\n        yield \"    line 10\\n\"\n"}], "retrieved_count": 10, "cost_time": 1.212033748626709}
{"question": "Why does repeatedly instantiating the mock linter, AST walker, and test checker in the message filtering decorator test method degrade performance across thousands of similar test cases?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport warnings\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers.base_checker import BaseChecker\nfrom pylint.checkers.utils import only_required_for_messages\nfrom pylint.utils import ASTWalker\n\n\nclass TestASTWalker:\n    class MockLinter:\n        def __init__(self, msgs: dict[str, bool]) -> None:\n            self._msgs = msgs\n\n        def is_message_enabled(self, msgid: str) -> bool:\n            return self._msgs.get(msgid, True)\n\n    class Checker(BaseChecker):\n        # pylint: disable-next=super-init-not-called\n        def __init__(self) -> None:\n            self.called: set[str] = set()\n\n        @only_required_for_messages(\"first-message\")\n        def visit_module(\n            self, module: nodes.Module  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = f"}, {"start_line": 1000, "end_line": 2877, "belongs_to": {"file_name": "unittest_ast_walker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/utils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"module\")\n\n        @only_required_for_messages(\"second-message\")\n        def visit_call(self, module: nodes.Call) -> None:\n            raise NotImplementedError\n\n        @only_required_for_messages(\"second-message\", \"third-message\")\n        def visit_assignname(\n            self, module: nodes.AssignName  # pylint: disable=unused-argument\n        ) -> None:\n            self.called.add(\"assignname\")\n\n        @only_required_for_messages(\"second-message\")\n        def leave_assignname(self, module: nodes.AssignName) -> None:\n            raise NotImplementedError\n\n    def test_only_required_for_messages(self) -> None:\n        linter = self.MockLinter(\n            {\"first-message\": True, \"second-message\": False, \"third-message\": True}\n        )\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = self.Checker()\n        walker.add_checker(checker)\n        walker.walk(astroid.parse(\"x = func()\"))\n        assert {\"module\", \"assignname\"} == checker.called\n\n    def test_deprecated_methods(self) -> None:\n        class Checker(BaseChecker):\n            # pylint: disable-next=super-init-not-called\n            def __init__(self) -> None:\n                self.called = False\n\n            @only_required_for_messages(\"first-message\")\n            def visit_assname(\n                self, node: nodes.AssignName  # pylint: disable=unused-argument\n            ) -> None:\n                self.called = True\n\n        linter = self.MockLinter({\"first-message\": True})\n        walker = ASTWalker(linter)  # type: ignore[arg-type]\n        checker = Checker()\n        walker.add_checker(checker)\n        with warnings.catch_warnings(record=True):\n            warnings.simplefilter(\"always\")\n            walker.walk(astroid.parse(\"x = 1\"))\n\n            assert not checker.called\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "checker_test_case.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport contextlib\nfrom collections.abc import Generator, Iterator\nfrom typing import Any\n\nfrom astroid import nodes\n\nfrom pylint.testutils.global_test_linter import linter\nfrom pylint.testutils.output_line import MessageTest\nfrom pylint.testutils.unittest_linter import UnittestLinter\nfrom pylint.utils import ASTWalker\n\n\nclass CheckerTestCase:\n    \"\"\"A base testcase class for unit testing individual checker classes.\"\"\"\n\n    # TODO: Figure out way to type this as type[BaseChecker] while also\n    # setting self.checker correctly.\n    CHECKER_CLASS: Any\n    CONFIG: dict[str, Any] = {}\n\n    def setup_method(self) -> None:\n        self.linter = UnittestLinter()\n        self.checker = self.CHECKER_CLASS(self.linter)\n        for key, value in self.CONFIG.items():\n            setattr(self.checker.linter.config, key, value)\n        self.checker.open()\n\n    @contextlib.contextmanager\n    def assertNoMessages(self) -> Iterator[None]:\n        \"\"\"Assert that no messages are added by the given method.\"\"\"\n        with self.assertAddsMessages():\n            yield\n\n    @contextlib.contextmanager\n    def assertAddsMessages(\n        self, *messages: MessageTest, ignore_position: bool = False\n    ) -> Generator[None]:\n        \"\"\"Assert that exactly the given method adds the given messages.\n\n        The list of messages must exactly match *all* the messages added by the\n        method. Additionally, we check to see whether the args in each message can\n        actually be substituted into the message string.\n\n        Using the keyword argument `ignore_position`, all checks for position\n        arguments (line, col_offset, ...) will be skipped. This can be used to\n        just test messages for the correct node.\n        \"\"\"\n  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "unittest_linter.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/testutils", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=duplicate-code\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.lint import PyLinter\nfrom pylint.testutils.output_line import MessageTest\n\n\nclass UnittestLinter(PyLinter):\n    \"\"\"A fake linter class to capture checker messages.\"\"\"\n\n    def __init__(self) -> None:\n        self._messages: list[MessageTest] = []\n        super().__init__()\n\n    def release_messages(self) -> list[MessageTest]:\n        try:\n            return self._messages\n        finally:\n            self._messages = []\n\n    def add_message(\n        self,\n        msgid: str,\n        line: int | None = None,\n        # TODO: Make node non optional\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"Add a MessageTest to the _messages attribute of the linter class.\"\"\"\n        # If confidence is None we set it to UNDEFINED as well in PyLinter\n        if confidence is None:\n            confidence = UNDEFINED\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n                    line = node.position.lineno\n                if not col_offset:\n                    col_offset = node.position.col_offset\n                if not end_lineno:\n                    end_lineno = node.position.end_lineno\n                if not end_col_offset:\n                    end_col_offset = node.position.end_col_offset\n            else:\n                if not line:\n                    line ="}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_func.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ompile(filter_rgx).search\n    else:\n        is_to_run = (  # noqa: E731 we're going to throw all this anyway\n            lambda x: 1  # type: ignore[assignment] # pylint: disable=unnecessary-lambda-assignment\n        )\n    tests: list[tuple[str, str, list[tuple[str, str]]]] = []\n    for module_file, messages_file in _get_tests_info(INPUT_DIR, MSG_DIR, \"func_\", \"\"):\n        if not is_to_run(module_file) or module_file.endswith((\".pyc\", \"$py.class\")):\n            continue\n        base = module_file.replace(\".py\", \"\").split(\"_\")[1]\n        dependencies = _get_tests_info(INPUT_DIR, MSG_DIR, base, \".py\")\n        tests.append((module_file, messages_file, dependencies))\n    if UPDATE_FILE.exists():\n        return tests\n    assert len(tests) < 13, \"Please do not add new test cases here.\" + \"\\n\".join(\n        str(k) for k in tests if not k[2]\n    )\n    return tests\n\n\nTEST_WITH_EXPECTED_DEPRECATION = [\"func_excess_escapes.py\"]\n\n\n@pytest.mark.parametrize(\n    \"module_file,messages_file,dependencies\",\n    gen_tests(FILTER_RGX),\n    ids=[o[0] for o in gen_tests(FILTER_RGX)],\n)\ndef test_functionality(\n    module_file: str,\n    messages_file: str,\n    dependencies: list[tuple[str, str]],\n    recwarn: pytest.WarningsRecorder,\n) -> None:\n    __test_functionality(module_file, messages_file, dependencies)\n    if recwarn.list:\n        if module_file in TEST_WITH_EXPECTED_DEPRECATION and sys.version_info.minor > 5:\n            assert any(\n                \"invalid escape sequence\" in str(i.message)\n                for i in recwarn.list\n                if issubclass(i.category, DeprecationWarning)\n            )\n\n\ndef __test_functionality(\n    module_file: str, messages_file: str, dependencies: list[tuple[str, str]]\n) -> None:\n    lint_test = LintTestUpdate() if UPDATE_FILE.exists() else LintTestUsingModule()\n    lint_test.module = module_file.replace(\".py\", \"\")\n    lint_test.output = messages_file\n    lint_test.depends = dependencies or None\n    lint_test.INPUT_DIR = INPUT_DIR\n    lint_te"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conftest.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n# pylint: disable=redefined-outer-name\n\nfrom __future__ import annotations\n\nfrom collections.abc import ValuesView\n\nimport pytest\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.lint.pylinter import PyLinter\nfrom pylint.message import MessageDefinition, MessageDefinitionStore, MessageIdStore\n\n\n@pytest.fixture\ndef msgid():\n    return \"W1234\"\n\n\n@pytest.fixture\ndef symbol():\n    return \"msg-symbol\"\n\n\n@pytest.fixture\ndef empty_store() -> MessageDefinitionStore:\n    return MessageDefinitionStore()\n\n\n@pytest.fixture\ndef store() -> MessageDefinitionStore:\n    store_ = MessageDefinitionStore()\n\n    class Checker(BaseChecker):\n        def __init__(self) -> None:\n            super().__init__(PyLinter())\n\n        name = \"achecker\"\n        msgs = {\n            \"W1234\": (\n                \"message\",\n                \"msg-symbol\",\n                \"msg description.\",\n                {\"old_names\": [(\"W0001\", \"old-symbol\")]},\n            ),\n            \"E1234\": (\n                \"Duplicate keyword argument %r in %s call\",\n                \"duplicate-keyword-arg\",\n                \"Used when a function call passes the same keyword argument multiple times.\",\n                {\"maxversion\": (2, 6)},\n            ),\n        }\n\n    store_.register_messages_from_checker(Checker())\n    return store_\n\n\n@pytest.fixture\ndef message_definitions(store: MessageDefinitionStore) -> ValuesView[MessageDefinition]:\n    return store.messages\n\n\n@pytest.fixture\ndef msgids() -> dict[str, str]:\n    return {\n        \"W1234\": \"warning-symbol\",\n        \"W1235\": \"warning-symbol-two\",\n        \"C1234\": \"convention-symbol\",\n        \"E1234\": \"error-symbol\",\n    }\n\n\n@pytest.fixture\ndef empty_msgid_store() -> MessageIdStore:\n    return MessageIdStore()\n\n\n@pytest.fixture\ndef msgid_store(ms"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_func.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "GenericTestReporter)\n        self._check_result(self.linter.reporter.finalize())\n\n    def _has_output(self) -> bool:\n        return isinstance(self.module, str) and not self.module.startswith(\n            \"func_noerror_\"\n        )\n\n    def _get_expected(self) -> str:\n        if self._has_output() and self.output:\n            with open(self.output, encoding=\"utf-8\") as fobj:\n                return fobj.read().strip() + \"\\n\"\n        else:\n            return \"\"\n\n\nclass LintTestUpdate(LintTestUsingModule):\n    def _check_result(self, got: str) -> None:\n        if not self._has_output():\n            return\n        try:\n            expected = self._get_expected()\n        except OSError:\n            expected = \"\"\n        if got != expected:\n            with open(self.output or \"\", \"w\", encoding=\"utf-8\") as f:\n                f.write(got)\n\n\ndef gen_tests(\n    filter_rgx: str | re.Pattern[str] | None,\n) -> list[tuple[str, str, list[tuple[str, str]]]]:\n    if filter_rgx:\n        is_to_run = re.compile(filter_rgx).search\n    else:\n        is_to_run = (  # noqa: E731 we're going to throw all this anyway\n            lambda x: 1  # type: ignore[assignment] # pylint: disable=unnecessary-lambda-assignment\n        )\n    tests: list[tuple[str, str, list[tuple[str, str]]]] = []\n    for module_file, messages_file in _get_tests_info(INPUT_DIR, MSG_DIR, \"func_\", \"\"):\n        if not is_to_run(module_file) or module_file.endswith((\".pyc\", \"$py.class\")):\n            continue\n        base = module_file.replace(\".py\", \"\").split(\"_\")[1]\n        dependencies = _get_tests_info(INPUT_DIR, MSG_DIR, base, \".py\")\n        tests.append((module_file, messages_file, dependencies))\n    if UPDATE_FILE.exists():\n        return tests\n    assert len(tests) < 13, \"Please do not add new test cases here.\" + \"\\n\".join(\n        str(k) for k in tests if not k[2]\n    )\n    return tests\n\n\nTEST_WITH_EXPECTED_DEPRECATION = [\"func_excess_escapes.py\"]\n\n\n@pytest.mark.parametrize(\n    \"module_file,messages_file,dependenci"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_path\n        with lint.augmented_sys_path(extra_sys_paths):\n            assert sys.path == expected\n        assert sys.path == fake_path\n\n\n@pytest.fixture(scope=\"module\")\ndef disable() -> list[str]:\n    return [\"I\"]\n\n\n@pytest.fixture(scope=\"module\")\ndef reporter() -> type[testutils.GenericTestReporter]:\n    return testutils.GenericTestReporter\n\n\n@pytest.fixture\ndef initialized_linter(linter: PyLinter) -> PyLinter:\n    linter.open()\n    linter.set_current_module(\"long_test_file\", \"long_test_file\")\n    linter.file_state = FileState(\n        \"long_test_file\",\n        linter.msgs_store,\n        linter.get_ast(\n            str(join(REGRTEST_DATA_DIR, \"long_test_file.py\")), \"long_test_file\"\n        ),\n    )\n    return linter\n\n\ndef test_pylint_visit_method_taken_in_account(linter: PyLinter) -> None:\n    class CustomChecker(checkers.BaseChecker):\n        name = \"custom\"\n        msgs = {\"W9999\": (\"\", \"custom\", \"\")}\n\n        @only_required_for_messages(\"custom\")\n        def visit_class(self, _: nodes.ClassDef) -> None:\n            pass\n\n    linter.register_checker(CustomChecker(linter))\n    linter.open()\n    out = StringIO()\n    linter.set_reporter(text.TextReporter(out))\n    linter.check([\"abc\"])\n\n\ndef test_enable_message(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.disable(\"W0101\", scope=\"package\")\n    linter.disable(\"W0102\", scope=\"module\", line=1)\n    assert not linter.is_message_enabled(\"W0101\")\n    assert not linter.is_message_enabled(\"W0102\", 1)\n    linter.set_current_module(\"tutu\")\n    assert not linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.enable(\"W0101\", scope=\"package\")\n    linter.enable(\"W0102\", scope=\"module\", line=1)\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\", 1)\n\n\ndef test_enable_message_category(initialized_linter: PyLinter) -> None:\n    l"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "unittest_lint.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/lint", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " nodes.ClassDef) -> None:\n            pass\n\n    linter.register_checker(CustomChecker(linter))\n    linter.open()\n    out = StringIO()\n    linter.set_reporter(text.TextReporter(out))\n    linter.check([\"abc\"])\n\n\ndef test_enable_message(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.disable(\"W0101\", scope=\"package\")\n    linter.disable(\"W0102\", scope=\"module\", line=1)\n    assert not linter.is_message_enabled(\"W0101\")\n    assert not linter.is_message_enabled(\"W0102\", 1)\n    linter.set_current_module(\"tutu\")\n    assert not linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\")\n    linter.enable(\"W0101\", scope=\"package\")\n    linter.enable(\"W0102\", scope=\"module\", line=1)\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"W0102\", 1)\n\n\ndef test_enable_message_category(initialized_linter: PyLinter) -> None:\n    linter = initialized_linter\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"C0202\")\n    linter.disable(\"W\", scope=\"package\")\n    linter.disable(\"C\", scope=\"module\", line=1)\n    assert not linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"C0202\")\n    assert not linter.is_message_enabled(\"C0202\", line=1)\n    linter.set_current_module(\"tutu\")\n    assert not linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"C0202\")\n    linter.enable(\"W\", scope=\"package\")\n    linter.enable(\"C\", scope=\"module\", line=1)\n    assert linter.is_message_enabled(\"W0101\")\n    assert linter.is_message_enabled(\"C0202\")\n    assert linter.is_message_enabled(\"C0202\", line=1)\n\n\ndef test_message_state_scope(initialized_linter: PyLinter) -> None:\n    class FakeConfig(argparse.Namespace):\n        confidence = [\"HIGH\"]\n\n    linter = initialized_linter\n    linter.disable(\"C0202\")\n    assert MSG_STATE_SCOPE_CONFIG == linter._get_message_state_scope"}, {"start_line": 9000, "end_line": 10805, "belongs_to": {"file_name": "unittest_message_definition_store.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/message", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Used when a function call passes the same keyword argument multiple times.\n  This message can't be emitted when using Python >= 2.6.\"\"\",\n            message_definition,\n            checkerref=False,\n        )\n\n\ndef test_list_messages(store: MessageDefinitionStore) -> None:\n    output = StringIO()\n    with redirect_stdout(output):\n        store.list_messages()\n    # cursory examination of the output: we're mostly testing it completes\n    assert \":msg-symbol (W1234): *message*\" in output.getvalue()\n\n\ndef test_renamed_message_register(store: MessageDefinitionStore) -> None:\n    assert store.get_message_definitions(\"W0001\")[0].symbol == \"msg-symbol\"\n    assert store.get_message_definitions(\"old-symbol\")[0].symbol == \"msg-symbol\"\n\n\ndef test_multiple_child_of_old_name(store: MessageDefinitionStore) -> None:\n    \"\"\"We can define multiple name with the same old name.\"\"\"\n\n    class FamillyChecker(BaseChecker):\n        def __init__(self) -> None:\n            super().__init__(PyLinter())\n\n        name = \"famillychecker\"\n        msgs = {\n            \"W1235\": (\n                \"Child 1\",\n                \"child-one\",\n                \"Child one description.\",\n                {\"old_names\": [(\"C1234\", \"mother\")]},\n            ),\n            \"W1236\": (\n                \"Child 2\",\n                \"child-two\",\n                \"Child two description\",\n                {\"old_names\": [(\"C1234\", \"mother\")]},\n            ),\n        }\n\n    store.register_messages_from_checker(FamillyChecker())\n    mother = store.get_message_definitions(\"C1234\")\n    child = store.get_message_definitions(\"W1235\")\n    other_child = store.get_message_definitions(\"W1236\")\n    assert len(mother) == 2\n    assert len(child) == 1\n    assert len(other_child) == 1\n    assert child[0] in mother\n    assert other_child[0] in mother\n"}], "retrieved_count": 10, "cost_time": 1.2183752059936523}
{"question": "Why does the property method that provides controlled access to a private attribute serve as a controlled accessor in the encapsulation pattern demonstrated by the test class?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 396, "belongs_to": {"file_name": "regression_property_slots_2439.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,invalid-name,too-few-public-methods\n# https://github.com/pylint-dev/pylint/issues/2439\nclass TestClass:\n    __slots__ = [\"_i\"]\n\n    def __init__(self):\n        self._i = 0\n\n    @property\n    def i(self):\n        return self._i\n\n    @i.setter\n    def i(self, v):\n        self._i = v\n\n    other = i\n\n\ninstance = TestClass()\ninstance.other = 42\nprint(instance.i)\n"}, {"start_line": 0, "end_line": 447, "belongs_to": {"file_name": "property_affectation_py26.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/p", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods\n\"\"\"\nSimple test case for an annoying behavior in pylint.\n\"\"\"\n\n\nclass Test:\n    \"\"\"Smallest test case for reported issue.\"\"\"\n\n    def __init__(self):\n        self._thing = None\n\n    @property\n    def myattr(self):\n        \"\"\"Getter for myattr\"\"\"\n        return self._thing\n\n    @myattr.setter\n    def myattr(self, value):\n        \"\"\"Setter for myattr.\"\"\"\n        self._thing = value\n\nTest().myattr = 'grou'\n"}, {"start_line": 0, "end_line": 393, "belongs_to": {"file_name": "regression_property_no_member_844.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods,invalid-overridden-method\n# https://github.com/pylint-dev/pylint/issues/844\nclass Parent:\n    def __init__(self):\n        self.__thing = 'foo'\n\n    @property\n    def thing(self):\n        return self.__thing\n\n\nclass Child(Parent):\n    @Parent.thing.getter\n    def thing(self):\n        return super().thing + '!'\n\n\nprint(Child().thing)\n"}, {"start_line": 0, "end_line": 514, "belongs_to": {"file_name": "regression_protected_access.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test for the regression on (outer)-class traversal for private methods\nMyClass does not have an outerclass which previously crashed the protected-access check\n\"\"\"\n# pylint: disable=too-few-public-methods\n\n\nclass MyClass:\n    \"\"\"Test class\"\"\"\n\n    @staticmethod\n    def _a_private_method():\n        \"\"\"Private method that references the class itself\"\"\"\n        return MySecondClass.MyClass._a_private_method()  # [protected-access]\n\n\nclass MySecondClass:\n    \"\"\"Class that uses MyClass\"\"\"\n\n    MyClass = MyClass\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hing(self):\n        \"\"\" Unsets a property. \"\"\"\n        self.thing = False\n\n    def complicated_example(self, flag):\n        def __inner_1():\n            pass\n\n        def __inner_2():\n            pass\n\n        def __inner_3(fn):\n            return fn\n\n        def __inner_4():  # [unused-private-member]\n            pass\n\n        fn_to_return = __inner_1 if flag else __inner_3(__inner_2)\n        return fn_to_return\n\n\n# https://github.com/pylint-dev/pylint/issues/4755\n# Nested attributes shouldn't cause crash\nclass Crash4755Context:\n    def __init__(self):\n        self.__messages = None  # [unused-private-member]\n\nclass Crash4755Command:\n    def __init__(self):\n        self.context = Crash4755Context()\n\n    def method(self):\n        self.context.__messages = []\n        for message in self.context.__messages:\n            print(message)\n\n\n# https://github.com/pylint-dev/pylint/issues/4681\n# Accessing attributes of the class using the class name should not result in a false positive\n# as long as it is used within the class\nclass FalsePositive4681:\n    __instance = None\n    __should_cause_error = None  # [unused-private-member]\n    @staticmethod\n    def instance():\n        if FalsePositive4681.__instance is None:\n            FalsePositive4681()\n        return FalsePositive4681.__instance\n\n    def __init__(self):\n        try:\n            FalsePositive4681.__instance = 42  # This should be fine\n            FalsePositive4681.__should_cause_error = True  # [unused-private-member]\n        except Exception:  # pylint: disable=broad-except\n            print(\"Error\")\n            FalsePositive4681.__instance = False  # This should be fine\n            FalsePositive4681.__should_cause_error = False  # [unused-private-member]\n\n# Accessing attributes of the class using `cls` should not result in a false positive\n# as long as it is used within the class\nclass FalsePositive4681b:\n    __instance = None\n\n    @classmethod  # Use class method here\n    def instance(cls):\n        if cls.__inst"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unused_private_member.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    def attr_a(self):\n        \"\"\"Get a.\"\"\"\n        return self.__attr_a\n\n    @property\n    def attr_b(self):\n        \"\"\"Get b.\"\"\"\n        return self.__attr_b\n\n    # Test cases where we assign self.attr, but try to\n    # access cls.attr\n\n    def __init__(self):\n        self.__attr_c = \"this is an unused private instance attribute\"  # [unused-private-member]\n\n    @property\n    def attr_c(self):\n        \"\"\"Get c.\"\"\"\n        return cls.__attr_c  # [undefined-variable]\n\n\n# https://github.com/pylint-dev/pylint/issues/4668\n# Attributes assigned within __new__() has to be processed as part of the class\nclass FalsePositive4668:\n    # pylint: disable=protected-access, no-member, unreachable\n\n    def __new__(cls, func, *args):\n        if args:\n            true_obj = super(FalsePositive4668, cls).__new__(cls)\n            true_obj.func = func\n            true_obj.__args = args  # Do not emit message here\n            return true_obj\n\n        false_obj = super(FalsePositive4668, cls).__new__(cls)\n        false_obj.func = func\n        false_obj.__args = args  # Do not emit message here\n        false_obj.__secret_bool = False\n        false_obj.__unused = None  # [unused-private-member]\n        return false_obj\n        # unreachable but non-Name return value\n        return 3+4\n\n    def exec(self):\n        print(self.__secret_bool)\n        return self.func(*self.__args)\n\n\n# https://github.com/pylint-dev/pylint/issues/4673\n# Nested functions shouldn't cause a false positive if they are properly used\nclass FalsePositive4673:\n    \"\"\" The testing class \"\"\"\n\n    def __init__(self, in_thing):\n        self.thing = False\n        self.do_thing(in_thing)\n\n    def do_thing(self, in_thing):\n        \"\"\" Checks the false-positive condition, sets a property. \"\"\"\n        def __false_positive(in_thing):\n            print(in_thing)\n\n        def __true_positive(in_thing):  # [unused-private-member]\n            print(in_thing)\n\n        __false_positive(in_thing)\n        self.thing = True\n\n    def undo_t"}, {"start_line": 0, "end_line": 372, "belongs_to": {"file_name": "regression_property_no_member_870.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods,invalid-name,missing-docstring\n# https://github.com/pylint-dev/pylint/issues/870\n\nclass X:\n    def __init__(self, val=None):\n        self._val = val\n    @property\n    def val(self):\n        return self._val\n    @val.setter\n    def val(self, value):\n        self._val = value\n\nif __name__ == '__main__':\n    print(X([]).val.append)\n"}, {"start_line": 1000, "end_line": 2387, "belongs_to": {"file_name": "method_hidden.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "*kwargs)\n\n\nclass Foo:\n    def __init__(self):\n        self._bar = 42\n        self._baz = 84\n\n    @my_decorator\n    def method(self):  # E0202\n        return self._baz\n\n    @method.setter\n    def method(self, value):\n        self._baz = value\n\n    def do_something_with_baz(self, value):\n        self.method = value\n\n\nclass One:\n    def __init__(self, one=None):\n        if one is not None:\n            self.one = one\n\n    def one(self):  # [method-hidden]\n        pass\n\n\nclass Two(One):\n    def one(self):\n        pass\n\n\ntry:\n    import unknown as js\nexcept ImportError:\n    import json as js\n\n\nclass JsonEncoder(js.JSONEncoder):\n    # pylint: disable=useless-super-delegation,super-with-arguments\n    def default(self, o):\n        return super(JsonEncoder, self).default(o)\n\n\nclass Parent:\n    def __init__(self):\n        self._protected = None\n        self._protected_two = None\n\n\nclass Child(Parent):\n    def _protected(self):  # [method-hidden]\n        pass\n\n\nclass CachedChild(Parent):\n    @ft.cached_property\n    def _protected(self):\n        pass\n\n    @functools.cached_property\n    def _protected_two(self):\n        pass\n\n\nclass ParentTwo:\n    def __init__(self):\n        self.__private = None\n\n\nclass ChildTwo(ParentTwo):\n    def __private(self):\n        pass\n\n\nclass ChildHidingAncestorAttribute(Parent):\n    @functools().cached_property\n    def _protected(self):\n        pass\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "not_callable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " test(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @test.setter\n    def test(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\n    @MyProperty\n    def custom(self):\n        \"\"\" Get the attribute \"\"\"\n        return self.attr\n\n    @custom.setter\n    def custom(self, value):\n        \"\"\" Set the attribute \"\"\"\n        self.attr = value\n\nPROP = PropertyTest()\nPROP.test(40) # [not-callable]\nPROP.custom() # [not-callable]\n\n# Safe from not-callable when using properties.\n\nclass SafeProperty:\n    @property\n    def static(self):\n        return staticmethod\n\n    @property\n    def klass(self):\n        return classmethod\n\n    @property\n    def get_lambda(self):\n        return lambda: None\n\n    @property\n    def other_function(self):\n        def function(arg):\n            return arg\n        return function\n\n    @property\n    def dict_builtin(self):\n        return dict\n\n    @property\n    def range_builtin(self):\n        return range\n\n    @property\n    def instance(self):\n        class Empty:\n            def __call__(self):\n                return 42\n        return Empty()\n\n    @property\n    def does_not_make_sense(self):\n        raise NotImplementedError\n\nPROP1 = SafeProperty()\nPROP1.static(2)\nPROP1.klass(2)\nPROP1.get_lambda()\nPROP1.other_function(4)\nPROP1.dict_builtin()\nPROP1.range_builtin(4)\nPROP1.instance()\nPROP1.does_not_make_sense()\n\n\nimport missing  # pylint: disable=import-error\n\n\nclass UnknownBaseCallable(missing.Blah):\n    pass\n\nUnknownBaseCallable()()\n\n# Regression test for #4426\n# If property is inferable we shouldn't double emit the message\n# See: https://github.com/pylint-dev/pylint/issues/4426\nclass ClassWithProperty:\n    @property\n    def value(self):\n        return 42\n\nCLASS_WITH_PROP = ClassWithProperty().value()  # [not-callable]\n\n# Test typing.Namedtuple is callable\n# See: https://github.com/pylint-dev/pylint/issues/1295\nimport typing\n\nNamed = typing.NamedTuple(\"Named\", [(\"foo\", int), (\"bar\", int)])\nNAMED = Named("}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "access_to_protected_members.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/access", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eturn False\n\n\nclass Issue1159OtherClass:\n    \"\"\"Test for GitHub issue 1159\"\"\"\n\n    _foo = 0\n\n    def __init__(self):\n        self._bar = 0\n\n\nclass Issue1159:\n    \"\"\"Test for GitHub issue 1159\"\"\"\n\n    _foo = 0\n\n    def __init__(self):\n        self._bar = 0\n\n    @classmethod\n    def access_cls_attr(cls):\n        \"\"\"\n        Access to protected class members inside class methods is OK.\n        \"\"\"\n\n        _ = cls._foo\n\n    @classmethod\n    def assign_cls_attr(cls):\n        \"\"\"\n        Assignment to protected class members inside class methods is OK.\n        \"\"\"\n\n        cls._foo = 1\n\n    @classmethod\n    def access_inst_attr(cls):\n        \"\"\"\n        Access to protected instance members inside class methods is OK.\n        \"\"\"\n\n        instance = cls()\n        _ = instance._bar\n\n    @classmethod\n    def assign_inst_attr(cls):\n        \"\"\"\n        Assignment to protected members inside class methods is OK.\n        \"\"\"\n\n        instance = cls()\n        instance._bar = 1\n\n    @classmethod\n    def access_other_attr(cls):\n        \"\"\"\n        Access to protected instance members of other classes is not OK.\n        \"\"\"\n\n        instance = Issue1159OtherClass()\n        instance._bar = 3  # [protected-access]\n        _ = instance._foo  # [protected-access]\n\n\nclass Issue1159Subclass(Issue1159):\n    \"\"\"Test for GitHub issue 1159\"\"\"\n\n    @classmethod\n    def access_inst_attr(cls):\n        \"\"\"\n        Access to protected instance members inside class methods is OK.\n        \"\"\"\n\n        instance = cls()\n        _ = instance._bar\n\n    @classmethod\n    def assign_inst_attr(cls):\n        \"\"\"\n        Assignment to protected instance members inside class methods is OK.\n        \"\"\"\n\n        instance = cls()\n        instance._bar = 1\n\n    @classmethod\n    def access_missing_member(cls):\n        \"\"\"\n        Access to unassigned members inside class methods is not OK.\n        \"\"\"\n\n        instance = cls()\n        _ = instance._baz  # [no-member,protected-access]\n\n    @classmethod\n    def assi"}], "retrieved_count": 10, "cost_time": 1.233039140701294}
{"question": "What determines whether the function call assignment validator or the dunder name string validator executes first in the type checker's assignment processing method?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "erred, bases.Instance)\n            and node.value.func.attrname\n            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())\n        )\n\n    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n        \"\"\"Check a string is assigned to self.__name__.\"\"\"\n        # Check the left-hand side of the assignment is <something>.__name__\n        lhs = node.targets[0]\n        if not isinstance(lhs, nodes.AssignAttr):\n            return\n        if not lhs.attrname == \"__name__\":\n            return\n\n        # If the right-hand side is not a string\n        rhs = node.value\n        if isinstance(rhs, nodes.Const) and isinstance(rhs.value, str):\n            return\n        inferred = utils.safe_infer(rhs)\n        if not inferred:\n            return\n        if not (isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)):\n            # Add the message\n            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n\n    def _check_uninferable_call(self, node: nodes.Call) -> None:\n        \"\"\"Check that the given uninferable Call node does not\n        call an actual function.\n        \"\"\"\n        if not isinstance(node.func, nodes.Attribute):\n            return\n\n        # Look for properties. First, obtain\n        # the lhs of the Attribute node and search the attribute\n        # there. If that attribute is a property or a subclass of properties,\n        # then most likely it's not callable.\n\n        expr = node.func.expr\n        klass = safe_infer(expr)\n        if not isinstance(klass, astroid.Instance):\n            return\n\n        try:\n            attrs = klass._proxied.getattr(node.func.attrname)\n        except astroid.NotFoundError:\n            return\n\n        for attr in attrs:\n            if not isinstance(attr, nodes.FunctionDef):\n                continue\n\n            # Decorated, see if it is decorated with a property.\n            # Also, check the returns and see if they are callable.\n            if decorated_with_property(attr)"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (\n                        isinstance(ret_node.value, nodes.Const)\n                        and ret_node.value.value is None\n                    )\n                    or ret_node.value is None\n                ):\n                    break\n            else:\n                self.add_message(\"assignment-from-none\", node=node)\n\n    @staticmethod\n    def _is_ignored_function(\n        function_node: nodes.FunctionDef | bases.UnboundMethod,\n    ) -> bool:\n        return (\n            isinstance(function_node, nodes.AsyncFunctionDef)\n            or utils.is_error(function_node)\n            or function_node.is_generator()\n            or function_node.is_abstract(pass_is_abstract=False)\n        )\n\n    @staticmethod\n    def _is_builtin_no_return(node: nodes.Assign) -> bool:\n        return (\n            isinstance(node.value, nodes.Call)\n            and isinstance(node.value.func, nodes.Attribute)\n            and bool(inferred := utils.safe_infer(node.value.func.expr))\n            and isinstance(inferred, bases.Instance)\n            and node.value.func.attrname\n            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())\n        )\n\n    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n        \"\"\"Check a string is assigned to self.__name__.\"\"\"\n        # Check the left-hand side of the assignment is <something>.__name__\n        lhs = node.targets[0]\n        if not isinstance(lhs, nodes.AssignAttr):\n            return\n        if not lhs.attrname == \"__name__\":\n            return\n\n        # If the right-hand side is not a string\n        rhs = node.value\n        if isinstance(rhs, nodes.Const) and isinstance(rhs.value, str):\n            return\n        inferred = utils.safe_infer(rhs)\n        if not inferred:\n            return\n        if not (isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)):\n            # Add the message\n            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n\n    def _check_uninferable_call(self, "}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "assignment-from-no-return\",\n        \"assignment-from-none\",\n        \"non-str-assignment-to-dunder-name\",\n    )\n    def visit_assign(self, node: nodes.Assign) -> None:\n        \"\"\"Process assignments in the AST.\"\"\"\n        self._check_assignment_from_function_call(node)\n        self._check_dundername_is_string(node)\n\n    def _check_assignment_from_function_call(self, node: nodes.Assign) -> None:\n        \"\"\"When assigning to a function call, check that the function returns a valid\n        value.\n        \"\"\"\n        if not isinstance(node.value, nodes.Call):\n            return\n\n        function_node = safe_infer(node.value.func)\n        funcs = (nodes.FunctionDef, astroid.UnboundMethod, astroid.BoundMethod)\n        if not isinstance(function_node, funcs):\n            return\n\n        # Unwrap to get the actual function node object\n        if isinstance(function_node, astroid.BoundMethod) and isinstance(\n            function_node._proxied, astroid.UnboundMethod\n        ):\n            function_node = function_node._proxied._proxied\n\n        # Make sure that it's a valid function that we can analyze.\n        # Ordered from less expensive to more expensive checks.\n        if (\n            not function_node.is_function\n            or function_node.decorators\n            or self._is_ignored_function(function_node)\n        ):\n            return\n\n        # Handle builtins such as list.sort() or dict.update()\n        if self._is_builtin_no_return(node):\n            self.add_message(\n                \"assignment-from-no-return\", node=node, confidence=INFERENCE\n            )\n            return\n\n        if not function_node.root().fully_defined():\n            return\n\n        return_nodes = list(\n            function_node.nodes_of_class(nodes.Return, skip_klass=nodes.FunctionDef)\n        )\n        if not return_nodes:\n            self.add_message(\"assignment-from-no-return\", node=node)\n        else:\n            for ret_node in return_nodes:\n                if not (\n                   "}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     confidence=INFERENCE,\n                )\n\n    def _get_nomember_msgid_hint(\n        self,\n        node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr,\n        owner: SuccessfulInferenceResult,\n    ) -> tuple[Literal[\"c-extension-no-member\", \"no-member\"], str]:\n        if _is_c_extension(owner):\n            return \"c-extension-no-member\", \"\"\n        if not self.linter.config.missing_member_hint:\n            return \"no-member\", \"\"\n        names = _similar_names(\n            owner,\n            node.attrname,\n            self.linter.config.missing_member_hint_distance,\n            self.linter.config.missing_member_max_choices,\n        )\n        if not names:\n            return \"no-member\", \"\"\n        names = [repr(name) for name in names]\n        if len(names) == 1:\n            names_hint = names[0]\n        else:\n            names_hint = f\"one of {', '.join(names[:-1])} or {names[-1]}\"\n        return \"no-member\", f\"; maybe {names_hint}?\"\n\n    @only_required_for_messages(\n        \"assignment-from-no-return\",\n        \"assignment-from-none\",\n        \"non-str-assignment-to-dunder-name\",\n    )\n    def visit_assign(self, node: nodes.Assign) -> None:\n        \"\"\"Process assignments in the AST.\"\"\"\n        self._check_assignment_from_function_call(node)\n        self._check_dundername_is_string(node)\n\n    def _check_assignment_from_function_call(self, node: nodes.Assign) -> None:\n        \"\"\"When assigning to a function call, check that the function returns a valid\n        value.\n        \"\"\"\n        if not isinstance(node.value, nodes.Call):\n            return\n\n        function_node = safe_infer(node.value.func)\n        funcs = (nodes.FunctionDef, astroid.UnboundMethod, astroid.BoundMethod)\n        if not isinstance(function_node, funcs):\n            return\n\n        # Unwrap to get the actual function node object\n        if isinstance(function_node, astroid.BoundMethod) and isinstance(\n            function_node._proxied, astroid.UnboundMethod\n        ):\n            functio"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "imports.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-level-dunder-names\n            valid_targets = [\n                isinstance(target, nodes.AssignName)\n                and target.name.startswith(\"__\")\n                and target.name.endswith(\"__\")\n                for target in node.targets\n            ]\n            if all(valid_targets):\n                return\n        self._first_non_import_node = node\n\n    visit_try = visit_assignattr = visit_assign = visit_ifexp = visit_comprehension = (\n        visit_expr\n    ) = visit_if = compute_first_non_import_node\n\n    def visit_functiondef(\n        self, node: nodes.FunctionDef | nodes.While | nodes.For | nodes.ClassDef\n    ) -> None:\n        # If it is the first non import instruction of the module, record it.\n        if self._first_non_import_node:\n            return\n\n        # Check if the node belongs to an `If` or a `Try` block. If they\n        # contain imports, skip recording this node.\n        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n\n        root = node\n        while not isinstance(root.parent, nodes.Module):\n            root = root.parent\n\n        if isinstance(root, (nodes.If, nodes.Try)):\n            if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):\n                return\n\n        self._first_non_import_node = node\n\n    visit_classdef = visit_for = visit_while = visit_functiondef\n\n    def _check_misplaced_future(self, node: nodes.ImportFrom) -> None:\n        basename = node.modname\n        if basename == \"__future__\":\n            # check if this is the first non-docstring statement in the module\n            prev = node.previous_sibling()\n            if prev:\n                # consecutive future statements are possible\n                if not (\n                    isinstance(prev, nodes.ImportFrom) and prev.modname == \"__future__\"\n                ):\n                    self.add_message(\"misplaced-future\", node=node)\n\n    def _check_same_line_imports(self, node: nodes.ImportFrom) -> None:\n        # Detect duplicate im"}, {"start_line": 2000, "end_line": 3892, "belongs_to": {"file_name": "dunder_methods.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_lambda_def(node: nodes.NodeNG) -> bool:\n        \"\"\"Check if dunder method call is within a dunder method definition.\"\"\"\n        parent = node.parent\n        while parent is not None:\n            if (\n                isinstance(parent, nodes.FunctionDef)\n                and parent.name.startswith(\"__\")\n                and parent.name.endswith(\"__\")\n            ) or DunderCallChecker.is_lambda_rule_exception(parent, node):\n                return True\n            parent = parent.parent\n        return False\n\n    @staticmethod\n    def is_lambda_rule_exception(ancestor: nodes.NodeNG, node: nodes.NodeNG) -> bool:\n        return (\n            isinstance(ancestor, nodes.Lambda)\n            and node.func.attrname in UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS\n        )\n\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check if method being called is an unnecessary dunder method.\"\"\"\n        if (\n            isinstance(node.func, nodes.Attribute)\n            and node.func.attrname in self._dunder_methods\n            and not self.within_dunder_or_lambda_def(node)\n            and not (\n                isinstance(node.func.expr, nodes.Call)\n                and isinstance(node.func.expr.func, nodes.Name)\n                and node.func.expr.func.name == \"super\"\n            )\n        ):\n            inf_expr = safe_infer(node.func.expr)\n            if not (\n                inf_expr is None or isinstance(inf_expr, (Instance, UninferableBase))\n            ):\n                # Skip dunder calls to non instantiated classes.\n                return\n\n            self.add_message(\n                \"unnecessary-dunder-call\",\n                node=node,\n                args=(node.func.attrname, self._dunder_methods[node.func.attrname]),\n                confidence=HIGH,\n            )\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(DunderCallChecker(linter))\n"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                   node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_import := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                 "}, {"start_line": 0, "end_line": 1457, "belongs_to": {"file_name": "non_str_assignment_to_dunder_name.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/non", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-module-docstring, missing-class-docstring\n# pylint: disable=too-few-public-methods, missing-function-docstring\n# pylint: disable=import-error\n\nimport random\n\nfrom unknown import Unknown\n\n\nclass ExampleClass():\n    pass\n\n\ndef example_function():\n    pass\n\n\ndef returns_str():\n    return \"abcd\"\n\n\ndef returns_int():\n    return 0\n\n\ndef returns_tuple():\n    return 0, \"abc\"\n\n\n# Might not be thorough if same hash seed is used in testing...\ndef returns_random_type():\n    if random.randint(0, 1) > 0:\n        return 0\n\n    return \"abc\"\n\nExampleClass.__name__ = 1  # [non-str-assignment-to-dunder-name]\nExampleClass.__name__ = True  # [non-str-assignment-to-dunder-name]\nExampleClass.__name__ = returns_tuple() # [non-str-assignment-to-dunder-name]\nExampleClass.__name__ = returns_int() # [non-str-assignment-to-dunder-name]\nExampleClass.__name__ = \"foo\"\nExampleClass.__name__ = returns_str()\nExampleClass.__name__ = returns_random_type()\nExampleClass.__name__ = Unknown\n\nexample_function.__name__ = 1  # [non-str-assignment-to-dunder-name]\nexample_function.__name__ = True  # [non-str-assignment-to-dunder-name]\nexample_function.__name__ = returns_tuple() # [non-str-assignment-to-dunder-name]\nexample_function.__name__ = returns_int() # [non-str-assignment-to-dunder-name]\nexample_function.__name__ = \"foo\"\nexample_function.__name__ = returns_str()\nexample_function.__name__ = returns_random_type()\nexample_function.__name__ = Unknown\n"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n                        self._check_name(\"typevar\", assign_type.targets[0].name, node)\n                        return\n                    if self._assigns_typealias(assign_type.value):\n                        self._check_name(\"typealias\", assign_type.targets[0].name, node)\n                        return\n\n                if (\n                    isinstance(node.parent, nodes.Tuple)\n                    and isinstance(assign_type.value, nodes.Tuple)\n                    # protect against unbalanced tuple unpacking\n                    and node.parent.elts.index(node) < len(assign_type.value.elts)\n                ):\n                    assigner = assign_type.value.elts[node.parent.elts.index(node)]\n                    if self._assigns_typevar(assigner):\n                        self._check_name(\n                            \"typevar\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_impor"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ClassDef):\n                    return True\n            return False\n\n        if self._name_allowed_by_regex(name=name):\n            return\n        if self._name_disallowed_by_regex(name=name):\n            self.linter.stats.increase_bad_name(node_type, 1)\n            self.add_message(\n                \"disallowed-name\", node=node, args=name, confidence=interfaces.HIGH\n            )\n            return\n        regexp = self._name_regexps[node_type]\n        match = regexp.match(name)\n\n        if _is_multi_naming_match(match, node_type, confidence):\n            name_group = self._find_name_group(node_type)\n            bad_name_group = self._bad_names.setdefault(name_group, {})\n            # Ignored because this is checked by the if statement\n            warnings = bad_name_group.setdefault(match.lastgroup, [])  # type: ignore[union-attr, arg-type]\n            warnings.append((node, node_type, name, confidence))\n\n        if (\n            match is None\n            and not disallowed_check_only\n            and not _should_exempt_from_invalid_name(node)\n        ):\n            self._raise_name_warning(None, node, node_type, name, confidence)\n\n        # Check TypeVar names for variance suffixes\n        if node_type == \"typevar\":\n            self._check_typevar(name, node)\n\n    @staticmethod\n    def _assigns_typevar(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeVar.\"\"\"\n        if isinstance(node, astroid.Call):\n            inferred = utils.safe_infer(node.func)\n            if (\n                isinstance(inferred, astroid.ClassDef)\n                and inferred.qname() in TYPE_VAR_QNAME\n            ):\n                return True\n        return False\n\n    @staticmethod\n    def _assigns_typealias(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeAlias.\"\"\"\n        inferred = utils.safe_infer(node)\n        if isinstance(inferred, (nodes.ClassDef, astroid.bases.UnionType)):\n            qname = inferred.qname()\n      "}], "retrieved_count": 10, "cost_time": 0.33628058433532715}
{"question": "Where is the initialization logic that the child class's initialization method delegates to through the parent class delegation mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 327, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/n/non-parent-init-called", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Animal:\n    def __init__(self):\n        self.is_multicellular = True\n\n\nclass Vertebrate(Animal):\n    def __init__(self):\n        super().__init__()\n        self.has_vertebrae = True\n\n\nclass Cat(Vertebrate):\n    def __init__(self):\n        Animal.__init__(self)  # [non-parent-init-called]\n        self.is_adorable = True\n"}, {"start_line": 1000, "end_line": 2510, "belongs_to": {"file_name": "super_init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "randParentWithInit it doesn't need to be called.\"\"\"\n\n    def __init__(self):\n        GrandParentWithInit.__init__(self)\n\n\nclass ChildTwo(ParentWithoutInit):\n    def __init__(self):\n        ParentWithoutInit.__init__(self)\n\n\nclass ChildThree(ParentWithoutInit):\n    def __init__(self):  # [super-init-not-called]\n        ...\n\n\n# Regression test as reported in\n# https://github.com/pylint-dev/pylint/issues/6027\nclass MyUnion(ctypes.Union):\n    def __init__(self):\n        pass\n\n\n# Should not be called on abstract __init__ methods\n# https://github.com/pylint-dev/pylint/issues/3975\nclass Base:\n    def __init__(self, param: int, param_two: str) -> None:\n        raise NotImplementedError()\n\n\nclass Derived(Base):\n    def __init__(self, param: int, param_two: str) -> None:\n        self.param = param + 1\n        self.param_two = param_two[::-1]\n\n\nclass AbstractBase(abc.ABC):\n    def __init__(self, param: int) -> None:\n        self.param = param + 1\n\n    def abstract_method(self) -> str:\n        \"\"\"This needs to be implemented.\"\"\"\n        raise NotImplementedError()\n\n\nclass DerivedFromAbstract(AbstractBase):\n    def __init__(self, param: int) -> None:  # [super-init-not-called]\n        print(\"Called\")\n\n    def abstract_method(self) -> str:\n        return \"Implemented\"\n\n\nclass DerivedFrom(UnknownParent):  # [undefined-variable]\n    def __init__(self) -> None:\n        print(\"Called\")\n\n\nclass DerivedFromUnknownGrandparent(DerivedFrom):\n    def __init__(self) -> None:\n        DerivedFrom.__init__(self)\n"}, {"start_line": 0, "end_line": 440, "belongs_to": {"file_name": "useless_parent_delegation_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/useless", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods\nfrom typing import Any\n\n\nclass Egg:\n    def __init__(self, first: Any, /, second: Any) -> None:\n        pass\n\n\nclass Spam(Egg):\n    def __init__(self, first: float, /, second: float) -> None:\n        super().__init__(first, second)\n\n\nclass Ham(Egg):\n    def __init__(self, first: Any, /, second: Any) -> None:  # [useless-parent-delegation]\n        super().__init__(first, second)\n"}, {"start_line": 0, "end_line": 1698, "belongs_to": {"file_name": "init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods, import-error, missing-docstring, wrong-import-position\n# pylint: disable=useless-super-delegation, unnecessary-pass\n\n\nfrom typing import overload\n\nfrom missing import Missing\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass BBBB:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass CCCC:\n    \"\"\"ancestor 3\"\"\"\n\n\nclass ZZZZ(AAAA, BBBB, CCCC):\n    \"\"\"derived class\"\"\"\n\n    def __init__(self):  # [super-init-not-called]\n        AAAA.__init__(self)\n\n\nclass NewStyleA:\n    \"\"\"new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        print(\"init\", self)\n\n\nclass NewStyleB(NewStyleA):\n    \"\"\"derived new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n\nclass NewStyleC:\n    \"\"\"__init__ defined by assignment.\"\"\"\n\n    def xx_init(self):\n        \"\"\"Initializer.\"\"\"\n        pass\n\n    __init__ = xx_init\n\n\nclass AssignedInit(NewStyleC):\n    \"\"\"No init called, but abstract so that is fine.\"\"\"\n\n    def __init__(self):\n        self.arg = 0\n\n\nclass UnknownBases(Missing):\n    \"\"\"No false positives if the bases aren't known.\"\"\"\n\n\nclass Parent:\n    def __init__(self, num: int):\n        self.number = num\n\n\nclass Child(Parent):\n    @overload\n    def __init__(self, num: int):\n        ...\n\n    @overload\n    def __init__(self, num: float):\n        ...\n\n    def __init__(self, num):\n        super().__init__(round(num))\n\n\n# https://github.com/pylint-dev/pylint/issues/7742\n# Crash when parent class has a class attribute named `__init__`\nclass NoInitMethod:\n    __init__ = 42\n\n\nclass ChildNoInitMethod(NoInitMethod):\n    def __init__(self):\n        ...\n"}, {"start_line": 0, "end_line": 241, "belongs_to": {"file_name": "dotted_ancestor.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"bla\"\"\"\n\n\nfrom ..n.non import non_init_parent_called\n\n\nclass Aaaa(non_init_parent_called.AAAA):  # [too-few-public-methods]\n    \"\"\"test dotted name in ancestors\"\"\"\n    def __init__(self):\n        non_init_parent_called.AAAA.__init__(self)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "super_init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for super-init-not-called.\"\"\"\n# pylint: disable=too-few-public-methods, missing-class-docstring\n\nimport abc\nimport ctypes\n\n\nclass Foo(ctypes.BigEndianStructure):\n    \"\"\"This class should not emit a super-init-not-called warning.\n\n    It previously did, because ``next(node.infer())`` was used in that checker's logic\n    and the first inferred node was an Uninferable object, leading to this false positive.\n    \"\"\"\n\n    def __init__(self):\n        ctypes.BigEndianStructure.__init__(self)\n\n\nclass UninferableChild(UninferableParent):  # [undefined-variable]\n    \"\"\"An implementation that test if we don't crash on uninferable parents.\"\"\"\n\n    def __init__(self):\n        ...\n\n\n# Tests for not calling the init of a parent that does not define one\n# but inherits it.\nclass GrandParentWithInit:\n    def __init__(self):\n        print(self)\n\n\nclass ParentWithoutInit(GrandParentWithInit):\n    pass\n\n\nclass ChildOne(ParentWithoutInit, GrandParentWithInit):\n    \"\"\"Since ParentWithoutInit calls GrandParentWithInit it doesn't need to be called.\"\"\"\n\n    def __init__(self):\n        GrandParentWithInit.__init__(self)\n\n\nclass ChildTwo(ParentWithoutInit):\n    def __init__(self):\n        ParentWithoutInit.__init__(self)\n\n\nclass ChildThree(ParentWithoutInit):\n    def __init__(self):  # [super-init-not-called]\n        ...\n\n\n# Regression test as reported in\n# https://github.com/pylint-dev/pylint/issues/6027\nclass MyUnion(ctypes.Union):\n    def __init__(self):\n        pass\n\n\n# Should not be called on abstract __init__ methods\n# https://github.com/pylint-dev/pylint/issues/3975\nclass Base:\n    def __init__(self, param: int, param_two: str) -> None:\n        raise NotImplementedError()\n\n\nclass Derived(Base):\n    def __init__(self, param: int, param_two: str) -> None:\n        self.param = param + 1\n        self.param_two = param_two[::-1]\n\n\nclass AbstractBase(abc.ABC):\n    def __init__(self, param: int) -> None:\n        self.param = param + 1\n\n    def abstract_method(self) -> str:\n        \"\"\""}, {"start_line": 14000, "end_line": 15284, "belongs_to": {"file_name": "useless_parent_delegation.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/useless", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng)\n\n\nclass Ham(Egg):\n    def __init__(self, thing: object) -> None:  # [useless-parent-delegation]\n        super().__init__(thing)\n\n\nclass Test:\n    def __init__(self, _arg: List[int]) -> None:\n        super().__init__()\n\n\nclass ReturnTypeAny:\n    choices = [\"a\", 1, (2, 3)]\n\n    def draw(self) -> Any:\n        return random.choice(self.choices)\n\n\nclass ReturnTypeNarrowed(ReturnTypeAny):\n    choices = [1, 2, 3]\n\n    def draw(self) -> int:\n        return super().draw()\n\n\nclass NoReturnType:\n    choices = [\"a\", 1, (2, 3)]\n\n    def draw(self):\n        return random.choice(self.choices)\n\n\nclass ReturnTypeSpecified(NoReturnType):\n    choices = [\"a\", \"b\"]\n\n    def draw(self) -> str:  # [useless-parent-delegation]\n        return super().draw()\n\n\nclass ReturnTypeSame(ReturnTypeAny):\n    choices = [\"a\", \"b\"]\n\n    def draw(self) -> Any:  # [useless-parent-delegation]\n        return super().draw()\n\n\n# Any number of positional arguments followed by one keyword argument with a default value\nclass Fruit:\n    def __init__(*, tastes_bitter=None):\n        ...\n\n\nclass Lemon(Fruit):\n    def __init__(*, tastes_bitter=True):\n        super().__init__(tastes_bitter=tastes_bitter)\n\n\nclass CustomError(Exception):\n    def __init__(self, message=\"default\"):\n        super().__init__(message)\n"}, {"start_line": 0, "end_line": 1448, "belongs_to": {"file_name": "non_init_parent_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/non", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=protected-access,import-self,too-few-public-methods,line-too-long\n# pylint: disable=wrong-import-order, unnecessary-dunder-call\n\"\"\"test for call to __init__ from a non ancestor class\n\"\"\"\nfrom . import non_init_parent_called\nimport nonexistent  # [import-error]\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print('init', self)\n        BBBBMixin.__init__(self)  # [non-parent-init-called]\n\nclass BBBBMixin:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print('init', self)\n\nclass CCC(BBBBMixin, non_init_parent_called.AAAA, non_init_parent_called.BBBB, nonexistent.AClass):  # [no-member]\n    \"\"\"mix different things, some inferable some not\"\"\"\n    def __init__(self):\n        BBBBMixin.__init__(self)\n        non_init_parent_called.AAAA.__init__(self)\n        non_init_parent_called.BBBB.__init__(self)  # [no-member]\n        nonexistent.AClass.__init__(self)\n\nclass DDDD(AAAA):\n    \"\"\"call superclass constructor in disjunct branches\"\"\"\n    def __init__(self, value):\n        if value:\n            AAAA.__init__(self)\n        else:\n            AAAA.__init__(self)\n\nclass Super(dict):\n    \"\"\" test late binding super() call \"\"\"\n    def __init__(self):\n        base = super()\n        base.__init__()\n\nclass Super2(dict):\n    \"\"\" Using the same idiom as Super, but without calling\n    the __init__ method.\n    \"\"\"\n    def __init__(self):\n        base = super()\n        base.__woohoo__()  # [no-member]\n"}, {"start_line": 85000, "end_line": 87000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n\n        def is_abstract(method: nodes.FunctionDef) -> bool:\n            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]\n\n        # check if this class abstract\n        if class_is_abstract(node):\n            return\n\n        methods = sorted(\n            unimplemented_abstract_methods(node, is_abstract).items(),\n            key=lambda item: item[0],\n        )\n        for name, method in methods:\n            owner = method.parent.frame()\n            if owner is node:\n                continue\n            # owner is not this class, it must be a parent class\n            # check that the ancestor's method is not abstract\n            if name in node.locals:\n                # it is redefined as an attribute or with a descriptor\n                continue\n\n            self.add_message(\n                \"abstract-method\",\n                node=node,\n                args=(name, owner.name, node.name),\n                confidence=INFERENCE,\n            )\n\n    def _check_init(self, node: nodes.FunctionDef, klass_node: nodes.ClassDef) -> None:\n        \"\"\"Check that the __init__ method call super or ancestors'__init__\n        method (unless it is used for type hinting with `typing.overload`).\n        \"\"\"\n        if not self.linter.is_message_enabled(\n            \"super-init-not-called\"\n        ) and not self.linter.is_message_enabled(\"non-parent-init-called\"):\n            return\n        to_call = _ancestors_to_call(klass_node)\n        not_called_yet = dict(to_call)\n        parents_with_called_inits: set[bases.UnboundMethod] = set()\n        for stmt in node.nodes_of_class(nodes.Call):\n            expr = stmt.func\n            if not isinstance(expr, nodes.Attribute) or expr.attrname != \"__init__\":\n                continue\n            # skip the test if using super\n            if (\n                isinstance(expr.expr, nodes.Call)\n                and isinstance(expr.expr.func, nodes.Name)\n                and expr.expr.func.name == \"super\"\n            "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "access_attr_before_def_false_positive.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/access", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=invalid-name,too-many-public-methods,attribute-defined-outside-init\n# pylint: disable=too-few-public-methods,deprecated-module,consider-using-max-builtin\n\"\"\"This module demonstrates a possible problem of pyLint with calling __init__ s\nfrom inherited classes.\nInitializations done there are not considered, which results in Error E0203 for\nself.cookedq.\"\"\"\n\n\nimport telnetlib\n\nclass SeeTelnet(telnetlib.Telnet):\n    \"\"\"\n    Extension of telnetlib.\n    \"\"\"\n\n    def __init__(self, host=None, port=0):\n        \"\"\"\n        Constructor.\n        When called without arguments, create an unconnected instance.\n        With a hostname argument, it connects the instance; a port\n        number is optional.\n        Parameter:\n        - host: IP address of the host\n        - port: Port number\n        \"\"\"\n        telnetlib.Telnet.__init__(self, host, port)\n\n    def readUntilArray(self, matches, _=None):\n        \"\"\"\n        Read until a given string is encountered or until timeout.\n        ...\n        \"\"\"\n        self.process_rawq()\n        maxLength = 0\n        for match in matches:\n            if len(match) > maxLength:\n                maxLength = len(match)\n\nclass Base:\n    \"\"\"bla bla\"\"\"\n    dougloup_papa = None\n\n    def __init__(self):\n        self._var = False\n\nclass Derived(Base):\n    \"\"\"derived blabla\"\"\"\n    dougloup_moi = None\n    def Work(self):\n        \"\"\"do something\"\"\"\n        # E0203 - Access to member '_var' before its definition\n        if self._var:\n            print(\"True\")\n        else:\n            print(\"False\")\n        self._var = True\n\n        # E0203 - Access to member 'dougloup_papa' before its definition\n        if self.dougloup_papa:\n            print('dougloup !')\n        self.dougloup_papa = True\n        # E0203 - Access to member 'dougloup_moi' before its definition\n        if self.dougloup_moi:\n            print('dougloup !')\n        self.dougloup_moi = True\n\n\nclass QoSALConnection:\n    \"\"\"blabla\"\"\"\n\n    _the_instance = None\n\n    def __new__"}], "retrieved_count": 10, "cost_time": 0.3377106189727783}
{"question": "Where does the yield statement in the context manager function that assigns a context variable and yields it without cleanup establish a data dependency between the variable assignment and the control flow suspension point?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 280, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/c/contextmanager-generator-missing-cleanup", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import contextlib\n\n\n@contextlib.contextmanager\ndef cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n\n\ndef genfunc_with_cm():\n    with cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n"}, {"start_line": 0, "end_line": 1161, "belongs_to": {"file_name": "good.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/c/contextmanager-generator-missing-cleanup", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import contextlib\n\n\n@contextlib.contextmanager\ndef good_cm_except():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    except GeneratorExit:\n        print(\"good cm exit\")\n\n\ndef genfunc_with_cm():\n    with good_cm_except() as context:\n        yield context * 2\n\n\ndef genfunc_with_discard():\n    with good_cm_except():\n        yield \"discarded\"\n\n\n@contextlib.contextmanager\ndef good_cm_yield_none():\n    print(\"good cm enter\")\n    yield\n    print(\"good cm exit\")\n\n\ndef genfunc_with_none_yield():\n    with good_cm_yield_none() as var:\n        print(var)\n        yield \"constant yield\"\n\n\n@contextlib.contextmanager\ndef good_cm_finally():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    finally:\n        print(\"good cm exit\")\n\n\ndef good_cm_finally_genfunc():\n    with good_cm_finally() as context:\n        yield context * 2\n\n\n@contextlib.contextmanager\ndef good_cm_no_cleanup():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n\n\ndef good_cm_no_cleanup_genfunc():\n    with good_cm_no_cleanup() as context:\n        yield context * 2\n"}, {"start_line": 2000, "end_line": 3789, "belongs_to": {"file_name": "contextmanager_generator_missing_cleanup.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\"good cm exit\")\n\n\ndef good_genfunc_with_cm():\n    with good_cm_except() as context:\n        yield context * 2\n\n\ndef genfunc_with_discard():\n    with good_cm_except():\n        yield \"discarded\"\n\n\n@contextlib.contextmanager\ndef good_cm_yield_none():\n    print(\"good cm enter\")\n    yield\n    print(\"good cm exit\")\n\n\ndef genfunc_with_none_yield():\n    with good_cm_yield_none() as var:\n        print(var)\n        yield \"discarded\"\n\n\n@contextlib.contextmanager\ndef good_cm_finally():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    finally:\n        print(\"good cm exit\")\n\n\ndef good_cm_finally_genfunc():\n    with good_cm_finally() as context:\n        yield context * 2\n\n\ndef genfunc_with_cm_finally_odd_body():\n    with good_cm_finally() as context:\n        if context:\n            yield context * 2\n        else:\n            yield context * 3\n\n\n@cm_with_improper_handling\ndef genfunc_wrapped():\n    yield \"wrapped\"\n\n\n@contextmanager\ndef cm_bare_handler():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    try:\n        yield contextvar\n    except:\n        print(\"cm exit\")\n\n\n@contextmanager\ndef cm_base_exception_handler():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    try:\n        yield contextvar\n    except Exception:\n        print(\"cm exit\")\n\n\ndef genfunc_with_cm_bare_handler():\n    with cm_bare_handler() as context:\n        yield context * 2\n\n\ndef genfunc_with_cm_base_exception_handler():\n    with cm_base_exception_handler() as context:\n        yield context * 2\n\n\n@contextlib.contextmanager\ndef good_cm_no_cleanup():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n\n\ndef good_cm_no_cleanup_genfunc():\n    with good_cm_no_cleanup() as context:\n        yield context * 2\n"}, {"start_line": 0, "end_line": 251, "belongs_to": {"file_name": "used_before_assignment_488.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\ndef func():\n    \"\"\"Test that a variable defined in a finally clause does not trigger a false positive\"\"\"\n    try:\n        variable = 1\n        yield variable\n    finally:\n        variable = 2\n        yield variable\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "contextmanager_generator_missing_cleanup.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable = missing-docstring, unused-variable, bare-except, broad-exception-caught\nfrom collections import namedtuple\nimport contextlib\nfrom contextlib import contextmanager\n\n# Positive\n\n\n@contextlib.contextmanager\ndef cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n\n\ndef genfunc_with_cm():\n    with cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n\n\n@contextmanager\ndef name_cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n\n\ndef genfunc_with_name_cm():\n    with name_cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n\n\ndef genfunc_with_cm_after():\n    with after_cm() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n\n\n@contextlib.contextmanager\ndef after_cm():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    yield contextvar\n    print(\"cm exit\")\n\n\n@contextmanager\ndef cm_with_improper_handling():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    try:\n        yield contextvar\n    except ValueError:\n        pass\n    print(\"cm exit\")\n\n\ndef genfunc_with_cm_improper():\n    with cm_with_improper_handling() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n\n\n# Negative\n\n\nclass Enterable:\n    def __enter__(self):\n        print(\"enter\")\n        return self\n\n    def __exit__(self, *args):\n        print(\"exit\")\n\n\ndef genfunc_with_enterable():\n    enter = Enterable()\n    with enter as context:\n        yield context * 2\n\n\ndef genfunc_with_enterable_attr():\n    EnterableTuple = namedtuple(\"EnterableTuple\", [\"attr\"])\n    t = EnterableTuple(Enterable())\n    with t.attr as context:\n        yield context.attr * 2\n\n\n@contextlib.contextmanager\ndef good_cm_except():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    except GeneratorExit:\n        print"}, {"start_line": 0, "end_line": 406, "belongs_to": {"file_name": "not_async_context_manager_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\n\nfrom contextlib import asynccontextmanager\n\n\n@asynccontextmanager\nasync def context_manager(value):\n    yield value\n\n\nasync with context_manager(42) as answer:\n    assert answer == 42\n\n\ndef async_context_manager():\n    @asynccontextmanager\n    async def wrapper():\n        pass\n    return wrapper\n\nasync def func():\n    async with async_context_manager():\n        pass\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "contextmanager_generator_missing_cleanup.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\")\n\n\n@contextmanager\ndef cm_with_improper_handling():\n    contextvar = \"acquired context\"\n    print(\"cm enter\")\n    try:\n        yield contextvar\n    except ValueError:\n        pass\n    print(\"cm exit\")\n\n\ndef genfunc_with_cm_improper():\n    with cm_with_improper_handling() as context:  # [contextmanager-generator-missing-cleanup]\n        yield context * 2\n\n\n# Negative\n\n\nclass Enterable:\n    def __enter__(self):\n        print(\"enter\")\n        return self\n\n    def __exit__(self, *args):\n        print(\"exit\")\n\n\ndef genfunc_with_enterable():\n    enter = Enterable()\n    with enter as context:\n        yield context * 2\n\n\ndef genfunc_with_enterable_attr():\n    EnterableTuple = namedtuple(\"EnterableTuple\", [\"attr\"])\n    t = EnterableTuple(Enterable())\n    with t.attr as context:\n        yield context.attr * 2\n\n\n@contextlib.contextmanager\ndef good_cm_except():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    except GeneratorExit:\n        print(\"good cm exit\")\n\n\ndef good_genfunc_with_cm():\n    with good_cm_except() as context:\n        yield context * 2\n\n\ndef genfunc_with_discard():\n    with good_cm_except():\n        yield \"discarded\"\n\n\n@contextlib.contextmanager\ndef good_cm_yield_none():\n    print(\"good cm enter\")\n    yield\n    print(\"good cm exit\")\n\n\ndef genfunc_with_none_yield():\n    with good_cm_yield_none() as var:\n        print(var)\n        yield \"discarded\"\n\n\n@contextlib.contextmanager\ndef good_cm_finally():\n    contextvar = \"acquired context\"\n    print(\"good cm enter\")\n    try:\n        yield contextvar\n    finally:\n        print(\"good cm exit\")\n\n\ndef good_cm_finally_genfunc():\n    with good_cm_finally() as context:\n        yield context * 2\n\n\ndef genfunc_with_cm_finally_odd_body():\n    with good_cm_finally() as context:\n        if context:\n            yield context * 2\n        else:\n            yield context * 3\n\n\n@cm_with_improper_handling\ndef genfunc_wrapped():\n    yield \"wrapped\"\n\n\n@contextmanager\ndef cm_bare_handl"}, {"start_line": 0, "end_line": 521, "belongs_to": {"file_name": "regression_2567.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nRegression test for `no-member`.\nSee: https://github.com/pylint-dev/pylint/issues/2567\n\"\"\"\n\n# pylint: disable=missing-docstring,too-few-public-methods\n\nimport contextlib\n\n\n@contextlib.contextmanager\ndef context_manager():\n    try:\n        yield\n    finally:\n        pass\n\n\nCM = context_manager()\nCM.__enter__()\nCM.__exit__(None, None, None)\n\n\n@contextlib.contextmanager\ndef other_context_manager():\n    try:\n        yield\n    finally:\n        pass\n\n\nwith other_context_manager():  # notice the function call\n    pass\n"}, {"start_line": 0, "end_line": 383, "belongs_to": {"file_name": "yield_assign.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/y", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=use-yield-from\n\"\"\"https://www.logilab.org/ticket/8771\"\"\"\n\n\ndef generator():\n    \"\"\"yield as assignment\"\"\"\n    yield 45\n    xxxx = yield 123\n    print(xxxx)\n\ndef generator_fp1(seq):\n    \"\"\"W0631 false positive\"\"\"\n    for val in seq:\n        pass\n    for val in seq:\n        yield val\n\ndef generator_fp2():\n    \"\"\"E0601 false positive\"\"\"\n    xxxx = 12\n    yield xxxx\n"}, {"start_line": 0, "end_line": 420, "belongs_to": {"file_name": "regression_4723.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Latest version of astroid (2.6.3) causes RuntimeError:\ngenerator raised StopIteration #4723\"\"\"\n# pylint: disable=invalid-name,missing-docstring,too-few-public-methods\n\nimport contextlib\n\n\nclass A:\n    @contextlib.contextmanager\n    def get(self):\n        yield self\n\n\nclass B(A):\n    def play():  # [no-method-argument]\n        pass\n\n\ndef func():\n    with B().get() as b:\n        b.play()  # [too-many-function-args]\n"}], "retrieved_count": 10, "cost_time": 0.34424543380737305}
{"question": "Where is the call chain through which the forward reference resolution for string literal type annotations in function return type annotations gets processed by the type checking infrastructure?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 137000, "end_line": 138916, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r\n        if not isinstance(inferred_slice, nodes.Const) or not isinstance(\n            inferred_slice.value, int\n        ):\n            return\n\n        # If the node.value is a Tuple or List without inference it is defined in place\n        if isinstance(node.value, (nodes.Tuple, nodes.List)):\n            # Add 1 because iterables are 0-indexed\n            if self._inferred_iterable_length(node.value) < inferred_slice.value + 1:\n                self.add_message(\n                    \"potential-index-error\", node=node, confidence=INFERENCE\n                )\n            return\n\n    @utils.only_required_for_messages(\n        \"unused-import\",\n        \"unused-variable\",\n    )\n    def visit_const(self, node: nodes.Const) -> None:\n        \"\"\"Take note of names that appear inside string literal type annotations\n        unless the string is a parameter to `typing.Literal` or `typing.Annotation`.\n        \"\"\"\n        if node.pytype() != \"builtins.str\":\n            return\n        if not utils.is_node_in_type_annotation_context(node):\n            return\n\n        # Check if parent's or grandparent's first child is typing.Literal\n        parent = node.parent\n        if isinstance(parent, nodes.Tuple):\n            parent = parent.parent\n        if isinstance(parent, nodes.Subscript):\n            origin = next(parent.get_children(), None)\n            if origin is not None and utils.is_typing_member(\n                origin, (\"Annotated\", \"Literal\")\n            ):\n                return\n\n        try:\n            annotation = extract_node(node.value)\n            self._store_type_annotation_node(annotation)\n        except ValueError:\n            # e.g. node.value is white space\n            pass\n        except astroid.AstroidSyntaxError:\n            # e.g. \"?\" or \":\" in typing.Literal[\"?\", \":\"]\n            pass\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(VariablesChecker(linter))\n"}, {"start_line": 0, "end_line": 925, "belongs_to": {"file_name": "unused_name_in_string_literal_type_annotation.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test if pylint sees names inside string literal type annotations. #3299\"\"\"\n# pylint: disable=too-few-public-methods\n\nfrom argparse import ArgumentParser, Namespace\nimport os\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import NoReturn, Set\n\n# unused-import shouldn't be emitted for Path\nexample1: Set[\"Path\"] = set()\n\ndef example2(_: \"ArgumentParser\") -> \"NoReturn\":\n    \"\"\"unused-import shouldn't be emitted for ArgumentParser or NoReturn.\"\"\"\n    while True:\n        pass\n\ndef example3(_: \"os.PathLike[str]\") -> None:\n    \"\"\"unused-import shouldn't be emitted for os.\"\"\"\n\ndef example4(_: \"PathLike[str]\") -> None:\n    \"\"\"unused-import shouldn't be emitted for PathLike.\"\"\"\n\n# pylint shouldn't crash with the following strings in a type annotation context\nexample5: Set[\"\"]\nexample6: Set[\" \"]\nexample7: Set[\"?\"]\n\nclass Class:\n    \"\"\"unused-import shouldn't be emitted for Namespace\"\"\"\n    cls: \"Namespace\"\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nments_call_private_name(name_assignments, private_name)\n                )\n\n    def _populate_type_annotations_function(\n        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds all names used as type annotation in the arguments and return type of\n        the function node into the dict `all_used_type_annotations`.\n        \"\"\"\n        if node.args and node.args.annotations:\n            for annotation in node.args.annotations:\n                self._populate_type_annotations_annotation(\n                    annotation, all_used_type_annotations\n                )\n        if node.returns:\n            self._populate_type_annotations_annotation(\n                node.returns, all_used_type_annotations\n            )\n\n    def _populate_type_annotations_annotation(\n        self,\n        node: nodes.Attribute | nodes.Subscript | nodes.Name | None,\n        all_used_type_annotations: dict[str, bool],\n    ) -> str | None:\n        \"\"\"Handles the possibility of an annotation either being a Name, i.e. just type,\n        or a Subscript e.g. `Optional[type]` or an Attribute, e.g. `pylint.lint.linter`.\n        \"\"\"\n        if isinstance(node, nodes.Name) and node.name not in all_used_type_annotations:\n            all_used_type_annotations[node.name] = True\n            return node.name  # type: ignore[no-any-return]\n        if isinstance(node, nodes.Subscript):  # e.g. Optional[List[str]]\n            # slice is the next nested type\n            self._populate_type_annotations_annotation(\n                node.slice, all_used_type_annotations\n            )\n            # value is the current type name: could be a Name or Attribute\n            return self._populate_type_annotations_annotation(\n                node.value, all_used_type_annotations\n            )\n        if isinstance(node, nodes.Attribute):\n            # An attribute is a type like `pylint.lint.pylinter`. node.expr is the next level\n            # up, could be another attrib"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "private_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "name_assignments.append(assign_parent)\n                        private_name = self._populate_type_annotations_annotation(\n                            usage_node.parent.annotation, all_used_type_annotations\n                        )\n                    elif isinstance(assign_parent, nodes.Assign):\n                        name_assignments.append(assign_parent)\n\n                if isinstance(usage_node, nodes.FunctionDef):\n                    self._populate_type_annotations_function(\n                        usage_node, all_used_type_annotations\n                    )\n                if isinstance(usage_node, nodes.LocalsDictNodeNG):\n                    self._populate_type_annotations(\n                        usage_node, all_used_type_annotations\n                    )\n            if private_name is not None:\n                # Found a new private annotation, make sure we are not accessing it elsewhere\n                all_used_type_annotations[private_name] = (\n                    self._assignments_call_private_name(name_assignments, private_name)\n                )\n\n    def _populate_type_annotations_function(\n        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds all names used as type annotation in the arguments and return type of\n        the function node into the dict `all_used_type_annotations`.\n        \"\"\"\n        if node.args and node.args.annotations:\n            for annotation in node.args.annotations:\n                self._populate_type_annotations_annotation(\n                    annotation, all_used_type_annotations\n                )\n        if node.returns:\n            self._populate_type_annotations_annotation(\n                node.returns, all_used_type_annotations\n            )\n\n    def _populate_type_annotations_annotation(\n        self,\n        node: nodes.Attribute | nodes.Subscript | nodes.Name | None,\n        all_used_type_annotations: dict[str, bool],\n    ) -> str | None:\n        \"\"\"Handles the "}, {"start_line": 0, "end_line": 968, "belongs_to": {"file_name": "typing_broken_noreturn_future_import.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/typing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n'typing.NoReturn' is broken inside compound types for Python 3.7.0\nhttps://bugs.python.org/issue34921\n\nIf no runtime introspection is required, use string annotations instead.\n\nWith 'from __future__ import annotations', only emit errors for nodes\nnot in a type annotation context.\n\"\"\"\n# pylint: disable=missing-docstring,broad-exception-raised,invalid-name\nfrom __future__ import annotations\n\nimport typing\nfrom typing import TYPE_CHECKING, Callable, NoReturn, Union\n\nimport typing_extensions\n\n\ndef func1() -> NoReturn:\n    raise Exception\n\n\ndef func2() -> Union[None, NoReturn]:\n    pass\n\n\ndef func3() -> Union[None, \"NoReturn\"]:\n    pass\n\n\ndef func4() -> Union[None, typing.NoReturn]:\n    pass\n\n\ndef func5() -> Union[None, typing_extensions.NoReturn]:\n    pass\n\n\nAlias1 = NoReturn\nAlias2 = Callable[..., NoReturn]  # [broken-noreturn]\nAlias3 = Callable[..., \"NoReturn\"]\n\nif TYPE_CHECKING:\n    # ok inside TYPE_CHECKING block\n    Alias4 = Callable[..., NoReturn]\n"}, {"start_line": 0, "end_line": 885, "belongs_to": {"file_name": "unused_name_in_string_literal_type_annotation_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/unused", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\n\nfrom argparse import ArgumentParser # [unused-import]\nfrom argparse import Namespace  # [unused-import]\nimport http  # [unused-import]\nfrom http import HTTPStatus\nimport typing as t\nfrom typing import Literal as Lit\n\n# str inside Literal shouldn't be treated as names\nexample1: t.Literal[\"ArgumentParser\", Lit[\"Namespace\", \"ArgumentParser\"]]\n\n\ndef unused_variable_example():\n    hello = \"hello\" # [unused-variable]\n    world = \"world\" # [unused-variable]\n    example2: Lit[\"hello\", \"world\"] = \"hello\"\n    return example2\n\n\n# pylint shouldn't crash with the following strings in a type annotation context\nEXAMPLE3: Lit[\"\", \" \", \"?\"] = \"?\"\n\n\n# See https://peps.python.org/pep-0586/#literals-enums-and-forward-references\nexample4: t.Literal[\"http.HTTPStatus.OK\", \"http.HTTPStatus.NOT_FOUND\"]\nexample5: \"t.Literal[HTTPStatus.OK, HTTPStatus.NOT_FOUND]\"\n"}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al`.\n    \"\"\"\n    if not isinstance(node.parent, nodes.AnnAssign):\n        return False\n    annotation = node.parent.annotation\n    if isinstance(annotation, nodes.Subscript):\n        annotation = annotation.value\n    if (isinstance(annotation, nodes.Name) and annotation.name == typing_name) or (\n        isinstance(annotation, nodes.Attribute) and annotation.attrname == typing_name\n    ):\n        return True\n    return False\n\n\ndef get_iterating_dictionary_name(node: nodes.For | nodes.Comprehension) -> str | None:\n    \"\"\"Get the name of the dictionary which keys are being iterated over on\n    a ``nodes.For`` or ``nodes.Comprehension`` node.\n\n    If the iterating object is not either the keys method of a dictionary\n    or a dictionary itself, this returns None.\n    \"\"\"\n    # Is it a proper keys call?\n    if (\n        isinstance(node.iter, nodes.Call)\n        and isinstance(node.iter.func, nodes.Attribute)\n        and node.iter.func.attrname == \"keys\"\n    ):\n        inferred = safe_infer(node.iter.func)\n        if not isinstance(inferred, astroid.BoundMethod):\n            return None\n        return node.iter.as_string().rpartition(\".keys\")[0]  # type: ignore[no-any-return]\n\n    # Is it a dictionary?\n    if isinstance(node.iter, (nodes.Name, nodes.Attribute)):\n        inferred = safe_infer(node.iter)\n        if not isinstance(inferred, nodes.Dict):\n            return None\n        return node.iter.as_string()  # type: ignore[no-any-return]\n\n    return None\n\n\ndef get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:\n    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n    if not isinstance(inferred, nodes.Const):\n        raise InferredTypeError(\"Subscript.slice cannot be inferred as a nodes.Const\")\n\n    return inferred\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/pyreverse", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "),\n        (\"def f() -> int: pass\", \"int\"),\n        (\"def f(a) -> Optional[int]: return 1 if a else None\", \"Optional[int]\"),\n        (\"def f() -> 'MyType': pass\", \"'MyType'\"),\n    ],\n)\ndef test_get_annotation_label_of_return_type(\n    node_text: str, expected_label: str\n) -> None:\n    func = astroid.extract_node(node_text)\n    assert isinstance(func, nodes.FunctionDef)\n    assert get_annotation_label(func.returns) == expected_label\n\n\n@patch(\"pylint.pyreverse.utils.get_annotation\")\n@patch(\"astroid.nodes.NodeNG.infer\", side_effect=astroid.InferenceError)\ndef test_infer_node_1(mock_infer: Any, mock_get_annotation: Any) -> None:\n    \"\"\"Return set() when astroid.InferenceError is raised and an annotation has\n    not been returned.\n    \"\"\"\n    mock_get_annotation.return_value = None\n    node = astroid.extract_node(\"a: str = 'mystr'\")\n    mock_infer.return_value = \"x\"\n    assert infer_node(node) == set()\n    assert mock_infer.called\n\n\n@patch(\"pylint.pyreverse.utils.get_annotation\")\n@patch(\"astroid.nodes.NodeNG.infer\")\ndef test_infer_node_2(mock_infer: Any, mock_get_annotation: Any) -> None:\n    \"\"\"Return set(node.infer()) when InferenceError is not raised and an\n    annotation has not been returned.\n    \"\"\"\n    mock_get_annotation.return_value = None\n    node = astroid.extract_node(\"a: str = 'mystr'\")\n    mock_infer.return_value = \"x\"\n    assert infer_node(node) == set(\"x\")\n    assert mock_infer.called\n\n\ndef test_infer_node_3() -> None:\n    \"\"\"Return a set containing a nodes.ClassDef object when the attribute\n    has a type annotation.\n    \"\"\"\n    node = astroid.extract_node(\n        \"\"\"\n        class Component:\n            pass\n\n        class Composite:\n            def __init__(self, component: Component):\n                self.component = component\n    \"\"\"\n    )\n    instance_attr = node.instance_attrs.get(\"component\")[0]\n    assert isinstance(infer_node(instance_attr), set)\n    assert isinstance(infer_node(instance_attr).pop(), nodes.ClassDef)\n\n\ndef test_infer_node_4() ->"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          for msg in self._deprecated_typing_alias_msgs:\n                if (\n                    self._found_broken_callable_location\n                    and msg.qname == \"typing.Callable\"\n                ):\n                    continue\n                self.add_message(\n                    \"deprecated-typing-alias\",\n                    node=msg.node,\n                    args=(msg.qname, msg.alias),\n                    confidence=INFERENCE,\n                )\n\n        elif self._py37_plus:\n            msg_future_import = self._msg_postponed_eval_hint(node)\n            for msg in self._consider_using_alias_msgs:\n                if msg.qname in self._alias_name_collisions:\n                    continue\n                self.add_message(\n                    \"consider-using-alias\",\n                    node=msg.node,\n                    args=(\n                        msg.qname,\n                        msg.alias,\n                        msg_future_import if msg.parent_subscript else \"\",\n                    ),\n                    confidence=INFERENCE,\n                )\n\n        # Clear all module cache variables\n        self._found_broken_callable_location = False\n        self._deprecated_typing_alias_msgs.clear()\n        self._alias_name_collisions.clear()\n        self._consider_using_alias_msgs.clear()\n\n    def _check_broken_noreturn(self, node: nodes.Name | nodes.Attribute) -> None:\n        \"\"\"Check for 'NoReturn' inside compound types.\"\"\"\n        if not isinstance(node.parent, nodes.BaseContainer):\n            # NoReturn not part of a Union or Callable type\n            return\n\n        if in_type_checking_block(node) or (\n            self._postponed_evaluation_enabled\n            and is_node_in_type_annotation_context(node)\n        ):\n            return\n\n        for inferred in node.infer():\n            # To deal with typing_extensions, don't use safe_infer\n            if (\n                (\n                    isinstance(inferred, (nodes.FunctionDef, nodes.ClassDef))\n    "}, {"start_line": 90000, "end_line": 92000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_parent := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n     "}], "retrieved_count": 10, "cost_time": 0.3494751453399658}
{"question": "Where is the example function that searches for even numbers using a loop with an else clause defined in the documentation directory for the checker message category that flags loops with else clauses lacking break statements?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 178, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/u/useless-else-on-loop", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def find_even_number(numbers):\n    for x in numbers:\n        if x % 2 == 0:\n            return x\n    else:  # [useless-else-on-loop]\n        print(\"Did not find an even number\")\n"}, {"start_line": 0, "end_line": 136, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/u/undefined-loop-variable", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def find_even_number(numbers):\n    for x in numbers:\n        if x % 2 == 0:\n            break\n    return x  # [undefined-loop-variable]\n"}, {"start_line": 2000, "end_line": 3948, "belongs_to": {"file_name": "undefined_loop_variable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le:\n        break\n    else:\n        return\n    print(thing)\n\n\ndef for_else_raises(iterable):\n    for thing in iterable:\n        break\n    else:\n        raise Exception\n    print(thing)\n\n\ndef for_else_break(iterable):\n    while True:\n        for thing in iterable:\n            break\n        else:\n            break\n        print(thing)\n\n\ndef for_else_continue(iterable):\n    while True:\n        for thing in iterable:\n            break\n        else:\n            continue\n        print(thing)\n\n\ndef for_else_no_return(iterable):\n    def fail() -> NoReturn:\n        ...\n\n    while True:\n        for thing in iterable:\n            break\n        else:\n            fail()\n        print(thing)\n\n\nLIST = []\nLIST2 = [1, 2, 3]\n\nfor item in LIST:\n    pass\n\nBIGGER = [\n    [\n        x for x in LIST2 if x > item\n    ]\n    for item in LIST\n]\n\n\ndef lambda_in_first_of_two_loops():\n    \"\"\"https://github.com/pylint-dev/pylint/issues/6419\"\"\"\n    my_list = []\n    for thing in my_list:\n        print_it = lambda: print(thing)  # pylint: disable=cell-var-from-loop, unnecessary-lambda-assignment\n        print_it()\n\n    for thing in my_list:\n        print(thing)\n\n\ndef variable_name_assigned_in_body_of_second_loop():\n    for alias in tuple(BIGGER):\n        continue\n    for _ in range(3):\n        alias = True\n        if alias:\n            print(alias)\n\n\ndef use_enumerate():\n    \"\"\"https://github.com/pylint-dev/pylint/issues/6593\"\"\"\n    for i, num in enumerate(range(3)):\n        pass\n    print(i, num)\n\n\ndef use_enumerate_in_ternary_expression():\n    \"\"\"https://github.com/pylint-dev/pylint/issues/7131\"\"\"\n    for i, num in enumerate(range(3)) if __revision__ else enumerate(range(4)):\n        pass\n    print(i, num)\n\n\ndef find_even_number(container):\n    \"\"\"https://github.com/pylint-dev/pylint/pull/6923#discussion_r895134495\"\"\"\n    for something in container:\n        if something % 2 == 0:\n            break\n    return something  # [undefined-loop-variable]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "no_else_break.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/no", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Test that superfluous else break are detected. \"\"\"\n\n# pylint:disable=invalid-name,missing-docstring,unused-variable\n\n\ndef foo1(x, y, z):\n    for i in x:\n        if i > y:  # [no-else-break]\n            break\n        else:\n            a = z\n\n\ndef foo2(x, y, w, z):\n    for i in x:\n        if i > y:  # [no-else-break]\n            break\n        elif i > w:\n            break\n        else:\n            a = z\n\n\ndef foo3(x, y, z):\n    for i in x:\n        if i > y:\n            a = 1\n            if z:  # [no-else-break]\n                b = 2\n                break\n            else:\n                c = 3\n                break\n        else:\n            d = 4\n            break\n\n\ndef foo4(x, y):\n    for i in x:\n        if i > x:  # [no-else-break]\n            if y:\n                a = 4\n            else:\n                b = 2\n            break\n        else:\n            c = 3\n        break\n\n\ndef foo5(x, y, z):\n    for i in x:\n        if i > y:  # [no-else-break]\n            if y:\n                a = 4\n            else:\n                b = 2\n            break\n        elif z:\n            c = 2\n        else:\n            c = 3\n        break\n\n\ndef foo6(x, y):\n    for i in x:\n        if i > x:\n            if y:  # [no-else-break]\n                a = 4\n                break\n            else:\n                b = 2\n        else:\n            c = 3\n        break\n\n\ndef bar1(x, y, z):\n    for i in x:\n        if i > y:\n            break\n        return z\n\n\ndef bar2(w, x, y, z):\n    for i in w:\n        if i > x:\n            break\n        if z < i:\n            a = y\n        else:\n            break\n        return\n\n\ndef bar3(x, y, z):\n    for i in x:\n        if i > y:\n            if z:\n                break\n        else:\n            return z\n        return None\n\n\ndef bar4(x):\n    for i in range(10):\n        if x:  # [no-else-break]\n            break\n        else:\n            try:\n                return\n            except ValueError:\n                break\n\n\ndef nested1(x, y, z):\n    for i in x:\n   "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "useless_else_on_loop.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/useless", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check for else branches on loops with break and return only.\"\"\"\n\n\ndef test_return_for():\n    \"\"\"else + return is not acceptable.\"\"\"\n    for i in range(10):\n        if i % 2:\n            return i\n    else:  # [useless-else-on-loop]\n        print('math is broken')\n    return None\n\ndef test_return_while():\n    \"\"\"else + return is not acceptable.\"\"\"\n    while True:\n        return 1\n    else:  # [useless-else-on-loop]\n        print('math is broken')\n    return None\n\n\nwhile True:\n    def short_fun():\n        \"\"\"A function with a loop.\"\"\"\n        for _ in range(10):\n            break\nelse:  # [useless-else-on-loop]\n    print('or else!')\n\n\nwhile True:\n    while False:\n        break\nelse:  # [useless-else-on-loop]\n    print('or else!')\n\nfor j in range(10):\n    pass\nelse:  # [useless-else-on-loop]\n    print('fat chance')\n    for j in range(10):\n        break\n\n\ndef test_return_for2():\n    \"\"\"no false positive for break in else\n\n    https://bitbucket.org/logilab/pylint/issue/117/useless-else-on-loop-false-positives\n    \"\"\"\n    for i in range(10):\n        for _ in range(i):\n            if i % 2:\n                break\n        else:\n            break\n    else:\n        print('great math')\n\n\ndef test_break_in_orelse_deep():\n    \"\"\"no false positive for break in else deeply nested\n    \"\"\"\n    for _ in range(10):\n        if 1 < 2:  # pylint: disable=comparison-of-constants\n            for _ in range(3):\n                if 3 < 2:  # pylint: disable=comparison-of-constants\n                    break\n            else:\n                break\n    else:\n        return True\n    return False\n\n\ndef test_break_in_orelse_deep2():\n    \"\"\"should rise a useless-else-on-loop message, as the break statement is only\n    for the inner for loop\n    \"\"\"\n    for _ in range(10):\n        if 1 < 2:  # pylint: disable=comparison-of-constants\n            for _ in range(3):\n                if 3 < 2:  # pylint: disable=comparison-of-constants\n                    break\n            else:\n                print(\"al"}, {"start_line": 0, "end_line": 139, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/n/not-in-loop", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def print_even_numbers():\n    for i in range(100):\n        if i % 2 == 0:\n            print(i)\n    else:\n        continue  # [not-in-loop]\n"}, {"start_line": 1000, "end_line": 2311, "belongs_to": {"file_name": "no_else_break.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/no", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "= 4\n            else:\n                b = 2\n            break\n        elif z:\n            c = 2\n        else:\n            c = 3\n        break\n\n\ndef foo6(x, y):\n    for i in x:\n        if i > x:\n            if y:  # [no-else-break]\n                a = 4\n                break\n            else:\n                b = 2\n        else:\n            c = 3\n        break\n\n\ndef bar1(x, y, z):\n    for i in x:\n        if i > y:\n            break\n        return z\n\n\ndef bar2(w, x, y, z):\n    for i in w:\n        if i > x:\n            break\n        if z < i:\n            a = y\n        else:\n            break\n        return\n\n\ndef bar3(x, y, z):\n    for i in x:\n        if i > y:\n            if z:\n                break\n        else:\n            return z\n        return None\n\n\ndef bar4(x):\n    for i in range(10):\n        if x:  # [no-else-break]\n            break\n        else:\n            try:\n                return\n            except ValueError:\n                break\n\n\ndef nested1(x, y, z):\n    for i in x:\n        if i > x:\n            for j in y:\n                if j < z:\n                    break\n        else:\n            a = z\n\n\ndef nested2(x, y, z):\n    for i in x:\n        if i > x:\n            for j in y:\n                if j > z:\n                    break\n                break\n        else:\n            a = z\n"}, {"start_line": 6000, "end_line": 7349, "belongs_to": {"file_name": "for_any_all.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/for_any_all", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "num)\n            potential_line_length_warning = True\n    return potential_line_length_warning\n\ns = [\"hi\", \"hello\", \"goodbye\", None]\n\nflag = True\nfor i, elem in enumerate(s):\n    if elem is None:\n        continue\n    cnt_s = cnt_t = 0\n    for j in range(i, len(s)):\n        if s[j] == elem:\n            cnt_s += 1\n            s[j] = None\n            Flag = False\n\ndef with_elif(split_lines, max_chars):\n    \"\"\"\n    Do not raise consider-using-any-or-all because the intent in this code\n    is to iterate over all the lines (not short-circuit) and see what\n    the last value would be.\n    \"\"\"\n    last_longest_line = False\n    for line in split_lines:\n        if len(line) > max_chars:\n            last_longest_line = True\n        elif len(line) == max_chars:\n            last_longest_line = False\n    return last_longest_line\n\ndef first_even(items):\n    \"\"\"Return first even number\"\"\"\n    for item in items:\n        if item % 2 == 0:\n            return item\n    return None\n\ndef even(items):\n    for item in items:\n        if item % 2 == 0:\n            return True\n    return None\n\ndef iterate_leaves(leaves, current_node):\n    results = []\n\n    current_node.was_checked = True\n    for leaf in leaves:\n        if isinstance(leaf, bool):\n            current_node.was_checked = False\n        else:\n            results.append(leaf)\n    return results\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "no_else_continue.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/no", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Test that superfluous else continue are detected. \"\"\"\n\n# pylint:disable=invalid-name,missing-docstring,unused-variable\n\n\ndef foo1(x, y, z):\n    for i in x:\n        if i < y:  # [no-else-continue]\n            continue\n        else:\n            a = z\n\n\ndef foo2(x, y, w, z):\n    for i in x:\n        if i < y:  # [no-else-continue]\n            continue\n        elif i < w:\n            continue\n        else:\n            a = z\n\n\ndef foo3(x, y, z):\n    for i in x:\n        if i < y:\n            a = 1\n            if z:  # [no-else-continue]\n                b = 2\n                continue\n            else:\n                c = 3\n                continue\n        else:\n            d = 4\n            continue\n\n\ndef foo4(x, y):\n    for i in x:\n        if i < x:  # [no-else-continue]\n            if y:\n                a = 4\n            else:\n                b = 2\n            continue\n        else:\n            c = 3\n        continue\n\n\ndef foo5(x, y, z):\n    for i in x:\n        if i < y:  # [no-else-continue]\n            if y:\n                a = 4\n            else:\n                b = 2\n            continue\n        elif z:\n            c = 2\n        else:\n            c = 3\n        continue\n\n\ndef foo6(x, y):\n    for i in x:\n        if i < x:\n            if y:  # [no-else-continue]\n                a = 4\n                continue\n            else:\n                b = 2\n        else:\n            c = 3\n        continue\n\n\ndef bar1(x, y, z):\n    for i in x:\n        if i < y:\n            continue\n        return z\n\n\ndef bar2(w, x, y, z):\n    for i in w:\n        if i < x:\n            continue\n        if z < i:\n            a = y\n        else:\n            continue\n        return\n\n\ndef bar3(x, y, z):\n    for i in x:\n        if i < y:\n            if z:\n                continue\n        else:\n            return z\n        return None\n\n\ndef bar4(x):\n    for i in range(10):\n        if x:  # [no-else-continue]\n            continue\n        else:\n            try:\n                return\n            except Va"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "for_any_all.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/for_any_all", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Functional test\"\"\"\n# pylint: disable=missing-function-docstring, invalid-name\n\ndef any_even(items):\n    \"\"\"Return True if the list contains any even numbers\"\"\"\n    for item in items: # [consider-using-any-or-all]\n        if item % 2 == 0:\n            return True\n    return False\n\ndef all_even(items):\n    \"\"\"Return True if the list contains all even numbers\"\"\"\n    for item in items: # [consider-using-any-or-all]\n        if not item % 2 == 0:\n            return False\n    return True\n\ndef any_uneven(items):\n    \"\"\"Return True if the list contains any uneven numbers\"\"\"\n    for item in items: # [consider-using-any-or-all]\n        if not item % 2 == 0:\n            return True\n    return False\n\ndef all_uneven(items):\n    \"\"\"Return True if the list contains all uneven numbers\"\"\"\n    for item in items: # [consider-using-any-or-all]\n        if item % 2 == 0:\n            return False\n    return True\n\ndef is_from_string(item):\n    \"\"\"Return True if one of parents of item is a string\"\"\"\n    for parent in item.parents(): # [consider-using-any-or-all]\n        if isinstance(parent, str):\n            return True\n    return False\n\ndef is_not_from_string(item):\n    \"\"\"Return True if one of parents of item isn't a string\"\"\"\n    for parent in item.parents(): # [consider-using-any-or-all]\n        if not isinstance(parent, str):\n            return True\n    return False\n\ndef nested_check(items):\n    \"\"\"Tests that for loops at deeper levels are picked up\"\"\"\n    if items and len(items) > 5:\n        print(items)\n        for item in items: # [consider-using-any-or-all]\n            if item in (1, 2, 3):\n                return False\n        return True\n    print(items)\n    return items[3] > 5\n\ndef words_contains_word(words):\n    \"\"\"Return whether words contains 'word'\"\"\"\n    for word in words: # [consider-using-any-or-all]\n        if word == \"word\":\n            return True\n    return False\n\ndef complicated_condition_check(items):\n    \"\"\"Case where we expect not any statement with a more compl"}], "retrieved_count": 10, "cost_time": 0.33713579177856445}
{"question": "Why does the memory overhead of the pickle protocol reconstruction method validated by the classes checker during repeated instantiation impact garbage collection cycles and heap fragmentation when thousands of instances are created and destroyed?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "arallel-checker\"\n    test_data = \"extra-parallel\"\n\n\nclass ThirdSequentialTestChecker(SequentialTestChecker):\n    \"\"\"A checker that does not need to consolidate data across run invocations.\"\"\"\n\n    name = \"third-sequential-checker\"\n    test_data = \"third-sequential\"\n\n\nclass ThirdParallelTestChecker(ParallelTestChecker):\n    \"\"\"A checker that does need to consolidate data across run invocations.\"\"\"\n\n    name = \"third-parallel-checker\"\n    test_data = \"third-parallel\"\n\n\nclass TestCheckParallelFramework:\n    \"\"\"Tests the check_parallel() function's framework.\"\"\"\n\n    def setup_class(self) -> None:\n        self._prev_global_linter = pylint.lint.parallel._worker_linter\n\n    def teardown_class(self) -> None:\n        pylint.lint.parallel._worker_linter = self._prev_global_linter\n\n    def test_worker_initialize(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        worker_initialize(linter=dill.dumps(linter))\n        assert isinstance(pylint.lint.parallel._worker_linter, type(linter))\n\n    def test_worker_initialize_with_package_paths(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        with augmented_sys_path([]):\n            worker_initialize(\n                linter=dill.dumps(linter), extra_packages_paths=[\"fake-path\"]\n            )\n            assert \"fake-path\" in sys.path\n\n    def test_worker_initialize_reregisters_custom_plugins(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        linter.load_plugin_modules([\"pylint.extensions.private_import\"])\n\n        pickled = dill.dumps(linter)\n        with patch(\n            \"pylint.extensions.private_import.register\", side_effect=AssertionError\n        ):\n            with pytest.raises(AssertionError):\n                worker_initialize(linter=pickled)\n\n    @pytest.mark.needs_two_cores\n    def test_worker_initialize_pickling(self) -> None:\n        \"\"\"Test that we can pickle objects that standard pickling in multiprocessing can't.\n\n        See:\n        https://stackoverflow.com/ques"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ter))\n\n    def test_worker_initialize_with_package_paths(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        with augmented_sys_path([]):\n            worker_initialize(\n                linter=dill.dumps(linter), extra_packages_paths=[\"fake-path\"]\n            )\n            assert \"fake-path\" in sys.path\n\n    def test_worker_initialize_reregisters_custom_plugins(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        linter.load_plugin_modules([\"pylint.extensions.private_import\"])\n\n        pickled = dill.dumps(linter)\n        with patch(\n            \"pylint.extensions.private_import.register\", side_effect=AssertionError\n        ):\n            with pytest.raises(AssertionError):\n                worker_initialize(linter=pickled)\n\n    @pytest.mark.needs_two_cores\n    def test_worker_initialize_pickling(self) -> None:\n        \"\"\"Test that we can pickle objects that standard pickling in multiprocessing can't.\n\n        See:\n        https://stackoverflow.com/questions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function\n        https://github.com/pylint-dev/pylint/pull/5584\n        \"\"\"\n        linter = PyLinter(reporter=Reporter())\n        linter.attribute = argparse.ArgumentParser()  # type: ignore[attr-defined]\n        with ProcessPoolExecutor(\n            max_workers=2, initializer=worker_initialize, initargs=(dill.dumps(linter),)\n        ) as executor:\n            executor.map(print, [1, 2])\n\n    def test_worker_check_single_file_uninitialised(self) -> None:\n        pylint.lint.parallel._worker_linter = None\n        with pytest.raises(  # Objects that do not match the linter interface will fail\n            RuntimeError, match=\"Worker linter not yet initialised\"\n        ):\n            worker_check_single_file(_gen_file_data())\n\n    def test_worker_check_single_file_no_checkers(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        worker_initialize(linter=dill.dumps(linter))\n\n        (\n            _,  # proc"}, {"start_line": 1000, "end_line": 2723, "belongs_to": {"file_name": "invalid_getnewargs_ex_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self._bar = far\n        self._hoo = hoo\n        self._haha = haha\n\n    def __getnewargs_ex__(self):\n        args = (self._foo, self._bar)\n        kwargs = {'hoo': self._hoo,\n                  'haha': self._haha}\n        return args, kwargs\n\n\nclass FirstBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns an integer \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return 1\n\n\nclass SecondBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with incorrect arg length\"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (tuple(1), dict(x=\"y\"), 1)\n\n\nclass ThirdBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for first arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return (dict(x=\"y\"), dict(x=\"y\"))\n\n\nclass FourthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for second arg \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ((1, ), (1, ))\n\n\nclass FifthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns tuple with wrong type for both args \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return ({'x': 'y'}, (2,))\n\n\nclass SixthBadGetNewArgsEx:\n    \"\"\" __getnewargs_ex__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs_ex__(self):  # [invalid-getnewargs-ex-returned]\n        return lambda: (1, 2)\n\n\nclass AmbigousGetNewArgsEx:\n    \"\"\" Uninferable return value \"\"\"\n\n    __getnewargs_ex__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgsEx:\n    \"\"\"Potential uninferable return value\"\"\"\n\n    def __getnewargs_ex__(self):\n        return tuple(Missing)\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lugins_is_pickleable(self) -> None:\n        \"\"\"The linter needs to be pickle-able in order to be passed between workers.\"\"\"\n        linter = PyLinter(reporter=Reporter())\n        # We load an extension that we know is not pickle-safe\n        linter.load_plugin_modules([\"pylint.extensions.overlapping_exceptions\"])\n        try:\n            dill.dumps(linter)\n            # TODO: 4.0: Fix this test by raising this assertion again\n            # raise AssertionError(\n            #     \"Plugins loaded were pickle-safe! This test needs altering\"\n            # )\n        except (KeyError, TypeError, PickleError, NotImplementedError):\n            pass\n\n        # And expect this call to make it pickle-able\n        linter.load_plugin_configuration()\n        try:\n            dill.dumps(linter)\n        except KeyError as exc:\n            raise AssertionError(\n                \"Cannot pickle linter when using non-pickleable plugin\"\n            ) from exc\n\n    def test_worker_check_sequential_checker(self) -> None:\n        \"\"\"Same as test_worker_check_single_file_no_checkers with SequentialTestChecker.\"\"\"\n        linter = PyLinter(reporter=Reporter())\n        worker_initialize(linter=dill.dumps(linter))\n\n        # Add the only checker we care about in this test\n        linter.register_checker(SequentialTestChecker(linter))\n\n        (\n            _,  # proc-id\n            name,\n            _,  # file_path\n            _,  # base_name\n            msgs,\n            stats,\n            msg_status,\n            _,  # mapreduce_data\n        ) = worker_check_single_file(_gen_file_data())\n\n        # Ensure we return the same data as the single_file_no_checkers test\n        assert name == \"--test-file_data-name-0--\"\n        assert not msgs\n        no_errors_status = 0\n        assert no_errors_status == msg_status\n        assert {\n            \"--test-file_data-name-0--\": {\n                \"convention\": 0,\n                \"error\": 0,\n                \"fatal\": 0,\n                \"info\": 0,\n         "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Classes checker for Python code.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import defaultdict\nfrom collections.abc import Callable, Sequence\nfrom functools import cached_property\nfrom itertools import chain, zip_longest\nfrom re import Pattern\nfrom typing import TYPE_CHECKING, Any, NamedTuple, TypeAlias\n\nimport astroid\nfrom astroid import bases, nodes, util\nfrom astroid.nodes import LocalsDictNodeNG\nfrom astroid.typing import SuccessfulInferenceResult\n\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.checkers.utils import (\n    PYMETHODS,\n    class_is_abstract,\n    decorated_with,\n    decorated_with_property,\n    get_outer_class,\n    has_known_bases,\n    is_attr_private,\n    is_attr_protected,\n    is_builtin_object,\n    is_comprehension,\n    is_iterable,\n    is_property_setter,\n    is_property_setter_or_deleter,\n    node_frame_class,\n    only_required_for_messages,\n    safe_infer,\n    unimplemented_abstract_methods,\n    uninferable_final_decorators,\n)\nfrom pylint.interfaces import HIGH, INFERENCE\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter\n\n\n_AccessNodes: TypeAlias = nodes.Attribute | nodes.AssignAttr\n\nINVALID_BASE_CLASSES = {\"bool\", \"range\", \"slice\", \"memoryview\"}\nALLOWED_PROPERTIES = {\"bultins.property\", \"functools.cached_property\"}\nBUILTIN_DECORATORS = {\"builtins.property\", \"builtins.classmethod\"}\nASTROID_TYPE_COMPARATORS = {\n    nodes.Const: lambda a, b: a.value == b.value,\n    nodes.ClassDef: lambda a, b: a.qname == b.qname,\n    nodes.Tuple: lambda a, b: a.elts == b.elts,\n    nodes.List: lambda a, b: a.elts == b.elts,\n    nodes.Dict: lambda a, b: a.items == b.items,\n    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),\n}\n\n# Deali"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Puts the check_parallel system under test.\"\"\"\n\n# pylint: disable=protected-access,missing-function-docstring\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom concurrent.futures import ProcessPoolExecutor\nfrom concurrent.futures.process import BrokenProcessPool\nfrom pathlib import Path\nfrom pickle import PickleError\nfrom typing import TYPE_CHECKING\nfrom unittest.mock import patch\n\nimport dill\nimport pytest\n\nimport pylint.interfaces\nimport pylint.lint.parallel\nfrom pylint.checkers import BaseRawFileChecker\nfrom pylint.checkers.imports import ImportsChecker\nfrom pylint.lint import PyLinter, augmented_sys_path\nfrom pylint.lint.parallel import _worker_check_single_file as worker_check_single_file\nfrom pylint.lint.parallel import _worker_initialize as worker_initialize\nfrom pylint.lint.parallel import check_parallel\nfrom pylint.reporters.progress_reporters import ProgressReporter\nfrom pylint.testutils import GenericTestReporter as Reporter\nfrom pylint.testutils.utils import _test_cwd\nfrom pylint.typing import FileItem\nfrom pylint.utils import LinterStats, ModuleStats\n\nif TYPE_CHECKING:\n    from unittest.mock import MagicMock\n\n    from astroid import nodes\n\n\ndef _gen_file_data(idx: int = 0) -> FileItem:\n    \"\"\"Generates a file to use as a stream.\"\"\"\n    filepath = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"input\", \"similar1\")\n    )\n    file_data = FileItem(\n        f\"--test-file_data-name-{idx}--\",\n        filepath,\n        f\"--test-file_data-modname-{idx}--\",\n    )\n    return file_data\n\n\ndef _gen_file_datas(count: int = 1) -> list[FileItem]:\n    return [_gen_file_data(idx) for idx in range(count)]\n\n\nclass SequentialTestChecker(BaseRawFileChecker):\n    \"\"\"A checker that does not need to con"}, {"start_line": 0, "end_line": 1447, "belongs_to": {"file_name": "invalid_getnewargs_returned.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i/invalid/invalid_getnewargs", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check invalid value returned by __getnewargs__ \"\"\"\n\n# pylint: disable=too-few-public-methods,missing-docstring,import-error,unnecessary-lambda-assignment,use-dict-literal\nimport six\n\nfrom missing import Missing\n\n\nclass FirstGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return (1, \"2\", 3)\n\n\nclass SecondGoodGetNewArgs:\n    \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\"\n\n    def __getnewargs__(self):\n        return tuple()\n\n\nclass GetNewArgsMetaclass(type):\n    def __getnewargs__(cls):\n        return (1, 2, 3)\n\n\n@six.add_metaclass(GetNewArgsMetaclass)\nclass ThirdGoodGetNewArgs:\n    \"\"\"GetNewArgs through the metaclass.\"\"\"\n\n\nclass FirstBadGetNewArgs:\n    \"\"\" __getnewargs__ returns an integer \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return 1\n\n\nclass SecondBadGetNewArgs:\n    \"\"\" __getnewargs__ returns str \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return \"(1, 2, 3)\"\n\n\nclass ThirdBadGetNewArgs:\n    \"\"\" __getnewargs__ returns node which does not have 'value' in AST \"\"\"\n\n    def __getnewargs__(self):  # [invalid-getnewargs-returned]\n        return lambda: tuple(1, 2)\n\n\nclass AmbigousGetNewArgs:\n    \"\"\" Uninferable return value \"\"\"\n    __getnewargs__ = lambda self: Missing\n\n\nclass AnotherAmbiguousGetNewArgs:\n    \"\"\"Potential uninferable return value\"\"\"\n    def __getnewargs__(self):\n        return tuple(Missing)\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_check_parallel.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function\n        https://github.com/pylint-dev/pylint/pull/5584\n        \"\"\"\n        linter = PyLinter(reporter=Reporter())\n        linter.attribute = argparse.ArgumentParser()  # type: ignore[attr-defined]\n        with ProcessPoolExecutor(\n            max_workers=2, initializer=worker_initialize, initargs=(dill.dumps(linter),)\n        ) as executor:\n            executor.map(print, [1, 2])\n\n    def test_worker_check_single_file_uninitialised(self) -> None:\n        pylint.lint.parallel._worker_linter = None\n        with pytest.raises(  # Objects that do not match the linter interface will fail\n            RuntimeError, match=\"Worker linter not yet initialised\"\n        ):\n            worker_check_single_file(_gen_file_data())\n\n    def test_worker_check_single_file_no_checkers(self) -> None:\n        linter = PyLinter(reporter=Reporter())\n        worker_initialize(linter=dill.dumps(linter))\n\n        (\n            _,  # proc-id\n            name,\n            _,  # file_path\n            _,  # base_name\n            msgs,\n            stats,\n            msg_status,\n            _,  # mapreduce_data\n        ) = worker_check_single_file(_gen_file_data())\n        assert name == \"--test-file_data-name-0--\"\n        assert not msgs\n        no_errors_status = 0\n        assert no_errors_status == msg_status\n        assert {\n            \"--test-file_data-name-0--\": {\n                \"convention\": 0,\n                \"error\": 0,\n                \"fatal\": 0,\n                \"info\": 0,\n                \"refactor\": 0,\n                \"statement\": 18,\n                \"warning\": 0,\n            }\n        } == stats.by_module\n        assert not stats.by_msg\n        assert stats.convention == 0\n        assert stats.error == 0\n        assert stats.fatal == 0\n        assert stats.info == 0\n        assert stats.refactor == 0\n        assert stats.statement == 18\n        assert stats.warning == 0\n\n    def test_linter_with_unpickleable_p"}, {"start_line": 0, "end_line": 727, "belongs_to": {"file_name": "regression_5408.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression_02", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Regression test for issue 5408.\n\nRecursion error for self-referencing class attribute.\nSee: https://github.com/pylint-dev/pylint/issues/5408\n\"\"\"\n\n# pylint: disable=missing-docstring, too-few-public-methods, invalid-name, inherit-non-class\n# pylint: disable=no-self-argument\n\n\nclass MyInnerClass:\n    ...\n\n\nclass MySubClass:\n    inner_class = MyInnerClass\n\n\nclass MyClass:\n    sub_class = MySubClass()\n\n\ndef get_unpatched_class(cls):\n    return cls\n\n\ndef get_unpatched(item):\n    lookup = get_unpatched_class if isinstance(item, type) else lambda item: None\n    return lookup(item)\n\n\n_Child = get_unpatched(MyClass.sub_class.inner_class)\n\n\nclass Child(_Child):\n    def patch(cls):\n        MyClass.sub_class.inner_class = cls\n"}, {"start_line": 2000, "end_line": 3031, "belongs_to": {"file_name": "abstract_class_instantiated.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "thing \"\"\"\n    GoodClass()\n    SecondGoodClass()\n    ThirdGoodClass()\n    FourthGoodClass()\n    weakref.WeakKeyDictionary()\n    weakref.WeakValueDictionary()\n    NoMroAbstractMethods()\n\n    BadMroAbstractMethods() # [abstract-class-instantiated]\n    BadClass() # [abstract-class-instantiated]\n    SecondBadClass() # [abstract-class-instantiated]\n    ThirdBadClass() # [abstract-class-instantiated]\n\n\nif 1: # pylint: disable=using-constant-test\n    class FourthBadClass(metaclass=abc.ABCMeta):\n\n        def test(self):\n            pass\nelse:\n    class FourthBadClass(metaclass=abc.ABCMeta):\n\n        @abc.abstractmethod\n        def test(self):\n            pass\n\n\ndef main2():\n    FourthBadClass() # [abstract-class-instantiated]\n\n\nclass BadClassTwo(abc.ABC):\n    \"\"\"\n    Check that instantiating a class with `abc.ABCMeta` as ancestor fails if it\n    defines abstract methods.\n    \"\"\"\n    @abc.abstractmethod\n    def test(self):\n        pass\n\n\ndef main_two():\n    \"\"\" do nothing \"\"\"\n    BadClassTwo() # [abstract-class-instantiated]\n"}], "retrieved_count": 10, "cost_time": 0.34636354446411133}
{"question": "Where is the abstract method checking implementation that handles assignments connecting abstract methods to protocol methods located?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1203, "belongs_to": {"file_name": "protocol_classes_abstract.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/p", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test that classes inheriting directly from Protocol should not warn about abstract-method.\"\"\"\n\n# pylint: disable=too-few-public-methods,disallowed-name,invalid-name\n\nfrom abc import abstractmethod, ABCMeta\nfrom typing import Protocol, Literal\n\n\nclass FooProtocol(Protocol):\n    \"\"\"Foo Protocol\"\"\"\n\n    @abstractmethod\n    def foo(self) -> Literal[\"foo\"]:\n        \"\"\"foo method\"\"\"\n\n    def foo_no_abstract(self) -> Literal[\"foo\"]:\n        \"\"\"foo not abstract method\"\"\"\n\n\nclass BarProtocol(Protocol):\n    \"\"\"Bar Protocol\"\"\"\n    @abstractmethod\n    def bar(self) -> Literal[\"bar\"]:\n        \"\"\"bar method\"\"\"\n\n\nclass FooBarProtocol(FooProtocol, BarProtocol, Protocol):\n    \"\"\"FooBar Protocol\"\"\"\n\nclass BarParent(BarProtocol): # [abstract-method]\n    \"\"\"Doesn't subclass typing.Protocol directly\"\"\"\n\nclass IndirectProtocol(FooProtocol):  # [abstract-method]\n    \"\"\"Doesn't subclass typing.Protocol directly\"\"\"\n\nclass AbcProtocol(FooProtocol, metaclass=ABCMeta):\n    \"\"\"Doesn't subclass typing.Protocol but uses metaclass directly\"\"\"\n\nclass FooBar(FooBarProtocol):\n    \"\"\"FooBar object\"\"\"\n\n    def bar(self) -> Literal[\"bar\"]:\n        return \"bar\"\n\n    def foo(self) -> Literal[\"foo\"]:\n        return \"foo\"\n"}, {"start_line": 84000, "end_line": 86000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lid_classmethod_first_arg,\n                node,\n                \"bad-classmethod-argument\",\n                node.name,\n            )\n        # regular class with regular method without self as argument\n        elif first != \"self\":\n            self.add_message(\"no-self-argument\", node=node, args=node.name)\n\n    def _check_first_arg_config(\n        self,\n        first: str | None,\n        config: Sequence[str],\n        node: nodes.FunctionDef,\n        message: str,\n        method_name: str,\n    ) -> None:\n        if first not in config:\n            if len(config) == 1:\n                valid = repr(config[0])\n            else:\n                valid = \", \".join(repr(v) for v in config[:-1])\n                valid = f\"{valid} or {config[-1]!r}\"\n            self.add_message(message, args=(method_name, valid), node=node)\n\n    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        \"\"\"\n\n        def is_abstract(method: nodes.FunctionDef) -> bool:\n            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]\n\n        # check if this class abstract\n        if class_is_abstract(node):\n            return\n\n        methods = sorted(\n            unimplemented_abstract_methods(node, is_abstract).items(),\n            key=lambda item: item[0],\n        )\n        for name, method in methods:\n            owner = method.parent.frame()\n            if owner is node:\n                continue\n            # owner is not this class, it must be a parent class\n            # check that the ancestor's method is not abstract\n            if name in node.locals:\n                # it is redefined as an attribute or with a descriptor\n                continue\n\n            self.add_message(\n                \"abstract-method\",\n                node=node,\n                args=(name, owner.name, node.name),\n                confidence=INFERENCE,\n            )\n\n    def _"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "k_nonlocal_without_binding(self, node: nodes.Nonlocal, name: str) -> None:\n        current_scope = node.scope()\n        while current_scope.parent is not None:\n            if not isinstance(current_scope, (nodes.ClassDef, nodes.FunctionDef)):\n                self.add_message(\"nonlocal-without-binding\", args=(name,), node=node)\n                return\n\n            # Search for `name` in the parent scope if:\n            #  `current_scope` is the same scope in which the `nonlocal` name is declared\n            #  or `name` is not in `current_scope.locals`.\n            if current_scope is node.scope() or name not in current_scope.locals:\n                current_scope = current_scope.parent.scope()\n                continue\n\n            # Okay, found it.\n            return\n\n        if not isinstance(current_scope, nodes.FunctionDef):\n            self.add_message(\n                \"nonlocal-without-binding\", args=(name,), node=node, confidence=HIGH\n            )\n\n    @utils.only_required_for_messages(\"nonlocal-without-binding\")\n    def visit_nonlocal(self, node: nodes.Nonlocal) -> None:\n        for name in node.names:\n            self._check_nonlocal_without_binding(node, name)\n\n    @utils.only_required_for_messages(\"abstract-class-instantiated\")\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check instantiating abstract class with\n        abc.ABCMeta as metaclass.\n        \"\"\"\n        for inferred in infer_all(node.func):\n            self._check_inferred_class_is_abstract(inferred, node)\n\n    def _check_inferred_class_is_abstract(\n        self, inferred: InferenceResult, node: nodes.Call\n    ) -> None:\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n\n        klass = utils.node_frame_class(node)\n        if klass is inferred:\n            # Don't emit the warning if the class is instantiated\n            # in its own body or if the call is not an instance\n            # creation. If the class is instantiated into its own\n            # body, "}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mport = (\"typing\" in import_names) and getattr(\n            decorator, \"attrname\", None\n        ) == \"final\"\n\n        if is_from_import or is_import:\n            inferred = safe_infer(decorator)\n            if inferred is None or isinstance(inferred, util.UninferableBase):\n                decorators.append(decorator)\n    return decorators\n\n\n@lru_cache(maxsize=1024)\ndef unimplemented_abstract_methods(\n    node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef | None = None\n) -> dict[str, nodes.FunctionDef]:\n    \"\"\"Get the unimplemented abstract methods for the given *node*.\n\n    A method can be considered abstract if the callback *is_abstract_cb*\n    returns a ``True`` value. The check defaults to verifying that\n    a method is decorated with abstract methods.\n    It will return a dictionary of abstract method\n    names and their inferred objects.\n    \"\"\"\n    if is_abstract_cb is None:\n        is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)\n    visited: dict[str, nodes.FunctionDef] = {}\n    try:\n        mro = reversed(node.mro())\n    except astroid.ResolveError:\n        # Probably inconsistent hierarchy, don't try to figure this out here.\n        return {}\n    for ancestor in mro:\n        for obj in ancestor.values():\n            inferred = obj\n            if isinstance(obj, nodes.AssignName):\n                inferred = safe_infer(obj)\n                if not inferred:\n                    # Might be an abstract function,\n                    # but since we don't have enough information\n                    # in order to take this decision, we're taking\n                    # the *safe* decision instead.\n                    if obj.name in visited:\n                        del visited[obj.name]\n                    continue\n                if not isinstance(inferred, nodes.FunctionDef):\n                    if obj.name in visited:\n                        del visited[obj.name]\n            if isinstance(inferred, nodes.FunctionDef):\n                # It's critical"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sages(\"nonlocal-without-binding\")\n    def visit_nonlocal(self, node: nodes.Nonlocal) -> None:\n        for name in node.names:\n            self._check_nonlocal_without_binding(node, name)\n\n    @utils.only_required_for_messages(\"abstract-class-instantiated\")\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check instantiating abstract class with\n        abc.ABCMeta as metaclass.\n        \"\"\"\n        for inferred in infer_all(node.func):\n            self._check_inferred_class_is_abstract(inferred, node)\n\n    def _check_inferred_class_is_abstract(\n        self, inferred: InferenceResult, node: nodes.Call\n    ) -> None:\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n\n        klass = utils.node_frame_class(node)\n        if klass is inferred:\n            # Don't emit the warning if the class is instantiated\n            # in its own body or if the call is not an instance\n            # creation. If the class is instantiated into its own\n            # body, we're expecting that it knows what it is doing.\n            return\n\n        # __init__ was called\n        abstract_methods = _has_abstract_methods(inferred)\n\n        if not abstract_methods:\n            return\n\n        metaclass = inferred.metaclass()\n\n        if metaclass is None:\n            # Python 3.4 has `abc.ABC`, which won't be detected\n            # by ClassNode.metaclass()\n            for ancestor in inferred.ancestors():\n                if ancestor.qname() == \"abc.ABC\":\n                    self.add_message(\n                        \"abstract-class-instantiated\", args=(inferred.name,), node=node\n                    )\n                    break\n\n            return\n\n        if metaclass.qname() in ABC_METACLASSES:\n            self.add_message(\n                \"abstract-class-instantiated\", args=(inferred.name,), node=node\n            )\n\n    def _check_yield_outside_func(self, node: nodes.Yield) -> None:\n        if not isinstance(node.frame(), (nodes.FunctionDef, nodes.Lambda)):\n "}, {"start_line": 83000, "end_line": 85000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o-method-argument\", node=node, args=node.name)\n        # metaclass\n        elif metaclass:\n            # metaclass __new__ or classmethod\n            if node.type == \"classmethod\":\n                self._check_first_arg_config(\n                    first,\n                    self.linter.config.valid_metaclass_classmethod_first_arg,\n                    node,\n                    \"bad-mcs-classmethod-argument\",\n                    node.name,\n                )\n            # metaclass regular method\n            else:\n                self._check_first_arg_config(\n                    first,\n                    self.linter.config.valid_classmethod_first_arg,\n                    node,\n                    \"bad-mcs-method-argument\",\n                    node.name,\n                )\n        # regular class with class method\n        elif node.type == \"classmethod\" or node.name == \"__class_getitem__\":\n            self._check_first_arg_config(\n                first,\n                self.linter.config.valid_classmethod_first_arg,\n                node,\n                \"bad-classmethod-argument\",\n                node.name,\n            )\n        # regular class with regular method without self as argument\n        elif first != \"self\":\n            self.add_message(\"no-self-argument\", node=node, args=node.name)\n\n    def _check_first_arg_config(\n        self,\n        first: str | None,\n        config: Sequence[str],\n        node: nodes.FunctionDef,\n        message: str,\n        method_name: str,\n    ) -> None:\n        if first not in config:\n            if len(config) == 1:\n                valid = repr(config[0])\n            else:\n                valid = \", \".join(repr(v) for v in config[:-1])\n                valid = f\"{valid} or {config[-1]!r}\"\n            self.add_message(message, args=(method_name, valid), node=node)\n\n    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        "}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r)\n            if isinstance(inferred, nodes.Module) and inferred.qname() == \"typing\":\n                _, import_nodes = decorator.expr.lookup(decorator.expr.name)\n\n        # Get the `ImportFrom` node. The decorator is of the form: @name\n        elif isinstance(decorator, nodes.Name):\n            _, import_nodes = decorator.lookup(decorator.name)\n\n        # The `final` decorator is expected to be found in the\n        # import_nodes. Continue if we don't find any `Import` or `ImportFrom`\n        # nodes for this decorator.\n        if not import_nodes:\n            continue\n        import_node = import_nodes[0]\n\n        if not isinstance(import_node, (astroid.Import, astroid.ImportFrom)):\n            continue\n\n        import_names = dict(import_node.names)\n\n        # Check if the import is of the form: `from typing import final`\n        is_from_import = (\"final\" in import_names) and import_node.modname == \"typing\"\n\n        # Check if the import is of the form: `import typing`\n        is_import = (\"typing\" in import_names) and getattr(\n            decorator, \"attrname\", None\n        ) == \"final\"\n\n        if is_from_import or is_import:\n            inferred = safe_infer(decorator)\n            if inferred is None or isinstance(inferred, util.UninferableBase):\n                decorators.append(decorator)\n    return decorators\n\n\n@lru_cache(maxsize=1024)\ndef unimplemented_abstract_methods(\n    node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef | None = None\n) -> dict[str, nodes.FunctionDef]:\n    \"\"\"Get the unimplemented abstract methods for the given *node*.\n\n    A method can be considered abstract if the callback *is_abstract_cb*\n    returns a ``True`` value. The check defaults to verifying that\n    a method is decorated with abstract methods.\n    It will return a dictionary of abstract method\n    names and their inferred objects.\n    \"\"\"\n    if is_abstract_cb is None:\n        is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)\n    visited: dict[str, nodes.Fun"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "abstract_method.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test abstract-method warning.\"\"\"\n\n\n# pylint: disable=missing-docstring\n# pylint: disable=too-few-public-methods\nimport abc\n\n\nclass Abstract:\n    def aaaa(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\n    def bbbb(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\n\nclass AbstractB(Abstract):\n    \"\"\"Abstract class.\n\n    this class is checking that it does not output an error msg for\n    unimplemeted methods in abstract classes\n    \"\"\"\n    def cccc(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\nclass AbstractC(AbstractB, abc.ABC):\n    \"\"\"\n    Abstract class.\n\n    Should not trigger a warning for unimplemented\n    abstract methods, because of explicit abc.ABC inheritance.\n    \"\"\"\n\n\nclass AbstractD(AbstractB, metaclass=abc.ABCMeta):\n    \"\"\"\n    Abstract class.\n\n    Should not trigger a warning for unimplemented\n    abstract methods, because of explicit metaclass.\n    \"\"\"\n\n\nclass Concrete(Abstract): # [abstract-method]\n    \"\"\"Concrete class\"\"\"\n\n    def aaaa(self):\n        \"\"\"overridden form Abstract\"\"\"\n\n\nclass Structure(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __iter__(self):\n        pass\n    @abc.abstractmethod\n    def __len__(self):\n        pass\n    @abc.abstractmethod\n    def __contains__(self, _):\n        pass\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Container(Structure):\n    def __contains__(self, _):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Sizable(Structure):\n    def __len__(self):\n        return 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Hashable(Structure):\n    __hash__ = 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Iterator(Structure):\n    def keys(self):\n        return iter([1, 2, 3])\n\n    __iter__ = keys\n\n\nclass AbstractSizable"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "value, AITER_METHOD)\n\n\ndef _supports_getitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, GETITEM_METHOD)\n\n\ndef _supports_setitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, SETITEM_METHOD)\n\n\ndef _supports_delitem_protocol(value: nodes.NodeNG) -> bool:\n    return _supports_protocol_method(value, DELITEM_METHOD)\n\n\ndef _is_abstract_class_name(name: str) -> bool:\n    lname = name.lower()\n    is_mixin = lname.endswith(\"mixin\")\n    is_abstract = lname.startswith(\"abstract\")\n    is_base = lname.startswith(\"base\") or lname.endswith(\"base\")\n    return is_mixin or is_abstract or is_base\n\n\ndef is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False\n\n\ndef _supports_protocol(\n    value: nodes.NodeNG, protocol_callback: Callable[[nodes.NodeNG], bool]\n) -> bool:\n    if isinstance(value, nodes.ClassDef):\n        if not has_known_bases(value):\n            return True\n        # classobj can only be iterable if it has an iterable metaclass\n        meta = value.metaclass()\n        if meta is not None:\n            if protocol_callback(meta):\n                return True\n    if isinstance(value, astroid.BaseInstance):\n        if not has_known_bases(value):\n            return True\n        if value.has_dynamic_getattr():\n            return True\n        if protocol_callback(value):\n            return True\n\n    if isinstance(value, nodes.ComprehensionScope):\n        return True\n\n    if (\n        isinstance(value, astroid.bases.Proxy)\n        and isinstance(value._proxied, astroid.BaseInstance)\n        and has_known_bases(value._proxied)\n    ):\n        value = value._proxied\n        return protocol"}, {"start_line": 85000, "end_line": 87000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n\n        def is_abstract(method: nodes.FunctionDef) -> bool:\n            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]\n\n        # check if this class abstract\n        if class_is_abstract(node):\n            return\n\n        methods = sorted(\n            unimplemented_abstract_methods(node, is_abstract).items(),\n            key=lambda item: item[0],\n        )\n        for name, method in methods:\n            owner = method.parent.frame()\n            if owner is node:\n                continue\n            # owner is not this class, it must be a parent class\n            # check that the ancestor's method is not abstract\n            if name in node.locals:\n                # it is redefined as an attribute or with a descriptor\n                continue\n\n            self.add_message(\n                \"abstract-method\",\n                node=node,\n                args=(name, owner.name, node.name),\n                confidence=INFERENCE,\n            )\n\n    def _check_init(self, node: nodes.FunctionDef, klass_node: nodes.ClassDef) -> None:\n        \"\"\"Check that the __init__ method call super or ancestors'__init__\n        method (unless it is used for type hinting with `typing.overload`).\n        \"\"\"\n        if not self.linter.is_message_enabled(\n            \"super-init-not-called\"\n        ) and not self.linter.is_message_enabled(\"non-parent-init-called\"):\n            return\n        to_call = _ancestors_to_call(klass_node)\n        not_called_yet = dict(to_call)\n        parents_with_called_inits: set[bases.UnboundMethod] = set()\n        for stmt in node.nodes_of_class(nodes.Call):\n            expr = stmt.func\n            if not isinstance(expr, nodes.Attribute) or expr.attrname != \"__init__\":\n                continue\n            # skip the test if using super\n            if (\n                isinstance(expr.expr, nodes.Call)\n                and isinstance(expr.expr.func, nodes.Name)\n                and expr.expr.func.name == \"super\"\n            "}], "retrieved_count": 10, "cost_time": 0.3600468635559082}
{"question": "Where does the descriptor protocol implementation that provides __get__ and __set__ methods interact with the slot assignment validation mechanisms across the inheritance hierarchy in the slot assignment test file?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def __setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n "}, {"start_line": 4000, "end_line": 5061, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_setattr__(self, name, value):\n        if name == \"foobar\":\n            super().__setattr__(name, value)\n        else:\n            self.foobar[name] = value\n\n\nclass ClassWithParentDefiningSetattr(ClassDefiningSetattr):\n    __slots__ = []\n\n\ndef dont_emit_for_defined_setattr():\n    inst = ClassDefiningSetattr()\n    # This should not emit because we can't reason about what happens with\n    # classes defining __setattr__\n    inst.non_existent = \"non-existent\"\n\n    child = ClassWithParentDefiningSetattr()\n    child.non_existent = \"non-existent\"\n\nclass ColorCls:\n    __slots__ = ()\n    COLOR = \"red\"\n\n\nclass Child(ColorCls):\n    __slots__ = ()\n\n\nrepro = Child()\nChild.COLOR = \"blue\"\n\nclass MyDescriptor:\n    \"\"\"Basic descriptor.\"\"\"\n\n    def __get__(self, instance, owner):\n        return 42\n\n    def __set__(self, instance, value):\n        pass\n\n\n# Regression test from https://github.com/pylint-dev/pylint/issues/6001\nclass Base:\n    __slots__ = ()\n\n    attr2 = MyDescriptor()\n\n\nclass Repro(Base):\n    __slots__ = ()\n\n\nrepro = Repro()\nrepro.attr2 = \"anything\"\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descriptor = 'foo'\n    inst.non_data_descriptor = 'lala'\n\n\nclass ClassWithSlots:\n    __slots__ = ['foobar']\n\n\nclass ClassReassigningDunderClass:\n    __slots__ = ['foobar']\n\n    def release(self):\n        self.__class__ = ClassWithSlots\n\n\nclass ClassReassingingInvalidLayoutClass:\n    __slots__ = []\n\n    def release(self):\n        self.__class__ = ClassWithSlots  # [assigning-non-slot]\n        self.test = 'test'  # [assigning-non-slot]\n\n\n# pylint: disable=attribute-defined-outside-init\nclass ClassHavingUnknownAncestors(Unknown):\n    __slots__ = ['yo']\n\n    def test(self):\n        self.not_yo = 42\n\n\n# pylint: disable=wrong-import-order, wrong-import-position\nfrom typing import (\n    Generic,\n    TypeVar,\n)\n\nTypeT = TypeVar('TypeT')\n\n\nclass Cls(Generic[TypeT]):\n    \"\"\" Simple class with slots \"\"\"\n    __slots__ = ['value']\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass ClassDefiningSetattr:\n    __slots__ = [\"foobar\"]\n\n    def __init__(self):\n        self.foobar = {}\n\n    def _"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Empty doesn't\n    specify __slots__.\n    \"\"\"\n    __slots__ = ['a']\n\n    def __init__(self):\n        self.missing = 42\n\nclass Good2:\n    \"\"\" Using __dict__ in slots will be safe. \"\"\"\n\n    __slots__ = ['__dict__', 'comp']\n\n    def __init__(self):\n        self.comp = 4\n        self.missing = 5\n\nclass PropertyGood:\n    \"\"\" Using properties is safe. \"\"\"\n\n    __slots__ = ['tmp', '_value']\n\n    @property\n    def test(self):\n        return self._value\n\n    @test.setter\n    def test(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    def __init__(self):\n        self.test = 42\n\nclass PropertyGood2:\n    \"\"\" Using properties in the body of the class is safe. \"\"\"\n    __slots__ = ['_value']\n\n    def _getter(self):\n        return self._value\n\n    def _setter(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    test = property(_getter, _setter)\n\n    def __init__(self):\n        self.test = 24\n\nclass UnicodeSlots:\n    \"\"\"Using unicode objects in __slots__ is okay.\n\n    On Python 3.3 onward, u'' is equivalent to '',\n    so this test should be safe for both versions.\n    \"\"\"\n    __slots__ = (u'first', u'second')\n\n    def __init__(self):\n        self.first = 42\n        self.second = 24\n\n\nclass DataDescriptor:\n    def __init__(self, name, default=''):\n        self.__name = name\n        self.__default = default\n\n    def __get__(self, inst, cls):\n        return getattr(inst, self.__name, self.__default)\n\n    def __set__(self, inst, value):\n        setattr(inst, self.__name, value)\n\n\nclass NonDataDescriptor:\n    def __get__(self, inst, cls):\n        return 42\n\n\nclass SlotsWithDescriptor:\n    __slots__ = ['_err']\n    data_descriptor = DataDescriptor('_err')\n    non_data_descriptor = NonDataDescriptor()\n    missing_descriptor = Unknown()\n\n\ndef dont_emit_for_descriptors():\n    inst = SlotsWithDescriptor()\n    # This should not emit, because attr is\n    # a data descriptor\n    inst.data_descri"}, {"start_line": 0, "end_line": 217, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/a/assigning-non-slot", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Student:\n    __slots__ = (\"name\",)\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n\n    def setup(self):\n        pass\n"}, {"start_line": 69000, "end_line": 71000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " cache[klass.slots]\n\n        slots = klass.slots()\n        if slots is None:\n            return\n        # If any ancestor doesn't use slots, the slots\n        # defined for this class are superfluous.\n        if any(\n            \"__slots__\" not in ancestor.locals\n            and ancestor.name not in (\"Generic\", \"object\")\n            for ancestor in klass.ancestors()\n        ):\n            return\n\n        if not any(slot.value == node.attrname for slot in slots):\n            # If we have a '__dict__' in slots, then\n            # assigning any name is valid.\n            if not any(slot.value == \"__dict__\" for slot in slots):\n                if _is_attribute_property(node.attrname, klass):\n                    # Properties circumvent the slots mechanism,\n                    # so we should not emit a warning for them.\n                    return\n                if node.attrname != \"__class__\" and utils.is_class_attr(\n                    node.attrname, klass\n                ):\n                    return\n                if node.attrname in klass.locals:\n                    for local_name in klass.locals.get(node.attrname):\n                        statement = local_name.statement()\n                        if (\n                            isinstance(statement, nodes.AnnAssign)\n                            and not statement.value\n                        ):\n                            return\n                    if _has_data_descriptor(klass, node.attrname):\n                        # Descriptors circumvent the slots mechanism as well.\n                        return\n                if node.attrname == \"__class__\" and _has_same_layout_slots(\n                    slots, node.parent.value\n                ):\n                    return\n                self.add_message(\n                    \"assigning-non-slot\",\n                    args=(node.attrname,),\n                    node=node,\n                    confidence=INFERENCE,\n                )\n\n    @only_required_for_messages(\n        \"pr"}, {"start_line": 2000, "end_line": 3887, "belongs_to": {"file_name": "slots_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ue.__name__)\n\n\nclass Metaclass(type):\n\n    def __iter__(cls):\n        for value in range(10):\n            yield str(value)\n\n\nclass IterableClass(metaclass=Metaclass):\n    pass\n\nclass PotentiallyThirdGood:\n    __slots__ = IterableClass\n\nclass PotentiallyFourthGood:\n    __slots__ = Good.__slots__\n\n\nclass ValueInSlotConflict:\n    __slots__ = ('first', 'second', 'third', 'fourth') # [class-variable-slots-conflict, class-variable-slots-conflict, class-variable-slots-conflict]\n    first = None\n\n    @property\n    def third(self):\n        return 42\n\n    def fourth(self):\n        return self.third\n\n\nclass Parent:\n    first = 42\n\n\nclass ChildNotAffectedByValueInSlot(Parent):\n    __slots__ = ('first', )\n\n\nclass ClassTypeHintNotInSlotsWithoutDict:\n    __slots__ = (\"a\", \"b\")\n\n    a: int\n    b: str\n    c: bool # [declare-non-slot]\n\n\nclass ClassTypeHintNotInSlotsWithDict:\n    __slots__ = (\"a\", \"b\", \"__dict__\")\n\n    a: int\n    b: str\n    c: bool\n\n\nclass BaseNoSlots:\n    pass\n\n\nclass DerivedWithSlots(BaseNoSlots):\n    __slots__ = (\"age\",)\n\n    price: int\n\n\nclass BaseWithSlots:\n    __slots__ = (\"a\", \"b\",)\n\n\nclass DerivedWithMoreSlots(BaseWithSlots):\n    __slots__ = (\"c\",)\n\n    # Is in base __slots__\n    a: int\n\n    # Not in any base __slots__\n    d: int # [declare-non-slot]\n    e: str= \"AnnAssign.value is not None\"\n\n\nclass BaseWithSlotsDict:\n    __slots__ = (\"__dict__\", )\n\nclass DerivedTypeHintNotInSlots(BaseWithSlotsDict):\n    __slots__ = (\"other\", )\n\n    a: int\n    def __init__(self) -> None:\n        super().__init__()\n        self.a = 42\n\n\nclass ClassWithEmptySlotsAndAnnotation:\n    __slots__ = ()\n\n    a: int\n\n\n# https://github.com/pylint-dev/pylint/issues/9814\nclass SlotsManipulationTest:\n    __slots__ = [\"a\", \"b\", \"c\"]\n\n\nclass TestChild(SlotsManipulationTest):\n    __slots__ += [\"d\", \"e\", \"f\"]  # pylint: disable=undefined-variable\n\n\nT = TestChild()\n\nprint(T.__slots__)\n"}, {"start_line": 0, "end_line": 123, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/r/redefined-slots-in-subclass", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = (\"a\", \"d\")  # [redefined-slots-in-subclass]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "assigning_non_slot.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" Checks assigning attributes not found in class slots\nwill trigger assigning-non-slot warning.\n\"\"\"\n# pylint: disable=too-few-public-methods, missing-docstring, import-error, redundant-u-string-prefix, unnecessary-dunder-call\n# pylint: disable=attribute-defined-outside-init\n\nfrom collections import deque\n\nfrom missing import Unknown\n\nclass Empty:\n    \"\"\" empty \"\"\"\n\nclass Bad:\n    \"\"\" missing not in slots. \"\"\"\n\n    __slots__ = ['member']\n\n    def __init__(self):\n        self.missing = 42 # [assigning-non-slot]\n\nclass Bad2:\n    \"\"\" missing not in slots \"\"\"\n    __slots__ = [deque.__name__, 'member']\n\n    def __init__(self):\n        self.deque = 42\n        self.missing = 42 # [assigning-non-slot]\n\nclass Bad3(Bad):\n    \"\"\" missing not found in slots \"\"\"\n\n    __slots__ = ['component']\n\n    def __init__(self):\n        self.component = 42\n        self.member = 24\n        self.missing = 42 # [assigning-non-slot]\n        super().__init__()\n\nclass Good(Empty):\n    \"\"\" missing not in slots, but Empty doesn't\n    specify __slots__.\n    \"\"\"\n    __slots__ = ['a']\n\n    def __init__(self):\n        self.missing = 42\n\nclass Good2:\n    \"\"\" Using __dict__ in slots will be safe. \"\"\"\n\n    __slots__ = ['__dict__', 'comp']\n\n    def __init__(self):\n        self.comp = 4\n        self.missing = 5\n\nclass PropertyGood:\n    \"\"\" Using properties is safe. \"\"\"\n\n    __slots__ = ['tmp', '_value']\n\n    @property\n    def test(self):\n        return self._value\n\n    @test.setter\n    def test(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    def __init__(self):\n        self.test = 42\n\nclass PropertyGood2:\n    \"\"\" Using properties in the body of the class is safe. \"\"\"\n    __slots__ = ['_value']\n\n    def _getter(self):\n        return self._value\n\n    def _setter(self, value):\n        # pylint: disable=attribute-defined-outside-init\n        self._value = value\n\n    test = property(_getter, _setter)\n\n    def __init__(self):\n        self.test = 24\n\nclass U"}, {"start_line": 0, "end_line": 481, "belongs_to": {"file_name": "assigning_non_slot_4509.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/assigning", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=invalid-name,missing-docstring,too-few-public-methods\n\n# Slots with base that inherits from 'Generic'\n# https://github.com/pylint-dev/pylint/issues/4509\n# https://github.com/pylint-dev/astroid/issues/999\n\nfrom typing import Generic, TypeVar\nT = TypeVar(\"T\")\n\nclass Base(Generic[T]):\n    __slots__ = ()\n\nclass Foo(Base[T]):\n    __slots__ = ['_value']\n\n    def __init__(self, value: T):\n        self._value = value\n        self._bar = value  # [assigning-non-slot]\n"}], "retrieved_count": 10, "cost_time": 0.3510470390319824}
{"question": "How does explicitly calling a parent constructor via a dotted module path handle method resolution order in multi-level inheritance hierarchies?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 241, "belongs_to": {"file_name": "dotted_ancestor.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"bla\"\"\"\n\n\nfrom ..n.non import non_init_parent_called\n\n\nclass Aaaa(non_init_parent_called.AAAA):  # [too-few-public-methods]\n    \"\"\"test dotted name in ancestors\"\"\"\n    def __init__(self):\n        non_init_parent_called.AAAA.__init__(self)\n"}, {"start_line": 0, "end_line": 1448, "belongs_to": {"file_name": "non_init_parent_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/n/non", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=protected-access,import-self,too-few-public-methods,line-too-long\n# pylint: disable=wrong-import-order, unnecessary-dunder-call\n\"\"\"test for call to __init__ from a non ancestor class\n\"\"\"\nfrom . import non_init_parent_called\nimport nonexistent  # [import-error]\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print('init', self)\n        BBBBMixin.__init__(self)  # [non-parent-init-called]\n\nclass BBBBMixin:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print('init', self)\n\nclass CCC(BBBBMixin, non_init_parent_called.AAAA, non_init_parent_called.BBBB, nonexistent.AClass):  # [no-member]\n    \"\"\"mix different things, some inferable some not\"\"\"\n    def __init__(self):\n        BBBBMixin.__init__(self)\n        non_init_parent_called.AAAA.__init__(self)\n        non_init_parent_called.BBBB.__init__(self)  # [no-member]\n        nonexistent.AClass.__init__(self)\n\nclass DDDD(AAAA):\n    \"\"\"call superclass constructor in disjunct branches\"\"\"\n    def __init__(self, value):\n        if value:\n            AAAA.__init__(self)\n        else:\n            AAAA.__init__(self)\n\nclass Super(dict):\n    \"\"\" test late binding super() call \"\"\"\n    def __init__(self):\n        base = super()\n        base.__init__()\n\nclass Super2(dict):\n    \"\"\" Using the same idiom as Super, but without calling\n    the __init__ method.\n    \"\"\"\n    def __init__(self):\n        base = super()\n        base.__woohoo__()  # [no-member]\n"}, {"start_line": 3000, "end_line": 4523, "belongs_to": {"file_name": "super_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "or pylint-dev/pylint/issues/773\nimport subprocess\n\n# The problem was related to astroid not filtering statements\n# at scope level properly, basically not doing strong updates.\ntry:\n    TimeoutExpired = subprocess.TimeoutExpired\nexcept AttributeError:\n    class TimeoutExpired(subprocess.CalledProcessError):\n        def __init__(self):\n            returncode = -1\n            self.timeout = -1\n            super(TimeoutExpired, self).__init__(\"\", returncode)\n\n\nclass SuperWithType:\n    \"\"\"type(self) may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(type(self), self).__init__() # [bad-super-call]\n\nclass SuperWithSelfClass:\n    \"\"\"self.__class__ may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(self.__class__, self).__init__() # [bad-super-call]\n\n\n# Reported in https://github.com/pylint-dev/pylint/issues/2903\nclass Parent:\n    def method(self):\n        print()\n\n\nclass Child(Parent):\n    def method(self):\n        print(\"Child\")\n        super().method()\n\nclass Niece(Parent):\n    def method(self):\n        print(\"Niece\")\n        super().method()\n\nclass GrandChild(Child):\n    def method(self):\n        print(\"Grandchild\")\n        super(GrandChild, self).method()\n        super(Child, self).method()\n        super(Niece, self).method()  # [bad-super-call]\n\n\n# Reported in https://github.com/pylint-dev/pylint/issues/4922\nclass AlabamaCousin(Child, Niece):\n    def method(self):\n        print(\"AlabamaCousin\")\n        super(Child, self).method()\n"}, {"start_line": 0, "end_line": 187, "belongs_to": {"file_name": "bad.py", "upper_path": "/data2/raymone/swebench-repos/pylint/doc/data/messages/b/bad-super-call", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Animal:\n    pass\n\n\nclass Tree:\n    pass\n\n\nclass Cat(Animal):\n    def __init__(self):\n        super(Tree, self).__init__()  # [bad-super-call]\n        super(Animal, self).__init__()\n"}, {"start_line": 0, "end_line": 872, "belongs_to": {"file_name": "super_with_arguments.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "class Foo:\n    pass\n\n\nclass Bar(Foo):\n    def __init__(self):\n        super(Bar, self).__init__()  # [super-with-arguments]\n\n\nclass Baz(Foo):\n    def __init__(self):\n        super().__init__()\n\n\nclass Qux(Foo):\n    def __init__(self):\n        super(Bar, self).__init__()\n\n\nclass NotSuperCall(Foo):\n    def __init__(self):\n        super.test(Bar, self).__init__()\n\n\nclass InvalidSuperCall(Foo):\n    def __init__(self):\n        super(InvalidSuperCall.__class__, self).__init__()\n\n\ndef method_accepting_cls(cls, self):\n    # Using plain `super()` is not valid here, since there's no `__class__` cell found\n    # (Exact exception would be 'RuntimeError: super(): __class__ cell not found')\n    # Instead, we expect to *not* see a warning about `super-with-arguments`.\n    # Explicitly passing `cls`, and `self` to `super()` is what's required.\n    super(cls, self).__init__()\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "super_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing, self).__init__()  # [bad-super-call]\n\nclass Getattr:\n    \"\"\" crash \"\"\"\n    name = NewAaaa\n\nclass CrashSuper:\n    \"\"\" test a crash with this checker \"\"\"\n    def __init__(self):\n        super(Getattr.name, self).__init__()  # [bad-super-call]\n\nclass Empty:\n    \"\"\"Just an empty class.\"\"\"\n\nclass SuperDifferentScope:\n    \"\"\"Don'emit bad-super-call when the super call is in another scope.\n    For reference, see https://bitbucket.org/logilab/pylint/issue/403.\n    \"\"\"\n    @staticmethod\n    def test():\n        \"\"\"Test that a bad-super-call is not emitted for this case.\"\"\"\n        class FalsePositive(Empty):\n            \"\"\"The following super is in another scope than `test`.\"\"\"\n            def __init__(self, arg):\n                super(FalsePositive, self).__init__(arg)\n        super(object, 1).__init__()\n\n\nclass UnknownBases(Missing):\n    \"\"\"Don't emit if we don't know all the bases.\"\"\"\n    def __init__(self):\n        super(UnknownBases, self).__init__()\n        super(UnknownBases, self).test()\n        super(Missing, self).test() # [bad-super-call]\n\n\n# Test that we are detecting proper super errors.\n\nclass BaseClass:\n\n    not_a_method = 42\n\n    def function(self, param):\n        return param + self.not_a_method\n\n    def __getattr__(self, attr):\n        return attr\n\n\nclass InvalidSuperChecks(BaseClass):\n\n    def __init__(self):\n        super(InvalidSuperChecks, self).not_a_method() # [not-callable]\n        super(InvalidSuperChecks, self).attribute_error() # [no-member]\n        super(InvalidSuperChecks, self).function(42)\n        super(InvalidSuperChecks, self).function() # [no-value-for-parameter]\n        super(InvalidSuperChecks, self).function(42, 24, 24) # [too-many-function-args]\n        # +1: [unexpected-keyword-arg,no-value-for-parameter]\n        super(InvalidSuperChecks, self).function(lala=42)\n        # Even though BaseClass has a __getattr__, that won't\n        # be called.\n        super(InvalidSuperChecks, self).attribute_error() # [no-member]\n\n\n\n# Regression f"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "super_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods,import-error, missing-docstring\n# pylint: disable=useless-super-delegation,wrong-import-position,invalid-name, wrong-import-order\n# pylint: disable=super-with-arguments\nfrom unknown import Missing\n\nclass Aaaa:\n    \"\"\"old style\"\"\"\n    def hop(self):\n        \"\"\"hop\"\"\"\n        super(Aaaa, self).hop() # >=3.0:[no-member]\n\n    def __init__(self):\n        super(Aaaa, self).__init__()\n\nclass NewAaaa:\n    \"\"\"old style\"\"\"\n    def hop(self):\n        \"\"\"hop\"\"\"\n        super(NewAaaa, self).hop() # [no-member]\n\n    def __init__(self):\n        super(Aaaa, self).__init__()  # [bad-super-call]\n\nclass Py3kAaaa(NewAaaa):\n    \"\"\"new style\"\"\"\n    def __init__(self):\n        super().__init__()  # <3.0:[missing-super-argument]\n\nclass Py3kWrongSuper(Py3kAaaa):\n    \"\"\"new style\"\"\"\n    def __init__(self):\n        super(NewAaaa, self).__init__()\n\nclass WrongNameRegression(Py3kAaaa):\n    \"\"\" test a regression with the message \"\"\"\n    def __init__(self):\n        super(Missing, self).__init__()  # [bad-super-call]\n\nclass Getattr:\n    \"\"\" crash \"\"\"\n    name = NewAaaa\n\nclass CrashSuper:\n    \"\"\" test a crash with this checker \"\"\"\n    def __init__(self):\n        super(Getattr.name, self).__init__()  # [bad-super-call]\n\nclass Empty:\n    \"\"\"Just an empty class.\"\"\"\n\nclass SuperDifferentScope:\n    \"\"\"Don'emit bad-super-call when the super call is in another scope.\n    For reference, see https://bitbucket.org/logilab/pylint/issue/403.\n    \"\"\"\n    @staticmethod\n    def test():\n        \"\"\"Test that a bad-super-call is not emitted for this case.\"\"\"\n        class FalsePositive(Empty):\n            \"\"\"The following super is in another scope than `test`.\"\"\"\n            def __init__(self, arg):\n                super(FalsePositive, self).__init__(arg)\n        super(object, 1).__init__()\n\n\nclass UnknownBases(Missing):\n    \"\"\"Don't emit if we don't know all the bases.\"\"\"\n    def __init__(self):\n        super(UnknownBases, self).__init__()\n        super(UnknownBases, self).t"}, {"start_line": 0, "end_line": 1698, "belongs_to": {"file_name": "init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods, import-error, missing-docstring, wrong-import-position\n# pylint: disable=useless-super-delegation, unnecessary-pass\n\n\nfrom typing import overload\n\nfrom missing import Missing\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass BBBB:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass CCCC:\n    \"\"\"ancestor 3\"\"\"\n\n\nclass ZZZZ(AAAA, BBBB, CCCC):\n    \"\"\"derived class\"\"\"\n\n    def __init__(self):  # [super-init-not-called]\n        AAAA.__init__(self)\n\n\nclass NewStyleA:\n    \"\"\"new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        print(\"init\", self)\n\n\nclass NewStyleB(NewStyleA):\n    \"\"\"derived new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n\nclass NewStyleC:\n    \"\"\"__init__ defined by assignment.\"\"\"\n\n    def xx_init(self):\n        \"\"\"Initializer.\"\"\"\n        pass\n\n    __init__ = xx_init\n\n\nclass AssignedInit(NewStyleC):\n    \"\"\"No init called, but abstract so that is fine.\"\"\"\n\n    def __init__(self):\n        self.arg = 0\n\n\nclass UnknownBases(Missing):\n    \"\"\"No false positives if the bases aren't known.\"\"\"\n\n\nclass Parent:\n    def __init__(self, num: int):\n        self.number = num\n\n\nclass Child(Parent):\n    @overload\n    def __init__(self, num: int):\n        ...\n\n    @overload\n    def __init__(self, num: float):\n        ...\n\n    def __init__(self, num):\n        super().__init__(round(num))\n\n\n# https://github.com/pylint-dev/pylint/issues/7742\n# Crash when parent class has a class attribute named `__init__`\nclass NoInitMethod:\n    __init__ = 42\n\n\nclass ChildNoInitMethod(NoInitMethod):\n    def __init__(self):\n        ...\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "super_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est()\n        super(Missing, self).test() # [bad-super-call]\n\n\n# Test that we are detecting proper super errors.\n\nclass BaseClass:\n\n    not_a_method = 42\n\n    def function(self, param):\n        return param + self.not_a_method\n\n    def __getattr__(self, attr):\n        return attr\n\n\nclass InvalidSuperChecks(BaseClass):\n\n    def __init__(self):\n        super(InvalidSuperChecks, self).not_a_method() # [not-callable]\n        super(InvalidSuperChecks, self).attribute_error() # [no-member]\n        super(InvalidSuperChecks, self).function(42)\n        super(InvalidSuperChecks, self).function() # [no-value-for-parameter]\n        super(InvalidSuperChecks, self).function(42, 24, 24) # [too-many-function-args]\n        # +1: [unexpected-keyword-arg,no-value-for-parameter]\n        super(InvalidSuperChecks, self).function(lala=42)\n        # Even though BaseClass has a __getattr__, that won't\n        # be called.\n        super(InvalidSuperChecks, self).attribute_error() # [no-member]\n\n\n\n# Regression for pylint-dev/pylint/issues/773\nimport subprocess\n\n# The problem was related to astroid not filtering statements\n# at scope level properly, basically not doing strong updates.\ntry:\n    TimeoutExpired = subprocess.TimeoutExpired\nexcept AttributeError:\n    class TimeoutExpired(subprocess.CalledProcessError):\n        def __init__(self):\n            returncode = -1\n            self.timeout = -1\n            super(TimeoutExpired, self).__init__(\"\", returncode)\n\n\nclass SuperWithType:\n    \"\"\"type(self) may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(type(self), self).__init__() # [bad-super-call]\n\nclass SuperWithSelfClass:\n    \"\"\"self.__class__ may lead to recursion loop in derived classes\"\"\"\n    def __init__(self):\n        super(self.__class__, self).__init__() # [bad-super-call]\n\n\n# Reported in https://github.com/pylint-dev/pylint/issues/2903\nclass Parent:\n    def method(self):\n        print()\n\n\nclass Child(Parent):\n    def method(self):\n        print(\""}, {"start_line": 1000, "end_line": 2510, "belongs_to": {"file_name": "super_init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "randParentWithInit it doesn't need to be called.\"\"\"\n\n    def __init__(self):\n        GrandParentWithInit.__init__(self)\n\n\nclass ChildTwo(ParentWithoutInit):\n    def __init__(self):\n        ParentWithoutInit.__init__(self)\n\n\nclass ChildThree(ParentWithoutInit):\n    def __init__(self):  # [super-init-not-called]\n        ...\n\n\n# Regression test as reported in\n# https://github.com/pylint-dev/pylint/issues/6027\nclass MyUnion(ctypes.Union):\n    def __init__(self):\n        pass\n\n\n# Should not be called on abstract __init__ methods\n# https://github.com/pylint-dev/pylint/issues/3975\nclass Base:\n    def __init__(self, param: int, param_two: str) -> None:\n        raise NotImplementedError()\n\n\nclass Derived(Base):\n    def __init__(self, param: int, param_two: str) -> None:\n        self.param = param + 1\n        self.param_two = param_two[::-1]\n\n\nclass AbstractBase(abc.ABC):\n    def __init__(self, param: int) -> None:\n        self.param = param + 1\n\n    def abstract_method(self) -> str:\n        \"\"\"This needs to be implemented.\"\"\"\n        raise NotImplementedError()\n\n\nclass DerivedFromAbstract(AbstractBase):\n    def __init__(self, param: int) -> None:  # [super-init-not-called]\n        print(\"Called\")\n\n    def abstract_method(self) -> str:\n        return \"Implemented\"\n\n\nclass DerivedFrom(UnknownParent):  # [undefined-variable]\n    def __init__(self) -> None:\n        print(\"Called\")\n\n\nclass DerivedFromUnknownGrandparent(DerivedFrom):\n    def __init__(self) -> None:\n        DerivedFrom.__init__(self)\n"}], "retrieved_count": 10, "cost_time": 0.34770870208740234}
{"question": "What are the semantic implications of a concrete class implementing a typing protocol having an empty __init__ method body containing only ellipsis for protocol conformance while still requiring calls in the inheritance chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 518, "belongs_to": {"file_name": "super_init_not_called_extensions_py310.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for super-init-not-called.\"\"\"\n# pylint: disable=too-few-public-methods\n\nfrom typing_extensions import Protocol as ExtensionProtocol\n\n\nclass TestProto(ExtensionProtocol):\n    \"\"\"A protocol without __init__ using Protocol from typing_extensions.\"\"\"\n\n\nclass TestParent(TestProto):\n    \"\"\"An implementation.\"\"\"\n\n    def __init__(self):\n        ...\n\n\nclass TestChild(TestParent):\n    \"\"\"An implementation which should call the init of TestParent.\"\"\"\n\n    def __init__(self):  # [super-init-not-called]\n        ...\n"}, {"start_line": 0, "end_line": 411, "belongs_to": {"file_name": "super_init_not_called_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for super-init-not-called with Protocol.\"\"\"\n# pylint: disable=too-few-public-methods\n\nfrom abc import abstractmethod\nfrom typing import Protocol\n\n\nclass MyProtocol(Protocol):\n    \"\"\"A protocol.\"\"\"\n\n    @abstractmethod\n    def __init__(self) -> None:\n        raise NotImplementedError\n\n\nclass ProtocolImplimentation(MyProtocol):\n    \"\"\"An implementation.\"\"\"\n\n    def __init__(self) -> None:\n        ...\n"}, {"start_line": 0, "end_line": 922, "belongs_to": {"file_name": "class_protocol_ellipsis.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\"Tests for return type checkers for protocol methods with ellipsis function body\"\"\"\n# pylint: disable=missing-class-docstring\nfrom typing import Any, Iterator\n\n\nclass MyClass:\n    \"\"\"The \"invalid-*-returned\" messages shouldn't be emitted for stub functions\n    Original issue: https://github.com/pylint-dev/pylint/issues/4736\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __hash__(self) -> int:\n        ...\n\n    def __index__(self) -> int:\n        ...\n\n    def __iter__(self) -> Iterator[Any]:\n        ...\n\n    def __bool__(self) -> bool:\n        ...\n\n    def __repr__(self) -> object:\n        ...\n\n    def __str__(self) -> str:\n        ...\n\n    def __bytes__(self) -> bytes:\n        ...\n\n    def __length_hint__(self) -> int:\n        ...\n\n    def __format__(self, format_spec: str) -> str:\n        ...\n\n    def __getnewargs__(self) -> tuple:\n        ...\n\n    def __getnewargs_ex__(self) -> tuple:\n        ...\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "super_init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for super-init-not-called.\"\"\"\n# pylint: disable=too-few-public-methods, missing-class-docstring\n\nimport abc\nimport ctypes\n\n\nclass Foo(ctypes.BigEndianStructure):\n    \"\"\"This class should not emit a super-init-not-called warning.\n\n    It previously did, because ``next(node.infer())`` was used in that checker's logic\n    and the first inferred node was an Uninferable object, leading to this false positive.\n    \"\"\"\n\n    def __init__(self):\n        ctypes.BigEndianStructure.__init__(self)\n\n\nclass UninferableChild(UninferableParent):  # [undefined-variable]\n    \"\"\"An implementation that test if we don't crash on uninferable parents.\"\"\"\n\n    def __init__(self):\n        ...\n\n\n# Tests for not calling the init of a parent that does not define one\n# but inherits it.\nclass GrandParentWithInit:\n    def __init__(self):\n        print(self)\n\n\nclass ParentWithoutInit(GrandParentWithInit):\n    pass\n\n\nclass ChildOne(ParentWithoutInit, GrandParentWithInit):\n    \"\"\"Since ParentWithoutInit calls GrandParentWithInit it doesn't need to be called.\"\"\"\n\n    def __init__(self):\n        GrandParentWithInit.__init__(self)\n\n\nclass ChildTwo(ParentWithoutInit):\n    def __init__(self):\n        ParentWithoutInit.__init__(self)\n\n\nclass ChildThree(ParentWithoutInit):\n    def __init__(self):  # [super-init-not-called]\n        ...\n\n\n# Regression test as reported in\n# https://github.com/pylint-dev/pylint/issues/6027\nclass MyUnion(ctypes.Union):\n    def __init__(self):\n        pass\n\n\n# Should not be called on abstract __init__ methods\n# https://github.com/pylint-dev/pylint/issues/3975\nclass Base:\n    def __init__(self, param: int, param_two: str) -> None:\n        raise NotImplementedError()\n\n\nclass Derived(Base):\n    def __init__(self, param: int, param_two: str) -> None:\n        self.param = param + 1\n        self.param_two = param_two[::-1]\n\n\nclass AbstractBase(abc.ABC):\n    def __init__(self, param: int) -> None:\n        self.param = param + 1\n\n    def abstract_method(self) -> str:\n        \"\"\""}, {"start_line": 0, "end_line": 440, "belongs_to": {"file_name": "useless_parent_delegation_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/useless", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,too-few-public-methods\nfrom typing import Any\n\n\nclass Egg:\n    def __init__(self, first: Any, /, second: Any) -> None:\n        pass\n\n\nclass Spam(Egg):\n    def __init__(self, first: float, /, second: float) -> None:\n        super().__init__(first, second)\n\n\nclass Ham(Egg):\n    def __init__(self, first: Any, /, second: Any) -> None:  # [useless-parent-delegation]\n        super().__init__(first, second)\n"}, {"start_line": 1000, "end_line": 2510, "belongs_to": {"file_name": "super_init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/s/super", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "randParentWithInit it doesn't need to be called.\"\"\"\n\n    def __init__(self):\n        GrandParentWithInit.__init__(self)\n\n\nclass ChildTwo(ParentWithoutInit):\n    def __init__(self):\n        ParentWithoutInit.__init__(self)\n\n\nclass ChildThree(ParentWithoutInit):\n    def __init__(self):  # [super-init-not-called]\n        ...\n\n\n# Regression test as reported in\n# https://github.com/pylint-dev/pylint/issues/6027\nclass MyUnion(ctypes.Union):\n    def __init__(self):\n        pass\n\n\n# Should not be called on abstract __init__ methods\n# https://github.com/pylint-dev/pylint/issues/3975\nclass Base:\n    def __init__(self, param: int, param_two: str) -> None:\n        raise NotImplementedError()\n\n\nclass Derived(Base):\n    def __init__(self, param: int, param_two: str) -> None:\n        self.param = param + 1\n        self.param_two = param_two[::-1]\n\n\nclass AbstractBase(abc.ABC):\n    def __init__(self, param: int) -> None:\n        self.param = param + 1\n\n    def abstract_method(self) -> str:\n        \"\"\"This needs to be implemented.\"\"\"\n        raise NotImplementedError()\n\n\nclass DerivedFromAbstract(AbstractBase):\n    def __init__(self, param: int) -> None:  # [super-init-not-called]\n        print(\"Called\")\n\n    def abstract_method(self) -> str:\n        return \"Implemented\"\n\n\nclass DerivedFrom(UnknownParent):  # [undefined-variable]\n    def __init__(self) -> None:\n        print(\"Called\")\n\n\nclass DerivedFromUnknownGrandparent(DerivedFrom):\n    def __init__(self) -> None:\n        DerivedFrom.__init__(self)\n"}, {"start_line": 0, "end_line": 1203, "belongs_to": {"file_name": "protocol_classes_abstract.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/p", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test that classes inheriting directly from Protocol should not warn about abstract-method.\"\"\"\n\n# pylint: disable=too-few-public-methods,disallowed-name,invalid-name\n\nfrom abc import abstractmethod, ABCMeta\nfrom typing import Protocol, Literal\n\n\nclass FooProtocol(Protocol):\n    \"\"\"Foo Protocol\"\"\"\n\n    @abstractmethod\n    def foo(self) -> Literal[\"foo\"]:\n        \"\"\"foo method\"\"\"\n\n    def foo_no_abstract(self) -> Literal[\"foo\"]:\n        \"\"\"foo not abstract method\"\"\"\n\n\nclass BarProtocol(Protocol):\n    \"\"\"Bar Protocol\"\"\"\n    @abstractmethod\n    def bar(self) -> Literal[\"bar\"]:\n        \"\"\"bar method\"\"\"\n\n\nclass FooBarProtocol(FooProtocol, BarProtocol, Protocol):\n    \"\"\"FooBar Protocol\"\"\"\n\nclass BarParent(BarProtocol): # [abstract-method]\n    \"\"\"Doesn't subclass typing.Protocol directly\"\"\"\n\nclass IndirectProtocol(FooProtocol):  # [abstract-method]\n    \"\"\"Doesn't subclass typing.Protocol directly\"\"\"\n\nclass AbcProtocol(FooProtocol, metaclass=ABCMeta):\n    \"\"\"Doesn't subclass typing.Protocol but uses metaclass directly\"\"\"\n\nclass FooBar(FooBarProtocol):\n    \"\"\"FooBar object\"\"\"\n\n    def bar(self) -> Literal[\"bar\"]:\n        return \"bar\"\n\n    def foo(self) -> Literal[\"foo\"]:\n        return \"foo\"\n"}, {"start_line": 0, "end_line": 1698, "belongs_to": {"file_name": "init_not_called.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/i", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=too-few-public-methods, import-error, missing-docstring, wrong-import-position\n# pylint: disable=useless-super-delegation, unnecessary-pass\n\n\nfrom typing import overload\n\nfrom missing import Missing\n\n\nclass AAAA:\n    \"\"\"ancestor 1\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass BBBB:\n    \"\"\"ancestor 2\"\"\"\n\n    def __init__(self):\n        print(\"init\", self)\n\n\nclass CCCC:\n    \"\"\"ancestor 3\"\"\"\n\n\nclass ZZZZ(AAAA, BBBB, CCCC):\n    \"\"\"derived class\"\"\"\n\n    def __init__(self):  # [super-init-not-called]\n        AAAA.__init__(self)\n\n\nclass NewStyleA:\n    \"\"\"new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        print(\"init\", self)\n\n\nclass NewStyleB(NewStyleA):\n    \"\"\"derived new style class\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n\nclass NewStyleC:\n    \"\"\"__init__ defined by assignment.\"\"\"\n\n    def xx_init(self):\n        \"\"\"Initializer.\"\"\"\n        pass\n\n    __init__ = xx_init\n\n\nclass AssignedInit(NewStyleC):\n    \"\"\"No init called, but abstract so that is fine.\"\"\"\n\n    def __init__(self):\n        self.arg = 0\n\n\nclass UnknownBases(Missing):\n    \"\"\"No false positives if the bases aren't known.\"\"\"\n\n\nclass Parent:\n    def __init__(self, num: int):\n        self.number = num\n\n\nclass Child(Parent):\n    @overload\n    def __init__(self, num: int):\n        ...\n\n    @overload\n    def __init__(self, num: float):\n        ...\n\n    def __init__(self, num):\n        super().__init__(round(num))\n\n\n# https://github.com/pylint-dev/pylint/issues/7742\n# Crash when parent class has a class attribute named `__init__`\nclass NoInitMethod:\n    __init__ = 42\n\n\nclass ChildNoInitMethod(NoInitMethod):\n    def __init__(self):\n        ...\n"}, {"start_line": 14000, "end_line": 15284, "belongs_to": {"file_name": "useless_parent_delegation.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/useless", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng)\n\n\nclass Ham(Egg):\n    def __init__(self, thing: object) -> None:  # [useless-parent-delegation]\n        super().__init__(thing)\n\n\nclass Test:\n    def __init__(self, _arg: List[int]) -> None:\n        super().__init__()\n\n\nclass ReturnTypeAny:\n    choices = [\"a\", 1, (2, 3)]\n\n    def draw(self) -> Any:\n        return random.choice(self.choices)\n\n\nclass ReturnTypeNarrowed(ReturnTypeAny):\n    choices = [1, 2, 3]\n\n    def draw(self) -> int:\n        return super().draw()\n\n\nclass NoReturnType:\n    choices = [\"a\", 1, (2, 3)]\n\n    def draw(self):\n        return random.choice(self.choices)\n\n\nclass ReturnTypeSpecified(NoReturnType):\n    choices = [\"a\", \"b\"]\n\n    def draw(self) -> str:  # [useless-parent-delegation]\n        return super().draw()\n\n\nclass ReturnTypeSame(ReturnTypeAny):\n    choices = [\"a\", \"b\"]\n\n    def draw(self) -> Any:  # [useless-parent-delegation]\n        return super().draw()\n\n\n# Any number of positional arguments followed by one keyword argument with a default value\nclass Fruit:\n    def __init__(*, tastes_bitter=None):\n        ...\n\n\nclass Lemon(Fruit):\n    def __init__(*, tastes_bitter=True):\n        super().__init__(tastes_bitter=tastes_bitter)\n\n\nclass CustomError(Exception):\n    def __init__(self, message=\"default\"):\n        super().__init__(message)\n"}, {"start_line": 85000, "end_line": 87000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n\n        def is_abstract(method: nodes.FunctionDef) -> bool:\n            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]\n\n        # check if this class abstract\n        if class_is_abstract(node):\n            return\n\n        methods = sorted(\n            unimplemented_abstract_methods(node, is_abstract).items(),\n            key=lambda item: item[0],\n        )\n        for name, method in methods:\n            owner = method.parent.frame()\n            if owner is node:\n                continue\n            # owner is not this class, it must be a parent class\n            # check that the ancestor's method is not abstract\n            if name in node.locals:\n                # it is redefined as an attribute or with a descriptor\n                continue\n\n            self.add_message(\n                \"abstract-method\",\n                node=node,\n                args=(name, owner.name, node.name),\n                confidence=INFERENCE,\n            )\n\n    def _check_init(self, node: nodes.FunctionDef, klass_node: nodes.ClassDef) -> None:\n        \"\"\"Check that the __init__ method call super or ancestors'__init__\n        method (unless it is used for type hinting with `typing.overload`).\n        \"\"\"\n        if not self.linter.is_message_enabled(\n            \"super-init-not-called\"\n        ) and not self.linter.is_message_enabled(\"non-parent-init-called\"):\n            return\n        to_call = _ancestors_to_call(klass_node)\n        not_called_yet = dict(to_call)\n        parents_with_called_inits: set[bases.UnboundMethod] = set()\n        for stmt in node.nodes_of_class(nodes.Call):\n            expr = stmt.func\n            if not isinstance(expr, nodes.Attribute) or expr.attrname != \"__init__\":\n                continue\n            # skip the test if using super\n            if (\n                isinstance(expr.expr, nodes.Call)\n                and isinstance(expr.expr.func, nodes.Name)\n                and expr.expr.func.name == \"super\"\n            "}], "retrieved_count": 10, "cost_time": 0.3449990749359131}
{"question": "Where is the undefined-variable error triggered for the type annotation parameter in the first-level method that incorrectly references its own class, through the chain of module imports and type-checking guards?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "used_before_assignment_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ception as e:  # pylint: disable=broad-exception-caught\n        import types\n    finally:\n        copy = None\nelif input():\n    for i in range(1,2):\n        email = None\n    else:  # pylint: disable=useless-else-on-loop\n        json = None\n    while input():\n        import mailbox\n    else:  # pylint: disable=useless-else-on-loop\n        mimetypes = None\nelif input():\n    with input() as base64:\n        pass\n    with input() as temp:\n        import binascii\nelse:\n    from urllib.request import urlopen\n    zoneinfo: str = ''\n    def pprint():\n        pass\n    class collections:  # pylint: disable=too-few-public-methods,missing-class-docstring\n        pass\n\nclass MyClass:\n    \"\"\"Type annotation or default values for first level methods can't refer to their own class\"\"\"\n\n    def incorrect_typing_method(\n        self, other: MyClass  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def incorrect_nested_typing_method(\n        self, other: List[MyClass]  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other[0]\n\n    def incorrect_default_method(\n        self, other=MyClass()  # [undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def correct_string_typing_method(self, other: \"MyClass\") -> bool:\n        return self == other\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyClass())\n\n\nclass MySecondClass:\n    \"\"\"Class to test self referential variable typing.\n    This regressed, reported in: https://github.com/pylint-dev/pylint/issues/5342\n    \"\"\"\n\n    def self_referential_optional_within_method(self) -> None:\n        variable: Optional[MySecondClass] = self\n        print(variable)\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MySecondClass) -> bool:\n            return self == other\n\n        return inner_method(self, MySecondClass())\n\n\nclass "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "used_before_assignment_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[undefined-variable]\n    ) -> bool:\n        return self == other[0]\n\n    def incorrect_default_method(\n        self, other=MyClass()  # [undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def correct_string_typing_method(self, other: \"MyClass\") -> bool:\n        return self == other\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyClass())\n\n\nclass MySecondClass:\n    \"\"\"Class to test self referential variable typing.\n    This regressed, reported in: https://github.com/pylint-dev/pylint/issues/5342\n    \"\"\"\n\n    def self_referential_optional_within_method(self) -> None:\n        variable: Optional[MySecondClass] = self\n        print(variable)\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MySecondClass) -> bool:\n            return self == other\n\n        return inner_method(self, MySecondClass())\n\n\nclass MyOtherClass:\n    \"\"\"Class to test self referential variable typing, no regression.\"\"\"\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyOtherClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyOtherClass())\n\n    def self_referential_optional_within_method(self) -> None:\n        variable: Optional[MyOtherClass] = self\n        print(variable)\n\n\nclass MyThirdClass:\n    \"\"\"Class to test self referential variable typing within conditionals.\n    This regressed, reported in: https://github.com/pylint-dev/pylint/issues/5499\n    \"\"\"\n\n    def function(self, var: int) -> None:\n        if var < 0.5:\n            _x: MyThirdClass = self\n\n    def other_function(self) -> None:\n        _x: MyThirdClass = self\n\n\nclass MyFourthClass:  # pylint: disable=too-few-public-methods\n    \"\"\"Class to test conditional imports guarded by TYPE_CHECKING two levels\n    up then used in function annotation. See https://github.com/pylint-dev/pyli"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "used_before_assignment_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "MyOtherClass:\n    \"\"\"Class to test self referential variable typing, no regression.\"\"\"\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyOtherClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyOtherClass())\n\n    def self_referential_optional_within_method(self) -> None:\n        variable: Optional[MyOtherClass] = self\n        print(variable)\n\n\nclass MyThirdClass:\n    \"\"\"Class to test self referential variable typing within conditionals.\n    This regressed, reported in: https://github.com/pylint-dev/pylint/issues/5499\n    \"\"\"\n\n    def function(self, var: int) -> None:\n        if var < 0.5:\n            _x: MyThirdClass = self\n\n    def other_function(self) -> None:\n        _x: MyThirdClass = self\n\n\nclass MyFourthClass:  # pylint: disable=too-few-public-methods\n    \"\"\"Class to test conditional imports guarded by TYPE_CHECKING two levels\n    up then used in function annotation. See https://github.com/pylint-dev/pylint/issues/7539\"\"\"\n\n    def is_close(self, comparator: math.isclose, first, second):  # <3.14:[used-before-assignment]\n        \"\"\"Conditional imports guarded are only valid for variable annotations.\"\"\"\n        comparator(first, second)\n\n\nclass VariableAnnotationsGuardedByTypeChecking:  # pylint: disable=too-few-public-methods\n    \"\"\"Class to test conditional imports guarded by TYPE_CHECKING then used in\n    local (function) variable annotations, which are not evaluated at runtime.\n\n    See: https://github.com/pylint-dev/pylint/issues/7609\n    and https://github.com/pylint-dev/pylint/issues/7882\n    \"\"\"\n\n    still_an_error: datetime.date  # <3.14:[used-before-assignment]\n\n    def print_date(self, date) -> None:\n        date: datetime.date = date\n        print(date)\n\n        import datetime  # pylint: disable=import-outside-toplevel\n\n\nclass ConditionalImportGuardedWhenUsed:  # pylint: disable=too-few-public-methods\n    \"\"\"Conditional imports also guarded by TYPE_CHECKING when used.\"\"\"\n   "}, {"start_line": 0, "end_line": 654, "belongs_to": {"file_name": "undefined_variable_classes.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for undefined-variable related to classes\"\"\"\n# pylint: disable=missing-function-docstring, missing-class-docstring, too-few-public-methods\n\n# Test that list comprehensions in base classes are scoped correctly\n# Regression reported in https://github.com/pylint-dev/pylint/issues/3434\n\nimport collections\n\nL = [\"a\", \"b\", \"c\"]\n\n\nclass Foo(collections.namedtuple(\"Foo\", [x + \"_foo\" for x in L])):\n    pass\n\n\n# Test that class attributes are in scope for return type annotations.\n# Regression reported in https://github.com/pylint-dev/pylint/issues/1976\nclass MyObject:\n    class MyType:\n        pass\n\n    def my_method(self) -> MyType:\n        pass\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "used_before_assignment_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for used-before-assignment for typing related issues\"\"\"\n# pylint: disable=missing-function-docstring,ungrouped-imports,invalid-name\n# pylint: disable=line-too-long\n\nfrom typing import List, NamedTuple, Optional, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    if True:  # pylint: disable=using-constant-test\n        import math\n    import dbm\n    print(dbm)  # no error when defined and used in the same false branch\n    from urllib.request import urlopen\n    import array\n    import base64\n    import binascii\n    import calendar\n    import collections\n    import copy\n    import datetime\n    import email\n    import heapq\n    import json\n    import mailbox\n    import mimetypes\n    import numbers\n    import pprint\n    import types\n    import zoneinfo\nelif input():\n    import calendar, bisect  # pylint: disable=multiple-imports\n    if input() + 1:\n        import heapq\n    else:\n        import heapq\nelif input():\n    try:\n        numbers = None if input() else 1\n        import array\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        import types\n    finally:\n        copy = None\nelif input():\n    for i in range(1,2):\n        email = None\n    else:  # pylint: disable=useless-else-on-loop\n        json = None\n    while input():\n        import mailbox\n    else:  # pylint: disable=useless-else-on-loop\n        mimetypes = None\nelif input():\n    with input() as base64:\n        pass\n    with input() as temp:\n        import binascii\nelse:\n    from urllib.request import urlopen\n    zoneinfo: str = ''\n    def pprint():\n        pass\n    class collections:  # pylint: disable=too-few-public-methods,missing-class-docstring\n        pass\n\nclass MyClass:\n    \"\"\"Type annotation or default values for first level methods can't refer to their own class\"\"\"\n\n    def incorrect_typing_method(\n        self, other: MyClass  # <3.14:[undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def incorrect_nested_typing_method(\n        self, other: List[MyClass]  # <3.14:"}, {"start_line": 0, "end_line": 1187, "belongs_to": {"file_name": "used_before_assignment_py37.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/used", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for used-before-assignment with functions added in python 3.7\"\"\"\n# pylint: disable=missing-function-docstring\nfrom __future__ import annotations\nfrom collections import namedtuple\nfrom typing import List\n\n\nclass MyClass:\n    \"\"\"With the future import only default values can't refer to the base class\"\"\"\n\n    def correct_typing_method(self, other: MyClass) -> bool:\n        return self == other\n\n    def second_correct_typing_method(self, other: List[MyClass]) -> bool:\n        return self == other[0]\n\n    def incorrect_default_method(\n        self, other=MyClass() # [undefined-variable]\n    ) -> bool:\n        return self == other\n\n    def correct_string_typing_method(self, other: \"MyClass\") -> bool:\n        return self == other\n\n    def correct_inner_typing_method(self) -> bool:\n        def inner_method(self, other: MyClass) -> bool:\n            return self == other\n\n        return inner_method(self, MyClass())\n\n\nclass NamedTupleSubclass(namedtuple(\"NamedTupleSubclass\", [])):\n    \"\"\"Taken from https://github.com/pylint-dev/pylint/issues/5982\"\"\"\n    def method(self) -> NamedTupleSubclass:\n        \"\"\"Variables checker crashed when astroid did not supply a lineno\"\"\"\n"}, {"start_line": 8000, "end_line": 9071, "belongs_to": {"file_name": "undefined_variable.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(3))  # [undefined-variable]\ndef decorated4(x):\n    print(x)\n\n\n# https://github.com/pylint-dev/pylint/issues/5111\n# AssignAttr in orelse block of 'TYPE_CHECKING' shouldn't crash\n# Name being assigned must be imported in orelse block\nif TYPE_CHECKING:\n    pass\nelse:\n    from types import GenericAlias\n    object().__class_getitem__ = classmethod(GenericAlias)\n\n\nGLOBAL_VAR: int\nGLOBAL_VAR_TWO: int\n\ndef global_var_mixed_assignment():\n    \"\"\"One global variable never gets assigned a value\"\"\"\n    global GLOBAL_VAR\n    print(GLOBAL_VAR) # [undefined-variable]\n    global GLOBAL_VAR_TWO\n    print(GLOBAL_VAR_TWO)\n\nGLOBAL_VAR_TWO = 2\n\n\nGLOBAL_VAR: int\nGLOBAL_VAR_TWO: int\n\n\nclass RepeatedReturnAnnotations:\n    def x(self, o: RepeatedReturnAnnotations) -> bool:  # <3.14:[undefined-variable]\n        pass\n    def y(self) -> RepeatedReturnAnnotations:  # <3.14:[undefined-variable]\n        pass\n    def z(self) -> RepeatedReturnAnnotations:  # <3.14:[undefined-variable]\n        pass\n\nclass A:\n    def say_hello(self) -> __module__:  # <3.14:[undefined-variable]\n        ...\n"}, {"start_line": 98000, "end_line": 100000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      return False\n\n            local_refs = parent_scope.locals.get(node.name, [])\n            for ref_node in local_refs:\n                # If local ref is in the same frame as our node, but on a later lineno\n                # we don't actually care about this local ref.\n                # Local refs are ordered, so we break.\n                #     print(var)\n                #     var = 1  # <- irrelevant\n                if defstmt_frame == node_frame and ref_node.lineno > node.lineno:\n                    break\n\n                # If the parent of the local reference is anything but an AnnAssign\n                # Or if the AnnAssign adds a value the variable will now have a value\n                #     var = 1  # OR\n                #     var: int = 1\n                if (\n                    not isinstance(ref_node.parent, nodes.AnnAssign)\n                    or ref_node.parent.value\n                ) and not (\n                    # EXCEPTION: will not have a value if a self-referencing named expression\n                    # var: int\n                    # if (var := var * var)  <-- \"var\" still undefined\n                    isinstance(ref_node.parent, nodes.NamedExpr)\n                    and any(a is ref_node.parent.value for a in node.node_ancestors())\n                ):\n                    return False\n            parent = parent_scope.parent\n        return True\n\n    def _is_first_level_self_reference(\n        self,\n        node: nodes.Name,\n        defstmt: nodes.ClassDef,\n        found_nodes: list[nodes.NodeNG],\n    ) -> tuple[VariableVisitConsumerAction, list[nodes.NodeNG] | None]:\n        \"\"\"Check if a first level method's annotation or default values\n        refers to its own class, and return a consumer action.\n        \"\"\"\n        if node.frame().parent == defstmt and node.statement() == node.frame():\n            # Check if used as type annotation\n            # Break if postponed evaluation is enabled\n            if utils.is_node_in_type_annotation_context(node)"}, {"start_line": 1000, "end_line": 2936, "belongs_to": {"file_name": "undefined_variable_py30.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         \"\"\" Triggers undefined-variable. \"\"\"\n\n\nclass FalsePositive342:\n    # pylint: disable=line-too-long\n    \"\"\" Fix some false positives found in\n    https://bitbucket.org/logilab/pylint/issue/342/spurious-undefined-variable-for-class\n    \"\"\"\n\n    top = 42\n\n    def test_good(self, bac: top):\n        \"\"\" top is defined at this moment. \"\"\"\n\n    def test_bad(self, bac: trop): # [undefined-variable]\n        \"\"\" trop is undefined at this moment. \"\"\"\n\n    def test_bad1(self, *args: trop1): # [undefined-variable]\n        \"\"\" trop1 is undefined at this moment. \"\"\"\n\n    def test_bad2(self, **bac: trop2): # [undefined-variable]\n        \"\"\" trop2 is undefined at this moment. \"\"\"\n\nimport abc\nfrom abc import ABCMeta\n\nclass Bad(metaclass=ABCMet): # [undefined-variable]\n    \"\"\" Notice the typo \"\"\"\n\nclass SecondBad(metaclass=ab.ABCMeta): # [undefined-variable]\n    \"\"\" Notice the `ab` module. \"\"\"\n\nclass Good(metaclass=int):\n    \"\"\" int is not a proper metaclass, but it is defined. \"\"\"\n\nclass SecondGood(metaclass=Good):\n    \"\"\" empty \"\"\"\n\nclass ThirdGood(metaclass=ABCMeta):\n    \"\"\" empty \"\"\"\n\nclass FourthGood(ThirdGood):\n    \"\"\" This should not trigger anything. \"\"\"\n\nclass FifthGood(metaclass=abc.Metaclass):\n    \"\"\"Metaclasses can come from imported modules.\"\"\"\n\n# The following used to raise used-before-assignment\n# pylint: disable=missing-docstring, multiple-statements\ndef used_before_assignment(*, arg): return arg + 1\n\n\n# Test for #4021\n# https://github.com/pylint-dev/pylint/issues/4021\nclass MetaClass(type):\n    def __new__(mcs, *args, parameter=None, **kwargs):\n        print(parameter)\n        return super().__new__(mcs, *args, **kwargs)\n\n\nclass InheritingClass(metaclass=MetaClass, parameter=variable):  # [undefined-variable]\n    pass\n\n\n# Test for #4031\n# https://github.com/pylint-dev/pylint/issues/4031\nclass Inheritor(metaclass=DefinedTooLate ): # [undefined-variable]\n    pass\n\n\nclass DefinedTooLate():\n    pass\n"}, {"start_line": 0, "end_line": 736, "belongs_to": {"file_name": "undefined_variable_typing.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/u/undefined", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for undefined-variable related to typing\"\"\"\n# pylint: disable=invalid-name, import-error\n\n# Ensure attribute lookups in type comments are accounted for.\n# Reported in https://github.com/pylint-dev/pylint/issues/4603\n\nfrom typing import TYPE_CHECKING, Any, Dict\n\nimport foo\nfrom foo import Bar, Boo\n\na = ...  # type: foo.Bar\nb = ...  # type: foo.Bar[Boo]\nc = ...  # type: Bar.Boo\n\n\nif TYPE_CHECKING:\n    __additional_builtin__: Dict[str, Any]\n    # For why this would emit redefined-builtin: https://github.com/pylint-dev/pylint/pull/3643\n    # pylint: disable-next=redefined-builtin\n    repr: Any\n\n\ndef run():\n    \"\"\"https://github.com/pylint-dev/pylint/issues/6388\"\"\"\n    print(repr)\n    return __additional_builtin__[\"test\"]\n"}], "retrieved_count": 10, "cost_time": 0.34581494331359863}
{"question": "Where in the no-member validation function is the mechanism that enables modules with dynamic attribute handlers to bypass member checks?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n    \"\"\"Try to see if no-member should be emitted for the given owner.\n\n    The following cases are ignored:\n\n        * the owner is a function and it has decorators.\n        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:\n        return False\n    if is_super(owner) or getattr(owner, \"type\", None) == \"metaclass\":\n        return False\n    if owner_name and ignored_mixins and mixin_class_rgx.match(owner_name):\n        return False\n    if isinstance(owner, nodes.FunctionDef) and (\n        owner.decorators or owner.is_abstract()\n    ):\n        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n            pass\n        else:\n            # Renamed in Python 3.10 to `EnumType`\n            if metaclass and metaclass.qname() in {\"enum.EnumMeta\", \"enum.EnumType\"}:\n                return not _enum_has_attribute(owner, node)\n        if owner.has_dynamic_getattr():\n            return False\n        if not has_known_bases(owner):\n            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return Fal"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d argument of isinstance is not a type\",\n        \"isinstance-second-argument-not-valid-type\",\n        \"Emitted when the second argument of an isinstance call is not a type.\",\n    ),\n    \"W1117\": (\n        \"%r will be included in %r since a positional-only parameter with this name already exists\",\n        \"kwarg-superseded-by-positional-arg\",\n        \"Emitted when a function is called with a keyword argument that has the \"\n        \"same name as a positional-only parameter and the function contains a \"\n        \"keyword variadic parameter dict.\",\n    ),\n}\n\n# builtin sequence types in Python 2 and 3.\nSEQUENCE_TYPES = {\n    \"str\",\n    \"unicode\",\n    \"list\",\n    \"tuple\",\n    \"bytearray\",\n    \"xrange\",\n    \"range\",\n    \"bytes\",\n    \"memoryview\",\n}\n\n\ndef _emit_no_member(\n    node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr,\n    owner: InferenceResult,\n    owner_name: str | None,\n    mixin_class_rgx: Pattern[str],\n    ignored_mixins: bool = True,\n    ignored_none: bool = True,\n) -> bool:\n    \"\"\"Try to see if no-member should be emitted for the given owner.\n\n    The following cases are ignored:\n\n        * the owner is a function and it has decorators.\n        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:\n        return False\n    if is_super(owner) or getattr(owner, \"type\", None) == \"metaclass\":\n        return False\n    if owner_name and ignored_mixins and mixin_class_rgx.match(owner_n"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "se\n    if isinstance(owner, astroid.objects.Super):\n        # Verify if we are dealing with an invalid Super object.\n        # If it is invalid, then there's no point in checking that\n        # it has the required attribute. Also, don't fail if the\n        # MRO is invalid.\n        try:\n            owner.super_mro()\n        except (astroid.MroError, astroid.SuperError):\n            return False\n        if not all(has_known_bases(base) for base in owner.type.mro()):\n            return False\n    if isinstance(owner, nodes.Module):\n        try:\n            owner.getattr(\"__getattr__\")\n            return False\n        except astroid.NotFoundError:\n            pass\n    if owner_name and node.attrname.startswith(\"_\" + owner_name):\n        # Test if an attribute has been mangled ('private' attribute)\n        unmangled_name = node.attrname.split(\"_\" + owner_name)[-1]\n        try:\n            if owner.getattr(unmangled_name, context=None) is not None:\n                return False\n        except astroid.NotFoundError:\n            return True\n\n    # Don't emit no-member if guarded behind `IF` or `IFExp`\n    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n            if (  # pylint: disable=too-many-boolean-expressions\n                isinstance(inferred, nodes.Const)\n                and inferred.bool_value() is False\n                and (\n                    (isinstance(parent, nodes.If) and node_origin in parent.body)\n                    or (isinstance(parent, nodes.IfExp) and node_origin == parent.body)\n                "}, {"start_line": 4000, "end_line": 5484, "belongs_to": {"file_name": "member_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m/member", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ething.conjugate()\n\n\nclass NoDunderNameInInstance:\n    \"\"\"Emit a warning when accessing __name__ from an instance.\"\"\"\n    def __init__(self):\n        self.var = self.__name__ # [no-member]\n\n\nclass InvalidAccessBySlots:\n    __slots__ = ('a', )\n    def __init__(self):\n        var = self.teta # [no-member]\n        self.teta = 24\n\n\nclass MetaWithDynamicGetattr(type):\n\n    def __getattr__(cls, attr):\n        return attr\n\n\nclass SomeClass(metaclass=MetaWithDynamicGetattr):\n    pass\n\n\nSomeClass.does_not_exist\n\nclass ClassWithMangledAttribute:\n    def __init__(self):\n        self.name = 'Bug1643'\n    def __bar(self):\n        print(self.name + \"xD\")\n\nClassWithMangledAttribute()._ClassWithMangledAttribute__bar()  # pylint: disable=protected-access\n\n\nimport enum\n\n\nclass Cls(enum.IntEnum):\n    BAR = 0\n\n\nSOME_VALUE = Cls.BAZ  # [no-member]\n\n\n\n# Does not crash when inferring the `append` attribute on the slice object\nclass SomeClassUsingSlice:\n    def __init__(self, flag):\n        if flag:\n            self.attribute = slice(None)\n        else:\n            self.attribute = []\n            self.attribute.append(1)\n\nfrom enum import Enum\nclass Animal(Enum):\n    ANT = 1\n    BEE = 2\n    CAT = 3\n    DOG = 4\n# To test false positive no-member on Enum.__members__.items()\nfor itm in Animal.__members__.items():\n    print(itm)\nfor keyy in Animal.__members__.keys():  # pylint: disable=consider-iterating-dictionary\n    print(keyy)\nfor vall in Animal.__members__.values():\n    print(vall)\n"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     if isinstance(metaclass, nodes.ClassDef):\n            if _is_invalid_metaclass(metaclass):\n                self.add_message(\n                    \"invalid-metaclass\", node=node, args=(_metaclass_name(metaclass),)\n                )\n        else:\n            self.add_message(\n                \"invalid-metaclass\", node=node, args=(_metaclass_name(metaclass),)\n            )\n\n    def visit_assignattr(self, node: nodes.AssignAttr) -> None:\n        if isinstance(node.assign_type(), nodes.AugAssign):\n            self.visit_attribute(node)\n\n    def visit_delattr(self, node: nodes.DelAttr) -> None:\n        self.visit_attribute(node)\n\n    # pylint: disable = too-many-branches, too-many-statements\n    @only_required_for_messages(\"no-member\", \"c-extension-no-member\")\n    def visit_attribute(\n        self, node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr\n    ) -> None:\n        \"\"\"Check that the accessed attribute exists.\n\n        to avoid too much false positives for now, we'll consider the code as\n        correct if a single of the inferred nodes has the accessed attribute.\n\n        function/method, super call and metaclasses are ignored\n        \"\"\"\n        if any(\n            pattern.match(name)\n            for name in (node.attrname, node.as_string())\n            for pattern in self._compiled_generated_members\n        ):\n            return\n\n        if self._postponed_evaluation_enabled and is_node_in_type_annotation_context(\n            node\n        ):\n            return\n\n        try:\n            inferred = list(node.expr.infer())\n        except astroid.InferenceError:\n            return\n\n        # list of (node, nodename) which are missing the attribute\n        missingattr: set[tuple[SuccessfulInferenceResult, str | None]] = set()\n\n        non_opaque_inference_results: list[SuccessfulInferenceResult] = [\n            owner\n            for owner in inferred\n            if not isinstance(owner, (nodes.Unknown, util.UninferableBase))\n        ]\n        if (\n            "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "member_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m/member", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "indeed()\nexcept AttributeError:\n    try:\n        Client.missing() # [no-member]\n    except Exception:\n        pass\n\n\nclass SuperChecks(str, str): # pylint: disable=duplicate-bases\n    \"\"\"Don't fail when the MRO is invalid.\"\"\"\n    def test(self):\n        super().lalala()\n\ntype(Client()).ala # [no-member]\ntype({}).bala # [no-member]\ntype('').portocala # [no-member]\n\n\ndef socket_false_positive():\n    \"\"\"Test a regression\n    Version used:\n\n    - Pylint 0.10.0\n    - Logilab common 0.15.0\n    - Logilab astroid 0.15.1\n\n    False E1101 positive, line 23:\n    Instance of '_socketobject' has no 'connect' member\n    \"\"\"\n\n    import socket\n    sckt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sckt.connect(('127.0.0.1', 80))\n    sckt.close()\n\n\ndef no_conjugate_member(magic_flag):\n    \"\"\"should not raise E1101 on something.conjugate\"\"\"\n    if magic_flag:\n        something = 1.0\n    else:\n        something = 1.0j\n    if isinstance(something, float):\n        return something\n    return something.conjugate()\n\n\nclass NoDunderNameInInstance:\n    \"\"\"Emit a warning when accessing __name__ from an instance.\"\"\"\n    def __init__(self):\n        self.var = self.__name__ # [no-member]\n\n\nclass InvalidAccessBySlots:\n    __slots__ = ('a', )\n    def __init__(self):\n        var = self.teta # [no-member]\n        self.teta = 24\n\n\nclass MetaWithDynamicGetattr(type):\n\n    def __getattr__(cls, attr):\n        return attr\n\n\nclass SomeClass(metaclass=MetaWithDynamicGetattr):\n    pass\n\n\nSomeClass.does_not_exist\n\nclass ClassWithMangledAttribute:\n    def __init__(self):\n        self.name = 'Bug1643'\n    def __bar(self):\n        print(self.name + \"xD\")\n\nClassWithMangledAttribute()._ClassWithMangledAttribute__bar()  # pylint: disable=protected-access\n\n\nimport enum\n\n\nclass Cls(enum.IntEnum):\n    BAR = 0\n\n\nSOME_VALUE = Cls.BAZ  # [no-member]\n\n\n\n# Does not crash when inferring the `append` attribute on the slice object\nclass SomeClassUsingSlice:\n    def __init__(self, flag):\n        if flag:\n         "}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ame):\n        return False\n    if isinstance(owner, nodes.FunctionDef) and (\n        owner.decorators or owner.is_abstract()\n    ):\n        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n            pass\n        else:\n            # Renamed in Python 3.10 to `EnumType`\n            if metaclass and metaclass.qname() in {\"enum.EnumMeta\", \"enum.EnumType\"}:\n                return not _enum_has_attribute(owner, node)\n        if owner.has_dynamic_getattr():\n            return False\n        if not has_known_bases(owner):\n            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n        # Verify if we are dealing with an invalid Super object.\n        # If it is invalid, then there's no point in checking that\n        # it has the required attribute. Also, don't fail if the\n        # MRO is invalid.\n        try:\n            owner.super_mro()\n        except (astroid.MroError, astroid.SuperError):\n            return False\n        if not all(has_known_bases(base) for base in owner.type.mro()):\n            return False\n    if isinstance(owner, nodes.Module):\n        try:\n            owner.getattr(\"__getattr__\")\n            return False\n        except astroid.NotFoundError:\n            pass\n    if owner_name and node.attrname.startswith(\"_\" + owner_name):\n        # Test if an attribute has been mangled ('private' attribute)\n        unmangled_name = node.attrname.split(\"_\" + owner_name)[-1]\n        try:\n            if owner.getattr(unmangled_name, context=None) is not None:\n                return False\n        except"}, {"start_line": 79000, "end_line": 81000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pt astroid.NotFoundError:\n                pass\n            # is it an instance attribute of a parent class ?\n            try:\n                next(node.instance_attr_ancestors(attr))\n                # yes, stop here\n                continue\n            except StopIteration:\n                pass\n            # is it an instance attribute ?\n            try:\n                defstmts = node.instance_attr(attr)\n            except astroid.NotFoundError:\n                pass\n            else:\n                # filter out augment assignment nodes\n                defstmts = [stmt for stmt in defstmts if stmt not in nodes_lst]\n                if not defstmts:\n                    # only augment assignment for this node, no-member should be\n                    # triggered by the typecheck checker\n                    continue\n                # filter defstmts to only pick the first one when there are\n                # several assignments in the same scope\n                scope = defstmts[0].scope()\n                defstmts = [\n                    stmt\n                    for i, stmt in enumerate(defstmts)\n                    if i == 0 or stmt.scope() is not scope\n                ]\n                # if there are still more than one, don't attempt to be smarter\n                # than we can be\n                if len(defstmts) == 1:\n                    defstmt = defstmts[0]\n                    # check that if the node is accessed in the same method as\n                    # it's defined, it's accessed after the initial assignment\n                    frame = defstmt.frame()\n                    lno = defstmt.fromlineno\n                    for _node in nodes_lst:\n                        if (\n                            _node.frame() is frame\n                            and _node.fromlineno < lno\n                            and not astroid.are_exclusive(\n                                _node.statement(), defstmt, excs\n                            )\n                        ):\n             "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " astroid.NotFoundError:\n            return True\n\n    # Don't emit no-member if guarded behind `IF` or `IFExp`\n    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n            if (  # pylint: disable=too-many-boolean-expressions\n                isinstance(inferred, nodes.Const)\n                and inferred.bool_value() is False\n                and (\n                    (isinstance(parent, nodes.If) and node_origin in parent.body)\n                    or (isinstance(parent, nodes.IfExp) and node_origin == parent.body)\n                )\n            ):\n                return False\n        node_origin, parent = parent, parent.parent\n\n    return True\n\n\ndef _get_all_attribute_assignments(\n    node: nodes.FunctionDef, name: str | None = None\n) -> set[str]:\n    attributes: set[str] = set()\n    for child in node.nodes_of_class((nodes.Assign, nodes.AnnAssign)):\n        targets = []\n        if isinstance(child, nodes.Assign):\n            targets = child.targets\n        elif isinstance(child, nodes.AnnAssign):\n            targets = [child.target]\n        for assign_target in targets:\n            if isinstance(assign_target, nodes.Tuple):\n                targets.extend(assign_target.elts)\n                continue\n            if (\n                isinstance(assign_target, nodes.AssignAttr)\n                and isinstance(assign_target.expr, nodes.Name)\n                and (name is None or assign_target.expr.name == name)\n            ):\n                attributes.add(assign_target.attrname)\n    return attributes\n\n\ndef _enum_has_a"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "member_checks.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/m/member", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " Mixin:\n    \"\"\"No no-member should be emitted for mixins.\"\"\"\n\nclass Getattr:\n    \"\"\"no-member shouldn't be emitted for classes with dunder getattr.\"\"\"\n\n    def __getattr__(self, attr):\n        return self.__dict__[attr]\n\n\nclass Getattribute:\n    \"\"\"no-member shouldn't be emitted for classes with dunder getattribute.\"\"\"\n\n    def __getattribute__(self, attr):\n        return 42\n\nprint(object.__init__)\nprint(property.__init__)\nprint(Client().set_later.lower())\nprint(Mixin().nanana())\nprint(Getattr().nananan())\nprint(Getattribute().batman())\n\ntry:\n    Client().missing_method()\nexcept AttributeError:\n    pass\n\ntry:\n    Client().indeed() # [no-member]\nexcept ImportError:\n    pass\n\ntry:\n    Client.missing()\nexcept AttributeError:\n    Client.missing() # [no-member]\n\ntry:\n    Client.missing()\nexcept AttributeError:\n    try:\n        Client.missing() # [no-member]\n    except ValueError:\n        pass\n\ntry:\n    if Client:\n        Client().missing()\nexcept AttributeError:\n    pass\n\ntry:\n    Client().indeed()\nexcept AttributeError:\n    try:\n        Client.missing() # [no-member]\n    except Exception:\n        pass\n\n\nclass SuperChecks(str, str): # pylint: disable=duplicate-bases\n    \"\"\"Don't fail when the MRO is invalid.\"\"\"\n    def test(self):\n        super().lalala()\n\ntype(Client()).ala # [no-member]\ntype({}).bala # [no-member]\ntype('').portocala # [no-member]\n\n\ndef socket_false_positive():\n    \"\"\"Test a regression\n    Version used:\n\n    - Pylint 0.10.0\n    - Logilab common 0.15.0\n    - Logilab astroid 0.15.1\n\n    False E1101 positive, line 23:\n    Instance of '_socketobject' has no 'connect' member\n    \"\"\"\n\n    import socket\n    sckt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sckt.connect(('127.0.0.1', 80))\n    sckt.close()\n\n\ndef no_conjugate_member(magic_flag):\n    \"\"\"should not raise E1101 on something.conjugate\"\"\"\n    if magic_flag:\n        something = 1.0\n    else:\n        something = 1.0j\n    if isinstance(something, float):\n        return something\n    return som"}], "retrieved_count": 10, "cost_time": 0.35152292251586914}
{"question": "Why does the test case that validates detection of overridden methods marked as immutable use the typing decorator that prevents subclass modifications to maintain behavioral contracts in class hierarchies?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 693, "belongs_to": {"file_name": "overridden_final_method_py38.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/o", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Since Python version 3.8, a method decorated with typing.final cannot be\noverridden\"\"\"\n\n# pylint: disable=missing-docstring, too-few-public-methods\n\nfrom typing import final\n\nclass Base:\n    @final\n    def my_method(self):\n        pass\n\n\nclass Subclass(Base):\n    def my_method(self): # [overridden-final-method]\n        pass\n\n# Check for crash on method definitions not at top level of class\n# https://github.com/pylint-dev/pylint/issues/5648\nclass BaseConditional:\n\n    create_final_method = True\n    if create_final_method:\n        @final\n        def my_method(self):\n            pass\n\nclass Subclass2(BaseConditional):\n\n    def my_method(self): # [overridden-final-method]\n        pass\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       end_col_offset=18,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def typing_objects_are_subscriptable(self, generic: str) -> None:\n        module = astroid.parse(\n            f\"\"\"\n        import typing\n        test = typing.{generic}[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_subscriptable_then_unsubscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Unsubscriptable\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"decorated\",\n                confidence=UNDEFINED,\n                line=18,\n                col_offset=7,\n                end_line=18,\n                end_col_offset=16,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_unsubscriptable_then_subscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        @Unsubscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.as"}, {"start_line": 0, "end_line": 181, "belongs_to": {"file_name": "overridden_final_method_regression.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/o", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test a crash regression for the overridden-final-method checker on uninferable decorators\"\"\"\n\n\n@unknown_decorator  # [undefined-variable]\ndef crash_test():\n    \"\"\"A docstring\"\"\"\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r.CTracer  #@\n        \"\"\"\n        )\n        message = MessageTest(\n            \"c-extension-no-member\",\n            node=node,\n            args=(\"Module\", \"coverage.tracer\", \"CTracer\", \"\"),\n            confidence=INFERENCE,\n            line=3,\n            col_offset=0,\n            end_line=3,\n            end_col_offset=14,\n        )\n        with self.assertAddsMessages(message):\n            self.checker.visit_attribute(node)\n\n\nclass TestTypeCheckerOnDecorators(CheckerTestCase):\n    \"\"\"Tests for pylint.checkers.typecheck on decorated functions.\"\"\"\n\n    CHECKER_CLASS = typecheck.TypeChecker\n\n    def test_issue3882_class_decorators(self) -> None:\n        decorators = \"\"\"\n        class Unsubscriptable:\n            def __init__(self, f):\n                self.f = f\n\n        class Subscriptable:\n            def __init__(self, f):\n                self.f = f\n\n            def __getitem__(self, item):\n                return item\n        \"\"\"\n        for generic in \"Optional\", \"List\", \"ClassVar\", \"Final\", \"Literal\":\n            self.typing_objects_are_subscriptable(generic)\n\n        self.getitem_on_modules()\n        self.decorated_by_a_subscriptable_class(decorators)\n        self.decorated_by_an_unsubscriptable_class(decorators)\n\n        self.decorated_by_subscriptable_then_unsubscriptable_class(decorators)\n        self.decorated_by_unsubscriptable_then_subscriptable_class(decorators)\n\n    def getitem_on_modules(self) -> None:\n        \"\"\"Mainly validate the code won't crash if we're not having a function.\"\"\"\n        module = astroid.parse(\n            \"\"\"\n        import collections\n        test = collections[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"collections\",\n                confidence=UNDEFINED,\n                line=3,\n                col_offset=7,\n                end_line=3,\n         "}, {"start_line": 0, "end_line": 493, "belongs_to": {"file_name": "cached_property.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,invalid-name\nfrom functools import cached_property\n\n\n# https://github.com/pylint-dev/pylint/issues/4023\n# False-positive 'invalid-overridden-method' with 'cached_property'\nclass Parent:\n    @property\n    def value(self):\n        return 42\n\n    def func(self):\n        return False\n\n\nclass Child(Parent):\n    @cached_property\n    def value(self):\n        return 2**6\n\n    @cached_property\n    def func(self):  # [invalid-overridden-method]\n        return 42\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "arguments_differ.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", *args, third, **kwargs)\n\n\nclass HasSpecialMethod:\n\n    def __getitem__(self, key):\n        return key\n\n\nclass OverridesSpecialMethod(HasSpecialMethod):\n\n    def __getitem__(self, cheie):\n        # no error here, method overrides special method\n        return cheie + 1\n\n\nclass ParentClass:\n\n    def meth(self, arg, arg1):\n        raise NotImplementedError\n\n\nclass ChildClass(ParentClass):\n\n    def meth(self, _arg, dummy):\n        # no error here, \"dummy\" and \"_\" are being ignored if\n        # spotted in a variable name (declared in dummy_parameter_regex)\n        pass\n\n\n# https://github.com/pylint-dev/pylint/issues/4443\n# Some valid overwrites with type annotations\n\nimport typing  # pylint: disable=wrong-import-position\nfrom typing import Dict  # pylint: disable=wrong-import-position\n\n\nclass ParentT1:\n    def func(self, user_input: Dict[str, int]) -> None:\n        pass\n\nclass ChildT1(ParentT1):\n    def func(self, user_input: Dict[str, int]) -> None:\n        pass\n\nclass ParentT2:\n    async def func(self, user_input: typing.List) -> None:\n        pass\n\nclass ChildT2(ParentT2):\n    async def func(self, user_input: typing.List) -> None:\n        pass\n\nclass FooT1:\n    pass\n\nclass ParentT3:\n    def func(self, user_input: FooT1) -> None:\n        pass\n\nclass ChildT3(ParentT3):\n    def func(self, user_input: FooT1) -> None:\n        pass\n\n# Keyword and positional overrides\nclass AbstractFoo:\n\n    def kwonly_1(self, first, *, second, third):\n        \"Normal positional with two positional only params.\"\n\n    def kwonly_2(self, *, first, second):\n        \"Two positional only parameter.\"\n\n    def kwonly_3(self, *, first, second):\n        \"Two positional only params.\"\n\n    def kwonly_4(self, *, first, second=None):\n        \"One positional only and another with a default.\"\n\n    def kwonly_5(self, *, first, **kwargs):\n        \"Keyword only and keyword variadics.\"\n\n    def kwonly_6(self, first, second, *, third):\n        \"Two positional and one keyword\"\n\n\nclass Foo(AbstractFoo):\n\n    de"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "arguments_differ.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "thod\n    def func(data):\n        return data\n\n\nclass StaticmethodChild(Staticmethod):\n\n    @classmethod\n    def func(cls, data):\n        return data\n\n\nclass Property:\n\n    @property\n    def close(self):\n        pass\n\nclass PropertySetter(Property):\n\n    @property\n    def close(self):\n        pass\n\n    @close.setter\n    def close(self, attr):\n        return attr\n\n\nclass StaticmethodChild2(Staticmethod):\n\n    def func(self, data):  # [arguments-differ]\n        super().func(data)\n\n\nclass SuperClass:\n\n    @staticmethod\n    def impl(arg1, arg2, **kwargs):\n        return arg1 + arg2\n\n    def should_have_been_decorated_as_static(arg1, arg2):  # pylint: disable=no-self-argument\n        return arg1 + arg2\n\n\nclass MyClass(SuperClass):\n\n    @staticmethod\n    def impl(*args, **kwargs):\n        \"\"\"\n        Acceptable use of vararg in subclass because it does not violate LSP.\n        \"\"\"\n        super().impl(*args, **kwargs)\n\n    @staticmethod\n    def should_have_been_decorated_as_static(arg1, arg2):\n        return arg1 + arg2\n\n\nclass FirstHasArgs:\n\n    def test(self, *args):\n        pass\n\n\nclass SecondChangesArgs(FirstHasArgs):\n\n    def test(self, first, second, *args):  # [arguments-differ]\n        pass\n\n\nclass Positional:\n\n    def test(self, first, second):\n        pass\n\n\nclass PositionalChild(Positional):\n\n    def test(self, *args):\n        \"\"\"\n        Acceptable use of vararg in subclass because it does not violate LSP.\n        \"\"\"\n        super().test(args[0], args[1])\n\nclass Mixed:\n\n    def mixed(self, first, second, *, third, fourth):\n        pass\n\n\nclass MixedChild1(Mixed):\n\n    def mixed(self, first, *args, **kwargs):\n        \"\"\"\n        Acceptable use of vararg in subclass because it does not violate LSP.\n        \"\"\"\n        super().mixed(first, *args, **kwargs)\n\n\nclass MixedChild2(Mixed):\n\n    def mixed(self, first, *args, third, **kwargs):\n        \"\"\"\n        Acceptable use of vararg in subclass because it does not violate LSP.\n        \"\"\"\n        super().mixed(first"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "unittest_typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Final\", \"Literal\":\n            self.typing_objects_are_subscriptable(generic)\n\n        self.getitem_on_modules()\n        self.decorated_by_a_subscriptable_class(decorators)\n        self.decorated_by_an_unsubscriptable_class(decorators)\n\n        self.decorated_by_subscriptable_then_unsubscriptable_class(decorators)\n        self.decorated_by_unsubscriptable_then_subscriptable_class(decorators)\n\n    def getitem_on_modules(self) -> None:\n        \"\"\"Mainly validate the code won't crash if we're not having a function.\"\"\"\n        module = astroid.parse(\n            \"\"\"\n        import collections\n        test = collections[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertAddsMessages(\n            MessageTest(\n                \"unsubscriptable-object\",\n                node=subscript.value,\n                args=\"collections\",\n                confidence=UNDEFINED,\n                line=3,\n                col_offset=7,\n                end_line=3,\n                end_col_offset=18,\n            )\n        ):\n            self.checker.visit_subscript(subscript)\n\n    def typing_objects_are_subscriptable(self, generic: str) -> None:\n        module = astroid.parse(\n            f\"\"\"\n        import typing\n        test = typing.{generic}[int]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_a_subscriptable_class(self, decorators: str) -> None:\n        module = astroid.parse(\n            decorators\n            + \"\"\"\n        @Subscriptable\n        def decorated():\n            ...\n\n        test = decorated[None]\n        \"\"\"\n        )\n        subscript = module.body[-1].value\n        with self.assertNoMessages():\n            self.checker.visit_subscript(subscript)\n\n    def decorated_by_subscriptable_then_unsubscriptable_class(\n        self, decorators: str\n    ) -> None:\n        module = astroid.parse(\n            decorators\n "}, {"start_line": 57000, "end_line": 59000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ction_node.type),\n                node=function_node,\n            )\n        elif not parent_is_property and current_is_property:\n            self.add_message(\n                \"invalid-overridden-method\",\n                args=(function_node.name, \"method\", \"property\"),\n                node=function_node,\n            )\n\n        parent_is_async = isinstance(parent_function_node, nodes.AsyncFunctionDef)\n        current_is_async = isinstance(function_node, nodes.AsyncFunctionDef)\n\n        if parent_is_async and not current_is_async:\n            self.add_message(\n                \"invalid-overridden-method\",\n                args=(function_node.name, \"async\", \"non-async\"),\n                node=function_node,\n            )\n\n        elif not parent_is_async and current_is_async:\n            self.add_message(\n                \"invalid-overridden-method\",\n                args=(function_node.name, \"non-async\", \"async\"),\n                node=function_node,\n            )\n        if (\n            decorated_with(parent_function_node, [\"typing.final\"])\n            or uninferable_final_decorators(parent_function_node.decorators)\n        ) and self._py38_plus:\n            self.add_message(\n                \"overridden-final-method\",\n                args=(function_node.name, parent_function_node.parent.frame().name),\n                node=function_node,\n            )\n\n    def _check_functools_or_not(self, decorator: nodes.Attribute) -> bool:\n        if decorator.attrname != \"cached_property\":\n            return False\n\n        if not isinstance(decorator.expr, nodes.Name):\n            return False\n\n        _, import_nodes = decorator.expr.lookup(decorator.expr.name)\n\n        if not import_nodes:\n            return False\n        import_node = import_nodes[0]\n\n        if not isinstance(import_node, (astroid.Import, astroid.ImportFrom)):\n            return False\n\n        return \"functools\" in dict(import_node.names)\n\n    def _has_valid_slots(self, node: nodes.ClassDef) -> bool:\n        if \"__s"}, {"start_line": 55000, "end_line": 57000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                   (arguments.posonlyargs_annotations or []), arguments.annotations\n                )\n                return [ann.as_string() for ann in annotations if ann is not None]\n\n            called_annotations = form_annotations(function.args)\n            overridden_annotations = form_annotations(meth_node.args)\n            if called_annotations and overridden_annotations:\n                if called_annotations != overridden_annotations:\n                    return\n\n            if (\n                function.returns is not None\n                and meth_node.returns is not None\n                and meth_node.returns.as_string() != function.returns.as_string()\n            ):\n                # Override adds typing information to the return type\n                return\n\n        if _definition_equivalent_to_call(params, args):\n            self.add_message(\n                \"useless-parent-delegation\",\n                node=function,\n                args=(function.name,),\n                confidence=INFERENCE,\n            )\n\n    def _check_property_with_parameters(self, node: nodes.FunctionDef) -> None:\n        if (\n            len(node.args.arguments) > 1\n            and decorated_with_property(node)\n            and not is_property_setter(node)\n        ):\n            self.add_message(\"property-with-parameters\", node=node, confidence=HIGH)\n\n    def _check_invalid_overridden_method(\n        self,\n        function_node: nodes.FunctionDef,\n        parent_function_node: nodes.FunctionDef,\n    ) -> None:\n        parent_is_property = decorated_with_property(\n            parent_function_node\n        ) or is_property_setter_or_deleter(parent_function_node)\n        current_is_property = decorated_with_property(\n            function_node\n        ) or is_property_setter_or_deleter(function_node)\n        if parent_is_property and not current_is_property:\n            self.add_message(\n                \"invalid-overridden-method\",\n                args=(function_node.name, \"property\", fun"}], "retrieved_count": 10, "cost_time": 0.3471083641052246}
{"question": "Where does the control flow in the method that checks ellipsis constants branch differently when the grandparent node is a class definition versus a function definition?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 2024, "belongs_to": {"file_name": "ellipsis_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " }\n\n    @only_required_for_messages(\"unnecessary-ellipsis\")\n    def visit_const(self, node: nodes.Const) -> None:\n        \"\"\"Check if the ellipsis constant is used unnecessarily.\n\n        Emits a warning when:\n         - A line consisting of an ellipsis is preceded by a docstring.\n         - A statement exists in the same scope as the ellipsis.\n           For example: A function consisting of an ellipsis followed by a\n           return statement on the next line.\n        \"\"\"\n        if (\n            node.pytype() == \"builtins.Ellipsis\"\n            and isinstance(node.parent, nodes.Expr)\n            and (\n                (\n                    isinstance(node.parent.parent, (nodes.ClassDef, nodes.FunctionDef))\n                    and node.parent.parent.doc_node\n                )\n                or len(node.parent.parent.body) > 1\n            )\n        ):\n            self.add_message(\"unnecessary-ellipsis\", node=node)\n\n\ndef register(linter: PyLinter) -> None:\n    linter.register_checker(EllipsisChecker(linter))\n"}, {"start_line": 90000, "end_line": 92000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_parent := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n     "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base/name_checker", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                   node,\n                        )\n                        return\n                    if self._assigns_typealias(assigner):\n                        self._check_name(\n                            \"typealias\",\n                            assign_type.targets[0]\n                            .elts[node.parent.elts.index(node)]\n                            .name,\n                            node,\n                        )\n                        return\n\n                # Check classes (TypeVar's are classes so they need to be excluded first)\n                elif isinstance(inferred_assign_type, nodes.ClassDef):\n                    self._check_name(\"class\", node.name, node)\n\n                elif inferred_assign_type in (None, astroid.util.Uninferable):\n                    return\n\n                # Don't emit if the name redefines an import in an ImportError except handler\n                # nor any other reassignment.\n                elif (\n                    not (redefines_import := _redefines_import(node))\n                    and not isinstance(\n                        inferred_assign_type, (nodes.FunctionDef, nodes.Lambda)\n                    )\n                    and not utils.is_reassigned_before_current(node, node.name)\n                    and not utils.is_reassigned_after_current(node, node.name)\n                    and not utils.get_node_first_ancestor_of_type(\n                        node, (nodes.For, nodes.While)\n                    )\n                ):\n                    if not self._meets_exception_for_non_consts(\n                        inferred_assign_type, node.name\n                    ):\n                        self._check_name(\"const\", node.name, node)\n                else:\n                    node_type = \"variable\"\n                    if (\n                        (iattrs := tuple(node.frame().igetattr(node.name)))\n                        and astroid.util.Uninferable not in iattrs\n                        and len(iattrs) == 2\n                 "}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "test, (nodes.Const, *structs, *const_nodes))\n        maybe_generator_call = None\n        if not isinstance(test, except_nodes):\n            inferred = utils.safe_infer(test)\n            if isinstance(inferred, util.UninferableBase) and isinstance(\n                test, nodes.Name\n            ):\n                emit, maybe_generator_call = BasicChecker._name_holds_generator(test)\n\n        # Emit if calling a function that only returns GeneratorExp (always tests True)\n        elif isinstance(test, nodes.Call):\n            maybe_generator_call = test\n        if maybe_generator_call:\n            inferred_call = utils.safe_infer(maybe_generator_call.func)\n            if isinstance(inferred_call, nodes.FunctionDef):\n                # Can't use all(x) or not any(not x) for this condition, because it\n                # will return True for empty generators, which is not what we want.\n                all_returns_were_generator = None\n                for return_node in inferred_call._get_return_nodes_skip_functions():\n                    if not isinstance(return_node.value, nodes.GeneratorExp):\n                        all_returns_were_generator = False\n                        break\n                    all_returns_were_generator = True\n                if all_returns_were_generator:\n                    self.add_message(\n                        \"using-constant-test\", node=node, confidence=INFERENCE\n                    )\n                    return\n\n        if emit:\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n        elif isinstance(inferred, const_nodes):\n            # If the constant node is a FunctionDef or Lambda then\n            # it may be an illicit function call due to missing parentheses\n            call_inferred = None\n            try:\n                # Just forcing the generator to infer all elements.\n                # astroid.exceptions.InferenceError are false positives\n                # see https://github.com/pylint-dev/pylint/"}, {"start_line": 91000, "end_line": 93000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t := next(defframe.node_ancestors()))\n                    and isinstance(defframe_parent, nodes.Module)\n                    # frame is the function inside the class.\n                    and (frame_ancestors := tuple(frame.node_ancestors()))\n                    # Does that function have any functions as ancestors?\n                    and any(\n                        isinstance(ancestor, nodes.FunctionDef)\n                        for ancestor in frame_ancestors\n                    )\n                    # And is its last ancestor the same module as the class's?\n                    and frame_ancestors[-1] is defframe_parent\n                ):\n                    annotation_return = True\n                    maybe_before_assign = False\n            if isinstance(node.parent, nodes.Arguments):\n                maybe_before_assign = stmt.fromlineno <= defstmt.fromlineno\n        elif is_recursive_klass:\n            maybe_before_assign = True\n        else:\n            maybe_before_assign = (\n                maybe_before_assign and stmt.fromlineno <= defstmt.fromlineno\n            )\n            if maybe_before_assign and stmt.fromlineno == defstmt.fromlineno:\n                if (\n                    isinstance(defframe, nodes.FunctionDef)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and (\n                        defnode in defframe.type_params\n                        # Single statement function, with the statement on the\n                        # same line as the function definition\n                        or stmt is not defstmt\n                    )\n                ):\n                    maybe_before_assign = False\n                elif (\n                    isinstance(defstmt, NODES_WITH_VALUE_ATTR)\n                    and VariablesChecker._maybe_used_and_assigned_at_once(defstmt)\n                    and frame is defframe\n                    and defframe.parent_of(node)\n                    and stmt is defstmt\n   "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r, nodes.Call):\n            name = \"\"\n            if isinstance(expr.func, nodes.Name):\n                name = expr.func.name\n            elif isinstance(expr.func, nodes.Attribute):\n                name = expr.func.attrname\n\n            # Heuristic: only run inference for names that begin with an uppercase char\n            # This reduces W0133's coverage, but retains acceptable runtime performance\n            # For more details, see: https://github.com/pylint-dev/pylint/issues/8073\n            inferred = utils.safe_infer(expr) if name[:1].isupper() else None\n            if isinstance(inferred, objects.ExceptionInstance):\n                self.add_message(\n                    \"pointless-exception-statement\", node=node, confidence=INFERENCE\n                )\n            return\n\n        # Ignore if this is :\n        # * the unique child of a try/except body\n        # * a yield statement\n        # * an ellipsis (which can be used on Python 3 instead of pass)\n        # warn W0106 if we have any underlying function call (we can't predict\n        # side effects), else pointless-statement\n        if (\n            isinstance(expr, (nodes.Yield, nodes.Await))\n            or (\n                isinstance(node.parent, (nodes.Try, nodes.TryStar))\n                and node.parent.body == [node]\n            )\n            or (isinstance(expr, nodes.Const) and expr.value is Ellipsis)\n        ):\n            return\n        if isinstance(expr, nodes.NamedExpr):\n            self.add_message(\"named-expr-without-context\", node=node, confidence=HIGH)\n        elif any(expr.nodes_of_class(nodes.Call)):\n            self.add_message(\n                \"expression-not-assigned\", node=node, args=expr.as_string()\n            )\n        else:\n            self.add_message(\"pointless-statement\", node=node)\n\n    @staticmethod\n    def _filter_vararg(\n        node: nodes.Lambda, call_args: list[nodes.NodeNG]\n    ) -> Iterator[nodes.NodeNG]:\n        # Return the arguments for the given call which are\n       "}, {"start_line": 89000, "end_line": 91000, "belongs_to": {"file_name": "variables.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n            #\n            # bar = None\n            # foo = lambda bar=bar: bar\n            #\n            # In this case, maybe_before_assign should be False, otherwise\n            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n            frame, nodes.FunctionDef\n        ):\n            # Special rules for function return annotations.\n            if node is frame.returns:\n                # Using a name defined earlier in the class containing the function.\n                if defframe.parent_of(frame.returns):\n                    annotation_return = True\n                    if frame.returns.name in defframe.locals:\n                        definition = defframe.locals[node.name][0]\n                        # no warning raised if a name was defined earlier in the class\n                        maybe_before_assign = (\n                            definition.lineno is not None\n                            and definition.lineno >= frame.lineno\n                        )\n                    else:\n                        maybe_before_assign = True\n                # Using a name defined in the module if this is a nested function.\n                elif (\n                    # defframe is the class containing the function.\n                    # It shouldn't be nested: expect its parent to be a module.\n                    (defframe_paren"}, {"start_line": 65000, "end_line": 67000, "belongs_to": {"file_name": "utils.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "de.body[0].value, nodes.Const)\n        and node.body[0].value.value == Ellipsis\n    )\n\n\ndef is_base_container(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.BaseContainer) and not node.elts\n\n\ndef is_empty_dict_literal(node: nodes.NodeNG | None) -> bool:\n    return isinstance(node, nodes.Dict) and not node.items\n\n\ndef is_empty_str_literal(node: nodes.NodeNG | None) -> bool:\n    return (\n        isinstance(node, nodes.Const) and isinstance(node.value, str) and not node.value\n    )\n\n\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n        and isinstance(node.value.value, bool)\n    )\n\n\ndef assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Assign)\n        and isinstance(node.value, nodes.Const)\n        and isinstance(node.value.value, bool)\n    )\n\n\ndef get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:\n    \"\"\"Return the first parent node that is any of the provided types (or None).\"\"\"\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return ancestor  # type: ignore[no-any-return]\n    return None\n\n\ndef get_node_first_ancestor_of_type_and_its_child(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> tuple[None, None] | tuple[_NodeT, nodes.NodeNG]:\n    \"\"\"Modified version of get_node_first_ancestor_of_type to also return the\n    descendant visited directly before reaching the sought ancestor.\n\n    Useful for extracting whether a statement is guarded by a try, except, or finally\n    when searching for a Try ancestor.\n    \"\"\"\n    child = node\n    for ancestor in node.node_ancestors():\n       "}, {"start_line": 21000, "end_line": 22739, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".parent.test.op == \"not\"\n                    and isinstance(node.parent.test.operand, nodes.Name)\n                    and node.parent.test.operand.name == node.name\n                ):\n                    return\n\n                # Exempt \"if <func> is not None\" cases\n                # pylint: disable=too-many-boolean-expressions\n                if (\n                    isinstance(node.parent.test, nodes.Compare)\n                    and isinstance(node.parent.test.left, nodes.Name)\n                    and node.parent.test.left.name == node.name\n                    and node.parent.test.ops[0][0] == \"is\"\n                    and isinstance(node.parent.test.ops[0][1], nodes.Const)\n                    and node.parent.test.ops[0][1].value is None\n                ):\n                    return\n\n            # Check if we have forward references for this node.\n            try:\n                redefinition_index = redefinitions.index(node)\n            except ValueError:\n                pass\n            else:\n                for redefinition in redefinitions[:redefinition_index]:\n                    inferred = utils.safe_infer(redefinition)\n                    if (\n                        inferred\n                        and isinstance(inferred, astroid.Instance)\n                        and inferred.qname() == TYPING_FORWARD_REF_QNAME\n                    ):\n                        return\n\n            dummy_variables_rgx = self.linter.config.dummy_variables_rgx\n            if dummy_variables_rgx and dummy_variables_rgx.match(node.name):\n                return\n            self.add_message(\n                \"function-redefined\",\n                node=node,\n                args=(redeftype, defined_self.fromlineno),\n            )\n"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "typecheck.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " astroid.NotFoundError:\n            return True\n\n    # Don't emit no-member if guarded behind `IF` or `IFExp`\n    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n            if (  # pylint: disable=too-many-boolean-expressions\n                isinstance(inferred, nodes.Const)\n                and inferred.bool_value() is False\n                and (\n                    (isinstance(parent, nodes.If) and node_origin in parent.body)\n                    or (isinstance(parent, nodes.IfExp) and node_origin == parent.body)\n                )\n            ):\n                return False\n        node_origin, parent = parent, parent.parent\n\n    return True\n\n\ndef _get_all_attribute_assignments(\n    node: nodes.FunctionDef, name: str | None = None\n) -> set[str]:\n    attributes: set[str] = set()\n    for child in node.nodes_of_class((nodes.Assign, nodes.AnnAssign)):\n        targets = []\n        if isinstance(child, nodes.Assign):\n            targets = child.targets\n        elif isinstance(child, nodes.AnnAssign):\n            targets = [child.target]\n        for assign_target in targets:\n            if isinstance(assign_target, nodes.Tuple):\n                targets.extend(assign_target.elts)\n                continue\n            if (\n                isinstance(assign_target, nodes.AssignAttr)\n                and isinstance(assign_target.expr, nodes.Name)\n                and (name is None or assign_target.expr.name == name)\n            ):\n                attributes.add(assign_target.attrname)\n    return attributes\n\n\ndef _enum_has_a"}], "retrieved_count": 10, "cost_time": 0.36326122283935547}
{"question": "What control path determines whether the docstring of a class definition node is accessible to the docstring checking mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(\n                is_property_setter(node)\n                or is_property_deleter(node)\n                or is_overload_stub(node)\n            ):\n                return\n\n            if isinstance(node.parent.frame(), nodes.ClassDef):\n                overridden = False\n                confidence = (\n                    interfaces.INFERENCE\n                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n                    if node.name in ancestor and isinstance(\n                        ancestor[node.name], nodes.FunctionDef\n                    ):\n                        overridden = True\n                        break\n                self._check_docstring(\n                    ftype, node, report_missing=not overridden, confidence=confidence  # type: ignore[arg-type]\n                )\n            elif isinstance(node.parent.frame(), nodes.Module):\n                self._check_docstring(ftype, node)  # type: ignore[arg-type]\n            else:\n                return\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_docstring(\n        self,\n        node_type: Literal[\"class\", \"function\", \"method\", \"module\"],\n        node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n\n        if docstring is None:\n            if not report_missing:\n                return\n            lines = utils.get_node_last_lineno(node) - node.lineno\n\n         "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ode, report_missing=not overridden, confidence=confidence  # type: ignore[arg-type]\n                )\n            elif isinstance(node.parent.frame(), nodes.Module):\n                self._check_docstring(ftype, node)  # type: ignore[arg-type]\n            else:\n                return\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_docstring(\n        self,\n        node_type: Literal[\"class\", \"function\", \"method\", \"module\"],\n        node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n\n        if docstring is None:\n            if not report_missing:\n                return\n            lines = utils.get_node_last_lineno(node) - node.lineno\n\n            if node_type == \"module\" and not lines:\n                # If the module does not have a body, there's no reason\n                # to require a docstring.\n                return\n            max_lines = self.linter.config.docstring_min_length\n\n            if node_type != \"module\" and max_lines > -1 and lines < max_lines:\n                return\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            if (\n                node.body\n                and isinstance(node.body[0], nodes.Expr)\n                and isinstance(node.body[0].value, nodes.Call)\n            ):\n                # Most likely a string with a format call. Let's see.\n                func = utils.safe_infer(node.body[0].value.func)\n                if isinstance(func, astroid.BoundMethod) and isinstance(\n                    func.bound, astroid.Instance\n                ):\n                    "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "um line length for functions/classes that\"\n                    \" require docstrings, shorter ones are exempt.\"\n                ),\n            },\n        ),\n    )\n\n    def open(self) -> None:\n        self.linter.stats.reset_undocumented()\n\n    @utils.only_required_for_messages(\"missing-module-docstring\", \"empty-docstring\")\n    def visit_module(self, node: nodes.Module) -> None:\n        self._check_docstring(\"module\", node)\n\n    @utils.only_required_for_messages(\"missing-class-docstring\", \"empty-docstring\")\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            self._check_docstring(\"class\", node)\n\n    @utils.only_required_for_messages(\"missing-function-docstring\", \"empty-docstring\")\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            ftype = \"method\" if node.is_method() else \"function\"\n            if (\n                is_property_setter(node)\n                or is_property_deleter(node)\n                or is_overload_stub(node)\n            ):\n                return\n\n            if isinstance(node.parent.frame(), nodes.ClassDef):\n                overridden = False\n                confidence = (\n                    interfaces.INFERENCE\n                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n                    if node.name in ancestor and isinstance(\n                        ancestor[node.name], nodes.FunctionDef\n                    ):\n                        overridden = True\n                        break\n                self._check_docstring(\n                    ftype, n"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r\",\n        \"attribute-defined-outside-init\",\n        \"access-member-before-definition\",\n    )\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Checker for Class nodes.\n\n        check that instance attributes are defined in __init__ and check\n        access to existent members\n        \"\"\"\n        self._check_unused_private_functions(node)\n        self._check_unused_private_variables(node)\n        self._check_unused_private_attributes(node)\n        self._check_attribute_defined_outside_init(node)\n\n    def _check_unused_private_functions(self, node: nodes.ClassDef) -> None:\n        for function_def in node.nodes_of_class(nodes.FunctionDef):\n            if not is_attr_private(function_def.name):\n                continue\n            parent_scope = function_def.parent.scope()\n            if isinstance(parent_scope, nodes.FunctionDef):\n                # Handle nested functions\n                if function_def.name in (\n                    n.name for n in parent_scope.nodes_of_class(nodes.Name)\n                ):\n                    continue\n            for child in node.nodes_of_class((nodes.Name, nodes.Attribute)):\n                # Check for cases where the functions are used as a variable instead of as a\n                # method call\n                if isinstance(child, nodes.Name) and child.name == function_def.name:\n                    break\n                if isinstance(child, nodes.Attribute):\n                    # Ignore recursive calls\n                    if (\n                        child.attrname != function_def.name\n                        or child.scope() == function_def\n                    ):\n                        continue\n\n                    # Check self.__attrname, cls.__attrname, node_name.__attrname\n                    if isinstance(child.expr, nodes.Name) and child.expr.name in {\n                        \"self\",\n                        \"cls\",\n                        node.name,\n                    }:\n                        break\n\n"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "elf, node: _AccessNodes) -> None:\n        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n            return\n        self._scopes[frame][node.attrname].append(node)\n\n    def accessed(self, scope: nodes.ClassDef) -> dict[str, list[_AccessNodes]]:\n        \"\"\"Get the accessed variables for the given scope.\"\"\"\n        return self._scopes.get(scope, {})\n\n\nclass ClassChecker(BaseChecker):\n    \"\"\"Checker for class nodes.\n\n    Checks for :\n    * methods without self as first argument\n    * overridden methods signature\n    * access only to existent members via self\n    * attributes not defined in the __init__ method\n    * unreachable code\n    \"\"\"\n\n    # configuration section name\n    name = \"classes\"\n    # messages\n    msgs = MSGS\n    # configuration options\n    options = (\n        (\n            \"defining-attr-methods\",\n            {\n                \"default\": (\n                    \"__init__\",\n                    \"__new__\",\n                    \"setUp\",\n                    \"asyncSetUp\",\n                    \"__post_init__\",\n                ),\n                \"type\": \"csv\",\n                \"metavar\": \"<method names>\",\n                \"help\": \"List of method names used to declare (i.e. assign) \\\ninstance attributes.\",\n            },\n        ),\n        (\n            \"valid-classmethod-first-arg\",\n            {\n                \"default\": (\"cls\",),\n                \"type\": \"csv\",\n                \"metavar\": \"<argument names>\",\n                \"help\": \"List of valid names for the first argument in \\\na class method.\",\n            },\n        ),\n        (\n            \"valid-metaclass-classmethod-first-arg\",\n            {\n                \"default\": (\"mcs\",),\n                \"type\": \"csv\",\n                \"metavar\": \"<argument names>\",\n                \"help\": \"List of valid names for the first argument in \\\na metaclass class method.\",\n            },\n        ),\n        (\n            \"excl"}, {"start_line": 6000, "end_line": 7786, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   if node_type == \"module\" and not lines:\n                # If the module does not have a body, there's no reason\n                # to require a docstring.\n                return\n            max_lines = self.linter.config.docstring_min_length\n\n            if node_type != \"module\" and max_lines > -1 and lines < max_lines:\n                return\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            if (\n                node.body\n                and isinstance(node.body[0], nodes.Expr)\n                and isinstance(node.body[0].value, nodes.Call)\n            ):\n                # Most likely a string with a format call. Let's see.\n                func = utils.safe_infer(node.body[0].value.func)\n                if isinstance(func, astroid.BoundMethod) and isinstance(\n                    func.bound, astroid.Instance\n                ):\n                    # Strings.\n                    if func.bound.name in {\"str\", \"unicode\", \"bytes\"}:\n                        return\n            if node_type == \"module\":\n                message = \"missing-module-docstring\"\n            elif node_type == \"class\":\n                message = \"missing-class-docstring\"\n            else:\n                message = \"missing-function-docstring\"\n            self.add_message(message, node=node, confidence=confidence)\n        elif not docstring.strip():\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            self.add_message(\n                \"empty-docstring\", node=node, args=(node_type,), confidence=confidence\n            )\n"}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "class_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/classes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "um_base(node, ancestor)\n\n            if ancestor.name == object.__name__:\n                self.add_message(\n                    \"useless-object-inheritance\", args=node.name, node=node\n                )\n\n    def _check_typing_final(self, node: nodes.ClassDef) -> None:\n        \"\"\"Detect that a class does not subclass a class decorated with\n        `typing.final`.\n        \"\"\"\n        if not self._py38_plus:\n            return\n        for base in node.bases:\n            ancestor = safe_infer(base)\n            if not ancestor:\n                continue\n\n            if isinstance(ancestor, nodes.ClassDef) and (\n                decorated_with(ancestor, [\"typing.final\"])\n                or uninferable_final_decorators(ancestor.decorators)\n            ):\n                self.add_message(\n                    \"subclassed-final-class\",\n                    args=(node.name, ancestor.name),\n                    node=node,\n                )\n\n    @only_required_for_messages(\n        \"unused-private-member\",\n        \"attribute-defined-outside-init\",\n        \"access-member-before-definition\",\n    )\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Checker for Class nodes.\n\n        check that instance attributes are defined in __init__ and check\n        access to existent members\n        \"\"\"\n        self._check_unused_private_functions(node)\n        self._check_unused_private_variables(node)\n        self._check_unused_private_attributes(node)\n        self._check_attribute_defined_outside_init(node)\n\n    def _check_unused_private_functions(self, node: nodes.ClassDef) -> None:\n        for function_def in node.nodes_of_class(nodes.FunctionDef):\n            if not is_attr_private(function_def.name):\n                continue\n            parent_scope = function_def.parent.scope()\n            if isinstance(parent_scope, nodes.FunctionDef):\n                # Handle nested functions\n                if function_def.name in (\n                    n.name for n in parent_scope.nod"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n        \"C0116\": (\n            \"Missing function or method docstring\",\n            \"missing-function-docstring\",\n            \"Used when a function or method has no docstring. \"\n            \"Some special methods like __init__ do not require a \"\n            \"docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n    }\n    options = (\n        (\n            \"no-docstring-rgx\",\n            {\n                \"default\": NO_REQUIRED_DOC_RGX,\n                \"type\": \"regexp\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"Regular expression which should only match \"\n                \"function or class names that do not require a \"\n                \"docstring.\",\n            },\n        ),\n        (\n            \"docstring-min-length\",\n            {\n                \"default\": -1,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": (\n                    \"Minimum line length for functions/classes that\"\n                    \" require docstrings, shorter ones are exempt.\"\n                ),\n            },\n        ),\n    )\n\n    def open(self) -> None:\n        self.linter.stats.reset_undocumented()\n\n    @utils.only_required_for_messages(\"missing-module-docstring\", \"empty-docstring\")\n    def visit_module(self, node: nodes.Module) -> None:\n        self._check_docstring(\"module\", node)\n\n    @utils.only_required_for_messages(\"missing-class-docstring\", \"empty-docstring\")\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            self._check_docstring(\"class\", node)\n\n    @utils.only_required_for_messages(\"missing-function-docstring\", \"empty-docstring\")\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            ftype = \"method\" if node.is_method() else \"function\"\n            if "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "docstring_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "safe_infer(docstring)\n    if not docstring:\n        return None\n    if not isinstance(docstring, nodes.Const):\n        return None\n    return str(docstring.value)\n\n\nclass DocStringChecker(_BasicChecker):\n    msgs = {\n        \"C0112\": (\n            \"Empty %s docstring\",\n            \"empty-docstring\",\n            \"Used when a module, function, class or method has an empty \"\n            \"docstring (it would be too easy ;).\",\n            {\"old_names\": [(\"W0132\", \"old-empty-docstring\")]},\n        ),\n        \"C0114\": (\n            \"Missing module docstring\",\n            \"missing-module-docstring\",\n            \"Used when a module has no docstring. \"\n            \"Empty modules do not require a docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n        \"C0115\": (\n            \"Missing class docstring\",\n            \"missing-class-docstring\",\n            \"Used when a class has no docstring. \"\n            \"Even an empty class must have a docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n        \"C0116\": (\n            \"Missing function or method docstring\",\n            \"missing-function-docstring\",\n            \"Used when a function or method has no docstring. \"\n            \"Some special methods like __init__ do not require a \"\n            \"docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n    }\n    options = (\n        (\n            \"no-docstring-rgx\",\n            {\n                \"default\": NO_REQUIRED_DOC_RGX,\n                \"type\": \"regexp\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"Regular expression which should only match \"\n                \"function or class names that do not require a \"\n                \"docstring.\",\n            },\n        ),\n        (\n            \"docstring-min-length\",\n            {\n                \"default\": -1,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": (\n                    \"Minim"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "basic_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tor_call = lookup_result[1][0].parent.value\n        return emit, maybe_generator_call\n\n    def visit_module(self, _: nodes.Module) -> None:\n        \"\"\"Check module name, docstring and required arguments.\"\"\"\n        self.linter.stats.node_count[\"module\"] += 1\n\n    def visit_classdef(self, _: nodes.ClassDef) -> None:\n        \"\"\"Check module name, docstring and redefinition\n        increment branch counter.\n        \"\"\"\n        self.linter.stats.node_count[\"klass\"] += 1\n\n    @utils.only_required_for_messages(\n        \"pointless-statement\",\n        \"pointless-exception-statement\",\n        \"pointless-string-statement\",\n        \"expression-not-assigned\",\n        \"named-expr-without-context\",\n    )\n    def visit_expr(self, node: nodes.Expr) -> None:\n        \"\"\"Check for various kind of statements without effect.\"\"\"\n        expr = node.value\n        if isinstance(expr, nodes.Const) and isinstance(expr.value, str):\n            # treat string statement in a separated message\n            # Handle PEP-257 attribute docstrings.\n            # An attribute docstring is defined as being a string right after\n            # an assignment at the module level, class level or __init__ level.\n            scope = expr.scope()\n            if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):\n                if isinstance(scope, nodes.FunctionDef) and scope.name != \"__init__\":\n                    pass\n                else:\n                    sibling = expr.previous_sibling()\n                    if (\n                        sibling is not None\n                        and sibling.scope() is scope\n                        and isinstance(\n                            sibling, (nodes.Assign, nodes.AnnAssign, nodes.TypeAlias)\n                        )\n                    ):\n                        return\n            self.add_message(\"pointless-string-statement\", node=node)\n            return\n\n        # Warn W0133 for exceptions that are used as statements\n        if isinstance(exp"}], "retrieved_count": 10, "cost_time": 0.5575094223022461}
{"question": "Where are the linting functions that invoke docstring parameter checking logic to detect missing type annotations for parameters without type hints?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n            params_with_type,\n            \"useless-type-doc\",\n            expected_but_ignored_argument_names,\n            warning_node,\n        )\n        params_with_type |= utils.args_with_annotation(arguments_node)\n\n        if not tolerate_missing_params:\n            missing_param_doc = (expected_argument_names - params_with_doc) - (\n                self.not_needed_param_in_docstring | expected_but_ignored_argument_names\n            )\n            missing_type_doc = (expected_argument_names - params_with_type) - (\n                not_needed_type_in_docstring | expected_but_ignored_argument_names\n            )\n            if (\n                missing_param_doc == expected_argument_names == missing_type_doc\n                and len(expected_argument_names) != 0\n            ):\n                self.add_message(\n                    \"missing-any-param-doc\",\n                    args=(warning_node.name,),\n                    node=warning_node,\n                    confidence=HIGH,\n                )\n            else:\n                self._compare_missing_args(\n                    params_with_doc,\n                    \"missing-param-doc\",\n                    self.not_needed_param_in_docstring\n                    | expected_but_ignored_argument_names,\n                    expected_argument_names,\n                    warning_node,\n                )\n                self._compare_missing_args(\n                    params_with_type,\n                    \"missing-type-doc\",\n                    not_needed_type_in_docstring | expected_but_ignored_argument_names,\n                    expected_argument_names,\n                    warning_node,\n                "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "missing_param_doc_required_Google.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-param-doc and missing-type-doc for Google style docstrings\nwith accept-no-param-doc = no\n\nStyleguide:\nhttps://google.github.io/styleguide/pyguide.html#doc-function-args\n\"\"\"\n\n# pylint: disable=invalid-name, unused-argument, undefined-variable\n# pylint: disable=line-too-long, too-few-public-methods, missing-class-docstring\n# pylint: disable=missing-function-docstring, function-redefined, inconsistent-return-statements\n# pylint: disable=dangerous-default-value, too-many-arguments\n\nfrom __future__ import annotations\n\n\ndef test_multi_line_parameters(param: int) -> None:\n    \"\"\"Checks that multi line parameters lists are checked correctly\n    See https://github.com/pylint-dev/pylint/issues/5452\n\n    Args:\n        param:\n            a description\n    \"\"\"\n    print(param)\n\n\ndef test_missing_func_params_in_google_docstring(  # [missing-param-doc, missing-type-doc]\n    x, y, z\n):\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring\n\n    Args:\n        x: bla\n        z (int): bar\n\n    some other stuff\n    \"\"\"\n\n\ndef test_missing_func_params_with_annotations_in_google_docstring(x: int, y: bool, z):\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n\n        Args:\n            x: bla\n            y: blah blah\n            z (int): bar\n\n        some other stuff\n    \"\"\"\n\n\ndef test_missing_type_doc_google_docstring_exempt_kwonly_args(\n    arg1: int, arg2: int, *, value1: str, value2: str\n):\n    \"\"\"Code to show failure in missing-type-doc\n\n    Args:\n        arg1: First argument.\n        arg2: Second argument.\n        value1: First kwarg.\n        value2: Second kwarg.\n    \"\"\"\n    print(\"NOTE: It doesn't like anything after the '*'.\")\n\n\ndef test_default_arg_with_annotations_in_google_docstring(\n    x: int, y: bool, z: int = 786\n):\n    \"\"\"Example of a function with missing Google style parameter\n        documentation in the docstring.\n\n    Args:\n        x: bla\n        y: bla"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 'type').\n\n        * Undocumented parameters except 'self' are noticed.\n        * Undocumented parameter types except for 'self' and the ``*<args>``\n          and ``**<kwargs>`` parameters are noticed.\n        * Parameters mentioned in the parameter documentation that don't or no\n          longer exist in the function parameter list are noticed.\n        * If the text \"For the parameters, see\" or \"For the other parameters,\n          see\" (ignoring additional white-space) is mentioned in the docstring,\n          missing parameter documentation is tolerated.\n        * If there's no Sphinx style, Google style or NumPy style parameter\n          documentation at all, i.e. ``:param`` is never mentioned etc., the\n          checker assumes that the parameters are documented in another format\n          and the absence is tolerated.\n\n        :param doc: Docstring for the function, method or class.\n        :type doc: :class:`Docstring`\n\n        :param arguments_node: Arguments node for the function, method or\n            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n        :param warning_node: The node to assign the warnings to\n        :type warning_node: :class:`astroid.scoped_nodes.Node`\n\n        :param accept_no_param_doc: Whether to allow no parameters to be\n            documented. If None then this value is read from the configuration.\n        :type accept_no_param_doc: bool or None\n        \"\"\"\n        # Tolerate missing param or type declarations if there is a link to\n        # another method carrying the same name.\n        if not doc.doc:\n            return\n\n        if accept_no_param_doc is None:\n            accept_no_param_doc = self.linter.config.accept_no_param_doc\n        tolerate_missing_params = doc.params_documented_elsewhere()\n\n        # Collect the function arguments.\n        expected_argument_names = {arg.name for arg in arguments_node.args}\n        expected_argument_names.update(\n            a.name for a in argumen"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ts_node.posonlyargs + arguments_node.kwonlyargs\n        )\n        not_needed_type_in_docstring = self.not_needed_param_in_docstring.copy()\n\n        expected_but_ignored_argument_names = set()\n        ignored_argument_names = self.linter.config.ignored_argument_names\n        if ignored_argument_names:\n            expected_but_ignored_argument_names = {\n                arg\n                for arg in expected_argument_names\n                if ignored_argument_names.match(arg)\n            }\n\n        if arguments_node.vararg is not None:\n            expected_argument_names.add(f\"*{arguments_node.vararg}\")\n            not_needed_type_in_docstring.add(f\"*{arguments_node.vararg}\")\n        if arguments_node.kwarg is not None:\n            expected_argument_names.add(f\"**{arguments_node.kwarg}\")\n            not_needed_type_in_docstring.add(f\"**{arguments_node.kwarg}\")\n        params_with_doc, params_with_type = doc.match_param_docs()\n        # Tolerate no parameter documentation at all.\n        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n            params_with_type,\n            \"useless-type-doc\",\n            expected_but_ignored_argument_names,\n            warning_node,\n        )\n        params_with_type |= utils.args_with_annotation(arguments_node)\n\n        if not tolerate_missing_params:\n            missing_param_doc = (expected_argument_names - params_with_doc) - (\n                self.not_needed_param_in_docstring | expected_but_ignored_argument_names\n            )\n            missing_type_doc = (expected_argument_names - params_with_type) - (\n                not_needed_type_in_docstring | expected_but_ignored_argument_names\n            )\n            if (\n                missing_pa"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "missing_param_doc_required_Google.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing\n\n    Args:\n        x: bla\n        z (int): bar\n\n    some other stuff\n    \"\"\"\n\n\ndef test_missing_func_params_with_annotations_in_google_docstring(x: int, y: bool, z):\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n\n        Args:\n            x: bla\n            y: blah blah\n            z (int): bar\n\n        some other stuff\n    \"\"\"\n\n\ndef test_missing_type_doc_google_docstring_exempt_kwonly_args(\n    arg1: int, arg2: int, *, value1: str, value2: str\n):\n    \"\"\"Code to show failure in missing-type-doc\n\n    Args:\n        arg1: First argument.\n        arg2: Second argument.\n        value1: First kwarg.\n        value2: Second kwarg.\n    \"\"\"\n    print(\"NOTE: It doesn't like anything after the '*'.\")\n\n\ndef test_default_arg_with_annotations_in_google_docstring(\n    x: int, y: bool, z: int = 786\n):\n    \"\"\"Example of a function with missing Google style parameter\n        documentation in the docstring.\n\n    Args:\n        x: bla\n        y: blah blah\n        z: bar\n\n    some other stuff\n    \"\"\"\n\n\ndef test_missing_func_params_with_partial_annotations_in_google_docstring(  # [missing-type-doc]\n    x, y: bool, z\n):\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n\n    Args:\n        x: bla\n        y: blah blah\n        z (int): bar\n\n    some other stuff\n    \"\"\"\n\n\ndef test_non_builtin_annotations_in_google_docstring(\n    bottomleft: Point, topright: Point\n) -> float:\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n        Args:\n            bottomleft: bottom left point of rectangle\n            topright: top right point of rectangle\n    \"\"\"\n\n\ndef test_non_builtin_annotations_for_returntype_in_google_docstring(\n    bottomleft: Point, topright: Point\n) -> Point:\n    \"\"\"Example of a function with missing Google style parameter\n    documentation in the docstring.\n    Args:\n        bottomleft: bottom left point of rectangle\n        t"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Pylint plugin for checking in Sphinx, Google, or Numpy style docstrings.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import TYPE_CHECKING\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers import utils as checker_utils\nfrom pylint.extensions import _check_docs_utils as utils\nfrom pylint.extensions._check_docs_utils import Docstring\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\n\nclass DocstringParameterChecker(BaseChecker):\n    \"\"\"Checker for Sphinx, Google, or Numpy style docstrings.\n\n    * Check that all function, method and constructor parameters are mentioned\n      in the params and types part of the docstring.  Constructor parameters\n      can be documented in either the class docstring or ``__init__`` docstring,\n      but not both.\n    * Check that there are no naming inconsistencies between the signature and\n      the documentation, i.e. also report documented parameters that are missing\n      in the signature. This is important to find cases where parameters are\n      renamed only in the code, not in the documentation.\n    * Check that all explicitly raised exceptions in a function are documented\n      in the function docstring. Caught exceptions are ignored.\n\n    Activate this checker by adding the line::\n\n        load-plugins=pylint.extensions.docparams\n\n    to the ``MAIN`` section of your ``.pylintrc``.\n    \"\"\"\n\n    name = \"parameter_documentation\"\n    msgs = {\n        \"W9005\": (\n            '\"%s\" has constructor parameters documented in class and __init__',\n            \"multiple-constructor-doc\",\n            \"Please remove parameter declarations in the class or constructor.\",\n        ),\n        \"W9006\": (\n    "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "missing_param_doc_required_Sphinx.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Tests for missing-param-doc and missing-type-doc for Sphinx style docstrings\nwith accept-no-param-doc = no\"\"\"\n\n# pylint: disable=function-redefined, invalid-name, undefined-variable, missing-class-docstring\n# pylint: disable=unused-argument, too-few-public-methods, unnecessary-pass, line-too-long\n# pylint: disable=missing-function-docstring, disallowed-name\n\nfrom __future__ import annotations\n\n\ndef test_missing_func_params_in_sphinx_docstring(  # [missing-param-doc, missing-type-doc]\n    x, y, z\n):\n    \"\"\"Example of a function with missing Sphinx parameter documentation in\n    the docstring\n\n    :param x: bla\n\n    :param int z: bar\n    \"\"\"\n    pass\n\n\nclass Foo:\n    def test_missing_method_params_in_sphinx_docstring(  # [missing-param-doc, missing-type-doc]\n        self, x, y\n    ):\n        \"\"\"Example of a class method with missing parameter documentation in\n        the Sphinx style docstring\n\n        missing parameter documentation\n\n        :param x: bla\n        \"\"\"\n        pass\n\n\ndef test_existing_func_params_in_sphinx_docstring(xarg, yarg, zarg, warg):\n    \"\"\"Example of a function with correctly documented parameters and\n    return values (Sphinx style)\n\n    :param xarg: bla xarg\n    :type xarg: int\n\n    :parameter yarg: bla yarg\n    :type yarg: my.qualified.type\n\n    :arg int zarg: bla zarg\n\n    :keyword my.qualified.type warg: bla warg\n\n    :return: sum\n    :rtype: float\n    \"\"\"\n    return xarg + yarg\n\n\ndef test_wrong_name_of_func_params_in_sphinx_docstring(  # [missing-param-doc, missing-type-doc, differing-param-doc, differing-type-doc]\n    xarg, yarg, zarg\n):\n    \"\"\"Example of functions with inconsistent parameter names in the\n        signature and in the Sphinx style documentation\n\n    :param xarg1: bla xarg\n    :type xarg: int\n\n    :param yarg: bla yarg\n    :type yarg1: float\n\n    :param str zarg1: bla zarg\n    \"\"\"\n    return xarg + yarg\n\n\ndef test_wrong_name_of_func_params_in_sphinx_docstring_two(  # [differing-param-doc, differing-type-doc]\n    xarg, y"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "docparams.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/extensions", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ",\n            \"missing-type-doc\",\n            \"Please add parameter type declarations for all parameters.\",\n            {\"old_names\": [(\"W9004\", \"old-missing-type-doc\")]},\n        ),\n        \"W9017\": (\n            '\"%s\" differing in parameter documentation',\n            \"differing-param-doc\",\n            \"Please check parameter names in declarations.\",\n        ),\n        \"W9018\": (\n            '\"%s\" differing in parameter type documentation',\n            \"differing-type-doc\",\n            \"Please check parameter names in type declarations.\",\n        ),\n        \"W9019\": (\n            '\"%s\" useless ignored parameter documentation',\n            \"useless-param-doc\",\n            \"Please remove the ignored parameter documentation.\",\n        ),\n        \"W9020\": (\n            '\"%s\" useless ignored parameter type documentation',\n            \"useless-type-doc\",\n            \"Please remove the ignored parameter type documentation.\",\n        ),\n        \"W9021\": (\n            'Missing any documentation in \"%s\"',\n            \"missing-any-param-doc\",\n            \"Please add parameter and/or type documentation.\",\n        ),\n    }\n\n    options = (\n        (\n            \"accept-no-param-doc\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Whether to accept totally missing parameter \"\n                \"documentation in the docstring of a function that has \"\n                \"parameters.\",\n            },\n        ),\n        (\n            \"accept-no-raise-doc\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n                \"metavar\": \"<y or n>\",\n                \"help\": \"Whether to accept totally missing raises \"\n                \"documentation in the docstring of a function that \"\n                \"raises an exception.\",\n            },\n        ),\n        (\n            \"accept-no-return-doc\",\n            {\n                \"default\": True,\n                \"type\": \"yn\",\n    "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "missing_param_doc_required_Google.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " y):  # [missing-param-doc, missing-type-doc]\n        \"\"\"docstring foo\n\n        Args:\n            y: bla\n\n        missing constructor parameter documentation\n        \"\"\"\n\n\ndef test_warns_missing_args_google(named_arg, *args):  # [missing-param-doc]\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if args:\n        return named_arg\n\n\ndef test_warns_missing_kwargs_google(named_arg, **kwargs):  # [missing-param-doc]\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_args_without_type_google(named_arg, *args):\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n        *args: Optional arguments\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if args:\n        return named_arg\n\n\ndef test_finds_kwargs_without_type_google(named_arg, **kwargs):\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n        **kwargs: Keyword arguments\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_kwargs_without_type_google(named_arg, **kwargs: dict[str, str]):\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n        **kwargs: Keyword arguments\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_kwargs_without_asterisk_google(named_arg, **kwargs):\n    \"\"\"The docstring\n\n    Args:\n        named_arg (object): Returned\n        kwargs: Keyword arguments\n\n    Returns:\n        object or None: Maybe named_arg\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_escaped_args_google(value: int, *args: Any) -> None:\n    \"\"\"This is myfunc.\n\n    Args:\n        \\\\*args: this is args\n        value: this is value\n    \"\"\"\n    print(*args, value)\n\n\ndef test_finds_args_with_xref"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "missing_param_doc_required_Sphinx.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/ext/docparams/parameter", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      \"\"\"\n        pass\n\n\ndef test_warns_missing_args_sphinx(  # [missing-param-doc, inconsistent-return-statements]\n    named_arg, *args\n):\n    \"\"\"The docstring\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :returns: Maybe named_arg\n    :rtype: object or None\n    \"\"\"\n    if args:\n        return named_arg\n\n\ndef test_warns_missing_kwargs_sphinx(  # [missing-param-doc, inconsistent-return-statements]\n    named_arg, **kwargs\n):\n    \"\"\"The docstring\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :returns: Maybe named_arg\n    :rtype: object or None\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_warns_typed_kwargs_sphinx(  # [missing-param-doc, inconsistent-return-statements]\n    named_arg, **kwargs: dict[str, str]\n):\n    \"\"\"The docstring\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :returns: Maybe named_arg\n    :rtype: object or None\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_args_without_type_sphinx(  # [missing-param-doc, inconsistent-return-statements]\n    named_arg, *args\n):\n    \"\"\"The docstring\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :param *args: Optional arguments\n\n    :returns: Maybe named_arg\n    :rtype: object or None\n    \"\"\"\n    if args:\n        return named_arg\n\n\ndef test_finds_kwargs_without_type_sphinx(  # [missing-param-doc, inconsistent-return-statements]\n    named_arg, **kwargs\n):\n    \"\"\"The docstring\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :param **kwargs: Keyword arguments\n\n    :returns: Maybe named_arg\n    :rtype: object or None\n    \"\"\"\n    if kwargs:\n        return named_arg\n\n\ndef test_finds_args_without_type_sphinx(  # [inconsistent-return-statements]\n    named_arg, *args\n):\n    r\"\"\"The Sphinx docstring\n    In Sphinx docstrings asterisks should be escaped.\n    See https://github.com/pylint-dev/pylint/issues/5406\n\n    :param named_arg: Returned\n    :type named_arg: object\n\n    :param \\*args: Optional arguments\n\n "}], "retrieved_count": 10, "cost_time": 0.7690439224243164}
{"question": "What is the contract enforcement mechanism for the method decorated with the abstract method decorator in the abstract base class that uses the ABCMeta metaclass in the generic alias test file when inherited by concrete subclasses?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1240, "belongs_to": {"file_name": "generic_alias_related_py39.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/g/generic_alias", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test related function for generic alias.\n\nAny solution should not change the behavior of\n- `__getitem__`\n- `__class_getitem__`\n- `metaclass=ABCMeta`\n\"\"\"\n# flake8: noqa\n# pylint: disable=missing-docstring,pointless-statement,expression-not-assigned\n# pylint: disable=too-few-public-methods,multiple-statements,line-too-long\nfrom abc import ABCMeta, abstractmethod\nimport typing\n\nGenericAlias = type(list[int])\n\n\nclass ClsUnsubscriptable:\n    def __init__(self):\n        pass\n\nclass ClsGetItem:\n    def __init__(self):\n        self.var = [1, 2, 3, 4]\n    def __getitem__(self, item):\n        return self.var[item]\n\nclass ClsClassGetItem:\n    def __init__(self):\n        pass\n    __class_getitem__ = classmethod(GenericAlias)\n\nclass ClsList(typing.List):\n    pass\n\n\nClsUnsubscriptable()[1]  # [unsubscriptable-object]\nClsUnsubscriptable[int]  # [unsubscriptable-object]\n\nClsGetItem()[1]\nClsGetItem[int]  # [unsubscriptable-object]\n\nClsClassGetItem()[1]  # [unsubscriptable-object]\nClsClassGetItem[int]\n\n# subscriptable because of inheritance\nClsList([0, 1, 2])[1]\nClsList[int]\n\n\nclass ClsAbstract(metaclass=ABCMeta):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass Derived(ClsAbstract):  # [abstract-method]\n    pass\n"}, {"start_line": 0, "end_line": 1233, "belongs_to": {"file_name": "generic_alias_related.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/g/generic_alias", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test related function for generic alias.\n\nAny solution should not change the behavior of\n- `__getitem__`\n- `__class_getitem__`\n- `metaclass=ABCMeta`\n\"\"\"\n# flake8: noqa\n# pylint: disable=missing-docstring,pointless-statement,expression-not-assigned\n# pylint: disable=too-few-public-methods,multiple-statements,line-too-long, unnecessary-lambda-assignment\nfrom abc import ABCMeta, abstractmethod\nimport typing\n\n\nclass ClsUnsubscriptable:\n    def __init__(self):\n        pass\n\nclass ClsGetItem:\n    def __init__(self):\n        self.var = [1, 2, 3, 4]\n    def __getitem__(self, item):\n        return self.var[item]\n\nclass ClsClassGetItem:\n    def __init__(self):\n        pass\n    __class_getitem__ = lambda cls, x: None\n\nclass ClsList(typing.List):\n    pass\n\n\nClsUnsubscriptable()[1]  # [unsubscriptable-object]\nClsUnsubscriptable[int]  # [unsubscriptable-object]\n\nClsGetItem()[1]\nClsGetItem[int]  # [unsubscriptable-object]\n\nClsClassGetItem()[1]  # [unsubscriptable-object]\nClsClassGetItem[int]\n\n# subscriptable because of inheritance\nClsList([0, 1, 2])[1]\nClsList[int]\n\n\nclass ClsAbstract(metaclass=ABCMeta):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass Derived(ClsAbstract):  # [abstract-method]\n    pass\n"}, {"start_line": 0, "end_line": 1233, "belongs_to": {"file_name": "generic_alias_mixed_py39.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/g/generic_alias", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test generic alias support with mix of typing.py and stdlib types (PY39+).\"\"\"\n# flake8: noqa\n# pylint: disable=missing-docstring,pointless-statement\n# pylint: disable=too-few-public-methods,multiple-statements,line-too-long\nimport collections\nimport collections.abc\nimport contextlib\nimport re\nimport typing\n\n# Type annotations\nvar_ordered_dict: collections.OrderedDict[int, str]\nvar_container: collections.abc.Container[int]\nvar_sequence: collections.abc.Sequence[int]\nvar_iterable: collections.abc.Iterable[int]\nvar_awaitable: collections.abc.Awaitable[int]\nvar_pattern: re.Pattern[int]\nvar_bytestring: collections.abc.ByteString\nvar_hashable: collections.abc.Hashable\nvar_context_manager: contextlib.AbstractContextManager[int]\n\n\n# No implementation required for 'builtins'\nclass DerivedListIterable(typing.List[typing.Iterable[int]]):\n    pass\n\n\n# Missing implementation for 'collections.abc' derived classes\nclass DerivedHashable(typing.Hashable):  # [abstract-method]  # __hash__\n    pass\n\nclass DerivedIterable(typing.Iterable[int]):  # [abstract-method]  # __iter__\n    pass\n\nclass DerivedCollection(typing.Collection[int]):  # [abstract-method,abstract-method,abstract-method]  # __contains__, __iter__, __len__\n    pass\n"}, {"start_line": 1000, "end_line": 2294, "belongs_to": {"file_name": "abstract_method.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " explicit metaclass.\n    \"\"\"\n\n\nclass Concrete(Abstract): # [abstract-method]\n    \"\"\"Concrete class\"\"\"\n\n    def aaaa(self):\n        \"\"\"overridden form Abstract\"\"\"\n\n\nclass Structure(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __iter__(self):\n        pass\n    @abc.abstractmethod\n    def __len__(self):\n        pass\n    @abc.abstractmethod\n    def __contains__(self, _):\n        pass\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Container(Structure):\n    def __contains__(self, _):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Sizable(Structure):\n    def __len__(self):\n        return 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Hashable(Structure):\n    __hash__ = 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Iterator(Structure):\n    def keys(self):\n        return iter([1, 2, 3])\n\n    __iter__ = keys\n\n\nclass AbstractSizable(Structure):\n    @abc.abstractmethod\n    def length(self):\n        pass\n    __len__ = length\n\n\nclass GoodComplexMRO(Container, Iterator, Sizable, Hashable):\n    pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass BadComplexMro(Container, Iterator, AbstractSizable):\n    pass\n"}, {"start_line": 0, "end_line": 346, "belongs_to": {"file_name": "regression_3231_no_member_property.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/r/regression", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring\nfrom abc import ABCMeta, abstractmethod\n\n\nclass Cls(metaclass=ABCMeta):\n    def __init__(self):\n        pass\n\n    @property\n    @abstractmethod\n    def values(self):\n        pass\n\n    @classmethod\n    def some_method(cls):\n        return cls.values.issubset({2, 3})\n\n\nclass Subcls(Cls):\n    values = {1, 2, 3}\n"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "basic_error_checker.py", "upper_path": "/data2/raymone/swebench-repos/pylint/pylint/checkers/base", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sages(\"nonlocal-without-binding\")\n    def visit_nonlocal(self, node: nodes.Nonlocal) -> None:\n        for name in node.names:\n            self._check_nonlocal_without_binding(node, name)\n\n    @utils.only_required_for_messages(\"abstract-class-instantiated\")\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Check instantiating abstract class with\n        abc.ABCMeta as metaclass.\n        \"\"\"\n        for inferred in infer_all(node.func):\n            self._check_inferred_class_is_abstract(inferred, node)\n\n    def _check_inferred_class_is_abstract(\n        self, inferred: InferenceResult, node: nodes.Call\n    ) -> None:\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n\n        klass = utils.node_frame_class(node)\n        if klass is inferred:\n            # Don't emit the warning if the class is instantiated\n            # in its own body or if the call is not an instance\n            # creation. If the class is instantiated into its own\n            # body, we're expecting that it knows what it is doing.\n            return\n\n        # __init__ was called\n        abstract_methods = _has_abstract_methods(inferred)\n\n        if not abstract_methods:\n            return\n\n        metaclass = inferred.metaclass()\n\n        if metaclass is None:\n            # Python 3.4 has `abc.ABC`, which won't be detected\n            # by ClassNode.metaclass()\n            for ancestor in inferred.ancestors():\n                if ancestor.qname() == \"abc.ABC\":\n                    self.add_message(\n                        \"abstract-class-instantiated\", args=(inferred.name,), node=node\n                    )\n                    break\n\n            return\n\n        if metaclass.qname() in ABC_METACLASSES:\n            self.add_message(\n                \"abstract-class-instantiated\", args=(inferred.name,), node=node\n            )\n\n    def _check_yield_outside_func(self, node: nodes.Yield) -> None:\n        if not isinstance(node.frame(), (nodes.FunctionDef, nodes.Lambda)):\n "}, {"start_line": 0, "end_line": 381, "belongs_to": {"file_name": "abstract_abc_methods.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\" This should not warn about `prop` being abstract in Child \"\"\"\n# pylint: disable=too-few-public-methods\n\nimport abc\n\nclass Parent:\n    \"\"\"Abstract Base Class \"\"\"\n    __metaclass__ = abc.ABCMeta\n\n    @property\n    @abc.abstractmethod\n    def prop(self):\n        \"\"\" Abstract \"\"\"\n\nclass Child(Parent):\n    \"\"\" No warning for the following. \"\"\"\n    prop = property(lambda self: 1)\n"}, {"start_line": 0, "end_line": 712, "belongs_to": {"file_name": "typing_generic.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/t", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# pylint: disable=missing-docstring,invalid-name,too-few-public-methods\n\n# https://github.com/pylint-dev/pylint/issues/2822\n# Base should be subscriptable, even with ABCMeta as metaclass\nfrom abc import ABC, ABCMeta\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\nclass Base(Generic[T], metaclass=ABCMeta):\n    \"\"\"Base\"\"\"\n\nclass Impl(Base[str]):\n    \"\"\"Impl\"\"\"\n\n\n# https://github.com/pylint-dev/astroid/issues/942\nAnything = TypeVar(\"Anything\")\nMoreSpecific = TypeVar(\"MoreSpecific\", str, int)\n\nclass A(ABC, Generic[Anything]):\n    def a_method(self) -> None:\n        print(\"hello\")\n\nclass B(A[MoreSpecific]):\n    pass\n\nclass C(B[str]):\n    pass\n\nc = C()\nc.a_method()  # should NOT emit `no-member` error\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "abstract_method.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test abstract-method warning.\"\"\"\n\n\n# pylint: disable=missing-docstring\n# pylint: disable=too-few-public-methods\nimport abc\n\n\nclass Abstract:\n    def aaaa(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\n    def bbbb(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\n\nclass AbstractB(Abstract):\n    \"\"\"Abstract class.\n\n    this class is checking that it does not output an error msg for\n    unimplemeted methods in abstract classes\n    \"\"\"\n    def cccc(self):\n        \"\"\"should be overridden in concrete class\"\"\"\n        raise NotImplementedError()\n\nclass AbstractC(AbstractB, abc.ABC):\n    \"\"\"\n    Abstract class.\n\n    Should not trigger a warning for unimplemented\n    abstract methods, because of explicit abc.ABC inheritance.\n    \"\"\"\n\n\nclass AbstractD(AbstractB, metaclass=abc.ABCMeta):\n    \"\"\"\n    Abstract class.\n\n    Should not trigger a warning for unimplemented\n    abstract methods, because of explicit metaclass.\n    \"\"\"\n\n\nclass Concrete(Abstract): # [abstract-method]\n    \"\"\"Concrete class\"\"\"\n\n    def aaaa(self):\n        \"\"\"overridden form Abstract\"\"\"\n\n\nclass Structure(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __iter__(self):\n        pass\n    @abc.abstractmethod\n    def __len__(self):\n        pass\n    @abc.abstractmethod\n    def __contains__(self, _):\n        pass\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Container(Structure):\n    def __contains__(self, _):\n        pass\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Sizable(Structure):\n    def __len__(self):\n        return 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Hashable(Structure):\n    __hash__ = 42\n\n\n# +1: [abstract-method, abstract-method, abstract-method]\nclass Iterator(Structure):\n    def keys(self):\n        return iter([1, 2, 3])\n\n    __iter__ = keys\n\n\nclass AbstractSizable"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "abstract_class_instantiated.py", "upper_path": "/data2/raymone/swebench-repos/pylint/tests/functional/a/abstract", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Check that instantiating a class with\n`abc.ABCMeta` as metaclass fails if it defines\nabstract methods.\n\"\"\"\n\n# pylint: disable=too-few-public-methods, missing-docstring\n# pylint: disable=abstract-method, import-error\n\nimport abc\nimport weakref\nfrom lala import Bala\n\n\nclass GoodClass(metaclass=abc.ABCMeta):\n    pass\n\nclass SecondGoodClass(metaclass=abc.ABCMeta):\n    def test(self):\n        \"\"\" do nothing. \"\"\"\n\nclass ThirdGoodClass(metaclass=abc.ABCMeta):\n    \"\"\" This should not raise the warning. \"\"\"\n    def test(self):\n        raise NotImplementedError()\n\nclass BadClass(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def test(self):\n        \"\"\" do nothing. \"\"\"\n\nclass SecondBadClass(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def test(self):\n        \"\"\" do nothing. \"\"\"\n\nclass ThirdBadClass(SecondBadClass):\n    pass\n\n\nclass Structure(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __iter__(self):\n        pass\n    @abc.abstractmethod\n    def __len__(self):\n        pass\n    @abc.abstractmethod\n    def __contains__(self, _):\n        pass\n    @abc.abstractmethod\n    def __hash__(self):\n        pass\n\nclass Container(Structure):\n    def __contains__(self, _):\n        pass\n\nclass Sizable(Structure):\n    def __len__(self):\n        return 42\n\nclass Hashable(Structure):\n    __hash__ = 42\n\n\nclass Iterator(Structure):\n    def keys(self):\n        return iter([1, 2, 3])\n\n    __iter__ = keys\n\nclass AbstractSizable(Structure):\n    @abc.abstractmethod\n    def length(self):\n        pass\n    __len__ = length\n\nclass NoMroAbstractMethods(Container, Iterator, Sizable, Hashable):\n    pass\n\nclass BadMroAbstractMethods(Container, Iterator, AbstractSizable):\n    pass\n\nclass SomeMetaclass(metaclass=abc.ABCMeta):\n\n    @abc.abstractmethod\n    def prop(self):\n        pass\n\nclass FourthGoodClass(SomeMetaclass):\n    \"\"\"Don't consider this abstract if some attributes are\n    there, but can't be inferred.\n    \"\"\"\n    prop = Bala # missing\n\n\ndef main():\n    \"\"\" do no"}], "retrieved_count": 10, "cost_time": 1.6931846141815186}
