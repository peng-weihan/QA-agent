{"question": "What is Sphinx's role system?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's role system is a markup mechanism that allows users to insert semantic markup into documents using interpreted text roles. Roles are written in the format `:rolename:`content`` and provide a way to create cross-references, apply formatting, and add semantic meaning to text.\n\nKey components of Sphinx's role system include:\n\n1. **XRefRole**: The core cross-referencing role class that handles automatic creation of references and content nodes. It supports features like automatic title/target separation with `title <target>` syntax, parentheses normalization, and customizable node classes.\n\n2. **Domain-specific roles**: Different domains (Python, C++, etc.) provide specialized roles for their object types. For example, the Python domain provides `:py:func:`, `:py:class:`, `:py:mod:` roles.\n\n3. **Standard domain roles**: The standard domain provides general-purpose roles like `:ref:`, `:doc:`, `:term:`, `:option:`, `:envvar:`, and `:any:` for cross-referencing various document elements.\n\n4. **Custom role creation**: Sphinx provides base classes like `SphinxRole` and `ReferenceRole` for creating custom roles. The `ReferenceRole` class implements Sphinx's title/target logic and is useful for creating cross-reference roles.\n\n5. **Role registration**: Roles are registered using `app.add_role()` or `app.add_role_to_domain()` methods, allowing extensions to add new roles.\n\n6. **Cross-reference modifiers**: Roles support modifiers like custom link text (`:role:`custom text <target>``) and suppressed links (`:role:`!target``) to prevent link generation.\n\nThe role system integrates with Sphinx's domain system and event system, allowing for flexible cross-reference resolution and extensibility through the extension API.", "score": null, "retrieved_content": [{"start_line": 21000, "end_line": 22595, "belongs_to": {"file_name": "roles.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es, language=language)\n\n    return [node], []\n\n\ncode_role.options = {  # type: ignore[attr-defined]\n    'class': docutils.parsers.rst.directives.class_option,\n    'language': docutils.parsers.rst.directives.unchanged,\n}\n\n\nspecific_docroles: dict[str, RoleFunction] = {\n    # links to download references\n    'download': XRefRole(nodeclass=addnodes.download_reference),\n    # links to anything\n    'any': AnyXRefRole(warn_dangling=True),\n    # external links\n    'cve': CVE(),\n    'cwe': CWE(),\n    'pep': PEP(),\n    'rfc': RFC(),\n    # emphasised things\n    'guilabel': GUILabel(),\n    'menuselection': MenuSelection(),\n    'file': EmphasizedLiteral(),\n    'samp': EmphasizedLiteral(),\n    # other\n    'abbr': Abbreviation(),\n    'kbd': Keyboard(),\n    'manpage': Manpage(),\n}\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    from docutils.parsers.rst import roles\n\n    for rolename, nodeclass in generic_docroles.items():\n        generic = roles.GenericRole(rolename, nodeclass)\n        role = roles.CustomRole(rolename, generic, {'classes': [rolename]})  # type: ignore[arg-type]\n        roles.register_local_role(rolename, role)  # type: ignore[arg-type]\n\n    for rolename, func in specific_docroles.items():\n        roles.register_local_role(rolename, func)  # type: ignore[arg-type]\n\n    # Since docutils registers it as a canonical role, override it as a\n    # canonical role as well.\n    roles.register_canonical_role('code', code_role)  # type: ignore[arg-type]\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     #: The interpreted text content.\n    lineno: int       #: The line number where the interpreted text begins.\n    inliner: Inliner  #: The ``docutils.parsers.rst.states.Inliner`` object.\n    #: A dictionary of directive options for customisation\n    #: (from the \"role\" directive).\n    options: dict[str, Any]\n    #: A list of strings, the directive content for customisation\n    #: (from the \"role\" directive).\n    content: Sequence[str]\n    # fmt: on\n\n    def __call__(\n        self,\n        name: str,\n        rawtext: str,\n        text: str,\n        lineno: int,\n        inliner: Inliner,\n        options: dict[str, Any] | None = None,\n        content: Sequence[str] = (),\n    ) -> tuple[list[Node], list[system_message]]:\n        self.rawtext = rawtext\n        self.text = unescape(text)\n        self.lineno = lineno\n        self.inliner = inliner\n        self.options = options if options is not None else {}\n        self.content = content\n\n        # guess role type\n        if name:\n            self.name = name.lower()\n        else:\n            self.name = self.env.current_document.default_role\n            if not self.name:\n                self.name = self.env.config.default_role\n            if not self.name:\n                msg = 'cannot determine default role!'\n                raise SphinxError(msg)\n\n        return self.run()\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        raise NotImplementedError\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.inliner.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.env.config\n\n    def get_source_info(self, lineno: int | None = None) -> tuple[str, int]:\n        # .. versionadded:: 3.0\n        if lineno is None:\n            lineno = self.lineno\n   "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " == 2:\n            return names[0], names[1]\n        else:\n            return None, None\n\n    def _emit_warning(self, msg: str, /, *args: Any) -> None:\n        LOGGER.warning(\n            msg,\n            *args,\n            type='intersphinx',\n            subtype='external',\n            location=(self.env.current_document.docname, self.lineno),\n        )\n\n    def _concat_strings(self, strings: Iterable[str]) -> str:\n        return ', '.join(f'{s!r}' for s in sorted(strings))\n\n    # deprecated methods\n\n    def get_role_name(self, name: str) -> tuple[str, str] | None:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.get_role_name', '', remove=(9, 0)\n        )\n        names = name.split(':')\n        if len(names) == 1:\n            # role\n            if (domain := self.env.current_document.default_domain) is not None:\n                domain_name = domain.name\n            else:\n                domain_name = None\n            role = names[0]\n        elif len(names) == 2:\n            # domain:role:\n            domain_name, role = names\n        else:\n            return None\n\n        if domain_name and self.is_existent_role(domain_name, role):\n            return domain_name, role\n        elif self.is_existent_role('std', role):\n            return 'std', role\n        else:\n            return None\n\n    def is_existent_role(self, domain_name: str, role_name: str) -> bool:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.is_existent_role', '', remove=(9, 0)\n        )\n        try:\n            domain = self.env.domains[domain_name]\n        except KeyError:\n            return False\n        else:\n            return role_name in domain.roles\n\n    def invoke_role(\n        self, role: tuple[str, str]\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Invoke the role described by a ``(domain, role name)`` pair.\"\"\"\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.invoke_role', '', remove"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   document.  In the object_types attribute of Domain subclasses, object type\n    names are mapped to instances of this class.\n\n    Constructor arguments:\n\n    - *lname*: localized name of the type (do not include domain name)\n    - *roles*: all the roles that can refer to an object of this type\n    - *attrs*: object attributes -- currently only \"searchprio\" is known,\n      which defines the object's priority in the full-text search index,\n      see :meth:`Domain.get_objects()`.\n    \"\"\"\n\n    known_attrs = {\n        'searchprio': 1,\n    }\n\n    def __init__(self, lname: str, /, *roles: Any, **attrs: Any) -> None:\n        self.lname: str = lname\n        self.roles: tuple[Any, ...] = roles\n        self.attrs: dict[str, Any] = self.known_attrs | attrs\n\n\nclass Domain:\n    \"\"\"A Domain is meant to be a group of \"object\" description directives for\n    objects of a similar nature, and corresponding roles to create references to\n    them.  Examples would be Python modules, classes, functions etc., elements\n    of a templating language, Sphinx roles and directives, etc.\n\n    Each domain has a separate storage for information about existing objects\n    and how to reference them in `self.data`, which must be a dictionary.  It\n    also must implement several functions that expose the object information in\n    a uniform way to parts of Sphinx that allow the user to reference or search\n    for objects in a domain-agnostic way.\n\n    About `self.data`: since all object and cross-referencing information is\n    stored on a BuildEnvironment instance, the `domain.data` object is also\n    stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n    build process starts, every active domain is instantiated and given the\n    environment object; the `domaindata` dict must then either be nonexistent or\n    a dictionary whose 'version' key is equal to the domain class'\n    :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n    pickled environment is disc"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_roles.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test sphinx.roles\"\"\"\n\nfrom __future__ import annotations\n\nfrom unittest.mock import Mock\n\nimport pytest\nfrom docutils import nodes\n\nfrom sphinx.roles import EmphasizedLiteral, _format_rfc_target\nfrom sphinx.testing.util import assert_node\n\n\ndef test_samp() -> None:\n    emph_literal_role = EmphasizedLiteral()\n\n    # normal case\n    text = 'print 1+{variable}'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(\n        ret[0],\n        [\n            nodes.literal,\n            (\n                'print 1+',\n                [nodes.emphasis, 'variable'],\n            ),\n        ],\n    )\n    assert msg == []\n\n    # two emphasis items\n    text = 'print {1}+{variable}'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(\n        ret[0],\n        [\n            nodes.literal,\n            (\n                'print ',\n                [nodes.emphasis, '1'],\n                '+',\n                [nodes.emphasis, 'variable'],\n            ),\n        ],\n    )\n    assert msg == []\n\n    # empty curly brace\n    text = 'print 1+{}'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(ret[0], [nodes.literal, 'print 1+{}'])\n    assert msg == []\n\n    # half-opened variable\n    text = 'print 1+{variable'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(ret[0], [nodes.literal, 'print 1+{variable'])\n    assert msg == []\n\n    # nested\n    text = 'print 1+{{variable}}'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(\n        ret[0],\n        [\n            nodes.literal,\n            (\n                'print 1+',\n                [nodes.emphasis, '{variable'],\n                '}',\n            ),\n        ],\n    )\n    assert msg == []\n\n    # emphasized item only\n    text = '{variable}'\n    ret, msg = emph_literal_role('samp', text, text, 0, Mock())\n    assert_node(ret[0], [nodes.literal, nodes.emphasis, 'variable'])\n    assert msg == []\n\n    # escaping\n    te"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    target_node = nodes.target(ids=node_ids)\n                self.set_source_info(target_node)\n                return [self.indexnode, target_node]\n            return [self.indexnode]\n        return [self.indexnode, node]\n\n\nclass DefaultRole(SphinxDirective):\n    \"\"\"Set the default interpreted text role.  Overridden from docutils.\"\"\"\n\n    optional_arguments = 1\n    final_argument_whitespace = False\n\n    def run(self) -> list[Node]:\n        if not self.arguments:\n            docutils.unregister_role('')\n            return []\n        role_name = self.arguments[0]\n        role, messages = roles.role(\n            role_name, self.state_machine.language, self.lineno, self.state.reporter\n        )\n        if role:\n            docutils.register_role('', role)  # type: ignore[arg-type]\n            self.env.current_document.default_role = role_name\n        else:\n            literal_block = nodes.literal_block(self.block_text, self.block_text)\n            reporter = self.state.reporter\n            error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_direct"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n\n        element = self.domains.standard_domain.directive(name)\n        if element is not None:\n            return element, []\n\n        return super().directive(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        \"\"\"Lookup a role, given its name which can include a domain.\"\"\"\n        role_name = role_name.lower()\n        # explicit domain given?\n        if ':' in role_name:\n            domain_name, _, name = role_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown role name: %s'), role_name)\n            else:\n                element = domain.role(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = role_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.role(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domain\n        element = self.domains.standard_domain.role(name)\n        if element is not None:\n            return element, []\n\n        return super().role(role_name, language_module, lineno, reporter)\n\n\nclass WarningStream:\n    def write(self, text: str) -> None:\n        matched = report_re.search(text)\n        if not matched:\n            logger.warning(text.rstrip('\\r\\n'), type='docutils')\n        else:\n            location, type, _level = matched.groups()\n            message = report_re.sub('', text).rstrip()\n            logger.log(type, message, location=location, type='docutils')\n\n\nclass LoggingReporter(Reporter):\n    @classmethod\n    def from_reporter(\n        cls: type[LoggingReporter], "}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    If true, unconditionally install the role.\n\n        For more details about role functions, see `the Docutils docs\n        <https://docutils.sourceforge.io/docs/howto/rst-roles.html>`__ .\n\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        logger.debug('[app] adding role: %r', (name, role))\n        if not override and docutils.is_role_registered(name):\n            logger.warning(\n                __('role %r is already registered and will not be overridden'),\n                name,\n                type='app',\n                subtype='add_role',\n            )\n        docutils.register_role(name, role)\n\n    def add_generic_role(\n        self, name: str, nodeclass: type[Node], override: bool = False\n    ) -> None:\n        \"\"\"Register a generic Docutils role.\n\n        Register a Docutils role that does nothing but wrap its contents in the\n        node given by *nodeclass*.\n\n        :param override: If false, do not install it if another role\n                         is already installed as the same name\n                         If true, unconditionally install the role.\n\n        .. versionadded:: 0.6\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        # Don't use ``roles.register_generic_role`` because it uses\n        # ``register_canonical_role``.\n        logger.debug('[app] adding generic role: %r', (name, nodeclass))\n        if not override and docutils.is_role_registered(name):\n            logger.warning(\n                __('role %r is already registered and will not be overridden'),\n                name,\n                type='app',\n                subtype='add_generic_role',\n            )\n        role = roles.GenericRole(name, nodeclass)\n        docutils.register_role(name, role)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        \"\"\"Register a domain.\n\n        :param domain: A domain class\n        :param override: If false, do not install it if another doma"}, {"start_line": 14000, "end_line": 15372, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_directive('default-domain', DefaultDomain)\n    directives.register_directive('describe', ObjectDescription)\n    # new, more consistent, name\n    directives.register_directive('object', ObjectDescription)\n\n    app.add_event('object-description-transform')\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}], "retrieved_count": 10, "cost_time": 1.0197808742523193}
{"question": "What is the structure of Sphinx's configuration system?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's configuration system is structured around a centralized Config class that manages all configuration values for a Sphinx project. The system consists of several key components:\n\n1. **Config Class**: The main configuration abstraction that makes all config options available as attributes. It's exposed via `app.config` and `env.config` attributes.\n\n2. **_Opt Class**: Represents individual configuration options with metadata including default values, rebuild requirements, valid types, and descriptions. Each option is defined with a default value, rebuild specification (what needs to be rebuilt if changed), and valid type constraints.\n\n3. **Configuration File (conf.py)**: A Python file that defines project-specific configuration values. The file is executed as Python code at build time, allowing for dynamic configuration based on environment variables or other conditions.\n\n4. **Configuration Values Dictionary**: A comprehensive dictionary (`config_values`) that defines all available configuration options with their metadata. This includes general options (project, author, version), build-specific options, and format-specific options for different output formats.\n\n5. **Override System**: Supports configuration overrides through the `confoverrides` parameter, allowing values to be overridden programmatically without modifying the conf.py file.\n\n6. **Type Validation**: The system validates configuration values against their defined types using the `valid_types` field in _Opt objects.\n\n7. **Rebuild Tracking**: Each configuration option specifies what needs to be rebuilt when the option changes (e.g., 'env', 'html', 'epub').\n\n8. **Extension Integration**: The configuration system integrates with Sphinx's extension system, allowing extensions to add their own configuration options.\n\nThe configuration is loaded during Sphinx initialization and is used throughout the build process to control various aspects of document generation, formatting, and output.", "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", 'env', frozenset((str,))),\n        'default_role': _Opt(None, 'env', frozenset((str,))),\n        'add_function_parentheses': _Opt(True, 'env', frozenset((bool,))),\n        'add_module_names': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries_show_parents': _Opt(\n            'domain', 'env', ENUM('domain', 'all', 'hide')\n        ),\n        'trim_footnote_reference_space': _Opt(False, 'env', frozenset((bool,))),\n        'show_authors': _Opt(False, 'env', frozenset((bool,))),\n        'pygments_style': _Opt(None, 'html', frozenset((str,))),\n        'highlight_language': _Opt('default', 'env', frozenset((str,))),\n        'highlight_options': _Opt({}, 'env', frozenset((dict,))),\n        'templates_path': _Opt([], 'html', frozenset((list,))),\n        'template_bridge': _Opt(None, 'html', frozenset((str,))),\n        'keep_warnings': _Opt(False, 'env', frozenset((bool,))),\n        'suppress_warnings': _Opt([], 'env', frozenset((list, tuple))),\n        'show_warning_types': _Opt(True, 'env', frozenset((bool,))),\n        'modindex_common_prefix': _Opt([], 'html', frozenset((list, tuple))),\n        'rst_epilog': _Opt(None, 'env', frozenset((str,))),\n        'rst_prolog': _Opt(None, 'env', frozenset((str,))),\n        'trim_doctest_flags': _Opt(True, 'env', frozenset((bool,))),\n        'primary_domain': _Opt('py', 'env', frozenset((types.NoneType,))),\n        'needs_sphinx': _Opt(None, '', frozenset((str,))),\n        'needs_extensions': _Opt({}, '', frozenset((dict,))),\n        'manpages_url': _Opt(None, 'env', frozenset((str, types.NoneType))),\n        'nitpicky': _Opt(False, '', frozenset((bool,))),\n        'nitpick_ignore': _Opt([], '', frozenset((set, list, tuple))),\n        'nitpick_ignore_regex': _Opt([], '', frozenset((set, list, tuple))),\n        'numfig': _Opt(False, 'env', frozenset((bool,))),\n        'numfig_secnum_depth': _Opt(1, 'env', frozenset((int, types.NoneType))),\n        # "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      default, rebuild, valid_types, description = state\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __getitem__(self, item: int | slice) -> Any:\n        warnings.warn(\n            f'The {self.__class__.__name__!r} object tuple interface is deprecated, '\n            \"use attribute access instead for 'default', 'rebuild', and 'valid_types'.\",\n            RemovedInSphinx90Warning,\n            stacklevel=2,\n        )\n        return (self.default, self.rebuild, self.valid_types)[item]\n\n\nclass Config:\n    r\"\"\"Configuration file abstraction.\n\n    The Config object makes the values of all config options available as\n    attributes.\n\n    It is exposed via the :py:class:`~sphinx.application.Sphinx`\\ ``.config``\n    and :py:class:`sphinx.environment.BuildEnvironment`\\ ``.config`` attributes.\n    For example, to get the value of :confval:`language`, use either\n    ``app.config.language`` or ``env.config.language``.\n    \"\"\"\n\n    # The values are:\n    # 1. Default\n    # 2. What needs to be rebuilt if changed\n    # 3. Valid types\n\n    # If you add a value here, remember to include it in the docs!\n\n    config_values: dict[str, _Opt] = {\n        # general options\n        'project': _Opt('Project name not set', 'env', frozenset((str,))),\n        'author': _Opt('Author name not set', 'env', frozenset((str,))),\n        'project_copyright': _Opt('', 'html', frozenset((str, tuple, list))),\n        'copyright': _Opt(\n            lambda config: config.project_copyright,\n            'html',\n            frozenset((str, tuple, list)),\n        ),\n        'version': _Opt('', 'env', frozenset((str,))),\n        'release': _Opt('', 'env', frozenset((str,))),\n        'today': _Opt('', 'env', frozenset((str,))),\n        # the real default is locale-dependent\n        'today_fmt': _Opt(None, 'env', frozenset((str,))),\n        'lan"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     ),\n        'option_emphasise_placeholders': _Opt(False, 'env', frozenset((bool,))),\n    }\n\n    def __init__(\n        self,\n        config: dict[str, Any] | None = None,\n        overrides: dict[str, Any] | None = None,\n    ) -> None:\n        raw_config: dict[str, Any] = config or {}\n        self._overrides = dict(overrides) if overrides is not None else {}\n        self._options = Config.config_values.copy()\n        self._raw_config = raw_config\n\n        for name in list(self._overrides.keys()):\n            if '.' in name:\n                real_name, _, key = name.partition('.')\n                raw_config.setdefault(real_name, {})[key] = self._overrides.pop(name)\n\n        self.setup: _ExtensionSetupFunc | None = raw_config.get('setup')\n\n        if 'extensions' in self._overrides:\n            extensions = self._overrides.pop('extensions')\n            if isinstance(extensions, str):\n                raw_config['extensions'] = extensions.split(',')\n            else:\n                raw_config['extensions'] = extensions\n        self.extensions: list[str] = raw_config.get('extensions', [])\n\n        self._verbosity: int = 0  # updated in Sphinx.__init__()\n\n    @property\n    def values(self) -> dict[str, _Opt]:\n        return self._options\n\n    @property\n    def overrides(self) -> dict[str, Any]:\n        return self._overrides\n\n    @property\n    def verbosity(self) -> int:\n        return self._verbosity\n\n    @classmethod\n    def read(\n        cls: type[Config],\n        confdir: str | os.PathLike[str],\n        *,\n        overrides: dict[str, Any],\n        tags: Tags,\n    ) -> Config:\n        \"\"\"Create a Config object from configuration file.\"\"\"\n        filename = Path(confdir, CONFIG_FILENAME)\n        if not filename.is_file():\n            raise ConfigError(\n                __(\"config directory doesn't contain a conf.py file (%s)\") % confdir\n            )\n        return _read_conf_py(filename, overrides=overrides, tags=tags)\n\n    def convert_overrides(self, name: str, valu"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    description: str\n\n    def __init__(\n        self,\n        default: Any,\n        rebuild: _ConfigRebuild,\n        valid_types: _OptValidTypes,\n        description: str = '',\n    ) -> None:\n        \"\"\"Configuration option type for Sphinx.\n\n        The type is intended to be immutable; changing the field values\n        is an unsupported action.\n        No validation is performed on the values, though consumers will\n        likely expect them to be of the types advertised.\n        The old tuple-based interface will be removed in Sphinx 9.\n        \"\"\"\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __repr__(self) -> str:\n        return (\n            f'{self.__class__.__qualname__}('\n            f'default={self.default!r}, '\n            f'rebuild={self.rebuild!r}, '\n            f'valid_types={self.rebuild!r}, '\n            f'description={self.description!r})'\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, _Opt):\n            self_tpl = (\n                self.default,\n                self.rebuild,\n                self.valid_types,\n                self.description,\n            )\n            other_tpl = (\n                other.default,\n                other.rebuild,\n                other.valid_types,\n                other.description,\n            )\n            return self_tpl == other_tpl\n        return NotImplemented\n\n    def __lt__(self, other: _Opt) -> bool:\n        if self.__class__ is other.__class__:\n            self_tpl = (\n                self.default,\n                self.rebuild,\n                self.valid_types,\n                self.description,\n            )\n            other_tpl = (\n                other.default,\n                other.rebuild,\n                other.valid_types,\n                other.description,\n            )\n            return self_tpl > "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "], 'env', frozenset((list, tuple))),\n        'show_warning_types': _Opt(True, 'env', frozenset((bool,))),\n        'modindex_common_prefix': _Opt([], 'html', frozenset((list, tuple))),\n        'rst_epilog': _Opt(None, 'env', frozenset((str,))),\n        'rst_prolog': _Opt(None, 'env', frozenset((str,))),\n        'trim_doctest_flags': _Opt(True, 'env', frozenset((bool,))),\n        'primary_domain': _Opt('py', 'env', frozenset((types.NoneType,))),\n        'needs_sphinx': _Opt(None, '', frozenset((str,))),\n        'needs_extensions': _Opt({}, '', frozenset((dict,))),\n        'manpages_url': _Opt(None, 'env', frozenset((str, types.NoneType))),\n        'nitpicky': _Opt(False, '', frozenset((bool,))),\n        'nitpick_ignore': _Opt([], '', frozenset((set, list, tuple))),\n        'nitpick_ignore_regex': _Opt([], '', frozenset((set, list, tuple))),\n        'numfig': _Opt(False, 'env', frozenset((bool,))),\n        'numfig_secnum_depth': _Opt(1, 'env', frozenset((int, types.NoneType))),\n        # numfig_format will be initialized in init_numfig_format()\n        'numfig_format': _Opt({}, 'env', frozenset((dict,))),\n        'maximum_signature_line_length': _Opt(\n            None, 'env', frozenset((int, types.NoneType))\n        ),\n        'math_number_all': _Opt(False, 'env', frozenset((bool,))),\n        'math_eqref_format': _Opt(None, 'env', frozenset((str,))),\n        'math_numfig': _Opt(True, 'env', frozenset((bool,))),\n        'math_numsep': _Opt('.', 'env', frozenset((str,))),\n        'tls_verify': _Opt(True, 'env', frozenset((bool,))),\n        'tls_cacerts': _Opt(None, 'env', frozenset((str, dict, types.NoneType))),\n        'user_agent': _Opt(None, 'env', frozenset((str,))),\n        'smartquotes': _Opt(True, 'env', frozenset((bool,))),\n        'smartquotes_action': _Opt('qDe', 'env', frozenset((str,))),\n        'smartquotes_excludes': _Opt(\n            {'languages': ['ja', 'zh_CN', 'zh_TW'], 'builders': ['man', 'text']},\n            'env',\n            frozenset((dict,)),\n   "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "guage': _Opt('en', 'env', frozenset((str,))),\n        'locale_dirs': _Opt(['locales'], 'env', frozenset((list, tuple))),\n        'figure_language_filename': _Opt(\n            '{root}.{language}{ext}', 'env', frozenset((str,))\n        ),\n        'gettext_allow_fuzzy_translations': _Opt(False, 'gettext', frozenset((bool,))),\n        'translation_progress_classes': _Opt(\n            False, 'env', ENUM(True, False, 'translated', 'untranslated')\n        ),\n        'master_doc': _Opt('index', 'env', frozenset((str,))),\n        'root_doc': _Opt(lambda config: config.master_doc, 'env', frozenset((str,))),\n        # ``source_suffix`` type is actually ``dict[str, str | None]``:\n        # see ``convert_source_suffix()`` below.\n        'source_suffix': _Opt({'.rst': 'restructuredtext'}, 'env', Any),  # type: ignore[arg-type]\n        'source_encoding': _Opt('utf-8-sig', 'env', frozenset((str,))),\n        'exclude_patterns': _Opt([], 'env', frozenset((str,))),\n        'include_patterns': _Opt(['**'], 'env', frozenset((str,))),\n        'default_role': _Opt(None, 'env', frozenset((str,))),\n        'add_function_parentheses': _Opt(True, 'env', frozenset((bool,))),\n        'add_module_names': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries_show_parents': _Opt(\n            'domain', 'env', ENUM('domain', 'all', 'hide')\n        ),\n        'trim_footnote_reference_space': _Opt(False, 'env', frozenset((bool,))),\n        'show_authors': _Opt(False, 'env', frozenset((bool,))),\n        'pygments_style': _Opt(None, 'html', frozenset((str,))),\n        'highlight_language': _Opt('default', 'env', frozenset((str,))),\n        'highlight_options': _Opt({}, 'env', frozenset((dict,))),\n        'templates_path': _Opt([], 'html', frozenset((list,))),\n        'template_bridge': _Opt(None, 'html', frozenset((str,))),\n        'keep_warnings': _Opt(False, 'env', frozenset((bool,))),\n        'suppress_warnings': _Opt(["}, {"start_line": 0, "end_line": 57, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Contains Sphinx features not activated by default.\"\"\"\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}], "retrieved_count": 10, "cost_time": 1.035675048828125}
{"question": "What dependencies exist between Sphinx's Builder classes and their corresponding Writer classes?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's Builder classes and their corresponding Writer classes have a well-defined dependency relationship that follows a separation of concerns principle. The Builder classes are responsible for orchestrating the build process and managing the overall workflow, while Writer classes handle the actual output generation for specific formats.\n\nKey dependencies and relationships include:\n\n1. **Builder Orchestration**: Builder classes coordinate the entire build process, including reading source files, applying transforms, and calling the appropriate writer to generate output. They manage the build workflow and delegate the actual output generation to writers.\n\n2. **Writer Selection**: Builders select and instantiate the appropriate writer class based on the output format they need to generate. For example, an HTML builder would use an HTML writer, while a LaTeX builder would use a LaTeX writer.\n\n3. **Document Tree Processing**: Builders prepare the document trees and apply necessary transformations before passing them to writers. Writers receive fully processed document trees and focus solely on converting them to the target output format.\n\n4. **Configuration Integration**: Builders pass configuration settings and build context to writers, ensuring that writers have access to the necessary information to generate appropriate output.\n\n5. **Output Management**: Builders manage the output directory structure and file organization, while writers handle the actual content generation for individual files.\n\n6. **Error Handling**: Builders provide error handling and logging context for the overall build process, while writers handle format-specific errors during output generation.\n\nThis separation allows Sphinx to maintain a clean architecture where builders focus on build process management and writers focus on format-specific output generation, making the system more modular and extensible.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 0, "end_line": 1679, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-api-set-translator", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# set this by test\n# import sys\n# from pathlib import Path\n# sys.path.insert(0, str(Path.cwd().resolve()))\n\nfrom docutils.writers.docutils_xml import XMLTranslator\n\nfrom sphinx.writers.html import HTML5Translator\nfrom sphinx.writers.latex import LaTeXTranslator\nfrom sphinx.writers.manpage import ManualPageTranslator\nfrom sphinx.writers.texinfo import TexinfoTranslator\nfrom sphinx.writers.text import TextTranslator\n\nproject = 'test'\n\n\nclass ConfHTMLTranslator(HTML5Translator):\n    pass\n\n\nclass ConfDirHTMLTranslator(HTML5Translator):\n    pass\n\n\nclass ConfSingleHTMLTranslator(HTML5Translator):\n    pass\n\n\nclass ConfPickleTranslator(HTML5Translator):\n    pass\n\n\nclass ConfJsonTranslator(HTML5Translator):\n    pass\n\n\nclass ConfLaTeXTranslator(LaTeXTranslator):\n    pass\n\n\nclass ConfManualPageTranslator(ManualPageTranslator):\n    pass\n\n\nclass ConfTexinfoTranslator(TexinfoTranslator):\n    pass\n\n\nclass ConfTextTranslator(TextTranslator):\n    pass\n\n\nclass ConfXMLTranslator(XMLTranslator):\n    pass\n\n\nclass ConfPseudoXMLTranslator(XMLTranslator):\n    pass\n\n\ndef setup(app):\n    app.set_translator('html', ConfHTMLTranslator)\n    app.set_translator('dirhtml', ConfDirHTMLTranslator)\n    app.set_translator('singlehtml', ConfSingleHTMLTranslator)\n    app.set_translator('pickle', ConfPickleTranslator)\n    app.set_translator('json', ConfJsonTranslator)\n    app.set_translator('latex', ConfLaTeXTranslator)\n    app.set_translator('man', ConfManualPageTranslator)\n    app.set_translator('texinfo', ConfTexinfoTranslator)\n    app.set_translator('text', ConfTextTranslator)\n    app.set_translator('xml', ConfXMLTranslator)\n    app.set_translator('pseudoxml', ConfPseudoXMLTranslator)\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self.post_transforms: list[type[Transform]] = []\n\n        #: source parsers; file type -> parser class\n        self.source_parsers: dict[str, type[Parser]] = {}\n\n        #: source suffix: suffix -> file type\n        self.source_suffix: dict[str, str] = {}\n\n        #: custom translators; builder name -> translator class\n        self.translators: dict[str, type[nodes.NodeVisitor]] = {}\n\n        #: custom handlers for translators\n        #: a dict of builder name -> dict of node name -> visitor and departure functions\n        self.translation_handlers: dict[str, dict[str, _NodeHandlerPair]] = {}\n\n        #: additional transforms; list of transforms\n        self.transforms: list[type[Transform]] = []\n\n    @property\n    def autodoc_attrgettrs(self) -> dict[type, Callable[[Any, str, Any], Any]]:\n        return self.autodoc_attrgetters\n\n    def add_builder(self, builder: type[Builder], override: bool = False) -> None:\n        logger.debug('[app] adding builder: %r', builder)\n        if not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n   "}, {"start_line": 0, "end_line": 31, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/writers", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Custom docutils writers.\"\"\"\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n    allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "i18n.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport os.path\nimport re\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nimport babel.dates\nfrom babel.messages.mofile import write_mo\nfrom babel.messages.pofile import read_po\n\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import SEP, _last_modified_time\n\nif TYPE_CHECKING:\n    import datetime as dt\n    from collections.abc import Iterator\n    from typing import Protocol, TypeAlias\n\n    from babel.core import Locale\n\n    from sphinx.environment import BuildEnvironment\n\n    class DateFormatter(Protocol):\n        def __call__(\n            self,\n            date: dt.date | None = ...,\n            format: str = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class TimeFormatter(Protocol):\n        def __call__(\n            self,\n            time: dt.time | dt.datetime | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class DatetimeFormatter(Protocol):\n        def __call__(\n            self,\n            datetime: dt.date | dt.time | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    Formatter: TypeAlias = DateFormatter | TimeFormatter | DatetimeFormatter\n\nfrom datetime import UTC\n\nlogger = logging.getLogger(__name__)\n\n\nclass CatalogInfo:\n    __slots__ = 'base_dir', 'domain', 'charset'\n\n    def __init__(\n        self, base_dir: str | os.PathLike[str], domain: str, charset: str\n    ) -> None:\n        self.base_dir = _StrPath(base_dir)\n        self.domain = domain\n        self.charset = charset\n\n    @property\n    def po_file(self) -> str:\n        return f'{self.domain}.po'\n\n    @property\n "}, {"start_line": 1000, "end_line": 2959, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                yield docname\n                continue\n            targetname = self.outdir / (docname + self.out_suffix)\n            try:\n                targetmtime = _last_modified_time(targetname)\n            except Exception:\n                targetmtime = 0\n            try:\n                srcmtime = _last_modified_time(self.env.doc2path(docname))\n                if srcmtime > targetmtime:\n                    yield docname\n            except OSError:\n                # source doesn't exist anymore\n                pass\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        return ''\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        self.current_docname = docname\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        visitor: TextTranslator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        output = visitor.body\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def finish(self) -> None:\n        pass\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_builder(TextBuilder)\n\n    app.add_config_value('text_sectionchars', '*=-~\"+`', 'env', types=frozenset({str}))\n    app.add_config_value('text_newlines', 'unix', 'env', types=frozenset({str}))\n    app.add_config_value('text_add_secnumbers', True, 'env', types=frozenset({bool}))\n    app.add_config_value('text_secnumber_suffix', '. ', 'env', types=frozenset({str}))\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport codecs\nimport pickle\nimport re\nimport time\nfrom contextlib import nullcontext\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, final\n\nfrom docutils import nodes\n\nfrom sphinx._cli.util.colour import bold\nfrom sphinx.deprecation import _deprecation_warning\nfrom sphinx.environment import (\n    CONFIG_CHANGED_REASON,\n    CONFIG_OK,\n    _CurrentDocument,\n)\nfrom sphinx.environment.adapters.asset import ImageAdapter\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import get_filetype, logging\nfrom sphinx.util._importer import import_object\nfrom sphinx.util._pathlib import _StrPathProperty\nfrom sphinx.util.build_phase import BuildPhase\nfrom sphinx.util.display import progress_message, status_iterator\nfrom sphinx.util.docutils import _parse_str_to_doctree\nfrom sphinx.util.i18n import CatalogRepository, docname_to_domain\nfrom sphinx.util.osutil import ensuredir, relative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n "}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     raise SphinxError(\n                __('Source parser for %s not registered') % filetype\n            ) from exc\n\n    def get_source_parsers(self) -> dict[str, type[Parser]]:\n        return self.source_parsers\n\n    def create_source_parser(\n        self, filename: str, *, config: Config, env: BuildEnvironment\n    ) -> Parser:\n        parser_class = self.get_source_parser(filename)\n        parser = parser_class()\n        if isinstance(parser, SphinxParser):\n            parser._config = config\n            parser._env = env\n        return parser\n\n    def add_translator(\n        self, name: str, translator: type[nodes.NodeVisitor], override: bool = False\n    ) -> None:\n        logger.debug('[app] Change of translator for the %s builder.', name)\n        if name in self.translators and not override:\n            raise ExtensionError(__('Translator for %r already exists') % name)\n        self.translators[name] = translator\n\n    def add_translation_handlers(\n        self, node: type[Element], **kwargs: _NodeHandlerPair\n    ) -> None:\n        logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)\n        for builder_name, handlers in kwargs.items():\n            translation_handlers = self.translation_handlers.setdefault(\n                builder_name, {}\n            )\n            try:\n                visit, depart = handlers  # unpack once for assertion\n                translation_handlers[node.__name__] = (visit, depart)\n            except ValueError as exc:\n                raise ExtensionError(\n                    __(\n                        'kwargs for add_node() must be a (visit, depart) '\n                        'function tuple: %r=%r'\n                    )\n                    % (builder_name, handlers),\n                ) from exc\n\n    def get_translator_class(\n        self, builder: type[Builder] | Builder\n    ) -> type[nodes.NodeVisitor]:\n        try:\n            return self.translators[builder.name]\n        except KeyError:\n            try:\n        "}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        if docnames:\n            logger.debug(__('docnames to write: %s'), ', '.join(sorted(docnames)))\n        else:\n            logger.debug(__('no docnames to write!'))\n\n        # add all toctree-containing files that may have changed\n        docnames |= {\n            toc_docname\n            for docname in docnames\n            for toc_docname in env.files_to_rebuild.get(docname, ())\n            if toc_docname in env.found_docs\n        }\n\n        # sort to ensure deterministic toctree generation\n        env.toctree_includes = dict(sorted(env.toctree_includes.items()))\n\n        with progress_message(__('preparing documents')):\n            self.prepare_writing(docnames)\n\n        with progress_message(__('copying assets'), nonl=False):\n            self.copy_assets()\n\n        if docnames:\n            self.write_documents(docnames)\n\n    def write_documents(self, docnames: Set[str]) -> None:\n        \"\"\"Write all documents in *docnames*.\n\n        This method can be overridden if a builder does not "}], "retrieved_count": 10, "cost_time": 1.019134283065796}
{"question": "What are the core components of Sphinx's document processing pipeline?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's document processing pipeline consists of several core components that work together to transform source documents into output formats. The main components include:\n\n1. **Sphinx Application (Sphinx class)**: The main application class that orchestrates the entire build process, manages extensions, and controls high-level functionality.\n\n2. **BuildEnvironment**: Responsible for parsing source documents, storing metadata about the document collection, and managing cross-references. It maintains the state of the build and is serialized to disk after each build.\n\n3. **Builder Classes**: Convert parsed documents into specific output formats (HTML, LaTeX, etc.). Each builder implements the core build workflow through methods like build(), read(), and write().\n\n4. **Parser System**: Handles different input formats (reStructuredText, Markdown) and converts them into docutils document trees.\n\n5. **Transform System**: Applies transformations to document trees during processing. This includes both regular transforms and post-transforms that handle cross-references and other document modifications.\n\n6. **Domain System**: Provides specialized functionality for different types of documentation (Python, C++, etc.) including cross-reference resolution and object descriptions.\n\n7. **Event System**: Manages the event-driven architecture that allows extensions to hook into various stages of the build process.\n\n8. **Configuration System**: Manages project settings and configuration values from conf.py files.\n\nThe pipeline follows a multi-phase build process: initialization, reading (parsing source files), consistency checks, resolving (cross-references), and writing (output generation).", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 3000, "end_line": 4540, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gs = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n    warnings.warn(\n        'sphinx.io.SphinxDummySourceClass is deprecated',\n        RemovedInSphinx10Warning,\n        stacklevel=2,\n    )\n    return source\n\n\nclass SphinxFileInput(FileInput):\n    \"\"\"A basic FileInput for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        kwargs['error_handler'] = 'sphinx'\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxFileInput is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docuti"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " # Create root document node\n    reporter = LoggingReporter(\n        source=str(filename),\n        report_level=settings.report_level,\n        halt_level=settings.halt_level,\n        debug=settings.debug,\n        error_handler=settings.error_encoding_error_handler,\n    )\n    document = nodes.document(settings, reporter, source=str(filename))\n    document.note_source(str(filename), -1)\n\n    # substitute transformer\n    document.transformer = transformer = SphinxTransformer(document)\n    transformer.add_transforms(_READER_TRANSFORMS)\n    transformer.add_transforms(transforms)\n    transformer.add_transforms(parser.get_transforms())\n\n    if default_role:\n        default_role_cm = rst.default_role(env.current_document.docname, default_role)\n    else:\n        default_role_cm = nullcontext()  # type: ignore[assignment]\n    with sphinx_domains(env), default_role_cm:\n        # TODO: Move the stanza below to Builder.read_doc(), within\n        #       a sphinx_domains() context manager.\n        #       This will require changes to IntersphinxDispatcher and/or\n        #       CustomReSTDispatcher.\n        if events is not None:\n            # emit \"source-read\" event\n            arg = [content]\n            events.emit('source-read', env.current_document.docname, arg)\n            content = arg[0]\n\n        # parse content to abstract syntax tree\n        parser.parse(content, document)\n        document.current_source = document.current_line = None\n\n        # run transforms\n        transformer.apply_transforms()\n\n    return document\n\n\ndef _get_settings(\n    *components: Component | type[Component],\n    defaults: Mapping[str, Any],\n    read_config_files: bool = False,\n) -> Values:\n    with warnings.catch_warnings(action='ignore', category=DeprecationWarning):\n        # DeprecationWarning: The frontend.OptionParser class will be replaced\n        # by a subclass of argparse.ArgumentParser in Docutils 0.21 or later.\n        # DeprecationWarning: The frontend.Option class will be removed"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".title),\n        }\n        return parts\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        # create the search indexer\n        self.indexer = None\n        if self.search:\n            from sphinx.search import IndexBuilder\n\n            lang = self.config.html_search_language or self.config.language\n            self.indexer = IndexBuilder(\n                self.env,\n                lang,\n                self.config.html_search_options,\n                self.config.html_search_scorer,\n            )\n            self.load_indexer(docnames)\n\n        self.docsettings = _get_settings(\n            HTMLWriter, defaults=self.env.settings, read_config_files=True\n        )\n        self.docsettings.compact_lists = bool(self.config.html_compact_lists)\n\n        # determine the additional indices to include\n        self.domain_indices = []\n        # html_domain_indices can be False/True or a list of index names\n        if indices_config := self.config.html_domain_indices:\n            if not isinstance(indices_config, bool):\n                check_names = True\n                indices_config = frozenset(indices_config)\n            else:\n                check_names = False\n            for domain in self.env.domains.sorted():\n                for index_cls in domain.indices:\n                    index_name = f'{domain.name}-{index_cls.name}'\n                    if check_names and index_name not in indices_config:\n                        continue\n                    content, collapse = index_cls(domain).generate()\n                    if content:\n                        self.domain_indices.append((\n                            index_name,\n                            index_cls,\n                            content,\n                            collapse,\n                        ))\n\n        # format the \"last updated on\" string, only once is enough since it\n        # typically doesn't include the time of day\n        last_updated: str | None\n        if (lu_fmt := self.config.html_las"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Input/Output files\"\"\"\n\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING\n\nfrom docutils.io import FileInput\nfrom docutils.readers import standalone\nfrom docutils.transforms.references import DanglingReferences\nfrom docutils.writers import UnfilteredWriter\n\nfrom sphinx.deprecation import RemovedInSphinx10Warning\nfrom sphinx.transforms import SphinxTransformer\nfrom sphinx.util import logging\nfrom sphinx.util.docutils import LoggingReporter\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from docutils import nodes\n    from docutils.frontend import Values\n    from docutils.io import Input\n    from docutils.parsers import Parser\n    from docutils.transforms import Transform\n\n    from sphinx.environment import BuildEnvironment\n\n\nlogger = logging.getLogger(__name__)\n\nwarnings.warn('sphinx.io is deprecated', RemovedInSphinx10Warning, stacklevel=2)\n\n\nclass SphinxBaseReader(standalone.Reader):  # type: ignore[misc]\n    \"\"\"A base class of readers for Sphinx.\n\n    This replaces reporter by Sphinx's on generating document.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxBaseReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    transforms: list[type[Transform]] = []\n\n    def get_transforms(self) -> list[type[Transform]]:\n        transforms = super().get_transforms() + self.transforms\n\n        # remove transforms which is not needed for Sphinx\n        unused = [DanglingReferences]\n        for transform in unused:\n            if transform in transforms:\n                transforms.remove(transform)\n\n        return transforms\n\n    def new_document(self) -> nodes.document:\n        \"\"\"Creates a new document object which has a special reporter object good\n        for logging.\n        \"\"\"\n        document = super().new_document()\n\n        # substitute transformer\n        document.transfor"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tuple of filename and attributes\n        self.css_files: list[tuple[str, dict[str, Any]]] = []\n\n        #: domains; a dict of domain name -> domain class\n        self.domains: dict[str, type[Domain]] = {}\n\n        #: additional directives for domains\n        #: a dict of domain name -> dict of directive name -> directive\n        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}\n\n        #: additional indices for domains\n        #: a dict of domain name -> list of index class\n        self.domain_indices: dict[str, list[type[Index]]] = {}\n\n        #: additional object types for domains\n        #: a dict of domain name -> dict of objtype name -> objtype\n        self.domain_object_types: dict[str, dict[str, ObjType]] = {}\n\n        #: additional roles for domains\n        #: a dict of domain name -> dict of role name -> role impl.\n        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}\n\n        #: additional enumerable nodes\n        #: a dict of node class"}], "retrieved_count": 10, "cost_time": 1.0621330738067627}
{"question": "What is the purpose of the SphinxTransformer class?", "answer": null, "relative_code_list": null, "ground_truth": "The SphinxTransformer class serves as a specialized transformer for Sphinx that extends the standard Docutils transformer functionality. Its primary purpose is to provide Sphinx-specific document tree transformations and ensure proper integration with Sphinx's build environment.\n\nKey purposes of the SphinxTransformer class include:\n\n1. **Environment Integration**: The SphinxTransformer maintains a reference to the Sphinx BuildEnvironment (`self.env`), allowing transforms to access Sphinx-specific data and functionality during the transformation process.\n\n2. **Document Wrapping**: The transformer can wrap target nodes in a document node during transformation when needed, ensuring that the transformation process works correctly even with partial document trees.\n\n3. **Settings Management**: The transformer ensures that the document settings include a reference to the Sphinx environment, making it available to transforms that need access to Sphinx-specific information.\n\n4. **Transform Application**: The transformer applies both regular transforms and post-transforms to document trees, handling the transformation pipeline in a way that's compatible with Sphinx's build process.\n\n5. **Node Processing**: It processes document trees by applying registered transforms in the correct order, ensuring that Sphinx-specific transformations (like cross-reference resolution) are applied at the appropriate stage.\n\n6. **Error Handling**: The transformer provides robust error handling for transformation operations, ensuring that the build process can continue even if individual transforms fail.\n\nThe SphinxTransformer is used throughout Sphinx's build process to apply various transformations to document trees, including cross-reference resolution, link processing, and other Sphinx-specific document modifications. It serves as the bridge between Docutils' transformation system and Sphinx's specialized document processing requirements.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hinx\n    from sphinx.config import Config\n    from sphinx.domains.std import StandardDomain\n    from sphinx.environment import BuildEnvironment\n    from sphinx.util.typing import ExtensionMetadata\n\n    _DEFAULT_SUBSTITUTION_NAMES: TypeAlias = Literal[\n        'version',\n        'release',\n        'today',\n        'translation progress',\n    ]\n\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_SUBSTITUTIONS = frozenset({\n    'version',\n    'release',\n    'today',\n    'translation progress',\n})\n\n\nclass SphinxTransform(Transform):\n    \"\"\"A base class of Transforms.\n\n    Compared with ``docutils.transforms.Transform``, this class improves accessibility to\n    Sphinx APIs.\n    \"\"\"\n\n    @property\n    def app(self) -> Sphinx:\n        \"\"\"Reference to the :class:`.Sphinx` object.\"\"\"\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self.env._app\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n        return self.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\"\"\"\n        return self.env.config\n\n\nclass SphinxTransformer(Transformer):\n    \"\"\"A transformer for Sphinx.\"\"\"\n\n    document: nodes.document\n    env: BuildEnvironment | None = None\n\n    def set_environment(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n    def apply_transforms(self) -> None:\n        if isinstance(self.document, nodes.document):\n            if not hasattr(self.document.settings, 'env') and self.env:\n                self.document.settings.env = self.env\n\n            super().apply_transforms()  # type: ignore[misc]\n        else:\n            # wrap the target node by document node during transforming\n            try:\n                from sphinx.util.docutils import new_document\n\n                document = new_document('"}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "x.\n\n    This replaces reporter by Sphinx's on generating document.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxBaseReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    transforms: list[type[Transform]] = []\n\n    def get_transforms(self) -> list[type[Transform]]:\n        transforms = super().get_transforms() + self.transforms\n\n        # remove transforms which is not needed for Sphinx\n        unused = [DanglingReferences]\n        for transform in unused:\n            if transform in transforms:\n                transforms.remove(transform)\n\n        return transforms\n\n    def new_document(self) -> nodes.document:\n        \"\"\"Creates a new document object which has a special reporter object good\n        for logging.\n        \"\"\"\n        document = super().new_document()\n\n        # substitute transformer\n        document.transformer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settin"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n        return self.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\"\"\"\n        return self.env.config\n\n\nclass SphinxTransformer(Transformer):\n    \"\"\"A transformer for Sphinx.\"\"\"\n\n    document: nodes.document\n    env: BuildEnvironment | None = None\n\n    def set_environment(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n    def apply_transforms(self) -> None:\n        if isinstance(self.document, nodes.document):\n            if not hasattr(self.document.settings, 'env') and self.env:\n                self.document.settings.env = self.env\n\n            super().apply_transforms()  # type: ignore[misc]\n        else:\n            # wrap the target node by document node during transforming\n            try:\n                from sphinx.util.docutils import new_document\n\n                document = new_document('')\n                if self.env:\n                    document.settings.env = self.env\n                document += self.document\n                self.document = document\n                super().apply_transforms()\n            finally:\n                self.document = self.document[0]\n\n\nclass DefaultSubstitutions(SphinxTransform):\n    \"\"\"Replace some substitutions if they aren't defined in the document.\"\"\"\n\n    # run before the default Substitutions\n    default_priority = 210\n\n    def apply(self, **kwargs: Any) -> None:\n        # only handle those not otherwise defined in the document\n        to_handle = _DEFAULT_SUBSTITUTIONS - set(self.document.substitution_defs)\n        for ref in self.document.findall(nodes.substitution_reference):\n            if (name := ref['refname']) in to_handle:\n                ref.replace_self(self._handle_default_substitution(name))\n\n    def _handle_default_substitution(\n        self, name: _DEFAULT_SUBSTITUTION_NAMES\n    ) -> nodes.Text:\n        if name == 'tra"}, {"start_line": 0, "end_line": 1438, "belongs_to": {"file_name": "references.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Docutils transforms used by Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom docutils.transforms.references import DanglingReferences\n\nfrom sphinx.transforms import SphinxTransform\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from sphinx.application import Sphinx\n    from sphinx.util.typing import ExtensionMetadata\n\n\nclass SphinxDanglingReferences(DanglingReferences):\n    \"\"\"DanglingReferences transform which does not output info messages.\"\"\"\n\n    def apply(self, **kwargs: Any) -> None:\n        try:\n            reporter = self.document.reporter\n            report_level = reporter.report_level\n\n            # suppress INFO level messages for a while\n            reporter.report_level = max(reporter.WARNING_LEVEL, reporter.report_level)\n            super().apply()\n        finally:\n            reporter.report_level = report_level\n\n\nclass SphinxDomains(SphinxTransform):\n    \"\"\"Collect objects to Sphinx domains for cross references.\"\"\"\n\n    default_priority = 850\n\n    def apply(self, **kwargs: Any) -> None:\n        self.env.domains._process_doc(\n            self.env, self.env.current_document.docname, self.document\n        )\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_transform(SphinxDanglingReferences)\n    app.add_transform(SphinxDomains)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  __('Footnote [#] is not referenced.'),\n                    type='ref',\n                    subtype='footnote',\n                    location=node,\n                )\n\n\nclass DoctestTransform(SphinxTransform):\n    \"\"\"Set \"doctest\" style to each doctest_block node\"\"\"\n\n    default_priority = 500\n\n    def apply(self, **kwargs: Any) -> None:\n        for node in self.document.findall(nodes.doctest_block):\n            node['classes'].append('doctest')\n\n\nclass FilterSystemMessages(SphinxTransform):\n    \"\"\"Filter system messages from a doctree.\"\"\"\n\n    default_priority = 999\n\n    def apply(self, **kwargs: Any) -> None:\n        filterlevel = 2 if self.config.keep_warnings else 5\n        for node in list(self.document.findall(nodes.system_message)):\n            if node['level'] < filterlevel:\n                logger.debug('%s [filtered system message]', node.astext())\n                node.parent.remove(node)\n\n\nclass SphinxContentsFilter(ContentsFilter):\n    \"\"\"Used with BuildEnvironment.add_toc_from() to discard cross-file links\n    within table-of-contents link nodes.\n    \"\"\"\n\n    visit_pending_xref = ContentsFilter.ignore_node_but_process_children\n\n    def visit_image(self, node: nodes.image) -> None:\n        raise nodes.SkipNode\n\n\nclass SphinxSmartQuotes(SmartQuotes, SphinxTransform):\n    \"\"\"Customized SmartQuotes to avoid transform for some extra node types.\n\n    refs: sphinx.parsers.RSTParser\n    \"\"\"\n\n    default_priority = 750\n\n    def apply(self, **kwargs: Any) -> None:\n        if not self.is_available():\n            return\n\n        # override default settings with :confval:`smartquotes_action`\n        self.smartquotes_action = self.config.smartquotes_action\n\n        super().apply()\n\n    def is_available(self) -> bool:\n        builders = self.config.smartquotes_excludes.get('builders', [])\n        languages = self.config.smartquotes_excludes.get('languages', [])\n\n        if self.document.settings.smart_quotes is False:\n            # disabled by 3rd party extension (worka"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tead of null-escapes\n                text = re.sub(r'(?<=\\x00)([-\\\\\\'\".`])', r'\\\\\\1', str(txtnode))\n                yield 'plain', text\n            else:\n                # skip smart quotes\n                yield 'literal', txtnode.astext()\n\n\nclass DoctreeReadEvent(SphinxTransform):\n    \"\"\"Emit :event:`doctree-read` event.\"\"\"\n\n    default_priority = 880\n\n    def apply(self, **kwargs: Any) -> None:\n        self.env.events.emit('doctree-read', self.document)\n\n\nclass GlossarySorter(SphinxTransform):\n    \"\"\"Sort glossaries that have the ``sorted`` flag.\"\"\"\n\n    # This must be done after i18n, therefore not right\n    # away in the glossary directive.\n    default_priority = 500\n\n    def apply(self, **kwargs: Any) -> None:\n        for glossary in self.document.findall(addnodes.glossary):\n            if glossary['sorted']:\n                definition_list = cast('nodes.definition_list', glossary[0])\n                definition_list[:] = sorted(\n                    definition_list,\n                    key=lambda item: unicodedata.normalize(\n                        'NFD', cast('nodes.term', item)[0].astext().lower()\n                    ),\n                )\n\n\nclass ReorderConsecutiveTargetAndIndexNodes(SphinxTransform):\n    \"\"\"Index nodes interspersed between target nodes prevent other\n    Transformations from combining those target nodes,\n    e.g. ``PropagateTargets``.  This transformation reorders them:\n\n    Given the following ``document`` as input::\n\n        <document>\n            <target ids=\"id1\" ...>\n            <index entries=\"...1...\">\n            <target ids=\"id2\" ...>\n            <target ids=\"id3\" ...>\n            <index entries=\"...2...\">\n            <target ids=\"id4\" ...>\n\n    The transformed result will be::\n\n        <document>\n            <index entries=\"...1...\">\n            <index entries=\"...2...\">\n            <target ids=\"id1\" ...>\n            <target ids=\"id2\" ...>\n            <target ids=\"id3\" ...>\n            <target ids=\"id4\" ...>\n    \"\"\"\n\n    # This transf"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Docutils transforms used by Sphinx when reading documents.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport unicodedata\nfrom typing import TYPE_CHECKING, cast\n\nfrom docutils import nodes\nfrom docutils.transforms import Transform, Transformer\nfrom docutils.transforms.parts import ContentsFilter\nfrom docutils.transforms.references import Footnotes\nfrom docutils.transforms.universal import SmartQuotes\nfrom docutils.utils import normalize_language_tag\nfrom docutils.utils.smartquotes import smartchars\n\nfrom sphinx import addnodes\nfrom sphinx.deprecation import _deprecation_warning\nfrom sphinx.locale import _, __\nfrom sphinx.util import logging\nfrom sphinx.util.i18n import format_date\nfrom sphinx.util.nodes import apply_source_workaround, is_smartquotable\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator\n    from typing import Any, Literal, TypeAlias\n\n    from docutils.nodes import Node, Text\n    from typing_extensions import TypeIs\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.domains.std import StandardDomain\n    from sphinx.environment import BuildEnvironment\n    from sphinx.util.typing import ExtensionMetadata\n\n    _DEFAULT_SUBSTITUTION_NAMES: TypeAlias = Literal[\n        'version',\n        'release',\n        'today',\n        'translation progress',\n    ]\n\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_SUBSTITUTIONS = frozenset({\n    'version',\n    'release',\n    'today',\n    'translation progress',\n})\n\n\nclass SphinxTransform(Transform):\n    \"\"\"A base class of Transforms.\n\n    Compared with ``docutils.transforms.Transform``, this class improves accessibility to\n    Sphinx APIs.\n    \"\"\"\n\n    @property\n    def app(self) -> Sphinx:\n        \"\"\"Reference to the :class:`.Sphinx` object.\"\"\"\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self.env._app\n\n    @property\n   "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "i18n.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Docutils transforms used by Sphinx when reading documents.\"\"\"\n\nfrom __future__ import annotations\n\nfrom re import DOTALL, match\nfrom textwrap import indent\nfrom typing import TYPE_CHECKING, Any, TypeVar\n\nimport docutils.utils\nfrom docutils import nodes\n\nfrom sphinx import addnodes\nfrom sphinx.domains.std import make_glossary_term, split_term_classifiers\nfrom sphinx.errors import ConfigError\nfrom sphinx.locale import __\nfrom sphinx.locale import init as init_locale\nfrom sphinx.transforms import SphinxTransform\nfrom sphinx.util import get_filetype, logging\nfrom sphinx.util.docutils import LoggingReporter\nfrom sphinx.util.i18n import docname_to_domain\nfrom sphinx.util.index_entries import split_index_msg\nfrom sphinx.util.nodes import (\n    IMAGE_TYPE_NODES,\n    LITERAL_TYPE_NODES,\n    NodeMatcher,\n    extract_messages,\n    traverse_translatable_index,\n)\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n\n    from docutils.frontend import Values\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import BuildEnvironment\n    from sphinx.registry import SphinxComponentRegistry\n    from sphinx.util.typing import ExtensionMetadata\n\n\nlogger = logging.getLogger(__name__)\n\n# The attributes not copied to the translated node\n#\n# * refexplict: For allow to give (or not to give) an explicit title\n#               to the pending_xref on translation\nEXCLUDED_PENDING_XREF_ATTRIBUTES = ('refexplicit',)\n\n\nN = TypeVar('N', bound=nodes.Node)\n\n\ndef _publish_msgstr(\n    source: str,\n    source_path: str,\n    source_line: int,\n    *,\n    config: Config,\n    env: BuildEnvironment,\n    registry: SphinxComponentRegistry,\n    settings: Values,\n) -> nodes.Element:\n    \"\"\"Publish msgstr (single line) into docutils document\n\n    :param str source: source text\n    :param str source_path: source path for warning indication\n    :param source_line: source line for warning indication\n    :param docutils.frontend.Values settings: docutil"}], "retrieved_count": 10, "cost_time": 1.0456922054290771}
{"question": "What is Sphinx's approach to handling large documentation projects?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx employs several strategies to efficiently handle large documentation projects:\n\n1. **Incremental Build System**: Sphinx uses an incremental build approach where only new or changed source files are processed. The system tracks which files have been modified since the last build and only rebuilds those files, significantly reducing build times for large projects.\n\n2. **Environment Caching**: Sphinx caches the build environment (containing cross-references, metadata, and other build state) as a pickle file. This allows the system to skip the expensive parsing and analysis phase for unchanged files.\n\n3. **Parallel Processing**: Sphinx supports parallel document processing using the `--jobs` or `-j` option. This distributes the build across multiple processes, making it more effective on multiprocessor machines. The system can automatically detect the number of CPU cores and use them optimally.\n\n4. **Document Tree Serialization**: Sphinx implements document tree serialization for distributed builds, allowing the parsed document trees to be shared between parallel processes and merged efficiently.\n\n5. **Doctree Caching**: Parsed source files are cached as \"doctree pickles\" in a `.doctrees` directory. These cached files can be shared between different builders and significantly speed up subsequent builds.\n\n6. **Memory Management**: The parallel processing system is designed to reduce memory usage and CPU utilization by distributing the workload across multiple processes, preventing any single process from consuming excessive resources.\n\n7. **Selective Rebuilding**: Users can specify individual files to rebuild using the `--write-all` option or by providing specific filenames, allowing for targeted rebuilding of only the necessary components.\n\n8. **Fresh Environment Option**: For cases where the cached environment might be corrupted or when a complete rebuild is needed, Sphinx provides the `--fresh-env` option to rebuild the environment completely.\n\nThese approaches work together to make Sphinx capable of handling documentation projects with thousands of files while maintaining reasonable build times and resource usage.", "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 0, "end_line": 163, "belongs_to": {"file_name": "__main__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"The Sphinx documentation toolchain.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nfrom sphinx.cmd.build import main\n\nraise SystemExit(main(sys.argv[1:]))\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Sphinx documentation build configuration file\nfrom __future__ import annotations\n\nimport os\nimport re\nfrom typing import TYPE_CHECKING\n\nfrom sphinx import __display_version__\n\nos.environ['SPHINX_AUTODOC_RELOAD_MODULES'] = '1'\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.todo',\n    'sphinx.ext.autosummary',\n    'sphinx.ext.extlinks',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.viewcode',\n    'sphinx.ext.inheritance_diagram',\n    'sphinx.ext.coverage',\n    'sphinx.ext.graphviz',\n]\ncoverage_statistics_to_report = coverage_statistics_to_stdout = True\ntemplates_path = ['_templates']\nexclude_patterns = ['_build']\n\nproject = 'Sphinx'\ncopyright = '2007-%Y, the Sphinx developers'\nrelease = version = __display_version__\nshow_authors = True\nnitpicky = True\nshow_warning_types = True\n\nhtml_theme = 'sphinx13'\nhtml_theme_path = ['_themes']\nhtml_css_files = [\n    # 'basic.css',  # included through inheritance from the basic theme\n    'sphinx13.css',\n]\nmodindex_common_prefix = ['sphinx.']\nhtml_static_path = ['_static']\nhtml_title = 'Sphinx documentation'\nhtml_additional_pages = {'contents': 'contents.html'}\nhtml_use_opensearch = 'https://www.sphinx-doc.org/en/master'\nhtml_baseurl = 'https://www.sphinx-doc.org/en/master/'\nhtml_favicon = '_static/favicon.svg'\n\nhtmlhelp_basename = 'Sphinxdoc'\n\nepub_theme = 'epub'\nepub_basename = 'sphinx'\nepub_author = 'the Sphinx developers'\nepub_publisher = 'https://www.sphinx-doc.org/'\nepub_uid = 'web-site'\nepub_scheme = 'url'\nepub_identifier = epub_publisher\nepub_pre_files = [('index.xhtml', 'Welcome')]\nepub_post_files = [\n    ('usage/installation.xhtml', 'Installing Sphinx'),\n    ('develop.xhtml', 'Sphinx development'),\n]\nepub_exclude_files = [\n    '_static/opensearch.xml',\n    '_static/doctools.js',\n    '_static/searchtools.js',\n    '_static/sphinx_highlight.js',\n    '_static/basic.css',\n    '_static/language_data.js',\n    'search.html',\n    '_static/websupport.js',\n]\nepub_fix_images = False\nepub_max_imag"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "x_common_prefix = ['sphinx.']\nhtml_static_path = ['_static']\nhtml_title = 'Sphinx documentation'\nhtml_additional_pages = {'contents': 'contents.html'}\nhtml_use_opensearch = 'https://www.sphinx-doc.org/en/master'\nhtml_baseurl = 'https://www.sphinx-doc.org/en/master/'\nhtml_favicon = '_static/favicon.svg'\n\nhtmlhelp_basename = 'Sphinxdoc'\n\nepub_theme = 'epub'\nepub_basename = 'sphinx'\nepub_author = 'the Sphinx developers'\nepub_publisher = 'https://www.sphinx-doc.org/'\nepub_uid = 'web-site'\nepub_scheme = 'url'\nepub_identifier = epub_publisher\nepub_pre_files = [('index.xhtml', 'Welcome')]\nepub_post_files = [\n    ('usage/installation.xhtml', 'Installing Sphinx'),\n    ('develop.xhtml', 'Sphinx development'),\n]\nepub_exclude_files = [\n    '_static/opensearch.xml',\n    '_static/doctools.js',\n    '_static/searchtools.js',\n    '_static/sphinx_highlight.js',\n    '_static/basic.css',\n    '_static/language_data.js',\n    'search.html',\n    '_static/websupport.js',\n]\nepub_fix_images = False\nepub_max_image_width = 0\nepub_show_urls = 'inline'\nepub_use_index = False\nepub_description = 'Sphinx documentation generator system manual'\n\nlatex_documents = [\n    (\n        'index',\n        'sphinx.tex',\n        'Sphinx Documentation',\n        'the Sphinx developers',\n        'manual',\n        1,\n    )\n]\nlatex_logo = '_static/sphinx.png'\nlatex_elements = {\n    'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n    'passoptionstopackages': r\"\"\"\n\\PassOptionsToPackage{svgnames}{xcolor}\n\"\"\",\n    'preamble': r\"\"\"\n\\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}\n\\setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)\n\\setcounter{secnumdepth}{1}% depth of section numbering\n\\setlength{\\tymin}{2cm}%     avoid too cramped table columns\n\"\"\",\n    # fix missing index entry due to RTD doing only once pdflatex after makeindex\n    'printindex': r\"\"\"\n\\IfFileExists{\\jobname.ind}\n             {\\footnotesize\\raggedright\\printindex}\n             {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n\"\"\",\n}"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_width = 0\nepub_show_urls = 'inline'\nepub_use_index = False\nepub_description = 'Sphinx documentation generator system manual'\n\nlatex_documents = [\n    (\n        'index',\n        'sphinx.tex',\n        'Sphinx Documentation',\n        'the Sphinx developers',\n        'manual',\n        1,\n    )\n]\nlatex_logo = '_static/sphinx.png'\nlatex_elements = {\n    'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n    'passoptionstopackages': r\"\"\"\n\\PassOptionsToPackage{svgnames}{xcolor}\n\"\"\",\n    'preamble': r\"\"\"\n\\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}\n\\setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)\n\\setcounter{secnumdepth}{1}% depth of section numbering\n\\setlength{\\tymin}{2cm}%     avoid too cramped table columns\n\"\"\",\n    # fix missing index entry due to RTD doing only once pdflatex after makeindex\n    'printindex': r\"\"\"\n\\IfFileExists{\\jobname.ind}\n             {\\footnotesize\\raggedright\\printindex}\n             {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n\"\"\",\n}\nlatex_show_urls = 'footnote'\nlatex_use_xindy = True\n\nlinkcheck_timeout = 5\nlinkcheck_ignore = [\n    r'^contents\\.html$',  # extra generated page\n    r'^\\.\\./contents\\.html$',\n    re.escape('https://gitlab.com/projects/new'),  # requires sign-in\n    re.escape('https://web.libera.chat/?channel=#sphinx-doc'),\n]\nlinkcheck_anchors_ignore_for_url = [\n    # anchors in Markdown files cannot be accessed directly\n    'https://github.com/Khan/style-guides/blob/master/style/python.md',\n]\n\nautodoc_member_order = 'groupwise'\nautosummary_generate = False\ntodo_include_todos = 'READTHEDOCS' not in os.environ\nextlinks = {\n    'dupage': ('https://docutils.sourceforge.io/docs/ref/rst/%s.html', '%s'),\n    'duref': (\n        'https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#%s',\n        '%s',\n    ),\n    'durole': ('https://docutils.sourceforge.io/docs/ref/rst/roles.html#%s', '%s'),\n    'dudir': ('https://docutils.sourceforge.io/docs/ref/rst/directives.html#%s', '%s'),\n}\n\nman_pages = [\n   "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rents': [],\n            'prev': None,\n            'next': None,\n            'docstitle': None,\n            'title': self.config.html_title,\n            'meta': None,\n            'body': body,\n            'metatags': metatags,\n            'rellinks': [],\n            'sourcename': '',\n            'toc': toc,\n            'display_toc': display_toc,\n        }\n\n    def write_documents(self, _docnames: Set[str]) -> None:\n        self.prepare_writing(self.env.all_docs.keys())\n\n        with progress_message(__('assembling single document'), nonl=False):\n            doctree = self.assemble_doctree()\n            self.env.toc_secnumbers = self.assemble_toc_secnumbers()\n            self.env.toc_fignumbers = self.assemble_toc_fignumbers()\n\n        with progress_message(__('writing')):\n            self.write_doc_serialized(self.config.root_doc, doctree)\n            self.write_doc(self.config.root_doc, doctree)\n\n    def finish(self) -> None:\n        self.write_additional_files()\n        self.copy_image_files()\n        self.copy_download_files()\n        self.copy_static_files()\n        self.copy_extra_files()\n        self.write_buildinfo()\n        self.dump_inventory()\n\n    @progress_message(__('writing additional files'))\n    def write_additional_files(self) -> None:\n        # no indices or search pages are supported\n\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info(' %s', pagename, nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        if self.config.html_use_opensearch:\n            logger.info(' opensearch', nonl=True)\n            self.handle_page(\n                'opensearch',\n                {},\n                'opensearch.xml',\n                outfilename=self._static_dir / 'opensearch.xml',\n            )\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.setup_extension('sphinx.builders.html')\n\n    app.add_builder(SingleFileHTMLBuilder)\n    app.add_config_value(\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir: Directory for caching pickled doctrees.\n        :param buildername: The name of the builder to use.\n        :param confoverrides: A dictionary of configuration settings that override the\n            settings in the configuration file.\n        :param status: A file-like object to write status messages to.\n        :param warning: A file-like object to write warnings to.\n        :param freshenv: If true, clear the cached environment.\n        :param warningiserror: If true, warnings become errors.\n        :param tags: A list of tags to apply.\n        :param verbosity: The verbosity level.\n        :param parallel: The maximum number of parallel jobs to use\n            when reading/writing documents.\n        :param keep_going: Unused.\n        :param pdb: If true, enable the Python debugger on an exception.\n        :param exception_on_warning: If true, raise an exception on warnings.\n        \"\"\"\n        self.verbosity = verbosity\n        self._fresh_env_used: bool | None = None\n        self."}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build documentation from a provided source.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport contextlib\nimport locale\nimport multiprocessing\nimport sys\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nimport sphinx._cli.util.errors\nimport sphinx.locale\nfrom sphinx import __display_version__\nfrom sphinx._cli.util.colour import disable_colour, terminal_supports_colour\nfrom sphinx.application import Sphinx\nfrom sphinx.locale import __\nfrom sphinx.util._io import TeeStripANSI\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.docutils import docutils_namespace, patch_docutils\nfrom sphinx.util.osutil import ensuredir\n\nif TYPE_CHECKING:\n    from collections.abc import Collection, Sequence\n    from typing import Any, TextIO\n\n    from sphinx.extension import Extension\n\n\ndef handle_exception(\n    app: Sphinx | None,\n    args: Any,\n    exception: BaseException,\n    stderr: TextIO = sys.stderr,\n) -> None:\n    if app is not None:\n        message_log: Sequence[str] = app.messagelog\n        extensions: Collection[Extension] = app.extensions.values()\n    else:\n        message_log = extensions = ()\n    return sphinx._cli.util.errors.handle_exception(\n        exception,\n        stderr=stderr,\n        use_pdb=args.pdb,\n        print_traceback=args.verbosity or args.traceback,\n        message_log=message_log,\n        extensions=extensions,\n    )\n\n\ndef jobs_argument(value: str) -> int:\n    \"\"\"Parse the ``--jobs`` flag.\n\n    Return the number of CPUs if 'auto' is used,\n    otherwise ensure *value* is a positive integer.\n    \"\"\"\n    if value == 'auto':\n        return multiprocessing.cpu_count()\n    else:\n        jobs = int(value)\n        if jobs <= 0:\n            raise argparse.ArgumentTypeError(\n                __('job number should be a positive number')\n            )\n        else:\n            return jobs\n\n\ndef get_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        usage='%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAME"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (\n        'index',\n        'sphinx-all',\n        'Sphinx documentation generator system manual',\n        'the Sphinx developers',\n        1,\n    ),\n    ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool', '', 1),\n    (\n        'man/sphinx-quickstart',\n        'sphinx-quickstart',\n        'Sphinx documentation template generator',\n        '',\n        1,\n    ),\n    ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool', '', 1),\n    ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages', '', 1),\n]\n\ntexinfo_documents = [\n    (\n        'index',\n        'sphinx',\n        'Sphinx Documentation',\n        'the Sphinx developers',\n        'Sphinx',\n        'The Sphinx documentation builder.',\n        'Documentation tools',\n        True,\n    ),\n]\n\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/3/', None),\n    'requests': ('https://requests.readthedocs.io/en/latest/', None),\n    'readthedocs': ('https://docs.readthedocs.io/en/stable', None),\n}\n\n# Sphinx document translation with sphinx gettext feature uses these settings:\ngettext_compact = False\n\nnitpick_ignore = {\n    (\n        'cpp:class',\n        'template<typename TOuter> template<typename TInner> Wrapper::Outer<TOuter>::Inner',\n    ),\n    ('cpp:identifier', 'MyContainer'),\n    ('js:func', 'SomeError'),\n    ('js:func', 'number'),\n    ('js:func', 'string'),\n    ('py:attr', 'srcline'),\n    ('py:class', '_AutodocProcessDocstringListener'),\n    ('py:class', '_ConfigRebuild'),  # sphinx.application.Sphinx.add_config_value\n    # sphinx.application.Sphinx.add_html_math_renderer\n    ('py:class', '_MathsBlockRenderers'),\n    # sphinx.application.Sphinx.add_html_math_renderer\n    ('py:class', '_MathsInlineRenderers'),\n    ('py:class', '_NodeHandler'),  # sphinx.application.Sphinx.add_enumerable_node\n    ('py:class', '_NodeHandlerPair'),  # sphinx.application.Sphinx.add_node\n    ('py:class', '_StrPath'),  # sphinx.environment.BuildEnvironment.doc2path\n    ('py:cl"}], "retrieved_count": 10, "cost_time": 1.0756211280822754}
{"question": "What is the role of the BuildEnvironment class in Sphinx?", "answer": null, "relative_code_list": null, "ground_truth": "The BuildEnvironment class serves as the central data store and state manager for Sphinx's document processing system. It plays a crucial role in managing the build process and maintaining consistency across builds.\n\nKey responsibilities of the BuildEnvironment class include:\n\n1. **Document State Management**: The environment tracks which documents have been read, their dependencies, and their modification times. It maintains collections like `all_docs`, `dependencies`, and `included` to track document relationships and changes.\n\n2. **Cross-Reference Storage**: The environment stores all metadata about the document collection, including cross-references, labels, headings, described objects, and index entries. This information is used to resolve cross-references during the build process.\n\n3. **Domain Data Management**: The environment manages domain-specific data through the `domaindata` attribute, which stores information for each domain (Python, C++, etc.) about objects, references, and other domain-specific metadata.\n\n4. **Incremental Build Support**: The environment is serialized to disk after each build as a pickle file, allowing Sphinx to skip expensive parsing and analysis phases for unchanged files in subsequent builds.\n\n5. **Configuration Integration**: The environment maintains a reference to the current configuration and tracks configuration changes to determine what needs to be rebuilt.\n\n6. **Document Tree Caching**: The environment provides methods to cache and retrieve parsed document trees, optimizing memory usage and build performance.\n\n7. **Extension Support**: The environment provides an API that extensions can use to cache information that should persist for incremental rebuilds, allowing extensions to store their own metadata.\n\n8. **Reference Resolution**: The environment provides methods for resolving cross-references and managing the relationships between different document elements.\n\nThe BuildEnvironment is instantiated by the Sphinx application and is available as `app.env` or `builder.env`. It serves as the foundation for Sphinx's incremental build system and provides the data persistence mechanism that makes efficient rebuilding possible.", "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lf._search_index_filenames: dict[str, str] = {}\n        # stemmed words -> set(docname)\n        self._search_index_mapping: dict[str, set[str]] = {}\n        # stemmed words in titles -> set(docname)\n        self._search_index_title_mapping: dict[str, set[str]] = {}\n        # docname -> all titles in document\n        self._search_index_all_titles: dict[str, list[tuple[str, str | None]]] = {}\n        # docname -> list(index entry)\n        self._search_index_index_entries: dict[str, list[tuple[str, str, str]]] = {}\n        # objtype -> index\n        self._search_index_objtypes: dict[tuple[str, str], int] = {}\n        # objtype index -> (domain, type, objname (localized))\n        self._search_index_objnames: dict[int, tuple[str, str, str]] = {}\n\n        # all the registered domains, set by the application\n        self.domains: _DomainsContainer = _DomainsContainer._from_environment(\n            self, registry=app.registry\n        )\n\n        # set up environment\n        self.setup(app)\n\n    def __getstate__(self) -> dict[str, Any]:\n        \"\"\"Obtains serializable data for pickling.\"\"\"\n        __dict__ = self.__dict__.copy()\n        # clear unpickleable attributes\n        __dict__.update(_app=None, domains=None, events=None)\n        # clear in-memory doctree caches, to reduce memory consumption and\n        # ensure that, upon restoring the state, the most recent pickled files\n        # on the disk are used instead of those from a possibly outdated state\n        __dict__.update(_pickled_doctree_cache={}, _write_doc_doctree_cache={})\n        return __dict__\n\n    def __setstate__(self, state: dict[str, Any]) -> None:\n        self.__dict__.update(state)\n\n    def setup(self, app: Sphinx) -> None:\n        \"\"\"Set up BuildEnvironment object.\"\"\"\n        if self.version and self.version != _get_env_version(app.extensions):\n            raise BuildEnvironmentError(__('build environment version not current'))\n        if self.srcdir and self.srcdir != app.srcdir:\n            raise Buil"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    'text': is_translatable,\n}\n\n\nclass BuildEnvironment:\n    \"\"\"The environment in which the ReST files are translated.\n    Stores an inventory of cross-file targets and provides doctree\n    transformations to resolve links to them.\n    \"\"\"\n\n    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n\n    srcdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    # builder is created after the environment.\n    _builder_cls: type[Builder]\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app: Sphinx = app\n        self.doctreedir = app.doctreedir\n        self.srcdir = app.srcdir\n        self.config: Config = None  # type: ignore[assignment]\n        self.config_status: int = CONFIG_UNSET\n        self.config_status_extra: str = ''\n        self.events: EventManager = app.events\n        self.project: Project = app.project\n        self.version: Mapping[str, int] = _get_env_version(app.extensions)\n\n        # the method of doctree versioning; see set_versioning_method\n        self.versioning_condition: Literal[False] | Callable[[Node], bool] | None = None\n        self.versioning_compare: bool | None = None\n\n        # the docutils settings for building\n        self.settings: dict[str, Any] = default_settings.copy()\n        self.settings['env'] = self\n\n        # All \"docnames\" here are /-separated and relative and exclude\n        # the source suffix.\n\n        # docname -> time of reading (in integer microseconds)\n        # contains all read docnames\n        self.all_docs: dict[str, int] = {}\n        # docname -> set of dependent file\n        # names, relative to documentation root\n        self.dependencies: dict[str, set[_StrPath]] = defaultdict(set)\n        # docname -> set of included file\n        # docnames included from other documents\n        self.included: dict[str, set[str]] = defaultdict(set)\n        # docnames to re-read unconditionally on next build\n        self.reread_always: set[str] = set()\n\n        self._pickled_doctree_c"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "refix': 'id',\n    'image_loading': 'link',\n    'embed_stylesheet': False,\n    'cloak_email_addresses': True,\n    'pep_base_url': 'https://peps.python.org/',\n    'pep_references': None,\n    'rfc_base_url': 'https://datatracker.ietf.org/doc/html/',\n    'rfc_references': None,\n    'input_encoding': 'utf-8-sig',\n    'doctitle_xform': False,\n    'sectsubtitle_xform': False,\n    'section_self_link': False,\n    'halt_level': 5,\n    'file_insertion_enabled': True,\n    'smartquotes_locales': [],\n}\n\n# This is increased every time an environment attribute is added\n# or changed to properly invalidate pickle files.\nENV_VERSION = 66\n\n# config status\nCONFIG_UNSET = -1\nCONFIG_OK = 1\nCONFIG_NEW = 2\nCONFIG_CHANGED = 3\nCONFIG_EXTENSIONS_CHANGED = 4\n\nCONFIG_CHANGED_REASON = {\n    CONFIG_NEW: __('new config'),\n    CONFIG_CHANGED: __('config changed'),\n    CONFIG_EXTENSIONS_CHANGED: __('extensions changed'),\n}\n\n\nversioning_conditions: dict[str, Literal[False] | Callable[[Node], bool]] = {\n    'none': False,\n    'text': is_translatable,\n}\n\n\nclass BuildEnvironment:\n    \"\"\"The environment in which the ReST files are translated.\n    Stores an inventory of cross-file targets and provides doctree\n    transformations to resolve links to them.\n    \"\"\"\n\n    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n\n    srcdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    # builder is created after the environment.\n    _builder_cls: type[Builder]\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app: Sphinx = app\n        self.doctreedir = app.doctreedir\n        self.srcdir = app.srcdir\n        self.config: Config = None  # type: ignore[assignment]\n        self.config_status: int = CONFIG_UNSET\n        self.config_status_extra: str = ''\n        self.events: EventManager = app.events\n        self.project: Project = app.project\n        self.version: Mapping[str, int] = _get_env_version(app.extensions)\n\n        # the method of doctree versioning; see set_ve"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me: Path) -> BuildEnvironment:\n        try:\n            with open(filename, 'rb') as f:\n                env = pickle.load(f)\n            env.setup(self)\n            self._fresh_env_used = False\n        except Exception as err:\n            logger.info(__('failed: %s'), err)\n            env = self._create_fresh_env()\n        return env\n\n    def _post_init_env(self) -> None:\n        if self._fresh_env_used:\n            self.env.find_files(self.config, self.builder)\n\n        self.env._builder_cls = self.builder.__class__\n\n    def preload_builder(self, name: str) -> None:\n        self.registry.preload_builder(self, name)\n\n    def create_builder(self, name: str) -> Builder:\n        if name is None:\n            logger.info(__('No builder selected, using default: html'))\n            name = 'html'\n\n        return self.registry.create_builder(self, name, self.env)\n\n    def _init_builder(self) -> None:\n        self.builder.init()\n        self.events.emit('builder-inited')\n\n    # ---- main \"build\" method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_environment.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test the BuildEnvironment class.\"\"\"\n\nfrom __future__ import annotations\n\nimport shutil\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nimport pytest\n\nfrom sphinx._cli.util.errors import strip_escape_sequences\nfrom sphinx.builders.html import StandaloneHTMLBuilder\nfrom sphinx.builders.latex import LaTeXBuilder\nfrom sphinx.config import Config\nfrom sphinx.environment import (\n    CONFIG_CHANGED,\n    CONFIG_EXTENSIONS_CHANGED,\n    CONFIG_NEW,\n    CONFIG_OK,\n    _differing_config_keys,\n)\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n    from sphinx.testing.fixtures import _app_params\n    from sphinx.testing.util import SphinxTestApp\n\n\n@pytest.mark.sphinx('dummy', testroot='basic', copy_test_root=True)\ndef test_config_status(\n    make_app: Callable[..., SphinxTestApp], app_params: _app_params\n) -> None:\n    args, kwargs = app_params\n\n    # clean build\n    app1 = make_app(*args, freshenv=True, **kwargs)\n    assert app1.env.config_status == CONFIG_NEW\n    app1.build()\n    output = strip_escape_sequences(app1.status.getvalue())\n    # assert 'The configuration has changed' not in output\n    assert '[new config] 1 added' in output\n\n    # incremental build (no config changed)\n    app2 = make_app(*args, **kwargs)\n    assert app2.env.config_status == CONFIG_OK\n    app2.build()\n    output = strip_escape_sequences(app2.status.getvalue())\n    assert 'The configuration has changed' not in output\n    assert '0 added, 0 changed, 0 removed' in output\n\n    # incremental build (config entry changed)\n    app3 = make_app(*args, confoverrides={'root_doc': 'indexx'}, **kwargs)\n    fname = app3.srcdir / 'index.rst'\n    other_fname = app3.srcdir / 'indexx.rst'\n    assert fname.is_file()\n    shutil.move(fname, other_fname)\n    assert app3.env.config_status == CONFIG_CHANGED\n    app3.build()\n    shutil.move(other_fname, fname)\n    output = strip_escape_sequences(app3.status.getvalue())\n    assert 'The configuration has changed' in output\n    assert \"[config changed ("}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_allow_fuzzy_translations\n                )\n\n        locale_dirs: list[_StrPath | None] = list(repo.locale_dirs)\n        locale_dirs += [None]\n        locale_dirs += [package_dir / 'locale']\n\n        self.translator, has_translation = locale.init(\n            locale_dirs, self.config.language\n        )\n        if has_translation or self.config.language == 'en':\n            logger.info(__('done'))\n        else:\n            logger.info(__('not available for built-in messages'))\n\n    def _init_env(self, freshenv: bool) -> BuildEnvironment:\n        filename = self.doctreedir / ENV_PICKLE_FILENAME\n        if freshenv or not filename.exists():\n            return self._create_fresh_env()\n        else:\n            return self._load_existing_env(filename)\n\n    def _create_fresh_env(self) -> BuildEnvironment:\n        env = BuildEnvironment(self)\n        self._fresh_env_used = True\n        return env\n\n    @progress_message(__('loading pickled environment'))\n    def _load_existing_env(self, filename: Path) -> BuildEnvironment:\n        try:\n            with open(filename, 'rb') as f:\n                env = pickle.load(f)\n            env.setup(self)\n            self._fresh_env_used = False\n        except Exception as err:\n            logger.info(__('failed: %s'), err)\n            env = self._create_fresh_env()\n        return env\n\n    def _post_init_env(self) -> None:\n        if self._fresh_env_used:\n            self.env.find_files(self.config, self.builder)\n\n        self.env._builder_cls = self.builder.__class__\n\n    def preload_builder(self, name: str) -> None:\n        self.registry.preload_builder(self, name)\n\n    def create_builder(self, name: str) -> Builder:\n        if name is None:\n            logger.info(__('No builder selected, using default: html'))\n            name = 'html'\n\n        return self.registry.create_builder(self, name, self.env)\n\n    def _init_builder(self) -> None:\n        self.builder.init()\n        self.events.emit('builder-inited')\n\n    # ---- main \"build\""}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ython callable. \"\n                            'Please modify its definition to make it a callable function. '\n                            'This is needed for conf.py to behave as a Sphinx extension.'\n                        ),\n                    )\n\n        # Report any warnings for overrides.\n        self.config._report_override_warnings()\n        self.events.emit('config-inited', self.config)\n\n        # create the project\n        self.project = Project(self.srcdir, self.config.source_suffix)\n\n        # set up the build environment\n        self.env = self._init_env(freshenv)\n\n        # create the builder\n        self.builder = self.create_builder(buildername)\n\n        # build environment post-initialisation, after creating the builder\n        self._post_init_env()\n\n        # set up the builder\n        self._init_builder()\n\n    @property\n    def fresh_env_used(self) -> bool | None:\n        \"\"\"True/False as to whether a new environment was created for this build,\n        or None if the environment has not been initialised yet.\n        \"\"\"\n        return self._fresh_env_used\n\n    @property\n    def phase(self) -> BuildPhase:\n        if not hasattr(self, 'builder'):\n            return BuildPhase.INITIALIZATION\n        return self.builder.phase\n\n    def _init_i18n(self) -> None:\n        \"\"\"Load translated strings from the configured localedirs if enabled in\n        the configuration.\n        \"\"\"\n        logger.info(\n            bold(__('loading translations [%s]... ')), self.config.language, nonl=True\n        )\n\n        # compile mo files if sphinx.po file in user locale directories are updated\n        repo = CatalogRepository(\n            self.srcdir,\n            self.config.locale_dirs,\n            self.config.language,\n            self.config.source_encoding,\n        )\n        for catalog in repo.catalogs:\n            if catalog.domain == 'sphinx' and catalog.is_outdated():\n                catalog.write_mo(\n                    self.config.language, self.config.gettext"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n    allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n  "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " first-party extension modules,\n        # and first-party themes\n        for extension in builtin_extensions:\n            self.setup_extension(extension)\n\n        # load all user-given extension modules\n        for extension in self.config.extensions:\n            self.setup_extension(extension)\n\n        # preload builder module (before init config values)\n        self.preload_builder(buildername)\n\n        if not self.outdir.is_dir():\n            with progress_message(__('making output directory')):\n                ensuredir(self.outdir)\n\n        # the config file itself can be an extension\n        if self.config.setup:\n            prefix = __('while setting up extension %s:') % 'conf.py'\n            with prefixed_warnings(prefix):\n                if callable(self.config.setup):\n                    self.config.setup(self)\n                else:\n                    raise ConfigError(\n                        __(\n                            \"'setup' as currently defined in conf.py isn't a Python callable. \"\n                            'Please modify its definition to make it a callable function. '\n                            'This is needed for conf.py to behave as a Sphinx extension.'\n                        ),\n                    )\n\n        # Report any warnings for overrides.\n        self.config._report_override_warnings()\n        self.events.emit('config-inited', self.config)\n\n        # create the project\n        self.project = Project(self.srcdir, self.config.source_suffix)\n\n        # set up the build environment\n        self.env = self._init_env(freshenv)\n\n        # create the builder\n        self.builder = self.create_builder(buildername)\n\n        # build environment post-initialisation, after creating the builder\n        self._post_init_env()\n\n        # set up the builder\n        self._init_builder()\n\n    @property\n    def fresh_env_used(self) -> bool | None:\n        \"\"\"True/False as to whether a new environment was created for this build,\n        or None if the "}], "retrieved_count": 10, "cost_time": 1.0840349197387695}
{"question": "Why does Sphinx implement its own Domain system rather than relying solely on Docutils' built-in roles?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements its own Domain system rather than relying solely on Docutils' built-in roles for several important reasons related to functionality, extensibility, and the specific needs of documentation generation.\n\nKey reasons for implementing a custom Domain system include:\n\n1. **Language-Specific Functionality**: Different programming languages and documentation domains have unique requirements for object descriptions, cross-references, and indexing. The Domain system allows Sphinx to provide specialized functionality for Python, C++, JavaScript, and other languages that goes beyond what Docutils' generic roles can provide.\n\n2. **Cross-Reference Resolution**: Sphinx's Domain system provides sophisticated cross-reference resolution capabilities that can handle complex relationships between objects, such as method inheritance, module imports, and namespace resolution. This requires domain-specific logic that Docutils' built-in roles cannot provide.\n\n3. **Object Type Management**: The Domain system allows Sphinx to define and manage specific object types (functions, classes, modules, etc.) with their own attributes, relationships, and documentation requirements. This provides much richer functionality than generic Docutils roles.\n\n4. **Namespace Isolation**: By organizing functionality into domains, Sphinx can avoid naming conflicts when documenting multiple languages or systems in the same project. For example, Python functions and C++ functions can coexist without conflicts.\n\n5. **Extensibility**: The Domain system provides a framework for extensions to add new object types, directives, and roles specific to their domain, making it much easier to extend Sphinx for new languages or documentation needs.\n\n6. **Data Persistence**: Domains can store complex metadata about documented objects that persists across builds, enabling features like automatic index generation, search functionality, and advanced cross-referencing.\n\n7. **Integration with Build Process**: The Domain system integrates deeply with Sphinx's build process, allowing for features like automatic object discovery, dependency tracking, and incremental builds that are specific to documentation generation.\n\nThe Domain system builds on top of Docutils' role system but provides the additional functionality needed for sophisticated documentation generation that goes beyond simple text markup.", "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rective] | None, list[system_message]]:\n        return self.directive_func(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        return self.role_func(\n            role_name,\n            language_module,  # type: ignore[return-value]\n            lineno,\n            reporter,\n        )\n\n\nclass ElementLookupError(Exception):\n    pass\n\n\nclass sphinx_domains(CustomReSTDispatcher):\n    \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n    markup takes precedence.\n    \"\"\"\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        self.domains = env.domains\n        self.current_document = env.current_document\n        super().__init__()\n\n    def directive(\n        self,\n        directive_name: str,\n        language_module: ModuleType,\n        document: nodes.document,\n    ) -> tuple[type[Directive] | None, list[system_message]]:\n        \"\"\"Lookup a directive, given its name which can include a domain.\"\"\"\n        directive_name = directive_name.lower()\n        # explicit domain given?\n        if ':' in directive_name:\n            domain_name, _, name = directive_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown directive name: %s'), directive_name)\n            else:\n                element = domain.directive(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = directive_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.directive(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domai"}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              is already installed as the same name\n                         If true, unconditionally install the role.\n\n        .. versionadded:: 0.6\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        # Don't use ``roles.register_generic_role`` because it uses\n        # ``register_canonical_role``.\n        logger.debug('[app] adding generic role: %r', (name, nodeclass))\n        if not override and docutils.is_role_registered(name):\n            logger.warning(\n                __('role %r is already registered and will not be overridden'),\n                name,\n                type='app',\n                subtype='add_generic_role',\n            )\n        role = roles.GenericRole(name, nodeclass)\n        docutils.register_role(name, role)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        \"\"\"Register a domain.\n\n        :param domain: A domain class\n        :param override: If false, do not install it if another domain\n                         is already installed as the same name\n                         If true, unconditionally install the domain.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        self.registry.add_domain(domain, override=override)\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        \"\"\"Register a Docutils directive in a domain.\n\n        Like :meth:`add_directive`, but the directive is added to the domain\n        named *domain*.\n\n        :param domain: The name of target domain\n        :param name: A name of directive\n        :param cls: A directive class\n        :param override: If false, do not install it if another directive\n                         is already installed as the same name\n                         If true, unconditionally install the directive.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 1.8\n    "}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in\n                         is already installed as the same name\n                         If true, unconditionally install the domain.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        self.registry.add_domain(domain, override=override)\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        \"\"\"Register a Docutils directive in a domain.\n\n        Like :meth:`add_directive`, but the directive is added to the domain\n        named *domain*.\n\n        :param domain: The name of target domain\n        :param name: A name of directive\n        :param cls: A directive class\n        :param override: If false, do not install it if another directive\n                         is already installed as the same name\n                         If true, unconditionally install the directive.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        self.registry.add_directive_to_domain(domain, name, cls, override=override)\n\n    def add_role_to_domain(\n        self,\n        domain: str,\n        name: str,\n        role: RoleFunction | XRefRole,\n        override: bool = False,\n    ) -> None:\n        \"\"\"Register a Docutils role in a domain.\n\n        Like :meth:`add_role`, but the role is added to the domain named\n        *domain*.\n\n        :param domain: The name of the target domain\n        :param name: The name of the role\n        :param role: The role function\n        :param override: If false, do not install it if another role\n                         is already installed as the same name\n                         If true, unconditionally install the role.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 1.8\n           Add *override* keyword.\n        \"\"\"\n        self.registry.add_role_to_domain(domain, name, role, override=override)\n\n    def add_index_to_domain(\n        "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n\n        element = self.domains.standard_domain.directive(name)\n        if element is not None:\n            return element, []\n\n        return super().directive(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        \"\"\"Lookup a role, given its name which can include a domain.\"\"\"\n        role_name = role_name.lower()\n        # explicit domain given?\n        if ':' in role_name:\n            domain_name, _, name = role_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown role name: %s'), role_name)\n            else:\n                element = domain.role(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = role_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.role(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domain\n        element = self.domains.standard_domain.role(name)\n        if element is not None:\n            return element, []\n\n        return super().role(role_name, language_module, lineno, reporter)\n\n\nclass WarningStream:\n    def write(self, text: str) -> None:\n        matched = report_re.search(text)\n        if not matched:\n            logger.warning(text.rstrip('\\r\\n'), type='docutils')\n        else:\n            location, type, _level = matched.groups()\n            message = report_re.sub('', text).rstrip()\n            logger.log(type, message, location=location, type='docutils')\n\n\nclass LoggingReporter(Reporter):\n    @classmethod\n    def from_reporter(\n        cls: type[LoggingReporter], "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.directive_func: _DirectivesDispatcher = lambda *args: (None, [])\n        self.roles_func: _RolesDispatcher = lambda *args: (None, [])\n\n    def __enter__(self) -> None:\n        self.enable()\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        self.disable()\n\n    def enable(self) -> None:\n        self.directive_func = directives.directive\n        self.role_func = roles.role\n\n        directives.directive = self.directive  # type: ignore[assignment]\n        roles.role = self.role  # type: ignore[assignment]\n\n    def disable(self) -> None:\n        directives.directive = self.directive_func  # type: ignore[assignment]\n        roles.role = self.role_func\n\n    def directive(\n        self,\n        directive_name: str,\n        language_module: ModuleType,\n        document: nodes.document,\n    ) -> tuple[type[Directive] | None, list[system_message]]:\n        return self.directive_func(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        return self.role_func(\n            role_name,\n            language_module,  # type: ignore[return-value]\n            lineno,\n            reporter,\n        )\n\n\nclass ElementLookupError(Exception):\n    pass\n\n\nclass sphinx_domains(CustomReSTDispatcher):\n    \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n    markup takes precedence.\n    \"\"\"\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        self.domains = env.domains\n        self.current_document = env.current_document\n        super().__init__()\n\n    def directive(\n        self,\n        directive_name: str,\n        language_module: ModuleType,\n        document: nodes.document,\n    ) -> tuple[ty"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n            )\n        directives[name] = cls\n\n    def add_role_to_domain(\n        self,\n        domain: str,\n        name: str,\n        role: RoleFunction | XRefRole,\n        override: bool = False,\n    ) -> None:\n        logger.debug('[app] adding role to domain: %r', (domain, name, role))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n        roles = self.domain_roles.setdefault(domain, {})\n        if name in roles and not override:\n            raise ExtensionError(\n                __('The %r role is already registered to domain %s') % (name, domain)\n            )\n        roles[name] = role\n\n    def add_index_to_domain(\n        self, domain: str, index: type[Index], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding index to domain: %r', (domain, index))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n        indices = self.domain_ind"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    target_node = nodes.target(ids=node_ids)\n                self.set_source_info(target_node)\n                return [self.indexnode, target_node]\n            return [self.indexnode]\n        return [self.indexnode, node]\n\n\nclass DefaultRole(SphinxDirective):\n    \"\"\"Set the default interpreted text role.  Overridden from docutils.\"\"\"\n\n    optional_arguments = 1\n    final_argument_whitespace = False\n\n    def run(self) -> list[Node]:\n        if not self.arguments:\n            docutils.unregister_role('')\n            return []\n        role_name = self.arguments[0]\n        role, messages = roles.role(\n            role_name, self.state_machine.language, self.lineno, self.state.reporter\n        )\n        if role:\n            docutils.register_role('', role)  # type: ignore[arg-type]\n            self.env.current_document.default_role = role_name\n        else:\n            literal_block = nodes.literal_block(self.block_text, self.block_text)\n            reporter = self.state.reporter\n            error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_direct"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   document.  In the object_types attribute of Domain subclasses, object type\n    names are mapped to instances of this class.\n\n    Constructor arguments:\n\n    - *lname*: localized name of the type (do not include domain name)\n    - *roles*: all the roles that can refer to an object of this type\n    - *attrs*: object attributes -- currently only \"searchprio\" is known,\n      which defines the object's priority in the full-text search index,\n      see :meth:`Domain.get_objects()`.\n    \"\"\"\n\n    known_attrs = {\n        'searchprio': 1,\n    }\n\n    def __init__(self, lname: str, /, *roles: Any, **attrs: Any) -> None:\n        self.lname: str = lname\n        self.roles: tuple[Any, ...] = roles\n        self.attrs: dict[str, Any] = self.known_attrs | attrs\n\n\nclass Domain:\n    \"\"\"A Domain is meant to be a group of \"object\" description directives for\n    objects of a similar nature, and corresponding roles to create references to\n    them.  Examples would be Python modules, classes, functions etc., elements\n    of a templating language, Sphinx roles and directives, etc.\n\n    Each domain has a separate storage for information about existing objects\n    and how to reference them in `self.data`, which must be a dictionary.  It\n    also must implement several functions that expose the object information in\n    a uniform way to parts of Sphinx that allow the user to reference or search\n    for objects in a domain-agnostic way.\n\n    About `self.data`: since all object and cross-referencing information is\n    stored on a BuildEnvironment instance, the `domain.data` object is also\n    stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n    build process starts, every active domain is instantiated and given the\n    environment object; the `domaindata` dict must then either be nonexistent or\n    a dictionary whose 'version' key is equal to the domain class'\n    :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n    pickled environment is disc"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "arded.\n    \"\"\"\n\n    #: domain name: should be short, but unique\n    name: ClassVar[str] = ''\n    #: domain label: longer, more descriptive (used in messages)\n    label: ClassVar[str] = ''\n    #: type (usually directive) name -> ObjType instance\n    object_types: ClassVar[dict[str, ObjType]] = {}\n    #: directive name -> directive class\n    directives: ClassVar[dict[str, type[Directive]]] = {}\n    #: role name -> role callable\n    roles: ClassVar[dict[str, RoleFunction | XRefRole]] = {}\n    #: a list of Index subclasses\n    indices: ClassVar[list[type[Index]]] = []\n    #: role name -> a warning message if reference is missing\n    dangling_warnings: ClassVar[dict[str, str]] = {}\n    #: node_class -> (enum_node_type, title_getter)\n    enumerable_nodes: ClassVar[dict[type[Node], tuple[str, TitleGetter | None]]] = {}\n    #: data value for a fresh environment\n    initial_data: ClassVar[dict[str, Any]] = {}\n    #: data value\n    data: dict[str, Any]\n    #: data version, bump this when the format of `self.data` changes\n    data_version: ClassVar[int] = 0\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        domain_data: dict[str, dict[str, Any]] = env.domaindata\n        self.env: BuildEnvironment = env\n        self._role_cache: dict[str, RoleFunction] = {}\n        self._directive_cache: dict[str, type[Directive]] = {}\n        self._role2type: dict[str, list[str]] = {}\n        self._type2role: dict[str, str] = {}\n\n        # convert class variables to instance one (to enhance through API)\n        self.object_types = dict(self.object_types)  # type: ignore[misc]\n        self.directives = dict(self.directives)  # type: ignore[misc]\n        self.roles = dict(self.roles)  # type: ignore[misc]\n        self.indices = list(self.indices)  # type: ignore[misc]\n\n        if self.name not in domain_data:\n            assert isinstance(self.initial_data, dict)\n            new_data = copy.deepcopy(self.initial_data)\n            new_data['version'] = self.data_version\n            s"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", elements\n    of a templating language, Sphinx roles and directives, etc.\n\n    Each domain has a separate storage for information about existing objects\n    and how to reference them in `self.data`, which must be a dictionary.  It\n    also must implement several functions that expose the object information in\n    a uniform way to parts of Sphinx that allow the user to reference or search\n    for objects in a domain-agnostic way.\n\n    About `self.data`: since all object and cross-referencing information is\n    stored on a BuildEnvironment instance, the `domain.data` object is also\n    stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n    build process starts, every active domain is instantiated and given the\n    environment object; the `domaindata` dict must then either be nonexistent or\n    a dictionary whose 'version' key is equal to the domain class'\n    :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n    pickled environment is discarded.\n    \"\"\"\n\n    #: domain name: should be short, but unique\n    name: ClassVar[str] = ''\n    #: domain label: longer, more descriptive (used in messages)\n    label: ClassVar[str] = ''\n    #: type (usually directive) name -> ObjType instance\n    object_types: ClassVar[dict[str, ObjType]] = {}\n    #: directive name -> directive class\n    directives: ClassVar[dict[str, type[Directive]]] = {}\n    #: role name -> role callable\n    roles: ClassVar[dict[str, RoleFunction | XRefRole]] = {}\n    #: a list of Index subclasses\n    indices: ClassVar[list[type[Index]]] = []\n    #: role name -> a warning message if reference is missing\n    dangling_warnings: ClassVar[dict[str, str]] = {}\n    #: node_class -> (enum_node_type, title_getter)\n    enumerable_nodes: ClassVar[dict[type[Node], tuple[str, TitleGetter | None]]] = {}\n    #: data value for a fresh environment\n    initial_data: ClassVar[dict[str, Any]] = {}\n    #: data value\n    data: dict[str, Any]\n    #: data version, bump this when the for"}], "retrieved_count": 10, "cost_time": 1.068127155303955}
{"question": "Why does Sphinx use a multi-phase build process instead of a single-pass document generation?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx uses a multi-phase build process instead of single-pass document generation for several important reasons related to cross-reference resolution, extensibility, and build efficiency.\n\nKey reasons for the multi-phase approach include:\n\n1. **Cross-Reference Resolution**: Many cross-references in Sphinx documentation can only be resolved after all documents have been read and their metadata has been collected. For example, a reference to a function in another document requires that the target document has been processed to know where that function is defined.\n\n2. **Incremental Builds**: The multi-phase approach allows Sphinx to implement efficient incremental builds. By separating reading from writing, Sphinx can determine which documents have changed and only rebuild the necessary parts of the documentation.\n\n3. **Extension Integration**: The multi-phase process provides multiple hook points for extensions to modify the document processing. Extensions can add functionality at different stages (reading, resolving, writing) without interfering with each other.\n\n4. **Memory Management**: Processing all documents in a single pass would require keeping all document trees in memory simultaneously, which could be problematic for large documentation projects. The multi-phase approach allows for more efficient memory usage.\n\n5. **Parallel Processing**: The separation of phases enables parallel processing of documents during the reading phase, as documents can be processed independently before cross-references are resolved.\n\n6. **Error Handling**: The multi-phase approach allows for better error handling and recovery. If errors occur during one phase, they can be handled appropriately without affecting other phases.\n\n7. **Consistency Checking**: The multi-phase process includes a consistency checking phase where Sphinx can verify that all cross-references are valid and that the documentation is internally consistent.\n\nThe phases typically include: initialization, reading (parsing source files), consistency checks, resolving (cross-references), and writing (output generation). This approach provides the flexibility and robustness needed for complex documentation projects.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 277, "belongs_to": {"file_name": "build_phase.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build phase of Sphinx application.\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass BuildPhase(IntEnum):\n    \"\"\"Build phase of Sphinx application.\"\"\"\n\n    INITIALIZATION = 1\n    READING = 2\n    CONSISTENCY_CHECK = 3\n    RESOLVING = 3\n    WRITING = 4\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode "}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int) -> None:\n        def write_process(docs: list[tuple[str, nodes.document]]) -> None:\n            self.phase = BuildPhase.WRITING\n            for docname, doctree in docs:\n                self.write_doc(docname, doctree)\n\n        # warm up caches/compile templates using the first document\n        firstname, docnames = docnames[0], docnames[1:]\n        _write_docname(firstname, env=self.env, builder=self, tags=self.tags)\n\n        tasks = ParallelTasks(nproc)\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after writing a document\n        # (see: ``on_chunk_done()`` function)\n        progress = status_iterator(\n            chunks,\n            __('writing output... '),\n            'darkgreen',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        def on_chunk_done(args: list[tuple[str, nodes.document]], result: None) -> None:\n            next(progress)\n\n        self.phase = BuildPhase.RESOLVING\n        for chunk in chunks:\n            arg = []\n            for docname in chunk:\n                doctree = self.env.get_and_resolve_doctree(\n                    docname, self, tags=self.tags\n                )\n                self.write_doc_serialized(docname, doctree)\n                arg.append((docname, doctree))\n            tasks.add_task(write_process, arg, on_chunk_done)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        \"\"\"A place where you can add logic before :meth:`write_doc` is run\"\"\"\n        pass\n\n    def copy_assets(self) -> None:\n        \"\"\"Where assets (images, static files, etc) are copied before writing\"\"\"\n        pass\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Write the output file for the document\n\n        :param docname: the :term:`docname <document name>`.\n        :param doctree: defines the content to be written.\n\n        The ou"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " toctree = global_toctree_for_doc(\n            self.env, docname, self, tags=self.tags, collapse=collapse, **kwargs\n        )\n        return self.render_partial(toctree)['fragment']\n\n    def assemble_doctree(self) -> nodes.document:\n        master = self.config.root_doc\n        tree = self.env.get_doctree(master)\n        logger.info(darkgreen(master))\n        tree = inline_all_toctrees(self, set(), master, tree, darkgreen, [master])\n        tree['docname'] = master\n        self.env.resolve_references(tree, master, self)\n        return tree\n\n    def assemble_toc_secnumbers(self) -> dict[str, dict[str, tuple[int, ...]]]:\n        # Assemble toc_secnumbers to resolve section numbers on SingleHTML.\n        # Merge all secnumbers to single secnumber.\n        #\n        # Note: current Sphinx has refid confliction in singlehtml mode.\n        #       To avoid the problem, it replaces key of secnumbers to\n        #       tuple of docname and refid.\n        #\n        #       There are related codes in inline_all_toctres() and\n        #       HTMLTranslter#add_secnumber().\n        new_secnumbers: dict[str, tuple[int, ...]] = {}\n        for docname, secnums in self.env.toc_secnumbers.items():\n            for id, secnum in secnums.items():\n                alias = f'{docname}/{id}'\n                new_secnumbers[alias] = secnum\n\n        return {self.config.root_doc: new_secnumbers}\n\n    def assemble_toc_fignumbers(\n        self,\n    ) -> dict[str, dict[str, dict[str, tuple[int, ...]]]]:\n        # Assemble toc_fignumbers to resolve figure numbers on SingleHTML.\n        # Merge all fignumbers to single fignumber.\n        #\n        # Note: current Sphinx has refid confliction in singlehtml mode.\n        #       To avoid the problem, it replaces key of secnumbers to\n        #       tuple of docname and refid.\n        #\n        #       There are related codes in inline_all_toctres() and\n        #       HTMLTranslter#add_fignumber().\n        new_fignumbers: dict[str, dict[str, tuple[int"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# type: ignore[assignment]\n        error = warning\n\n    return status, warning, error, warnfp\n\n\ndef _parse_confoverrides(\n    parser: argparse.ArgumentParser,\n    define: list[str],\n    htmldefine: list[str],\n    nitpicky: bool,\n) -> dict[str, Any]:\n    confoverrides: dict[str, Any] = {}\n    val: Any\n    for val in define:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-D option argument must be in the form name=value'))\n        confoverrides[key] = val\n\n    for val in htmldefine:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-A option argument must be in the form name=value'))\n        with contextlib.suppress(ValueError):\n            val = int(val)\n\n        confoverrides[f'html_context.{key}'] = val\n\n    if nitpicky:\n        confoverrides['nitpicky'] = True\n\n    return confoverrides\n\n\ndef build_main(argv: Sequence[str]) -> int:\n    \"\"\"Sphinx build \"main\" command-line entry.\"\"\"\n    parser = get_parser()\n    args = _parse_arguments(parser, argv)\n    args.confdir = _parse_confdir(args.noconfig, args.confdir, args.sourcedir)\n    args.doctreedir = _parse_doctreedir(args.doctreedir, args.outputdir)\n    _validate_filenames(parser, args.force_all, args.filenames)\n    _validate_colour_support(args.color)\n    args.status, args.warning, args.error, warnfp = _parse_logging(\n        parser, args.quiet, args.really_quiet, args.warnfile\n    )\n    args.confoverrides = _parse_confoverrides(\n        parser, args.define, args.htmldefine, args.nitpicky\n    )\n\n    app = None\n    try:\n        confdir = args.confdir or args.sourcedir\n        with patch_docutils(confdir), docutils_namespace():\n            app = Sphinx(\n                srcdir=args.sourcedir,\n                confdir=args.confdir,\n                outdir=args.outputdir,\n                doctreedir=args.doctreedir,\n                buildername=args.builder,\n                confoverrides=args.conf"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.copy_download_files)\n        self.finish_tasks.add_task(self.copy_static_files)\n        self.finish_tasks.add_task(self.copy_extra_files)\n        self.finish_tasks.join()\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        doctree.settings = self.docsettings\n\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n        self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n        self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n        self.current_docname = docname\n        visitor: HTML5Translator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        body = ''.join(visitor.fragment)\n        clean_meta = ''.join(visitor.meta[2:])\n\n        ctx = self.get_doc_context(docname, body, clean_meta)\n        ctx['has_maths_elements'] = getattr(visitor, '_has_maths_elements', False)\n        self.handle_page(docname, ctx, event_arg=doctree)\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n        self.post_process_images(doctree)\n        title_node = self.env.longtitles.get(docname)\n        title = self.render_partial(title_node)['title'] if title_node else ''\n        self.index_page(docname, doctree, title)\n\n    def finish(self) -> None:\n        self.finish_tasks.add_task(self.gen_indices)\n        self.finish_tasks.add_task(self.gen_pages_from_extensions)\n        self.finish_tasks.add_task(self.gen_additional_pages)\n        self.finish_tasks.add_task(self.copy_image_files)\n        self.finish_tasks.add_task(self.write_buildinfo)\n\n        # dump the search index\n        self.handle_finish()\n\n    @progress_message(__('generating indices'))\n    def gen_indices(self) -> None:\n        # the global general index\n        if self.use_index:\n            self.write_g"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rents': [],\n            'prev': None,\n            'next': None,\n            'docstitle': None,\n            'title': self.config.html_title,\n            'meta': None,\n            'body': body,\n            'metatags': metatags,\n            'rellinks': [],\n            'sourcename': '',\n            'toc': toc,\n            'display_toc': display_toc,\n        }\n\n    def write_documents(self, _docnames: Set[str]) -> None:\n        self.prepare_writing(self.env.all_docs.keys())\n\n        with progress_message(__('assembling single document'), nonl=False):\n            doctree = self.assemble_doctree()\n            self.env.toc_secnumbers = self.assemble_toc_secnumbers()\n            self.env.toc_fignumbers = self.assemble_toc_fignumbers()\n\n        with progress_message(__('writing')):\n            self.write_doc_serialized(self.config.root_doc, doctree)\n            self.write_doc(self.config.root_doc, doctree)\n\n    def finish(self) -> None:\n        self.write_additional_files()\n        self.copy_image_files()\n        self.copy_download_files()\n        self.copy_static_files()\n        self.copy_extra_files()\n        self.write_buildinfo()\n        self.dump_inventory()\n\n    @progress_message(__('writing additional files'))\n    def write_additional_files(self) -> None:\n        # no indices or search pages are supported\n\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info(' %s', pagename, nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        if self.config.html_use_opensearch:\n            logger.info(' opensearch', nonl=True)\n            self.handle_page(\n                'opensearch',\n                {},\n                'opensearch.xml',\n                outfilename=self._static_dir / 'opensearch.xml',\n            )\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.setup_extension('sphinx.builders.html')\n\n    app.add_builder(SingleFileHTMLBuilder)\n    app.add_config_value(\n"}], "retrieved_count": 10, "cost_time": 1.0762279033660889}
{"question": "What is the function of the Domain class in Sphinx's architecture?", "answer": null, "relative_code_list": null, "ground_truth": "The Domain class in Sphinx's architecture serves as a specialized container for organizing and managing documentation elements that belong to a specific domain or language. It provides a structured way to handle object descriptions, cross-references, and domain-specific functionality.\n\nKey functions of the Domain class include:\n\n1. **Object Type Management**: Each domain defines and manages specific object types (e.g., functions, classes, modules for Python domain) through the `object_types` attribute, which maps object type names to `ObjType` instances.\n\n2. **Directive Registration**: Domains register domain-specific directives (e.g., `py:function`, `cpp:class`) that create object descriptions and store information about documented objects.\n\n3. **Role Management**: Domains provide domain-specific roles (e.g., `:py:func:`, `:cpp:class:`) for creating cross-references to objects within that domain.\n\n4. **Data Storage**: Each domain maintains its own data storage in `self.data`, which is stored in the environment's `domaindata` dictionary under the domain's name. This data persists across builds and contains information about all objects in that domain.\n\n5. **Cross-Reference Resolution**: Domains implement methods to resolve cross-references to objects within their domain, providing domain-specific logic for finding and linking to documented objects.\n\n6. **Index Generation**: Domains can provide custom indices for their objects, allowing for specialized indexing and search functionality.\n\n7. **Namespace Isolation**: By organizing functionality into domains, Sphinx avoids naming conflicts when documenting multiple languages or systems in the same project.\n\n8. **Extension Support**: Domains provide a framework for extensions to add new object types, directives, and roles specific to their domain.\n\nThe Domain class is instantiated for each active domain during the build process and is given access to the BuildEnvironment. It serves as the foundation for Sphinx's multi-language documentation capabilities, allowing different domains to coexist and provide specialized functionality for their respective languages or systems.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "arded.\n    \"\"\"\n\n    #: domain name: should be short, but unique\n    name: ClassVar[str] = ''\n    #: domain label: longer, more descriptive (used in messages)\n    label: ClassVar[str] = ''\n    #: type (usually directive) name -> ObjType instance\n    object_types: ClassVar[dict[str, ObjType]] = {}\n    #: directive name -> directive class\n    directives: ClassVar[dict[str, type[Directive]]] = {}\n    #: role name -> role callable\n    roles: ClassVar[dict[str, RoleFunction | XRefRole]] = {}\n    #: a list of Index subclasses\n    indices: ClassVar[list[type[Index]]] = []\n    #: role name -> a warning message if reference is missing\n    dangling_warnings: ClassVar[dict[str, str]] = {}\n    #: node_class -> (enum_node_type, title_getter)\n    enumerable_nodes: ClassVar[dict[type[Node], tuple[str, TitleGetter | None]]] = {}\n    #: data value for a fresh environment\n    initial_data: ClassVar[dict[str, Any]] = {}\n    #: data value\n    data: dict[str, Any]\n    #: data version, bump this when the format of `self.data` changes\n    data_version: ClassVar[int] = 0\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        domain_data: dict[str, dict[str, Any]] = env.domaindata\n        self.env: BuildEnvironment = env\n        self._role_cache: dict[str, RoleFunction] = {}\n        self._directive_cache: dict[str, type[Directive]] = {}\n        self._role2type: dict[str, list[str]] = {}\n        self._type2role: dict[str, str] = {}\n\n        # convert class variables to instance one (to enhance through API)\n        self.object_types = dict(self.object_types)  # type: ignore[misc]\n        self.directives = dict(self.directives)  # type: ignore[misc]\n        self.roles = dict(self.roles)  # type: ignore[misc]\n        self.indices = list(self.indices)  # type: ignore[misc]\n\n        if self.name not in domain_data:\n            assert isinstance(self.initial_data, dict)\n            new_data = copy.deepcopy(self.initial_data)\n            new_data['version'] = self.data_version\n            s"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", elements\n    of a templating language, Sphinx roles and directives, etc.\n\n    Each domain has a separate storage for information about existing objects\n    and how to reference them in `self.data`, which must be a dictionary.  It\n    also must implement several functions that expose the object information in\n    a uniform way to parts of Sphinx that allow the user to reference or search\n    for objects in a domain-agnostic way.\n\n    About `self.data`: since all object and cross-referencing information is\n    stored on a BuildEnvironment instance, the `domain.data` object is also\n    stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n    build process starts, every active domain is instantiated and given the\n    environment object; the `domaindata` dict must then either be nonexistent or\n    a dictionary whose 'version' key is equal to the domain class'\n    :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n    pickled environment is discarded.\n    \"\"\"\n\n    #: domain name: should be short, but unique\n    name: ClassVar[str] = ''\n    #: domain label: longer, more descriptive (used in messages)\n    label: ClassVar[str] = ''\n    #: type (usually directive) name -> ObjType instance\n    object_types: ClassVar[dict[str, ObjType]] = {}\n    #: directive name -> directive class\n    directives: ClassVar[dict[str, type[Directive]]] = {}\n    #: role name -> role callable\n    roles: ClassVar[dict[str, RoleFunction | XRefRole]] = {}\n    #: a list of Index subclasses\n    indices: ClassVar[list[type[Index]]] = []\n    #: role name -> a warning message if reference is missing\n    dangling_warnings: ClassVar[dict[str, str]] = {}\n    #: node_class -> (enum_node_type, title_getter)\n    enumerable_nodes: ClassVar[dict[type[Node], tuple[str, TitleGetter | None]]] = {}\n    #: data value for a fresh environment\n    initial_data: ClassVar[dict[str, Any]] = {}\n    #: data value\n    data: dict[str, Any]\n    #: data version, bump this when the for"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ss _DomainsContainer:\n    \"\"\"Container for domain instances.\n\n    This class is private, including its name, constructor, and all methods.\n    Any or all of these will change without notice or warning in any release.\n\n    The public interface is restricted to:\n\n    * the``domains.['<domain-name>']`` mapping interface\n    * the ``domains.<core-domain-name>`` attributes for core domains.\n    * the `.get()``, ``.keys()``, ``.items()``, and ``.values()`` methods.\n\n    Additionally, this class supports ``iter`` and ``len``,\n    and provides membership testing via the ``in`` operator.\n    \"\"\"\n\n    __slots__ = (\n        '_domain_instances',\n        'c_domain',\n        'changeset_domain',\n        'citation_domain',\n        'cpp_domain',\n        'index_domain',\n        'javascript_domain',\n        'math_domain',\n        'python_domain',\n        'restructuredtext_domain',\n        'standard_domain',\n    )\n\n    #: First-party domains in :mod:`sphinx.domains`\n    _core_domains: Final = frozenset({\n        'std',\n        # Language-specific domains\n        'c',\n        'cpp',\n        'js',\n        'py',\n        'rst',\n        # Other core domains\n        'changeset',\n        'citation',\n        'index',\n        'math',\n    })\n\n    @classmethod\n    def _from_environment(\n        cls, env: BuildEnvironment, /, *, registry: SphinxComponentRegistry\n    ) -> Self:\n        create_domains = registry.create_domains\n        # Initialise domains\n        if domains := {domain.name: domain for domain in create_domains(env)}:\n            return cls(**domains)  # type: ignore[arg-type]\n\n        return cls._from_environment_default(env=env)\n\n    @classmethod\n    def _from_environment_default(cls, *, env: BuildEnvironment) -> Self:\n        \"\"\"Return a default instance with every domain we require.\"\"\"\n        from sphinx.domains.c import CDomain\n        from sphinx.domains.changeset import ChangeSetDomain\n        from sphinx.domains.citation import CitationDomain\n        from sphinx.domains.cpp i"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self.index_domain: IndexDomain = index\n        self.math_domain: MathDomain = math\n\n        for domain_name, domain in self._domain_instances.items():\n            # invariant from ``_DomainsContainer._from_environment``\n            if domain_name != domain.name:\n                msg = f'Domain name mismatch in {domain!r}: {domain_name!r} != {domain.name!r}'\n                raise ValueError(msg)\n\n    def _setup(self) -> None:\n        for domain in self._domain_instances.values():\n            domain.setup()\n\n    def _process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        for domain in self._domain_instances.values():\n            domain.process_doc(env, docname, document)\n\n    def _clear_doc(self, docname: str) -> None:\n        for domain in self._domain_instances.values():\n            domain.clear_doc(docname)\n\n    def _merge_domain_data(\n        self, docnames: Set[str], domain_data: dict[str, Any]\n    ) -> None:\n        for domain_name, domain in self._domain_instances.items():\n            domain.merge_domaindata(docnames, domain_data[domain_name])\n\n    def _check_consistency(self) -> None:\n        for domain in self._domain_instances.values():\n            domain.check_consistency()\n\n    def __contains__(self, key: str) -> bool:\n        return key in self._domain_instances\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _DomainsContainer):\n            return NotImplemented\n        return self._domain_instances == other._domain_instances\n\n    def __hash__(self) -> int:\n        return hash(sorted(self._domain_instances.items()))\n\n    def __setattr__(self, key: str, value: object) -> None:\n        if key in self._core_domains:\n            msg = f'{self.__class__.__name__!r} object does not support assignment to {key!r}'\n            raise TypeError(msg)\n        super().__setattr__(key, value)\n\n    def __delattr__(self, key: str) -> None:\n        if key in self._core_domains:\n  "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   document.  In the object_types attribute of Domain subclasses, object type\n    names are mapped to instances of this class.\n\n    Constructor arguments:\n\n    - *lname*: localized name of the type (do not include domain name)\n    - *roles*: all the roles that can refer to an object of this type\n    - *attrs*: object attributes -- currently only \"searchprio\" is known,\n      which defines the object's priority in the full-text search index,\n      see :meth:`Domain.get_objects()`.\n    \"\"\"\n\n    known_attrs = {\n        'searchprio': 1,\n    }\n\n    def __init__(self, lname: str, /, *roles: Any, **attrs: Any) -> None:\n        self.lname: str = lname\n        self.roles: tuple[Any, ...] = roles\n        self.attrs: dict[str, Any] = self.known_attrs | attrs\n\n\nclass Domain:\n    \"\"\"A Domain is meant to be a group of \"object\" description directives for\n    objects of a similar nature, and corresponding roles to create references to\n    them.  Examples would be Python modules, classes, functions etc., elements\n    of a templating language, Sphinx roles and directives, etc.\n\n    Each domain has a separate storage for information about existing objects\n    and how to reference them in `self.data`, which must be a dictionary.  It\n    also must implement several functions that expose the object information in\n    a uniform way to parts of Sphinx that allow the user to reference or search\n    for objects in a domain-agnostic way.\n\n    About `self.data`: since all object and cross-referencing information is\n    stored on a BuildEnvironment instance, the `domain.data` object is also\n    stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n    build process starts, every active domain is instantiated and given the\n    environment object; the `domaindata` dict must then either be nonexistent or\n    a dictionary whose 'version' key is equal to the domain class'\n    :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n    pickled environment is disc"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mport CPPDomain\n        from sphinx.domains.index import IndexDomain\n        from sphinx.domains.javascript import JavaScriptDomain\n        from sphinx.domains.math import MathDomain\n        from sphinx.domains.python import PythonDomain\n        from sphinx.domains.rst import ReSTDomain\n        from sphinx.domains.std import StandardDomain\n\n        return cls(\n            c=CDomain(env),\n            changeset=ChangeSetDomain(env),\n            citation=CitationDomain(env),\n            cpp=CPPDomain(env),\n            index=IndexDomain(env),\n            js=JavaScriptDomain(env),\n            math=MathDomain(env),\n            py=PythonDomain(env),\n            rst=ReSTDomain(env),\n            std=StandardDomain(env),\n        )\n\n    def __init__(\n        self,\n        *,\n        c: CDomain,\n        cpp: CPPDomain,\n        js: JavaScriptDomain,\n        py: PythonDomain,\n        rst: ReSTDomain,\n        std: StandardDomain,\n        changeset: ChangeSetDomain,\n        citation: CitationDomain,\n        index: IndexDomain,\n        math: MathDomain,\n        **domains: Domain,\n    ) -> None:\n        # All domains, including core.\n        # Implemented as a dict for backwards compatibility.\n        self._domain_instances: Mapping[str, Domain] = {\n            'c': c,\n            'changeset': changeset,\n            'citation': citation,\n            'cpp': cpp,\n            'index': index,\n            'js': js,\n            'math': math,\n            'py': py,\n            'rst': rst,\n            'std': std,\n            **domains,\n        }\n\n        # Provide typed attributes for the core domains\n        self.standard_domain: StandardDomain = std\n        self.c_domain: CDomain = c\n        self.cpp_domain: CPPDomain = cpp\n        self.javascript_domain: JavaScriptDomain = js\n        self.python_domain: PythonDomain = py\n        self.restructuredtext_domain: ReSTDomain = rst\n        self.changeset_domain: ChangeSetDomain = changeset\n        self.citation_domain: CitationDomain = citation\n "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       index: IndexDomain,\n        math: MathDomain,\n        **domains: Domain,\n    ) -> None:\n        # All domains, including core.\n        # Implemented as a dict for backwards compatibility.\n        self._domain_instances: Mapping[str, Domain] = {\n            'c': c,\n            'changeset': changeset,\n            'citation': citation,\n            'cpp': cpp,\n            'index': index,\n            'js': js,\n            'math': math,\n            'py': py,\n            'rst': rst,\n            'std': std,\n            **domains,\n        }\n\n        # Provide typed attributes for the core domains\n        self.standard_domain: StandardDomain = std\n        self.c_domain: CDomain = c\n        self.cpp_domain: CPPDomain = cpp\n        self.javascript_domain: JavaScriptDomain = js\n        self.python_domain: PythonDomain = py\n        self.restructuredtext_domain: ReSTDomain = rst\n        self.changeset_domain: ChangeSetDomain = changeset\n        self.citation_domain: CitationDomain = citation\n        self.index_domain: IndexDomain = index\n        self.math_domain: MathDomain = math\n\n        for domain_name, domain in self._domain_instances.items():\n            # invariant from ``_DomainsContainer._from_environment``\n            if domain_name != domain.name:\n                msg = f'Domain name mismatch in {domain!r}: {domain_name!r} != {domain.name!r}'\n                raise ValueError(msg)\n\n    def _setup(self) -> None:\n        for domain in self._domain_instances.values():\n            domain.setup()\n\n    def _process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        for domain in self._domain_instances.values():\n            domain.process_doc(env, docname, document)\n\n    def _clear_doc(self, docname: str) -> None:\n        for domain in self._domain_instances.values():\n            domain.clear_doc(docname)\n\n    def _merge_domain_data(\n        self, docnames: Set[str], domain_data: dict[str, Any]\n    ) -> None:\n        for"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " domain_name, domain in self._domain_instances.items():\n            domain.merge_domaindata(docnames, domain_data[domain_name])\n\n    def _check_consistency(self) -> None:\n        for domain in self._domain_instances.values():\n            domain.check_consistency()\n\n    def __contains__(self, key: str) -> bool:\n        return key in self._domain_instances\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _DomainsContainer):\n            return NotImplemented\n        return self._domain_instances == other._domain_instances\n\n    def __hash__(self) -> int:\n        return hash(sorted(self._domain_instances.items()))\n\n    def __setattr__(self, key: str, value: object) -> None:\n        if key in self._core_domains:\n            msg = f'{self.__class__.__name__!r} object does not support assignment to {key!r}'\n            raise TypeError(msg)\n        super().__setattr__(key, value)\n\n    def __delattr__(self, key: str) -> None:\n        if key in self._core_domains:\n            msg = f'{self.__class__.__name__!r} object does not support deletion of {key!r}'\n            raise TypeError(msg)\n        super().__delattr__(key)\n\n    # Mapping interface: builtin domains\n\n    @overload\n    def __getitem__(self, key: Literal['c']) -> CDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['cpp']) -> CPPDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['changeset']) -> ChangeSetDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['citation']) -> CitationDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['index']) -> IndexDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['js']) -> JavaScriptDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['math']) -> MathDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['py']) -> PythonDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['rst']) -> ReSTDomain: ...\n\n    @overload\n    def __getitem__(self, key: Li"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          msg = f'{self.__class__.__name__!r} object does not support deletion of {key!r}'\n            raise TypeError(msg)\n        super().__delattr__(key)\n\n    # Mapping interface: builtin domains\n\n    @overload\n    def __getitem__(self, key: Literal['c']) -> CDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['cpp']) -> CPPDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['changeset']) -> ChangeSetDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['citation']) -> CitationDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['index']) -> IndexDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['js']) -> JavaScriptDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['math']) -> MathDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['py']) -> PythonDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['rst']) -> ReSTDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['std']) -> StandardDomain: ...\n\n    # Mapping interface: first-party domains\n\n    @overload\n    def __getitem__(self, key: Literal['duration']) -> DurationDomain: ...\n\n    @overload\n    def __getitem__(self, key: Literal['todo']) -> TodoDomain: ...\n\n    # Mapping interface: third-party domains\n\n    @overload\n    def __getitem__(self, key: str) -> Domain: ...\n\n    def __getitem__(self, key: str) -> Domain:\n        if domain := getattr(self, key, None):\n            return domain\n        return self._domain_instances[key]\n\n    def __setitem__(self, key: str, value: Domain) -> NoReturn:\n        msg = f'{self.__class__.__name__!r} object does not support item assignment'\n        raise TypeError(msg)\n\n    def __delitem__(self, key: str) -> NoReturn:\n        msg = f'{self.__class__.__name__!r} object does not support item deletion'\n        raise TypeError(msg)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._domain_instances.keys())\n\n    def __len__(self) -> int:\n    "}], "retrieved_count": 10, "cost_time": 1.091278314590454}
{"question": "Why does Sphinx separate the Builder concept from the Writer concept in its output generation pipeline?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx separates the Builder concept from the Writer concept in its output generation pipeline to achieve better separation of concerns, modularity, and extensibility. This separation provides several important architectural benefits.\n\nKey reasons for this separation include:\n\n1. **Separation of Concerns**: Builders focus on orchestrating the overall build process, managing file dependencies, and coordinating the build workflow, while Writers focus specifically on converting document trees to the target output format. This separation makes the codebase more maintainable and easier to understand.\n\n2. **Reusability**: Writers can be reused across different builders. For example, the same HTML writer can be used by both the HTML builder and the singlehtml builder, reducing code duplication and ensuring consistent output formatting.\n\n3. **Modularity**: The separation allows for independent development and testing of build logic and output generation logic. Builders can be modified without affecting writers, and vice versa.\n\n4. **Extensibility**: New output formats can be added by creating new writers without modifying existing builders. Similarly, new build strategies can be implemented by creating new builders that use existing writers.\n\n5. **Complexity Management**: Builders handle complex build-specific logic such as incremental builds, parallel processing, and dependency management, while writers focus on the simpler task of format conversion. This reduces the complexity of each component.\n\n6. **Testing**: The separation makes it easier to test builders and writers independently. Writers can be tested with sample document trees without needing to set up a full build environment.\n\n7. **Flexibility**: Different builders can use different strategies for managing the build process while still using the same writers for output generation. This allows for specialized builders (like linkcheck builders) that don't generate traditional documentation output.\n\n8. **Maintenance**: Changes to output formatting only require modifications to writers, while changes to build process logic only require modifications to builders. This reduces the risk of introducing bugs when making changes.\n\nThis architectural separation follows the single responsibility principle and makes Sphinx's output generation system more flexible and maintainable.", "score": null, "retrieved_content": [{"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "octree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in parallel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        "}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        if docnames:\n            logger.debug(__('docnames to write: %s'), ', '.join(sorted(docnames)))\n        else:\n            logger.debug(__('no docnames to write!'))\n\n        # add all toctree-containing files that may have changed\n        docnames |= {\n            toc_docname\n            for docname in docnames\n            for toc_docname in env.files_to_rebuild.get(docname, ())\n            if toc_docname in env.found_docs\n        }\n\n        # sort to ensure deterministic toctree generation\n        env.toctree_includes = dict(sorted(env.toctree_includes.items()))\n\n        with progress_message(__('preparing documents')):\n            self.prepare_writing(docnames)\n\n        with progress_message(__('copying assets'), nonl=False):\n            self.copy_assets()\n\n        if docnames:\n            self.write_documents(docnames)\n\n    def write_documents(self, docnames: Set[str]) -> None:\n        \"\"\"Write all documents in *docnames*.\n\n        This method can be overridden if a builder does not "}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hunk in chunks:\n            arg = []\n            for docname in chunk:\n                doctree = self.env.get_and_resolve_doctree(\n                    docname, self, tags=self.tags\n                )\n                self.write_doc_serialized(docname, doctree)\n                arg.append((docname, doctree))\n            tasks.add_task(write_process, arg, on_chunk_done)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        \"\"\"A place where you can add logic before :meth:`write_doc` is run\"\"\"\n        pass\n\n    def copy_assets(self) -> None:\n        \"\"\"Where assets (images, static files, etc) are copied before writing\"\"\"\n        pass\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Write the output file for the document\n\n        :param docname: the :term:`docname <document name>`.\n        :param doctree: defines the content to be written.\n\n        The output filename must be determined within this method,\n        typically by calling :meth:`~.Builder.get_target_uri`\n        or :meth:`~.Builder.get_relative_uri`.\n        \"\"\"\n        raise NotImplementedError\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Handle parts of write_doc that must be called in the main process\n        if parallel build is active.\n        \"\"\"\n        pass\n\n    def finish(self) -> None:\n        \"\"\"Finish the building process.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def cleanup(self) -> None:\n        \"\"\"Cleanup any resources.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def get_builder_config(self, option: str, default: str) -> Any:\n        \"\"\"Return a builder specific option.\n\n        This method allows customization of common builder settings by\n        inserting the name of the current builder in the option key.\n        If the key does not"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n    allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n  "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tput filename must be determined within this method,\n        typically by calling :meth:`~.Builder.get_target_uri`\n        or :meth:`~.Builder.get_relative_uri`.\n        \"\"\"\n        raise NotImplementedError\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Handle parts of write_doc that must be called in the main process\n        if parallel build is active.\n        \"\"\"\n        pass\n\n    def finish(self) -> None:\n        \"\"\"Finish the building process.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def cleanup(self) -> None:\n        \"\"\"Cleanup any resources.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def get_builder_config(self, option: str, default: str) -> Any:\n        \"\"\"Return a builder specific option.\n\n        This method allows customization of common builder settings by\n        inserting the name of the current builder in the option key.\n        If the key does not exist, use default as builder name.\n        \"\"\"\n        # At the moment, only XXX_use_index is looked up this way.\n        # Every new builder variant must be registered in Config.config_values.\n        try:\n            optname = f'{self.name}_{option}'\n            return getattr(self.config, optname)\n        except AttributeError:\n            optname = f'{default}_{option}'\n            return getattr(self.config, optname)\n\n\ndef _write_docname(\n    docname: str,\n    /,\n    *,\n    env: BuildEnvironment,\n    builder: Builder,\n    tags: Tags,\n) -> None:\n    \"\"\"Write a single document.\"\"\"\n    builder.phase = BuildPhase.RESOLVING\n    doctree = env.get_and_resolve_doctree(docname, builder=builder, tags=tags)\n    builder.phase = BuildPhase.WRITING\n    builder.write_doc_serialized(docname, doctree)\n    builder.write_doc(docname, doctree)\n\n\nclass _UnicodeDecodeErrorHandler:\n    \"\"\"Custom error handler for open() that warns and replaces.\"\"\"\n\n    def __init__(self, docname: str, /) -> None:\n    "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n        ensuredir(self.doctreedir)\n\n        self._app: Sphinx = app\n        self.env: BuildEnvironment = env\n        self.env.set_versioning_method(self.versioning_method, self.versioning_compare)\n        self.events: EventManager = app.events\n        self.config: Config = app.config\n        self.tags: Tags = app.tags\n        self.tags.add(self.format)\n        self.tags.add(self.name)\n        self.tags.add(f'format_{self.format}')\n        self.tags.add(f'builder_{self.name}')\n        self._registry = app.registry\n\n        # images that need to be copied over (source -> dest)\n        self.images: dict[str, str] = {}\n        # basename of images directory\n        self.imagedir = ''\n        # relative path to image directory from current docname (used at writing docs)\n        self.imgpath = ''\n\n        # these get set later\n        self.parallel_ok = False\n        self.finish_tasks: Any = None\n\n    @property\n    def app(self) -> Sphinx:\n        cls_module = self.__class__.__module__\n       "}, {"start_line": 2000, "end_line": 3970, "belongs_to": {"file_name": "xml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "indall(nodes.Element):\n            for att, value in node.attributes.items():\n                if isinstance(value, tuple):\n                    node.attributes[att] = list(value)\n                value = node.attributes[att]\n                if isinstance(value, list):\n                    for i, val in enumerate(value):\n                        if isinstance(val, tuple):\n                            value[i] = list(val)\n        output = self._translate(doctree)\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def _translate(self, doctree: nodes.document) -> str:\n        doctree.settings.newlines = doctree.settings.indents = self.config.xml_pretty\n        doctree.settings.xml_declaration = True\n        doctree.settings.doctype_declaration = True\n\n        # copied from docutils.writers.docutils_xml.Writer.translate()\n        # so that we can override the translator class\n        visitor: XMLTranslator = self.create_translator(doctree)\n        doctree.walkabout(visitor)\n        return ''.join(visitor.output)\n\n    def finish(self) -> None:\n        pass\n\n\nclass PseudoXMLBuilder(XMLBuilder):\n    \"\"\"Builds pseudo-XML for display purposes.\"\"\"\n\n    name = 'pseudoxml'\n    format = 'pseudoxml'\n    epilog = __('The pseudo-XML files are in %(outdir)s.')\n\n    out_suffix = '.pseudoxml'\n\n    def _translate(self, doctree: nodes.document) -> str:\n        return doctree.pformat()\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_builder(XMLBuilder)\n    app.add_builder(PseudoXMLBuilder)\n\n    app.add_config_value('xml_pretty', True, 'env', types=frozenset({bool}))\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 1000, "end_line": 2959, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                yield docname\n                continue\n            targetname = self.outdir / (docname + self.out_suffix)\n            try:\n                targetmtime = _last_modified_time(targetname)\n            except Exception:\n                targetmtime = 0\n            try:\n                srcmtime = _last_modified_time(self.env.doc2path(docname))\n                if srcmtime > targetmtime:\n                    yield docname\n            except OSError:\n                # source doesn't exist anymore\n                pass\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        return ''\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        self.current_docname = docname\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        visitor: TextTranslator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        output = visitor.body\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def finish(self) -> None:\n        pass\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_builder(TextBuilder)\n\n    app.add_config_value('text_sectionchars', '*=-~\"+`', 'env', types=frozenset({str}))\n    app.add_config_value('text_newlines', 'unix', 'env', types=frozenset({str}))\n    app.add_config_value('text_add_secnumbers', True, 'env', types=frozenset({bool}))\n    app.add_config_value('text_secnumber_suffix', '. ', 'env', types=frozenset({str}))\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "i18n.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport os.path\nimport re\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nimport babel.dates\nfrom babel.messages.mofile import write_mo\nfrom babel.messages.pofile import read_po\n\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import SEP, _last_modified_time\n\nif TYPE_CHECKING:\n    import datetime as dt\n    from collections.abc import Iterator\n    from typing import Protocol, TypeAlias\n\n    from babel.core import Locale\n\n    from sphinx.environment import BuildEnvironment\n\n    class DateFormatter(Protocol):\n        def __call__(\n            self,\n            date: dt.date | None = ...,\n            format: str = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class TimeFormatter(Protocol):\n        def __call__(\n            self,\n            time: dt.time | dt.datetime | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class DatetimeFormatter(Protocol):\n        def __call__(\n            self,\n            datetime: dt.date | dt.time | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    Formatter: TypeAlias = DateFormatter | TimeFormatter | DatetimeFormatter\n\nfrom datetime import UTC\n\nlogger = logging.getLogger(__name__)\n\n\nclass CatalogInfo:\n    __slots__ = 'base_dir', 'domain', 'charset'\n\n    def __init__(\n        self, base_dir: str | os.PathLike[str], domain: str, charset: str\n    ) -> None:\n        self.base_dir = _StrPath(base_dir)\n        self.domain = domain\n        self.charset = charset\n\n    @property\n    def po_file(self) -> str:\n        return f'{self.domain}.po'\n\n    @property\n "}], "retrieved_count": 10, "cost_time": 1.0684814453125}
{"question": "Why does Sphinx implement an incremental build system for large documentation projects?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements an incremental build system for large documentation projects to address the performance and efficiency challenges that arise when dealing with extensive documentation sets. This approach provides significant benefits for both development workflow and build performance.\n\nKey reasons for implementing incremental builds include:\n\n1. **Build Time Optimization**: Large documentation projects can contain thousands of files, and rebuilding everything from scratch would be prohibitively time-consuming. Incremental builds only process files that have changed since the last build, dramatically reducing build times.\n\n2. **Development Efficiency**: During active documentation development, developers often make small changes to individual files. Incremental builds allow for rapid feedback by only rebuilding the affected parts, enabling faster iteration cycles.\n\n3. **Resource Conservation**: Full rebuilds of large projects consume significant computational resources (CPU, memory, disk I/O). Incremental builds minimize resource usage by avoiding unnecessary processing of unchanged files.\n\n4. **Dependency Tracking**: The incremental build system tracks dependencies between documents, ensuring that when one document changes, all documents that depend on it are also rebuilt. This maintains consistency while still avoiding unnecessary work.\n\n5. **Environment Persistence**: Sphinx caches the build environment (including cross-references, metadata, and document relationships) between builds, allowing the system to skip expensive parsing and analysis phases for unchanged files.\n\n6. **Scalability**: As documentation projects grow in size, the benefits of incremental builds become more pronounced. The system scales better with project size compared to full rebuilds.\n\n7. **User Experience**: Faster build times improve the overall user experience for documentation maintainers, making the development process more efficient and less frustrating.\n\n8. **CI/CD Integration**: Incremental builds are particularly valuable in continuous integration environments where builds need to be fast and efficient to provide timely feedback.\n\nThe incremental build system is a key feature that makes Sphinx practical for large-scale documentation projects and contributes to its widespread adoption in the documentation community.", "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 10634, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path or '', removal version)\n_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {\n    'strip_escseq': (\n        strip_escape_sequences,\n        'sphinx.util.console.strip_escape_sequences',\n        (9, 0),\n    ),\n}\n\n\ndef __getattr__(name: str) -> Any:\n    if name not in _DEPRECATED_OBJECTS:\n        msg = f'module {__name__!r} has no attribute {name!r}'\n        raise AttributeError(msg)\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=remove)\n    return deprecated_object\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mand line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @final\n    def build(\n        self,\n        docnames: Iterable[str] | None,\n        summary: str | None = None,\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Main build method, usually called by a specific ``build_*`` method.\n\n        First updates the environment, and then calls\n        :meth:`!write`.\n        \"\"\"\n        if summary:\n            logger.info(bold(__('building [%s]: ')) + summary, self.name)  # NoQA: G003\n\n        # while reading, collect all warnings from docutils\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            updated_docnames = set(self.read())\n\n        doccount = len(updated_docnames)\n        logger.info(bold(__('looking for now-outdated files... ')), nonl=True)\n        updated_docnames.update(self.env.check_dependents(self._app, updated_docnames))\n        outdated = len(updated_docnames) - doccount\n        if outdate"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me: Path) -> BuildEnvironment:\n        try:\n            with open(filename, 'rb') as f:\n                env = pickle.load(f)\n            env.setup(self)\n            self._fresh_env_used = False\n        except Exception as err:\n            logger.info(__('failed: %s'), err)\n            env = self._create_fresh_env()\n        return env\n\n    def _post_init_env(self) -> None:\n        if self._fresh_env_used:\n            self.env.find_files(self.config, self.builder)\n\n        self.env._builder_cls = self.builder.__class__\n\n    def preload_builder(self, name: str) -> None:\n        self.registry.preload_builder(self, name)\n\n    def create_builder(self, name: str) -> Builder:\n        if name is None:\n            logger.info(__('No builder selected, using default: html'))\n            name = 'html'\n\n        return self.registry.create_builder(self, name, self.env)\n\n    def _init_builder(self) -> None:\n        self.builder.init()\n        self.events.emit('builder-inited')\n\n    # ---- main \"build\" method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              exception_on_warning=exception_on_warning,\n            )\n        except Exception:\n            self.cleanup()\n            raise\n\n    def _init_builder(self) -> None:\n        # override the default theme to 'basic' rather than 'alabaster'\n        # for test independence\n\n        if 'html_theme' in self.config._overrides:\n            pass  # respect overrides\n        elif 'html_theme' in self.config and self.config.html_theme == 'alabaster':\n            self.config.html_theme = self.config._overrides.get('html_theme', 'basic')\n        super()._init_builder()\n\n    @property\n    def status(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application status messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._status, StringIO)\n        return self._status\n\n    @property\n    def warning(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application warning messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(sel"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "octree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in parallel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport codecs\nimport pickle\nimport re\nimport time\nfrom contextlib import nullcontext\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, final\n\nfrom docutils import nodes\n\nfrom sphinx._cli.util.colour import bold\nfrom sphinx.deprecation import _deprecation_warning\nfrom sphinx.environment import (\n    CONFIG_CHANGED_REASON,\n    CONFIG_OK,\n    _CurrentDocument,\n)\nfrom sphinx.environment.adapters.asset import ImageAdapter\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import get_filetype, logging\nfrom sphinx.util._importer import import_object\nfrom sphinx.util._pathlib import _StrPathProperty\nfrom sphinx.util.build_phase import BuildPhase\nfrom sphinx.util.display import progress_message, status_iterator\nfrom sphinx.util.docutils import _parse_str_to_doctree\nfrom sphinx.util.i18n import CatalogRepository, docname_to_domain\nfrom sphinx.util.osutil import ensuredir, relative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n "}], "retrieved_count": 10, "cost_time": 1.0791385173797607}
{"question": "What is the relationship between Sphinx's Config class and the Project class in configuration inheritance?", "answer": null, "relative_code_list": null, "ground_truth": "The relationship between Sphinx's Config class and Project class in configuration inheritance is primarily one of data sharing and coordination rather than direct inheritance. Both classes work together to manage different aspects of the project's configuration and metadata.\n\nKey aspects of this relationship include:\n\n1. **Configuration Access**: The Project class has access to the Config object through the environment (`env.config`), allowing it to read configuration values that affect project behavior, such as source file suffixes and other project-specific settings.\n\n2. **Source File Management**: The Project class uses configuration information from the Config class to determine which files should be considered as source files for the documentation project. It relies on the `source_suffix` configuration to identify valid source file extensions.\n\n3. **Project Metadata**: While the Config class manages most configuration values, the Project class handles project-specific metadata such as the list of source files, their relationships, and project structure information.\n\n4. **Environment Integration**: Both classes are integrated through the BuildEnvironment, where the environment maintains references to both the config (`env.config`) and the project (`env.project`), allowing them to work together seamlessly.\n\n5. **Initialization Coordination**: During Sphinx initialization, the Config class is created first from the conf.py file, and then the Project class is created using configuration values from the Config class to set up the project structure.\n\n6. **Data Persistence**: The Project class can be serialized and restored as part of the environment, allowing project information to persist across builds, while the Config class is recreated from the conf.py file on each build.\n\nThis relationship ensures that project-specific information and general configuration settings work together to provide a complete picture of the documentation project's setup and requirements.", "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      default, rebuild, valid_types, description = state\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __getitem__(self, item: int | slice) -> Any:\n        warnings.warn(\n            f'The {self.__class__.__name__!r} object tuple interface is deprecated, '\n            \"use attribute access instead for 'default', 'rebuild', and 'valid_types'.\",\n            RemovedInSphinx90Warning,\n            stacklevel=2,\n        )\n        return (self.default, self.rebuild, self.valid_types)[item]\n\n\nclass Config:\n    r\"\"\"Configuration file abstraction.\n\n    The Config object makes the values of all config options available as\n    attributes.\n\n    It is exposed via the :py:class:`~sphinx.application.Sphinx`\\ ``.config``\n    and :py:class:`sphinx.environment.BuildEnvironment`\\ ``.config`` attributes.\n    For example, to get the value of :confval:`language`, use either\n    ``app.config.language`` or ``env.config.language``.\n    \"\"\"\n\n    # The values are:\n    # 1. Default\n    # 2. What needs to be rebuilt if changed\n    # 3. Valid types\n\n    # If you add a value here, remember to include it in the docs!\n\n    config_values: dict[str, _Opt] = {\n        # general options\n        'project': _Opt('Project name not set', 'env', frozenset((str,))),\n        'author': _Opt('Author name not set', 'env', frozenset((str,))),\n        'project_copyright': _Opt('', 'html', frozenset((str, tuple, list))),\n        'copyright': _Opt(\n            lambda config: config.project_copyright,\n            'html',\n            frozenset((str, tuple, list)),\n        ),\n        'version': _Opt('', 'env', frozenset((str,))),\n        'release': _Opt('', 'env', frozenset((str,))),\n        'today': _Opt('', 'env', frozenset((str,))),\n        # the real default is locale-dependent\n        'today_fmt': _Opt(None, 'env', frozenset((str,))),\n        'lan"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ning, stacklevel=2)\n\n    def init_values(self) -> None:\n        # method only retained for compatibility\n        self._report_override_warnings()\n        # warnings.warn(\n        #     'Config.init_values() will be removed in Sphinx 9.0 or later',\n        #     RemovedInSphinx90Warning, stacklevel=2)\n\n    def _report_override_warnings(self) -> None:\n        for name in self._overrides:\n            if name not in self._options:\n                logger.warning(\n                    __('unknown config value %r in override, ignoring'), name\n                )\n\n    def __repr__(self) -> str:\n        values = []\n        for opt_name in self._options:\n            try:\n                opt_value = getattr(self, opt_name)\n            except Exception:\n                opt_value = '<error!>'\n            values.append(f'{opt_name}={opt_value!r}')\n        return self.__class__.__qualname__ + '(' + ', '.join(values) + ')'\n\n    def __setattr__(self, key: str, value: object) -> None:\n        # Ensure aliases update their counterpart.\n        if key == 'master_doc':\n            super().__setattr__('root_doc', value)\n        elif key == 'root_doc':\n            super().__setattr__('master_doc', value)\n        elif key == 'copyright':\n            super().__setattr__('project_copyright', value)\n        elif key == 'project_copyright':\n            super().__setattr__('copyright', value)\n        super().__setattr__(key, value)\n\n    def __getattr__(self, name: str) -> Any:\n        if name in self._options:\n            # first check command-line overrides\n            if name in self._overrides:\n                value = self._overrides[name]\n                if not isinstance(value, str):\n                    self.__dict__[name] = value\n                    return value\n                try:\n                    value = self.convert_overrides(name, value)\n                except ValueError as exc:\n                    logger.warning('%s', exc)\n                else:\n                    self.__setattr__(n"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     ),\n        'option_emphasise_placeholders': _Opt(False, 'env', frozenset((bool,))),\n    }\n\n    def __init__(\n        self,\n        config: dict[str, Any] | None = None,\n        overrides: dict[str, Any] | None = None,\n    ) -> None:\n        raw_config: dict[str, Any] = config or {}\n        self._overrides = dict(overrides) if overrides is not None else {}\n        self._options = Config.config_values.copy()\n        self._raw_config = raw_config\n\n        for name in list(self._overrides.keys()):\n            if '.' in name:\n                real_name, _, key = name.partition('.')\n                raw_config.setdefault(real_name, {})[key] = self._overrides.pop(name)\n\n        self.setup: _ExtensionSetupFunc | None = raw_config.get('setup')\n\n        if 'extensions' in self._overrides:\n            extensions = self._overrides.pop('extensions')\n            if isinstance(extensions, str):\n                raw_config['extensions'] = extensions.split(',')\n            else:\n                raw_config['extensions'] = extensions\n        self.extensions: list[str] = raw_config.get('extensions', [])\n\n        self._verbosity: int = 0  # updated in Sphinx.__init__()\n\n    @property\n    def values(self) -> dict[str, _Opt]:\n        return self._options\n\n    @property\n    def overrides(self) -> dict[str, Any]:\n        return self._overrides\n\n    @property\n    def verbosity(self) -> int:\n        return self._verbosity\n\n    @classmethod\n    def read(\n        cls: type[Config],\n        confdir: str | os.PathLike[str],\n        *,\n        overrides: dict[str, Any],\n        tags: Tags,\n    ) -> Config:\n        \"\"\"Create a Config object from configuration file.\"\"\"\n        filename = Path(confdir, CONFIG_FILENAME)\n        if not filename.is_file():\n            raise ConfigError(\n                __(\"config directory doesn't contain a conf.py file (%s)\") % confdir\n            )\n        return _read_conf_py(filename, overrides=overrides, tags=tags)\n\n    def convert_overrides(self, name: str, valu"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         # will always mark the config value as changed,\n                    # and thus always invalidate the cache and perform a rebuild.\n                    logger.warning(\n                        __(\n                            'cannot cache unpickleable configuration value: %r '\n                            '(because it contains a function, class, or module object)'\n                        ),\n                        name,\n                        type='config',\n                        subtype='cache',\n                        once=True,\n                    )\n                # omit unserializable value\n                real_value = None\n            # valid_types is also omitted\n            _options[name] = real_value, opt.rebuild\n\n        return __dict__\n\n    def __setstate__(self, state: dict[str, Any]) -> None:\n        self._overrides = {}\n        self._options = {\n            name: _Opt(real_value, rebuild, frozenset())\n            for name, (real_value, rebuild) in state.pop('_options').items()\n        }\n        self._raw_config = {}\n        self.__dict__.update(state)\n\n\ndef _read_conf_py(conf_path: Path, *, overrides: dict[str, Any], tags: Tags) -> Config:\n    \"\"\"Create a Config object from a conf.py file.\"\"\"\n    namespace = eval_config_file(conf_path, tags)\n\n    # Note: Old sphinx projects have been configured as \"language = None\" because\n    #       sphinx-quickstart previously generated this by default.\n    #       To keep compatibility, they should be fallback to 'en' for a while\n    #       (This conversion should not be removed before 2025-01-01).\n    if namespace.get('language', ...) is None:\n        logger.warning(\n            __(\n                \"Invalid configuration value found: 'language = None'. \"\n                'Update your configuration to a valid language code. '\n                \"Falling back to 'en' (English).\"\n            )\n        )\n        namespace['language'] = 'en'\n    return Config(namespace, overrides)\n\n\ndef eval_config_file(filename: P"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "onfig['extensions'] = extensions\n        self.extensions: list[str] = raw_config.get('extensions', [])\n\n        self._verbosity: int = 0  # updated in Sphinx.__init__()\n\n    @property\n    def values(self) -> dict[str, _Opt]:\n        return self._options\n\n    @property\n    def overrides(self) -> dict[str, Any]:\n        return self._overrides\n\n    @property\n    def verbosity(self) -> int:\n        return self._verbosity\n\n    @classmethod\n    def read(\n        cls: type[Config],\n        confdir: str | os.PathLike[str],\n        *,\n        overrides: dict[str, Any],\n        tags: Tags,\n    ) -> Config:\n        \"\"\"Create a Config object from configuration file.\"\"\"\n        filename = Path(confdir, CONFIG_FILENAME)\n        if not filename.is_file():\n            raise ConfigError(\n                __(\"config directory doesn't contain a conf.py file (%s)\") % confdir\n            )\n        return _read_conf_py(filename, overrides=overrides, tags=tags)\n\n    def convert_overrides(self, name: str, value: str) -> Any:\n        opt = self._options[name]\n        default = opt.default\n        valid_types = opt.valid_types\n        if valid_types == Any:\n            return value\n        if isinstance(valid_types, ENUM):\n            if False in valid_types._candidates and value == '0':\n                return False\n            if True in valid_types._candidates and value == '1':\n                return True\n            return value\n        elif type(default) is bool or (bool in valid_types):\n            if value == '0':\n                return False\n            if value == '1':\n                return True\n            if len(valid_types) > 1:\n                return value\n            msg = __(\"'%s' must be '0' or '1', got '%s'\") % (name, value)\n            raise ConfigError(msg)\n        if isinstance(default, dict):\n            raise ValueError(  # NoQA: TRY004\n                __(\n                    'cannot override dictionary config setting %r, '\n                    'ignoring (use %r to set in"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ns').items()\n        }\n        self._raw_config = {}\n        self.__dict__.update(state)\n\n\ndef _read_conf_py(conf_path: Path, *, overrides: dict[str, Any], tags: Tags) -> Config:\n    \"\"\"Create a Config object from a conf.py file.\"\"\"\n    namespace = eval_config_file(conf_path, tags)\n\n    # Note: Old sphinx projects have been configured as \"language = None\" because\n    #       sphinx-quickstart previously generated this by default.\n    #       To keep compatibility, they should be fallback to 'en' for a while\n    #       (This conversion should not be removed before 2025-01-01).\n    if namespace.get('language', ...) is None:\n        logger.warning(\n            __(\n                \"Invalid configuration value found: 'language = None'. \"\n                'Update your configuration to a valid language code. '\n                \"Falling back to 'en' (English).\"\n            )\n        )\n        namespace['language'] = 'en'\n    return Config(namespace, overrides)\n\n\ndef eval_config_file(filename: Path, tags: Tags) -> dict[str, Any]:\n    \"\"\"Evaluate a config file.\"\"\"\n    namespace: dict[str, Any] = {\n        '__file__': str(filename),\n        'tags': tags,\n    }\n\n    with chdir(filename.parent):\n        # during executing config file, current dir is changed to ``confdir``.\n        try:\n            code = compile(filename.read_bytes(), filename, 'exec')\n            exec(code, namespace)  # NoQA: S102\n        except SyntaxError as err:\n            msg = __('There is a syntax error in your configuration file: %s\\n')\n            raise ConfigError(msg % err) from err\n        except SystemExit as exc:\n            msg = __(\n                'The configuration file (or one of the modules it imports) '\n                'called sys.exit()'\n            )\n            raise ConfigError(msg) from exc\n        except ConfigError:\n            # pass through ConfigError from conf.py as is.  It will be shown in console.\n            raise\n        except Exception as exc:\n            msg = __('There is"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "other_tpl\n        return NotImplemented\n\n    def __hash__(self) -> int:\n        return hash((self.default, self.rebuild, self.valid_types, self.description))\n\n    def __setattr__(self, key: str, value: Any) -> None:\n        if key in {'default', 'rebuild', 'valid_types', 'description'}:\n            msg = f'{self.__class__.__name__!r} object does not support assignment to {key!r}'\n            raise TypeError(msg)\n        super().__setattr__(key, value)\n\n    def __delattr__(self, key: str) -> None:\n        if key in {'default', 'rebuild', 'valid_types', 'description'}:\n            msg = f'{self.__class__.__name__!r} object does not support deletion of {key!r}'\n            raise TypeError(msg)\n        super().__delattr__(key)\n\n    def __getstate__(self) -> tuple[Any, _ConfigRebuild, _OptValidTypes, str]:\n        return self.default, self.rebuild, self.valid_types, self.description\n\n    def __setstate__(\n        self, state: tuple[Any, _ConfigRebuild, _OptValidTypes, str]\n    ) -> None:\n        default, rebuild, valid_types, description = state\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __getitem__(self, item: int | slice) -> Any:\n        warnings.warn(\n            f'The {self.__class__.__name__!r} object tuple interface is deprecated, '\n            \"use attribute access instead for 'default', 'rebuild', and 'valid_types'.\",\n            RemovedInSphinx90Warning,\n            stacklevel=2,\n        )\n        return (self.default, self.rebuild, self.valid_types)[item]\n\n\nclass Config:\n    r\"\"\"Configuration file abstraction.\n\n    The Config object makes the values of all config options available as\n    attributes.\n\n    It is exposed via the :py:class:`~sphinx.application.Sphinx`\\ ``.config``\n    and :py:class:`sphinx.environment.BuildEnvironment`\\ ``.config`` attributes.\n    For example, to get the value "}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dividual elements)'\n                )\n                % (name, f'{name}.key=value')\n            )\n        if isinstance(default, list):\n            return value.split(',')\n        if isinstance(default, int):\n            try:\n                return int(value)\n            except ValueError as exc:\n                raise ValueError(\n                    __('invalid number %r for config value %r, ignoring')\n                    % (value, name)\n                ) from exc\n        if callable(default):\n            return value\n        if isinstance(default, str) or default is None:\n            return value\n        raise ValueError(\n            __('cannot override config setting %r with unsupported type, ignoring')\n            % name\n        )\n\n    @staticmethod\n    def pre_init_values() -> None:\n        # method only retained for compatibility\n        pass\n        # warnings.warn(\n        #     'Config.pre_init_values() will be removed in Sphinx 9.0 or later',\n        #     RemovedInSphinx90Warning, stacklevel=2)\n\n    def init_values(self) -> None:\n        # method only retained for compatibility\n        self._report_override_warnings()\n        # warnings.warn(\n        #     'Config.init_values() will be removed in Sphinx 9.0 or later',\n        #     RemovedInSphinx90Warning, stacklevel=2)\n\n    def _report_override_warnings(self) -> None:\n        for name in self._overrides:\n            if name not in self._options:\n                logger.warning(\n                    __('unknown config value %r in override, ignoring'), name\n                )\n\n    def __repr__(self) -> str:\n        values = []\n        for opt_name in self._options:\n            try:\n                opt_value = getattr(self, opt_name)\n            except Exception:\n                opt_value = '<error!>'\n            values.append(f'{opt_name}={opt_value!r}')\n        return self.__class__.__qualname__ + '(' + ', '.join(values) + ')'\n\n    def __setattr__(self, key: str, value: object) -> None:\n        # Ensure alia"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    description: str\n\n    def __init__(\n        self,\n        default: Any,\n        rebuild: _ConfigRebuild,\n        valid_types: _OptValidTypes,\n        description: str = '',\n    ) -> None:\n        \"\"\"Configuration option type for Sphinx.\n\n        The type is intended to be immutable; changing the field values\n        is an unsupported action.\n        No validation is performed on the values, though consumers will\n        likely expect them to be of the types advertised.\n        The old tuple-based interface will be removed in Sphinx 9.\n        \"\"\"\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __repr__(self) -> str:\n        return (\n            f'{self.__class__.__qualname__}('\n            f'default={self.default!r}, '\n            f'rebuild={self.rebuild!r}, '\n            f'valid_types={self.rebuild!r}, '\n            f'description={self.description!r})'\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, _Opt):\n            self_tpl = (\n                self.default,\n                self.rebuild,\n                self.valid_types,\n                self.description,\n            )\n            other_tpl = (\n                other.default,\n                other.rebuild,\n                other.valid_types,\n                other.description,\n            )\n            return self_tpl == other_tpl\n        return NotImplemented\n\n    def __lt__(self, other: _Opt) -> bool:\n        if self.__class__ is other.__class__:\n            self_tpl = (\n                self.default,\n                self.rebuild,\n                self.valid_types,\n                self.description,\n            )\n            other_tpl = (\n                other.default,\n                other.rebuild,\n                other.valid_types,\n                other.description,\n            )\n            return self_tpl > "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pt\n\n    with pytest.warns(RemovedInSphinx90Warning):\n        _ = opt[0]\n\n    with pytest.warns(RemovedInSphinx90Warning):\n        _ = list(opt)\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='config',\n    confoverrides={\n        'root_doc': 'root',\n        'nonexisting_value': 'True',\n        'latex_elements.maketitle': 'blah blah blah',\n        'modindex_common_prefix': 'path1,path2',\n    },\n)\ndef test_core_config(app: SphinxTestApp) -> None:\n    cfg = app.config\n\n    # simple values\n    assert 'project' in cfg.__dict__\n    assert cfg.project == 'Sphinx <Tests>'\n    assert cfg.templates_path == ['_templates']\n\n    # overrides\n    assert cfg.root_doc == 'root'\n    assert cfg.latex_elements['maketitle'] == 'blah blah blah'\n    assert cfg.modindex_common_prefix == ['path1', 'path2']\n\n    # simple default values\n    assert 'locale_dirs' in cfg.__dict__\n    assert cfg.locale_dirs == ['locales']\n    assert cfg.trim_footnote_reference_space is False\n\n    # complex default values\n    assert 'html_title' not in cfg.__dict__\n    assert cfg.html_title == 'Sphinx <Tests> 0.6alpha1 documentation'\n\n    # complex default values mustn't raise\n    for valuename in cfg.config_values:\n        getattr(cfg, valuename)\n\n    # \"contains\" gives True both for set and unset values\n    assert 'project' in cfg\n    assert 'html_title' in cfg\n    assert 'nonexisting_value' not in cfg\n\n    # invalid values\n    with pytest.raises(AttributeError):\n        _ = cfg._value\n    with pytest.raises(AttributeError):\n        _ = cfg.nonexisting_value\n\n    # non-value attributes are deleted from the namespace\n    with pytest.raises(AttributeError):\n        _ = cfg.sys\n\n    # setting attributes\n    cfg.project = 'Foo'\n    assert cfg.project == 'Foo'\n\n    # alternative access via item interface\n    cfg['project'] = 'Sphinx Tests'\n    assert cfg['project'] == cfg.project == 'Sphinx Tests'\n\n\ndef test_config_not_found(tmp_path):\n    with pytest.raises(ConfigError):\n        Config.read(tmp_path, overrides={}, t"}], "retrieved_count": 10, "cost_time": 1.094825267791748}
{"question": "What is the relationship between Sphinx's Domain system and the Role system in cross-reference resolution?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's Domain system and Role system work together in a tightly integrated manner to provide comprehensive cross-reference resolution capabilities. The relationship between these systems is fundamental to Sphinx's ability to handle cross-references across different types of documentation objects.\n\nKey aspects of this relationship include:\n\n1. **Domain-Specific Roles**: Each domain provides its own set of roles for creating cross-references to objects within that domain. For example, the Python domain provides roles like `:py:func:`, `:py:class:`, and `:py:mod:` for referencing Python functions, classes, and modules respectively.\n\n2. **Role Registration**: Domains register their domain-specific roles in the `roles` attribute, which maps role names to role functions. These roles are then available for use in documents and are processed during the cross-reference resolution phase.\n\n3. **Object Type Mapping**: Domains define object types through the `object_types` attribute, which maps object type names to `ObjType` instances. Each object type specifies which roles can be used to reference objects of that type.\n\n4. **Cross-Reference Resolution**: When a role is used in a document, the domain system provides the logic to resolve the reference to the appropriate object. The domain's `resolve_xref` method is called to find the target object and create the appropriate reference node.\n\n5. **Data Storage**: Domains store information about documented objects in their `data` attribute, which is used during cross-reference resolution to find the target objects and their locations.\n\n6. **Namespace Isolation**: The domain system ensures that cross-references are resolved within the correct context, preventing conflicts between different types of objects (e.g., Python functions vs. C++ functions).\n\n7. **Extension Integration**: Both systems work together to support extensions that can add new object types, roles, and cross-reference resolution logic to existing domains or create entirely new domains.\n\nThis integration allows Sphinx to provide rich cross-referencing capabilities while maintaining clear separation between different types of documentation objects and ensuring that references are resolved correctly within their appropriate contexts.", "score": null, "retrieved_content": [{"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es) == 2:\n            # domain:role:\n            domain_name, role = names\n        else:\n            return None\n\n        if domain_name and self.is_existent_role(domain_name, role):\n            return domain_name, role\n        elif self.is_existent_role('std', role):\n            return 'std', role\n        else:\n            return None\n\n    def is_existent_role(self, domain_name: str, role_name: str) -> bool:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.is_existent_role', '', remove=(9, 0)\n        )\n        try:\n            domain = self.env.domains[domain_name]\n        except KeyError:\n            return False\n        else:\n            return role_name in domain.roles\n\n    def invoke_role(\n        self, role: tuple[str, str]\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Invoke the role described by a ``(domain, role name)`` pair.\"\"\"\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.invoke_role', '', remove=(9, 0)\n        )\n        domain = self.env.get_domain(role[0])\n        if domain:\n            role_func = domain.role(role[1])\n            assert role_func is not None\n\n            return role_func(\n                ':'.join(role),\n                self.rawtext,\n                self.text,\n                self.lineno,\n                self.inliner,\n                self.options,\n                self.content,\n            )\n        else:\n            return [], []\n\n\nclass IntersphinxRoleResolver(ReferencesResolver):\n    \"\"\"pending_xref node resolver for intersphinx role.\n\n    This resolves pending_xref nodes generated by :intersphinx:***: role.\n    \"\"\"\n\n    default_priority = ReferencesResolver.default_priority - 1\n\n    def run(self, **kwargs: Any) -> None:\n        for node in self.document.findall(pending_xref):\n            if 'intersphinx' not in node:\n                continue\n            contnode = cast('nodes.TextElement', node[0].deepcopy())\n            inv_name = node['inventory']\n     "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "concat_strings(domain.name for domain in domains)\n                msg = 'role for external cross-reference not found in domains %s: %r'\n                possible_roles: set[str] = {\n                    f'{domain.name}:{r}'\n                    for domain in domains\n                    if (object_types := domain.object_types.get(role_name))\n                    for r in object_types.roles\n                }\n                if possible_roles:\n                    msg = f'{msg} (perhaps you meant one of: %s)'\n                    self._emit_warning(\n                        __(msg),\n                        domains_str,\n                        role_name,\n                        self._concat_strings(possible_roles),\n                    )\n                else:\n                    self._emit_warning(__(msg), domains_str, role_name)\n                return [], []\n\n        result, messages = role_func(\n            f'{domain_name}:{role_name}',\n            self.rawtext,\n            self.text,\n            self.lineno,\n            self.inliner,\n            self.options,\n            self.content,\n        )\n\n        if not self_referential:\n            # We do the intersphinx resolution by inserting our\n            # 'intersphinx' and 'inventory' attributes into the nodes.\n            # Only do this when it is an external reference.\n            for node in result:\n                if isinstance(node, pending_xref):\n                    node['intersphinx'] = True\n                    node['inventory'] = inventory\n\n        return result, messages\n\n    def get_inventory_and_name_suffix(self, name: str) -> tuple[str | None, str]:\n        \"\"\"Extract an inventory name (if any) and ``domain+name`` suffix from a role *name*.\n        and the domain+name suffix.\n\n        The role name is expected to be of one of the following forms:\n\n        - ``external+inv:name`` -- explicit inventory and name, any domain.\n        - ``external+inv:domain:name`` -- explicit inventory, domain and name.\n        - ``ex"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " == 2:\n            return names[0], names[1]\n        else:\n            return None, None\n\n    def _emit_warning(self, msg: str, /, *args: Any) -> None:\n        LOGGER.warning(\n            msg,\n            *args,\n            type='intersphinx',\n            subtype='external',\n            location=(self.env.current_document.docname, self.lineno),\n        )\n\n    def _concat_strings(self, strings: Iterable[str]) -> str:\n        return ', '.join(f'{s!r}' for s in sorted(strings))\n\n    # deprecated methods\n\n    def get_role_name(self, name: str) -> tuple[str, str] | None:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.get_role_name', '', remove=(9, 0)\n        )\n        names = name.split(':')\n        if len(names) == 1:\n            # role\n            if (domain := self.env.current_document.default_domain) is not None:\n                domain_name = domain.name\n            else:\n                domain_name = None\n            role = names[0]\n        elif len(names) == 2:\n            # domain:role:\n            domain_name, role = names\n        else:\n            return None\n\n        if domain_name and self.is_existent_role(domain_name, role):\n            return domain_name, role\n        elif self.is_existent_role('std', role):\n            return 'std', role\n        else:\n            return None\n\n    def is_existent_role(self, domain_name: str, role_name: str) -> bool:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.is_existent_role', '', remove=(9, 0)\n        )\n        try:\n            domain = self.env.domains[domain_name]\n        except KeyError:\n            return False\n        else:\n            return role_name in domain.roles\n\n    def invoke_role(\n        self, role: tuple[str, str]\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Invoke the role described by a ``(domain, role name)`` pair.\"\"\"\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.invoke_role', '', remove"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "= re.compile(r'(\\+([^:]+))?:(.*)')\n\n    def __init__(self, orig_name: str) -> None:\n        self.orig_name = orig_name\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        assert self.name == self.orig_name.lower()\n        inventory, name_suffix = self.get_inventory_and_name_suffix(self.orig_name)\n        resolve_self = self.env.config.intersphinx_resolve_self\n        self_referential = bool(resolve_self) and resolve_self == inventory\n\n        if not self_referential:\n            if inventory and not inventory_exists(self.env, inventory):\n                self._emit_warning(\n                    __('inventory for external cross-reference not found: %r'),\n                    inventory,\n                )\n                return [], []\n\n        domain_name, role_name = self._get_domain_role(name_suffix)\n\n        if role_name is None:\n            self._emit_warning(\n                __('invalid external cross-reference suffix: %r'), name_suffix\n            )\n            return [], []\n\n        # attempt to find a matching role function\n        role_func: RoleFunction | None\n\n        if domain_name is not None:\n            # the user specified a domain, so we only check that\n            if domain_name not in self.env.domains:\n                self._emit_warning(\n                    __('domain for external cross-reference not found: %r'), domain_name\n                )\n                return [], []\n            domain = self.env.domains[domain_name]\n            role_func = domain.roles.get(role_name)\n            if role_func is None:\n                msg = 'role for external cross-reference not found in domain %r: %r'\n                object_types = domain.object_types.get(role_name)\n                if object_types is not None and object_types.roles:\n                    self._emit_warning(\n                        __(f'{msg} (perhaps you meant one of: %s)'),\n                        domain_name,\n                        role_name,\n                        self._concat"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=(9, 0)\n        )\n        domain = self.env.get_domain(role[0])\n        if domain:\n            role_func = domain.role(role[1])\n            assert role_func is not None\n\n            return role_func(\n                ':'.join(role),\n                self.rawtext,\n                self.text,\n                self.lineno,\n                self.inliner,\n                self.options,\n                self.content,\n            )\n        else:\n            return [], []\n\n\nclass IntersphinxRoleResolver(ReferencesResolver):\n    \"\"\"pending_xref node resolver for intersphinx role.\n\n    This resolves pending_xref nodes generated by :intersphinx:***: role.\n    \"\"\"\n\n    default_priority = ReferencesResolver.default_priority - 1\n\n    def run(self, **kwargs: Any) -> None:\n        for node in self.document.findall(pending_xref):\n            if 'intersphinx' not in node:\n                continue\n            contnode = cast('nodes.TextElement', node[0].deepcopy())\n            inv_name = node['inventory']\n            if inv_name is not None:\n                assert inventory_exists(self.env, inv_name)\n                newnode = resolve_reference_in_inventory(\n                    self.env, inv_name, node, contnode\n                )\n            else:\n                newnode = resolve_reference_any_inventory(\n                    self.env, False, node, contnode\n                )\n            if newnode is None:\n                typ = node['reftype']\n                msg = __('external %s:%s reference target not found: %s') % (\n                    node['refdomain'],\n                    typ,\n                    node['reftarget'],\n                )\n                LOGGER.warning(msg, location=node, type='ref', subtype=typ)\n                node.replace_self(contnode)\n            else:\n                node.replace_self(newnode)\n\n\ndef install_dispatcher(app: Sphinx, docname: str, source: list[str]) -> None:\n    \"\"\"Enable IntersphinxDispatcher.\n\n    .. note:: The installed dispatcher will be uninstalled on "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rective] | None, list[system_message]]:\n        return self.directive_func(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        return self.role_func(\n            role_name,\n            language_module,  # type: ignore[return-value]\n            lineno,\n            reporter,\n        )\n\n\nclass ElementLookupError(Exception):\n    pass\n\n\nclass sphinx_domains(CustomReSTDispatcher):\n    \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n    markup takes precedence.\n    \"\"\"\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        self.domains = env.domains\n        self.current_document = env.current_document\n        super().__init__()\n\n    def directive(\n        self,\n        directive_name: str,\n        language_module: ModuleType,\n        document: nodes.document,\n    ) -> tuple[type[Directive] | None, list[system_message]]:\n        \"\"\"Lookup a directive, given its name which can include a domain.\"\"\"\n        directive_name = directive_name.lower()\n        # explicit domain given?\n        if ':' in directive_name:\n            domain_name, _, name = directive_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown directive name: %s'), directive_name)\n            else:\n                element = domain.directive(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = directive_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.directive(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domai"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_strings(object_types.roles),\n                    )\n                else:\n                    self._emit_warning(__(msg), domain_name, role_name)\n                return [], []\n\n        else:\n            # the user did not specify a domain,\n            # so we check first the default (if available) then standard domains\n            default_domain = self.env.current_document.default_domain\n            std_domain = self.env.domains.standard_domain\n            domains: Sequence[Domain]\n            if default_domain is None or std_domain == default_domain:\n                domains = (std_domain,)\n            else:\n                domains = (default_domain, std_domain)\n\n            role_func = None\n            for domain in domains:\n                role_func = domain.roles.get(role_name)\n                if role_func is not None:\n                    domain_name = domain.name\n                    break\n\n            if role_func is None or domain_name is None:\n                domains_str = self._concat_strings(domain.name for domain in domains)\n                msg = 'role for external cross-reference not found in domains %s: %r'\n                possible_roles: set[str] = {\n                    f'{domain.name}:{r}'\n                    for domain in domains\n                    if (object_types := domain.object_types.get(role_name))\n                    for r in object_types.roles\n                }\n                if possible_roles:\n                    msg = f'{msg} (perhaps you meant one of: %s)'\n                    self._emit_warning(\n                        __(msg),\n                        domains_str,\n                        role_name,\n                        self._concat_strings(possible_roles),\n                    )\n                else:\n                    self._emit_warning(__(msg), domains_str, role_name)\n                return [], []\n\n        result, messages = role_func(\n            f'{domain_name}:{role_name}',\n            self.rawtext,\n            self.text,\n          "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            declaration.get_newest_id(),\n            contnode,\n            display_name,\n        ), declaration.objectType\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        return self._resolve_xref_inner(\n            env, fromdocname, builder, typ, target, node, contnode\n        )[0]\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        with logging.suppress_logging():\n            retnode, objtype = self._resolve_xref_inner(\n                env, fromdocname, builder, 'any', target, node, contnode\n            )\n        if retnode:\n            return [('c:' + self.role_for_objtype(objtype), retnode)]\n        return []\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        root_symbol = self.data['root_symbol']\n        for symbol in root_symbol.get_all_symbols():\n            if symbol.declaration is None:\n                continue\n            assert symbol.docname\n            full_nested_name = symbol.get_full_nested_name()\n            name = str(full_nested_name).lstrip('.')\n            dispname = full_nested_name.get_display_string().lstrip('.')\n            object_type = symbol.declaration.objectType\n            docname = symbol.docname\n            newest_id = symbol.declaration.get_newest_id()\n            yield name, dispname, object_type, docname, newest_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(CDomain)\n    app.add_config_value('c_id_attributes', [], 'env', types=frozenset({list, tuple}))\n    app.add_config_value(\n        'c_paren_attributes', [], 'env', types=frozenset({list, tuple})\n    )\n    app.add_config_"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n\n        element = self.domains.standard_domain.directive(name)\n        if element is not None:\n            return element, []\n\n        return super().directive(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        \"\"\"Lookup a role, given its name which can include a domain.\"\"\"\n        role_name = role_name.lower()\n        # explicit domain given?\n        if ':' in role_name:\n            domain_name, _, name = role_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown role name: %s'), role_name)\n            else:\n                element = domain.role(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = role_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.role(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domain\n        element = self.domains.standard_domain.role(name)\n        if element is not None:\n            return element, []\n\n        return super().role(role_name, language_module, lineno, reporter)\n\n\nclass WarningStream:\n    def write(self, text: str) -> None:\n        matched = report_re.search(text)\n        if not matched:\n            logger.warning(text.rstrip('\\r\\n'), type='docutils')\n        else:\n            location, type, _level = matched.groups()\n            message = report_re.sub('', text).rstrip()\n            logger.log(type, message, location=location, type='docutils')\n\n\nclass LoggingReporter(Reporter):\n    @classmethod\n    def from_reporter(\n        cls: type[LoggingReporter], "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "port _DomainsContainer\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.intersphinx._shared import InventoryName\n    from sphinx.util.inventory import _InventoryItem\n    from sphinx.util.typing import Inventory, RoleFunction\n\n\ndef _create_element_from_result(\n    domain_name: str,\n    inv_name: InventoryName | None,\n    inv_item: _InventoryItem,\n    node: pending_xref,\n    contnode: TextElement,\n) -> nodes.reference:\n    uri = inv_item.uri\n    if '://' not in uri and node.get('refdoc'):\n        # get correct path in case of subdirectories\n        uri = (_relative_path(Path(), Path(node['refdoc']).parent) / uri).as_posix()\n    if inv_item.project_version:\n        if not inv_item.project_version[0].isdigit():\n            # Do not append 'v' to non-numeric version\n            version = inv_item.project_version\n        else:\n            version = f'v{inv_item.project_version}'\n        reftitle = _('(in %s %s)') % (inv_item.project_name, version)\n    else:\n        reftitle = _('(in %s)') % (inv_item.project_name,)\n\n    newnode = nodes.reference('', '', internal=False, refuri=uri, reftitle=reftitle)\n    if node.get('refexplicit'):\n        # use whatever title was given\n        newnode.append(contnode)\n    elif inv_item.display_name == '-' or (\n        domain_name == 'std' and node['reftype'] == 'keyword'\n    ):\n        # use whatever title was given, but strip prefix\n        title = contnode.astext()\n        if inv_name is not None and title.startswith(inv_name + ':'):\n            newnode.append(\n                contnode.__class__(\n                    title[len(inv_name) + 1 :], title[len(inv_name) + 1 :]\n                )\n            )\n        else:\n            newnode.append(contnode)\n    else:\n        # else use the given display name (used for :ref:)\n        newnode.append(contnode.__class__(inv_item.display_name, inv_item.display_name))\n    return newnode\n\n\ndef _resolve_reference_in_domain_by_target(\n    inv_name: InventoryName | None,\n    inve"}], "retrieved_count": 10, "cost_time": 1.1032514572143555}
{"question": "Why does Sphinx use a caching mechanism for build time optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx uses a caching mechanism for build time optimization to avoid redundant processing and significantly improve build performance, especially for large documentation projects and incremental builds. This caching system provides several important performance benefits.\n\nKey reasons for implementing caching include:\n\n1. **Avoid Redundant Processing**: Caching allows Sphinx to skip expensive operations like parsing source files, resolving cross-references, and generating document trees for files that haven't changed since the last build.\n\n2. **Incremental Build Support**: The caching system is fundamental to Sphinx's incremental build functionality. By caching the build environment and document trees, Sphinx can determine which files have changed and only rebuild the necessary components.\n\n3. **Cross-Reference Persistence**: Cross-reference data and metadata about documented objects are cached between builds, allowing Sphinx to maintain consistency and avoid recalculating complex relationships.\n\n4. **Memory Efficiency**: Caching reduces memory usage by allowing Sphinx to load only the necessary data from disk rather than keeping all document trees in memory simultaneously.\n\n5. **Build Time Reduction**: For large projects, caching can dramatically reduce build times by avoiding the expensive parsing and analysis phases for unchanged files.\n\n6. **Resource Conservation**: Caching reduces CPU usage and disk I/O by avoiding unnecessary file processing, making builds more efficient and less resource-intensive.\n\n7. **Development Workflow**: Caching improves the development experience by providing fast feedback during documentation development, allowing developers to see changes quickly without waiting for full rebuilds.\n\n8. **Scalability**: As documentation projects grow in size, the benefits of caching become more pronounced, making it possible to handle projects with thousands of files efficiently.\n\nThe caching system includes multiple levels of caching, including the build environment cache (stored as a pickle file), document tree caching, and various metadata caches that work together to optimize the build process.", "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 10634, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path or '', removal version)\n_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {\n    'strip_escseq': (\n        strip_escape_sequences,\n        'sphinx.util.console.strip_escape_sequences',\n        (9, 0),\n    ),\n}\n\n\ndef __getattr__(name: str) -> Any:\n    if name not in _DEPRECATED_OBJECTS:\n        msg = f'module {__name__!r} has no attribute {name!r}'\n        raise AttributeError(msg)\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=remove)\n    return deprecated_object\n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ache: dict[str, bytes] = {}\n        \"\"\"In-memory cache for reading pickled doctrees from disk.\n        docname -> pickled doctree\n\n        This cache is used in the ``get_doctree`` method to avoid reading the\n        doctree from disk multiple times.\n        \"\"\"\n\n        self._write_doc_doctree_cache: dict[str, nodes.document] = {}\n        \"\"\"In-memory cache for unpickling doctrees from disk.\n        docname -> doctree\n\n        Items are added in ``Builder.write_doctree``, during the read phase,\n        then used only in the ``get_and_resolve_doctree`` method.\n        \"\"\"\n\n        # File metadata\n        # docname -> dict of metadata items\n        self.metadata: dict[str, dict[str, Any]] = defaultdict(dict)\n\n        # TOC inventory\n        # docname -> title node\n        self.titles: dict[str, nodes.title] = {}\n        # docname -> title node; only different if\n        # set differently with title directive\n        self.longtitles: dict[str, nodes.title] = {}\n        # docname -> table of contents nodetree\n        self.tocs: dict[str, nodes.bullet_list] = {}\n        # docname -> number of real entries\n        self.toc_num_entries: dict[str, int] = {}\n\n        # used to determine when to show the TOC\n        # in a sidebar (don't show if it's only one item)\n        # docname -> dict of sectionid -> number\n        self.toc_secnumbers: dict[str, dict[str, tuple[int, ...]]] = {}\n        # docname -> dict of figtype -> dict of figureid -> number\n        self.toc_fignumbers: dict[str, dict[str, dict[str, tuple[int, ...]]]] = {}\n\n        # docname -> list of toctree includefiles\n        self.toctree_includes: dict[str, list[str]] = {}\n        # docname -> set of files (containing its TOCs) to rebuild too\n        self.files_to_rebuild: dict[str, set[str]] = {}\n        # docnames that have :glob: toctrees\n        self.glob_toctrees: set[str] = set()\n        # docnames that have :numbered: toctrees\n        self.numbered_toctrees: set[str] = set()\n\n        # domain-specific in"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "octree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in parallel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rsioning_method\n        self.versioning_condition: Literal[False] | Callable[[Node], bool] | None = None\n        self.versioning_compare: bool | None = None\n\n        # the docutils settings for building\n        self.settings: dict[str, Any] = default_settings.copy()\n        self.settings['env'] = self\n\n        # All \"docnames\" here are /-separated and relative and exclude\n        # the source suffix.\n\n        # docname -> time of reading (in integer microseconds)\n        # contains all read docnames\n        self.all_docs: dict[str, int] = {}\n        # docname -> set of dependent file\n        # names, relative to documentation root\n        self.dependencies: dict[str, set[_StrPath]] = defaultdict(set)\n        # docname -> set of included file\n        # docnames included from other documents\n        self.included: dict[str, set[str]] = defaultdict(set)\n        # docnames to re-read unconditionally on next build\n        self.reread_always: set[str] = set()\n\n        self._pickled_doctree_cache: dict[str, bytes] = {}\n        \"\"\"In-memory cache for reading pickled doctrees from disk.\n        docname -> pickled doctree\n\n        This cache is used in the ``get_doctree`` method to avoid reading the\n        doctree from disk multiple times.\n        \"\"\"\n\n        self._write_doc_doctree_cache: dict[str, nodes.document] = {}\n        \"\"\"In-memory cache for unpickling doctrees from disk.\n        docname -> doctree\n\n        Items are added in ``Builder.write_doctree``, during the read phase,\n        then used only in the ``get_and_resolve_doctree`` method.\n        \"\"\"\n\n        # File metadata\n        # docname -> dict of metadata items\n        self.metadata: dict[str, dict[str, Any]] = defaultdict(dict)\n\n        # TOC inventory\n        # docname -> title node\n        self.titles: dict[str, nodes.title] = {}\n        # docname -> title node; only different if\n        # set differently with title directive\n        self.longtitles: dict[str, nodes.title] = {}\n        # docname -> table"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    'text': is_translatable,\n}\n\n\nclass BuildEnvironment:\n    \"\"\"The environment in which the ReST files are translated.\n    Stores an inventory of cross-file targets and provides doctree\n    transformations to resolve links to them.\n    \"\"\"\n\n    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n\n    srcdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    # builder is created after the environment.\n    _builder_cls: type[Builder]\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app: Sphinx = app\n        self.doctreedir = app.doctreedir\n        self.srcdir = app.srcdir\n        self.config: Config = None  # type: ignore[assignment]\n        self.config_status: int = CONFIG_UNSET\n        self.config_status_extra: str = ''\n        self.events: EventManager = app.events\n        self.project: Project = app.project\n        self.version: Mapping[str, int] = _get_env_version(app.extensions)\n\n        # the method of doctree versioning; see set_versioning_method\n        self.versioning_condition: Literal[False] | Callable[[Node], bool] | None = None\n        self.versioning_compare: bool | None = None\n\n        # the docutils settings for building\n        self.settings: dict[str, Any] = default_settings.copy()\n        self.settings['env'] = self\n\n        # All \"docnames\" here are /-separated and relative and exclude\n        # the source suffix.\n\n        # docname -> time of reading (in integer microseconds)\n        # contains all read docnames\n        self.all_docs: dict[str, int] = {}\n        # docname -> set of dependent file\n        # names, relative to documentation root\n        self.dependencies: dict[str, set[_StrPath]] = defaultdict(set)\n        # docname -> set of included file\n        # docnames included from other documents\n        self.included: dict[str, set[str]] = defaultdict(set)\n        # docnames to re-read unconditionally on next build\n        self.reread_always: set[str] = set()\n\n        self._pickled_doctree_c"}, {"start_line": 4000, "end_line": 5490, "belongs_to": {"file_name": "_shared.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(msg)\n\n\nclass InventoryAdapter:\n    \"\"\"Inventory adapter for environment\"\"\"\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n        if not hasattr(env, 'intersphinx_cache'):\n            # initial storage when fetching inventories before processing\n            self.env.intersphinx_cache = {}  # type: ignore[attr-defined]\n\n            self.env.intersphinx_inventory = {}  # type: ignore[attr-defined]\n            self.env.intersphinx_named_inventory = {}  # type: ignore[attr-defined]\n\n    @property\n    def cache(self) -> dict[InventoryURI, InventoryCacheEntry]:\n        \"\"\"Intersphinx cache.\n\n        - Key is the URI of the remote inventory.\n        - Element one is the key given in the Sphinx :confval:`intersphinx_mapping`.\n        - Element two is a time value for cache invalidation, an integer.\n        - Element three is the loaded remote inventory of type :class:`!Inventory`.\n        \"\"\"\n        return self.env.intersphinx_cache  # type: ignore[attr-defined]\n\n    @property\n    def main_inventory(self) -> Inventory:\n        return self.env.intersphinx_inventory  # type: ignore[attr-defined]\n\n    @property\n    def named_inventory(self) -> dict[InventoryName, Inventory]:\n        return self.env.intersphinx_named_inventory  # type: ignore[attr-defined]\n\n    def clear(self) -> None:\n        self.env.intersphinx_inventory.clear()  # type: ignore[attr-defined]\n        self.env.intersphinx_named_inventory.clear()  # type: ignore[attr-defined]\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              exception_on_warning=exception_on_warning,\n            )\n        except Exception:\n            self.cleanup()\n            raise\n\n    def _init_builder(self) -> None:\n        # override the default theme to 'basic' rather than 'alabaster'\n        # for test independence\n\n        if 'html_theme' in self.config._overrides:\n            pass  # respect overrides\n        elif 'html_theme' in self.config and self.config.html_theme == 'alabaster':\n            self.config.html_theme = self.config._overrides.get('html_theme', 'basic')\n        super()._init_builder()\n\n    @property\n    def status(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application status messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._status, StringIO)\n        return self._status\n\n    @property\n    def warning(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application warning messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(sel"}, {"start_line": 0, "end_line": 277, "belongs_to": {"file_name": "build_phase.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build phase of Sphinx application.\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass BuildPhase(IntEnum):\n    \"\"\"Build phase of Sphinx application.\"\"\"\n\n    INITIALIZATION = 1\n    READING = 2\n    CONSISTENCY_CHECK = 3\n    RESOLVING = 3\n    WRITING = 4\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_load.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nger in `intersphinx_mapping`.\n            del intersphinx_cache[uri]\n        elif uri not in expected_uris:\n            # Remove cached entries with a different target URI\n            # than the one in `intersphinx_mapping`.\n            # This happens when the URI in `intersphinx_mapping` is changed.\n            del intersphinx_cache[uri]\n\n    inv_config = _InvConfig.from_config(app.config)\n    with concurrent.futures.ThreadPoolExecutor() as pool:\n        futures = [\n            pool.submit(\n                _fetch_inventory_group,\n                project=project,\n                cache=intersphinx_cache,\n                now=now,\n                config=inv_config,\n                srcdir=app.srcdir,\n                # the location of this cache directory must not be relied upon\n                # externally, it may change without notice or warning.\n                cache_dir=app.doctreedir / '__intersphinx_cache__',\n            )\n            for project in projects\n        ]\n        updated = [f.result() for f in concurrent.futures.as_completed(futures)]\n\n    if any(updated):\n        # clear the local inventories\n        inventories.clear()\n\n        # Duplicate values in different inventories will shadow each\n        # other; which one will override which can vary between builds.\n        #\n        # In an attempt to make this more consistent,\n        # we sort the named inventories in the cache\n        # by their name and expiry time ``(NAME, EXPIRY)``.\n        by_name_and_time = itemgetter(0, 1)  # 0: name, 1: expiry\n        cache_values = sorted(intersphinx_cache.values(), key=by_name_and_time)\n        for name, _expiry, invdata in cache_values:\n            inventories.named_inventory[name] = invdata\n            for objtype, objects in invdata.items():\n                inventories.main_inventory.setdefault(objtype, {}).update(objects)\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True, slots=True)\nclass _InvConfig:\n    intersphinx_cache_limit: int\n    intersphinx_timeou"}], "retrieved_count": 10, "cost_time": 1.0897736549377441}
{"question": "Why does Sphinx provide parallel processing capabilities for build performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx provides parallel processing capabilities for build performance optimization to leverage modern multi-core systems and significantly reduce build times for large documentation projects. This feature addresses the computational demands of processing extensive documentation sets.\n\nKey reasons for implementing parallel processing include:\n\n1. **Multi-Core Utilization**: Modern systems typically have multiple CPU cores, and parallel processing allows Sphinx to utilize all available cores simultaneously, dramatically improving build performance compared to single-threaded processing.\n\n2. **Document Independence**: During the reading phase, many documents can be processed independently since they don't depend on each other for parsing and initial processing. This makes them ideal candidates for parallel execution.\n\n3. **Scalability**: As documentation projects grow in size, the benefits of parallel processing become more pronounced. The system can scale with the number of available CPU cores, providing better performance on high-end systems.\n\n4. **Build Time Reduction**: Parallel processing can significantly reduce build times, especially for large projects with hundreds or thousands of documents. This improves developer productivity and reduces waiting times during documentation development.\n\n5. **Resource Efficiency**: By distributing the workload across multiple processes, parallel processing can make better use of system resources and reduce the overall time the system is occupied with build tasks.\n\n6. **CI/CD Performance**: In continuous integration environments, faster builds mean quicker feedback and more efficient development workflows. Parallel processing helps maintain fast build times even as projects grow.\n\n7. **Memory Management**: The parallel processing system is designed to manage memory usage effectively across multiple processes, preventing memory exhaustion on large projects.\n\n8. **Flexibility**: Users can control the level of parallelism through the `--jobs` option, allowing them to balance build performance with system resource usage based on their specific needs.\n\nParallel processing is particularly effective during the document reading phase where documents can be processed independently, and the system includes mechanisms to merge the results from parallel processes back into the main build environment.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Parallel building utilities.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport time\nimport traceback\nfrom math import sqrt\nfrom typing import TYPE_CHECKING\n\ntry:\n    import multiprocessing\n\n    HAS_MULTIPROCESSING = True\nexcept ImportError:\n    HAS_MULTIPROCESSING = False\n\nfrom sphinx.errors import SphinxParallelError\nfrom sphinx.util import logging\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Sequence\n    from typing import Any\n\nlogger = logging.getLogger(__name__)\n\n# our parallel functionality only works for the forking Process\nparallel_available = HAS_MULTIPROCESSING and os.name == 'posix'\n\n\nclass SerialTasks:\n    \"\"\"Has the same interface as ParallelTasks, but executes tasks directly.\"\"\"\n\n    def __init__(self, nproc: int = 1) -> None:\n        pass\n\n    def add_task(\n        self,\n        task_func: Callable[[Any], Any] | Callable[[], Any],\n        arg: Any = None,\n        result_func: Callable[[Any], Any] | None = None,\n    ) -> None:\n        if arg is not None:\n            res = task_func(arg)  # type: ignore[call-arg]\n        else:\n            res = task_func()  # type: ignore[call-arg]\n        if result_func:\n            result_func(res)\n\n    def join(self) -> None:\n        pass\n\n\nclass ParallelTasks:\n    \"\"\"Executes *nproc* tasks in parallel after forking.\"\"\"\n\n    def __init__(self, nproc: int) -> None:\n        self.nproc = nproc\n        # (optional) function performed by each task on the result of main task\n        self._result_funcs: dict[int, Callable[[Any, Any], Any]] = {}\n        # task arguments\n        self._args: dict[int, list[Any] | None] = {}\n        # list of subprocesses (both started and waiting)\n        self._procs: dict[int, Any] = {}\n        # list of receiving pipe connections of running subprocesses\n        self._precvs: dict[int, Any] = {}\n        # list of receiving pipe connections of waiting subprocesses\n        self._precvs_waiting: dict[int, Any] = {}\n        # number of working subprocesses\n        self._p"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build documentation from a provided source.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport contextlib\nimport locale\nimport multiprocessing\nimport sys\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nimport sphinx._cli.util.errors\nimport sphinx.locale\nfrom sphinx import __display_version__\nfrom sphinx._cli.util.colour import disable_colour, terminal_supports_colour\nfrom sphinx.application import Sphinx\nfrom sphinx.locale import __\nfrom sphinx.util._io import TeeStripANSI\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.docutils import docutils_namespace, patch_docutils\nfrom sphinx.util.osutil import ensuredir\n\nif TYPE_CHECKING:\n    from collections.abc import Collection, Sequence\n    from typing import Any, TextIO\n\n    from sphinx.extension import Extension\n\n\ndef handle_exception(\n    app: Sphinx | None,\n    args: Any,\n    exception: BaseException,\n    stderr: TextIO = sys.stderr,\n) -> None:\n    if app is not None:\n        message_log: Sequence[str] = app.messagelog\n        extensions: Collection[Extension] = app.extensions.values()\n    else:\n        message_log = extensions = ()\n    return sphinx._cli.util.errors.handle_exception(\n        exception,\n        stderr=stderr,\n        use_pdb=args.pdb,\n        print_traceback=args.verbosity or args.traceback,\n        message_log=message_log,\n        extensions=extensions,\n    )\n\n\ndef jobs_argument(value: str) -> int:\n    \"\"\"Parse the ``--jobs`` flag.\n\n    Return the number of CPUs if 'auto' is used,\n    otherwise ensure *value* is a positive integer.\n    \"\"\"\n    if value == 'auto':\n        return multiprocessing.cpu_count()\n    else:\n        jobs = int(value)\n        if jobs <= 0:\n            raise argparse.ArgumentTypeError(\n                __('job number should be a positive number')\n            )\n        else:\n            return jobs\n\n\ndef get_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        usage='%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAME"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# type: ignore[assignment]\n        error = warning\n\n    return status, warning, error, warnfp\n\n\ndef _parse_confoverrides(\n    parser: argparse.ArgumentParser,\n    define: list[str],\n    htmldefine: list[str],\n    nitpicky: bool,\n) -> dict[str, Any]:\n    confoverrides: dict[str, Any] = {}\n    val: Any\n    for val in define:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-D option argument must be in the form name=value'))\n        confoverrides[key] = val\n\n    for val in htmldefine:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-A option argument must be in the form name=value'))\n        with contextlib.suppress(ValueError):\n            val = int(val)\n\n        confoverrides[f'html_context.{key}'] = val\n\n    if nitpicky:\n        confoverrides['nitpicky'] = True\n\n    return confoverrides\n\n\ndef build_main(argv: Sequence[str]) -> int:\n    \"\"\"Sphinx build \"main\" command-line entry.\"\"\"\n    parser = get_parser()\n    args = _parse_arguments(parser, argv)\n    args.confdir = _parse_confdir(args.noconfig, args.confdir, args.sourcedir)\n    args.doctreedir = _parse_doctreedir(args.doctreedir, args.outputdir)\n    _validate_filenames(parser, args.force_all, args.filenames)\n    _validate_colour_support(args.color)\n    args.status, args.warning, args.error, warnfp = _parse_logging(\n        parser, args.quiet, args.really_quiet, args.warnfile\n    )\n    args.confoverrides = _parse_confoverrides(\n        parser, args.define, args.htmldefine, args.nitpicky\n    )\n\n    app = None\n    try:\n        confdir = args.confdir or args.sourcedir\n        with patch_docutils(confdir), docutils_namespace():\n            app = Sphinx(\n                srcdir=args.sourcedir,\n                confdir=args.confdir,\n                outdir=args.outputdir,\n                doctreedir=args.doctreedir,\n                buildername=args.builder,\n                confoverrides=args.conf"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.l"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir: Directory for caching pickled doctrees.\n        :param buildername: The name of the builder to use.\n        :param confoverrides: A dictionary of configuration settings that override the\n            settings in the configuration file.\n        :param status: A file-like object to write status messages to.\n        :param warning: A file-like object to write warnings to.\n        :param freshenv: If true, clear the cached environment.\n        :param warningiserror: If true, warnings become errors.\n        :param tags: A list of tags to apply.\n        :param verbosity: The verbosity level.\n        :param parallel: The maximum number of parallel jobs to use\n            when reading/writing documents.\n        :param keep_going: Unused.\n        :param pdb: If true, enable the Python debugger on an exception.\n        :param exception_on_warning: If true, raise an exception on warnings.\n        \"\"\"\n        self.verbosity = verbosity\n        self._fresh_env_used: bool | None = None\n        self."}, {"start_line": 0, "end_line": 277, "belongs_to": {"file_name": "build_phase.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build phase of Sphinx application.\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass BuildPhase(IntEnum):\n    \"\"\"Build phase of Sphinx application.\"\"\"\n\n    INITIALIZATION = 1\n    READING = 2\n    CONSISTENCY_CHECK = 3\n    RESOLVING = 3\n    WRITING = 4\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "alidate_colour_support(colour: str) -> None:\n    if colour == 'no' or (colour == 'auto' and not terminal_supports_colour()):\n        disable_colour()\n\n\ndef _parse_logging(\n    parser: argparse.ArgumentParser,\n    quiet: bool,\n    really_quiet: bool,\n    warnfile: str | None,\n) -> tuple[TextIO | None, TextIO | None, TextIO, TextIO | None]:\n    status: TextIO | None = sys.stdout\n    warning: TextIO | None = sys.stderr\n    error = sys.stderr\n\n    if quiet:\n        status = None\n\n    if really_quiet:\n        status = warning = None\n\n    warnfp = None\n    if warning and warnfile:\n        try:\n            warn_file = Path(warnfile).resolve()\n            ensuredir(warn_file.parent)\n            # the caller is responsible for closing this file descriptor\n            warnfp = open(warn_file, 'w', encoding='utf-8')  # NoQA: SIM115\n        except Exception as exc:\n            parser.error(__(\"cannot open warning file '%s': %s\") % (warn_file, exc))\n        warning = TeeStripANSI(warning, warnfp)  # type: ignore[assignment]\n        error = warning\n\n    return status, warning, error, warnfp\n\n\ndef _parse_confoverrides(\n    parser: argparse.ArgumentParser,\n    define: list[str],\n    htmldefine: list[str],\n    nitpicky: bool,\n) -> dict[str, Any]:\n    confoverrides: dict[str, Any] = {}\n    val: Any\n    for val in define:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-D option argument must be in the form name=value'))\n        confoverrides[key] = val\n\n    for val in htmldefine:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-A option argument must be in the form name=value'))\n        with contextlib.suppress(ValueError):\n            val = int(val)\n\n        confoverrides[f'html_context.{key}'] = val\n\n    if nitpicky:\n        confoverrides['nitpicky'] = True\n\n    return confoverrides\n\n\ndef build_main(argv: Sequence[str]) -> int:\n    \"\"\"Sphinx build \"mai"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "make_mode.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"sphinx-build -M command-line handling.\n\nThis replaces the old, platform-dependent and once-generated content\nof Makefile / make.bat.\n\nThis is in its own module so that importing it is fast.  It should not\nimport the main Sphinx modules (like sphinx.applications, sphinx.builders).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\nfrom contextlib import chdir\nfrom typing import TYPE_CHECKING\n\nimport sphinx\nfrom sphinx._cli.util.colour import blue, bold, disable_colour, terminal_supports_colour\nfrom sphinx.cmd.build import build_main\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import rmtree\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n\nBUILDERS = [\n    ('', 'html', 'to make standalone HTML files'),\n    ('', 'dirhtml', 'to make HTML files named index.html in directories'),\n    ('', 'singlehtml', 'to make a single large HTML file'),\n    ('', 'pickle', 'to make pickle files'),\n    ('', 'json', 'to make JSON files'),\n    ('', 'htmlhelp', 'to make HTML files and an HTML help project'),\n    ('', 'qthelp', 'to make HTML files and a qthelp project'),\n    ('', 'devhelp', 'to make HTML files and a Devhelp project'),\n    ('', 'epub', 'to make an epub'),\n    ('', 'latex', 'to make LaTeX files, you can set PAPER=a4 or PAPER=letter'),\n    ('posix', 'latexpdf', 'to make LaTeX and PDF files (default pdflatex)'),\n    ('posix', 'latexpdfja', 'to make LaTeX files and run them through platex/dvipdfmx'),\n    ('', 'text', 'to make text files'),\n    ('', 'man', 'to make manual pages'),\n    ('', 'texinfo', 'to make Texinfo files'),\n    ('posix', 'info', 'to make Texinfo files and run them through makeinfo'),\n    ('', 'gettext', 'to make PO message catalogs'),\n    ('', 'changes', 'to make an overview of all changed/added/deprecated items'),\n    ('', 'xml', 'to make Docutils-native XML files'),\n    ('', 'pseudoxml', 'to make pseudoxml-XML files for display purposes'),\n    ('', 'linkcheck', 'to check all external links for int"}], "retrieved_count": 10, "cost_time": 1.1008987426757812}
{"question": "What dependencies does Sphinx's extension system have on the core BuildEnvironment and Application classes?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's extension system has significant dependencies on both the BuildEnvironment and Application (Sphinx) classes, as these provide the core infrastructure and APIs that extensions rely on to function properly.\n\nKey dependencies on the Application class include:\n\n1. **Event System Access**: Extensions depend on the application's event system to register callbacks for various build phases. The application provides the `events` attribute that extensions use to connect to events like 'config-inited', 'builder-inited', 'doctree-read', etc.\n\n2. **Configuration Access**: Extensions need access to the application's configuration through `app.config` to read project settings and extension-specific configuration values.\n\n3. **Component Registration**: Extensions use the application's registry (`app.registry`) to register new components like directives, roles, builders, and domains.\n\n4. **Extension Management**: The application manages the loading and initialization of extensions, providing the extension setup function with the application instance.\n\nKey dependencies on the BuildEnvironment class include:\n\n1. **Document State Access**: Extensions need access to the environment's document state information, including which documents have been read, their dependencies, and modification times.\n\n2. **Cross-Reference Data**: Extensions often need to access the environment's cross-reference data and metadata about documented objects to implement custom functionality.\n\n3. **Domain Data Access**: Extensions that work with domains need access to the environment's `domaindata` to store and retrieve domain-specific information.\n\n4. **Document Tree Access**: Extensions may need to access and modify document trees through the environment's document tree management methods.\n\n5. **Caching and Persistence**: Extensions can use the environment's caching mechanisms to store data that should persist across builds.\n\nThese dependencies ensure that extensions can integrate seamlessly with Sphinx's build process and access all the necessary information and functionality to implement their features.", "score": null, "retrieved_content": [{"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lf._search_index_filenames: dict[str, str] = {}\n        # stemmed words -> set(docname)\n        self._search_index_mapping: dict[str, set[str]] = {}\n        # stemmed words in titles -> set(docname)\n        self._search_index_title_mapping: dict[str, set[str]] = {}\n        # docname -> all titles in document\n        self._search_index_all_titles: dict[str, list[tuple[str, str | None]]] = {}\n        # docname -> list(index entry)\n        self._search_index_index_entries: dict[str, list[tuple[str, str, str]]] = {}\n        # objtype -> index\n        self._search_index_objtypes: dict[tuple[str, str], int] = {}\n        # objtype index -> (domain, type, objname (localized))\n        self._search_index_objnames: dict[int, tuple[str, str, str]] = {}\n\n        # all the registered domains, set by the application\n        self.domains: _DomainsContainer = _DomainsContainer._from_environment(\n            self, registry=app.registry\n        )\n\n        # set up environment\n        self.setup(app)\n\n    def __getstate__(self) -> dict[str, Any]:\n        \"\"\"Obtains serializable data for pickling.\"\"\"\n        __dict__ = self.__dict__.copy()\n        # clear unpickleable attributes\n        __dict__.update(_app=None, domains=None, events=None)\n        # clear in-memory doctree caches, to reduce memory consumption and\n        # ensure that, upon restoring the state, the most recent pickled files\n        # on the disk are used instead of those from a possibly outdated state\n        __dict__.update(_pickled_doctree_cache={}, _write_doc_doctree_cache={})\n        return __dict__\n\n    def __setstate__(self, state: dict[str, Any]) -> None:\n        self.__dict__.update(state)\n\n    def setup(self, app: Sphinx) -> None:\n        \"\"\"Set up BuildEnvironment object.\"\"\"\n        if self.version and self.version != _get_env_version(app.extensions):\n            raise BuildEnvironmentError(__('build environment version not current'))\n        if self.srcdir and self.srcdir != app.srcdir:\n            raise Buil"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode == 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot be built with this '\n                            'version.'\n                        )\n                        % (extname, err),\n                    ) from err\n\n            if metadata is None:\n                metadata = {}\n            elif not isinstance(metadata, dict):\n                logger.warning(\n                    __(\n                        'extension %r returned an unsupported object from '\n                        'its setup() function; it should return None or a '\n                        'metadata dictionary'\n                    ),\n                    extname,\n                )\n                metadata = {}\n\n            app.extensions[extname] = Extension(extname, mod, **metadata)\n\n    def get_envversion(self, app: Sphinx) -> Mapping[str, int]:\n        from sphinx.environment import _get_env_version\n\n        return _get_env_version(app.extensions)\n\n\ndef merge_source_suffix(app: Sphinx, config: Config) -> None:\n    \"\"\"Merge any user-specified source_suffix with any added by ex"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".debug(\n            '[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter\n        )\n        if node in self.enumerable_nodes and not override:\n            raise ExtensionError(__('enumerable_node %r already registered') % node)\n        self.enumerable_nodes[node] = (figtype, title_getter)\n\n    def add_html_math_renderer(\n        self,\n        name: str,\n        inline_renderers: _MathsInlineRenderers | None,\n        block_renderers: _MathsBlockRenderers | None,\n    ) -> None:\n        logger.debug(\n            '[app] adding html_math_renderer: %s, %r, %r',\n            name,\n            inline_renderers,\n            block_renderers,\n        )\n        if name in self.html_inline_math_renderers:\n            raise ExtensionError(__('math renderer %s is already registered') % name)\n\n        if inline_renderers is not None:\n            self.html_inline_math_renderers[name] = inline_renderers\n        if block_renderers is not None:\n            self.html_block_math_renderers[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + tra"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n                ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.dom"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    'text': is_translatable,\n}\n\n\nclass BuildEnvironment:\n    \"\"\"The environment in which the ReST files are translated.\n    Stores an inventory of cross-file targets and provides doctree\n    transformations to resolve links to them.\n    \"\"\"\n\n    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n\n    srcdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    # builder is created after the environment.\n    _builder_cls: type[Builder]\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app: Sphinx = app\n        self.doctreedir = app.doctreedir\n        self.srcdir = app.srcdir\n        self.config: Config = None  # type: ignore[assignment]\n        self.config_status: int = CONFIG_UNSET\n        self.config_status_extra: str = ''\n        self.events: EventManager = app.events\n        self.project: Project = app.project\n        self.version: Mapping[str, int] = _get_env_version(app.extensions)\n\n        # the method of doctree versioning; see set_versioning_method\n        self.versioning_condition: Literal[False] | Callable[[Node], bool] | None = None\n        self.versioning_compare: bool | None = None\n\n        # the docutils settings for building\n        self.settings: dict[str, Any] = default_settings.copy()\n        self.settings['env'] = self\n\n        # All \"docnames\" here are /-separated and relative and exclude\n        # the source suffix.\n\n        # docname -> time of reading (in integer microseconds)\n        # contains all read docnames\n        self.all_docs: dict[str, int] = {}\n        # docname -> set of dependent file\n        # names, relative to documentation root\n        self.dependencies: dict[str, set[_StrPath]] = defaultdict(set)\n        # docname -> set of included file\n        # docnames included from other documents\n        self.included: dict[str, set[str]] = defaultdict(set)\n        # docnames to re-read unconditionally on next build\n        self.reread_always: set[str] = set()\n\n        self._pickled_doctree_c"}], "retrieved_count": 10, "cost_time": 1.1223878860473633}
{"question": "Why does Sphinx's incremental build system improve build performance for large documentation sets?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's incremental build system improves build performance for large documentation sets by intelligently tracking changes and only rebuilding the components that have actually been modified. This approach provides significant performance benefits that scale with project size.\n\nKey ways the incremental build system improves performance include:\n\n1. **Selective Processing**: The system tracks which files have changed since the last build and only processes those files, avoiding the expensive parsing and analysis of unchanged documents.\n\n2. **Dependency Tracking**: Sphinx maintains a dependency graph that tracks relationships between documents. When one document changes, only documents that depend on it are rebuilt, minimizing unnecessary work.\n\n3. **Environment Persistence**: The build environment, including cross-references, metadata, and document relationships, is cached between builds. This allows Sphinx to skip the expensive initial setup phase for unchanged components.\n\n4. **Cross-Reference Optimization**: Cross-reference data is preserved across builds, allowing Sphinx to avoid recalculating complex relationships between documents that haven't changed.\n\n5. **Memory Efficiency**: By processing only changed files, the incremental system reduces peak memory usage, making it possible to handle larger projects on systems with limited memory.\n\n6. **Scalable Performance**: The performance benefits of incremental builds increase with project size. For very large projects with thousands of files, the time savings can be dramatic compared to full rebuilds.\n\n7. **Development Workflow**: Incremental builds enable faster feedback during development, allowing developers to see changes quickly without waiting for complete rebuilds.\n\n8. **Resource Conservation**: By avoiding unnecessary processing, incremental builds reduce CPU usage, disk I/O, and overall system resource consumption.\n\nThe incremental build system is particularly effective for large documentation sets because the overhead of tracking changes is minimal compared to the time saved by avoiding redundant processing of unchanged files.", "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 10634, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path or '', removal version)\n_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {\n    'strip_escseq': (\n        strip_escape_sequences,\n        'sphinx.util.console.strip_escape_sequences',\n        (9, 0),\n    ),\n}\n\n\ndef __getattr__(name: str) -> Any:\n    if name not in _DEPRECATED_OBJECTS:\n        msg = f'module {__name__!r} has no attribute {name!r}'\n        raise AttributeError(msg)\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=remove)\n    return deprecated_object\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              exception_on_warning=exception_on_warning,\n            )\n        except Exception:\n            self.cleanup()\n            raise\n\n    def _init_builder(self) -> None:\n        # override the default theme to 'basic' rather than 'alabaster'\n        # for test independence\n\n        if 'html_theme' in self.config._overrides:\n            pass  # respect overrides\n        elif 'html_theme' in self.config and self.config.html_theme == 'alabaster':\n            self.config.html_theme = self.config._overrides.get('html_theme', 'basic')\n        super()._init_builder()\n\n    @property\n    def status(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application status messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._status, StringIO)\n        return self._status\n\n    @property\n    def warning(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application warning messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(sel"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mand line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @final\n    def build(\n        self,\n        docnames: Iterable[str] | None,\n        summary: str | None = None,\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Main build method, usually called by a specific ``build_*`` method.\n\n        First updates the environment, and then calls\n        :meth:`!write`.\n        \"\"\"\n        if summary:\n            logger.info(bold(__('building [%s]: ')) + summary, self.name)  # NoQA: G003\n\n        # while reading, collect all warnings from docutils\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            updated_docnames = set(self.read())\n\n        doccount = len(updated_docnames)\n        logger.info(bold(__('looking for now-outdated files... ')), nonl=True)\n        updated_docnames.update(self.env.check_dependents(self._app, updated_docnames))\n        outdated = len(updated_docnames) - doccount\n        if outdate"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# type: ignore[assignment]\n        error = warning\n\n    return status, warning, error, warnfp\n\n\ndef _parse_confoverrides(\n    parser: argparse.ArgumentParser,\n    define: list[str],\n    htmldefine: list[str],\n    nitpicky: bool,\n) -> dict[str, Any]:\n    confoverrides: dict[str, Any] = {}\n    val: Any\n    for val in define:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-D option argument must be in the form name=value'))\n        confoverrides[key] = val\n\n    for val in htmldefine:\n        try:\n            key, _, val = val.partition('=')\n        except ValueError:\n            parser.error(__('-A option argument must be in the form name=value'))\n        with contextlib.suppress(ValueError):\n            val = int(val)\n\n        confoverrides[f'html_context.{key}'] = val\n\n    if nitpicky:\n        confoverrides['nitpicky'] = True\n\n    return confoverrides\n\n\ndef build_main(argv: Sequence[str]) -> int:\n    \"\"\"Sphinx build \"main\" command-line entry.\"\"\"\n    parser = get_parser()\n    args = _parse_arguments(parser, argv)\n    args.confdir = _parse_confdir(args.noconfig, args.confdir, args.sourcedir)\n    args.doctreedir = _parse_doctreedir(args.doctreedir, args.outputdir)\n    _validate_filenames(parser, args.force_all, args.filenames)\n    _validate_colour_support(args.color)\n    args.status, args.warning, args.error, warnfp = _parse_logging(\n        parser, args.quiet, args.really_quiet, args.warnfile\n    )\n    args.confoverrides = _parse_confoverrides(\n        parser, args.define, args.htmldefine, args.nitpicky\n    )\n\n    app = None\n    try:\n        confdir = args.confdir or args.sourcedir\n        with patch_docutils(confdir), docutils_namespace():\n            app = Sphinx(\n                srcdir=args.sourcedir,\n                confdir=args.confdir,\n                outdir=args.outputdir,\n                doctreedir=args.doctreedir,\n                buildername=args.builder,\n                confoverrides=args.conf"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "make_mode.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"sphinx-build -M command-line handling.\n\nThis replaces the old, platform-dependent and once-generated content\nof Makefile / make.bat.\n\nThis is in its own module so that importing it is fast.  It should not\nimport the main Sphinx modules (like sphinx.applications, sphinx.builders).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\nfrom contextlib import chdir\nfrom typing import TYPE_CHECKING\n\nimport sphinx\nfrom sphinx._cli.util.colour import blue, bold, disable_colour, terminal_supports_colour\nfrom sphinx.cmd.build import build_main\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import rmtree\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n\nBUILDERS = [\n    ('', 'html', 'to make standalone HTML files'),\n    ('', 'dirhtml', 'to make HTML files named index.html in directories'),\n    ('', 'singlehtml', 'to make a single large HTML file'),\n    ('', 'pickle', 'to make pickle files'),\n    ('', 'json', 'to make JSON files'),\n    ('', 'htmlhelp', 'to make HTML files and an HTML help project'),\n    ('', 'qthelp', 'to make HTML files and a qthelp project'),\n    ('', 'devhelp', 'to make HTML files and a Devhelp project'),\n    ('', 'epub', 'to make an epub'),\n    ('', 'latex', 'to make LaTeX files, you can set PAPER=a4 or PAPER=letter'),\n    ('posix', 'latexpdf', 'to make LaTeX and PDF files (default pdflatex)'),\n    ('posix', 'latexpdfja', 'to make LaTeX files and run them through platex/dvipdfmx'),\n    ('', 'text', 'to make text files'),\n    ('', 'man', 'to make manual pages'),\n    ('', 'texinfo', 'to make Texinfo files'),\n    ('posix', 'info', 'to make Texinfo files and run them through makeinfo'),\n    ('', 'gettext', 'to make PO message catalogs'),\n    ('', 'changes', 'to make an overview of all changed/added/deprecated items'),\n    ('', 'xml', 'to make Docutils-native XML files'),\n    ('', 'pseudoxml', 'to make pseudoxml-XML files for display purposes'),\n    ('', 'linkcheck', 'to check all external links for int"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}], "retrieved_count": 10, "cost_time": 1.1003246307373047}
{"question": "Why does Sphinx's parallel document processing reduce memory usage and CPU utilization?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's parallel document processing reduces memory usage and CPU utilization through several mechanisms that distribute the workload more efficiently across system resources. This approach provides better resource management compared to single-threaded processing.\n\nKey ways parallel processing reduces resource usage include:\n\n1. **Distributed Memory Load**: By distributing document processing across multiple processes, the memory load is spread out rather than concentrated in a single process. Each worker process handles a subset of documents, reducing peak memory usage in any single process.\n\n2. **Process Isolation**: Each worker process has its own memory space, allowing the operating system to manage memory more efficiently. When a process completes its work, its memory can be freed immediately.\n\n3. **CPU Load Balancing**: Parallel processing distributes CPU-intensive tasks across multiple cores, preventing any single core from becoming a bottleneck. This results in more efficient CPU utilization and better overall system performance.\n\n4. **Reduced Memory Fragmentation**: By processing documents in smaller chunks across multiple processes, memory fragmentation is reduced compared to processing all documents in a single large process.\n\n5. **Fault Tolerance**: If one worker process encounters memory issues or crashes, only that process is affected. The main process and other workers can continue processing, improving overall system stability.\n\n6. **Garbage Collection Efficiency**: Smaller processes have more efficient garbage collection, as the garbage collector can work on smaller memory spaces more effectively.\n\n7. **I/O Parallelization**: Multiple processes can perform I/O operations in parallel, reducing the time spent waiting for disk operations and improving overall throughput.\n\n8. **Scalable Resource Usage**: The system can scale resource usage based on the number of available CPU cores, making better use of modern multi-core systems without overwhelming any single resource.\n\nParallel processing is particularly effective at reducing resource usage for large projects where the overhead of process management is outweighed by the benefits of distributed processing.", "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 5613, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self._result_funcs.pop(tid)\n            self._procs.pop(tid)\n            self._precvs.pop(tid)\n            self._pworking -= 1\n\n    def _join_one(self) -> bool:\n        joined_any = False\n        for tid, pipe in self._precvs.items():\n            if pipe.poll():\n                exc, logs, result = pipe.recv()\n                if exc:\n                    raise SphinxParallelError(*result)\n                for log in logs:\n                    logger.handle(log)\n                self._result_funcs.pop(tid)(self._args.pop(tid), result)\n                self._procs[tid].join()\n                self._precvs.pop(tid)\n                self._pworking -= 1\n                joined_any = True\n                break\n\n        while self._precvs_waiting and self._pworking < self.nproc:\n            newtid, newprecv = self._precvs_waiting.popitem()\n            self._precvs[newtid] = newprecv\n            self._procs[newtid].start()\n            self._pworking += 1\n\n        return joined_any\n\n\ndef make_chunks(arguments: Sequence[str], nproc: int, maxbatch: int = 10) -> list[Any]:\n    # determine how many documents to read in one go\n    nargs = len(arguments)\n    chunksize = nargs // nproc\n    if chunksize >= maxbatch:\n        # try to improve batch size vs. number of batches\n        chunksize = int(sqrt(nargs / nproc * maxbatch))\n    if chunksize == 0:\n        chunksize = 1\n    nchunks, rest = divmod(nargs, chunksize)\n    if rest:\n        nchunks += 1\n    # partition documents in \"chunks\" that will be written by one Process\n    return [arguments[i * chunksize : (i + 1) * chunksize] for i in range(nchunks)]\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "parallel.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Parallel building utilities.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport time\nimport traceback\nfrom math import sqrt\nfrom typing import TYPE_CHECKING\n\ntry:\n    import multiprocessing\n\n    HAS_MULTIPROCESSING = True\nexcept ImportError:\n    HAS_MULTIPROCESSING = False\n\nfrom sphinx.errors import SphinxParallelError\nfrom sphinx.util import logging\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Sequence\n    from typing import Any\n\nlogger = logging.getLogger(__name__)\n\n# our parallel functionality only works for the forking Process\nparallel_available = HAS_MULTIPROCESSING and os.name == 'posix'\n\n\nclass SerialTasks:\n    \"\"\"Has the same interface as ParallelTasks, but executes tasks directly.\"\"\"\n\n    def __init__(self, nproc: int = 1) -> None:\n        pass\n\n    def add_task(\n        self,\n        task_func: Callable[[Any], Any] | Callable[[], Any],\n        arg: Any = None,\n        result_func: Callable[[Any], Any] | None = None,\n    ) -> None:\n        if arg is not None:\n            res = task_func(arg)  # type: ignore[call-arg]\n        else:\n            res = task_func()  # type: ignore[call-arg]\n        if result_func:\n            result_func(res)\n\n    def join(self) -> None:\n        pass\n\n\nclass ParallelTasks:\n    \"\"\"Executes *nproc* tasks in parallel after forking.\"\"\"\n\n    def __init__(self, nproc: int) -> None:\n        self.nproc = nproc\n        # (optional) function performed by each task on the result of main task\n        self._result_funcs: dict[int, Callable[[Any, Any], Any]] = {}\n        # task arguments\n        self._args: dict[int, list[Any] | None] = {}\n        # list of subprocesses (both started and waiting)\n        self._procs: dict[int, Any] = {}\n        # list of receiving pipe connections of running subprocesses\n        self._precvs: dict[int, Any] = {}\n        # list of receiving pipe connections of waiting subprocesses\n        self._precvs_waiting: dict[int, Any] = {}\n        # number of working subprocesses\n        self._p"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.l"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pp.parallel)\n        else:\n            self._read_serial(docnames)\n\n        if self.config.master_doc not in self.env.all_docs:\n            from sphinx.project import EXCLUDE_PATHS\n            from sphinx.util.matching import _translate_pattern\n\n            master_doc_path = self.env.doc2path(self.config.master_doc)\n            master_doc_canon = master_doc_path.as_posix()\n            for pat in EXCLUDE_PATHS:\n                if not re.match(_translate_pattern(pat), master_doc_canon):\n                    continue\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it matches a built-in exclude pattern %r. '\n                    'Please move your master document to a different location.'\n                )\n                raise SphinxError(msg % (master_doc_path, pat))\n            for pat in self.config.exclude_patterns:\n                if not re.match(_translate_pattern(pat), master_doc_canon):\n                    continue\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it matches an exclude pattern specified '\n                    'in conf.py, %r. '\n                    'Please remove this pattern from conf.py.'\n                )\n                raise SphinxError(msg % (master_doc_path, pat))\n            if set(self.config.include_patterns) != {'**'} and not any(\n                re.match(_translate_pattern(pat), master_doc_canon)\n                for pat in self.config.include_patterns\n            ):\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it is not included in the custom include_patterns = %r. '\n                    'Ensure that a pattern in include_patterns matches the '\n                    'master document.'\n                )\n                raise SphinxError(msg % (master_doc_path, self.config.include_patterns))\n            msg"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.loads(otherenv)\n            self.env.merge_info_from(docs, env, self._app)\n\n            next(progress)\n\n        tasks = ParallelTasks(nproc)\n        for chunk in chunks:\n            tasks.add_task(read_process, chunk, merge)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    @final\n    def read_doc(self, docname: str, *, _cache: bool = True) -> None:\n        \"\"\"Parse a file and add/update inventory entries for the doctree.\"\"\"\n        env = self.env\n        env.prepare_settings(docname)\n\n        # Add confdir/docutils.conf to dependencies list if exists\n        docutils_conf = self.confdir / 'docutils.conf'\n        if docutils_conf.is_file():\n            env.note_dependency(docutils_conf)\n\n        filename = env.doc2path(docname)\n\n        # set up error_handler for the target document\n        # xref RemovedInSphinx90Warning\n        error_handler = _UnicodeDecodeErrorHandler(docname)\n        codecs.register_error('sphinx', error_handler)  # ty"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "create\n        output files for each document.\n        \"\"\"\n        sorted_docnames = sorted(docnames)\n        if self.parallel_ok:\n            # number of subprocesses is parallel-1 because the main process\n            # is busy loading doctrees and doing write_doc_serialized()\n            self._write_parallel(sorted_docnames, nproc=self._app.parallel - 1)\n        else:\n            self._write_serial(sorted_docnames)\n\n    def _write_serial(self, docnames: Sequence[str]) -> None:\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            for docname in status_iterator(\n                docnames,\n                __('writing output... '),\n                'darkgreen',\n                len(docnames),\n                self.config.verbosity,\n            ):\n                _write_docname(docname, env=self.env, builder=self, tags=self.tags)\n\n    def _write_parallel(self, docnames: Sequence[str], nproc: int) -> None:\n        def write_process(docs: list[tuple[str, nodes.document]]) -> None:\n            self.phase = BuildPhase.WRITING\n            for docname, doctree in docs:\n                self.write_doc(docname, doctree)\n\n        # warm up caches/compile templates using the first document\n        firstname, docnames = docnames[0], docnames[1:]\n        _write_docname(firstname, env=self.env, builder=self, tags=self.tags)\n\n        tasks = ParallelTasks(nproc)\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after writing a document\n        # (see: ``on_chunk_done()`` function)\n        progress = status_iterator(\n            chunks,\n            __('writing output... '),\n            'darkgreen',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        def on_chunk_done(args: list[tuple[str, nodes.document]], result: None) -> None:\n            next(progress)\n\n        self.phase = BuildPhase.RESOLVING\n        for c"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int) -> None:\n        def write_process(docs: list[tuple[str, nodes.document]]) -> None:\n            self.phase = BuildPhase.WRITING\n            for docname, doctree in docs:\n                self.write_doc(docname, doctree)\n\n        # warm up caches/compile templates using the first document\n        firstname, docnames = docnames[0], docnames[1:]\n        _write_docname(firstname, env=self.env, builder=self, tags=self.tags)\n\n        tasks = ParallelTasks(nproc)\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after writing a document\n        # (see: ``on_chunk_done()`` function)\n        progress = status_iterator(\n            chunks,\n            __('writing output... '),\n            'darkgreen',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        def on_chunk_done(args: list[tuple[str, nodes.document]], result: None) -> None:\n            next(progress)\n\n        self.phase = BuildPhase.RESOLVING\n        for chunk in chunks:\n            arg = []\n            for docname in chunk:\n                doctree = self.env.get_and_resolve_doctree(\n                    docname, self, tags=self.tags\n                )\n                self.write_doc_serialized(docname, doctree)\n                arg.append((docname, doctree))\n            tasks.add_task(write_process, arg, on_chunk_done)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        \"\"\"A place where you can add logic before :meth:`write_doc` is run\"\"\"\n        pass\n\n    def copy_assets(self) -> None:\n        \"\"\"Where assets (images, static files, etc) are copied before writing\"\"\"\n        pass\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Write the output file for the document\n\n        :param docname: the :term:`docname <document name>`.\n        :param doctree: defines the content to be written.\n\n        The ou"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "duration.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Measure document reading durations.\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom itertools import islice\nfrom operator import itemgetter\nfrom typing import TYPE_CHECKING\n\nimport sphinx\nfrom sphinx.domains import Domain\nfrom sphinx.locale import __\nfrom sphinx.util import logging\n\nif TYPE_CHECKING:\n    from collections.abc import Set\n    from typing import TypedDict\n\n    from docutils import nodes\n\n    from sphinx.application import Sphinx\n\n    class _DurationDomainData(TypedDict):\n        reading_durations: dict[str, float]\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass DurationDomain(Domain):\n    \"\"\"A domain for durations of Sphinx processing.\"\"\"\n\n    name = 'duration'\n\n    @property\n    def reading_durations(self) -> dict[str, float]:\n        return self.data.setdefault('reading_durations', {})\n\n    def note_reading_duration(self, duration: float) -> None:\n        self.reading_durations[self.env.current_document.docname] = duration\n\n    def clear(self) -> None:\n        self.reading_durations.clear()\n\n    def clear_doc(self, docname: str) -> None:\n        self.reading_durations.pop(docname, None)\n\n    def merge_domaindata(  # type: ignore[override]\n        self, docnames: Set[str], otherdata: _DurationDomainData\n    ) -> None:\n        other_reading_durations = otherdata.get('reading_durations', {})\n        docnames_set = frozenset(docnames)\n        for docname, duration in other_reading_durations.items():\n            if docname in docnames_set:\n                self.reading_durations[docname] = duration\n\n\ndef on_builder_inited(app: Sphinx) -> None:\n    \"\"\"Initialize DurationDomain on bootstrap.\n\n    This clears the results of the last build.\n    \"\"\"\n    domain = app.env.domains['duration']\n    domain.clear()\n\n\ndef on_source_read(app: Sphinx, docname: str, content: list[str]) -> None:\n    \"\"\"Start to measure reading duration.\"\"\"\n    app.env.current_document.reading_started_at = time.monotonic()\n\n\ndef on_doctree_read(app: Sphinx, doctree: nodes.document"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  continue\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it matches an exclude pattern specified '\n                    'in conf.py, %r. '\n                    'Please remove this pattern from conf.py.'\n                )\n                raise SphinxError(msg % (master_doc_path, pat))\n            if set(self.config.include_patterns) != {'**'} and not any(\n                re.match(_translate_pattern(pat), master_doc_canon)\n                for pat in self.config.include_patterns\n            ):\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it is not included in the custom include_patterns = %r. '\n                    'Ensure that a pattern in include_patterns matches the '\n                    'master document.'\n                )\n                raise SphinxError(msg % (master_doc_path, self.config.include_patterns))\n            msg = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.copy_download_files)\n        self.finish_tasks.add_task(self.copy_static_files)\n        self.finish_tasks.add_task(self.copy_extra_files)\n        self.finish_tasks.join()\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        doctree.settings = self.docsettings\n\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n        self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n        self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n        self.current_docname = docname\n        visitor: HTML5Translator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        body = ''.join(visitor.fragment)\n        clean_meta = ''.join(visitor.meta[2:])\n\n        ctx = self.get_doc_context(docname, body, clean_meta)\n        ctx['has_maths_elements'] = getattr(visitor, '_has_maths_elements', False)\n        self.handle_page(docname, ctx, event_arg=doctree)\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n        self.post_process_images(doctree)\n        title_node = self.env.longtitles.get(docname)\n        title = self.render_partial(title_node)['title'] if title_node else ''\n        self.index_page(docname, doctree, title)\n\n    def finish(self) -> None:\n        self.finish_tasks.add_task(self.gen_indices)\n        self.finish_tasks.add_task(self.gen_pages_from_extensions)\n        self.finish_tasks.add_task(self.gen_additional_pages)\n        self.finish_tasks.add_task(self.copy_image_files)\n        self.finish_tasks.add_task(self.write_buildinfo)\n\n        # dump the search index\n        self.handle_finish()\n\n    @progress_message(__('generating indices'))\n    def gen_indices(self) -> None:\n        # the global general index\n        if self.use_index:\n            self.write_g"}], "retrieved_count": 10, "cost_time": 1.1159579753875732}
{"question": "Why does Sphinx's caching strategy optimize build time versus memory consumption trade-offs?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's caching strategy optimizes build time versus memory consumption trade-offs through a sophisticated multi-level caching system that balances performance benefits with resource constraints. This approach provides optimal performance while managing memory usage effectively.\n\nKey aspects of Sphinx's caching strategy include:\n\n1. **Selective Caching**: Sphinx caches the most expensive-to-compute data (like parsed document trees and cross-reference metadata) while avoiding caching of easily regenerated information, optimizing the memory-to-performance ratio.\n\n2. **Environment Persistence**: The build environment, which contains cross-references, metadata, and document relationships, is cached as a pickle file. This provides significant build time savings while using a reasonable amount of disk space.\n\n3. **Document Tree Caching**: Parsed document trees are cached to avoid expensive re-parsing of unchanged files. The system uses disk-based caching to avoid keeping all document trees in memory simultaneously.\n\n4. **Memory Management**: Sphinx clears in-memory caches when serializing the environment to disk, reducing memory consumption while preserving the performance benefits of caching.\n\n5. **Incremental Cache Updates**: The caching system only updates cached data for files that have actually changed, minimizing both cache update time and memory usage.\n\n6. **Configurable Cache Levels**: Different types of data are cached at different levels (memory vs. disk) based on their access patterns and regeneration costs, optimizing the trade-off between speed and memory usage.\n\n7. **Cache Invalidation**: The system intelligently invalidates cached data when dependencies change, ensuring consistency while avoiding unnecessary cache rebuilds.\n\n8. **Resource-Aware Caching**: The caching strategy takes into account available system resources, allowing it to adapt to different system configurations and project sizes.\n\nThis multi-level approach allows Sphinx to provide significant build time improvements while keeping memory usage within reasonable bounds, making it suitable for both small and large documentation projects.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ache: dict[str, bytes] = {}\n        \"\"\"In-memory cache for reading pickled doctrees from disk.\n        docname -> pickled doctree\n\n        This cache is used in the ``get_doctree`` method to avoid reading the\n        doctree from disk multiple times.\n        \"\"\"\n\n        self._write_doc_doctree_cache: dict[str, nodes.document] = {}\n        \"\"\"In-memory cache for unpickling doctrees from disk.\n        docname -> doctree\n\n        Items are added in ``Builder.write_doctree``, during the read phase,\n        then used only in the ``get_and_resolve_doctree`` method.\n        \"\"\"\n\n        # File metadata\n        # docname -> dict of metadata items\n        self.metadata: dict[str, dict[str, Any]] = defaultdict(dict)\n\n        # TOC inventory\n        # docname -> title node\n        self.titles: dict[str, nodes.title] = {}\n        # docname -> title node; only different if\n        # set differently with title directive\n        self.longtitles: dict[str, nodes.title] = {}\n        # docname -> table of contents nodetree\n        self.tocs: dict[str, nodes.bullet_list] = {}\n        # docname -> number of real entries\n        self.toc_num_entries: dict[str, int] = {}\n\n        # used to determine when to show the TOC\n        # in a sidebar (don't show if it's only one item)\n        # docname -> dict of sectionid -> number\n        self.toc_secnumbers: dict[str, dict[str, tuple[int, ...]]] = {}\n        # docname -> dict of figtype -> dict of figureid -> number\n        self.toc_fignumbers: dict[str, dict[str, dict[str, tuple[int, ...]]]] = {}\n\n        # docname -> list of toctree includefiles\n        self.toctree_includes: dict[str, list[str]] = {}\n        # docname -> set of files (containing its TOCs) to rebuild too\n        self.files_to_rebuild: dict[str, set[str]] = {}\n        # docnames that have :glob: toctrees\n        self.glob_toctrees: set[str] = set()\n        # docnames that have :numbered: toctrees\n        self.numbered_toctrees: set[str] = set()\n\n        # domain-specific in"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rsioning_method\n        self.versioning_condition: Literal[False] | Callable[[Node], bool] | None = None\n        self.versioning_compare: bool | None = None\n\n        # the docutils settings for building\n        self.settings: dict[str, Any] = default_settings.copy()\n        self.settings['env'] = self\n\n        # All \"docnames\" here are /-separated and relative and exclude\n        # the source suffix.\n\n        # docname -> time of reading (in integer microseconds)\n        # contains all read docnames\n        self.all_docs: dict[str, int] = {}\n        # docname -> set of dependent file\n        # names, relative to documentation root\n        self.dependencies: dict[str, set[_StrPath]] = defaultdict(set)\n        # docname -> set of included file\n        # docnames included from other documents\n        self.included: dict[str, set[str]] = defaultdict(set)\n        # docnames to re-read unconditionally on next build\n        self.reread_always: set[str] = set()\n\n        self._pickled_doctree_cache: dict[str, bytes] = {}\n        \"\"\"In-memory cache for reading pickled doctrees from disk.\n        docname -> pickled doctree\n\n        This cache is used in the ``get_doctree`` method to avoid reading the\n        doctree from disk multiple times.\n        \"\"\"\n\n        self._write_doc_doctree_cache: dict[str, nodes.document] = {}\n        \"\"\"In-memory cache for unpickling doctrees from disk.\n        docname -> doctree\n\n        Items are added in ``Builder.write_doctree``, during the read phase,\n        then used only in the ``get_and_resolve_doctree`` method.\n        \"\"\"\n\n        # File metadata\n        # docname -> dict of metadata items\n        self.metadata: dict[str, dict[str, Any]] = defaultdict(dict)\n\n        # TOC inventory\n        # docname -> title node\n        self.titles: dict[str, nodes.title] = {}\n        # docname -> title node; only different if\n        # set differently with title directive\n        self.longtitles: dict[str, nodes.title] = {}\n        # docname -> table"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "octree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in parallel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        "}, {"start_line": 9000, "end_line": 10634, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path or '', removal version)\n_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {\n    'strip_escseq': (\n        strip_escape_sequences,\n        'sphinx.util.console.strip_escape_sequences',\n        (9, 0),\n    ),\n}\n\n\ndef __getattr__(name: str) -> Any:\n    if name not in _DEPRECATED_OBJECTS:\n        msg = f'module {__name__!r} has no attribute {name!r}'\n        raise AttributeError(msg)\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=remove)\n    return deprecated_object\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "_load.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = [f.result() for f in concurrent.futures.as_completed(futures)]\n\n    if any(updated):\n        # clear the local inventories\n        inventories.clear()\n\n        # Duplicate values in different inventories will shadow each\n        # other; which one will override which can vary between builds.\n        #\n        # In an attempt to make this more consistent,\n        # we sort the named inventories in the cache\n        # by their name and expiry time ``(NAME, EXPIRY)``.\n        by_name_and_time = itemgetter(0, 1)  # 0: name, 1: expiry\n        cache_values = sorted(intersphinx_cache.values(), key=by_name_and_time)\n        for name, _expiry, invdata in cache_values:\n            inventories.named_inventory[name] = invdata\n            for objtype, objects in invdata.items():\n                inventories.main_inventory.setdefault(objtype, {}).update(objects)\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True, slots=True)\nclass _InvConfig:\n    intersphinx_cache_limit: int\n    intersphinx_timeout: int | float | None\n    tls_verify: bool\n    tls_cacerts: str | dict[str, str] | None\n    user_agent: str\n\n    @classmethod\n    def from_config(cls, config: Config) -> _InvConfig:\n        return cls(\n            intersphinx_cache_limit=config.intersphinx_cache_limit,\n            intersphinx_timeout=config.intersphinx_timeout,\n            tls_verify=config.tls_verify,\n            tls_cacerts=config.tls_cacerts,\n            user_agent=config.user_agent,\n        )\n\n\ndef _fetch_inventory_group(\n    *,\n    project: _IntersphinxProject,\n    cache: dict[InventoryURI, InventoryCacheEntry],\n    now: int,\n    config: _InvConfig,\n    srcdir: Path,\n    cache_dir: Path | None,\n) -> bool:\n    if config.intersphinx_cache_limit >= 0:\n        # Positive value: cache is expired if its timestamp is below\n        # `now - X days`.\n        cache_time = now - config.intersphinx_cache_limit * 86400\n    else:\n        # Negative value: cache is expired if its timestamp is below\n        # zero, which is impos"}, {"start_line": 4000, "end_line": 5490, "belongs_to": {"file_name": "_shared.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(msg)\n\n\nclass InventoryAdapter:\n    \"\"\"Inventory adapter for environment\"\"\"\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n        if not hasattr(env, 'intersphinx_cache'):\n            # initial storage when fetching inventories before processing\n            self.env.intersphinx_cache = {}  # type: ignore[attr-defined]\n\n            self.env.intersphinx_inventory = {}  # type: ignore[attr-defined]\n            self.env.intersphinx_named_inventory = {}  # type: ignore[attr-defined]\n\n    @property\n    def cache(self) -> dict[InventoryURI, InventoryCacheEntry]:\n        \"\"\"Intersphinx cache.\n\n        - Key is the URI of the remote inventory.\n        - Element one is the key given in the Sphinx :confval:`intersphinx_mapping`.\n        - Element two is a time value for cache invalidation, an integer.\n        - Element three is the loaded remote inventory of type :class:`!Inventory`.\n        \"\"\"\n        return self.env.intersphinx_cache  # type: ignore[attr-defined]\n\n    @property\n    def main_inventory(self) -> Inventory:\n        return self.env.intersphinx_inventory  # type: ignore[attr-defined]\n\n    @property\n    def named_inventory(self) -> dict[InventoryName, Inventory]:\n        return self.env.intersphinx_named_inventory  # type: ignore[attr-defined]\n\n    def clear(self) -> None:\n        self.env.intersphinx_inventory.clear()  # type: ignore[attr-defined]\n        self.env.intersphinx_named_inventory.clear()  # type: ignore[attr-defined]\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              exception_on_warning=exception_on_warning,\n            )\n        except Exception:\n            self.cleanup()\n            raise\n\n    def _init_builder(self) -> None:\n        # override the default theme to 'basic' rather than 'alabaster'\n        # for test independence\n\n        if 'html_theme' in self.config._overrides:\n            pass  # respect overrides\n        elif 'html_theme' in self.config and self.config.html_theme == 'alabaster':\n            self.config.html_theme = self.config._overrides.get('html_theme', 'basic')\n        super()._init_builder()\n\n    @property\n    def status(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application status messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._status, StringIO)\n        return self._status\n\n    @property\n    def warning(self) -> StringIO:\n        \"\"\"The in-memory text I/O for the application warning messages.\"\"\"\n        # sphinx.application.Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(sel"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".Sphinx uses StringIO for a quiet stream\n        assert isinstance(self._warning, StringIO)\n        return self._warning\n\n    def cleanup(self, doctrees: bool = False) -> None:\n        sys.path[:] = self._saved_path\n        _clean_up_global_state()\n        try:\n            self.docutils_conf_path.unlink(missing_ok=True)\n        except OSError as exc:\n            if exc.errno != 30:  # Ignore \"read-only file system\" errors\n                raise\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} buildername={self._builder_name!r}>'\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.env._pickled_doctree_cache.clear()\n        super().build(force_all, filenames)\n\n\nclass SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):\n    \"\"\"A wrapper for SphinxTestApp.\n\n    This class is used to speed up the test by skipping ``app.build()``\n    if it has already been built and there are any output files.\n    \"\"\"\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_load.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nger in `intersphinx_mapping`.\n            del intersphinx_cache[uri]\n        elif uri not in expected_uris:\n            # Remove cached entries with a different target URI\n            # than the one in `intersphinx_mapping`.\n            # This happens when the URI in `intersphinx_mapping` is changed.\n            del intersphinx_cache[uri]\n\n    inv_config = _InvConfig.from_config(app.config)\n    with concurrent.futures.ThreadPoolExecutor() as pool:\n        futures = [\n            pool.submit(\n                _fetch_inventory_group,\n                project=project,\n                cache=intersphinx_cache,\n                now=now,\n                config=inv_config,\n                srcdir=app.srcdir,\n                # the location of this cache directory must not be relied upon\n                # externally, it may change without notice or warning.\n                cache_dir=app.doctreedir / '__intersphinx_cache__',\n            )\n            for project in projects\n        ]\n        updated = [f.result() for f in concurrent.futures.as_completed(futures)]\n\n    if any(updated):\n        # clear the local inventories\n        inventories.clear()\n\n        # Duplicate values in different inventories will shadow each\n        # other; which one will override which can vary between builds.\n        #\n        # In an attempt to make this more consistent,\n        # we sort the named inventories in the cache\n        # by their name and expiry time ``(NAME, EXPIRY)``.\n        by_name_and_time = itemgetter(0, 1)  # 0: name, 1: expiry\n        cache_values = sorted(intersphinx_cache.values(), key=by_name_and_time)\n        for name, _expiry, invdata in cache_values:\n            inventories.named_inventory[name] = invdata\n            for objtype, objects in invdata.items():\n                inventories.main_inventory.setdefault(objtype, {}).update(objects)\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True, slots=True)\nclass _InvConfig:\n    intersphinx_cache_limit: int\n    intersphinx_timeou"}, {"start_line": 0, "end_line": 277, "belongs_to": {"file_name": "build_phase.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build phase of Sphinx application.\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass BuildPhase(IntEnum):\n    \"\"\"Build phase of Sphinx application.\"\"\"\n\n    INITIALIZATION = 1\n    READING = 2\n    CONSISTENCY_CHECK = 3\n    RESOLVING = 3\n    WRITING = 4\n"}], "retrieved_count": 10, "cost_time": 1.1142446994781494}
{"question": "Why does Sphinx's extension system design impact build performance when multiple extensions are loaded?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's extension system design impacts build performance when multiple extensions are loaded due to the cumulative overhead of extension processing and the way extensions integrate with the build process. This impact becomes more significant as the number of loaded extensions increases.\n\nKey factors that affect build performance include:\n\n1. **Event Processing Overhead**: Each extension that connects to Sphinx events adds processing time during the build. Multiple extensions listening to the same events can create a cascade of processing that accumulates across the entire build process.\n\n2. **Document Tree Modifications**: Extensions that modify document trees during processing (e.g., adding nodes, transforming content) can significantly impact performance, especially when multiple extensions perform similar operations on the same documents.\n\n3. **Cross-Reference Processing**: Extensions that add custom cross-reference types or modify cross-reference resolution can increase the complexity and time required for the reference resolution phase.\n\n4. **Memory Usage**: Each extension adds to the memory footprint of the build process. Multiple extensions can collectively consume significant memory, especially if they cache data or maintain large data structures.\n\n5. **Initialization Overhead**: Extensions require initialization time during the build setup phase. With many extensions, this initialization time can become noticeable.\n\n6. **Dependency Conflicts**: Some extensions may have conflicting requirements or may perform redundant operations, leading to inefficient processing and potential performance degradation.\n\n7. **Extension Ordering**: The order in which extensions are loaded and their event handler priorities can affect performance, as some extensions may need to process documents multiple times or in specific sequences.\n\n8. **Resource Competition**: Multiple extensions competing for the same system resources (CPU, memory, I/O) can lead to performance bottlenecks, especially on systems with limited resources.\n\nThe extension system's event-driven architecture, while providing flexibility and extensibility, introduces these performance considerations that need to be balanced against the functionality benefits that extensions provide.", "score": null, "retrieved_content": [{"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode == 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".debug(\n            '[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter\n        )\n        if node in self.enumerable_nodes and not override:\n            raise ExtensionError(__('enumerable_node %r already registered') % node)\n        self.enumerable_nodes[node] = (figtype, title_getter)\n\n    def add_html_math_renderer(\n        self,\n        name: str,\n        inline_renderers: _MathsInlineRenderers | None,\n        block_renderers: _MathsBlockRenderers | None,\n    ) -> None:\n        logger.debug(\n            '[app] adding html_math_renderer: %s, %r, %r',\n            name,\n            inline_renderers,\n            block_renderers,\n        )\n        if name in self.html_inline_math_renderers:\n            raise ExtensionError(__('math renderer %s is already registered') % name)\n\n        if inline_renderers is not None:\n            self.html_inline_math_renderers[name] = inline_renderers\n        if block_renderers is not None:\n            self.html_block_math_renderers[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + tra"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tuple of filename and attributes\n        self.css_files: list[tuple[str, dict[str, Any]]] = []\n\n        #: domains; a dict of domain name -> domain class\n        self.domains: dict[str, type[Domain]] = {}\n\n        #: additional directives for domains\n        #: a dict of domain name -> dict of directive name -> directive\n        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}\n\n        #: additional indices for domains\n        #: a dict of domain name -> list of index class\n        self.domain_indices: dict[str, list[type[Index]]] = {}\n\n        #: additional object types for domains\n        #: a dict of domain name -> dict of objtype name -> objtype\n        self.domain_object_types: dict[str, dict[str, ObjType]] = {}\n\n        #: additional roles for domains\n        #: a dict of domain name -> dict of role name -> role impl.\n        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}\n\n        #: additional enumerable nodes\n        #: a dict of node class"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ext.todo import todo_node\n    from sphinx.extension import Extension\n    from sphinx.registry import (\n        _MathsBlockRenderers,\n        _MathsInlineRenderers,\n        _NodeHandler,\n        _NodeHandlerPair,\n    )\n    from sphinx.roles import XRefRole\n    from sphinx.search import SearchLanguage\n    from sphinx.theming import Theme\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import RoleFunction, TitleGetter\n\n\nbuiltin_extensions: tuple[str, ...] = (\n    'sphinx.addnodes',\n    'sphinx.builders.changes',\n    'sphinx.builders.epub3',\n    'sphinx.builders.dirhtml',\n    'sphinx.builders.dummy',\n    'sphinx.builders.gettext',\n    'sphinx.builders.html',\n    'sphinx.builders.latex',\n    'sphinx.builders.linkcheck',\n    'sphinx.builders.manpage',\n    'sphinx.builders.singlehtml',\n    'sphinx.builders.texinfo',\n    'sphinx.builders.text',\n    'sphinx.builders.xml',\n    'sphinx.config',\n    'sphinx.domains.c',\n    'sphinx.domains.changeset',\n    'sphinx.domains.citation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environme"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + traceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot b"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot be built with this '\n                            'version.'\n                        )\n                        % (extname, err),\n                    ) from err\n\n            if metadata is None:\n                metadata = {}\n            elif not isinstance(metadata, dict):\n                logger.warning(\n                    __(\n                        'extension %r returned an unsupported object from '\n                        'its setup() function; it should return None or a '\n                        'metadata dictionary'\n                    ),\n                    extname,\n                )\n                metadata = {}\n\n            app.extensions[extname] = Extension(extname, mod, **metadata)\n\n    def get_envversion(self, app: Sphinx) -> Mapping[str, int]:\n        from sphinx.environment import _get_env_version\n\n        return _get_env_version(app.extensions)\n\n\ndef merge_source_suffix(app: Sphinx, config: Config) -> None:\n    \"\"\"Merge any user-specified source_suffix with any added by ex"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}], "retrieved_count": 10, "cost_time": 1.123934030532837}
{"question": "Why does Sphinx implement document tree serialization for distributed builds?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements document tree serialization for distributed builds to enable efficient parallel processing and sharing of parsed document data across multiple processes. This feature is essential for the parallel build system and provides several important benefits.\n\nKey reasons for implementing document tree serialization include:\n\n1. **Parallel Processing Support**: Document tree serialization allows Sphinx to distribute document processing across multiple parallel processes. Each process can work on a subset of documents independently, and the results can be merged back into the main build environment.\n\n2. **Process Communication**: Serialization enables communication between the main Sphinx process and worker processes. Document trees can be passed to worker processes for processing and then returned with the results.\n\n3. **Memory Efficiency**: By serializing document trees, Sphinx can transfer document data between processes without keeping all document trees in memory simultaneously in the main process, which is important for large projects.\n\n4. **Data Sharing**: Serialization allows the build environment and document metadata to be shared between processes, ensuring that all processes have access to the necessary information for cross-reference resolution and other build tasks.\n\n5. **Incremental Build Integration**: Serialized document trees can be cached and reused in subsequent builds, supporting the incremental build system by allowing processed document trees to persist between builds.\n\n6. **Fault Tolerance**: If a worker process fails, the serialized data can be used to restart processing without losing all progress, improving the robustness of the parallel build system.\n\n7. **Scalability**: Document tree serialization enables Sphinx to scale beyond the memory limitations of a single process, allowing for processing of very large documentation projects.\n\n8. **Cross-Platform Compatibility**: Serialization provides a standardized way to transfer complex data structures between processes, ensuring compatibility across different operating systems and Python implementations.\n\nThe serialization system uses Python's pickle module to serialize document trees and build environment data, allowing for efficient transfer and storage of complex document structures while maintaining the integrity of the build process.", "score": null, "retrieved_content": [{"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "octree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in parallel mode, ``write_doctree()`` is invoked\n        # in the context of a process worker, and thus it does not make sense to\n        # pickle the doctree and send it to the main process\n        if _cache:\n            self.env._write_doc_doctree_cache[docname] = doctree\n\n    @final\n    def write(\n        self,\n        build_docnames: Iterable[str] | None,\n        updated_docnames: Iterable[str],\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Write builder specific output files.\"\"\"\n        env = self.env\n\n        # Allow any extensions to perform setup for writing\n        self.events.emit('write-started', self)\n\n        if build_docnames is None or build_docnames == ['__all__']:\n            # build_all\n            build_docnames = env.found_docs\n        if method == 'update':\n            # build updated ones as well\n            docnames = set(build_docnames) | set(updated_docnames)\n        else:\n            docnames = set(build_docnames)\n        "}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.copy_download_files)\n        self.finish_tasks.add_task(self.copy_static_files)\n        self.finish_tasks.add_task(self.copy_extra_files)\n        self.finish_tasks.join()\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        doctree.settings = self.docsettings\n\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n        self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n        self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n        self.current_docname = docname\n        visitor: HTML5Translator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        body = ''.join(visitor.fragment)\n        clean_meta = ''.join(visitor.meta[2:])\n\n        ctx = self.get_doc_context(docname, body, clean_meta)\n        ctx['has_maths_elements'] = getattr(visitor, '_has_maths_elements', False)\n        self.handle_page(docname, ctx, event_arg=doctree)\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n        self.post_process_images(doctree)\n        title_node = self.env.longtitles.get(docname)\n        title = self.render_partial(title_node)['title'] if title_node else ''\n        self.index_page(docname, doctree, title)\n\n    def finish(self) -> None:\n        self.finish_tasks.add_task(self.gen_indices)\n        self.finish_tasks.add_task(self.gen_pages_from_extensions)\n        self.finish_tasks.add_task(self.gen_additional_pages)\n        self.finish_tasks.add_task(self.copy_image_files)\n        self.finish_tasks.add_task(self.write_buildinfo)\n\n        # dump the search index\n        self.handle_finish()\n\n    @progress_message(__('generating indices'))\n    def gen_indices(self) -> None:\n        # the global general index\n        if self.use_index:\n            self.write_g"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "int) -> None:\n        def write_process(docs: list[tuple[str, nodes.document]]) -> None:\n            self.phase = BuildPhase.WRITING\n            for docname, doctree in docs:\n                self.write_doc(docname, doctree)\n\n        # warm up caches/compile templates using the first document\n        firstname, docnames = docnames[0], docnames[1:]\n        _write_docname(firstname, env=self.env, builder=self, tags=self.tags)\n\n        tasks = ParallelTasks(nproc)\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after writing a document\n        # (see: ``on_chunk_done()`` function)\n        progress = status_iterator(\n            chunks,\n            __('writing output... '),\n            'darkgreen',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        def on_chunk_done(args: list[tuple[str, nodes.document]], result: None) -> None:\n            next(progress)\n\n        self.phase = BuildPhase.RESOLVING\n        for chunk in chunks:\n            arg = []\n            for docname in chunk:\n                doctree = self.env.get_and_resolve_doctree(\n                    docname, self, tags=self.tags\n                )\n                self.write_doc_serialized(docname, doctree)\n                arg.append((docname, doctree))\n            tasks.add_task(write_process, arg, on_chunk_done)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        \"\"\"A place where you can add logic before :meth:`write_doc` is run\"\"\"\n        pass\n\n    def copy_assets(self) -> None:\n        \"\"\"Where assets (images, static files, etc) are copied before writing\"\"\"\n        pass\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Write the output file for the document\n\n        :param docname: the :term:`docname <document name>`.\n        :param doctree: defines the content to be written.\n\n        The ou"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    if doc:\n            self.included.setdefault(self.docname, set()).add(doc)\n\n    def note_reread(self) -> None:\n        \"\"\"Add the current document to the list of documents that will\n        automatically be re-read at the next build.\n        \"\"\"\n        self.reread_always.add(self.docname)\n\n    def get_domain(self, domainname: str) -> Domain:\n        \"\"\"Return the domain instance with the specified name.\n\n        Raises an ExtensionError if the domain is not registered.\n        \"\"\"\n        try:\n            return self.domains[domainname]\n        except KeyError as exc:\n            msg = __('Domain %r is not registered') % domainname\n            raise ExtensionError(msg) from exc\n\n    # --------- RESOLVING REFERENCES AND TOCTREES ------------------------------\n\n    def get_doctree(self, docname: str) -> nodes.document:\n        \"\"\"Read the doctree for a file from the pickle and return it.\"\"\"\n        try:\n            serialised = self._pickled_doctree_cache[docname]\n        except KeyError:\n            filename = self.doctreedir / f'{docname}.doctree'\n            with open(filename, 'rb') as f:\n                serialised = self._pickled_doctree_cache[docname] = f.read()\n\n        doctree = pickle.loads(serialised)\n        doctree.settings.env = self\n        doctree.reporter = LoggingReporter(str(self.doc2path(docname)))\n        return doctree\n\n    @functools.cached_property\n    def master_doctree(self) -> nodes.document:\n        return self.get_doctree(self.config.root_doc)\n\n    def get_and_resolve_doctree(\n        self,\n        docname: str,\n        builder: Builder,\n        *,\n        tags: Tags,\n        doctree: nodes.document | None = None,\n        prune_toctrees: bool = True,\n        includehidden: bool = False,\n    ) -> nodes.document:\n        \"\"\"Read the doctree from the pickle, resolve cross-references and\n        toctrees and return it.\n        \"\"\"\n        if doctree is None:\n            try:\n                doctree = self._write_doc_doctree_cache.pop(docna"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", ...]]] = {}\n        # {'foo': {'figure': {'id2': (2,), 'id1': (1,)}}, 'bar': {'figure': {'id1': (3,)}}}\n        for docname, fignumlist in self.env.toc_fignumbers.items():\n            for figtype, fignums in fignumlist.items():\n                alias = f'{docname}/{figtype}'\n                new_fignumbers.setdefault(alias, {})\n                for id, fignum in fignums.items():\n                    new_fignumbers[alias][id] = fignum\n\n        return {self.config.root_doc: new_fignumbers}\n\n    def get_doc_context(self, docname: str, body: str, metatags: str) -> dict[str, Any]:\n        # no relation links...\n        toctree = global_toctree_for_doc(\n            self.env, self.config.root_doc, self, tags=self.tags, collapse=False\n        )\n        # if there is no toctree, toc is None\n        if toctree:\n            toc = self.render_partial(toctree)['fragment']\n            display_toc = True\n        else:\n            toc = ''\n            display_toc = False\n        return {\n            'parents': [],\n            'prev': None,\n            'next': None,\n            'docstitle': None,\n            'title': self.config.html_title,\n            'meta': None,\n            'body': body,\n            'metatags': metatags,\n            'rellinks': [],\n            'sourcename': '',\n            'toc': toc,\n            'display_toc': display_toc,\n        }\n\n    def write_documents(self, _docnames: Set[str]) -> None:\n        self.prepare_writing(self.env.all_docs.keys())\n\n        with progress_message(__('assembling single document'), nonl=False):\n            doctree = self.assemble_doctree()\n            self.env.toc_secnumbers = self.assemble_toc_secnumbers()\n            self.env.toc_fignumbers = self.assemble_toc_fignumbers()\n\n        with progress_message(__('writing')):\n            self.write_doc_serialized(self.config.root_doc, doctree)\n            self.write_doc(self.config.root_doc, doctree)\n\n    def finish(self) -> None:\n        self.write_additional_files()\n        self.copy_ima"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self.handle_page(docname, ctx, event_arg=doctree)\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n        self.post_process_images(doctree)\n        title_node = self.env.longtitles.get(docname)\n        title = self.render_partial(title_node)['title'] if title_node else ''\n        self.index_page(docname, doctree, title)\n\n    def finish(self) -> None:\n        self.finish_tasks.add_task(self.gen_indices)\n        self.finish_tasks.add_task(self.gen_pages_from_extensions)\n        self.finish_tasks.add_task(self.gen_additional_pages)\n        self.finish_tasks.add_task(self.copy_image_files)\n        self.finish_tasks.add_task(self.write_buildinfo)\n\n        # dump the search index\n        self.handle_finish()\n\n    @progress_message(__('generating indices'))\n    def gen_indices(self) -> None:\n        # the global general index\n        if self.use_index:\n            self.write_genindex()\n\n        # the global domain-specific indices\n        self.write_domain_indices()\n\n    def gen_pages_from_extensions(self) -> None:\n        # pages from extensions\n        for pagelist in self.events.emit('html-collect-pages'):\n            for pagename, context, template in pagelist:\n                self.handle_page(pagename, context, template)\n\n    @progress_message(__('writing additional pages'))\n    def gen_additional_pages(self) -> None:\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info('%s ', pagename, nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        # the search page\n        if self.search:\n            logger.info('search ', nonl=True)\n            self.handle_page('search', {}, 'search.html')\n\n        # the opensearch xml file\n        if self.config.html_use_opensearch and self.search:\n            logger.info('opensearch ', nonl=True)\n            self.handl"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ache: dict[str, bytes] = {}\n        \"\"\"In-memory cache for reading pickled doctrees from disk.\n        docname -> pickled doctree\n\n        This cache is used in the ``get_doctree`` method to avoid reading the\n        doctree from disk multiple times.\n        \"\"\"\n\n        self._write_doc_doctree_cache: dict[str, nodes.document] = {}\n        \"\"\"In-memory cache for unpickling doctrees from disk.\n        docname -> doctree\n\n        Items are added in ``Builder.write_doctree``, during the read phase,\n        then used only in the ``get_and_resolve_doctree`` method.\n        \"\"\"\n\n        # File metadata\n        # docname -> dict of metadata items\n        self.metadata: dict[str, dict[str, Any]] = defaultdict(dict)\n\n        # TOC inventory\n        # docname -> title node\n        self.titles: dict[str, nodes.title] = {}\n        # docname -> title node; only different if\n        # set differently with title directive\n        self.longtitles: dict[str, nodes.title] = {}\n        # docname -> table of contents nodetree\n        self.tocs: dict[str, nodes.bullet_list] = {}\n        # docname -> number of real entries\n        self.toc_num_entries: dict[str, int] = {}\n\n        # used to determine when to show the TOC\n        # in a sidebar (don't show if it's only one item)\n        # docname -> dict of sectionid -> number\n        self.toc_secnumbers: dict[str, dict[str, tuple[int, ...]]] = {}\n        # docname -> dict of figtype -> dict of figureid -> number\n        self.toc_fignumbers: dict[str, dict[str, dict[str, tuple[int, ...]]]] = {}\n\n        # docname -> list of toctree includefiles\n        self.toctree_includes: dict[str, list[str]] = {}\n        # docname -> set of files (containing its TOCs) to rebuild too\n        self.files_to_rebuild: dict[str, set[str]] = {}\n        # docnames that have :glob: toctrees\n        self.glob_toctrees: set[str] = set()\n        # docnames that have :numbered: toctrees\n        self.numbered_toctrees: set[str] = set()\n\n        # domain-specific in"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.l"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rents': [],\n            'prev': None,\n            'next': None,\n            'docstitle': None,\n            'title': self.config.html_title,\n            'meta': None,\n            'body': body,\n            'metatags': metatags,\n            'rellinks': [],\n            'sourcename': '',\n            'toc': toc,\n            'display_toc': display_toc,\n        }\n\n    def write_documents(self, _docnames: Set[str]) -> None:\n        self.prepare_writing(self.env.all_docs.keys())\n\n        with progress_message(__('assembling single document'), nonl=False):\n            doctree = self.assemble_doctree()\n            self.env.toc_secnumbers = self.assemble_toc_secnumbers()\n            self.env.toc_fignumbers = self.assemble_toc_fignumbers()\n\n        with progress_message(__('writing')):\n            self.write_doc_serialized(self.config.root_doc, doctree)\n            self.write_doc(self.config.root_doc, doctree)\n\n    def finish(self) -> None:\n        self.write_additional_files()\n        self.copy_image_files()\n        self.copy_download_files()\n        self.copy_static_files()\n        self.copy_extra_files()\n        self.write_buildinfo()\n        self.dump_inventory()\n\n    @progress_message(__('writing additional files'))\n    def write_additional_files(self) -> None:\n        # no indices or search pages are supported\n\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info(' %s', pagename, nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        if self.config.html_use_opensearch:\n            logger.info(' opensearch', nonl=True)\n            self.handle_page(\n                'opensearch',\n                {},\n                'opensearch.xml',\n                outfilename=self._static_dir / 'opensearch.xml',\n            )\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.setup_extension('sphinx.builders.html')\n\n    app.add_builder(SingleFileHTMLBuilder)\n    app.add_config_value(\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "xml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   yield docname\n                continue\n            targetname = self.outdir / (docname + self.out_suffix)\n            try:\n                targetmtime = _last_modified_time(targetname)\n            except Exception:\n                targetmtime = 0\n            try:\n                srcmtime = _last_modified_time(self.env.doc2path(docname))\n                if srcmtime > targetmtime:\n                    yield docname\n            except OSError:\n                # source doesn't exist anymore\n                pass\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        return docname\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        # work around multiple string % tuple issues in docutils;\n        # replace tuples in attribute values with lists\n        doctree = doctree.deepcopy()\n        for domain in self.env.domains.sorted():\n            doctree[f'xmlns:{domain.name}'] = 'https://www.sphinx-doc.org/'\n        for node in doctree.findall(nodes.Element):\n            for att, value in node.attributes.items():\n                if isinstance(value, tuple):\n                    node.attributes[att] = list(value)\n                value = node.attributes[att]\n                if isinstance(value, list):\n                    for i, val in enumerate(value):\n                        if isinstance(val, tuple):\n                            value[i] = list(val)\n        output = self._translate(doctree)\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def _translate(self, doctree: nodes.document) -> str:\n        doctree.settings.newlines = doctree.settings.indents = self.config.xml_pretty\n        doctree.settings.xml_declaration = True\n        doctree.settings.doct"}], "retrieved_count": 10, "cost_time": 1.1378159523010254}
{"question": "Where does Sphinx's extension system flow from extension loading through hook execution to document modification?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's extension system flow follows a structured path from extension loading through hook execution to document modification, with multiple components working together to provide extensibility throughout the build process.\n\nThe extension system flow includes the following key stages:\n\n1. **Extension Discovery and Loading**: The process begins in the SphinxComponentRegistry, which discovers extensions through various mechanisms including the extensions list in conf.py, entry points, and direct module imports. The registry loads each extension module and calls its setup function.\n\n2. **Component Registration**: During extension setup, extensions register their components (directives, roles, builders, domains, etc.) with the SphinxComponentRegistry. This registration process makes the components available for use throughout the build process.\n\n3. **Event System Integration**: Extensions connect to Sphinx's event system by registering event handlers with the EventManager. These handlers are called at specific points during the build process, such as 'config-inited', 'builder-inited', 'doctree-read', and 'doctree-resolved'.\n\n4. **Build Phase Integration**: The extension system integrates with Sphinx's multi-phase build process. Extensions can hook into different phases (initialization, reading, resolving, writing) by connecting to appropriate events and implementing the necessary callback functions.\n\n5. **Document Processing Hooks**: During document processing, extensions can modify document trees, add custom nodes, process cross-references, and perform other document modifications through event handlers and custom transforms.\n\n6. **Configuration Integration**: Extensions can add configuration options to the Config system, allowing users to customize extension behavior through conf.py settings.\n\n7. **Output Generation Integration**: Extensions can modify the output generation process by registering custom builders, writers, or by modifying the output through post-processing hooks.\n\n8. **Environment Integration**: Extensions can store and retrieve data from the BuildEnvironment, allowing them to maintain state across the build process and implement features like caching and incremental builds.\n\nThis flow is managed by the main Sphinx application, which coordinates the extension system with the core build process, ensuring that extensions are properly initialized and their hooks are executed at the appropriate times during the build.", "score": null, "retrieved_content": [{"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".debug(\n            '[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter\n        )\n        if node in self.enumerable_nodes and not override:\n            raise ExtensionError(__('enumerable_node %r already registered') % node)\n        self.enumerable_nodes[node] = (figtype, title_getter)\n\n    def add_html_math_renderer(\n        self,\n        name: str,\n        inline_renderers: _MathsInlineRenderers | None,\n        block_renderers: _MathsBlockRenderers | None,\n    ) -> None:\n        logger.debug(\n            '[app] adding html_math_renderer: %s, %r, %r',\n            name,\n            inline_renderers,\n            block_renderers,\n        )\n        if name in self.html_inline_math_renderers:\n            raise ExtensionError(__('math renderer %s is already registered') % name)\n\n        if inline_renderers is not None:\n            self.html_inline_math_renderers[name] = inline_renderers\n        if block_renderers is not None:\n            self.html_block_math_renderers[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + tra"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + traceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot b"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/napoleon", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n self._config_values:\n            setattr(self, name, default)\n        for name, value in settings.items():\n            setattr(self, name, value)\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    \"\"\"Sphinx extension setup function.\n\n    When the extension is loaded, Sphinx imports this module and executes\n    the ``setup()`` function, which in turn notifies Sphinx of everything\n    the extension offers.\n\n    Parameters\n    ----------\n    app : sphinx.application.Sphinx\n        Application object representing the Sphinx process\n\n    See Also\n    --------\n    `The Sphinx documentation on Extensions\n    <https://www.sphinx-doc.org/extensions.html>`_\n\n    `The Extension Tutorial <https://www.sphinx-doc.org/extdev/tutorial.html>`_\n\n    `The Extension API <https://www.sphinx-doc.org/extdev/appapi.html>`_\n\n    \"\"\"\n    if not isinstance(app, Sphinx):\n        # probably called by tests\n        return {\n            'version': sphinx.__display_version__,\n            'parallel_read_safe': True,\n        }\n\n    _patch_python_domain()\n\n    app.setup_extension('sphinx.ext.autodoc')\n    app.connect('autodoc-process-docstring', _process_docstring)\n    app.connect('autodoc-skip-member', _skip_member)\n\n    for name, default, rebuild, types in Config._config_values:\n        app.add_config_value(name, default, rebuild, types=types)\n\n    return {\n        'version': sphinx.__display_version__,\n        'parallel_read_safe': True,\n    }\n\n\ndef _patch_python_domain() -> None:\n    from sphinx.domains.python._object import PyObject, PyTypedField\n    from sphinx.locale import _\n\n    for doc_field in PyObject.doc_field_types:\n        if doc_field.name == 'parameter':\n            doc_field.names = ('param', 'parameter', 'arg', 'argument')\n            break\n    PyObject.doc_field_types.append(\n        PyTypedField(\n            'keyword',\n            label=_('Keyword Arguments'),\n            names=('keyword', 'kwarg', 'kwparam'),\n            typerolename='class',\n            typenames=('paramtype'"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode == 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot be built with this '\n                            'version.'\n                        )\n                        % (extname, err),\n                    ) from err\n\n            if metadata is None:\n                metadata = {}\n            elif not isinstance(metadata, dict):\n                logger.warning(\n                    __(\n                        'extension %r returned an unsupported object from '\n                        'its setup() function; it should return None or a '\n                        'metadata dictionary'\n                    ),\n                    extname,\n                )\n                metadata = {}\n\n            app.extensions[extname] = Extension(extname, mod, **metadata)\n\n    def get_envversion(self, app: Sphinx) -> Mapping[str, int]:\n        from sphinx.environment import _get_env_version\n\n        return _get_env_version(app.extensions)\n\n\ndef merge_source_suffix(app: Sphinx, config: Config) -> None:\n    \"\"\"Merge any user-specified source_suffix with any added by ex"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ]"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute"}], "retrieved_count": 10, "cost_time": 1.1250977516174316}
{"question": "Where in the Sphinx codebase is the core document processor implemented?", "answer": null, "relative_code_list": null, "ground_truth": "The core document processor in Sphinx is implemented across several key modules and classes that work together to handle document parsing, transformation, and processing. The main components are distributed throughout the codebase to provide modularity and extensibility.\n\nKey locations where the core document processor is implemented include:\n\n1. **sphinx/application.py**: The main Sphinx application class orchestrates the overall document processing workflow, coordinating between different components and managing the build process phases.\n\n2. **sphinx/builders/__init__.py**: The Builder base class implements the core document reading and writing logic, including methods like `read_doc()`, `write_doc()`, and the overall build workflow.\n\n3. **sphinx/environment/__init__.py**: The BuildEnvironment class manages document state, cross-references, and metadata throughout the build process, providing the data store for document processing.\n\n4. **sphinx/transforms/__init__.py**: The SphinxTransformer class and various transform implementations handle document tree modifications, including cross-reference resolution and other document transformations.\n\n5. **sphinx/parsers.py**: Contains parser implementations for different input formats, including reStructuredText and Markdown parsers that convert source text into docutils document trees.\n\n6. **sphinx/domains/__init__.py**: The Domain class and domain implementations provide specialized document processing for different types of documentation (Python, C++, etc.).\n\n7. **sphinx/registry.py**: The SphinxComponentRegistry manages all the components involved in document processing, including parsers, transforms, and other extensible elements.\n\n8. **sphinx/util/docutils.py**: Contains utility functions and classes that integrate with Docutils for document processing, including the SphinxRole and SphinxDirective base classes.\n\nThe document processor is designed as a modular system where different components handle specific aspects of document processing, allowing for extensibility and customization while maintaining a consistent overall architecture.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}, {"start_line": 3000, "end_line": 4540, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gs = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n    warnings.warn(\n        'sphinx.io.SphinxDummySourceClass is deprecated',\n        RemovedInSphinx10Warning,\n        stacklevel=2,\n    )\n    return source\n\n\nclass SphinxFileInput(FileInput):\n    \"\"\"A basic FileInput for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        kwargs['error_handler'] = 'sphinx'\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxFileInput is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "index.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ntries', {})\n\n    def clear_doc(self, docname: str) -> None:\n        self.entries.pop(docname, None)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        for docname in docnames:\n            self.entries[docname] = otherdata['entries'][docname]\n\n    def process_doc(self, env: BuildEnvironment, docname: str, document: Node) -> None:\n        \"\"\"Process a document after it is read by the environment.\"\"\"\n        entries = self.entries.setdefault(env.current_document.docname, [])\n        for node in list(document.findall(addnodes.index)):\n            node_entries = node['entries']\n            try:\n                for entry_type, value, _target_id, _main, _category_key in node_entries:\n                    split_index_msg(entry_type, value)\n            except ValueError as exc:\n                logger.warning(str(exc), location=node, type='index')\n                node.parent.remove(node)\n            else:\n                for entry in node_entries:\n                    entries.append(entry)\n\n\nclass IndexDirective(SphinxDirective):\n    \"\"\"Directive to add entries to the index.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec: ClassVar[OptionSpec] = {\n        'name': directives.unchanged,\n    }\n\n    def run(self) -> list[Node]:\n        arguments = self.arguments[0].split('\\n')\n\n        if 'name' in self.options:\n            targetname = self.options['name']\n            targetnode = nodes.target('', '', names=[targetname])\n        else:\n            targetid = 'index-%s' % self.env.new_serialno('index')\n            targetnode = nodes.target('', '', ids=[targetid])\n\n        self.state.document.note_explicit_target(targetnode)\n        indexnode = addnodes.index()\n        indexnode['entries'] = []\n        indexnode['inline'] = False\n        self.set_source_info(indexnode)\n        for entry in arguments:\n            indexnode['entries'].extend(\n            "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "oads(otherenv)\n            self.env.merge_info_from(docs, env, self._app)\n\n            next(progress)\n\n        tasks = ParallelTasks(nproc)\n        for chunk in chunks:\n            tasks.add_task(read_process, chunk, merge)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    @final\n    def read_doc(self, docname: str, *, _cache: bool = True) -> None:\n        \"\"\"Parse a file and add/update inventory entries for the doctree.\"\"\"\n        env = self.env\n        env.prepare_settings(docname)\n\n        # Add confdir/docutils.conf to dependencies list if exists\n        docutils_conf = self.confdir / 'docutils.conf'\n        if docutils_conf.is_file():\n            env.note_dependency(docutils_conf)\n\n        filename = env.doc2path(docname)\n\n        # set up error_handler for the target document\n        # xref RemovedInSphinx90Warning\n        error_handler = _UnicodeDecodeErrorHandler(docname)\n        codecs.register_error('sphinx', error_handler)  # type: ignore[arg-type]\n\n        # read the source file\n        content = filename.read_text(\n            encoding=env.settings['input_encoding'], errors='sphinx'\n        )\n\n        # TODO: move the \"source-read\" event to here.\n\n        filetype = get_filetype(self.config.source_suffix, filename)\n        parser = self._registry.create_source_parser(\n            filetype, config=self.config, env=env\n        )\n        doctree = _parse_str_to_doctree(\n            content,\n            filename=filename,\n            default_role=self.config.default_role,\n            default_settings=env.settings,\n            env=env,\n            events=self.events,\n            parser=parser,\n            transforms=self._registry.get_transforms(),\n        )\n\n        # store time of reading, for outdated files detection\n        env.all_docs[docname] = time.time_ns() // 1_000\n\n        # cleanup\n        env.current_document = _CurrentDocument()\n        env.ref_context.clear()\n\n        self.write_doctree(docname, d"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "('clear_doc end: %s', docname)\n\n    def process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('process_doc: %s', docname)\n            logger.debug(self.data['root_symbol'].dump(0))\n            logger.debug('process_doc end: %s', docname)\n\n    def process_field_xref(self, pnode: pending_xref) -> None:\n        pnode.attributes.update(self.env.ref_context)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('merge_domaindata:')\n            logger.debug('\\tself:')\n            logger.debug(self.data['root_symbol'].dump(1))\n            logger.debug('\\tself end')\n            logger.debug('\\tother:')\n            logger.debug(otherdata['root_symbol'].dump(1))\n            logger.debug('\\tother end')\n            logger.debug('merge_domaindata end')\n\n        self.data['root_symbol'].merge_with(\n            otherdata['root_symbol'], docnames, self.env\n        )\n        our_objects = self.data['objects']\n        for fullname, (fn, id_, objtype) in otherdata['objects'].items():\n            if fn in docnames:\n                if fullname not in our_objects:\n                    our_objects[fullname] = (fn, id_, objtype)\n                # no need to warn on duplicates, the symbol merge already does that\n\n    def _resolve_xref_inner(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> tuple[nodes.reference, str] | tuple[None, None]:\n        parser = DefinitionParser(target, location=node, config=env.config)\n        try:\n            name = parser.parse_xref_object()\n        except DefinitionError as e:\n            logger.warning(\n                'Unparseable C cross-reference: %r\\n%s', target, e, location=node\n            )\n            ret"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "x.\n\n    This replaces reporter by Sphinx's on generating document.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxBaseReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    transforms: list[type[Transform]] = []\n\n    def get_transforms(self) -> list[type[Transform]]:\n        transforms = super().get_transforms() + self.transforms\n\n        # remove transforms which is not needed for Sphinx\n        unused = [DanglingReferences]\n        for transform in unused:\n            if transform in transforms:\n                transforms.remove(transform)\n\n        return transforms\n\n    def new_document(self) -> nodes.document:\n        \"\"\"Creates a new document object which has a special reporter object good\n        for logging.\n        \"\"\"\n        document = super().new_document()\n\n        # substitute transformer\n        document.transformer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settin"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docuti"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/cpp", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d')\n            logger.debug('clear_doc end: %s', docname)\n        for name, n_docname in list(self.data['names'].items()):\n            if n_docname == docname:\n                del self.data['names'][name]\n\n    def process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('process_doc: %s', docname)\n            logger.debug(self.data['root_symbol'].dump(0))\n            logger.debug('process_doc end: %s', docname)\n\n    def process_field_xref(self, pnode: pending_xref) -> None:\n        pnode.attributes.update(self.env.ref_context)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('merge_domaindata:')\n            logger.debug('\\tself:')\n            logger.debug(self.data['root_symbol'].dump(1))\n            logger.debug('\\tself end')\n            logger.debug('\\tother:')\n            logger.debug(otherdata['root_symbol'].dump(1))\n            logger.debug('\\tother end')\n\n        self.data['root_symbol'].merge_with(\n            otherdata['root_symbol'], docnames, self.env\n        )\n        our_names = self.data['names']\n        for name, docname in otherdata['names'].items():\n            if docname in docnames:\n                if name not in our_names:\n                    our_names[name] = docname\n                # no need to warn on duplicates, the symbol merge already does that\n        if Symbol.debug_show_tree:\n            logger.debug('\\tresult:')\n            logger.debug(self.data['root_symbol'].dump(1))\n            logger.debug('\\tresult end')\n            logger.debug('merge_domaindata end')\n\n    def _check_type(self, typ: str, decl_typ: str) -> bool:\n        if typ == 'any':\n            return True\n        objtypes = self.objtypes_for_role(typ)\n        if objtypes:\n            return decl_typ in objtypes\n        logger.debug(f'Type is {typ}, declaration type is {decl"}], "retrieved_count": 10, "cost_time": 1.12471604347229}
{"question": "Where does Sphinx store its extension implementations?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx stores its extension implementations in several locations within the codebase, organized by functionality and type. The extension system is designed to be modular and extensible, with built-in extensions distributed throughout the codebase.\n\nKey locations where Sphinx stores extension implementations include:\n\n1. **sphinx/ext/**: This directory contains many of Sphinx's built-in extensions, including autodoc, autosummary, doctest, intersphinx, and others. Each extension is typically implemented as a separate module or package within this directory.\n\n2. **sphinx/domains/**: Domain-specific extensions are stored in this directory, including implementations for Python (py), C++ (cpp), C (c), JavaScript (js), and other programming language domains. Each domain provides specialized functionality for documenting code in that language.\n\n3. **sphinx/directives/**: Built-in directive implementations are stored here, including general-purpose directives like admonitions, code blocks, and other document structure elements.\n\n4. **sphinx/roles.py**: Built-in role implementations are stored in this file, including cross-reference roles, formatting roles, and other inline markup elements.\n\n5. **sphinx/builders/**: Builder implementations for different output formats (HTML, LaTeX, PDF, etc.) are stored in this directory, with each builder providing functionality for generating documentation in a specific format.\n\n6. **sphinx/transforms/**: Transform implementations that modify document trees during processing are stored here, including transforms for cross-reference resolution, indexing, and other document modifications.\n\n7. **sphinx/themes/**: Theme implementations for customizing the appearance of generated documentation are stored in this directory.\n\n8. **sphinx/writers/**: Writer implementations for different output formats are stored here, providing the actual output generation logic for each format.\n\nThe extension system also supports external extensions that can be installed separately and loaded through the extensions configuration in conf.py. These external extensions are typically distributed as separate Python packages and can be installed via pip or other package managers.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ext.todo import todo_node\n    from sphinx.extension import Extension\n    from sphinx.registry import (\n        _MathsBlockRenderers,\n        _MathsInlineRenderers,\n        _NodeHandler,\n        _NodeHandlerPair,\n    )\n    from sphinx.roles import XRefRole\n    from sphinx.search import SearchLanguage\n    from sphinx.theming import Theme\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import RoleFunction, TitleGetter\n\n\nbuiltin_extensions: tuple[str, ...] = (\n    'sphinx.addnodes',\n    'sphinx.builders.changes',\n    'sphinx.builders.epub3',\n    'sphinx.builders.dirhtml',\n    'sphinx.builders.dummy',\n    'sphinx.builders.gettext',\n    'sphinx.builders.html',\n    'sphinx.builders.latex',\n    'sphinx.builders.linkcheck',\n    'sphinx.builders.manpage',\n    'sphinx.builders.singlehtml',\n    'sphinx.builders.texinfo',\n    'sphinx.builders.text',\n    'sphinx.builders.xml',\n    'sphinx.config',\n    'sphinx.domains.c',\n    'sphinx.domains.changeset',\n    'sphinx.domains.citation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environme"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tuple of filename and attributes\n        self.css_files: list[tuple[str, dict[str, Any]]] = []\n\n        #: domains; a dict of domain name -> domain class\n        self.domains: dict[str, type[Domain]] = {}\n\n        #: additional directives for domains\n        #: a dict of domain name -> dict of directive name -> directive\n        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}\n\n        #: additional indices for domains\n        #: a dict of domain name -> list of index class\n        self.domain_indices: dict[str, list[type[Index]]] = {}\n\n        #: additional object types for domains\n        #: a dict of domain name -> dict of objtype name -> objtype\n        self.domain_object_types: dict[str, dict[str, ObjType]] = {}\n\n        #: additional roles for domains\n        #: a dict of domain name -> dict of role name -> role impl.\n        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}\n\n        #: additional enumerable nodes\n        #: a dict of node class"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + traceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot b"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot be built with this '\n                            'version.'\n                        )\n                        % (extname, err),\n                    ) from err\n\n            if metadata is None:\n                metadata = {}\n            elif not isinstance(metadata, dict):\n                logger.warning(\n                    __(\n                        'extension %r returned an unsupported object from '\n                        'its setup() function; it should return None or a '\n                        'metadata dictionary'\n                    ),\n                    extname,\n                )\n                metadata = {}\n\n            app.extensions[extname] = Extension(extname, mod, **metadata)\n\n    def get_envversion(self, app: Sphinx) -> Mapping[str, int]:\n        from sphinx.environment import _get_env_version\n\n        return _get_env_version(app.extensions)\n\n\ndef merge_source_suffix(app: Sphinx, config: Config) -> None:\n    \"\"\"Merge any user-specified source_suffix with any added by ex"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".debug(\n            '[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter\n        )\n        if node in self.enumerable_nodes and not override:\n            raise ExtensionError(__('enumerable_node %r already registered') % node)\n        self.enumerable_nodes[node] = (figtype, title_getter)\n\n    def add_html_math_renderer(\n        self,\n        name: str,\n        inline_renderers: _MathsInlineRenderers | None,\n        block_renderers: _MathsBlockRenderers | None,\n    ) -> None:\n        logger.debug(\n            '[app] adding html_math_renderer: %s, %r, %r',\n            name,\n            inline_renderers,\n            block_renderers,\n        )\n        if name in self.html_inline_math_renderers:\n            raise ExtensionError(__('math renderer %s is already registered') % name)\n\n        if inline_renderers is not None:\n            self.html_inline_math_renderers[name] = inline_renderers\n        if block_renderers is not None:\n            self.html_block_math_renderers[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + tra"}, {"start_line": 0, "end_line": 36, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-html_signaturereturn_icon", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "extensions = ['sphinx.ext.autodoc']\n"}, {"start_line": 0, "end_line": 40, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-ext-intersphinx-cppdomain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "extensions = ['sphinx.ext.intersphinx']\n"}, {"start_line": 0, "end_line": 36, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-trim_doctest_flags", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "extensions = ['sphinx.ext.doctest']\n"}], "retrieved_count": 10, "cost_time": 1.1792371273040771}
{"question": "Where does Sphinx implement its theme system?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements its theme system across several modules and directories within the codebase, providing a flexible and extensible system for customizing the appearance of generated documentation. The theme system is designed to support both built-in and custom themes.\n\nKey locations where Sphinx's theme system is implemented include:\n\n1. **sphinx/theming.py**: Contains the core theme system implementation, including the Theme class that manages theme loading, configuration, and template resolution. This module provides the foundation for the entire theme system.\n\n2. **sphinx/themes/**: This directory contains built-in theme implementations, including themes like 'alabaster' (the default theme), 'classic', 'sphinxdoc', and others. Each theme is typically implemented as a separate directory with its own templates and static files.\n\n3. **sphinx/themes/basic/**: Contains the basic theme that serves as a foundation for other themes, providing core templates and styling that can be extended or overridden by specific themes.\n\n4. **sphinx/themes/alabaster/**: Contains the default Alabaster theme implementation, including HTML templates, CSS stylesheets, and other static assets.\n\n5. **sphinx/themes/classic/**: Contains the classic theme implementation, providing an alternative styling option for Sphinx documentation.\n\n6. **sphinx/themes/sphinxdoc/**: Contains the sphinxdoc theme implementation, which was the original Sphinx theme.\n\n7. **sphinx/builders/html.py**: The HTML builder integrates with the theme system to apply themes during HTML generation, using theme templates and static files to create the final output.\n\n8. **sphinx/builders/html/**: Contains HTML-specific builder implementations that work with the theme system to generate themed HTML output.\n\n9. **sphinx/util/template.py**: Contains utility functions for template processing, including Jinja2 template engine integration that the theme system uses for template rendering.\n\n10. **sphinx/config.py**: Contains configuration options for theme settings, allowing users to specify themes and theme-specific options in their conf.py files.\n\nThe theme system supports both built-in themes that are distributed with Sphinx and external themes that can be installed separately as Python packages. Themes can customize HTML templates, CSS styles, JavaScript, and other static assets to create unique documentation appearances.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        confdir: Path,\n        app: Sphinx,\n        config: Config,\n        registry: SphinxComponentRegistry,\n    ) -> None:\n        self._app = app\n        self._confdir = confdir\n        self._themes = registry.html_themes\n        self._entry_point_themes: dict[str, Callable[[], None]] = {}\n        self._load_builtin_themes()\n        if html_theme_path := getattr(config, 'html_theme_path', None):\n            self._load_additional_themes(html_theme_path)\n        self._load_entry_point_themes()\n\n    def _load_builtin_themes(self) -> None:\n        \"\"\"Load built-in themes.\"\"\"\n        themes = self._find_themes(package_dir / 'themes')\n        for name, theme in themes.items():\n            self._themes[name] = _StrPath(theme)\n\n    def _load_additional_themes(self, theme_paths: list[str]) -> None:\n        \"\"\"Load additional themes placed at specified directories.\"\"\"\n        for theme_path in theme_paths:\n            abs_theme_path = (self._confdir / theme_path).resolve()\n            themes = self._find_themes(abs_theme_path)\n            for name, theme in themes.items():\n                self._themes[name] = _StrPath(theme)\n\n    def _load_entry_point_themes(self) -> None:\n        \"\"\"Try to load a theme with the specified name.\n\n        This uses the ``sphinx.html_themes`` entry point from package metadata.\n        \"\"\"\n        for entry_point in entry_points(group='sphinx.html_themes'):\n            if entry_point.name in self._themes:\n                continue  # don't overwrite loaded themes\n\n            def _load_theme_closure(\n                # bind variables in the function definition\n                app: Sphinx = self._app,\n                theme_module: str = entry_point.module,\n            ) -> None:\n                app.setup_extension(theme_module)\n                _config_post_init(app, app.config)\n\n            self._entry_point_themes[entry_point.name] = _load_theme_closure\n\n    @staticmethod\n    def _find_themes(theme_path: Path) -> dict[str, Path]:\n        \"\"\"Sea"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "fig.html_style\n        elif self.config.html_style is not None:\n            yield from self.config.html_style\n        elif self.theme:\n            yield from self.theme.stylesheets\n        else:\n            yield 'default.css'\n\n    def get_theme_config(self) -> tuple[str, dict[str, str | int | bool]]:\n        return self.config.html_theme, self.config.html_theme_options\n\n    def init_templates(self) -> None:\n        theme_factory = HTMLThemeFactory(\n            confdir=self.confdir,\n            app=self._app,\n            config=self.config,\n            registry=self._registry,\n        )\n        theme_name, theme_options = self.get_theme_config()\n        self.theme = theme_factory.create(theme_name)\n        self.theme_options = theme_options\n        self.create_template_bridge()\n        self.templates.init(self, self.theme)\n\n    def init_highlighter(self) -> None:\n        # determine Pygments style and create the highlighter\n        if self.config.pygments_style is not None:\n            style = self.config.pygments_style\n        elif self.theme:\n            # From the ``pygments_style`` theme setting\n            style = self.theme.pygments_style_default or 'none'\n        else:\n            style = 'sphinx'\n        self.highlighter = PygmentsBridge('html', style)\n\n        if self.theme:\n            # From the ``pygments_dark_style`` theme setting\n            dark_style = self.theme.pygments_style_dark\n        else:\n            dark_style = None\n\n        self.dark_highlighter: PygmentsBridge | None\n        if dark_style is not None:\n            self.dark_highlighter = PygmentsBridge('html', dark_style)\n        else:\n            self.dark_highlighter = None\n\n    @property\n    def css_files(self) -> list[_CascadingStyleSheet]:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.css_files', remove=(9, 0)\n        )\n        return self._css_files\n\n    def init_css_files(self) -> None:\n        self._css_files = []\n        self.add_css_file('pygment"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Theming support for HTML builders.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ('Theme', 'HTMLThemeFactory')\n\nimport configparser\nimport contextlib\nimport shutil\nimport sys\nimport tempfile\nimport tomllib\nfrom importlib.metadata import entry_points\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom zipfile import ZipFile\n\nfrom sphinx import package_dir\nfrom sphinx.config import check_confval_types as _config_post_init\nfrom sphinx.errors import ThemeError\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import ensuredir\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n    from typing import Any, Required, TypedDict\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.registry import SphinxComponentRegistry\n\n    class _ThemeToml(TypedDict, total=False):\n        theme: Required[_ThemeTomlTheme]\n        options: dict[str, str]\n\n    class _ThemeTomlTheme(TypedDict, total=False):\n        inherit: Required[str]\n        stylesheets: list[str]\n        sidebars: list[str]\n        pygments_style: _ThemeTomlThemePygments\n\n    class _ThemeTomlThemePygments(TypedDict, total=False):\n        default: str\n        dark: str\n\n\nlogger = logging.getLogger(__name__)\n\n_NO_DEFAULT = object()\n_THEME_TOML = 'theme.toml'\n_THEME_CONF = 'theme.conf'\n\n\nclass Theme:\n    \"\"\"A Theme is a set of HTML templates and configurations.\n\n    This class supports both theme directory and theme archive (zipped theme).\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        *,\n        configs: dict[str, _ConfigFile],\n        paths: list[Path],\n        tmp_dirs: list[Path],\n    ) -> None:\n        self.name = name\n        self._dirs = tuple(paths)\n        self._tmp_dirs = tmp_dirs\n\n        options: dict[str, Any] = {}\n        self.stylesheets: tuple[str, ...] = ()\n        self.sidebar_templates: tuple[str, ...] = ()\n        self.pygments_style_default"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_theming", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test the Theme class.\"\"\"\n\nfrom __future__ import annotations\n\nimport shutil\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom xml.etree.ElementTree import ParseError\n\nimport pytest\nfrom defusedxml.ElementTree import parse as xml_parse\n\nimport sphinx.builders.html\nfrom sphinx.builders.html import StandaloneHTMLBuilder\nfrom sphinx.errors import ThemeError\nfrom sphinx.theming import (\n    _ConfigFile,\n    _convert_theme_conf,\n    _convert_theme_toml,\n    _load_theme,\n    _load_theme_conf,\n    _load_theme_toml,\n)\n\nif TYPE_CHECKING:\n    from sphinx.testing.util import SphinxTestApp\n\nHERE = Path(__file__).resolve().parent\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='theming',\n    confoverrides={'html_theme': 'ziptheme', 'html_theme_options.testopt': 'foo'},\n)\ndef test_theme_api(app: SphinxTestApp) -> None:\n    assert isinstance(app.builder, StandaloneHTMLBuilder)  # type-checking\n    themes = [\n        'basic',\n        'default',\n        'scrolls',\n        'agogo',\n        'sphinxdoc',\n        'haiku',\n        'traditional',\n        'epub',\n        'nature',\n        'pyramid',\n        'bizstyle',\n        'classic',\n        'nonav',\n        'test-theme',\n        'ziptheme',\n        'staticfiles',\n        'parent',\n        'child',\n        'alabaster',\n    ]\n\n    # test Theme class API\n    assert set(app.registry.html_themes.keys()) == set(themes)\n    assert app.registry.html_themes['test-theme'] == (\n        app.srcdir / 'test_theme' / 'test-theme'\n    )\n    assert app.registry.html_themes['ziptheme'] == (app.srcdir / 'ziptheme.zip')\n    assert app.registry.html_themes['staticfiles'] == (\n        app.srcdir / 'test_theme' / 'staticfiles'\n    )\n\n    # test Theme instance API\n    theme = app.builder.theme\n    assert theme.name == 'ziptheme'\n    assert len(theme.get_theme_dirs()) == 2\n\n    # direct setting\n    assert theme.get_config('theme', 'stylesheet') == 'custom.css'\n    # inherited setting\n    assert theme.get_config('options', 'nosidebar') == 'false"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = self._find_themes(abs_theme_path)\n            for name, theme in themes.items():\n                self._themes[name] = _StrPath(theme)\n\n    def _load_entry_point_themes(self) -> None:\n        \"\"\"Try to load a theme with the specified name.\n\n        This uses the ``sphinx.html_themes`` entry point from package metadata.\n        \"\"\"\n        for entry_point in entry_points(group='sphinx.html_themes'):\n            if entry_point.name in self._themes:\n                continue  # don't overwrite loaded themes\n\n            def _load_theme_closure(\n                # bind variables in the function definition\n                app: Sphinx = self._app,\n                theme_module: str = entry_point.module,\n            ) -> None:\n                app.setup_extension(theme_module)\n                _config_post_init(app, app.config)\n\n            self._entry_point_themes[entry_point.name] = _load_theme_closure\n\n    @staticmethod\n    def _find_themes(theme_path: Path) -> dict[str, Path]:\n        \"\"\"Search themes from specified directory.\"\"\"\n        themes: dict[str, Path] = {}\n        if not theme_path.is_dir():\n            return themes\n\n        for pathname in theme_path.iterdir():\n            entry = pathname.name\n            if pathname.is_file() and pathname.suffix.lower() == '.zip':\n                if _is_archived_theme(pathname):\n                    themes[pathname.stem] = pathname\n                else:\n                    logger.warning(\n                        __(\n                            'file %r on theme path is not a valid '\n                            'zipfile or contains no theme'\n                        ),\n                        entry,\n                    )\n            else:\n                toml_path = pathname / _THEME_TOML\n                conf_path = pathname / _THEME_CONF\n                if toml_path.is_file() or conf_path.is_file():\n                    themes[entry] = pathname\n\n        return themes\n\n    def create(self, name: str) -> Theme:\n        \"\"\"Create "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "jinja2glue.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " if legacy_template is not None:\n                filename = search_path / legacy_template\n                f = open_if_exists(str(filename))\n                if f is not None:\n                    break\n        else:\n            raise TemplateNotFound(template)\n\n        with f:\n            contents = f.read().decode(self.encoding)\n\n        mtime = _last_modified_time(filename)\n\n        def uptodate() -> bool:\n            try:\n                return _last_modified_time(filename) == mtime\n            except OSError:\n                return False\n\n        return contents, str(filename), uptodate\n\n\nclass BuiltinTemplateLoader(TemplateBridge, BaseLoader):\n    \"\"\"Interfaces the rendering environment of jinja2 for use in Sphinx.\"\"\"\n\n    # TemplateBridge interface\n\n    def init(\n        self,\n        builder: Builder,\n        theme: Theme | None = None,\n        dirs: list[str] | None = None,\n    ) -> None:\n        # create a chain of paths to search\n        if theme:\n            # the theme's own dir and its bases' dirs\n            pathchain = theme.get_theme_dirs()\n            # the loader dirs: pathchain + the parent directories for all themes\n            loaderchain = pathchain + [p.parent for p in pathchain]\n        elif dirs:\n            pathchain = list(map(_StrPath, dirs))\n            loaderchain = list(map(_StrPath, dirs))\n        else:\n            pathchain = []\n            loaderchain = []\n\n        # prepend explicit template paths\n        self.templatepathlen = len(builder.config.templates_path)\n        if builder.config.templates_path:\n            cfg_templates_path = [\n                builder.confdir / tp for tp in builder.config.templates_path\n            ]\n            pathchain[0:0] = cfg_templates_path\n            loaderchain[0:0] = cfg_templates_path\n\n        # store it for use in newest_template_mtime\n        self.pathchain = pathchain\n\n        # make the paths into loaders\n        self.loaders = [SphinxFileSystemLoader(x) for x in loaderchain]\n\n        use_i1"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   else:\n            self.link_suffix = self.out_suffix\n\n        self.use_index = self.get_builder_config('use_index', 'html')\n\n    def create_build_info(self) -> BuildInfo:\n        return BuildInfo(self.config, self.tags, frozenset({'html'}))\n\n    def _get_translations_js(self) -> Path | None:\n        for dir_ in self.config.locale_dirs:\n            js_file = Path(dir_, self.config.language, 'LC_MESSAGES', 'sphinx.js')\n            if js_file.is_file():\n                return js_file\n\n        js_file = package_dir.joinpath(\n            'locale', self.config.language, 'LC_MESSAGES', 'sphinx.js'\n        )\n        if js_file.is_file():\n            return js_file\n\n        js_file = Path(\n            sys.prefix, 'share', 'sphinx', 'locale', self.config.language, 'sphinx.js'\n        )\n        if js_file.is_file():\n            return js_file\n\n        return None\n\n    def _get_style_filenames(self) -> Iterator[str]:\n        if isinstance(self.config.html_style, str):\n            yield self.config.html_style\n        elif self.config.html_style is not None:\n            yield from self.config.html_style\n        elif self.theme:\n            yield from self.theme.stylesheets\n        else:\n            yield 'default.css'\n\n    def get_theme_config(self) -> tuple[str, dict[str, str | int | bool]]:\n        return self.config.html_theme, self.config.html_theme_options\n\n    def init_templates(self) -> None:\n        theme_factory = HTMLThemeFactory(\n            confdir=self.confdir,\n            app=self._app,\n            config=self.config,\n            registry=self._registry,\n        )\n        theme_name, theme_options = self.get_theme_config()\n        self.theme = theme_factory.create(theme_name)\n        self.theme_options = theme_options\n        self.create_template_bridge()\n        self.templates.init(self, self.theme)\n\n    def init_highlighter(self) -> None:\n        # determine Pygments style and create the highlighter\n        if self.config.pygments_style is not None:\n           "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'setting %s.%s occurs in none of the searched theme configs') % (\n                section,\n                name,\n            )\n            raise ThemeError(msg)\n        return value\n\n    def get_options(self, overrides: dict[str, Any] | None = None) -> dict[str, Any]:\n        \"\"\"Return a dictionary of theme options and their values.\"\"\"\n        if overrides is None:\n            overrides = {}\n\n        options = self._options.copy()\n        for option, value in overrides.items():\n            if option not in options:\n                logger.warning(__('unsupported theme option %r given'), option)\n            else:\n                options[option] = value\n\n        return options\n\n    def _cleanup(self) -> None:\n        \"\"\"Remove temporary directories.\"\"\"\n        for tmp_dir in self._tmp_dirs:\n            with contextlib.suppress(Exception):\n                shutil.rmtree(tmp_dir)\n\n\nclass HTMLThemeFactory:\n    \"\"\"A factory class for HTML Themes.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        confdir: Path,\n        app: Sphinx,\n        config: Config,\n        registry: SphinxComponentRegistry,\n    ) -> None:\n        self._app = app\n        self._confdir = confdir\n        self._themes = registry.html_themes\n        self._entry_point_themes: dict[str, Callable[[], None]] = {}\n        self._load_builtin_themes()\n        if html_theme_path := getattr(config, 'html_theme_path', None):\n            self._load_additional_themes(html_theme_path)\n        self._load_entry_point_themes()\n\n    def _load_builtin_themes(self) -> None:\n        \"\"\"Load built-in themes.\"\"\"\n        themes = self._find_themes(package_dir / 'themes')\n        for name, theme in themes.items():\n            self._themes[name] = _StrPath(theme)\n\n    def _load_additional_themes(self, theme_paths: list[str]) -> None:\n        \"\"\"Load additional themes placed at specified directories.\"\"\"\n        for theme_path in theme_paths:\n            abs_theme_path = (self._confdir / theme_path).resolve()\n            themes"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "jinja2glue.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dir and its bases' dirs\n            pathchain = theme.get_theme_dirs()\n            # the loader dirs: pathchain + the parent directories for all themes\n            loaderchain = pathchain + [p.parent for p in pathchain]\n        elif dirs:\n            pathchain = list(map(_StrPath, dirs))\n            loaderchain = list(map(_StrPath, dirs))\n        else:\n            pathchain = []\n            loaderchain = []\n\n        # prepend explicit template paths\n        self.templatepathlen = len(builder.config.templates_path)\n        if builder.config.templates_path:\n            cfg_templates_path = [\n                builder.confdir / tp for tp in builder.config.templates_path\n            ]\n            pathchain[0:0] = cfg_templates_path\n            loaderchain[0:0] = cfg_templates_path\n\n        # store it for use in newest_template_mtime\n        self.pathchain = pathchain\n\n        # make the paths into loaders\n        self.loaders = [SphinxFileSystemLoader(x) for x in loaderchain]\n\n        use_i18n = builder._translator is not None\n        extensions = ['jinja2.ext.i18n'] if use_i18n else []\n        self.environment = SandboxedEnvironment(loader=self, extensions=extensions)\n        self.environment.filters['tobool'] = _tobool\n        self.environment.filters['toint'] = _toint\n        self.environment.filters['todim'] = _todim\n        self.environment.filters['slice_index'] = _slice_index\n        self.environment.globals['debug'] = pass_context(pformat)\n        self.environment.globals['warning'] = warning\n        self.environment.globals['accesskey'] = pass_context(accesskey)\n        self.environment.globals['idgen'] = idgen\n        if use_i18n:\n            # ``install_gettext_translations`` is injected by the ``jinja2.ext.i18n`` extension\n            self.environment.install_gettext_translations(builder._translator)  # type: ignore[attr-defined]\n\n    def render(self, template: str, context: dict[str, Any]) -> str:  # type: ignore[override]\n        return self.environment.get_"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "theming.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hemeTomlTheme(TypedDict, total=False):\n        inherit: Required[str]\n        stylesheets: list[str]\n        sidebars: list[str]\n        pygments_style: _ThemeTomlThemePygments\n\n    class _ThemeTomlThemePygments(TypedDict, total=False):\n        default: str\n        dark: str\n\n\nlogger = logging.getLogger(__name__)\n\n_NO_DEFAULT = object()\n_THEME_TOML = 'theme.toml'\n_THEME_CONF = 'theme.conf'\n\n\nclass Theme:\n    \"\"\"A Theme is a set of HTML templates and configurations.\n\n    This class supports both theme directory and theme archive (zipped theme).\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        *,\n        configs: dict[str, _ConfigFile],\n        paths: list[Path],\n        tmp_dirs: list[Path],\n    ) -> None:\n        self.name = name\n        self._dirs = tuple(paths)\n        self._tmp_dirs = tmp_dirs\n\n        options: dict[str, Any] = {}\n        self.stylesheets: tuple[str, ...] = ()\n        self.sidebar_templates: tuple[str, ...] = ()\n        self.pygments_style_default: str | None = None\n        self.pygments_style_dark: str | None = None\n        for config in reversed(configs.values()):\n            options |= config.options\n            if config.stylesheets is not None:\n                self.stylesheets = config.stylesheets\n            if config.sidebar_templates is not None:\n                self.sidebar_templates = config.sidebar_templates\n            if config.pygments_style_default is not None:\n                self.pygments_style_default = config.pygments_style_default\n            if config.pygments_style_dark is not None:\n                self.pygments_style_dark = config.pygments_style_dark\n\n        self._options = options\n\n    def get_theme_dirs(self) -> list[_StrPath]:\n        \"\"\"Return a list of theme directories, beginning with this theme's,\n        then the base theme's, then that one's base theme's, etc.\n        \"\"\"\n        return list(map(_StrPath, self._dirs))\n\n    def get_config(self, section: str, name: str, default: Any = _NO_DEFAULT)"}], "retrieved_count": 10, "cost_time": 1.1744413375854492}
{"question": "Where does the control flow when Sphinx's incremental build system determines which documents need to be rebuilt?", "answer": null, "relative_code_list": null, "ground_truth": "The control flow when Sphinx's incremental build system determines which documents need to be rebuilt follows a structured decision-making process: 1) Environment loading phase begins where Sphinx attempts to load the cached BuildEnvironment from the previous build, checking for the existence and validity of the environment pickle file, 2) Change detection phase occurs where the system compares file modification times of source files against the cached environment data to identify which files have been modified since the last build, 3) Configuration change analysis happens where Sphinx checks if the configuration file (conf.py) has been modified and determines what needs to be rebuilt based on which configuration options have changed, 4) Dependency analysis phase begins where the system analyzes the dependency graph stored in the environment to determine which documents are affected by changes to other documents, including both direct and transitive dependencies, 5) Document status evaluation occurs where each document is evaluated to determine if it needs to be rebuilt based on its own changes, dependency changes, or configuration changes, 6) Outdated document identification happens where the get_outdated_docs() method identifies which documents are outdated and need to be rebuilt, considering factors like file modification times, dependency changes, and configuration changes, 7) Build strategy determination occurs where the system decides whether to perform a full rebuild or selective rebuilding based on the scope of changes and the --fresh-env option, 8) Parallel processing coordination happens where the system determines how to distribute the rebuilding work across multiple processes if parallel processing is enabled, 9) Cache validation phase occurs where the system validates the integrity of cached doctree files and determines which cached files can be reused, 10) Error handling and fallback mechanisms are triggered if the incremental build system encounters corrupted cache files or other issues, potentially falling back to a full rebuild, 11) The control flow is coordinated through the builder's build() method which orchestrates the entire incremental build process, 12) The system provides feedback to the user about what is being rebuilt and why, helping users understand the incremental build decisions and optimize their documentation structure.", "score": null, "retrieved_content": [{"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mand line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @final\n    def build(\n        self,\n        docnames: Iterable[str] | None,\n        summary: str | None = None,\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Main build method, usually called by a specific ``build_*`` method.\n\n        First updates the environment, and then calls\n        :meth:`!write`.\n        \"\"\"\n        if summary:\n            logger.info(bold(__('building [%s]: ')) + summary, self.name)  # NoQA: G003\n\n        # while reading, collect all warnings from docutils\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            updated_docnames = set(self.read())\n\n        doccount = len(updated_docnames)\n        logger.info(bold(__('looking for now-outdated files... ')), nonl=True)\n        updated_docnames.update(self.env.check_dependents(self._app, updated_docnames))\n        outdated = len(updated_docnames) - doccount\n        if outdate"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n\n    # if the doctree file is not there, rebuild\n    doctree_path = doctreedir / f'{docname}.doctree'\n    if not doctree_path.is_file():\n        logger.debug('[build target] changed %r: doctree file does not exist', docname)\n        return True\n\n    # check the mtime of the document\n    mtime = all_docs[docname]\n    new_mtime = _last_modified_time(filename)\n    if new_mtime > mtime:\n        logger.debug(\n            '[build target] changed: %r is outdated (%s -> %s)',\n            docname,\n            _format_rfc3339_microseconds(mtime),\n            _format_rfc3339_microseconds(new_mtime),\n        )\n        return True\n\n    # finally, check the mtime of dependencies\n    if docname not in dependencies:\n        return False\n    for dep_path in dependencies[docname]:\n        try:\n            dep_path_is_file = dep_path.is_file()\n        except OSError:\n            return True  # give it another chance\n        if not dep_path_is_file:\n            logger.debug(\n                '[build target] changed: %r is missing dependency %r',\n                docname,\n                dep_path,\n            )\n            return True\n\n        try:\n            dep_mtime = _last_modified_time(dep_path)\n        except OSError:\n            return True  # give it another chance\n        if dep_mtime > mtime:\n            logger.debug(\n                '[build target] changed: %r is outdated due to dependency %r (%s -> %s)',\n                docname,\n                dep_path,\n                _format_rfc3339_microseconds(mtime),\n                _format_rfc3339_microseconds(dep_mtime),\n            )\n            return True\n\n    return False\n\n\ndef _traverse_toctree(\n    traversed: set[str],\n    parent: str | None,\n    docname: str,\n    toctree_includes: dict[str, list[str]],\n) -> Iterator[tuple[str | None, str]]:\n    if parent == docname:\n        logger.warning(\n            __('self referenced toctree found. Ignored.'),\n            location=docname,\n            type='toc',\n            subtype='"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ildinfo.bak'\n                    )\n                    logger.info(bold(__('building [html]: ')) + msg)  # NoQA: G003\n\n                yield from self.env.found_docs\n                return\n\n        if self.templates:\n            template_mtime = int(self.templates.newest_template_mtime() * 10**6)\n            try:\n                old_mtime = _last_modified_time(build_info_path)\n            except Exception:\n                pass\n            else:\n                # Let users know they have a newer template\n                if template_mtime > old_mtime:\n                    logger.info(\n                        bold('building [html]: ')  # NoQA: G003\n                        + __(\n                            'template %s has been changed since the previous build, '\n                            'all docs will be rebuilt'\n                        ),\n                        self.templates.newest_template_name(),\n                    )\n        else:\n            template_mtime = 0\n        for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                logger.debug('[build target] did not in env: %r', docname)\n                yield docname\n                continue\n            target_name = self.get_output_path(docname)\n            try:\n                target_mtime = _last_modified_time(target_name)\n            except OSError:\n                target_mtime = 0\n            try:\n                doc_mtime = _last_modified_time(self.env.doc2path(docname))\n                srcmtime = max(doc_mtime, template_mtime)\n                if srcmtime > target_mtime:\n                    logger.debug(\n                        '[build target] target_name %r(%s), template(%s), docname %r(%s)',\n                        target_name,\n                        _format_rfc3339_microseconds(target_mtime),\n                        _format_rfc3339_microseconds(template_mtime),\n                        docname,\n                        _format_rfc3339_microseconds(doc_mtime),\n     "}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.env.config_status, '') + (\n                self.env.config_status_extra or ''\n            )\n            logger.info('[%s] ', reason, nonl=True)\n\n        logger.info(\n            __('%s added, %s changed, %s removed'),\n            len(added),\n            len(changed),\n            len(removed),\n        )\n\n        # clear all files no longer present\n        for docname in removed:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        # read all new and changed files\n        docnames = sorted(added | changed)\n        # allow changing and reordering the list of docs to read\n        self.events.emit('env-before-read-docs', self.env, docnames)\n\n        # check if we should do parallel or serial read\n        if parallel_available and self._app.parallel > 1:\n            par_ok = self._app.is_parallel_allowed('read')\n        else:\n            par_ok = False\n\n        if par_ok:\n            self._read_parallel(docnames, nproc=self._app.parallel)\n        else:\n            self._read_serial(docnames)\n\n        if self.config.master_doc not in self.env.all_docs:\n            from sphinx.project import EXCLUDE_PATHS\n            from sphinx.util.matching import _translate_pattern\n\n            master_doc_path = self.env.doc2path(self.config.master_doc)\n            master_doc_canon = master_doc_path.as_posix()\n            for pat in EXCLUDE_PATHS:\n                if not re.match(_translate_pattern(pat), master_doc_canon):\n                    continue\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it matches a built-in exclude pattern %r. '\n                    'Please move your master document to a different location.'\n                )\n                raise SphinxError(msg % (master_doc_path, pat))\n            for pat in self.config.exclude_patterns:\n                if not re.match(_translate_pattern(pat), master_doc_canon):\n                  "}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "target] changed: %r is missing dependency %r',\n                docname,\n                dep_path,\n            )\n            return True\n\n        try:\n            dep_mtime = _last_modified_time(dep_path)\n        except OSError:\n            return True  # give it another chance\n        if dep_mtime > mtime:\n            logger.debug(\n                '[build target] changed: %r is outdated due to dependency %r (%s -> %s)',\n                docname,\n                dep_path,\n                _format_rfc3339_microseconds(mtime),\n                _format_rfc3339_microseconds(dep_mtime),\n            )\n            return True\n\n    return False\n\n\ndef _traverse_toctree(\n    traversed: set[str],\n    parent: str | None,\n    docname: str,\n    toctree_includes: dict[str, list[str]],\n) -> Iterator[tuple[str | None, str]]:\n    if parent == docname:\n        logger.warning(\n            __('self referenced toctree found. Ignored.'),\n            location=docname,\n            type='toc',\n            subtype='circular',\n        )\n        return\n\n    # traverse toctree by pre-order\n    yield parent, docname\n    traversed.add(docname)\n\n    for child in toctree_includes.get(docname, ()):\n        for sub_parent, sub_docname in _traverse_toctree(\n            traversed, docname, child, toctree_includes\n        ):\n            if sub_docname not in traversed:\n                yield sub_parent, sub_docname\n                traversed.add(sub_docname)\n\n\ndef _check_toc_parents(toctree_includes: dict[str, list[str]]) -> None:\n    toc_parents: dict[str, list[str]] = {}\n    for parent, children in toctree_includes.items():\n        for child in children:\n            toc_parents.setdefault(child, []).append(parent)\n\n    for doc, parents in sorted(toc_parents.items()):\n        if len(parents) > 1:\n            logger.info(\n                __(\n                    'document is referenced in multiple toctrees: %s, selecting: %s <- %s'\n                ),\n                parents,\n                max(parents),\n      "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ose automatically!\n                return None\n\n    def get_outdated_docs(self) -> Iterator[str]:\n        build_info_path = self.outdir / '.buildinfo'\n        try:\n            build_info = BuildInfo.load(build_info_path)\n        except ValueError as exc:\n            logger.warning(__('Failed to read build info file: %r'), exc)\n        except OSError:\n            # ignore errors on reading\n            pass\n        else:\n            if self.build_info != build_info:\n                # log the mismatch and backup the old build info\n                build_info_backup = build_info_path.with_name('.buildinfo.bak')\n                try:\n                    shutil.move(build_info_path, build_info_backup)\n                    self.build_info.dump(build_info_path)\n                except OSError:\n                    pass  # ignore errors\n                else:\n                    # only log on success\n                    msg = __(\n                        'build_info mismatch, copying .buildinfo to .buildinfo.bak'\n                    )\n                    logger.info(bold(__('building [html]: ')) + msg)  # NoQA: G003\n\n                yield from self.env.found_docs\n                return\n\n        if self.templates:\n            template_mtime = int(self.templates.newest_template_mtime() * 10**6)\n            try:\n                old_mtime = _last_modified_time(build_info_path)\n            except Exception:\n                pass\n            else:\n                # Let users know they have a newer template\n                if template_mtime > old_mtime:\n                    logger.info(\n                        bold('building [html]: ')  # NoQA: G003\n                        + __(\n                            'template %s has been changed since the previous build, '\n                            'all docs will be rebuilt'\n                        ),\n                        self.templates.newest_template_name(),\n                    )\n        else:\n            template_mtime = 0\n        for docname"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d:\n            logger.info(__('%d found'), outdated)\n        else:\n            logger.info(__('none found'))\n\n        if updated_docnames:\n            # save the environment\n            from sphinx.application import ENV_PICKLE_FILENAME\n\n            with (\n                progress_message(__('pickling environment')),\n                open(self.doctreedir / ENV_PICKLE_FILENAME, 'wb') as f,\n            ):\n                pickle.dump(self.env, f, pickle.HIGHEST_PROTOCOL)\n\n            # global actions\n            self.phase = BuildPhase.CONSISTENCY_CHECK\n            with progress_message(__('checking consistency')):\n                self.env.check_consistency()\n        else:\n            if method == 'update' and not docnames:\n                logger.info(bold(__('no targets are out of date.')))\n\n        self.phase = BuildPhase.RESOLVING\n\n        # filter \"docnames\" (list of outdated files) by the updated\n        # found_docs of the environment; this will remove docs that\n        # have since been removed\n        if docnames and docnames != ['__all__']:\n            docnames = set(docnames) & self.env.found_docs\n\n        # determine if we can write in parallel\n        if parallel_available and self._app.parallel > 1 and self.allow_parallel:\n            self.parallel_ok = self._app.is_parallel_allowed('write')\n        else:\n            self.parallel_ok = False\n\n        #  create a task executor to use for misc. \"finish-up\" tasks\n        # if self.parallel_ok:\n        #     self.finish_tasks = ParallelTasks(self._app.parallel)\n        # else:\n        # for now, just execute them serially\n        self.finish_tasks = SerialTasks()\n\n        # write all \"normal\" documents (or everything for some builders)\n        self.write(docnames, updated_docnames, method)\n\n        # finish (write static files etc.)\n        self.finish()\n\n        # wait for all tasks\n        self.finish_tasks.join()\n\n    @final\n    def read(self) -> list[str]:\n        \"\"\"(Re-)read all files new or changed since"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "l\n    def build_specific(self, filenames: Sequence[Path]) -> None:\n        \"\"\"Only rebuild as much as needed for changes in the *filenames*.\"\"\"\n        docnames: list[str] = []\n\n        filenames = [Path(filename).resolve() for filename in filenames]\n        for filename in filenames:\n            if not filename.is_file():\n                logger.warning(\n                    __('file %r given on command line does not exist, '), filename\n                )\n                continue\n\n            if not filename.is_relative_to(self.srcdir):\n                logger.warning(\n                    __(\n                        'file %r given on command line is not under the '\n                        'source directory, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docname = self.env.path2doc(filename)\n            if not docname:\n                logger.warning(\n                    __(\n                        'file %r given on command line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @"}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " in included:\n                    # the document is included from other documents\n                    continue\n                if 'orphan' in self.metadata[docname]:\n                    continue\n                logger.warning(\n                    __(\"document isn't included in any toctree\"),\n                    location=docname,\n                    type='toc',\n                    subtype='not_included',\n                )\n        # Call _check_toc_parents here rather than in  _get_toctree_ancestors()\n        # because that method is called multiple times per document and would\n        # lead to duplicate warnings.\n        _check_toc_parents(self.toctree_includes)\n\n        # call check-consistency for all extensions\n        self.domains._check_consistency()\n        self.events.emit('env-check-consistency', self)\n\n\ndef _get_env_version(extensions: Mapping[str, Extension]) -> Mapping[str, int]:\n    env_version = {\n        ext.name: ext_env_version\n        for ext in extensions.values()\n        if (ext_env_version := ext.metadata.get('env_version'))\n    }\n    env_version['sphinx'] = ENV_VERSION\n    return env_version\n\n\ndef _differing_config_keys(old: Config, new: Config) -> frozenset[str]:\n    \"\"\"Return a set of keys that differ between two config objects.\"\"\"\n    old_vals = {c.name: c.value for c in old}\n    new_vals = {c.name: c.value for c in new}\n    not_in_both = old_vals.keys() ^ new_vals.keys()\n    different_values = {\n        key\n        for key in old_vals.keys() & new_vals.keys()\n        if stable_str(old_vals[key]) != stable_str(new_vals[key])\n    }\n    return frozenset(not_in_both | different_values)\n\n\ndef _has_doc_changed(\n    docname: str,\n    *,\n    filename: Path,\n    reread_always: Set[str],\n    doctreedir: Path,\n    all_docs: Mapping[str, int],\n    dependencies: Mapping[str, Set[Path]],\n) -> bool:\n    # check the \"reread always\" list\n    if docname in reread_always:\n        logger.debug('[build target] changed %r: re-read forced', docname)\n        return"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "for catalog in repo.catalogs:\n            if catalog.domain in domains and catalog.is_outdated():\n                catalogs.add(catalog)\n        message = __('targets for %d po files that are specified') % len(catalogs)\n        self.compile_catalogs(catalogs, message)\n\n    # TODO(stephenfin): This would make more sense as 'compile_outdated_catalogs'\n    def compile_update_catalogs(self) -> None:\n        repo = CatalogRepository(\n            self.srcdir,\n            self.config.locale_dirs,\n            self.config.language,\n            self.config.source_encoding,\n        )\n        catalogs = {c for c in repo.catalogs if c.is_outdated()}\n        message = __('targets for %d po files that are out of date') % len(catalogs)\n        self.compile_catalogs(catalogs, message)\n\n    # build methods\n\n    @final\n    def build_all(self) -> None:\n        \"\"\"Build all source files.\"\"\"\n        self.compile_all_catalogs()\n\n        self.build(None, summary=__('all source files'), method='all')\n\n    @final\n    def build_specific(self, filenames: Sequence[Path]) -> None:\n        \"\"\"Only rebuild as much as needed for changes in the *filenames*.\"\"\"\n        docnames: list[str] = []\n\n        filenames = [Path(filename).resolve() for filename in filenames]\n        for filename in filenames:\n            if not filename.is_file():\n                logger.warning(\n                    __('file %r given on command line does not exist, '), filename\n                )\n                continue\n\n            if not filename.is_relative_to(self.srcdir):\n                logger.warning(\n                    __(\n                        'file %r given on command line is not under the '\n                        'source directory, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docname = self.env.path2doc(filename)\n            if not docname:\n                logger.warning(\n                    __(\n                        'file %r given on com"}], "retrieved_count": 10, "cost_time": 1.1949942111968994}
{"question": "Where in Sphinx is the cross-reference system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's cross-reference system is implemented across multiple components and modules throughout the codebase, with different parts handling various aspects of cross-reference functionality. The system is designed to be extensible and domain-specific.\n\nKey locations where the cross-reference system is implemented include:\n\n1. **sphinx/roles.py**: Contains the XRefRole class and other cross-reference role implementations that handle the creation of cross-reference nodes in documents. This includes the core logic for processing cross-reference markup.\n\n2. **sphinx/domains/__init__.py**: The Domain base class provides the framework for domain-specific cross-reference resolution. Each domain (Python, C++, etc.) implements its own cross-reference logic through the `resolve_xref` method.\n\n3. **sphinx/domains/python.py**: Contains the Python domain implementation with specific cross-reference resolution logic for Python objects like functions, classes, modules, etc.\n\n4. **sphinx/domains/cpp.py**: Contains the C++ domain implementation with cross-reference resolution for C++ objects like classes, functions, namespaces, etc.\n\n5. **sphinx/transforms/__init__.py**: Contains transform implementations that handle cross-reference resolution during the document processing pipeline, including the SphinxTransformer class.\n\n6. **sphinx/transforms/references.py**: Contains specific transforms for handling cross-reference resolution, including the ReferenceResolver transform that processes pending cross-reference nodes.\n\n7. **sphinx/environment/__init__.py**: The BuildEnvironment class manages cross-reference data and metadata, storing information about documented objects that can be referenced across documents.\n\n8. **sphinx/environment/collectors/**: Contains collector implementations that gather cross-reference information during document processing, including the TitleCollector and other metadata collectors.\n\n9. **sphinx/ext/intersphinx/**: Contains the intersphinx extension that enables cross-references between different Sphinx projects.\n\n10. **sphinx/util/docutils.py**: Contains utility functions for cross-reference processing, including the ReferenceRole base class that provides common functionality for cross-reference roles.\n\nThe cross-reference system integrates with Sphinx's event system, allowing extensions to hook into the cross-reference resolution process and add custom cross-reference types or modify existing resolution logic.", "score": null, "retrieved_content": [{"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le(),\n        # links to terms in glossary\n        'term': XRefRole(innernodeclass=nodes.inline, warn_dangling=True),\n        # links to headings or arbitrary labels\n        'ref': XRefRole(\n            lowercase=True, innernodeclass=nodes.inline, warn_dangling=True\n        ),\n        # links to labels of numbered figures, tables and code-blocks\n        'numref': XRefRole(lowercase=True, warn_dangling=True),\n        # links to labels, without a different title\n        'keyword': XRefRole(warn_dangling=True),\n        # links to documents\n        'doc': XRefRole(warn_dangling=True, innernodeclass=nodes.inline),\n    }\n\n    initial_data: Final = {  # type: ignore[misc]\n        'progoptions': {},  # (program, name) -> docname, labelid\n        'objects': {},  # (type, name) -> docname, labelid\n        'labels': {  # labelname -> docname, labelid, sectionname\n            'genindex': ('genindex', '', _('Index')),\n            'modindex': ('py-modindex', '', _('Module Index')),\n            'search': ('search', '', _('Search Page')),\n        },\n        'anonlabels': {  # labelname -> docname, labelid\n            'genindex': ('genindex', ''),\n            'modindex': ('py-modindex', ''),\n            'search': ('search', ''),\n        },\n    }\n\n    # labelname -> docname, sectionname\n    _virtual_doc_names: Final = {\n        'genindex': ('genindex', _('Index')),\n        'modindex': ('py-modindex', _('Module Index')),\n        'search': ('search', _('Search Page')),\n    }\n\n    dangling_warnings = {\n        'term': 'term not in glossary: %(target)r',\n        'numref': 'undefined label: %(target)r',\n        'keyword': 'unknown keyword: %(target)r',\n        'doc': 'unknown document: %(target)r',\n        'option': 'unknown option: %(target)r',\n    }\n\n    # node_class -> (figtype, title_getter)\n    enumerable_nodes = {\n        nodes.figure: ('figure', None),\n        nodes.table: ('table', None),\n        nodes.container: ('code-block', None),\n    }\n\n    def __init__(self, env: BuildEnviro"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            declaration.get_newest_id(),\n            contnode,\n            display_name,\n        ), declaration.objectType\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        return self._resolve_xref_inner(\n            env, fromdocname, builder, typ, target, node, contnode\n        )[0]\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        with logging.suppress_logging():\n            retnode, objtype = self._resolve_xref_inner(\n                env, fromdocname, builder, 'any', target, node, contnode\n            )\n        if retnode:\n            return [('c:' + self.role_for_objtype(objtype), retnode)]\n        return []\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        root_symbol = self.data['root_symbol']\n        for symbol in root_symbol.get_all_symbols():\n            if symbol.declaration is None:\n                continue\n            assert symbol.docname\n            full_nested_name = symbol.get_full_nested_name()\n            name = str(full_nested_name).lstrip('.')\n            dispname = full_nested_name.get_display_string().lstrip('.')\n            object_type = symbol.declaration.objectType\n            docname = symbol.docname\n            newest_id = symbol.declaration.get_newest_id()\n            yield name, dispname, object_type, docname, newest_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(CDomain)\n    app.add_config_value('c_id_attributes', [], 'env', types=frozenset({list, tuple}))\n    app.add_config_value(\n        'c_paren_attributes', [], 'env', types=frozenset({list, tuple})\n    )\n    app.add_config_"}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_class: type[nodes.reference] = nodes.reference,\n        **options: Any,\n    ) -> nodes.reference:\n        newnode = node_class('', '', internal=True, **options)\n        innernode = nodes.inline(sectname, sectname)\n        if innernode.get('classes') is not None:\n            innernode['classes'].append('std')\n            innernode['classes'].append('std-' + rolename)\n        if docname == fromdocname:\n            newnode['refid'] = labelid\n        else:\n            # set more info in contnode; in case the\n            # get_relative_uri call raises NoUri,\n            # the builder will then have to resolve these\n            contnode = pending_xref('')\n            contnode['refdocname'] = docname\n            contnode['refsectname'] = sectname\n            newnode['refuri'] = builder.get_relative_uri(fromdocname, docname)\n            if labelid:\n                newnode['refuri'] += '#' + labelid\n        newnode.append(innernode)\n        return newnode\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if typ == 'ref':\n            resolver = self._resolve_ref_xref\n        elif typ == 'numref':\n            resolver = self._resolve_numref_xref  # type: ignore[assignment]\n        elif typ == 'keyword':\n            resolver = self._resolve_keyword_xref\n        elif typ == 'doc':\n            resolver = self._resolve_doc_xref\n        elif typ == 'option':\n            resolver = self._resolve_option_xref\n        elif typ == 'term':\n            resolver = self._resolve_term_xref\n        else:\n            resolver = self._resolve_obj_xref\n\n        return resolver(env, fromdocname, builder, typ, target, node, contnode)\n\n    def _resolve_ref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if typ == 'ref':\n            resolver = self._resolve_ref_xref\n        elif typ == 'numref':\n            resolver = self._resolve_numref_xref  # type: ignore[assignment]\n        elif typ == 'keyword':\n            resolver = self._resolve_keyword_xref\n        elif typ == 'doc':\n            resolver = self._resolve_doc_xref\n        elif typ == 'option':\n            resolver = self._resolve_option_xref\n        elif typ == 'term':\n            resolver = self._resolve_term_xref\n        else:\n            resolver = self._resolve_obj_xref\n\n        return resolver(env, fromdocname, builder, typ, target, node, contnode)\n\n    def _resolve_ref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if node['refexplicit']:\n            # reference to anonymous label; the reference uses\n            # the supplied link caption\n            docname, labelid = self.anonlabels.get(target, ('', ''))\n            sectname = node.astext()\n        else:\n            # reference to named label; the final node will\n            # contain the section name after the label\n            docname, labelid, sectname = self.labels.get(target, ('', '', ''))\n        if not docname:\n            return None\n\n        return self.build_reference_node(\n            fromdocname, builder, docname, labelid, sectname, 'ref'\n        )\n\n    def _resolve_numref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | Element | None:\n        if target in self.la"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "maxsplit=1)\n                commands.append(subcommand)\n                progname = '-'.join(commands)\n\n                docname, labelid = self.progoptions.get((progname, target), ('', ''))\n                if docname:\n                    break\n            else:\n                return None\n\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def _resolve_term_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        result = self._resolve_obj_xref(\n            env, fromdocname, builder, typ, target, node, contnode\n        )\n        if result:\n            return result\n        else:\n            # fallback to case insensitive match\n            if target.lower() in self._terms:\n                docname, labelid = self._terms[target.lower()]\n                return make_refnode(builder, fromdocname, docname, labelid, contnode)\n            else:\n                return None\n\n    def _resolve_obj_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ) or []\n        for objtype in objtypes:\n            if (objtype, target) in self.objects:\n                docname, labelid = self.objects[objtype, target]\n                break\n        else:\n            docname, labelid = '', ''\n        if not docname:\n            return None\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "rst.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e:\n        # XXX check duplicates\n        for (typ, name), (doc, node_id) in otherdata['objects'].items():\n            if doc in docnames:\n                self.objects[typ, name] = (doc, node_id)\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ)\n        if not objtypes:\n            return None\n        for objtype in objtypes:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                return make_refnode(\n                    builder,\n                    fromdocname,\n                    todocname,\n                    node_id,\n                    contnode,\n                    f'{target} {objtype}',\n                )\n        return None\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results: list[tuple[str, nodes.reference]] = []\n        for objtype in self.object_types:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                results.append((\n                    f'rst:{self.role_for_objtype(objtype)}',\n                    make_refnode(\n                        builder,\n                        fromdocname,\n                        todocname,\n                        node_id,\n                        contnode,\n                        f'{target} {objtype}',\n                    ),\n                ))\n        return results\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        for (typ, name), (docname, node_id) in self.data['objects'].items():\n  "}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "', node.children[0])\n                if isinstance(node, nodes.term | nodes.field_name):\n                    sectname = clean_astext(node)\n                else:\n                    toctree = next(node.findall(addnodes.toctree), None)\n                    if toctree and toctree.get('caption'):\n                        sectname = toctree['caption']\n                    else:\n                        # anonymous-only labels\n                        continue\n            self.labels[name] = docname, labelid, sectname\n\n    def add_program_option(\n        self, program: str | None, name: str, docname: str, labelid: str\n    ) -> None:\n        # prefer first command option entry\n        if (program, name) not in self.progoptions:\n            self.progoptions[program, name] = (docname, labelid)\n\n    def build_reference_node(\n        self,\n        fromdocname: str,\n        builder: Builder,\n        docname: str,\n        labelid: str,\n        sectname: str,\n        rolename: str,\n        *,\n        node_class: type[nodes.reference] = nodes.reference,\n        **options: Any,\n    ) -> nodes.reference:\n        newnode = node_class('', '', internal=True, **options)\n        innernode = nodes.inline(sectname, sectname)\n        if innernode.get('classes') is not None:\n            innernode['classes'].append('std')\n            innernode['classes'].append('std-' + rolename)\n        if docname == fromdocname:\n            newnode['refid'] = labelid\n        else:\n            # set more info in contnode; in case the\n            # get_relative_uri call raises NoUri,\n            # the builder will then have to resolve these\n            contnode = pending_xref('')\n            contnode['refdocname'] = docname\n            contnode['refsectname'] = sectname\n            newnode['refuri'] = builder.get_relative_uri(fromdocname, docname)\n            if labelid:\n                newnode['refuri'] += '#' + labelid\n        newnode.append(innernode)\n        return newnode\n\n    def resolve_xref(\n        self,\n"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "KeyError as exc:\n            logger.warning(\n                __('invalid numfig_format: %s (%r)'), title, exc, location=node\n            )\n            return contnode\n        except TypeError:\n            logger.warning(__('invalid numfig_format: %s'), title, location=node)\n            return contnode\n\n        return self.build_reference_node(\n            fromdocname,\n            builder,\n            docname,\n            labelid,\n            newtitle,\n            'numref',\n            node_class=addnodes.number_reference,\n            title=title,\n        )\n\n    def _resolve_keyword_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        # keywords are oddballs: they are referenced by named labels\n        docname, labelid, _ = self.labels.get(target, ('', '', ''))\n        if not docname:\n            return None\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def _resolve_doc_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        # directly reference to document by source name; can be absolute or relative\n        refdoc = node.get('refdoc', fromdocname)\n        docname = docname_join(refdoc, node['reftarget'])\n        if docname not in env.all_docs:\n            return None\n        else:\n            if node['refexplicit']:\n                # reference with explicit title\n                caption = node.astext()\n            else:\n                caption = clean_astext(env.titles[docname])\n            innernode = nodes.inline(caption, caption, classes=['doc'])\n            return make_refnode(builder, fromdocname, docname, None, innernode)\n\n    def _resolve_option_xref(\n        sel"}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            otherdata['root_symbol'], docnames, self.env\n        )\n        our_objects = self.data['objects']\n        for fullname, (fn, id_, objtype) in otherdata['objects'].items():\n            if fn in docnames:\n                if fullname not in our_objects:\n                    our_objects[fullname] = (fn, id_, objtype)\n                # no need to warn on duplicates, the symbol merge already does that\n\n    def _resolve_xref_inner(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> tuple[nodes.reference, str] | tuple[None, None]:\n        parser = DefinitionParser(target, location=node, config=env.config)\n        try:\n            name = parser.parse_xref_object()\n        except DefinitionError as e:\n            logger.warning(\n                'Unparseable C cross-reference: %r\\n%s', target, e, location=node\n            )\n            return None, None\n        parent_key: LookupKey | None = node.get('c:parent_key', None)\n        root_symbol = self.data['root_symbol']\n        if parent_key:\n            parent_symbol: Symbol = root_symbol.direct_lookup(parent_key)\n            if not parent_symbol:\n                logger.debug('Target: %s', target)\n                logger.debug('ParentKey: %s', parent_key)\n                logger.debug(root_symbol.dump(1))\n            assert parent_symbol  # should be there\n        else:\n            parent_symbol = root_symbol\n        s = parent_symbol.find_declaration(\n            name, typ, matchSelf=True, recurseInAnon=True\n        )\n        if s is None or s.declaration is None:\n            return None, None\n\n        # TODO: check role type vs. object type\n\n        declaration = s.declaration\n        display_name = name.get_display_string()\n        docname = s.docname\n        assert docname\n\n        return make_refnode(\n            builder,\n            fromdocname,\n            docname,\n"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "('clear_doc end: %s', docname)\n\n    def process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('process_doc: %s', docname)\n            logger.debug(self.data['root_symbol'].dump(0))\n            logger.debug('process_doc end: %s', docname)\n\n    def process_field_xref(self, pnode: pending_xref) -> None:\n        pnode.attributes.update(self.env.ref_context)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('merge_domaindata:')\n            logger.debug('\\tself:')\n            logger.debug(self.data['root_symbol'].dump(1))\n            logger.debug('\\tself end')\n            logger.debug('\\tother:')\n            logger.debug(otherdata['root_symbol'].dump(1))\n            logger.debug('\\tother end')\n            logger.debug('merge_domaindata end')\n\n        self.data['root_symbol'].merge_with(\n            otherdata['root_symbol'], docnames, self.env\n        )\n        our_objects = self.data['objects']\n        for fullname, (fn, id_, objtype) in otherdata['objects'].items():\n            if fn in docnames:\n                if fullname not in our_objects:\n                    our_objects[fullname] = (fn, id_, objtype)\n                # no need to warn on duplicates, the symbol merge already does that\n\n    def _resolve_xref_inner(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> tuple[nodes.reference, str] | tuple[None, None]:\n        parser = DefinitionParser(target, location=node, config=env.config)\n        try:\n            name = parser.parse_xref_object()\n        except DefinitionError as e:\n            logger.warning(\n                'Unparseable C cross-reference: %r\\n%s', target, e, location=node\n            )\n            ret"}], "retrieved_count": 10, "cost_time": 1.2175438404083252}
{"question": "Where does the data flow when Sphinx processes cross-references from role resolution through target lookup to link generation?", "answer": null, "relative_code_list": null, "ground_truth": "The data flow when Sphinx processes cross-references follows a structured sequence from role resolution through target lookup to link generation: 1) Role resolution phase begins when the parser encounters cross-reference roles (like `:py:func:`, `:ref:`, `:doc:`) in the markup, which are processed by the role system to create reference nodes in the document tree, 2) Reference node creation occurs where the role system creates docutils reference nodes containing the reference target, role type, and other metadata, storing this information in the document tree during the parsing phase, 3) Environment data collection happens during the reading phase where domains collect information about all documented objects and store it in the BuildEnvironment's domaindata, including object names, locations, and cross-reference metadata, 4) Target lookup phase occurs during the resolving phase where the cross-reference system searches the environment data to find matching target objects based on the reference information stored in the reference nodes, 5) Domain-specific resolution happens through each domain's resolve_xref method, which implements domain-specific logic for finding and validating target objects within that domain, 6) Cross-reference validation occurs where the system verifies that the target object exists and is accessible, handling cases where targets are missing or ambiguous, 7) Link generation phase begins where the resolved cross-reference information is used to generate appropriate links in the output format, with the builder determining the target URI and link format, 8) Output-specific processing happens where the writer generates the actual link markup (HTML, LaTeX, etc.) based on the resolved cross-reference data and the target format, 9) Error handling occurs throughout the process where broken references are handled gracefully with appropriate error messages and fallback behavior, 10) The entire data flow is coordinated through Sphinx's event system, with events like 'doctree-resolved' marking the completion of cross-reference resolution, 11) Caching mechanisms store resolved cross-reference data in the environment to support incremental builds and improve performance, 12) The data flow ensures that cross-references are accurately resolved and properly linked while maintaining the flexibility and extensibility of the cross-reference system.", "score": null, "retrieved_content": [{"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "= re.compile(r'(\\+([^:]+))?:(.*)')\n\n    def __init__(self, orig_name: str) -> None:\n        self.orig_name = orig_name\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        assert self.name == self.orig_name.lower()\n        inventory, name_suffix = self.get_inventory_and_name_suffix(self.orig_name)\n        resolve_self = self.env.config.intersphinx_resolve_self\n        self_referential = bool(resolve_self) and resolve_self == inventory\n\n        if not self_referential:\n            if inventory and not inventory_exists(self.env, inventory):\n                self._emit_warning(\n                    __('inventory for external cross-reference not found: %r'),\n                    inventory,\n                )\n                return [], []\n\n        domain_name, role_name = self._get_domain_role(name_suffix)\n\n        if role_name is None:\n            self._emit_warning(\n                __('invalid external cross-reference suffix: %r'), name_suffix\n            )\n            return [], []\n\n        # attempt to find a matching role function\n        role_func: RoleFunction | None\n\n        if domain_name is not None:\n            # the user specified a domain, so we only check that\n            if domain_name not in self.env.domains:\n                self._emit_warning(\n                    __('domain for external cross-reference not found: %r'), domain_name\n                )\n                return [], []\n            domain = self.env.domains[domain_name]\n            role_func = domain.roles.get(role_name)\n            if role_func is None:\n                msg = 'role for external cross-reference not found in domain %r: %r'\n                object_types = domain.object_types.get(role_name)\n                if object_types is not None and object_types.roles:\n                    self._emit_warning(\n                        __(f'{msg} (perhaps you meant one of: %s)'),\n                        domain_name,\n                        role_name,\n                        self._concat"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es) == 2:\n            # domain:role:\n            domain_name, role = names\n        else:\n            return None\n\n        if domain_name and self.is_existent_role(domain_name, role):\n            return domain_name, role\n        elif self.is_existent_role('std', role):\n            return 'std', role\n        else:\n            return None\n\n    def is_existent_role(self, domain_name: str, role_name: str) -> bool:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.is_existent_role', '', remove=(9, 0)\n        )\n        try:\n            domain = self.env.domains[domain_name]\n        except KeyError:\n            return False\n        else:\n            return role_name in domain.roles\n\n    def invoke_role(\n        self, role: tuple[str, str]\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Invoke the role described by a ``(domain, role name)`` pair.\"\"\"\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.invoke_role', '', remove=(9, 0)\n        )\n        domain = self.env.get_domain(role[0])\n        if domain:\n            role_func = domain.role(role[1])\n            assert role_func is not None\n\n            return role_func(\n                ':'.join(role),\n                self.rawtext,\n                self.text,\n                self.lineno,\n                self.inliner,\n                self.options,\n                self.content,\n            )\n        else:\n            return [], []\n\n\nclass IntersphinxRoleResolver(ReferencesResolver):\n    \"\"\"pending_xref node resolver for intersphinx role.\n\n    This resolves pending_xref nodes generated by :intersphinx:***: role.\n    \"\"\"\n\n    default_priority = ReferencesResolver.default_priority - 1\n\n    def run(self, **kwargs: Any) -> None:\n        for node in self.document.findall(pending_xref):\n            if 'intersphinx' not in node:\n                continue\n            contnode = cast('nodes.TextElement', node[0].deepcopy())\n            inv_name = node['inventory']\n     "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=(9, 0)\n        )\n        domain = self.env.get_domain(role[0])\n        if domain:\n            role_func = domain.role(role[1])\n            assert role_func is not None\n\n            return role_func(\n                ':'.join(role),\n                self.rawtext,\n                self.text,\n                self.lineno,\n                self.inliner,\n                self.options,\n                self.content,\n            )\n        else:\n            return [], []\n\n\nclass IntersphinxRoleResolver(ReferencesResolver):\n    \"\"\"pending_xref node resolver for intersphinx role.\n\n    This resolves pending_xref nodes generated by :intersphinx:***: role.\n    \"\"\"\n\n    default_priority = ReferencesResolver.default_priority - 1\n\n    def run(self, **kwargs: Any) -> None:\n        for node in self.document.findall(pending_xref):\n            if 'intersphinx' not in node:\n                continue\n            contnode = cast('nodes.TextElement', node[0].deepcopy())\n            inv_name = node['inventory']\n            if inv_name is not None:\n                assert inventory_exists(self.env, inv_name)\n                newnode = resolve_reference_in_inventory(\n                    self.env, inv_name, node, contnode\n                )\n            else:\n                newnode = resolve_reference_any_inventory(\n                    self.env, False, node, contnode\n                )\n            if newnode is None:\n                typ = node['reftype']\n                msg = __('external %s:%s reference target not found: %s') % (\n                    node['refdomain'],\n                    typ,\n                    node['reftarget'],\n                )\n                LOGGER.warning(msg, location=node, type='ref', subtype=typ)\n                node.replace_self(contnode)\n            else:\n                node.replace_self(newnode)\n\n\ndef install_dispatcher(app: Sphinx, docname: str, source: list[str]) -> None:\n    \"\"\"Enable IntersphinxDispatcher.\n\n    .. note:: The installed dispatcher will be uninstalled on "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "roles.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            self.env, refnode, self.has_explicit_title, title, target\n        )\n        refnode['reftarget'] = target\n        refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)\n\n        return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)\n\n    # methods that can be overwritten\n\n    def process_link(\n        self,\n        env: BuildEnvironment,\n        refnode: Element,\n        has_explicit_title: bool,\n        title: str,\n        target: str,\n    ) -> tuple[str, str]:\n        \"\"\"Called after parsing title and target text, and creating the\n        reference node (given in *refnode*).  This method can alter the\n        reference node and must return a new (or the same) ``(title, target)``\n        tuple.\n        \"\"\"\n        return title, ws_re.sub(' ', target)\n\n    def result_nodes(\n        self,\n        document: nodes.document,\n        env: BuildEnvironment,\n        node: Element,\n        is_ref: bool,\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Called before returning the finished nodes.  *node* is the reference\n        node if one was created (*is_ref* is then true), else the content node.\n        This method can add other nodes and must return a ``(nodes, messages)``\n        tuple (the usual return value of a role function).\n        \"\"\"\n        return [node], []\n\n\nclass AnyXRefRole(XRefRole):\n    def process_link(\n        self,\n        env: BuildEnvironment,\n        refnode: Element,\n        has_explicit_title: bool,\n        title: str,\n        target: str,\n    ) -> tuple[str, str]:\n        result = super().process_link(env, refnode, has_explicit_title, title, target)\n        # add all possible context info (i.e. std:program, py:module etc.)\n        refnode.attributes.update(env.ref_context)\n        return result\n\n\nclass CVE(ReferenceRole):\n    _BASE_URL: Final = 'https://www.cve.org/CVERecord?id=CVE-'\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        target_id = f'index-{self."}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            otherdata['root_symbol'], docnames, self.env\n        )\n        our_objects = self.data['objects']\n        for fullname, (fn, id_, objtype) in otherdata['objects'].items():\n            if fn in docnames:\n                if fullname not in our_objects:\n                    our_objects[fullname] = (fn, id_, objtype)\n                # no need to warn on duplicates, the symbol merge already does that\n\n    def _resolve_xref_inner(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> tuple[nodes.reference, str] | tuple[None, None]:\n        parser = DefinitionParser(target, location=node, config=env.config)\n        try:\n            name = parser.parse_xref_object()\n        except DefinitionError as e:\n            logger.warning(\n                'Unparseable C cross-reference: %r\\n%s', target, e, location=node\n            )\n            return None, None\n        parent_key: LookupKey | None = node.get('c:parent_key', None)\n        root_symbol = self.data['root_symbol']\n        if parent_key:\n            parent_symbol: Symbol = root_symbol.direct_lookup(parent_key)\n            if not parent_symbol:\n                logger.debug('Target: %s', target)\n                logger.debug('ParentKey: %s', parent_key)\n                logger.debug(root_symbol.dump(1))\n            assert parent_symbol  # should be there\n        else:\n            parent_symbol = root_symbol\n        s = parent_symbol.find_declaration(\n            name, typ, matchSelf=True, recurseInAnon=True\n        )\n        if s is None or s.declaration is None:\n            return None, None\n\n        # TODO: check role type vs. object type\n\n        declaration = s.declaration\n        display_name = name.get_display_string()\n        docname = s.docname\n        assert docname\n\n        return make_refnode(\n            builder,\n            fromdocname,\n            docname,\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms/post_transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tnode=contnode, ref_doc=ref_doc, target=target\n            )\n\n        return None\n\n    def _resolve_pending_any_xref(\n        self,\n        *,\n        node: addnodes.pending_xref,\n        contnode: Element,\n        ref_doc: str,\n        target: str,\n    ) -> nodes.reference | None:\n        \"\"\"Resolve reference generated by the \"any\" role.\"\"\"\n        env = self.env\n        builder = self.env._app.builder\n        domains = env.domains\n\n        results: list[tuple[str, nodes.reference]] = []\n        # first, try resolving as :doc:\n        doc_ref = domains.standard_domain.resolve_xref(\n            env, ref_doc, builder, 'doc', target, node, contnode\n        )\n        if doc_ref:\n            results.append(('doc', doc_ref))\n        # next, do the standard domain (makes this a priority)\n        results += domains.standard_domain.resolve_any_xref(\n            env, ref_doc, builder, target, node, contnode\n        )\n        for domain in domains.sorted():\n            if domain.name == 'std':\n                continue  # we did this one already\n            try:\n                results += domain.resolve_any_xref(\n                    env, ref_doc, builder, target, node, contnode\n                )\n            except NotImplementedError:\n                # the domain doesn't yet support the new interface\n                # we have to manually collect possible references (SLOW)\n                for role in domain.roles:\n                    res = domain.resolve_xref(\n                        env, ref_doc, builder, role, target, node, contnode\n                    )\n                    if res and len(res) > 0 and isinstance(res[0], nodes.Element):\n                        results.append((f'{domain.name}:{role}', res))\n        # now, see how many matches we got...\n        if not results:\n            return None\n        if len(results) > 1:\n            candidates = ' or '.join(starmap(self._stringify, results))\n            msg = __(\n                \"more than one target found for 'any' cros"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ventory with the new target.\n    \"\"\"\n    resolve_self = env.config.intersphinx_resolve_self\n\n    # ordinary direct lookup, use data as is\n    res = resolve_reference_any_inventory(env, True, node, contnode)\n    if res is not None:\n        return res\n\n    # try splitting the target into 'inv_name:target'\n    target = node['reftarget']\n    if ':' not in target:\n        return None\n    inv_name, _, new_target = target.partition(':')\n\n    # check if the target is self-referential\n    self_referential = bool(resolve_self) and resolve_self == inv_name\n    if self_referential:\n        node['reftarget'] = new_target\n        node['intersphinx_self_referential'] = True\n        return None\n\n    if not inventory_exists(env, inv_name):\n        return None\n    node['reftarget'] = new_target\n    res_inv = resolve_reference_in_inventory(env, inv_name, node, contnode)\n    node['reftarget'] = target\n    return res_inv\n\n\ndef missing_reference(\n    app: Sphinx, env: BuildEnvironment, node: pending_xref, contnode: TextElement\n) -> nodes.reference | None:\n    \"\"\"Attempt to resolve a missing reference via intersphinx references.\"\"\"\n    return resolve_reference_detect_inventory(env, node, contnode)\n\n\nclass IntersphinxDispatcher(CustomReSTDispatcher):\n    \"\"\"Custom dispatcher for external role.\n\n    This enables :external:***:/:external+***: roles on parsing reST document.\n    \"\"\"\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        if len(role_name) > 9 and role_name.startswith(('external:', 'external+')):\n            return IntersphinxRole(role_name), []\n        else:\n            return super().role(role_name, language_module, lineno, reporter)\n\n\nclass IntersphinxRole(SphinxRole):\n    # group 1: just for the optionality of the inventory name\n    # group 2: the inventory name (optional)\n    # group 3: the domain:role or role part\n    _re_inv_ref "}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_class: type[nodes.reference] = nodes.reference,\n        **options: Any,\n    ) -> nodes.reference:\n        newnode = node_class('', '', internal=True, **options)\n        innernode = nodes.inline(sectname, sectname)\n        if innernode.get('classes') is not None:\n            innernode['classes'].append('std')\n            innernode['classes'].append('std-' + rolename)\n        if docname == fromdocname:\n            newnode['refid'] = labelid\n        else:\n            # set more info in contnode; in case the\n            # get_relative_uri call raises NoUri,\n            # the builder will then have to resolve these\n            contnode = pending_xref('')\n            contnode['refdocname'] = docname\n            contnode['refsectname'] = sectname\n            newnode['refuri'] = builder.get_relative_uri(fromdocname, docname)\n            if labelid:\n                newnode['refuri'] += '#' + labelid\n        newnode.append(innernode)\n        return newnode\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if typ == 'ref':\n            resolver = self._resolve_ref_xref\n        elif typ == 'numref':\n            resolver = self._resolve_numref_xref  # type: ignore[assignment]\n        elif typ == 'keyword':\n            resolver = self._resolve_keyword_xref\n        elif typ == 'doc':\n            resolver = self._resolve_doc_xref\n        elif typ == 'option':\n            resolver = self._resolve_option_xref\n        elif typ == 'term':\n            resolver = self._resolve_term_xref\n        else:\n            resolver = self._resolve_obj_xref\n\n        return resolver(env, fromdocname, builder, typ, target, node, contnode)\n\n    def _resolve_ref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "maxsplit=1)\n                commands.append(subcommand)\n                progname = '-'.join(commands)\n\n                docname, labelid = self.progoptions.get((progname, target), ('', ''))\n                if docname:\n                    break\n            else:\n                return None\n\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def _resolve_term_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        result = self._resolve_obj_xref(\n            env, fromdocname, builder, typ, target, node, contnode\n        )\n        if result:\n            return result\n        else:\n            # fallback to case insensitive match\n            if target.lower() in self._terms:\n                docname, labelid = self._terms[target.lower()]\n                return make_refnode(builder, fromdocname, docname, labelid, contnode)\n            else:\n                return None\n\n    def _resolve_obj_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ) or []\n        for objtype in objtypes:\n            if (objtype, target) in self.objects:\n                docname, labelid = self.objects[objtype, target]\n                break\n        else:\n            docname, labelid = '', ''\n        if not docname:\n            return None\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_strings(object_types.roles),\n                    )\n                else:\n                    self._emit_warning(__(msg), domain_name, role_name)\n                return [], []\n\n        else:\n            # the user did not specify a domain,\n            # so we check first the default (if available) then standard domains\n            default_domain = self.env.current_document.default_domain\n            std_domain = self.env.domains.standard_domain\n            domains: Sequence[Domain]\n            if default_domain is None or std_domain == default_domain:\n                domains = (std_domain,)\n            else:\n                domains = (default_domain, std_domain)\n\n            role_func = None\n            for domain in domains:\n                role_func = domain.roles.get(role_name)\n                if role_func is not None:\n                    domain_name = domain.name\n                    break\n\n            if role_func is None or domain_name is None:\n                domains_str = self._concat_strings(domain.name for domain in domains)\n                msg = 'role for external cross-reference not found in domains %s: %r'\n                possible_roles: set[str] = {\n                    f'{domain.name}:{r}'\n                    for domain in domains\n                    if (object_types := domain.object_types.get(role_name))\n                    for r in object_types.roles\n                }\n                if possible_roles:\n                    msg = f'{msg} (perhaps you meant one of: %s)'\n                    self._emit_warning(\n                        __(msg),\n                        domains_str,\n                        role_name,\n                        self._concat_strings(possible_roles),\n                    )\n                else:\n                    self._emit_warning(__(msg), domains_str, role_name)\n                return [], []\n\n        result, messages = role_func(\n            f'{domain_name}:{role_name}',\n            self.rawtext,\n            self.text,\n          "}], "retrieved_count": 10, "cost_time": 1.2265903949737549}
{"question": "Where does Sphinx's document processing flow from source files through parsing to final output generation?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's document processing flow follows a well-defined pipeline from source files through parsing to final output generation, with multiple stages and components working together to transform raw documentation into finished output.\n\nThe document processing flow includes the following key stages:\n\n1. **Source File Discovery**: The process begins in the Project class, which scans the source directory to identify all source files based on configured file extensions (typically .rst files). The Project class maintains a list of all source files and their relationships.\n\n2. **Configuration Loading**: The Config class loads project configuration from conf.py, setting up all the parameters that control the build process, including extensions, theme settings, and output format options.\n\n3. **Extension Initialization**: The SphinxComponentRegistry loads and initializes all configured extensions, registering their components (directives, roles, builders, etc.) with the system.\n\n4. **Document Reading Phase**: The Builder class orchestrates the reading of source files. For each document, the system uses appropriate parsers (typically reStructuredText parsers) to convert source text into docutils document trees.\n\n5. **Transform Application**: The SphinxTransformer applies various transforms to document trees, including Sphinx-specific transforms for cross-references, indexing, and other document modifications.\n\n6. **Cross-Reference Resolution**: The BuildEnvironment manages cross-reference resolution, using domain-specific logic to resolve references to documented objects and create appropriate links.\n\n7. **Output Generation**: The Builder class coordinates with appropriate Writer classes to convert the processed document trees into the target output format (HTML, LaTeX, etc.).\n\n8. **File Writing**: The final output files are written to the output directory, with the Builder managing the overall file structure and the Writer handling format-specific content generation.\n\nThis flow is managed by the main Sphinx application class, which coordinates all components and ensures that each stage is completed before moving to the next, while providing extension points throughout the process for customization and enhancement.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 4540, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gs = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n    warnings.warn(\n        'sphinx.io.SphinxDummySourceClass is deprecated',\n        RemovedInSphinx10Warning,\n        stacklevel=2,\n    )\n    return source\n\n\nclass SphinxFileInput(FileInput):\n    \"\"\"A basic FileInput for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        kwargs['error_handler'] = 'sphinx'\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxFileInput is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "oads(otherenv)\n            self.env.merge_info_from(docs, env, self._app)\n\n            next(progress)\n\n        tasks = ParallelTasks(nproc)\n        for chunk in chunks:\n            tasks.add_task(read_process, chunk, merge)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    @final\n    def read_doc(self, docname: str, *, _cache: bool = True) -> None:\n        \"\"\"Parse a file and add/update inventory entries for the doctree.\"\"\"\n        env = self.env\n        env.prepare_settings(docname)\n\n        # Add confdir/docutils.conf to dependencies list if exists\n        docutils_conf = self.confdir / 'docutils.conf'\n        if docutils_conf.is_file():\n            env.note_dependency(docutils_conf)\n\n        filename = env.doc2path(docname)\n\n        # set up error_handler for the target document\n        # xref RemovedInSphinx90Warning\n        error_handler = _UnicodeDecodeErrorHandler(docname)\n        codecs.register_error('sphinx', error_handler)  # type: ignore[arg-type]\n\n        # read the source file\n        content = filename.read_text(\n            encoding=env.settings['input_encoding'], errors='sphinx'\n        )\n\n        # TODO: move the \"source-read\" event to here.\n\n        filetype = get_filetype(self.config.source_suffix, filename)\n        parser = self._registry.create_source_parser(\n            filetype, config=self.config, env=env\n        )\n        doctree = _parse_str_to_doctree(\n            content,\n            filename=filename,\n            default_role=self.config.default_role,\n            default_settings=env.settings,\n            env=env,\n            events=self.events,\n            parser=parser,\n            transforms=self._registry.get_transforms(),\n        )\n\n        # store time of reading, for outdated files detection\n        env.all_docs[docname] = time.time_ns() // 1_000\n\n        # cleanup\n        env.current_document = _CurrentDocument()\n        env.ref_context.clear()\n\n        self.write_doctree(docname, d"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.loads(otherenv)\n            self.env.merge_info_from(docs, env, self._app)\n\n            next(progress)\n\n        tasks = ParallelTasks(nproc)\n        for chunk in chunks:\n            tasks.add_task(read_process, chunk, merge)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    @final\n    def read_doc(self, docname: str, *, _cache: bool = True) -> None:\n        \"\"\"Parse a file and add/update inventory entries for the doctree.\"\"\"\n        env = self.env\n        env.prepare_settings(docname)\n\n        # Add confdir/docutils.conf to dependencies list if exists\n        docutils_conf = self.confdir / 'docutils.conf'\n        if docutils_conf.is_file():\n            env.note_dependency(docutils_conf)\n\n        filename = env.doc2path(docname)\n\n        # set up error_handler for the target document\n        # xref RemovedInSphinx90Warning\n        error_handler = _UnicodeDecodeErrorHandler(docname)\n        codecs.register_error('sphinx', error_handler)  # ty"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pe: ignore[arg-type]\n\n        # read the source file\n        content = filename.read_text(\n            encoding=env.settings['input_encoding'], errors='sphinx'\n        )\n\n        # TODO: move the \"source-read\" event to here.\n\n        filetype = get_filetype(self.config.source_suffix, filename)\n        parser = self._registry.create_source_parser(\n            filetype, config=self.config, env=env\n        )\n        doctree = _parse_str_to_doctree(\n            content,\n            filename=filename,\n            default_role=self.config.default_role,\n            default_settings=env.settings,\n            env=env,\n            events=self.events,\n            parser=parser,\n            transforms=self._registry.get_transforms(),\n        )\n\n        # store time of reading, for outdated files detection\n        env.all_docs[docname] = time.time_ns() // 1_000\n\n        # cleanup\n        env.current_document = _CurrentDocument()\n        env.ref_context.clear()\n\n        self.write_doctree(docname, doctree, _cache=_cache)\n\n    @final\n    def write_doctree(\n        self,\n        docname: str,\n        doctree: nodes.document,\n        *,\n        _cache: bool = True,\n    ) -> None:\n        \"\"\"Write the doctree to a file, to be used as a cache by re-builds.\"\"\"\n        # make it pickleable\n        doctree.reporter = None  # type: ignore[assignment]\n        doctree.transformer = None  # type: ignore[assignment]\n\n        # Create a copy of settings object before modification because it is\n        # shared with other documents.\n        doctree.settings = doctree.settings.copy()\n        doctree.settings.warning_stream = None\n        doctree.settings.env = None\n        doctree.settings.record_dependencies = None\n\n        doctree_filename = self.doctreedir / f'{docname}.doctree'\n        doctree_filename.parent.mkdir(parents=True, exist_ok=True)\n        with open(doctree_filename, 'wb') as f:\n            pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)\n\n        # When Sphinx is running in para"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_doc(docname)\n\n    def _read_parallel(self, docnames: list[str], nproc: int) -> None:\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after reading a document\n        # (see: ``merge()`` function)\n        progress = status_iterator(\n            chunks,\n            __('reading sources... '),\n            'purple',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        # clear all outdated docs at once\n        for docname in docnames:\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n\n        def read_process(docs: list[str]) -> bytes:\n            self.env._app = self._app\n            for docname in docs:\n                self.read_doc(docname, _cache=False)\n            # allow pickling self to send it back\n            return pickle.dumps(self.env, pickle.HIGHEST_PROTOCOL)\n\n        def merge(docs: list[str], otherenv: bytes) -> None:\n            env = pickle.l"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  continue\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it matches an exclude pattern specified '\n                    'in conf.py, %r. '\n                    'Please remove this pattern from conf.py.'\n                )\n                raise SphinxError(msg % (master_doc_path, pat))\n            if set(self.config.include_patterns) != {'**'} and not any(\n                re.match(_translate_pattern(pat), master_doc_canon)\n                for pat in self.config.include_patterns\n            ):\n                msg = __(\n                    'Sphinx is unable to load the master document (%s) '\n                    'because it is not included in the custom include_patterns = %r. '\n                    'Ensure that a pattern in include_patterns matches the '\n                    'master document.'\n                )\n                raise SphinxError(msg % (master_doc_path, self.config.include_patterns))\n            msg = __(\n                'Sphinx is unable to load the master document (%s). '\n                'The master document must be within the source directory '\n                'or a subdirectory of it.'\n            )\n            raise SphinxError(msg % master_doc_path)\n\n        for retval in self.events.emit('env-updated', self.env):\n            if retval is not None:\n                docnames.extend(retval)\n\n        # workaround: marked as okay to call builder.read() twice in same process\n        self.env.config_status = CONFIG_OK\n\n        return sorted(docnames)\n\n    def _read_serial(self, docnames: list[str]) -> None:\n        for docname in status_iterator(\n            docnames,\n            __('reading sources... '),\n            'purple',\n            len(docnames),\n            self.config.verbosity,\n        ):\n            # remove all inventory entries for that file\n            self.events.emit('env-purge-doc', self.env, docname)\n            self.env.clear_doc(docname)\n            self.read_"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " # Create root document node\n    reporter = LoggingReporter(\n        source=str(filename),\n        report_level=settings.report_level,\n        halt_level=settings.halt_level,\n        debug=settings.debug,\n        error_handler=settings.error_encoding_error_handler,\n    )\n    document = nodes.document(settings, reporter, source=str(filename))\n    document.note_source(str(filename), -1)\n\n    # substitute transformer\n    document.transformer = transformer = SphinxTransformer(document)\n    transformer.add_transforms(_READER_TRANSFORMS)\n    transformer.add_transforms(transforms)\n    transformer.add_transforms(parser.get_transforms())\n\n    if default_role:\n        default_role_cm = rst.default_role(env.current_document.docname, default_role)\n    else:\n        default_role_cm = nullcontext()  # type: ignore[assignment]\n    with sphinx_domains(env), default_role_cm:\n        # TODO: Move the stanza below to Builder.read_doc(), within\n        #       a sphinx_domains() context manager.\n        #       This will require changes to IntersphinxDispatcher and/or\n        #       CustomReSTDispatcher.\n        if events is not None:\n            # emit \"source-read\" event\n            arg = [content]\n            events.emit('source-read', env.current_document.docname, arg)\n            content = arg[0]\n\n        # parse content to abstract syntax tree\n        parser.parse(content, document)\n        document.current_source = document.current_line = None\n\n        # run transforms\n        transformer.apply_transforms()\n\n    return document\n\n\ndef _get_settings(\n    *components: Component | type[Component],\n    defaults: Mapping[str, Any],\n    read_config_files: bool = False,\n) -> Values:\n    with warnings.catch_warnings(action='ignore', category=DeprecationWarning):\n        # DeprecationWarning: The frontend.OptionParser class will be replaced\n        # by a subclass of argparse.ArgumentParser in Docutils 0.21 or later.\n        # DeprecationWarning: The frontend.Option class will be removed"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "create\n        output files for each document.\n        \"\"\"\n        sorted_docnames = sorted(docnames)\n        if self.parallel_ok:\n            # number of subprocesses is parallel-1 because the main process\n            # is busy loading doctrees and doing write_doc_serialized()\n            self._write_parallel(sorted_docnames, nproc=self._app.parallel - 1)\n        else:\n            self._write_serial(sorted_docnames)\n\n    def _write_serial(self, docnames: Sequence[str]) -> None:\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            for docname in status_iterator(\n                docnames,\n                __('writing output... '),\n                'darkgreen',\n                len(docnames),\n                self.config.verbosity,\n            ):\n                _write_docname(docname, env=self.env, builder=self, tags=self.tags)\n\n    def _write_parallel(self, docnames: Sequence[str], nproc: int) -> None:\n        def write_process(docs: list[tuple[str, nodes.document]]) -> None:\n            self.phase = BuildPhase.WRITING\n            for docname, doctree in docs:\n                self.write_doc(docname, doctree)\n\n        # warm up caches/compile templates using the first document\n        firstname, docnames = docnames[0], docnames[1:]\n        _write_docname(firstname, env=self.env, builder=self, tags=self.tags)\n\n        tasks = ParallelTasks(nproc)\n        chunks = make_chunks(docnames, nproc)\n\n        # create a status_iterator to step progressbar after writing a document\n        # (see: ``on_chunk_done()`` function)\n        progress = status_iterator(\n            chunks,\n            __('writing output... '),\n            'darkgreen',\n            len(chunks),\n            self.config.verbosity,\n        )\n\n        def on_chunk_done(args: list[tuple[str, nodes.document]], result: None) -> None:\n            next(progress)\n\n        self.phase = BuildPhase.RESOLVING\n        for c"}, {"start_line": 0, "end_line": 163, "belongs_to": {"file_name": "__main__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"The Sphinx documentation toolchain.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nfrom sphinx.cmd.build import main\n\nraise SystemExit(main(sys.argv[1:]))\n"}], "retrieved_count": 10, "cost_time": 1.2352101802825928}
{"question": "Why does Sphinx use an event-driven architecture for its extension system instead of direct method calls?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx uses an event-driven architecture for its extension system instead of direct method calls for several important reasons related to extensibility, decoupling, and maintainability.\n\nKey reasons for the event-driven approach include:\n\n1. **Loose Coupling**: The event-driven architecture decouples the core Sphinx system from extensions, allowing extensions to be added or removed without modifying the core codebase. This makes the system more modular and maintainable.\n\n2. **Multiple Extension Support**: Multiple extensions can listen to the same events without interfering with each other. This allows for rich extension ecosystems where different extensions can add functionality to the same build phases.\n\n3. **Flexible Hook Points**: The event system provides numerous hook points throughout the build process (e.g., 'config-inited', 'builder-inited', 'doctree-read', 'doctree-resolved'), allowing extensions to integrate at the most appropriate stage.\n\n4. **Non-Intrusive Integration**: Extensions can add functionality without requiring changes to the core Sphinx code. This makes it easier to maintain backward compatibility and reduces the risk of introducing bugs when adding new features.\n\n5. **Dynamic Extension Loading**: The event system allows extensions to be loaded dynamically and to register their event handlers at runtime, providing flexibility in how extensions are integrated.\n\n6. **Error Isolation**: If one extension fails during event processing, it doesn't necessarily affect other extensions or the core build process, providing better error isolation and robustness.\n\n7. **Build Phase Integration**: The event system aligns well with Sphinx's multi-phase build process, allowing extensions to hook into specific phases (reading, resolving, writing) as needed.\n\n8. **Extensibility**: The event-driven approach makes it easy to add new extension points in the future without breaking existing extensions, as new events can be added without changing the existing event system.\n\nThis architecture provides the flexibility and robustness needed for a complex documentation system that needs to support a wide variety of extensions and use cases.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Sphinx.\"\"\"\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app = app\n        self.events = core_events.copy()\n        self.listeners: dict[str, list[EventListener]] = defaultdict(list)\n        self.next_listener_id = 0\n\n        # pass through errors for debugging.\n        self._reraise_errors: bool = app.pdb\n\n    def add(self, name: str) -> None:\n        \"\"\"Register a custom Sphinx event.\"\"\"\n        if name in self.events:\n            raise ExtensionError(__('Event %r already present') % name)\n        self.events[name] = ''\n\n    @property\n    def app(self) -> Sphinx:\n        _deprecation_warning(__name__, 'EventManager.app', remove=(10, 0))\n        return self._app\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-get-outdated'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], Set[str], Set[str]], Sequence[str]\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-before-read-docs'],\n        callback: Callable[[Sphinx, BuildEnvironment, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-purge-doc'],\n        callback: Callable[[Sphinx, BuildEnvironment, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['source-read'],\n        callback: Callable[[Sphinx, str, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o_node\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass EventListener(NamedTuple):\n    id: int\n    handler: Callable[..., Any]\n    priority: int\n\n\n# List of all known core events. Maps name to arguments description.\ncore_events = {\n    'config-inited': 'config',\n    'builder-inited': '',\n    'env-get-outdated': 'env, added, changed, removed',\n    'env-before-read-docs': 'env, docnames',\n    'env-purge-doc': 'env, docname',\n    'source-read': 'docname, source text',\n    'include-read': 'relative path, parent docname, source text',\n    'doctree-read': 'the doctree before being pickled',\n    'env-merge-info': 'env, read docnames, other env instance',\n    'env-updated': 'env',\n    'env-get-updated': 'env',\n    'env-check-consistency': 'env',\n    'write-started': 'builder',\n    'doctree-resolved': 'doctree, docname',\n    'missing-reference': 'env, node, contnode',\n    'warn-missing-reference': 'domain, node',\n    'build-finished': 'exception',\n}\n\n\nclass EventManager:\n    \"\"\"Event manager for Sphinx.\"\"\"\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app = app\n        self.events = core_events.copy()\n        self.listeners: dict[str, list[EventListener]] = defaultdict(list)\n        self.next_listener_id = 0\n\n        # pass through errors for debugging.\n        self._reraise_errors: bool = app.pdb\n\n    def add(self, name: str) -> None:\n        \"\"\"Register a custom Sphinx event.\"\"\"\n        if name in self.events:\n            raise ExtensionError(__('Event %r already present') % name)\n        self.events[name] = ''\n\n    @property\n    def app(self) -> Sphinx:\n        _deprecation_warning(__name__, 'EventManager.app', remove=(10, 0))\n        return self._app\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ot in self.events:\n            raise ExtensionError(__('Unknown event name: %s') % name)\n\n        listener_id = self.next_listener_id\n        self.next_listener_id += 1\n        self.listeners[name].append(EventListener(listener_id, callback, priority))\n        return listener_id\n\n    def disconnect(self, listener_id: int) -> None:\n        \"\"\"Disconnect a handler.\"\"\"\n        for listeners in self.listeners.values():\n            for listener in listeners.copy():\n                if listener.id == listener_id:\n                    listeners.remove(listener)\n\n    def emit(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Exception], ...] = (),\n    ) -> list[Any]:\n        \"\"\"Emit a Sphinx event.\"\"\"\n        # not every object likes to be repr()'d (think\n        # random stuff coming via autodoc)\n        try:\n            repr_args = repr(args)\n        except Exception:\n            pass\n        else:\n            logger.debug('[app] emitting event: %r%s', name, repr_args)\n\n        results = []\n        listeners = sorted(self.listeners[name], key=attrgetter('priority'))\n        for listener in listeners:\n            try:\n                results.append(listener.handler(self._app, *args))\n            except allowed_exceptions:\n                # pass through the errors specified as *allowed_exceptions*\n                raise\n            except SphinxError:\n                raise\n            except Exception as exc:\n                if self._reraise_errors:\n                    raise\n                modname = safe_getattr(listener.handler, '__module__', None)\n                raise ExtensionError(\n                    __('Handler %r for event %r threw an exception')\n                    % (listener.handler, name),\n                    exc,\n                    modname=modname,\n                ) from exc\n        return results\n\n    def emit_firstresult(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Excep"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ",\n        name: Literal['todo-defined'],\n        callback: Callable[[Sphinx, todo_node], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['viewcode-find-source'],\n        callback: Callable[\n            [Sphinx, str],\n            tuple[str, dict[str, tuple[Literal['class', 'def', 'other'], int, int]]],\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['viewcode-follow-imported'],\n        callback: Callable[[Sphinx, str, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Catch-all ---------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: str,\n        callback: Callable[..., Any],\n        priority: int,\n    ) -> int: ...\n\n    def connect(self, name: str, callback: Callable[..., Any], priority: int) -> int:\n        \"\"\"Connect a handler to specific event.\"\"\"\n        if name not in self.events:\n            raise ExtensionError(__('Unknown event name: %s') % name)\n\n        listener_id = self.next_listener_id\n        self.next_listener_id += 1\n        self.listeners[name].append(EventListener(listener_id, callback, priority))\n        return listener_id\n\n    def disconnect(self, listener_id: int) -> None:\n        \"\"\"Disconnect a handler.\"\"\"\n        for listeners in self.listeners.values():\n            for listener in listeners.copy():\n                if listener.id == listener_id:\n                    listeners.remove(listener)\n\n    def emit(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Exception], ...] = (),\n    ) -> list[Any]:\n        \"\"\"Emit a Sphinx event.\"\"\"\n        # not every object likes to be repr()'d (think\n        # random stuff coming via autodoc)\n        try:\n            repr_args = repr(args)\n        except Exception:\n            pass\n        else:\n            logger.debug('[app] emitting event: %r%s'"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ]"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   callback: Callable[[Sphinx, Path, str, list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-read'],\n        callback: Callable[[Sphinx, nodes.document], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-merge-info'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], BuildEnvironment], None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], str],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-get-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], "}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "bool | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n           "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self,\n        name: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions--"}], "retrieved_count": 10, "cost_time": 1.2859320640563965}
{"question": "What is the purpose of the SphinxComponentRegistry class?", "answer": null, "relative_code_list": null, "ground_truth": "The SphinxComponentRegistry class serves as the central registry and component management system for Sphinx's extensible architecture. Its primary purpose is to maintain and organize all the various components that can be registered and used throughout the Sphinx build process.\n\nKey responsibilities of the SphinxComponentRegistry include:\n\n1. **Component Storage**: The registry maintains dictionaries and collections for storing various types of components including builders, domains, directives, roles, transforms, documenters, and other extensible elements.\n\n2. **Extension Management**: It handles the loading and registration of Sphinx extensions, managing their metadata and ensuring proper initialization. The registry can load extensions from entry points and handle extension setup functions.\n\n3. **Domain Component Management**: The registry manages domain-specific components such as directives, roles, object types, and indices that are associated with specific domains (Python, C++, etc.).\n\n4. **Builder Management**: It maintains a registry of available builder classes and provides methods to create builder instances.\n\n5. **Autodoc Integration**: The registry manages autodoc documenters and attribute getters for automatic documentation generation.\n\n6. **Node Handler Management**: It manages custom node handlers for translators, allowing extensions to customize how specific node types are rendered in different output formats.\n\n7. **Math Renderer Management**: The registry handles math rendering components for different output formats.\n\n8. **Component Creation**: It provides methods to create instances of registered components, such as creating domain instances with all their associated components properly initialized.\n\nThe registry is instantiated as part of the Sphinx application (`self.registry = SphinxComponentRegistry()`) and serves as the foundation for Sphinx's plugin architecture, allowing extensions to register new functionality without modifying the core Sphinx codebase.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tuple of filename and attributes\n        self.css_files: list[tuple[str, dict[str, Any]]] = []\n\n        #: domains; a dict of domain name -> domain class\n        self.domains: dict[str, type[Domain]] = {}\n\n        #: additional directives for domains\n        #: a dict of domain name -> dict of directive name -> directive\n        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}\n\n        #: additional indices for domains\n        #: a dict of domain name -> list of index class\n        self.domain_indices: dict[str, list[type[Index]]] = {}\n\n        #: additional object types for domains\n        #: a dict of domain name -> dict of objtype name -> objtype\n        self.domain_object_types: dict[str, dict[str, ObjType]] = {}\n\n        #: additional roles for domains\n        #: a dict of domain name -> dict of role name -> role impl.\n        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}\n\n        #: additional enumerable nodes\n        #: a dict of node class"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx component registry.\"\"\"\n\nfrom __future__ import annotations\n\nimport traceback\nfrom importlib import import_module\nfrom importlib.metadata import entry_points\nfrom types import MethodType\nfrom typing import TYPE_CHECKING\n\nfrom sphinx.domains import ObjType\nfrom sphinx.domains.std import GenericObject, Target\nfrom sphinx.errors import ExtensionError, SphinxError, VersionRequirementError\nfrom sphinx.extension import Extension\nfrom sphinx.locale import __\nfrom sphinx.parsers import Parser as SphinxParser\nfrom sphinx.roles import XRefRole\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.logging import prefixed_warnings\n\nif TYPE_CHECKING:\n    import os\n    from collections.abc import Callable, Iterator, Mapping, Sequence\n    from typing import Any, TypeAlias\n\n    from docutils import nodes\n    from docutils.nodes import Element, Node, TextElement\n    from docutils.parsers import Parser\n    from docutils.parsers.rst import Directive\n    from docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n                ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.dom"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "_domains_container.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        'std',\n        # Language-specific domains\n        'c',\n        'cpp',\n        'js',\n        'py',\n        'rst',\n        # Other core domains\n        'changeset',\n        'citation',\n        'index',\n        'math',\n    })\n\n    @classmethod\n    def _from_environment(\n        cls, env: BuildEnvironment, /, *, registry: SphinxComponentRegistry\n    ) -> Self:\n        create_domains = registry.create_domains\n        # Initialise domains\n        if domains := {domain.name: domain for domain in create_domains(env)}:\n            return cls(**domains)  # type: ignore[arg-type]\n\n        return cls._from_environment_default(env=env)\n\n    @classmethod\n    def _from_environment_default(cls, *, env: BuildEnvironment) -> Self:\n        \"\"\"Return a default instance with every domain we require.\"\"\"\n        from sphinx.domains.c import CDomain\n        from sphinx.domains.changeset import ChangeSetDomain\n        from sphinx.domains.citation import CitationDomain\n        from sphinx.domains.cpp import CPPDomain\n        from sphinx.domains.index import IndexDomain\n        from sphinx.domains.javascript import JavaScriptDomain\n        from sphinx.domains.math import MathDomain\n        from sphinx.domains.python import PythonDomain\n        from sphinx.domains.rst import ReSTDomain\n        from sphinx.domains.std import StandardDomain\n\n        return cls(\n            c=CDomain(env),\n            changeset=ChangeSetDomain(env),\n            citation=CitationDomain(env),\n            cpp=CPPDomain(env),\n            index=IndexDomain(env),\n            js=JavaScriptDomain(env),\n            math=MathDomain(env),\n            py=PythonDomain(env),\n            rst=ReSTDomain(env),\n            std=StandardDomain(env),\n        )\n\n    def __init__(\n        self,\n        *,\n        c: CDomain,\n        cpp: CPPDomain,\n        js: JavaScriptDomain,\n        py: PythonDomain,\n        rst: ReSTDomain,\n        std: StandardDomain,\n        changeset: ChangeSetDomain,\n        citation: CitationDomain,\n "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "extensions: dict[str, Extension] = {}\n        self.registry = SphinxComponentRegistry()\n\n        # validate provided directories\n        self.srcdir = _StrPath(srcdir).resolve()\n        self.outdir = _StrPath(outdir).resolve()\n        self.doctreedir = _StrPath(doctreedir).resolve()\n\n        if not self.srcdir.is_dir():\n            raise ApplicationError(\n                __('Cannot find source directory (%s)') % self.srcdir\n            )\n\n        if self.outdir.exists() and not self.outdir.is_dir():\n            raise ApplicationError(\n                __('Output directory (%s) is not a directory') % self.outdir\n            )\n\n        if self.srcdir == self.outdir:\n            raise ApplicationError(\n                __('Source directory and destination directory cannot be identical')\n            )\n\n        self.parallel = parallel\n\n        if status is None:\n            self._status: IO[str] = StringIO()\n            self.quiet: bool = True\n        else:\n            self._status = status\n            self.quiet = False\n\n        if warning is None:\n            self._warning: IO[str] = StringIO()\n        else:\n            self._warning = warning\n        self._warncount = 0\n        self.keep_going = bool(warningiserror)  # Unused\n        self._fail_on_warnings = bool(warningiserror)\n        self.pdb = pdb\n        self._exception_on_warning = exception_on_warning\n        logging.setup(self, self._status, self._warning, verbosity=verbosity)\n\n        self.events = EventManager(self)\n\n        # keep last few messages for traceback\n        # This will be filled by sphinx.util.logging.LastMessagesWriter\n        self.messagelog: deque[str] = deque(maxlen=10)\n\n        # say hello to the world\n        logger.info(bold(__('Running Sphinx v%s')), sphinx.__display_version__)\n\n        # status code for command-line application\n        self.statuscode = 0\n\n        # read config\n        overrides = confoverrides or {}\n        self.tags = Tags(tags)\n        if confdir is None:\n           "}], "retrieved_count": 10, "cost_time": 1.3144690990447998}
{"question": "Where in the Sphinx codebase are the core Builder class definitions located?", "answer": null, "relative_code_list": null, "ground_truth": "The core Builder class definitions in Sphinx are located in the sphinx/builders/ directory, with the main Builder base class and various specific builder implementations distributed across multiple files and subdirectories.\n\nKey locations where Builder class definitions are located include:\n\n1. **sphinx/builders/__init__.py**: Contains the main Builder base class that defines the core interface and common functionality for all builders. This includes the abstract methods that must be implemented by specific builders and the overall build workflow.\n\n2. **sphinx/builders/html.py**: Contains the HTML builder implementation, which is one of the most commonly used builders for generating HTML documentation.\n\n3. **sphinx/builders/latex.py**: Contains the LaTeX builder implementation for generating LaTeX output that can be compiled to PDF.\n\n4. **sphinx/builders/manpage.py**: Contains the manpage builder for generating Unix manual pages.\n\n5. **sphinx/builders/texinfo.py**: Contains the Texinfo builder for generating Texinfo documentation.\n\n6. **sphinx/builders/text.py**: Contains the text builder for generating plain text documentation.\n\n7. **sphinx/builders/xml.py**: Contains the XML builder for generating XML output.\n\n8. **sphinx/builders/epub3.py**: Contains the EPUB3 builder for generating electronic book format documentation.\n\n9. **sphinx/builders/gettext.py**: Contains the gettext builder for generating message catalogs for internationalization.\n\n10. **sphinx/builders/linkcheck.py**: Contains the linkcheck builder for checking external links in documentation.\n\n11. **sphinx/builders/dummy.py**: Contains a dummy builder for testing purposes.\n\n12. **sphinx/builders/changes.py**: Contains the changes builder for generating change logs.\n\n13. **sphinx/builders/dirhtml.py**: Contains the directory HTML builder for generating HTML with directory-based URLs.\n\n14. **sphinx/builders/singlehtml.py**: Contains the single HTML builder for generating a single HTML file containing all documentation.\n\nEach builder implementation extends the base Builder class and provides specific functionality for its target output format. The builders are registered with the SphinxComponentRegistry and can be selected through the buildername parameter when creating a Sphinx application.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n    allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "i18n.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport os.path\nimport re\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nimport babel.dates\nfrom babel.messages.mofile import write_mo\nfrom babel.messages.pofile import read_po\n\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import SEP, _last_modified_time\n\nif TYPE_CHECKING:\n    import datetime as dt\n    from collections.abc import Iterator\n    from typing import Protocol, TypeAlias\n\n    from babel.core import Locale\n\n    from sphinx.environment import BuildEnvironment\n\n    class DateFormatter(Protocol):\n        def __call__(\n            self,\n            date: dt.date | None = ...,\n            format: str = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class TimeFormatter(Protocol):\n        def __call__(\n            self,\n            time: dt.time | dt.datetime | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class DatetimeFormatter(Protocol):\n        def __call__(\n            self,\n            datetime: dt.date | dt.time | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    Formatter: TypeAlias = DateFormatter | TimeFormatter | DatetimeFormatter\n\nfrom datetime import UTC\n\nlogger = logging.getLogger(__name__)\n\n\nclass CatalogInfo:\n    __slots__ = 'base_dir', 'domain', 'charset'\n\n    def __init__(\n        self, base_dir: str | os.PathLike[str], domain: str, charset: str\n    ) -> None:\n        self.base_dir = _StrPath(base_dir)\n        self.domain = domain\n        self.charset = charset\n\n    @property\n    def po_file(self) -> str:\n        return f'{self.domain}.po'\n\n    @property\n "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self.post_transforms: list[type[Transform]] = []\n\n        #: source parsers; file type -> parser class\n        self.source_parsers: dict[str, type[Parser]] = {}\n\n        #: source suffix: suffix -> file type\n        self.source_suffix: dict[str, str] = {}\n\n        #: custom translators; builder name -> translator class\n        self.translators: dict[str, type[nodes.NodeVisitor]] = {}\n\n        #: custom handlers for translators\n        #: a dict of builder name -> dict of node name -> visitor and departure functions\n        self.translation_handlers: dict[str, dict[str, _NodeHandlerPair]] = {}\n\n        #: additional transforms; list of transforms\n        self.transforms: list[type[Transform]] = []\n\n    @property\n    def autodoc_attrgettrs(self) -> dict[type, Callable[[Any, str, Any], Any]]:\n        return self.autodoc_attrgetters\n\n    def add_builder(self, builder: type[Builder], override: bool = False) -> None:\n        logger.debug('[app] adding builder: %r', builder)\n        if not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n   "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n        ensuredir(self.doctreedir)\n\n        self._app: Sphinx = app\n        self.env: BuildEnvironment = env\n        self.env.set_versioning_method(self.versioning_method, self.versioning_compare)\n        self.events: EventManager = app.events\n        self.config: Config = app.config\n        self.tags: Tags = app.tags\n        self.tags.add(self.format)\n        self.tags.add(self.name)\n        self.tags.add(f'format_{self.format}')\n        self.tags.add(f'builder_{self.name}')\n        self._registry = app.registry\n\n        # images that need to be copied over (source -> dest)\n        self.images: dict[str, str] = {}\n        # basename of images directory\n        self.imagedir = ''\n        # relative path to image directory from current docname (used at writing docs)\n        self.imgpath = ''\n\n        # these get set later\n        self.parallel_ok = False\n        self.finish_tasks: Any = None\n\n    @property\n    def app(self) -> Sphinx:\n        cls_module = self.__class__.__module__\n       "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport codecs\nimport pickle\nimport re\nimport time\nfrom contextlib import nullcontext\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, final\n\nfrom docutils import nodes\n\nfrom sphinx._cli.util.colour import bold\nfrom sphinx.deprecation import _deprecation_warning\nfrom sphinx.environment import (\n    CONFIG_CHANGED_REASON,\n    CONFIG_OK,\n    _CurrentDocument,\n)\nfrom sphinx.environment.adapters.asset import ImageAdapter\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import get_filetype, logging\nfrom sphinx.util._importer import import_object\nfrom sphinx.util._pathlib import _StrPathProperty\nfrom sphinx.util.build_phase import BuildPhase\nfrom sphinx.util.display import progress_message, status_iterator\nfrom sphinx.util.docutils import _parse_str_to_doctree\nfrom sphinx.util.i18n import CatalogRepository, docname_to_domain\nfrom sphinx.util.osutil import ensuredir, relative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self._app\n\n    @property\n    def _translator(self) -> NullTranslations | None:\n        return self._app.translator\n\n    def get_translator_class(self, *args: Any) -> type[nodes.NodeVisitor]:\n        \"\"\"Return a class of translator.\"\"\"\n        return self._registry.get_translator_class(self)\n\n    def create_translator(self, *args: Any) -> nodes.NodeVisitor:\n        \"\"\"Return an instance of translator.\n\n        This method returns an instance of ``default_translator_class`` by default.\n        Users can replace the translator class with ``app.set_translator()`` API.\n        \"\"\"\n        return self._registry.create_translator(self, *args)\n\n    # helper methods\n    def init(self) -> None:\n        \"\"\"Load necessary templates and perform initialization.  The default\n        implementation does nothing.\n        \"\"\"\n        pass\n\n    def create_template_bridge(self) -> None:\n        \"\"\"Return the template bridge configured.\"\"\"\n        if self.config.template_bridge:\n            template_bridge_cls = import_object(\n                self.config.template_bridge,\n                source='template_bridge setting',\n            )\n            self.templates = template_bridge_cls()\n        else:\n            from sphinx.jinja2glue import BuiltinTemplateLoader\n\n            self.templates = BuiltinTemplateLoader()\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        \"\"\"Return the target URI for a document name.\n\n        *typ* can be used to qualify the link characteristic for individual\n        builders.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_relative_uri(self, from_: str, to: str, typ: str | None = None) -> str:\n        \"\"\"Return a relative URI between two source filenames.\n\n        :raises: :exc:`!NoUri` if there's no way to return a sensible URI.\n        \"\"\"\n        return relative_uri(\n            self.ge"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      ensuredir(self.doctreedir)\n\n        self._app: Sphinx = app\n        self.env: BuildEnvironment = env\n        self.env.set_versioning_method(self.versioning_method, self.versioning_compare)\n        self.events: EventManager = app.events\n        self.config: Config = app.config\n        self.tags: Tags = app.tags\n        self.tags.add(self.format)\n        self.tags.add(self.name)\n        self.tags.add(f'format_{self.format}')\n        self.tags.add(f'builder_{self.name}')\n        self._registry = app.registry\n\n        # images that need to be copied over (source -> dest)\n        self.images: dict[str, str] = {}\n        # basename of images directory\n        self.imagedir = ''\n        # relative path to image directory from current docname (used at writing docs)\n        self.imgpath = ''\n\n        # these get set later\n        self.parallel_ok = False\n        self.finish_tasks: Any = None\n\n    @property\n    def app(self) -> Sphinx:\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self._app\n\n    @property\n    def _translator(self) -> NullTranslations | None:\n        return self._app.translator\n\n    def get_translator_class(self, *args: Any) -> type[nodes.NodeVisitor]:\n        \"\"\"Return a class of translator.\"\"\"\n        return self._registry.get_translator_class(self)\n\n    def create_translator(self, *args: Any) -> nodes.NodeVisitor:\n        \"\"\"Return an instance of translator.\n\n        This method returns an instance of ``default_translator_class`` by default.\n        Users can replace the translator class with ``app.set_translator()`` API.\n        \"\"\"\n        return self._registry.create_translator(self, *args)\n\n    # helper methods\n    def init(self) -> None:\n        \"\"\"Load necessary templates and perform initialization.  The default\n        implementation does nothing.\n        \"\"\"\n        pass\n\n    def create_template_bridge(self"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}], "retrieved_count": 10, "cost_time": 0.3266594409942627}
{"question": "Where are Sphinx's built-in role definitions registered in the codebase?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's built-in role definitions are registered in the codebase through several mechanisms and locations, with the registration process happening during Sphinx initialization and extension setup.\n\nKey locations where built-in role definitions are registered include:\n\n1. **sphinx/roles.py**: This is the main file where built-in roles are defined and registered. The file contains role implementations and a `setup()` function that registers these roles with the Docutils role system. This includes roles like `XRefRole`, `AnyXRefRole`, and various specialized roles for cross-references, formatting, and other functionality.\n\n2. **sphinx/domains/__init__.py**: The Domain base class provides a framework for registering domain-specific roles. Each domain can register its own roles through the `roles` attribute and the domain initialization process.\n\n3. **sphinx/domains/python.py**: Contains Python domain-specific role implementations and registration, including roles like `:py:func:`, `:py:class:`, `:py:mod:`, etc.\n\n4. **sphinx/domains/cpp.py**: Contains C++ domain-specific role implementations and registration, including roles for C++ objects like classes, functions, namespaces, etc.\n\n5. **sphinx/domains/c.py**: Contains C domain-specific role implementations and registration.\n\n6. **sphinx/domains/js.py**: Contains JavaScript domain-specific role implementations and registration.\n\n7. **sphinx/domains/rst.py**: Contains reStructuredText domain-specific role implementations and registration.\n\n8. **sphinx/domains/math.py**: Contains math domain-specific role implementations and registration.\n\n9. **sphinx/domains/std.py**: Contains standard domain role implementations and registration, including general-purpose roles like `:ref:`, `:doc:`, `:term:`, etc.\n\n10. **sphinx/registry.py**: The SphinxComponentRegistry manages the registration of roles across the system, providing methods for extensions to register custom roles.\n\nThe registration process typically involves calling Docutils' `register_local_role()` function or using Sphinx's extension API to register roles with the system. Roles are registered during the extension setup phase, ensuring they are available throughout the build process.", "score": null, "retrieved_content": [{"start_line": 21000, "end_line": 22595, "belongs_to": {"file_name": "roles.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es, language=language)\n\n    return [node], []\n\n\ncode_role.options = {  # type: ignore[attr-defined]\n    'class': docutils.parsers.rst.directives.class_option,\n    'language': docutils.parsers.rst.directives.unchanged,\n}\n\n\nspecific_docroles: dict[str, RoleFunction] = {\n    # links to download references\n    'download': XRefRole(nodeclass=addnodes.download_reference),\n    # links to anything\n    'any': AnyXRefRole(warn_dangling=True),\n    # external links\n    'cve': CVE(),\n    'cwe': CWE(),\n    'pep': PEP(),\n    'rfc': RFC(),\n    # emphasised things\n    'guilabel': GUILabel(),\n    'menuselection': MenuSelection(),\n    'file': EmphasizedLiteral(),\n    'samp': EmphasizedLiteral(),\n    # other\n    'abbr': Abbreviation(),\n    'kbd': Keyboard(),\n    'manpage': Manpage(),\n}\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    from docutils.parsers.rst import roles\n\n    for rolename, nodeclass in generic_docroles.items():\n        generic = roles.GenericRole(rolename, nodeclass)\n        role = roles.CustomRole(rolename, generic, {'classes': [rolename]})  # type: ignore[arg-type]\n        roles.register_local_role(rolename, role)  # type: ignore[arg-type]\n\n    for rolename, func in specific_docroles.items():\n        roles.register_local_role(rolename, func)  # type: ignore[arg-type]\n\n    # Since docutils registers it as a canonical role, override it as a\n    # canonical role as well.\n    roles.register_canonical_role('code', code_role)  # type: ignore[arg-type]\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    target_node = nodes.target(ids=node_ids)\n                self.set_source_info(target_node)\n                return [self.indexnode, target_node]\n            return [self.indexnode]\n        return [self.indexnode, node]\n\n\nclass DefaultRole(SphinxDirective):\n    \"\"\"Set the default interpreted text role.  Overridden from docutils.\"\"\"\n\n    optional_arguments = 1\n    final_argument_whitespace = False\n\n    def run(self) -> list[Node]:\n        if not self.arguments:\n            docutils.unregister_role('')\n            return []\n        role_name = self.arguments[0]\n        role, messages = roles.role(\n            role_name, self.state_machine.language, self.lineno, self.state.reporter\n        )\n        if role:\n            docutils.register_role('', role)  # type: ignore[arg-type]\n            self.env.current_document.default_role = role_name\n        else:\n            literal_block = nodes.literal_block(self.block_text, self.block_text)\n            reporter = self.state.reporter\n            error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_direct"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ext.todo import todo_node\n    from sphinx.extension import Extension\n    from sphinx.registry import (\n        _MathsBlockRenderers,\n        _MathsInlineRenderers,\n        _NodeHandler,\n        _NodeHandlerPair,\n    )\n    from sphinx.roles import XRefRole\n    from sphinx.search import SearchLanguage\n    from sphinx.theming import Theme\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import RoleFunction, TitleGetter\n\n\nbuiltin_extensions: tuple[str, ...] = (\n    'sphinx.addnodes',\n    'sphinx.builders.changes',\n    'sphinx.builders.epub3',\n    'sphinx.builders.dirhtml',\n    'sphinx.builders.dummy',\n    'sphinx.builders.gettext',\n    'sphinx.builders.html',\n    'sphinx.builders.latex',\n    'sphinx.builders.linkcheck',\n    'sphinx.builders.manpage',\n    'sphinx.builders.singlehtml',\n    'sphinx.builders.texinfo',\n    'sphinx.builders.text',\n    'sphinx.builders.xml',\n    'sphinx.config',\n    'sphinx.domains.c',\n    'sphinx.domains.changeset',\n    'sphinx.domains.citation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environme"}, {"start_line": 14000, "end_line": 15372, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_directive('default-domain', DefaultDomain)\n    directives.register_directive('describe', ObjectDescription)\n    # new, more consistent, name\n    directives.register_directive('object', ObjectDescription)\n\n    app.add_event('object-description-transform')\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n\n        element = self.domains.standard_domain.directive(name)\n        if element is not None:\n            return element, []\n\n        return super().directive(directive_name, language_module, document)\n\n    def role(\n        self,\n        role_name: str,\n        language_module: ModuleType,\n        lineno: int,\n        reporter: Reporter,\n    ) -> tuple[RoleFunction, list[system_message]]:\n        \"\"\"Lookup a role, given its name which can include a domain.\"\"\"\n        role_name = role_name.lower()\n        # explicit domain given?\n        if ':' in role_name:\n            domain_name, _, name = role_name.partition(':')\n            try:\n                domain = self.domains[domain_name]\n            except KeyError:\n                logger.warning(__('unknown role name: %s'), role_name)\n            else:\n                element = domain.role(name)\n                if element is not None:\n                    return element, []\n        # else look in the default domain\n        else:\n            name = role_name\n            default_domain = self.current_document.default_domain\n            if default_domain is not None:\n                element = default_domain.role(name)\n                if element is not None:\n                    return element, []\n\n        # always look in the std domain\n        element = self.domains.standard_domain.role(name)\n        if element is not None:\n            return element, []\n\n        return super().role(role_name, language_module, lineno, reporter)\n\n\nclass WarningStream:\n    def write(self, text: str) -> None:\n        matched = report_re.search(text)\n        if not matched:\n            logger.warning(text.rstrip('\\r\\n'), type='docutils')\n        else:\n            location, type, _level = matched.groups()\n            message = report_re.sub('', text).rstrip()\n            logger.log(type, message, location=location, type='docutils')\n\n\nclass LoggingReporter(Reporter):\n    @classmethod\n    def from_reporter(\n        cls: type[LoggingReporter], "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "roles.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Handlers for additional ReST roles.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import TYPE_CHECKING\n\nimport docutils.parsers.rst.directives\nimport docutils.parsers.rst.roles\nimport docutils.parsers.rst.states\nfrom docutils import nodes, utils\n\nfrom sphinx import addnodes\nfrom sphinx.locale import _, __\nfrom sphinx.util import ws_re\nfrom sphinx.util.docutils import ReferenceRole, SphinxRole\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n    from typing import Any, Final\n\n    from docutils.nodes import Element, Node, TextElement, system_message\n\n    from sphinx.application import Sphinx\n    from sphinx.environment import BuildEnvironment\n    from sphinx.util.typing import ExtensionMetadata, RoleFunction\n\n\ngeneric_docroles = {\n    'command': addnodes.literal_strong,\n    'dfn': nodes.emphasis,\n    'mailheader': addnodes.literal_emphasis,\n    'makevar': addnodes.literal_strong,\n    'mimetype': addnodes.literal_emphasis,\n    'newsgroup': addnodes.literal_emphasis,\n    'program': addnodes.literal_strong,  # XXX should be an x-ref\n    'regexp': nodes.literal,\n}\n\n\n# -- generic cross-reference role ----------------------------------------------\n\n\nclass XRefRole(ReferenceRole):\n    \"\"\"A generic cross-referencing role.  To create a callable that can be used as\n    a role function, create an instance of this class.\n\n    The general features of this role are:\n\n    * Automatic creation of a reference and a content node.\n    * Optional separation of title and target with `title <target>`.\n    * The implementation is a class rather than a function to make\n      customization easier.\n\n    Customization can be done in two ways:\n\n    * Supplying constructor parameters:\n      * `fix_parens` to normalize parentheses (strip from target, and add to\n        title if configured)\n      * `lowercase` to lowercase the target\n      * `nodeclass` and `innernodeclass` select the node classes for\n        the reference and the content node\n\n    * Subclassing and ov"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "typing.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "descriptor'): 'types.WrapperDescriptorType',\n    # types from 'weakref':\n    ('_weakrefset', 'WeakSet'): 'weakref.WeakSet',\n    # types from 'zipfile':\n    ('zipfile._path', 'CompleteDirs'): 'zipfile.CompleteDirs',\n    ('zipfile._path', 'Path'): 'zipfile.Path',\n}\n\n\ndef is_invalid_builtin_class(obj: Any) -> str:\n    \"\"\"Check *obj* is an invalid built-in class.\"\"\"\n    try:\n        key = obj.__module__, obj.__qualname__\n    except AttributeError:  # non-standard type\n        return ''\n    return _INVALID_BUILTIN_CLASSES.get(key, '')\n\n\n# Text like nodes which are initialized with text and rawsource\nTextlikeNode: TypeAlias = nodes.Text | nodes.TextElement\n\n# path matcher\nPathMatcher: TypeAlias = Callable[[str], bool]\n\n# common role functions\nif TYPE_CHECKING:\n\n    class RoleFunction(Protocol):\n        def __call__(\n            self,\n            name: str,\n            rawtext: str,\n            text: str,\n            lineno: int,\n            inliner: Inliner,\n            /,\n            options: dict[str, Any] | None = None,\n            content: Sequence[str] = (),\n        ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...\n\nelse:\n    RoleFunction: TypeAlias = Callable[\n        [str, str, str, int, Inliner, dict[str, typing.Any], Sequence[str]],\n        tuple[list[nodes.Node], list[nodes.system_message]],\n    ]\n\n# A option spec for directive\nOptionSpec: TypeAlias = dict[str, Callable[[str], typing.Any]]\n\n# title getter functions for enumerable nodes (see sphinx.domains.std)\nTitleGetter: TypeAlias = Callable[[nodes.Node], str]\n\n# inventory data on memory\nInventory: TypeAlias = dict[str, dict[str, '_InventoryItem']]\n\n\nclass ExtensionMetadata(typing.TypedDict, total=False):\n    \"\"\"The metadata returned by an extension's ``setup()`` function.\n\n    See :ref:`ext-metadata`.\n    \"\"\"\n\n    version: str\n    \"\"\"The extension version (default: ``'unknown version'``).\"\"\"\n    env_version: int\n    \"\"\"An integer that identifies the version of env data added by the extension.\"\"\"\n "}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "_resolve.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/intersphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "es) == 2:\n            # domain:role:\n            domain_name, role = names\n        else:\n            return None\n\n        if domain_name and self.is_existent_role(domain_name, role):\n            return domain_name, role\n        elif self.is_existent_role('std', role):\n            return 'std', role\n        else:\n            return None\n\n    def is_existent_role(self, domain_name: str, role_name: str) -> bool:\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.is_existent_role', '', remove=(9, 0)\n        )\n        try:\n            domain = self.env.domains[domain_name]\n        except KeyError:\n            return False\n        else:\n            return role_name in domain.roles\n\n    def invoke_role(\n        self, role: tuple[str, str]\n    ) -> tuple[list[Node], list[system_message]]:\n        \"\"\"Invoke the role described by a ``(domain, role name)`` pair.\"\"\"\n        _deprecation_warning(\n            __name__, f'{self.__class__.__name__}.invoke_role', '', remove=(9, 0)\n        )\n        domain = self.env.get_domain(role[0])\n        if domain:\n            role_func = domain.role(role[1])\n            assert role_func is not None\n\n            return role_func(\n                ':'.join(role),\n                self.rawtext,\n                self.text,\n                self.lineno,\n                self.inliner,\n                self.options,\n                self.content,\n            )\n        else:\n            return [], []\n\n\nclass IntersphinxRoleResolver(ReferencesResolver):\n    \"\"\"pending_xref node resolver for intersphinx role.\n\n    This resolves pending_xref nodes generated by :intersphinx:***: role.\n    \"\"\"\n\n    default_priority = ReferencesResolver.default_priority - 1\n\n    def run(self, **kwargs: Any) -> None:\n        for node in self.document.findall(pending_xref):\n            if 'intersphinx' not in node:\n                continue\n            contnode = cast('nodes.TextElement', node[0].deepcopy())\n            inv_name = node['inventory']\n     "}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     #: The interpreted text content.\n    lineno: int       #: The line number where the interpreted text begins.\n    inliner: Inliner  #: The ``docutils.parsers.rst.states.Inliner`` object.\n    #: A dictionary of directive options for customisation\n    #: (from the \"role\" directive).\n    options: dict[str, Any]\n    #: A list of strings, the directive content for customisation\n    #: (from the \"role\" directive).\n    content: Sequence[str]\n    # fmt: on\n\n    def __call__(\n        self,\n        name: str,\n        rawtext: str,\n        text: str,\n        lineno: int,\n        inliner: Inliner,\n        options: dict[str, Any] | None = None,\n        content: Sequence[str] = (),\n    ) -> tuple[list[Node], list[system_message]]:\n        self.rawtext = rawtext\n        self.text = unescape(text)\n        self.lineno = lineno\n        self.inliner = inliner\n        self.options = options if options is not None else {}\n        self.content = content\n\n        # guess role type\n        if name:\n            self.name = name.lower()\n        else:\n            self.name = self.env.current_document.default_role\n            if not self.name:\n                self.name = self.env.config.default_role\n            if not self.name:\n                msg = 'cannot determine default role!'\n                raise SphinxError(msg)\n\n        return self.run()\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        raise NotImplementedError\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.inliner.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.env.config\n\n    def get_source_info(self, lineno: int | None = None) -> tuple[str, int]:\n        # .. versionadded:: 3.0\n        if lineno is None:\n            lineno = self.lineno\n   "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "docutils.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.name = name.lower()\n        else:\n            self.name = self.env.current_document.default_role\n            if not self.name:\n                self.name = self.env.config.default_role\n            if not self.name:\n                msg = 'cannot determine default role!'\n                raise SphinxError(msg)\n\n        return self.run()\n\n    def run(self) -> tuple[list[Node], list[system_message]]:\n        raise NotImplementedError\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.inliner.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self.env.config\n\n    def get_source_info(self, lineno: int | None = None) -> tuple[str, int]:\n        # .. versionadded:: 3.0\n        if lineno is None:\n            lineno = self.lineno\n        return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore[attr-defined]\n\n    def set_source_info(self, node: Node, lineno: int | None = None) -> None:\n        # .. versionadded:: 2.0\n        node.source, node.line = self.get_source_info(lineno)\n\n    def get_location(self) -> str:\n        \"\"\"Get current location info for logging.\n\n        .. versionadded:: 4.2\n        \"\"\"\n        source, line = self.get_source_info()\n        if source and line:\n            return f'{source}:{line}'\n        if source:\n            return f'{source}:'\n        if line:\n            return f'<unknown>:{line}'\n        return ''\n\n\nclass ReferenceRole(SphinxRole):\n    \"\"\"A base class for reference roles.\n\n    The reference roles can accept ``link title <target>`` style as a text for\n    the role.  The parsed result; link title and target will be stored to\n    ``self.title`` and ``self.target``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    # fmt: off\n    has_explicit_title: bool    #: A boolean ind"}], "retrieved_count": 10, "cost_time": 0.33306336402893066}
{"question": "Where are the default configuration values defined in Sphinx's source code?", "answer": null, "relative_code_list": null, "ground_truth": "The default configuration values in Sphinx's source code are primarily defined in the sphinx/config.py module, specifically in the Config class. This is where the comprehensive configuration system is implemented with all the default values for Sphinx's various settings.\n\nKey locations where default configuration values are defined include:\n\n1. **sphinx/config.py**: The main location where default configuration values are defined. The Config class contains a `config_values` dictionary that defines all available configuration options with their default values, rebuild requirements, and valid types. This includes settings for project information, build options, output formatting, extension settings, and many other configuration parameters.\n\n2. **sphinx/application.py**: Contains some configuration-related defaults, particularly for built-in extensions and their initialization order.\n\n3. **sphinx/builders/__init__.py**: Contains default configuration values specific to builders, such as default builder settings and builder-specific options.\n\n4. **sphinx/theming.py**: Contains default theme-related configuration values and theme system settings.\n\n5. **sphinx/environment/__init__.py**: Contains default environment settings and configuration values related to the build environment.\n\n6. **sphinx/ext/**: Various extension modules contain their own default configuration values, which are typically defined within the extension's setup function or configuration handling code.\n\n7. **sphinx/domains/**: Domain-specific configuration defaults are defined within each domain implementation, particularly for domain-specific settings and object type configurations.\n\nThe configuration system uses a structured approach where each configuration option is defined with metadata including the default value, what needs to be rebuilt if the value changes, valid types for the value, and a description. This system allows for comprehensive configuration management while providing sensible defaults for all Sphinx features.", "score": null, "retrieved_content": [{"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "], 'env', frozenset((list, tuple))),\n        'show_warning_types': _Opt(True, 'env', frozenset((bool,))),\n        'modindex_common_prefix': _Opt([], 'html', frozenset((list, tuple))),\n        'rst_epilog': _Opt(None, 'env', frozenset((str,))),\n        'rst_prolog': _Opt(None, 'env', frozenset((str,))),\n        'trim_doctest_flags': _Opt(True, 'env', frozenset((bool,))),\n        'primary_domain': _Opt('py', 'env', frozenset((types.NoneType,))),\n        'needs_sphinx': _Opt(None, '', frozenset((str,))),\n        'needs_extensions': _Opt({}, '', frozenset((dict,))),\n        'manpages_url': _Opt(None, 'env', frozenset((str, types.NoneType))),\n        'nitpicky': _Opt(False, '', frozenset((bool,))),\n        'nitpick_ignore': _Opt([], '', frozenset((set, list, tuple))),\n        'nitpick_ignore_regex': _Opt([], '', frozenset((set, list, tuple))),\n        'numfig': _Opt(False, 'env', frozenset((bool,))),\n        'numfig_secnum_depth': _Opt(1, 'env', frozenset((int, types.NoneType))),\n        # numfig_format will be initialized in init_numfig_format()\n        'numfig_format': _Opt({}, 'env', frozenset((dict,))),\n        'maximum_signature_line_length': _Opt(\n            None, 'env', frozenset((int, types.NoneType))\n        ),\n        'math_number_all': _Opt(False, 'env', frozenset((bool,))),\n        'math_eqref_format': _Opt(None, 'env', frozenset((str,))),\n        'math_numfig': _Opt(True, 'env', frozenset((bool,))),\n        'math_numsep': _Opt('.', 'env', frozenset((str,))),\n        'tls_verify': _Opt(True, 'env', frozenset((bool,))),\n        'tls_cacerts': _Opt(None, 'env', frozenset((str, dict, types.NoneType))),\n        'user_agent': _Opt(None, 'env', frozenset((str,))),\n        'smartquotes': _Opt(True, 'env', frozenset((bool,))),\n        'smartquotes_action': _Opt('qDe', 'env', frozenset((str,))),\n        'smartquotes_excludes': _Opt(\n            {'languages': ['ja', 'zh_CN', 'zh_TW'], 'builders': ['man', 'text']},\n            'env',\n            frozenset((dict,)),\n   "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", 'env', frozenset((str,))),\n        'default_role': _Opt(None, 'env', frozenset((str,))),\n        'add_function_parentheses': _Opt(True, 'env', frozenset((bool,))),\n        'add_module_names': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries_show_parents': _Opt(\n            'domain', 'env', ENUM('domain', 'all', 'hide')\n        ),\n        'trim_footnote_reference_space': _Opt(False, 'env', frozenset((bool,))),\n        'show_authors': _Opt(False, 'env', frozenset((bool,))),\n        'pygments_style': _Opt(None, 'html', frozenset((str,))),\n        'highlight_language': _Opt('default', 'env', frozenset((str,))),\n        'highlight_options': _Opt({}, 'env', frozenset((dict,))),\n        'templates_path': _Opt([], 'html', frozenset((list,))),\n        'template_bridge': _Opt(None, 'html', frozenset((str,))),\n        'keep_warnings': _Opt(False, 'env', frozenset((bool,))),\n        'suppress_warnings': _Opt([], 'env', frozenset((list, tuple))),\n        'show_warning_types': _Opt(True, 'env', frozenset((bool,))),\n        'modindex_common_prefix': _Opt([], 'html', frozenset((list, tuple))),\n        'rst_epilog': _Opt(None, 'env', frozenset((str,))),\n        'rst_prolog': _Opt(None, 'env', frozenset((str,))),\n        'trim_doctest_flags': _Opt(True, 'env', frozenset((bool,))),\n        'primary_domain': _Opt('py', 'env', frozenset((types.NoneType,))),\n        'needs_sphinx': _Opt(None, '', frozenset((str,))),\n        'needs_extensions': _Opt({}, '', frozenset((dict,))),\n        'manpages_url': _Opt(None, 'env', frozenset((str, types.NoneType))),\n        'nitpicky': _Opt(False, '', frozenset((bool,))),\n        'nitpick_ignore': _Opt([], '', frozenset((set, list, tuple))),\n        'nitpick_ignore_regex': _Opt([], '', frozenset((set, list, tuple))),\n        'numfig': _Opt(False, 'env', frozenset((bool,))),\n        'numfig_secnum_depth': _Opt(1, 'env', frozenset((int, types.NoneType))),\n        # "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "of :confval:`language`, use either\n    ``app.config.language`` or ``env.config.language``.\n    \"\"\"\n\n    # The values are:\n    # 1. Default\n    # 2. What needs to be rebuilt if changed\n    # 3. Valid types\n\n    # If you add a value here, remember to include it in the docs!\n\n    config_values: dict[str, _Opt] = {\n        # general options\n        'project': _Opt('Project name not set', 'env', frozenset((str,))),\n        'author': _Opt('Author name not set', 'env', frozenset((str,))),\n        'project_copyright': _Opt('', 'html', frozenset((str, tuple, list))),\n        'copyright': _Opt(\n            lambda config: config.project_copyright,\n            'html',\n            frozenset((str, tuple, list)),\n        ),\n        'version': _Opt('', 'env', frozenset((str,))),\n        'release': _Opt('', 'env', frozenset((str,))),\n        'today': _Opt('', 'env', frozenset((str,))),\n        # the real default is locale-dependent\n        'today_fmt': _Opt(None, 'env', frozenset((str,))),\n        'language': _Opt('en', 'env', frozenset((str,))),\n        'locale_dirs': _Opt(['locales'], 'env', frozenset((list, tuple))),\n        'figure_language_filename': _Opt(\n            '{root}.{language}{ext}', 'env', frozenset((str,))\n        ),\n        'gettext_allow_fuzzy_translations': _Opt(False, 'gettext', frozenset((bool,))),\n        'translation_progress_classes': _Opt(\n            False, 'env', ENUM(True, False, 'translated', 'untranslated')\n        ),\n        'master_doc': _Opt('index', 'env', frozenset((str,))),\n        'root_doc': _Opt(lambda config: config.master_doc, 'env', frozenset((str,))),\n        # ``source_suffix`` type is actually ``dict[str, str | None]``:\n        # see ``convert_source_suffix()`` below.\n        'source_suffix': _Opt({'.rst': 'restructuredtext'}, 'env', Any),  # type: ignore[arg-type]\n        'source_encoding': _Opt('utf-8-sig', 'env', frozenset((str,))),\n        'exclude_patterns': _Opt([], 'env', frozenset((str,))),\n        'include_patterns': _Opt(['**']"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "guage': _Opt('en', 'env', frozenset((str,))),\n        'locale_dirs': _Opt(['locales'], 'env', frozenset((list, tuple))),\n        'figure_language_filename': _Opt(\n            '{root}.{language}{ext}', 'env', frozenset((str,))\n        ),\n        'gettext_allow_fuzzy_translations': _Opt(False, 'gettext', frozenset((bool,))),\n        'translation_progress_classes': _Opt(\n            False, 'env', ENUM(True, False, 'translated', 'untranslated')\n        ),\n        'master_doc': _Opt('index', 'env', frozenset((str,))),\n        'root_doc': _Opt(lambda config: config.master_doc, 'env', frozenset((str,))),\n        # ``source_suffix`` type is actually ``dict[str, str | None]``:\n        # see ``convert_source_suffix()`` below.\n        'source_suffix': _Opt({'.rst': 'restructuredtext'}, 'env', Any),  # type: ignore[arg-type]\n        'source_encoding': _Opt('utf-8-sig', 'env', frozenset((str,))),\n        'exclude_patterns': _Opt([], 'env', frozenset((str,))),\n        'include_patterns': _Opt(['**'], 'env', frozenset((str,))),\n        'default_role': _Opt(None, 'env', frozenset((str,))),\n        'add_function_parentheses': _Opt(True, 'env', frozenset((bool,))),\n        'add_module_names': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries': _Opt(True, 'env', frozenset((bool,))),\n        'toc_object_entries_show_parents': _Opt(\n            'domain', 'env', ENUM('domain', 'all', 'hide')\n        ),\n        'trim_footnote_reference_space': _Opt(False, 'env', frozenset((bool,))),\n        'show_authors': _Opt(False, 'env', frozenset((bool,))),\n        'pygments_style': _Opt(None, 'html', frozenset((str,))),\n        'highlight_language': _Opt('default', 'env', frozenset((str,))),\n        'highlight_options': _Opt({}, 'env', frozenset((dict,))),\n        'templates_path': _Opt([], 'html', frozenset((list,))),\n        'template_bridge': _Opt(None, 'html', frozenset((str,))),\n        'keep_warnings': _Opt(False, 'env', frozenset((bool,))),\n        'suppress_warnings': _Opt(["}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      default, rebuild, valid_types, description = state\n        super().__setattr__('default', default)\n        super().__setattr__('rebuild', rebuild)\n        super().__setattr__('valid_types', valid_types)\n        super().__setattr__('description', description)\n\n    def __getitem__(self, item: int | slice) -> Any:\n        warnings.warn(\n            f'The {self.__class__.__name__!r} object tuple interface is deprecated, '\n            \"use attribute access instead for 'default', 'rebuild', and 'valid_types'.\",\n            RemovedInSphinx90Warning,\n            stacklevel=2,\n        )\n        return (self.default, self.rebuild, self.valid_types)[item]\n\n\nclass Config:\n    r\"\"\"Configuration file abstraction.\n\n    The Config object makes the values of all config options available as\n    attributes.\n\n    It is exposed via the :py:class:`~sphinx.application.Sphinx`\\ ``.config``\n    and :py:class:`sphinx.environment.BuildEnvironment`\\ ``.config`` attributes.\n    For example, to get the value of :confval:`language`, use either\n    ``app.config.language`` or ``env.config.language``.\n    \"\"\"\n\n    # The values are:\n    # 1. Default\n    # 2. What needs to be rebuilt if changed\n    # 3. Valid types\n\n    # If you add a value here, remember to include it in the docs!\n\n    config_values: dict[str, _Opt] = {\n        # general options\n        'project': _Opt('Project name not set', 'env', frozenset((str,))),\n        'author': _Opt('Author name not set', 'env', frozenset((str,))),\n        'project_copyright': _Opt('', 'html', frozenset((str, tuple, list))),\n        'copyright': _Opt(\n            lambda config: config.project_copyright,\n            'html',\n            frozenset((str, tuple, list)),\n        ),\n        'version': _Opt('', 'env', frozenset((str,))),\n        'release': _Opt('', 'env', frozenset((str,))),\n        'today': _Opt('', 'env', frozenset((str,))),\n        # the real default is locale-dependent\n        'today_fmt': _Opt(None, 'env', frozenset((str,))),\n        'lan"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_config", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pt\n\n    with pytest.warns(RemovedInSphinx90Warning):\n        _ = opt[0]\n\n    with pytest.warns(RemovedInSphinx90Warning):\n        _ = list(opt)\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='config',\n    confoverrides={\n        'root_doc': 'root',\n        'nonexisting_value': 'True',\n        'latex_elements.maketitle': 'blah blah blah',\n        'modindex_common_prefix': 'path1,path2',\n    },\n)\ndef test_core_config(app: SphinxTestApp) -> None:\n    cfg = app.config\n\n    # simple values\n    assert 'project' in cfg.__dict__\n    assert cfg.project == 'Sphinx <Tests>'\n    assert cfg.templates_path == ['_templates']\n\n    # overrides\n    assert cfg.root_doc == 'root'\n    assert cfg.latex_elements['maketitle'] == 'blah blah blah'\n    assert cfg.modindex_common_prefix == ['path1', 'path2']\n\n    # simple default values\n    assert 'locale_dirs' in cfg.__dict__\n    assert cfg.locale_dirs == ['locales']\n    assert cfg.trim_footnote_reference_space is False\n\n    # complex default values\n    assert 'html_title' not in cfg.__dict__\n    assert cfg.html_title == 'Sphinx <Tests> 0.6alpha1 documentation'\n\n    # complex default values mustn't raise\n    for valuename in cfg.config_values:\n        getattr(cfg, valuename)\n\n    # \"contains\" gives True both for set and unset values\n    assert 'project' in cfg\n    assert 'html_title' in cfg\n    assert 'nonexisting_value' not in cfg\n\n    # invalid values\n    with pytest.raises(AttributeError):\n        _ = cfg._value\n    with pytest.raises(AttributeError):\n        _ = cfg.nonexisting_value\n\n    # non-value attributes are deleted from the namespace\n    with pytest.raises(AttributeError):\n        _ = cfg.sys\n\n    # setting attributes\n    cfg.project = 'Foo'\n    assert cfg.project == 'Foo'\n\n    # alternative access via item interface\n    cfg['project'] = 'Sphinx Tests'\n    assert cfg['project'] == cfg.project == 'Sphinx Tests'\n\n\ndef test_config_not_found(tmp_path):\n    with pytest.raises(ConfigError):\n        Config.read(tmp_path, overrides={}, t"}, {"start_line": 57000, "end_line": 59000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dd_config_value(\n        'html_title',\n        lambda c: _('%s %s documentation') % (c.project, c.release),\n        'html',\n        types=frozenset({str}),\n    )\n    app.add_config_value(\n        'html_short_title', lambda self: self.html_title, 'html', types=frozenset({str})\n    )\n    app.add_config_value(\n        'html_style', None, 'html', types=frozenset({list, str, tuple})\n    )\n    app.add_config_value('html_logo', None, 'html', types=frozenset({str}))\n    app.add_config_value('html_favicon', None, 'html', types=frozenset({str}))\n    app.add_config_value('html_css_files', [], 'html', types=frozenset({list, tuple}))\n    app.add_config_value('html_js_files', [], 'html', types=frozenset({list, tuple}))\n    app.add_config_value('html_static_path', [], 'html', types=frozenset({list, tuple}))\n    app.add_config_value('html_extra_path', [], 'html', types=frozenset({list, tuple}))\n    app.add_config_value('html_last_updated_fmt', None, 'html', types=frozenset({str}))\n    app.add_config_value(\n        'html_last_updated_use_utc', False, 'html', types=frozenset({bool})\n    )\n    app.add_config_value('html_sidebars', {}, 'html', types=frozenset({dict}))\n    app.add_config_value('html_additional_pages', {}, 'html', types=frozenset({dict}))\n    app.add_config_value(\n        'html_domain_indices',\n        True,\n        'html',\n        types=frozenset({frozenset, list, set, tuple}),\n    )\n    app.add_config_value('html_permalinks', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_permalinks_icon', '', 'html', types=frozenset({str}))\n    app.add_config_value('html_use_index', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_split_index', False, 'html', types=frozenset({bool}))\n    app.add_config_value('html_copy_source', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_show_sourcelink', True, 'html', types=frozenset({bool}))\n    app.add_config_value(\n        'html_sourcelink_suffix', '.txt', 'html', types=frozens"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "config.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dividual elements)'\n                )\n                % (name, f'{name}.key=value')\n            )\n        if isinstance(default, list):\n            return value.split(',')\n        if isinstance(default, int):\n            try:\n                return int(value)\n            except ValueError as exc:\n                raise ValueError(\n                    __('invalid number %r for config value %r, ignoring')\n                    % (value, name)\n                ) from exc\n        if callable(default):\n            return value\n        if isinstance(default, str) or default is None:\n            return value\n        raise ValueError(\n            __('cannot override config setting %r with unsupported type, ignoring')\n            % name\n        )\n\n    @staticmethod\n    def pre_init_values() -> None:\n        # method only retained for compatibility\n        pass\n        # warnings.warn(\n        #     'Config.pre_init_values() will be removed in Sphinx 9.0 or later',\n        #     RemovedInSphinx90Warning, stacklevel=2)\n\n    def init_values(self) -> None:\n        # method only retained for compatibility\n        self._report_override_warnings()\n        # warnings.warn(\n        #     'Config.init_values() will be removed in Sphinx 9.0 or later',\n        #     RemovedInSphinx90Warning, stacklevel=2)\n\n    def _report_override_warnings(self) -> None:\n        for name in self._overrides:\n            if name not in self._options:\n                logger.warning(\n                    __('unknown config value %r in override, ignoring'), name\n                )\n\n    def __repr__(self) -> str:\n        values = []\n        for opt_name in self._options:\n            try:\n                opt_value = getattr(self, opt_name)\n            except Exception:\n                opt_value = '<error!>'\n            values.append(f'{opt_name}={opt_value!r}')\n        return self.__class__.__qualname__ + '(' + ', '.join(values) + ')'\n\n    def __setattr__(self, key: str, value: object) -> None:\n        # Ensure alia"}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "alue(\n        'html_last_updated_use_utc', False, 'html', types=frozenset({bool})\n    )\n    app.add_config_value('html_sidebars', {}, 'html', types=frozenset({dict}))\n    app.add_config_value('html_additional_pages', {}, 'html', types=frozenset({dict}))\n    app.add_config_value(\n        'html_domain_indices',\n        True,\n        'html',\n        types=frozenset({frozenset, list, set, tuple}),\n    )\n    app.add_config_value('html_permalinks', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_permalinks_icon', '', 'html', types=frozenset({str}))\n    app.add_config_value('html_use_index', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_split_index', False, 'html', types=frozenset({bool}))\n    app.add_config_value('html_copy_source', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_show_sourcelink', True, 'html', types=frozenset({bool}))\n    app.add_config_value(\n        'html_sourcelink_suffix', '.txt', 'html', types=frozenset({str})\n    )\n    app.add_config_value('html_use_opensearch', '', 'html', types=frozenset({str}))\n    app.add_config_value('html_file_suffix', None, 'html', types=frozenset({str}))\n    app.add_config_value('html_link_suffix', None, 'html', types=frozenset({str}))\n    app.add_config_value('html_show_copyright', True, 'html', types=frozenset({bool}))\n    app.add_config_value(\n        'html_show_search_summary', True, 'html', types=frozenset({bool})\n    )\n    app.add_config_value('html_show_sphinx', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_context', {}, 'html', types=frozenset({dict}))\n    app.add_config_value(\n        'html_output_encoding', 'utf-8', 'html', types=frozenset({str})\n    )\n    app.add_config_value('html_compact_lists', True, 'html', types=frozenset({bool}))\n    app.add_config_value('html_secnumber_suffix', '. ', 'html', types=frozenset({str}))\n    app.add_config_value('html_search_language', None, 'html', types=frozenset({str}))\n    app.add_co"}, {"start_line": 0, "end_line": 256, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-ext-ifconfig", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "extensions = ['sphinx.ext.ifconfig']\nexclude_patterns = ['_build']\n\nconfval1 = True\n\n\ndef setup(app):\n    app.add_config_value('confval1', False, None)\n    app.add_config_value('confval2', False, None)\n    app.add_config_value('false_config', False, None)\n"}], "retrieved_count": 10, "cost_time": 0.33872437477111816}
{"question": "How does Sphinx implement its document building system?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements its document building system through a sophisticated multi-phase architecture that coordinates various components to transform source documents into finished output. The system is designed to be modular, extensible, and efficient.\n\nThe document building system works through the following key mechanisms:\n\n1. **Multi-Phase Build Process**: Sphinx uses a structured build process with distinct phases: initialization, reading, consistency checking, resolving, and writing. Each phase has specific responsibilities and can be extended through the event system.\n\n2. **Builder Pattern**: The system uses a Builder pattern where different builder classes handle specific output formats (HTML, LaTeX, PDF, etc.). Each builder implements the core build workflow while providing format-specific functionality.\n\n3. **Component Registry**: The SphinxComponentRegistry manages all build components including parsers, transforms, builders, domains, and extensions. This provides a centralized system for component discovery and registration.\n\n4. **Event-Driven Architecture**: The build process is orchestrated through an event system that allows extensions to hook into various stages of the build. Events like 'config-inited', 'builder-inited', 'doctree-read', and 'doctree-resolved' provide extension points.\n\n5. **Document Tree Processing**: Source documents are parsed into docutils document trees, which are then processed through various transforms that handle cross-references, indexing, and other modifications.\n\n6. **Environment Management**: The BuildEnvironment class maintains the state of the build, including cross-references, metadata, and document relationships. This environment is serialized between builds for incremental build support.\n\n7. **Domain System**: Specialized domains (Python, C++, etc.) provide domain-specific functionality for object descriptions, cross-references, and indexing.\n\n8. **Transform Pipeline**: Document trees are processed through a series of transforms that handle various aspects of document processing, from cross-reference resolution to output-specific modifications.\n\n9. **Caching and Incremental Builds**: The system implements sophisticated caching mechanisms that allow for efficient incremental builds by only processing changed files.\n\n10. **Parallel Processing**: The system supports parallel document processing to improve build performance on multi-core systems.\n\nThis architecture provides the flexibility and performance needed to handle complex documentation projects while maintaining extensibility through the extension system.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 163, "belongs_to": {"file_name": "__main__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"The Sphinx documentation toolchain.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nfrom sphinx.cmd.build import main\n\nraise SystemExit(main(sys.argv[1:]))\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(\n        self,\n        srcdir: str | os.PathLike[str],\n        confdir: str | os.PathLike[str] | None,\n        outdir: str | os.PathLike[str],\n        doctreedir: str | os.PathLike[str],\n        buildername: str,\n        confoverrides: dict[str, Any] | None = None,\n        status: IO[str] | None = sys.stdout,\n        warning: IO[str] | None = sys.stderr,\n        freshenv: bool = False,\n        warningiserror: bool = False,\n        tags: Sequence[str] = (),\n        verbosity: int = 0,\n        parallel: int = 0,\n        keep_going: bool = False,\n        pdb: bool = False,\n        exception_on_warning: bool = False,\n    ) -> None:\n        \"\"\"Initialize the Sphinx application.\n\n        :param srcdir: The path to the source directory.\n        :param confdir: The path to the configuration directory.\n            If not given, it is assumed to be the same as ``srcdir``.\n        :param outdir: Directory for storing build documents.\n        :param doctreedir:"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self.post_transforms: list[type[Transform]] = []\n\n        #: source parsers; file type -> parser class\n        self.source_parsers: dict[str, type[Parser]] = {}\n\n        #: source suffix: suffix -> file type\n        self.source_suffix: dict[str, str] = {}\n\n        #: custom translators; builder name -> translator class\n        self.translators: dict[str, type[nodes.NodeVisitor]] = {}\n\n        #: custom handlers for translators\n        #: a dict of builder name -> dict of node name -> visitor and departure functions\n        self.translation_handlers: dict[str, dict[str, _NodeHandlerPair]] = {}\n\n        #: additional transforms; list of transforms\n        self.transforms: list[type[Transform]] = []\n\n    @property\n    def autodoc_attrgettrs(self) -> dict[type, Callable[[Any, str, Any], Any]]:\n        return self.autodoc_attrgetters\n\n    def add_builder(self, builder: type[Builder], override: bool = False) -> None:\n        logger.debug('[app] adding builder: %r', builder)\n        if not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n   "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "singlehtml.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rents': [],\n            'prev': None,\n            'next': None,\n            'docstitle': None,\n            'title': self.config.html_title,\n            'meta': None,\n            'body': body,\n            'metatags': metatags,\n            'rellinks': [],\n            'sourcename': '',\n            'toc': toc,\n            'display_toc': display_toc,\n        }\n\n    def write_documents(self, _docnames: Set[str]) -> None:\n        self.prepare_writing(self.env.all_docs.keys())\n\n        with progress_message(__('assembling single document'), nonl=False):\n            doctree = self.assemble_doctree()\n            self.env.toc_secnumbers = self.assemble_toc_secnumbers()\n            self.env.toc_fignumbers = self.assemble_toc_fignumbers()\n\n        with progress_message(__('writing')):\n            self.write_doc_serialized(self.config.root_doc, doctree)\n            self.write_doc(self.config.root_doc, doctree)\n\n    def finish(self) -> None:\n        self.write_additional_files()\n        self.copy_image_files()\n        self.copy_download_files()\n        self.copy_static_files()\n        self.copy_extra_files()\n        self.write_buildinfo()\n        self.dump_inventory()\n\n    @progress_message(__('writing additional files'))\n    def write_additional_files(self) -> None:\n        # no indices or search pages are supported\n\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info(' %s', pagename, nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        if self.config.html_use_opensearch:\n            logger.info(' opensearch', nonl=True)\n            self.handle_page(\n                'opensearch',\n                {},\n                'opensearch.xml',\n                outfilename=self._static_dir / 'opensearch.xml',\n            )\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.setup_extension('sphinx.builders.html')\n\n    app.add_builder(SingleFileHTMLBuilder)\n    app.add_config_value(\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 1000, "end_line": 2959, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                yield docname\n                continue\n            targetname = self.outdir / (docname + self.out_suffix)\n            try:\n                targetmtime = _last_modified_time(targetname)\n            except Exception:\n                targetmtime = 0\n            try:\n                srcmtime = _last_modified_time(self.env.doc2path(docname))\n                if srcmtime > targetmtime:\n                    yield docname\n            except OSError:\n                # source doesn't exist anymore\n                pass\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        return ''\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        self.current_docname = docname\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        visitor: TextTranslator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        output = visitor.body\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def finish(self) -> None:\n        pass\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_builder(TextBuilder)\n\n    app.add_config_value('text_sectionchars', '*=-~\"+`', 'env', types=frozenset({str}))\n    app.add_config_value('text_newlines', 'unix', 'env', types=frozenset({str}))\n    app.add_config_value('text_add_secnumbers', True, 'env', types=frozenset({bool}))\n    app.add_config_value('text_secnumber_suffix', '. ', 'env', types=frozenset({str}))\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "build.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/cmd", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Build documentation from a provided source.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport contextlib\nimport locale\nimport multiprocessing\nimport sys\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nimport sphinx._cli.util.errors\nimport sphinx.locale\nfrom sphinx import __display_version__\nfrom sphinx._cli.util.colour import disable_colour, terminal_supports_colour\nfrom sphinx.application import Sphinx\nfrom sphinx.locale import __\nfrom sphinx.util._io import TeeStripANSI\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.docutils import docutils_namespace, patch_docutils\nfrom sphinx.util.osutil import ensuredir\n\nif TYPE_CHECKING:\n    from collections.abc import Collection, Sequence\n    from typing import Any, TextIO\n\n    from sphinx.extension import Extension\n\n\ndef handle_exception(\n    app: Sphinx | None,\n    args: Any,\n    exception: BaseException,\n    stderr: TextIO = sys.stderr,\n) -> None:\n    if app is not None:\n        message_log: Sequence[str] = app.messagelog\n        extensions: Collection[Extension] = app.extensions.values()\n    else:\n        message_log = extensions = ()\n    return sphinx._cli.util.errors.handle_exception(\n        exception,\n        stderr=stderr,\n        use_pdb=args.pdb,\n        print_traceback=args.verbosity or args.traceback,\n        message_log=message_log,\n        extensions=extensions,\n    )\n\n\ndef jobs_argument(value: str) -> int:\n    \"\"\"Parse the ``--jobs`` flag.\n\n    Return the number of CPUs if 'auto' is used,\n    otherwise ensure *value* is a positive integer.\n    \"\"\"\n    if value == 'auto':\n        return multiprocessing.cpu_count()\n    else:\n        jobs = int(value)\n        if jobs <= 0:\n            raise argparse.ArgumentTypeError(\n                __('job number should be a positive number')\n            )\n        else:\n            return jobs\n\n\ndef get_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(\n        usage='%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAME"}, {"start_line": 0, "end_line": 34, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/environment/adapters", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Sphinx environment adapters\"\"\"\n"}], "retrieved_count": 10, "cost_time": 0.33144307136535645}
{"question": "Where are Sphinx's built-in directive implementations located in the codebase?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's built-in directive implementations are located throughout the codebase, organized by functionality and domain. The directives are distributed across multiple modules and directories to provide modularity and domain-specific functionality.\n\nKey locations where built-in directive implementations are located include:\n\n1. **sphinx/directives/**: This directory contains many of Sphinx's built-in directive implementations, organized into subdirectories and files based on functionality. This includes general-purpose directives for document structure and formatting.\n\n2. **sphinx/directives/admonitions.py**: Contains directive implementations for admonitions like note, warning, tip, etc.\n\n3. **sphinx/directives/code.py**: Contains directive implementations for code blocks, literal includes, and other code-related directives.\n\n4. **sphinx/directives/other.py**: Contains various other directive implementations for general document structure and formatting.\n\n5. **sphinx/directives/patches.py**: Contains directive implementations that patch or extend Docutils functionality.\n\n6. **sphinx/domains/**: Domain-specific directive implementations are stored in domain modules, with each domain providing directives specific to that domain's functionality.\n\n7. **sphinx/domains/python.py**: Contains Python domain-specific directive implementations like `py:function`, `py:class`, `py:module`, etc.\n\n8. **sphinx/domains/cpp.py**: Contains C++ domain-specific directive implementations for C++ objects like classes, functions, namespaces, etc.\n\n9. **sphinx/domains/c.py**: Contains C domain-specific directive implementations.\n\n10. **sphinx/domains/js.py**: Contains JavaScript domain-specific directive implementations.\n\n11. **sphinx/domains/rst.py**: Contains reStructuredText domain-specific directive implementations.\n\n12. **sphinx/domains/math.py**: Contains math domain-specific directive implementations.\n\n13. **sphinx/domains/std.py**: Contains standard domain directive implementations for general-purpose directives like `glossary`, `productionlist`, etc.\n\n14. **sphinx/ext/**: Various extension modules contain their own directive implementations, particularly for extension-specific functionality.\n\n15. **sphinx/util/docutils.py**: Contains base classes and utility functions for directive implementation, including the SphinxDirective base class.\n\nThe directive implementations are registered with the SphinxComponentRegistry during the extension setup process, making them available for use in documentation. Each directive typically extends the appropriate base class and implements the necessary methods for processing the directive content.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ext.todo import todo_node\n    from sphinx.extension import Extension\n    from sphinx.registry import (\n        _MathsBlockRenderers,\n        _MathsInlineRenderers,\n        _NodeHandler,\n        _NodeHandlerPair,\n    )\n    from sphinx.roles import XRefRole\n    from sphinx.search import SearchLanguage\n    from sphinx.theming import Theme\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import RoleFunction, TitleGetter\n\n\nbuiltin_extensions: tuple[str, ...] = (\n    'sphinx.addnodes',\n    'sphinx.builders.changes',\n    'sphinx.builders.epub3',\n    'sphinx.builders.dirhtml',\n    'sphinx.builders.dummy',\n    'sphinx.builders.gettext',\n    'sphinx.builders.html',\n    'sphinx.builders.latex',\n    'sphinx.builders.linkcheck',\n    'sphinx.builders.manpage',\n    'sphinx.builders.singlehtml',\n    'sphinx.builders.texinfo',\n    'sphinx.builders.text',\n    'sphinx.builders.xml',\n    'sphinx.config',\n    'sphinx.domains.c',\n    'sphinx.domains.changeset',\n    'sphinx.domains.citation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environme"}, {"start_line": 7000, "end_line": 8212, "belongs_to": {"file_name": "patches.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rguments = 0\n    final_argument_whitespace = True\n    option_spec = {\n        'class': directives.class_option,\n        'name': directives.unchanged,\n        'heading-level': lambda c: directives.choice(c, ('1', '2', '3', '4', '5', '6')),\n    }\n\n    def run(self) -> list[nodes.rubric | nodes.system_message]:\n        set_classes(self.options)\n        rubric_text = self.arguments[0]\n        textnodes, messages = self.parse_inline(rubric_text, lineno=self.lineno)\n        if 'heading-level' in self.options:\n            self.options['heading-level'] = int(self.options['heading-level'])\n        rubric = nodes.rubric(rubric_text, '', *textnodes, **self.options)\n        self.add_name(rubric)\n        return [rubric, *messages]\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    directives.register_directive('figure', Figure)\n    directives.register_directive('meta', Meta)\n    directives.register_directive('csv-table', CSVTable)\n    directives.register_directive('code', Code)\n    directives.register_directive('math', MathDirective)\n    directives.register_directive('rubric', Rubric)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 15000, "end_line": 16504, "belongs_to": {"file_name": "other.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "b.com/python/mypy/issues/2427 for details on the mypy issue\n            self.state_machine.insert_input = _insert_input\n\n        if self.arguments[0].startswith('<') and self.arguments[0].endswith('>'):\n            # docutils \"standard\" includes, do not do path processing\n            return super().run()\n        _rel_filename, filename = self.env.relfn2path(self.arguments[0])\n        self.arguments[0] = str(filename)\n        self.env.note_included(filename)\n        return super().run()\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    directives.register_directive('toctree', TocTree)\n    directives.register_directive('sectionauthor', Author)\n    directives.register_directive('moduleauthor', Author)\n    directives.register_directive('codeauthor', Author)\n    directives.register_directive('tabularcolumns', TabularColumns)\n    directives.register_directive('centered', Centered)\n    directives.register_directive('acks', Acks)\n    directives.register_directive('hlist', HList)\n    directives.register_directive('only', Only)\n    directives.register_directive('include', Include)\n\n    # register the standard rst class directive under a different name\n    # only for backwards compatibility now\n    directives.register_directive('cssclass', Class)\n    # new standard name when default-domain with \"class\" is in effect\n    directives.register_directive('rst-class', Class)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 14000, "end_line": 15372, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_directive('default-domain', DefaultDomain)\n    directives.register_directive('describe', ObjectDescription)\n    # new, more consistent, name\n    directives.register_directive('object', ObjectDescription)\n\n    app.add_event('object-description-transform')\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_util_docutils_sphinx_directive.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "def test_sphinx_directive_config() -> None:\n    env = SimpleNamespace(config=object())\n    state, directive = make_directive_and_state(env=env)\n\n    assert hasattr(directive, 'config')\n    assert directive.config is directive.env.config\n    assert directive.config is state.document.settings.env.config\n\n\ndef test_sphinx_directive_get_source_info() -> None:\n    env = SimpleNamespace()\n    input_lines = StringList(['spam'], source='<source>')\n    directive = make_directive(env=env, input_lines=input_lines)\n\n    assert directive.get_source_info() == ('<source>', 1)\n\n\ndef test_sphinx_directive_set_source_info() -> None:\n    env = SimpleNamespace()\n    input_lines = StringList(['spam'], source='<source>')\n    directive = make_directive(env=env, input_lines=input_lines)\n\n    node = nodes.Element()\n    directive.set_source_info(node)\n    assert node.source == '<source>'\n    assert node.line == 1\n\n\ndef test_sphinx_directive_get_location() -> None:\n    env = SimpleNamespace()\n    input_lines = StringList(['spam'], source='<source>')\n    directive = make_directive(env=env, input_lines=input_lines)\n\n    assert directive.get_location() == '<source>:1'\n\n\ndef test_sphinx_directive_parse_content_to_nodes() -> None:\n    directive = make_directive(env=SimpleNamespace())\n    content = 'spam\\n====\\n\\nEggs! *Lobster thermidor.*'\n    directive.content = StringList(content.split('\\n'), source='<source>')\n\n    parsed = directive.parse_content_to_nodes(allow_section_headings=True)\n    assert len(parsed) == 1\n    node = parsed[0]\n    assert isinstance(node, nodes.section)\n    assert len(node.children) == 2\n    assert isinstance(node.children[0], nodes.title)\n    assert node.children[0].astext() == 'spam'\n    assert isinstance(node.children[1], nodes.paragraph)\n    assert node.children[1].astext() == 'Eggs! Lobster thermidor.'\n\n\ndef test_sphinx_directive_parse_text_to_nodes() -> None:\n    directive = make_directive(env=SimpleNamespace())\n    content = 'spam\\n====\\n\\nEggs! *Lobster thermidor.*"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 1000, "end_line": 2794, "belongs_to": {"file_name": "admonitions.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dmonition\n    \"\"\"Subclasses must set this to the appropriate admonition node class.\"\"\"\n\n    def run(self) -> list[Node]:\n        (admonition_node,) = super().run()\n        return [admonition_node]\n\n\nclass Admonition(SphinxAdmonition):\n    required_arguments = 1\n    node_class = nodes.admonition\n\n\nclass Attention(SphinxAdmonition):\n    node_class = nodes.attention\n\n\nclass Caution(SphinxAdmonition):\n    node_class = nodes.caution\n\n\nclass Danger(SphinxAdmonition):\n    node_class = nodes.danger\n\n\nclass Error(SphinxAdmonition):\n    node_class = nodes.error\n\n\nclass Hint(SphinxAdmonition):\n    node_class = nodes.hint\n\n\nclass Important(SphinxAdmonition):\n    node_class = nodes.important\n\n\nclass Note(SphinxAdmonition):\n    node_class = nodes.note\n\n\nclass Tip(SphinxAdmonition):\n    node_class = nodes.tip\n\n\nclass Warning(SphinxAdmonition):\n    node_class = nodes.warning\n\n\nclass SeeAlso(SphinxAdmonition):\n    \"\"\"An admonition mentioning things to look at as reference.\"\"\"\n\n    node_class = addnodes.seealso\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_directive('admonition', Admonition, override=True)\n    app.add_directive('attention', Attention, override=True)\n    app.add_directive('caution', Caution, override=True)\n    app.add_directive('danger', Danger, override=True)\n    app.add_directive('error', Error, override=True)\n    app.add_directive('hint', Hint, override=True)\n    app.add_directive('important', Important, override=True)\n    app.add_directive('note', Note, override=True)\n    app.add_directive('tip', Tip, override=True)\n    app.add_directive('warning', Warning, override=True)\n    app.add_directive('seealso', SeeAlso, override=True)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    target_node = nodes.target(ids=node_ids)\n                self.set_source_info(target_node)\n                return [self.indexnode, target_node]\n            return [self.indexnode]\n        return [self.indexnode, node]\n\n\nclass DefaultRole(SphinxDirective):\n    \"\"\"Set the default interpreted text role.  Overridden from docutils.\"\"\"\n\n    optional_arguments = 1\n    final_argument_whitespace = False\n\n    def run(self) -> list[Node]:\n        if not self.arguments:\n            docutils.unregister_role('')\n            return []\n        role_name = self.arguments[0]\n        role, messages = roles.role(\n            role_name, self.state_machine.language, self.lineno, self.state.reporter\n        )\n        if role:\n            docutils.register_role('', role)  # type: ignore[arg-type]\n            self.env.current_document.default_role = role_name\n        else:\n            literal_block = nodes.literal_block(self.block_text, self.block_text)\n            reporter = self.state.reporter\n            error = reporter.error(\n                'Unknown interpreted text role \"%s\".' % role_name,\n                literal_block,\n                line=self.lineno,\n            )\n            messages += [error]\n\n        return cast('list[nodes.Node]', messages)\n\n\nclass DefaultDomain(SphinxDirective):\n    \"\"\"Directive to (re-)set the default domain for this source file.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: ClassVar[OptionSpec] = {}\n\n    def run(self) -> list[Node]:\n        domain_name = self.arguments[0].lower()\n        default_domain = self.env.domains.get(domain_name)\n        self.env.current_document.default_domain = default_domain\n        return []\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_config_value(\n        'strip_signature_backslash', False, 'env', types=frozenset({bool})\n    )\n    directives.register_directive('default-role', DefaultRole)\n    directives.register_direct"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_util_docutils_sphinx_directive.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from __future__ import annotations\n\nfrom types import SimpleNamespace\n\nfrom docutils import nodes\nfrom docutils.parsers.rst.languages import en as english\nfrom docutils.parsers.rst.states import (\n    Inliner,\n    RSTState,\n    RSTStateMachine,\n    state_classes,\n)\nfrom docutils.statemachine import StringList\n\nfrom sphinx.util.docutils import SphinxDirective, new_document\n\n\ndef make_directive(\n    *, env: SimpleNamespace, input_lines: StringList | None = None\n) -> SphinxDirective:\n    _, directive = make_directive_and_state(env=env, input_lines=input_lines)\n    return directive\n\n\ndef make_directive_and_state(\n    *, env: SimpleNamespace, input_lines: StringList | None = None\n) -> tuple[RSTState, SphinxDirective]:\n    sm = RSTStateMachine(state_classes, initial_state='Body')\n    sm.reporter = object()\n    if input_lines is not None:\n        sm.input_lines = input_lines\n    state = RSTState(sm)\n    document = state.document = new_document('<tests>')\n    document.settings.env = env\n    document.settings.tab_width = 4\n    document.settings.pep_references = None\n    document.settings.rfc_references = None\n    inliner = Inliner()\n    inliner.init_customizations(document.settings)\n    state.inliner = inliner\n    state.parent = None\n    state.memo = SimpleNamespace(\n        document=document,\n        reporter=document.reporter,\n        language=english,\n        title_styles=[],\n        section_level=0,\n        section_bubble_up_kludge=False,\n        inliner=inliner,\n    )\n    directive = SphinxDirective(\n        name='test_directive',\n        arguments=[],\n        options={},\n        content=StringList(),\n        lineno=0,\n        content_offset=0,\n        block_text='',\n        state=state,\n        state_machine=state.state_machine,\n    )\n    return state, directive\n\n\ndef test_sphinx_directive_env() -> None:\n    state, directive = make_directive_and_state(env=SimpleNamespace())\n\n    assert hasattr(directive, 'env')\n    assert directive.env is state.document.settings.env\n\n\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docuti"}], "retrieved_count": 10, "cost_time": 0.33765149116516113}
{"question": "How does Sphinx's extension system work?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's extension system works through a sophisticated plugin architecture that allows third-party code to extend and customize Sphinx's functionality without modifying the core codebase. The system is designed to be flexible, extensible, and maintainable.\n\nThe extension system operates through the following key mechanisms:\n\n1. **Extension Discovery and Loading**: Extensions are discovered through multiple mechanisms including the extensions list in conf.py, entry points in Python packages, and direct module imports. The SphinxComponentRegistry manages the loading and initialization of extensions.\n\n2. **Setup Function Protocol**: Each extension must provide a setup function that is called during Sphinx initialization. This function receives the Sphinx application instance and registers the extension's components with the system.\n\n3. **Component Registration**: Extensions can register various types of components including directives, roles, builders, domains, transforms, and event handlers. These components are stored in the SphinxComponentRegistry and made available throughout the build process.\n\n4. **Event System Integration**: Extensions can connect to Sphinx's event system by registering event handlers. These handlers are called at specific points during the build process, allowing extensions to modify documents, add functionality, or respond to build events.\n\n5. **Configuration Integration**: Extensions can add configuration options to Sphinx's configuration system, allowing users to customize extension behavior through conf.py settings.\n\n6. **Build Phase Integration**: Extensions can hook into different phases of the build process (initialization, reading, resolving, writing) by connecting to appropriate events and implementing the necessary callback functions.\n\n7. **Environment Integration**: Extensions can store and retrieve data from the BuildEnvironment, allowing them to maintain state across the build process and implement features like caching and incremental builds.\n\n8. **Namespace Management**: The extension system provides namespace isolation, allowing extensions to add functionality without conflicts with other extensions or the core system.\n\n9. **Error Handling**: The extension system includes robust error handling that isolates extension failures from the core build process, ensuring that one problematic extension doesn't break the entire build.\n\n10. **Version Compatibility**: Extensions can specify version requirements and compatibility information, helping users understand which extensions work with their version of Sphinx.\n\nThis architecture allows Sphinx to support a rich ecosystem of extensions while maintaining stability and performance of the core system.", "score": null, "retrieved_content": [{"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".debug(\n            '[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter\n        )\n        if node in self.enumerable_nodes and not override:\n            raise ExtensionError(__('enumerable_node %r already registered') % node)\n        self.enumerable_nodes[node] = (figtype, title_getter)\n\n    def add_html_math_renderer(\n        self,\n        name: str,\n        inline_renderers: _MathsInlineRenderers | None,\n        block_renderers: _MathsBlockRenderers | None,\n    ) -> None:\n        logger.debug(\n            '[app] adding html_math_renderer: %s, %r, %r',\n            name,\n            inline_renderers,\n            block_renderers,\n        )\n        if name in self.html_inline_math_renderers:\n            raise ExtensionError(__('math renderer %s is already registered') % name)\n\n        if inline_renderers is not None:\n            self.html_inline_math_renderers[name] = inline_renderers\n        if block_renderers is not None:\n            self.html_block_math_renderers[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + tra"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[name] = block_renderers\n\n    def add_html_theme(self, name: str, theme_path: str | os.PathLike[str]) -> None:\n        self.html_themes[name] = _StrPath(theme_path)\n\n    def load_extension(self, app: Sphinx, extname: str) -> None:\n        \"\"\"Load a Sphinx extension.\"\"\"\n        if extname in app.extensions:  # already loaded\n            return\n        if extname in EXTENSION_BLACKLIST:\n            logger.warning(\n                __(\n                    'the extension %r was already merged with Sphinx since '\n                    'version %s; this extension is ignored.'\n                ),\n                extname,\n                EXTENSION_BLACKLIST[extname],\n            )\n            return\n\n        # update loading context\n        prefix = __('while setting up extension %s:') % extname\n        with prefixed_warnings(prefix):\n            try:\n                mod = import_module(extname)\n            except ImportError as err:\n                logger.verbose(__('Original exception:\\n') + traceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot b"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environment.collectors.toctree',\n)\n_first_party_extensions = (\n    # 1st party extensions\n    'sphinxcontrib.applehelp',\n    'sphinxcontrib.devhelp',\n    'sphinxcontrib.htmlhelp',\n    'sphinxcontrib.serializinghtml',\n    'sphinxcontrib.qthelp',\n)\n_first_party_themes = (\n    # Alabaster is loaded automatically to be used as the default theme\n    'alabaster',\n)\nbuiltin_extensions += _first_party_themes\nbuiltin_extensions += _first_party_extensions\n\nENV_PICKLE_FILENAME = 'environment.pickle'\n\nlogger = logging.getLogger(__name__)\n\n\nclass Sphinx:\n    \"\"\"The main application class and extensibility interface.\n\n    :ivar srcdir: Directory containing source.\n    :ivar confdir: Directory containing ``conf.py``.\n    :ivar doctreedir: Directory for storing pickled doctrees.\n    :ivar outdir: Directory for storing build documents.\n    \"\"\"\n\n    warningiserror: Final = False\n    _warncount: int\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode == 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ext.todo import todo_node\n    from sphinx.extension import Extension\n    from sphinx.registry import (\n        _MathsBlockRenderers,\n        _MathsInlineRenderers,\n        _NodeHandler,\n        _NodeHandlerPair,\n    )\n    from sphinx.roles import XRefRole\n    from sphinx.search import SearchLanguage\n    from sphinx.theming import Theme\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import RoleFunction, TitleGetter\n\n\nbuiltin_extensions: tuple[str, ...] = (\n    'sphinx.addnodes',\n    'sphinx.builders.changes',\n    'sphinx.builders.epub3',\n    'sphinx.builders.dirhtml',\n    'sphinx.builders.dummy',\n    'sphinx.builders.gettext',\n    'sphinx.builders.html',\n    'sphinx.builders.latex',\n    'sphinx.builders.linkcheck',\n    'sphinx.builders.manpage',\n    'sphinx.builders.singlehtml',\n    'sphinx.builders.texinfo',\n    'sphinx.builders.text',\n    'sphinx.builders.xml',\n    'sphinx.config',\n    'sphinx.domains.c',\n    'sphinx.domains.changeset',\n    'sphinx.domains.citation',\n    'sphinx.domains.cpp',\n    'sphinx.domains.index',\n    'sphinx.domains.javascript',\n    'sphinx.domains.math',\n    'sphinx.domains.python',\n    'sphinx.domains.rst',\n    'sphinx.domains.std',\n    'sphinx.directives',\n    'sphinx.directives.admonitions',\n    'sphinx.directives.code',\n    'sphinx.directives.other',\n    'sphinx.directives.patches',\n    'sphinx.extension',\n    'sphinx.parsers',\n    'sphinx.registry',\n    'sphinx.roles',\n    'sphinx.transforms',\n    'sphinx.transforms.compact_bullet_list',\n    'sphinx.transforms.i18n',\n    'sphinx.transforms.references',\n    'sphinx.transforms.post_transforms',\n    'sphinx.transforms.post_transforms.code',\n    'sphinx.transforms.post_transforms.images',\n    'sphinx.versioning',\n    # collectors should be loaded by specific order\n    'sphinx.environment.collectors.dependencies',\n    'sphinx.environment.collectors.asset',\n    'sphinx.environment.collectors.metadata',\n    'sphinx.environment.collectors.title',\n    'sphinx.environme"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ceback.format_exc())\n                raise ExtensionError(\n                    __('Could not import extension %s') % extname, err\n                ) from err\n\n            setup: _ExtensionSetupFunc | None = getattr(mod, 'setup', None)\n            if setup is None:\n                logger.warning(\n                    __(\n                        'extension %r has no setup() function; is it really '\n                        'a Sphinx extension module?'\n                    ),\n                    extname,\n                )\n                metadata: ExtensionMetadata = {}\n            else:\n                try:\n                    metadata = setup(app)\n                except VersionRequirementError as err:\n                    # add the extension name to the version required\n                    raise VersionRequirementError(\n                        __(\n                            'The %s extension used by this project needs at least '\n                            'Sphinx v%s; it therefore cannot be built with this '\n                            'version.'\n                        )\n                        % (extname, err),\n                    ) from err\n\n            if metadata is None:\n                metadata = {}\n            elif not isinstance(metadata, dict):\n                logger.warning(\n                    __(\n                        'extension %r returned an unsupported object from '\n                        'its setup() function; it should return None or a '\n                        'metadata dictionary'\n                    ),\n                    extname,\n                )\n                metadata = {}\n\n            app.extensions[extname] = Extension(extname, mod, **metadata)\n\n    def get_envversion(self, app: Sphinx) -> Mapping[str, int]:\n        from sphinx.environment import _get_env_version\n\n        return _get_env_version(app.extensions)\n\n\ndef merge_source_suffix(app: Sphinx, config: Config) -> None:\n    \"\"\"Merge any user-specified source_suffix with any added by ex"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tuple of filename and attributes\n        self.css_files: list[tuple[str, dict[str, Any]]] = []\n\n        #: domains; a dict of domain name -> domain class\n        self.domains: dict[str, type[Domain]] = {}\n\n        #: additional directives for domains\n        #: a dict of domain name -> dict of directive name -> directive\n        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}\n\n        #: additional indices for domains\n        #: a dict of domain name -> list of index class\n        self.domain_indices: dict[str, list[type[Index]]] = {}\n\n        #: additional object types for domains\n        #: a dict of domain name -> dict of objtype name -> objtype\n        self.domain_object_types: dict[str, dict[str, ObjType]] = {}\n\n        #: additional roles for domains\n        #: a dict of domain name -> dict of role name -> role impl.\n        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}\n\n        #: additional enumerable nodes\n        #: a dict of node class"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/napoleon", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n self._config_values:\n            setattr(self, name, default)\n        for name, value in settings.items():\n            setattr(self, name, value)\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    \"\"\"Sphinx extension setup function.\n\n    When the extension is loaded, Sphinx imports this module and executes\n    the ``setup()`` function, which in turn notifies Sphinx of everything\n    the extension offers.\n\n    Parameters\n    ----------\n    app : sphinx.application.Sphinx\n        Application object representing the Sphinx process\n\n    See Also\n    --------\n    `The Sphinx documentation on Extensions\n    <https://www.sphinx-doc.org/extensions.html>`_\n\n    `The Extension Tutorial <https://www.sphinx-doc.org/extdev/tutorial.html>`_\n\n    `The Extension API <https://www.sphinx-doc.org/extdev/appapi.html>`_\n\n    \"\"\"\n    if not isinstance(app, Sphinx):\n        # probably called by tests\n        return {\n            'version': sphinx.__display_version__,\n            'parallel_read_safe': True,\n        }\n\n    _patch_python_domain()\n\n    app.setup_extension('sphinx.ext.autodoc')\n    app.connect('autodoc-process-docstring', _process_docstring)\n    app.connect('autodoc-skip-member', _skip_member)\n\n    for name, default, rebuild, types in Config._config_values:\n        app.add_config_value(name, default, rebuild, types=types)\n\n    return {\n        'version': sphinx.__display_version__,\n        'parallel_read_safe': True,\n    }\n\n\ndef _patch_python_domain() -> None:\n    from sphinx.domains.python._object import PyObject, PyTypedField\n    from sphinx.locale import _\n\n    for doc_field in PyObject.doc_field_types:\n        if doc_field.name == 'parameter':\n            doc_field.names = ('param', 'parameter', 'arg', 'argument')\n            break\n    PyObject.doc_field_types.append(\n        PyTypedField(\n            'keyword',\n            label=_('Keyword Arguments'),\n            names=('keyword', 'kwarg', 'kwparam'),\n            typerolename='class',\n            typenames=('paramtype'"}], "retrieved_count": 10, "cost_time": 0.3250236511230469}
{"question": "How does Sphinx implement its event system for extensions?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements its event system for extensions through the EventManager class, which provides a robust event-driven architecture that allows extensions to hook into various stages of the build process. The event system is designed to be flexible, efficient, and maintainable.\n\nThe event system works through the following key mechanisms:\n\n1. **EventManager Class**: The core of the event system is the EventManager class, which manages event registration, event emission, and event handling. It maintains a registry of event handlers and provides methods for connecting and disconnecting event listeners.\n\n2. **Event Registration**: Extensions can register event handlers using the `connect` method, specifying the event name and the callback function to be called when the event occurs. The system supports multiple handlers for the same event.\n\n3. **Event Emission**: Events are emitted at specific points during the build process using the `emit` method. This method calls all registered handlers for the event, passing the appropriate arguments to each handler.\n\n4. **Build Phase Events**: The event system provides events for different phases of the build process, including 'config-inited', 'builder-inited', 'doctree-read', 'doctree-resolved', 'env-before-read-docs', 'env-check-consistency', and many others.\n\n5. **Event Arguments**: Events can pass various arguments to handlers, including the Sphinx application instance, document objects, and other relevant data. This allows handlers to access and modify the build context.\n\n6. **Error Handling**: The event system includes robust error handling that isolates failures in individual event handlers from the rest of the build process. If one handler fails, it doesn't prevent other handlers from being called.\n\n7. **Event Ordering**: The system maintains the order in which event handlers are called, ensuring that handlers are executed in the order they were registered.\n\n8. **Extension Integration**: The event system is tightly integrated with Sphinx's extension system, allowing extensions to easily connect to events during their setup process.\n\n9. **Performance Optimization**: The event system is designed for performance, with efficient event dispatch and minimal overhead for event handling.\n\n10. **Documentation and Discovery**: The event system provides documentation and discovery mechanisms that help extension developers understand what events are available and when they are emitted.\n\nThe event system is instantiated as part of the Sphinx application (`self.events = EventManager()`) and is available to extensions through the application instance. It serves as the foundation for Sphinx's extensible architecture, allowing extensions to customize and extend the build process without modifying the core codebase.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Sphinx.\"\"\"\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app = app\n        self.events = core_events.copy()\n        self.listeners: dict[str, list[EventListener]] = defaultdict(list)\n        self.next_listener_id = 0\n\n        # pass through errors for debugging.\n        self._reraise_errors: bool = app.pdb\n\n    def add(self, name: str) -> None:\n        \"\"\"Register a custom Sphinx event.\"\"\"\n        if name in self.events:\n            raise ExtensionError(__('Event %r already present') % name)\n        self.events[name] = ''\n\n    @property\n    def app(self) -> Sphinx:\n        _deprecation_warning(__name__, 'EventManager.app', remove=(10, 0))\n        return self._app\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-get-outdated'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], Set[str], Set[str]], Sequence[str]\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-before-read-docs'],\n        callback: Callable[[Sphinx, BuildEnvironment, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-purge-doc'],\n        callback: Callable[[Sphinx, BuildEnvironment, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['source-read'],\n        callback: Callable[[Sphinx, str, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o_node\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass EventListener(NamedTuple):\n    id: int\n    handler: Callable[..., Any]\n    priority: int\n\n\n# List of all known core events. Maps name to arguments description.\ncore_events = {\n    'config-inited': 'config',\n    'builder-inited': '',\n    'env-get-outdated': 'env, added, changed, removed',\n    'env-before-read-docs': 'env, docnames',\n    'env-purge-doc': 'env, docname',\n    'source-read': 'docname, source text',\n    'include-read': 'relative path, parent docname, source text',\n    'doctree-read': 'the doctree before being pickled',\n    'env-merge-info': 'env, read docnames, other env instance',\n    'env-updated': 'env',\n    'env-get-updated': 'env',\n    'env-check-consistency': 'env',\n    'write-started': 'builder',\n    'doctree-resolved': 'doctree, docname',\n    'missing-reference': 'env, node, contnode',\n    'warn-missing-reference': 'domain, node',\n    'build-finished': 'exception',\n}\n\n\nclass EventManager:\n    \"\"\"Event manager for Sphinx.\"\"\"\n\n    def __init__(self, app: Sphinx) -> None:\n        self._app = app\n        self.events = core_events.copy()\n        self.listeners: dict[str, list[EventListener]] = defaultdict(list)\n        self.next_listener_id = 0\n\n        # pass through errors for debugging.\n        self._reraise_errors: bool = app.pdb\n\n    def add(self, name: str) -> None:\n        \"\"\"Register a custom Sphinx event.\"\"\"\n        if name in self.events:\n            raise ExtensionError(__('Event %r already present') % name)\n        self.events[name] = ''\n\n    @property\n    def app(self) -> Sphinx:\n        _deprecation_warning(__name__, 'EventManager.app', remove=(10, 0))\n        return self._app\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ot in self.events:\n            raise ExtensionError(__('Unknown event name: %s') % name)\n\n        listener_id = self.next_listener_id\n        self.next_listener_id += 1\n        self.listeners[name].append(EventListener(listener_id, callback, priority))\n        return listener_id\n\n    def disconnect(self, listener_id: int) -> None:\n        \"\"\"Disconnect a handler.\"\"\"\n        for listeners in self.listeners.values():\n            for listener in listeners.copy():\n                if listener.id == listener_id:\n                    listeners.remove(listener)\n\n    def emit(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Exception], ...] = (),\n    ) -> list[Any]:\n        \"\"\"Emit a Sphinx event.\"\"\"\n        # not every object likes to be repr()'d (think\n        # random stuff coming via autodoc)\n        try:\n            repr_args = repr(args)\n        except Exception:\n            pass\n        else:\n            logger.debug('[app] emitting event: %r%s', name, repr_args)\n\n        results = []\n        listeners = sorted(self.listeners[name], key=attrgetter('priority'))\n        for listener in listeners:\n            try:\n                results.append(listener.handler(self._app, *args))\n            except allowed_exceptions:\n                # pass through the errors specified as *allowed_exceptions*\n                raise\n            except SphinxError:\n                raise\n            except Exception as exc:\n                if self._reraise_errors:\n                    raise\n                modname = safe_getattr(listener.handler, '__module__', None)\n                raise ExtensionError(\n                    __('Handler %r for event %r threw an exception')\n                    % (listener.handler, name),\n                    exc,\n                    modname=modname,\n                ) from exc\n        return results\n\n    def emit_firstresult(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Excep"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ",\n        name: Literal['todo-defined'],\n        callback: Callable[[Sphinx, todo_node], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['viewcode-find-source'],\n        callback: Callable[\n            [Sphinx, str],\n            tuple[str, dict[str, tuple[Literal['class', 'def', 'other'], int, int]]],\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['viewcode-follow-imported'],\n        callback: Callable[[Sphinx, str, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Catch-all ---------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: str,\n        callback: Callable[..., Any],\n        priority: int,\n    ) -> int: ...\n\n    def connect(self, name: str, callback: Callable[..., Any], priority: int) -> int:\n        \"\"\"Connect a handler to specific event.\"\"\"\n        if name not in self.events:\n            raise ExtensionError(__('Unknown event name: %s') % name)\n\n        listener_id = self.next_listener_id\n        self.next_listener_id += 1\n        self.listeners[name].append(EventListener(listener_id, callback, priority))\n        return listener_id\n\n    def disconnect(self, listener_id: int) -> None:\n        \"\"\"Disconnect a handler.\"\"\"\n        for listeners in self.listeners.values():\n            for listener in listeners.copy():\n                if listener.id == listener_id:\n                    listeners.remove(listener)\n\n    def emit(\n        self,\n        name: str,\n        *args: Any,\n        allowed_exceptions: tuple[type[Exception], ...] = (),\n    ) -> list[Any]:\n        \"\"\"Emit a Sphinx event.\"\"\"\n        # not every object likes to be repr()'d (think\n        # random stuff coming via autodoc)\n        try:\n            repr_args = repr(args)\n        except Exception:\n            pass\n        else:\n            logger.debug('[app] emitting event: %r%s'"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   callback: Callable[[Sphinx, Path, str, list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-read'],\n        callback: Callable[[Sphinx, nodes.document], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-merge-info'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], BuildEnvironment], None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], str],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-get-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], "}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['todo-defined'],\n        callback: Callable[[Sphinx, todo_node], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['viewcode-find-source'],\n        callback: Callable[\n            [Sphinx, str],\n            tuple[str, dict[str, tuple[Literal['class', 'def', 'other'], int, int]]],\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['viewcode-follow-imported'],\n        callback: Callable[[Sphinx, str, str], str | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Catch-all ---------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: str,\n        callback: Callable[..., Any],\n        priority: int = 500,\n    ) -> int: ...\n\n    # event interface\n    def con"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docutils.parsers.rst.directives'),\n    ('py:mod', 'sphinx.ext'),\n    ('py:obj', 'sphinx.util.relative_uri'),\n    ('rst:role', 'c:any'),\n    ('std:confval', 'autodoc_inherit_docstring'),\n    ('std:confval', 'automodule_skip_lines'),\n    ('std:confval', 'autossummary_imported_members'),\n    ('std:confval', 'gettext_language_team'),\n    ('std:confval', 'gettext_last_translator'),\n    ('std:confval', 'globaltoc_collapse'),\n    ('std:confval', 'globaltoc_includehidden'),\n    ('std:confval', 'globaltoc_maxdepth'),\n}\n\n\n# -- Extension interface -------------------------------------------------------\n\nfrom sphinx import addnodes  # NoQA: E402\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n    from docutils.nodes import Element\n\n    from sphinx.application import Sphinx\n    from sphinx.environment import BuildEnvironment\n\n_event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n\n\ndef parse_event(_env: BuildEnvironment, sig: str, signode: Element) -> str:\n    m = _event_sig_re.match(sig)\n    if m is No"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ]"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute"}], "retrieved_count": 10, "cost_time": 0.3316664695739746}
{"question": "How does Sphinx implement its search functionality?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx implements its search functionality through a combination of indexing, JavaScript-based client-side search, and server-side search capabilities. The search system is designed to provide fast and accurate search results across the entire documentation.\n\nThe search functionality is implemented through the following key components:\n\n1. **Search Index Generation**: During the build process, Sphinx generates a search index that contains information about all documents, including titles, content, and metadata. This index is typically stored as a JSON file that can be loaded by the search system.\n\n2. **HTML Builder Integration**: The HTML builder includes search functionality by generating the necessary JavaScript files and HTML elements for the search interface. This includes the search box, search results display, and search logic.\n\n3. **JavaScript Search Engine**: Sphinx uses a JavaScript-based search engine that runs in the browser to provide fast, client-side search capabilities. This engine can search through the generated index without requiring server requests.\n\n4. **Search Index Format**: The search index contains structured data about documents including document titles, section headings, content excerpts, and other metadata that can be searched.\n\n5. **Search Result Ranking**: The search system implements ranking algorithms to order search results by relevance, taking into account factors like exact matches, partial matches, and the location of matches within documents.\n\n6. **Cross-Reference Integration**: The search system can include information about cross-references and links, allowing users to search for and find related content across the documentation.\n\n7. **Extension Support**: The search functionality can be extended through Sphinx's extension system, allowing custom search implementations or modifications to the default search behavior.\n\n8. **Multi-language Support**: The search system can handle documentation in multiple languages, with appropriate indexing and search capabilities for each language.\n\n9. **Search Configuration**: Users can configure various aspects of the search functionality through Sphinx's configuration system, including search options and customizations.\n\n10. **Performance Optimization**: The search system is designed for performance, with efficient indexing algorithms and optimized search queries to provide fast results even for large documentation sets.\n\nThe search functionality is primarily implemented in the HTML builder and related modules, with the actual search logic distributed across JavaScript files and Python modules that handle index generation and search configuration.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/search", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hinx.search.ro.SearchRomanian',\n    'ru': 'sphinx.search.ru.SearchRussian',\n    'sv': 'sphinx.search.sv.SearchSwedish',\n    'tr': 'sphinx.search.tr.SearchTurkish',\n    'zh': 'sphinx.search.zh.SearchChinese',\n}\n\n\nclass _JavaScriptIndex:\n    \"\"\"The search index as JavaScript file that calls a function\n    on the documentation search object to register the index.\n    \"\"\"\n\n    PREFIX = 'Search.setIndex('\n    SUFFIX = ')'\n\n    def dumps(self, data: Any) -> str:\n        data_json = json.dumps(data, separators=(',', ':'), sort_keys=True)\n        return self.PREFIX + data_json + self.SUFFIX\n\n    def loads(self, s: str) -> Any:\n        data = s[len(self.PREFIX) : -len(self.SUFFIX)]\n        if not data or not s.startswith(self.PREFIX) or not s.endswith(self.SUFFIX):\n            msg = 'invalid data'\n            raise ValueError(msg)\n        return json.loads(data)\n\n    def dump(self, data: Any, f: _WritableStream[str]) -> None:\n        f.write(self.dumps(data))\n\n    def load(self, f: _ReadableStream[str]) -> Any:\n        return self.loads(f.read())\n\n\njs_index = _JavaScriptIndex()\n\n\ndef _is_meta_keywords(\n    node: nodes.meta,\n    lang: str | None,\n) -> bool:\n    if node.get('name') == 'keywords':\n        meta_lang = node.get('lang')\n        if meta_lang is None or meta_lang == lang:\n            # lang not specified or matched to html_search_language\n            return True\n\n    return False\n\n\n@dataclasses.dataclass\nclass WordStore:\n    words: list[str] = dataclasses.field(default_factory=list)\n    titles: list[tuple[str, str | None]] = dataclasses.field(default_factory=list)\n    title_words: list[str] = dataclasses.field(default_factory=list)\n\n\nclass WordCollector(nodes.NodeVisitor):\n    \"\"\"A special visitor that collects words for the `IndexBuilder`.\"\"\"\n\n    def __init__(self, document: nodes.document, lang: SearchLanguage) -> None:\n        super().__init__(document)\n        self.found_words: list[str] = []\n        self.found_titles: list[tuple[str, str | None]] = []\n        "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/search", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ould be\n       ``Stemmer`` and this class must have ``stemWord`` method.  This string is\n       embedded as-is in searchtools.js.\n\n       This class is used to preprocess search word which Sphinx HTML readers\n       type, before searching index. Default implementation does nothing.\n    \"\"\"\n\n    lang: str = ''\n    language_name: str = ''\n    stopwords: Set[str] = frozenset()\n    js_splitter_code: str = ''\n    js_stemmer_rawcode: str = ''\n    js_stemmer_code = \"\"\"\n/**\n * Dummy stemmer for languages without stemming rules.\n */\nvar Stemmer = function () {\n  this.stemWord = function (w) {\n    return w;\n  };\n};\n\"\"\"\n\n    _word_re = re.compile(r'\\w+')\n\n    def __init__(self, options: dict[str, str]) -> None:\n        \"\"\"Initialize the class with the options the user has given.\"\"\"\n        self.options = options\n\n    def split(self, input: str) -> list[str]:\n        \"\"\"This method splits a sentence into words.  Default splitter splits input\n        at white spaces, which should be enough for most languages except CJK\n        languages.\n        \"\"\"\n        return self._word_re.findall(input)\n\n    def stem(self, word: str) -> str:\n        \"\"\"This method implements stemming algorithm of the Python version.\n\n        Default implementation does nothing.  You should implement this if the\n        language has any stemming rules.\n\n        This class is used to preprocess search words before registering them in\n        the search index.  The stemming of the Python version and the JS version\n        (given in the js_stemmer_code attribute) must be compatible.\n        \"\"\"\n        return word\n\n    def word_filter(self, word: str) -> bool:\n        \"\"\"Return true if the target word should be registered in the search index.\n        This method is called after stemming.\n        \"\"\"\n        return not word.isdigit() and word not in self.stopwords\n\n\n# SearchEnglish imported after SearchLanguage is defined due to circular import\nfrom sphinx.search.en import SearchEnglish  # NoQA: E402\n\n\ndef pars"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_search.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nx('html', testroot='search')\ndef test_stemmer_does_not_remove_short_words(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = (app.outdir / 'searchindex.js').read_text(encoding='utf8')\n    assert 'bat' in searchindex\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_stemmer(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    print(searchindex)\n    assert is_registered_term(searchindex, 'findthisstemmedkey')\n    assert is_registered_term(searchindex, 'intern')\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_term_in_heading_and_section(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = (app.outdir / 'searchindex.js').read_text(encoding='utf8')\n    # if search term is in the title of one doc and in the text of another\n    # both documents should be a hit in the search index as a title,\n    # respectively text hit\n    assert '\"textinhead\":2' in searchindex\n    assert '\"textinhead\":0' in searchindex\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_term_in_raw_directive(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    assert not is_registered_term(searchindex, 'raw')\n    assert is_registered_term(searchindex, 'rawword')\n    assert not is_registered_term(searchindex, 'latex_keyword')\n\n\ndef test_IndexBuilder():\n    settings = frontend.get_default_settings(rst.Parser)\n    parser = rst.Parser()\n\n    domain1 = DummyDomain(\n        'dummy1',\n        [\n            ('objname1', 'objdispname1', 'objtype1', 'docname1_1', '#anchor', 1),\n            ('objname2', 'objdispname2', 'objtype2', 'docname1_2', '', -1),\n        ],\n    )\n    domain2 = DummyDomain(\n        'dummy2',\n        [\n            ('objname1', 'objdispname1', 'objtype1', 'docname2_1', '#anchor', 1),\n            ('objname2', 'objdispname2', 'objtype2', 'docname2_2', '', -1),\n        ],\n   "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/search", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " languages except CJK\n        languages.\n        \"\"\"\n        return self._word_re.findall(input)\n\n    def stem(self, word: str) -> str:\n        \"\"\"This method implements stemming algorithm of the Python version.\n\n        Default implementation does nothing.  You should implement this if the\n        language has any stemming rules.\n\n        This class is used to preprocess search words before registering them in\n        the search index.  The stemming of the Python version and the JS version\n        (given in the js_stemmer_code attribute) must be compatible.\n        \"\"\"\n        return word\n\n    def word_filter(self, word: str) -> bool:\n        \"\"\"Return true if the target word should be registered in the search index.\n        This method is called after stemming.\n        \"\"\"\n        return not word.isdigit() and word not in self.stopwords\n\n\n# SearchEnglish imported after SearchLanguage is defined due to circular import\nfrom sphinx.search.en import SearchEnglish  # NoQA: E402\n\n\ndef parse_stop_word(source: str) -> set[str]:\n    \"\"\"Collect the stopwords from a snowball style word list:\n\n    .. code:: text\n\n        list of space separated stop words | optional comment\n    \"\"\"\n    result: set[str] = set()\n    for line in source.splitlines():\n        line = line.split('|')[0]  # remove comment\n        result.update(line.split())\n    return result\n\n\n# maps language name to module.class or directly a class\nlanguages: dict[str, str | type[SearchLanguage]] = {\n    'da': 'sphinx.search.da.SearchDanish',\n    'de': 'sphinx.search.de.SearchGerman',\n    'en': SearchEnglish,\n    'es': 'sphinx.search.es.SearchSpanish',\n    'fi': 'sphinx.search.fi.SearchFinnish',\n    'fr': 'sphinx.search.fr.SearchFrench',\n    'hu': 'sphinx.search.hu.SearchHungarian',\n    'it': 'sphinx.search.it.SearchItalian',\n    'ja': 'sphinx.search.ja.SearchJapanese',\n    'nl': 'sphinx.search.nl.SearchDutch',\n    'no': 'sphinx.search.no.SearchNorwegian',\n    'pt': 'sphinx.search.pt.SearchPortuguese',\n    'ro': 'sp"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_search.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "searchindex\n    assert '\"textinhead\":0' in searchindex\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_term_in_raw_directive(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    assert not is_registered_term(searchindex, 'raw')\n    assert is_registered_term(searchindex, 'rawword')\n    assert not is_registered_term(searchindex, 'latex_keyword')\n\n\ndef test_IndexBuilder():\n    settings = frontend.get_default_settings(rst.Parser)\n    parser = rst.Parser()\n\n    domain1 = DummyDomain(\n        'dummy1',\n        [\n            ('objname1', 'objdispname1', 'objtype1', 'docname1_1', '#anchor', 1),\n            ('objname2', 'objdispname2', 'objtype2', 'docname1_2', '', -1),\n        ],\n    )\n    domain2 = DummyDomain(\n        'dummy2',\n        [\n            ('objname1', 'objdispname1', 'objtype1', 'docname2_1', '#anchor', 1),\n            ('objname2', 'objdispname2', 'objtype2', 'docname2_2', '', -1),\n        ],\n    )\n    env = DummyEnvironment('1.0', DummyDomainsContainer(dummy1=domain1, dummy2=domain2))\n    doc = utils.new_document('test data', settings)\n    doc['file'] = 'dummy'\n    parser.parse(FILE_CONTENTS, doc)\n\n    # feed\n    index = IndexBuilder(env, 'en', {}, '')\n    index.feed('docname1_1', 'filename1_1', 'title1_1', doc)\n    index.feed('docname1_2', 'filename1_2', 'title1_2', doc)\n    index.feed('docname2_2', 'filename2_2', 'title2_2', doc)\n    index.feed('docname2_1', 'filename2_1', 'title2_1', doc)\n    assert index._titles == {\n        'docname1_1': 'title1_1',\n        'docname1_2': 'title1_2',\n        'docname2_1': 'title2_1',\n        'docname2_2': 'title2_2',\n    }\n    assert index._filenames == {\n        'docname1_1': 'filename1_1',\n        'docname1_2': 'filename1_2',\n        'docname2_1': 'filename2_1',\n        'docname2_2': 'filename2_2',\n    }\n    # note: element iteration order (sort order) is important when the index\n    # is frozen (serialized) during build -- however, the"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_search.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "('dummy1', 'objtype1', 'objtype1'),\n        1: ('dummy2', 'objtype1', 'objtype1'),\n    }\n\n\ndef test_IndexBuilder_lookup():\n    env = DummyEnvironment('1.0', {})\n\n    # zh\n    index = IndexBuilder(env, 'zh', {}, '')\n    assert index.lang.lang == 'zh'\n\n    # zh_CN\n    index = IndexBuilder(env, 'zh_CN', {}, '')\n    assert index.lang.lang == 'zh'\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='search',\n    confoverrides={'html_search_language': 'zh'},\n    srcdir='search_zh',\n)\ndef test_search_index_gen_zh(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    index = load_searchindex(app.outdir / 'searchindex.js')\n    assert 'chinesetest ' not in index['terms']\n    assert 'chinesetest' in index['terms']\n    assert 'chinesetesttwo' in index['terms']\n    assert 'cas' in index['terms']\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='search',\n    freshenv=True,\n)\ndef test_nosearch(app: SphinxTestApp) -> None:\n    app.build()\n    index = load_searchindex(app.outdir / 'searchindex.js')\n    assert index['docnames'] == ['index', 'nosearch', 'tocitem']\n    # latex is in 'nosearch.rst', and nowhere else\n    assert 'latex' not in index['terms']\n    # cat is in 'index.rst' but is marked with the 'no-search' class\n    assert 'cat' not in index['terms']\n    # bat is indexed from 'index.rst' and 'tocitem.rst' (document IDs 0, 2), and\n    # not from 'nosearch.rst' (document ID 1)\n    assert 'bat' in index['terms']\n    assert index['terms']['bat'] == [0, 2]\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='search',\n    parallel=3,\n    freshenv=True,\n)\ndef test_parallel(app: SphinxTestApp) -> None:\n    app.build()\n    index = load_searchindex(app.outdir / 'searchindex.js')\n    assert index['docnames'] == ['index', 'nosearch', 'tocitem']\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_search_index_is_deterministic(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    index = load_searchindex(app.outdir / 'searchindex.js')\n    # Pretty print the index. Only show"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_search.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(searchindex, 'findthiskey')\n    assert is_registered_term(searchindex, 'thistoo')\n    assert not is_registered_term(searchindex, 'onlygerman')\n    assert is_registered_term(searchindex, 'notgerman')\n    assert not is_registered_term(searchindex, 'onlytoogerman')\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='search',\n    confoverrides={'html_search_language': 'de'},\n    freshenv=True,\n)\ndef test_meta_keys_are_handled_for_language_de(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    assert not is_registered_term(searchindex, 'thisnoteith')\n    assert is_registered_term(searchindex, 'thisonetoo')\n    assert not is_registered_term(searchindex, 'findthiskey')\n    assert not is_registered_term(searchindex, 'thistoo')\n    assert is_registered_term(searchindex, 'onlygerman')\n    assert not is_registered_term(searchindex, 'notgerman')\n    assert is_registered_term(searchindex, 'onlytoogerman')\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_stemmer_does_not_remove_short_words(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = (app.outdir / 'searchindex.js').read_text(encoding='utf8')\n    assert 'bat' in searchindex\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_stemmer(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    print(searchindex)\n    assert is_registered_term(searchindex, 'findthisstemmedkey')\n    assert is_registered_term(searchindex, 'intern')\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_term_in_heading_and_section(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = (app.outdir / 'searchindex.js').read_text(encoding='utf8')\n    # if search term is in the title of one doc and in the text of another\n    # both documents should be a hit in the search index as a title,\n    # respectively text hit\n    assert '\"textinhead\":2' in "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/search", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Create a full-text search index for offline search.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nimport functools\nimport html\nimport json\nimport os\nimport pickle\nimport re\nfrom importlib import import_module\nfrom typing import TYPE_CHECKING\n\nfrom docutils import nodes\nfrom docutils.nodes import Element\n\nfrom sphinx import addnodes, package_dir\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.index_entries import split_index_msg\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Iterable, Set\n    from typing import Any, Protocol, TypeVar\n\n    from docutils.nodes import Node\n\n    from sphinx.environment import BuildEnvironment\n\n    _T_co = TypeVar('_T_co', covariant=True)\n    _T_contra = TypeVar('_T_contra', contravariant=True)\n\n    class _ReadableStream(Protocol[_T_co]):\n        def read(self, n: int = ..., /) -> _T_co: ...\n        def readline(self, n: int = ..., /) -> _T_co: ...\n\n    class _WritableStream(Protocol[_T_contra]):\n        def write(self, s: _T_contra, /) -> object: ...\n\n\n_NON_MINIFIED_JS_PATH = package_dir.joinpath('search', 'non-minified-js')\n_MINIFIED_JS_PATH = package_dir.joinpath('search', 'minified-js')\n\n\nclass SearchLanguage:\n    \"\"\"This class is the base class for search natural language preprocessors.  If\n    you want to add support for a new language, you should override the methods\n    of this class.\n\n    You should override `lang` class property too (e.g. 'en', 'fr' and so on).\n\n    .. attribute:: stopwords\n\n       This is a set of stop words of the target language.  Default `stopwords`\n       is empty.  This word is used for building index and embedded in JS.\n\n    .. attribute:: js_splitter_code\n\n       Return splitter function of JavaScript version.  The function should be\n       named as ``splitQuery``.  And it should take a string and return list of\n       strings.\n\n       .. versionadded:: 3.0\n\n    .. attribute:: js_stemmer_code\n\n       Return stemmer class of JavaScript version.  This class' name sh"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_search.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r, domains: DummyDomainsContainer) -> None:\n        self.version = version\n        self.domains = domains\n\n    def __getattr__(self, name: str) -> Any:\n        if name.startswith('_search_index_'):\n            setattr(self, name, {})\n        return getattr(self, name, {})\n\n    def __str__(self) -> str:\n        return f'DummyEnvironment({self.version!r}, {self.domains!r})'\n\n\nclass DummyDomain:\n    def __init__(\n        self, name: str, data: Iterable[tuple[str, str, str, str, str, int]]\n    ) -> None:\n        self.name = name\n        self.data = data\n        self.object_types: dict[str, ObjType] = {}\n\n    def get_objects(self) -> Iterable[tuple[str, str, str, str, str, int]]:\n        return self.data\n\n\ndef load_searchindex(path: Path) -> Any:\n    searchindex = path.read_text(encoding='utf8')\n    assert searchindex.startswith('Search.setIndex(')\n    assert searchindex.endswith(')')\n\n    return json.loads(searchindex[16:-1])\n\n\ndef is_registered_term(index: Any, keyword: str) -> bool:\n    return index['terms'].get(keyword, []) != []\n\n\nFILE_CONTENTS = \"\"\"\\\nsection_title\n=============\n\n.. test that comments are not indexed: boson\n\nanother_title\n=============\n\ntest that non-comments are indexed: fermion\n\"\"\"\n\n\n@pytest.mark.sphinx('html', testroot='ext-viewcode')\ndef test_objects_are_escaped(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    index = load_searchindex(app.outdir / 'searchindex.js')\n    for item in index.get('objects').get(''):\n        if item[-1] == 'n::Array&lt;T, d&gt;':  # n::Array<T,d> is escaped\n            break\n    else:\n        raise AssertionError(index.get('objects').get(''))\n\n\n@pytest.mark.sphinx('html', testroot='search')\ndef test_meta_keys_are_handled_for_language_en(app: SphinxTestApp) -> None:\n    app.build(force_all=True)\n    searchindex = load_searchindex(app.outdir / 'searchindex.js')\n    assert not is_registered_term(searchindex, 'thisnoteith')\n    assert is_registered_term(searchindex, 'thisonetoo')\n    assert is_registered_term"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/search", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ed on the doctrees\n    passed to the `feed` method.\n    \"\"\"\n\n    formats = {\n        'json': json,\n        'pickle': pickle,\n    }\n\n    def __init__(\n        self, env: BuildEnvironment, lang: str, options: dict[str, str], scoring: str\n    ) -> None:\n        self._domains = env.domains\n        self._env_version = env.version\n        # docname -> title\n        self._titles: dict[str, str | None] = env._search_index_titles\n        # docname -> filename\n        self._filenames: dict[str, str] = env._search_index_filenames\n        # stemmed words -> set(docname)\n        self._mapping: dict[str, set[str]] = env._search_index_mapping\n        # stemmed words in titles -> set(docname)\n        self._title_mapping: dict[str, set[str]] = env._search_index_title_mapping\n        # docname -> all titles in document\n        self._all_titles: dict[str, list[tuple[str, str | None]]] = (\n            env._search_index_all_titles\n        )\n        # docname -> list(index entry)\n        self._index_entries: dict[str, list[tuple[str, str, str]]] = (\n            env._search_index_index_entries\n        )\n        # objtype -> index\n        self._objtypes: dict[tuple[str, str], int] = env._search_index_objtypes\n        # objtype index -> (domain, type, objname (localized))\n        self._objnames: dict[int, tuple[str, str, str]] = env._search_index_objnames\n        # add language-specific SearchLanguage instance\n        lang_class = languages.get(lang)\n\n        # fallback; try again with language-code\n        if lang_class is None and '_' in lang:\n            lang_class = languages.get(lang.partition('_')[0])\n\n        if lang_class is None:\n            self.lang: SearchLanguage = SearchEnglish(options)\n        elif isinstance(lang_class, str):\n            module, classname = lang_class.rsplit('.', 1)\n            lang_class: type[SearchLanguage] = getattr(import_module(module), classname)  # type: ignore[no-redef]\n            self.lang = lang_class(options)  # type: ignore[operator]\n        el"}], "retrieved_count": 10, "cost_time": 0.3408939838409424}
{"question": "How does Sphinx handle cross-references?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx handles cross-references through a sophisticated system that integrates the Domain system, Role system, and BuildEnvironment to provide comprehensive cross-reference resolution capabilities. The cross-reference system is designed to be flexible, accurate, and extensible.\n\nThe cross-reference handling works through the following key mechanisms:\n\n1. **Role-Based Cross-References**: Cross-references are created using roles in the markup (e.g., `:py:func:`, `:ref:`, `:doc:`). These roles are processed during the parsing phase and create reference nodes in the document tree.\n\n2. **Domain-Specific Resolution**: Each domain provides its own cross-reference resolution logic through the `resolve_xref` method. This allows domains to implement domain-specific logic for finding and linking to objects within their domain.\n\n3. **Environment Data Storage**: The BuildEnvironment stores metadata about all documented objects, including their locations, relationships, and cross-reference information. This data is used during the resolution phase to find target objects.\n\n4. **Multi-Phase Resolution**: Cross-references are resolved in multiple phases. During the reading phase, reference nodes are created but not yet resolved. During the resolving phase, all references are resolved to their target objects.\n\n5. **Cross-Domain References**: The system supports cross-references between different domains, allowing references from one domain to objects in another domain when appropriate.\n\n6. **Standard Domain References**: The standard domain provides general-purpose cross-reference roles like `:ref:` for section references, `:doc:` for document references, and `:any:` for automatic reference resolution.\n\n7. **Reference Data Collection**: During the reading phase, all domains collect information about their objects and store it in the environment's `domaindata`. This information includes object names, locations, and other metadata needed for resolution.\n\n8. **Automatic Reference Resolution**: The system can automatically resolve references based on object names, allowing for flexible reference creation without requiring exact target specification.\n\n9. **Error Handling**: The cross-reference system includes robust error handling for broken references, providing helpful error messages and allowing the build process to continue when possible.\n\n10. **Extension Integration**: The cross-reference system integrates with Sphinx's extension system, allowing extensions to add new cross-reference types or modify existing resolution logic.\n\n11. **Performance Optimization**: The system is designed for performance, with efficient data structures and algorithms for storing and retrieving cross-reference information.\n\n12. **Incremental Build Support**: Cross-reference information is cached in the environment, allowing for efficient incremental builds that only resolve references for changed documents.\n\nThis comprehensive cross-reference system allows Sphinx to provide rich linking capabilities across documentation while maintaining accuracy and performance for large documentation projects.", "score": null, "retrieved_content": [{"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "KeyError as exc:\n            logger.warning(\n                __('invalid numfig_format: %s (%r)'), title, exc, location=node\n            )\n            return contnode\n        except TypeError:\n            logger.warning(__('invalid numfig_format: %s'), title, location=node)\n            return contnode\n\n        return self.build_reference_node(\n            fromdocname,\n            builder,\n            docname,\n            labelid,\n            newtitle,\n            'numref',\n            node_class=addnodes.number_reference,\n            title=title,\n        )\n\n    def _resolve_keyword_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        # keywords are oddballs: they are referenced by named labels\n        docname, labelid, _ = self.labels.get(target, ('', '', ''))\n        if not docname:\n            return None\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def _resolve_doc_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        # directly reference to document by source name; can be absolute or relative\n        refdoc = node.get('refdoc', fromdocname)\n        docname = docname_join(refdoc, node['reftarget'])\n        if docname not in env.all_docs:\n            return None\n        else:\n            if node['refexplicit']:\n                # reference with explicit title\n                caption = node.astext()\n            else:\n                caption = clean_astext(env.titles[docname])\n            innernode = nodes.inline(caption, caption, classes=['doc'])\n            return make_refnode(builder, fromdocname, docname, None, innernode)\n\n    def _resolve_option_xref(\n        sel"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "maxsplit=1)\n                commands.append(subcommand)\n                progname = '-'.join(commands)\n\n                docname, labelid = self.progoptions.get((progname, target), ('', ''))\n                if docname:\n                    break\n            else:\n                return None\n\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def _resolve_term_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        result = self._resolve_obj_xref(\n            env, fromdocname, builder, typ, target, node, contnode\n        )\n        if result:\n            return result\n        else:\n            # fallback to case insensitive match\n            if target.lower() in self._terms:\n                docname, labelid = self._terms[target.lower()]\n                return make_refnode(builder, fromdocname, docname, labelid, contnode)\n            else:\n                return None\n\n    def _resolve_obj_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ) or []\n        for objtype in objtypes:\n            if (objtype, target) in self.objects:\n                docname, labelid = self.objects[objtype, target]\n                break\n        else:\n            docname, labelid = '', ''\n        if not docname:\n            return None\n        return make_refnode(builder, fromdocname, docname, labelid, contnode)\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results"}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_class: type[nodes.reference] = nodes.reference,\n        **options: Any,\n    ) -> nodes.reference:\n        newnode = node_class('', '', internal=True, **options)\n        innernode = nodes.inline(sectname, sectname)\n        if innernode.get('classes') is not None:\n            innernode['classes'].append('std')\n            innernode['classes'].append('std-' + rolename)\n        if docname == fromdocname:\n            newnode['refid'] = labelid\n        else:\n            # set more info in contnode; in case the\n            # get_relative_uri call raises NoUri,\n            # the builder will then have to resolve these\n            contnode = pending_xref('')\n            contnode['refdocname'] = docname\n            contnode['refsectname'] = sectname\n            newnode['refuri'] = builder.get_relative_uri(fromdocname, docname)\n            if labelid:\n                newnode['refuri'] += '#' + labelid\n        newnode.append(innernode)\n        return newnode\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if typ == 'ref':\n            resolver = self._resolve_ref_xref\n        elif typ == 'numref':\n            resolver = self._resolve_numref_xref  # type: ignore[assignment]\n        elif typ == 'keyword':\n            resolver = self._resolve_keyword_xref\n        elif typ == 'doc':\n            resolver = self._resolve_doc_xref\n        elif typ == 'option':\n            resolver = self._resolve_option_xref\n        elif typ == 'term':\n            resolver = self._resolve_term_xref\n        else:\n            resolver = self._resolve_obj_xref\n\n        return resolver(env, fromdocname, builder, typ, target, node, contnode)\n\n    def _resolve_ref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "', node.children[0])\n                if isinstance(node, nodes.term | nodes.field_name):\n                    sectname = clean_astext(node)\n                else:\n                    toctree = next(node.findall(addnodes.toctree), None)\n                    if toctree and toctree.get('caption'):\n                        sectname = toctree['caption']\n                    else:\n                        # anonymous-only labels\n                        continue\n            self.labels[name] = docname, labelid, sectname\n\n    def add_program_option(\n        self, program: str | None, name: str, docname: str, labelid: str\n    ) -> None:\n        # prefer first command option entry\n        if (program, name) not in self.progoptions:\n            self.progoptions[program, name] = (docname, labelid)\n\n    def build_reference_node(\n        self,\n        fromdocname: str,\n        builder: Builder,\n        docname: str,\n        labelid: str,\n        sectname: str,\n        rolename: str,\n        *,\n        node_class: type[nodes.reference] = nodes.reference,\n        **options: Any,\n    ) -> nodes.reference:\n        newnode = node_class('', '', internal=True, **options)\n        innernode = nodes.inline(sectname, sectname)\n        if innernode.get('classes') is not None:\n            innernode['classes'].append('std')\n            innernode['classes'].append('std-' + rolename)\n        if docname == fromdocname:\n            newnode['refid'] = labelid\n        else:\n            # set more info in contnode; in case the\n            # get_relative_uri call raises NoUri,\n            # the builder will then have to resolve these\n            contnode = pending_xref('')\n            contnode['refdocname'] = docname\n            contnode['refsectname'] = sectname\n            newnode['refuri'] = builder.get_relative_uri(fromdocname, docname)\n            if labelid:\n                newnode['refuri'] += '#' + labelid\n        newnode.append(innernode)\n        return newnode\n\n    def resolve_xref(\n        self,\n"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if typ == 'ref':\n            resolver = self._resolve_ref_xref\n        elif typ == 'numref':\n            resolver = self._resolve_numref_xref  # type: ignore[assignment]\n        elif typ == 'keyword':\n            resolver = self._resolve_keyword_xref\n        elif typ == 'doc':\n            resolver = self._resolve_doc_xref\n        elif typ == 'option':\n            resolver = self._resolve_option_xref\n        elif typ == 'term':\n            resolver = self._resolve_term_xref\n        else:\n            resolver = self._resolve_obj_xref\n\n        return resolver(env, fromdocname, builder, typ, target, node, contnode)\n\n    def _resolve_ref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        if node['refexplicit']:\n            # reference to anonymous label; the reference uses\n            # the supplied link caption\n            docname, labelid = self.anonlabels.get(target, ('', ''))\n            sectname = node.astext()\n        else:\n            # reference to named label; the final node will\n            # contain the section name after the label\n            docname, labelid, sectname = self.labels.get(target, ('', '', ''))\n        if not docname:\n            return None\n\n        return self.build_reference_node(\n            fromdocname, builder, docname, labelid, sectname, 'ref'\n        )\n\n    def _resolve_numref_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | Element | None:\n        if target in self.la"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "test_domain_py.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "strong> (<a class=\"reference internal\" href=\"#foo.Name\" '\n        'title=\"foo.Name\"><em>foo.Name</em></a>)  blah blah</p>'\n    ) in content\n    assert '<p><strong>age</strong> (<em>foo.Age</em>)  blah blah</p>' in content\n\n\n@pytest.mark.sphinx('dummy', testroot='domain-py-xref-warning')\ndef test_warn_missing_reference(app):\n    app.build()\n    assert \"index.rst:6: WARNING: undefined label: 'no-label'\" in app.warning.getvalue()\n    assert (\n        'index.rst:6: WARNING: Failed to create a cross reference. '\n        \"A title or caption not found: 'existing-label'\"\n    ) in app.warning.getvalue()\n\n\n@pytest.mark.parametrize('include_options', [True, False])\n@pytest.mark.sphinx('html', testroot='root', confoverrides={'nitpicky': True})\ndef test_signature_line_number(app, include_options):\n    text = '.. py:function:: foo(bar : string)\\n' + (\n        '   :no-index-entry:\\n' if include_options else ''\n    )\n    doc = restructuredtext.parse(app, text)\n    xrefs = list(doc.findall(condition=addnodes.pending_xref))\n    assert len(xrefs) == 1\n    source, line = docutils.utils.get_source_line(xrefs[0])\n    assert 'index.rst' in source\n    assert line == 1\n\n\n@pytest.mark.sphinx(\n    'html',\n    testroot='root',\n    confoverrides={\n        'python_maximum_signature_line_length': len('hello(name: str) -> str'),\n        'maximum_signature_line_length': 1,\n    },\n)\ndef test_python_maximum_signature_line_length_overrides_global(app):\n    text = '.. py:function:: hello(name: str) -> str'\n    doctree = restructuredtext.parse(app, text)\n    expected_doctree = (\n        addnodes.index,\n        [\n            desc,\n            (\n                [\n                    desc_signature,\n                    (\n                        [desc_name, 'hello'],\n                        desc_parameterlist,\n                        [desc_returns, pending_xref, 'str'],\n                    ),\n                ],\n                desc_content,\n            ),\n        ],\n    )\n    assert_node(doctree, expected"}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "aise ValueError  # no number assigned\n            else:\n                anchorname = '#' + target_node['ids'][0]\n                if anchorname not in env.toc_secnumbers[docname]:\n                    # try first heading which has no anchor\n                    return env.toc_secnumbers[docname].get('')\n                else:\n                    return env.toc_secnumbers[docname].get(anchorname)\n        else:\n            try:\n                figure_id = target_node['ids'][0]\n                return env.toc_fignumbers[docname][figtype][figure_id]\n            except (KeyError, IndexError) as exc:\n                # target_node is found, but fignumber is not assigned.\n                # Maybe it is defined in orphaned document.\n                raise ValueError from exc\n\n    def get_full_qualified_name(self, node: Element) -> str | None:\n        if node.get('reftype') == 'option':\n            progname = node.get('std:program')\n            command = ws_re.split(node.get('reftarget'))\n            if progname:\n                command.insert(0, progname)\n            option = command.pop()\n            if command:\n                command_str = '-'.join(command)\n                return f'{command_str}.{option}'\n            else:\n                return None\n        else:\n            return None\n\n\ndef _has_child(node: Element, cls: type) -> bool:\n    return any(isinstance(child, cls) for child in node)\n\n\ndef warn_missing_reference(\n    app: Sphinx,\n    domain: Domain,\n    node: pending_xref,\n) -> bool | None:\n    if (domain and domain.name != 'std') or node['reftype'] != 'ref':\n        return None\n    else:\n        target = node['reftarget']\n        if target not in domain.anonlabels:  # type: ignore[attr-defined]\n            msg = __('undefined label: %r')\n        else:\n            msg = __(\n                'Failed to create a cross reference. A title or caption not found: %r'\n            )\n\n        logger.warning(msg, target, location=node, type='ref', subtype=node['reftype'])\n       "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            declaration.get_newest_id(),\n            contnode,\n            display_name,\n        ), declaration.objectType\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        return self._resolve_xref_inner(\n            env, fromdocname, builder, typ, target, node, contnode\n        )[0]\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        with logging.suppress_logging():\n            retnode, objtype = self._resolve_xref_inner(\n                env, fromdocname, builder, 'any', target, node, contnode\n            )\n        if retnode:\n            return [('c:' + self.role_for_objtype(objtype), retnode)]\n        return []\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        root_symbol = self.data['root_symbol']\n        for symbol in root_symbol.get_all_symbols():\n            if symbol.declaration is None:\n                continue\n            assert symbol.docname\n            full_nested_name = symbol.get_full_nested_name()\n            name = str(full_nested_name).lstrip('.')\n            dispname = full_nested_name.get_display_string().lstrip('.')\n            object_type = symbol.declaration.objectType\n            docname = symbol.docname\n            newest_id = symbol.declaration.get_newest_id()\n            yield name, dispname, object_type, docname, newest_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(CDomain)\n    app.add_config_value('c_id_attributes', [], 'env', types=frozenset({list, tuple}))\n    app.add_config_value(\n        'c_paren_attributes', [], 'env', types=frozenset({list, tuple})\n    )\n    app.add_config_"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "rst.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e:\n        # XXX check duplicates\n        for (typ, name), (doc, node_id) in otherdata['objects'].items():\n            if doc in docnames:\n                self.objects[typ, name] = (doc, node_id)\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ)\n        if not objtypes:\n            return None\n        for objtype in objtypes:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                return make_refnode(\n                    builder,\n                    fromdocname,\n                    todocname,\n                    node_id,\n                    contnode,\n                    f'{target} {objtype}',\n                )\n        return None\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results: list[tuple[str, nodes.reference]] = []\n        for objtype in self.object_types:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                results.append((\n                    f'rst:{self.role_for_objtype(objtype)}',\n                    make_refnode(\n                        builder,\n                        fromdocname,\n                        todocname,\n                        node_id,\n                        contnode,\n                        f'{target} {objtype}',\n                    ),\n                ))\n        return results\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        for (typ, name), (docname, node_id) in self.data['objects'].items():\n  "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms/post_transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ight be a bug.'\n                        )\n                        logger.warning(msg, location=node)\n\n            node.replace_self(new_nodes)\n\n    def _resolve_pending_xref(\n        self, node: addnodes.pending_xref, contnode: Element\n    ) -> nodes.reference | None:\n        new_node: nodes.reference | None\n        typ = node['reftype']\n        target = node['reftarget']\n        ref_doc = node.setdefault('refdoc', self.env.current_document.docname)\n        ref_domain = node.get('refdomain', '')\n        domain: Domain | None\n        if ref_domain:\n            try:\n                domain = self.env.domains[ref_domain]\n            except KeyError:\n                return None\n        else:\n            domain = None\n\n        try:\n            new_node = self._resolve_pending_xref_in_domain(\n                domain=domain,\n                node=node,\n                contnode=contnode,\n                ref_doc=ref_doc,\n                typ=typ,\n                target=target,\n            )\n        except NoUri:\n            return None\n        if new_node is not None:\n            return new_node\n\n        try:\n            # no new node found? try the missing-reference event\n            new_node = self.env.events.emit_firstresult(\n                'missing-reference',\n                self.env,\n                node,\n                contnode,\n                allowed_exceptions=(NoUri,),\n            )\n        except NoUri:\n            return None\n        if new_node is not None:\n            return new_node\n\n        # Is this a self-referential intersphinx reference?\n        if 'intersphinx_self_referential' in node:\n            del node.attributes['intersphinx_self_referential']\n            try:\n                new_node = self._resolve_pending_xref_in_domain(\n                    domain=domain,\n                    node=node,\n                    contnode=contnode,\n                    ref_doc=ref_doc,\n                    typ=typ,\n                    target=node['reftarget'],\n            "}], "retrieved_count": 10, "cost_time": 0.33998918533325195}
{"question": "How does Sphinx process different input formats (reStructuredText, Markdown)?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx processes different input formats through a parser system that converts various markup languages into docutils document trees. The system is designed to be extensible, allowing support for multiple input formats while maintaining a unified internal representation.\n\nThe processing of different input formats works through the following key mechanisms:\n\n1. **Parser Registration**: Sphinx registers different parsers for various input formats through the SphinxComponentRegistry. Each parser is responsible for converting a specific input format into docutils document trees.\n\n2. **reStructuredText Processing**: reStructuredText is the default and most fully supported input format. Sphinx uses Docutils' built-in reStructuredText parser, which converts RST markup into docutils document trees. This parser handles all standard RST directives, roles, and markup.\n\n3. **Markdown Processing**: Sphinx can process Markdown files through extensions like `myst-parser` or `recommonmark`. These extensions provide parsers that convert Markdown syntax into docutils document trees, allowing Sphinx to handle Markdown input alongside RST.\n\n4. **Unified Document Tree**: Regardless of the input format, all parsers convert their input into docutils document trees. This provides a unified internal representation that can be processed by Sphinx's transform system, domain system, and output generators.\n\n5. **Format Detection**: Sphinx detects the input format based on file extensions and configuration settings. The `source_suffix` configuration option specifies which file extensions should be processed by which parsers.\n\n6. **Extension Integration**: The parser system integrates with Sphinx's extension system, allowing extensions to add support for new input formats by registering custom parsers.\n\n7. **Directive and Role Support**: Different input formats may have different capabilities for directives and roles. Sphinx's parser system ensures that format-specific features are properly converted to the unified document tree representation.\n\n8. **Cross-Reference Handling**: The parser system handles cross-references and links in a format-appropriate way, converting them to Sphinx's internal cross-reference system.\n\n9. **Error Handling**: The parser system includes robust error handling for malformed input, providing helpful error messages and allowing the build process to continue when possible.\n\n10. **Performance Optimization**: The parser system is designed for performance, with efficient parsing algorithms and caching mechanisms to handle large documentation projects.\n\nThis architecture allows Sphinx to support multiple input formats while maintaining a consistent internal processing pipeline, making it flexible for different documentation workflows and user preferences.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 299, "belongs_to": {"file_name": "prolog_markdown_parser.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-prolog", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from docutils.parsers import Parser\n\n\nclass DummyMarkdownParser(Parser):\n    supported = ('markdown',)\n\n    def parse(self, inputstring, document):\n        document.rawsource = inputstring\n\n\ndef setup(app):\n    app.add_source_suffix('.md', 'markdown')\n    app.add_source_parser(DummyMarkdownParser)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Input/Output files\"\"\"\n\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING\n\nfrom docutils.io import FileInput\nfrom docutils.readers import standalone\nfrom docutils.transforms.references import DanglingReferences\nfrom docutils.writers import UnfilteredWriter\n\nfrom sphinx.deprecation import RemovedInSphinx10Warning\nfrom sphinx.transforms import SphinxTransformer\nfrom sphinx.util import logging\nfrom sphinx.util.docutils import LoggingReporter\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from docutils import nodes\n    from docutils.frontend import Values\n    from docutils.io import Input\n    from docutils.parsers import Parser\n    from docutils.transforms import Transform\n\n    from sphinx.environment import BuildEnvironment\n\n\nlogger = logging.getLogger(__name__)\n\nwarnings.warn('sphinx.io is deprecated', RemovedInSphinx10Warning, stacklevel=2)\n\n\nclass SphinxBaseReader(standalone.Reader):  # type: ignore[misc]\n    \"\"\"A base class of readers for Sphinx.\n\n    This replaces reporter by Sphinx's on generating document.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxBaseReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    transforms: list[type[Transform]] = []\n\n    def get_transforms(self) -> list[type[Transform]]:\n        transforms = super().get_transforms() + self.transforms\n\n        # remove transforms which is not needed for Sphinx\n        unused = [DanglingReferences]\n        for transform in unused:\n            if transform in transforms:\n                transforms.remove(transform)\n\n        return transforms\n\n    def new_document(self) -> nodes.document:\n        \"\"\"Creates a new document object which has a special reporter object good\n        for logging.\n        \"\"\"\n        document = super().new_document()\n\n        # substitute transformer\n        document.transfor"}, {"start_line": 3000, "end_line": 4540, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gs = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n    warnings.warn(\n        'sphinx.io.SphinxDummySourceClass is deprecated',\n        RemovedInSphinx10Warning,\n        stacklevel=2,\n    )\n    return source\n\n\nclass SphinxFileInput(FileInput):\n    \"\"\"A basic FileInput for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        kwargs['error_handler'] = 'sphinx'\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxFileInput is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}, {"start_line": 2000, "end_line": 3874, "belongs_to": {"file_name": "parsers.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._config = app.config\n        self._env = app.env\n\n\nclass RSTParser(docutils.parsers.rst.Parser, Parser):\n    \"\"\"A reST parser for Sphinx.\"\"\"\n\n    def get_transforms(self) -> list[type[Transform]]:\n        \"\"\"Sphinx's reST parser replaces a transform class for smart-quotes by its own\n\n        refs: sphinx.io.SphinxStandaloneReader\n        \"\"\"\n        transforms = super(RSTParser, RSTParser()).get_transforms()\n        transforms.remove(SmartQuotes)\n        return transforms\n\n    def parse(self, inputstring: str | StringList, document: nodes.document) -> None:\n        \"\"\"Parse text and generate a document tree.\"\"\"\n        self.setup_parse(inputstring, document)  # type: ignore[arg-type]\n        self.statemachine = states.RSTStateMachine(\n            state_classes=self.state_classes,\n            initial_state=self.initial_state,\n            debug=document.reporter.debug_flag,\n        )\n\n        # preprocess inputstring\n        if isinstance(inputstring, str):\n            lines = docutils.statemachine.string2lines(\n                inputstring,\n                tab_width=document.settings.tab_width,\n                convert_whitespace=True,\n            )\n\n            inputlines = StringList(lines, document.current_source)\n        else:\n            inputlines = inputstring\n\n        self.decorate(inputlines)\n        self.statemachine.run(inputlines, document, inliner=self.inliner)\n        self.finish_parse()\n\n    def decorate(self, content: StringList) -> None:\n        \"\"\"Preprocess reStructuredText content before parsing.\"\"\"\n        _prepend_prologue(content, self._config.rst_prolog)\n        _append_epilogue(content, self._config.rst_epilog)\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_source_parser(RSTParser)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 0, "end_line": 349, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/roots/test-add_source_parser-conflicts-with-users-setting", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path.cwd().resolve()))\n\nfrom docutils.parsers import Parser\n\n\nclass DummyTestParser(Parser):\n    supported = ('dummy',)\n\n\nextensions = ['source_parser']\nsource_suffix = {\n    '.rst': 'restructuredtext',\n    '.test': 'restructuredtext',\n}\nsource_parsers = {\n    '.test': DummyTestParser,\n}\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_directive_productionlist.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_directives", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et` (\",\" `target`)* [\",\"]\n   target: `identifier`\n         : | \"(\" [`target_list`] \")\"\n         : | \"[\" [`target_list`] \"]\"\n         : | `attributeref`\n         : | `subscription`\n         : | `slicing`\n         : | \"*\" `target`\n\"\"\"\n    (tmp_path / 'conf.py').touch()\n    (tmp_path / 'index.rst').write_text(text, encoding='utf-8')\n\n    app = make_app(buildername='text', srcdir=tmp_path)\n    app.build(force_all=True)\n    content = (app.outdir / 'index.txt').read_text(encoding='utf-8')\n    expected = \"\"\"\\\n   assignment_stmt ::= (target_list \"=\")+ (starred_expression | yield_expression)\n   target_list     ::= target (\",\" target)* [\",\"]\n   target          ::= identifier\n                       | \"(\" [target_list] \")\"\n                       | \"[\" [target_list] \"]\"\n                       | attributeref\n                       | subscription\n                       | slicing\n                       | \"*\" target\n\"\"\"\n    assert content == expected\n\n    app = make_app(buildername='html', srcdir=tmp_path)\n    app.build(force_all=True)\n    content = (app.outdir / 'index.html').read_text(encoding='utf-8')\n    _, _, content = content.partition('<pre>')\n    content, _, _ = content.partition('</pre>')\n    expected = \"\"\"\n<strong id=\"grammar-token-python-grammar-assignment_stmt\">assignment_stmt</strong> ::= (<a class=\"reference internal\" href=\"#grammar-token-python-grammar-target_list\"><code class=\"xref docutils literal notranslate\"><span class=\"pre\">target_list</span></code></a> &quot;=&quot;)+ (<code class=\"xref docutils literal notranslate\"><span class=\"pre\">starred_expression</span></code> | <code class=\"xref docutils literal notranslate\"><span class=\"pre\">yield_expression</span></code>)\n<strong id=\"grammar-token-python-grammar-target_list\">target_list</strong>     ::= <a class=\"reference internal\" href=\"#grammar-token-python-grammar-target\"><code class=\"xref docutils literal notranslate\"><span class=\"pre\">target</span></code></a> (&quot;,&quot; <a class=\"reference internal\" href=\"#gr"}, {"start_line": 1000, "end_line": 2959, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                yield docname\n                continue\n            targetname = self.outdir / (docname + self.out_suffix)\n            try:\n                targetmtime = _last_modified_time(targetname)\n            except Exception:\n                targetmtime = 0\n            try:\n                srcmtime = _last_modified_time(self.env.doc2path(docname))\n                if srcmtime > targetmtime:\n                    yield docname\n            except OSError:\n                # source doesn't exist anymore\n                pass\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        return ''\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        self.current_docname = docname\n        self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n        visitor: TextTranslator = self.create_translator(doctree, self)  # type: ignore[assignment]\n        doctree.walkabout(visitor)\n        output = visitor.body\n        out_file_name = self.outdir / (docname + self.out_suffix)\n        out_file_name.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            out_file_name.write_text(output, encoding='utf-8')\n        except OSError as err:\n            logger.warning(__('error writing file %s: %s'), out_file_name, err)\n\n    def finish(self) -> None:\n        pass\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_builder(TextBuilder)\n\n    app.add_config_value('text_sectionchars', '*=-~\"+`', 'env', types=frozenset({str}))\n    app.add_config_value('text_newlines', 'unix', 'env', types=frozenset({str}))\n    app.add_config_value('text_add_secnumbers', True, 'env', types=frozenset({bool}))\n    app.add_config_value('text_secnumber_suffix', '. ', 'env', types=frozenset({str}))\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 1000, "end_line": 2374, "belongs_to": {"file_name": "test_parser.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_markup", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    # with rst_prolog\n    app.config.rst_prolog = 'this is rst_prolog\\nhello reST!'\n    parser.parse(text, document)\n    (content, _), _ = RSTStateMachine().run.call_args\n    assert list(content.xitems()) == [\n        ('<rst_prologue>', 0, 'this is rst_prolog'),\n        ('<rst_prologue>', 1, 'hello reST!'),\n        ('<generated>', 0, ''),\n        ('dummy.rst', 0, 'hello Sphinx world'),\n        ('dummy.rst', 1, 'Sphinx is a document generator'),\n    ]\n\n    # with rst_epilog\n    app.config.rst_prolog = None\n    app.config.rst_epilog = 'this is rst_epilog\\ngood-bye reST!'\n    parser.parse(text, document)\n    (content, _), _ = RSTStateMachine().run.call_args\n    assert list(content.xitems()) == [\n        ('dummy.rst', 0, 'hello Sphinx world'),\n        ('dummy.rst', 1, 'Sphinx is a document generator'),\n        ('dummy.rst', 2, ''),\n        ('<rst_epilogue>', 0, 'this is rst_epilog'),\n        ('<rst_epilogue>', 1, 'good-bye reST!'),\n    ]\n\n    # expandtabs / convert whitespaces\n    app.config.rst_prolog = None\n    app.config.rst_epilog = None\n    text = '\\thello Sphinx world\\n\\v\\fSphinx is a document generator'\n    parser.parse(text, document)\n    (content, _), _ = RSTStateMachine().run.call_args\n    assert list(content.xitems()) == [\n        ('dummy.rst', 0, '        hello Sphinx world'),\n        ('dummy.rst', 1, '  Sphinx is a document generator'),\n    ]\n"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "test_markup.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_markup", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   assert rst[-1][-1][0][0] == 'Good-bye world'\n\n    # rst_prolog & rst_epilog on exlucding reST parser\n    assert not md.rawsource.startswith('*Hello world*.')\n    assert not md.rawsource.endswith('*Good-bye world*.\\n')\n\n\n@pytest.mark.sphinx('dummy', testroot='keep_warnings')\ndef test_keep_warnings_is_True(app):\n    app.build(force_all=True)\n    doctree = app.env.get_doctree('index')\n    assert_node(doctree[0], nodes.section)\n    assert len(doctree[0]) == 2\n    assert_node(doctree[0][1], nodes.system_message)\n\n\n@pytest.mark.sphinx(\n    'dummy',\n    testroot='keep_warnings',\n    confoverrides={'keep_warnings': False},\n)\ndef test_keep_warnings_is_False(app):\n    app.build(force_all=True)\n    doctree = app.env.get_doctree('index')\n    assert_node(doctree[0], nodes.section)\n    assert len(doctree[0]) == 1\n\n\n@pytest.mark.sphinx('dummy', testroot='refonly_bullet_list')\ndef test_compact_refonly_bullet_list(app):\n    app.build(force_all=True)\n    doctree = app.env.get_doctree('index')\n    assert_node(doctree[0], nodes.section)\n    assert len(doctree[0]) == 5\n\n    assert doctree[0][1].astext() == 'List A:'\n    assert_node(doctree[0][2], nodes.bullet_list)\n    assert_node(doctree[0][2][0][0], addnodes.compact_paragraph)\n    assert doctree[0][2][0][0].astext() == 'genindex'\n\n    assert doctree[0][3].astext() == 'List B:'\n    assert_node(doctree[0][4], nodes.bullet_list)\n    assert_node(doctree[0][4][0][0], nodes.paragraph)\n    assert doctree[0][4][0][0].astext() == 'Hello'\n\n\n@pytest.mark.sphinx('dummy', testroot='default_role')\ndef test_default_role1(app):\n    app.build(force_all=True)\n\n    # default-role: pep\n    doctree = app.env.get_doctree('index')\n    assert_node(doctree[0], nodes.section)\n    assert_node(doctree[0][1], nodes.paragraph)\n    assert_node(doctree[0][1][0], addnodes.index)\n    assert_node(doctree[0][1][1], nodes.target)\n    assert_node(doctree[0][1][2], nodes.reference, classes=['pep'])\n\n    # no default-role\n    doctree = app.env.get_doctree('foo')\n    asse"}], "retrieved_count": 10, "cost_time": 0.35062670707702637}
{"question": "How do Sphinx extensions hook into the document building process?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx extensions hook into the document building process through multiple mechanisms that allow them to integrate with different phases of the build and modify various aspects of document processing. The hooking system is designed to be flexible and non-intrusive.\n\nExtensions can hook into the document building process through the following key mechanisms:\n\n1. **Event System Hooks**: Extensions can connect to Sphinx's event system by registering event handlers for specific events. These events are emitted at various points during the build process, allowing extensions to respond to and modify the build context.\n\n2. **Build Phase Events**: Extensions can hook into different phases of the build process by connecting to phase-specific events such as 'config-inited', 'builder-inited', 'doctree-read', 'doctree-resolved', 'env-before-read-docs', 'env-check-consistency', and 'build-finished'.\n\n3. **Document Processing Hooks**: Extensions can hook into document processing by connecting to events like 'doctree-read' and 'doctree-resolved', which allow them to modify document trees after they have been read or after cross-references have been resolved.\n\n4. **Transform Registration**: Extensions can register custom transforms that are applied to document trees during the transformation phase. These transforms can modify document structure, add content, or perform other document manipulations.\n\n5. **Directive and Role Registration**: Extensions can register custom directives and roles that are processed during the parsing phase. These can add new markup capabilities or modify how existing markup is processed.\n\n6. **Builder Integration**: Extensions can hook into the builder system by registering custom builders or modifying existing builders to add format-specific functionality.\n\n7. **Domain Integration**: Extensions can hook into the domain system by registering custom domains or extending existing domains with new object types, directives, and roles.\n\n8. **Configuration Hooks**: Extensions can hook into the configuration system by adding configuration options and responding to configuration changes through events like 'config-inited'.\n\n9. **Environment Integration**: Extensions can hook into the BuildEnvironment by storing and retrieving data, allowing them to maintain state across the build process and implement features like caching.\n\n10. **Output Generation Hooks**: Extensions can hook into output generation by registering custom writers or modifying the output generation process through events and transforms.\n\n11. **Setup Function Protocol**: Each extension provides a setup function that is called during Sphinx initialization. This function receives the Sphinx application instance and registers all the extension's hooks and components.\n\n12. **Error Handling Integration**: Extensions can hook into Sphinx's error handling system to provide custom error reporting or recovery mechanisms.\n\nThis comprehensive hooking system allows extensions to integrate deeply with Sphinx's build process while maintaining the stability and performance of the core system. Extensions can modify documents, add functionality, and respond to build events without requiring changes to the core Sphinx codebase.", "score": null, "retrieved_content": [{"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "== 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, and abort the\n        build when it is too old.\n\n        :param version: The required version in the form of ``major.minor`` or\n                        ``(major, minor)``.\n\n        .. versionadded:: 1.0\n        .. versionchanged:: 7.1\n           Type of *version* now allows ``(major, minor)`` form.\n        \"\"\"\n        if isinstance(version, tuple):\n            major, minor = version\n        else:\n            major, minor = map(int, version.split('.')[:2])\n        if (major, minor) > sphinx.version_info[:2]:\n            req = f'{major}.{minor}'\n            raise VersionRequirementError(req)\n\n    # ---- Core events -------------------------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['config-inited'],\n        callback: Callable[[Sphinx, Config], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n     "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode == 0 and self.builder.epilog:\n            logger.info('')\n            logger.info(\n                self.builder.epilog,\n                {\n                    'outdir': relpath(self.outdir),\n                    'project': self.config.project,\n                },\n            )\n\n        self.builder.cleanup()\n\n    # ---- general extensibility interface -------------------------------------\n\n    def setup_extension(self, extname: str) -> None:\n        \"\"\"Import and setup a Sphinx extension module.\n\n        Load the extension given by the module *name*.  Use this if your\n        extension needs the features provided by another extension.  No-op if\n        called twice.\n        \"\"\"\n        logger.debug('[app] setting up extension: %r', extname)\n        self.registry.load_extension(self, extname)\n\n    @staticmethod\n    def require_sphinx(version: tuple[int, int] | str) -> None:\n        \"\"\"Check the Sphinx version if requested.\n\n        Compare *version* with the version of the running Sphinx, "}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  event: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int = 500,\n    ) -> in"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ",\n        name: Literal['include-read'],\n        callback: Callable[[Sphinx, Path, str, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['doctree-read'],\n        callback: Callable[[Sphinx, nodes.document], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-merge-info'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], BuildEnvironment], None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], str],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-get-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],\n   "}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   callback: Callable[[Sphinx, Path, str, list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-read'],\n        callback: Callable[[Sphinx, nodes.document], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-merge-info'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], BuildEnvironment], None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], str],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-get-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ame: Literal['builder-inited'],\n        callback: Callable[[Sphinx], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-get-outdated'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], Set[str], Set[str]], Sequence[str]\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-before-read-docs'],\n        callback: Callable[[Sphinx, BuildEnvironment, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-purge-doc'],\n        callback: Callable[[Sphinx, BuildEnvironment, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['source-read'],\n        callback: Callable[[Sphinx, str, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['include-read'],\n        callback: Callable[[Sphinx, Path, str, list[str]], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['doctree-read'],\n        callback: Callable[[Sphinx, nodes.document], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-merge-info'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, Set[str], BuildEnvironment], None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], str],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['env-get-updated'],\n        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "events.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self,\n        name: Literal['env-check-consistency'],\n        callback: Callable[[Sphinx, BuildEnvironment], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['write-started'],\n        callback: Callable[[Sphinx, Builder], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['doctree-resolved'],\n        callback: Callable[[Sphinx, nodes.document, str], None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['missing-reference'],\n        callback: Callable[\n            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],\n            nodes.reference | None,\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['warn-missing-reference'],\n        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        name: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions--"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                dict[str, bool],\n                str | None,\n                str | None,\n            ],\n            tuple[str | None, str | None] | None,\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-bases'],\n        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-skip-member'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n                    'module', 'class', 'exception', 'function', 'method', 'attribute'\n                ],\n                str,\n                Any,\n                bool,\n                dict[str, bool],\n            ],\n            bool,\n        ]"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "bool | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['build-finished'],\n        callback: Callable[[Sphinx, Exception | None], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from builtin builders --------------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-collect-pages'],\n        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['html-page-context'],\n        callback: Callable[\n            [Sphinx, str, str, dict[str, Any], nodes.document], str | None\n        ],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['linkcheck-process-uri'],\n        callback: Callable[[Sphinx, str], str | None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from builtin extensions-- ----------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['object-description-transform'],\n        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    # ---- Events from first-party extensions --------------------------------\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-docstring'],\n        callback: _AutodocProcessDocstringListener,\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-before-process-signature'],\n        callback: Callable[[Sphinx, Any, bool], None],\n        priority: int = 500,\n    ) -> int: ...\n\n    @overload\n    def connect(\n        self,\n        event: Literal['autodoc-process-signature'],\n        callback: Callable[\n            [\n                Sphinx,\n                Literal[\n           "}], "retrieved_count": 10, "cost_time": 0.3468739986419678}
{"question": "How does Sphinx handle incremental builds?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx handles incremental builds through a sophisticated caching and state management system that tracks changes and only rebuilds what is necessary. The incremental build system is designed to significantly reduce build times for large documentation projects.\n\nThe incremental build system works through the following key mechanisms:\n\n1. **Environment Serialization**: The BuildEnvironment is serialized to disk after each build as a pickle file. This environment contains all the metadata, cross-references, and build state needed to determine what has changed.\n\n2. **Change Detection**: Sphinx tracks which source files have been modified since the last build by comparing file modification times with the cached environment data. Only files that have changed or are affected by changes are processed.\n\n3. **Dependency Tracking**: The environment maintains dependency information between documents, allowing Sphinx to determine which documents need to be rebuilt when a particular file changes. This includes both direct dependencies and transitive dependencies.\n\n4. **Doctree Caching**: Parsed source files are cached as \"doctree pickles\" in a `.doctrees` directory. These cached files can be shared between different builders and significantly speed up subsequent builds.\n\n5. **Configuration Change Detection**: Sphinx tracks changes to the configuration file (conf.py) and determines what needs to be rebuilt based on which configuration options have changed. Different configuration options specify different rebuild requirements.\n\n6. **Selective Rebuilding**: Users can specify individual files to rebuild using the `--write-all` option or by providing specific filenames, allowing for targeted rebuilding of only the necessary components.\n\n7. **Fresh Environment Option**: For cases where the cached environment might be corrupted or when a complete rebuild is needed, Sphinx provides the `--fresh-env` option to rebuild the environment completely.\n\n8. **Parallel Processing Integration**: The incremental build system works with Sphinx's parallel processing capabilities, allowing for efficient parallel rebuilding of changed files.\n\n9. **Extension State Persistence**: Extensions can store their own state in the environment, allowing them to participate in incremental builds and only process what has changed.\n\n10. **Error Recovery**: If the incremental build system encounters errors or corrupted cache files, it can fall back to a full rebuild to ensure consistency.\n\n11. **Memory Management**: The incremental build system is designed to manage memory efficiently, loading only the necessary cached data and cleaning up unused resources.\n\n12. **Build Performance Monitoring**: Sphinx provides information about what is being rebuilt and why, helping users understand the incremental build process and optimize their documentation structure.\n\nThis incremental build system allows Sphinx to handle large documentation projects efficiently by minimizing the amount of work needed for subsequent builds, while maintaining the accuracy and consistency of the generated documentation.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1615, "belongs_to": {"file_name": "test_incremental_reading.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Test the Builder class.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nimport pytest\n\nif TYPE_CHECKING:\n    from sphinx.testing.util import SphinxTestApp\n\n\n@pytest.mark.sphinx(\n    'dummy',\n    testroot='root',\n    srcdir='test_builder',\n    freshenv=True,\n)\ndef test_incremental_reading(app: SphinxTestApp) -> None:\n    # first reading\n    updated = app.builder.read()\n    assert set(updated) == app.env.found_docs == set(app.env.all_docs)\n    assert updated == sorted(updated)  # sorted by alphanumeric\n\n    # test if exclude_patterns works ok\n    assert 'subdir/excluded' not in app.env.found_docs\n\n    # before second reading, add, modify and remove source files\n    (app.srcdir / 'new.txt').write_text('New file\\n========\\n', encoding='utf8')\n    app.env.all_docs['index'] = 0  # mark as modified\n    (app.srcdir / 'autodoc.txt').unlink()\n\n    # second reading\n    updated = app.builder.read()\n\n    assert set(updated) == {'index', 'new'}\n    assert 'autodoc' not in app.env.all_docs\n    assert 'autodoc' not in app.env.found_docs\n\n\n@pytest.mark.sphinx(\n    'dummy',\n    testroot='warnings',\n    freshenv=True,\n)\ndef test_incremental_reading_for_missing_files(app: SphinxTestApp) -> None:\n    # first reading\n    updated = app.builder.read()\n    assert set(updated) == app.env.found_docs == set(app.env.all_docs)\n\n    # second reading\n    updated = app.builder.read()\n\n    # \"index\" is listed up to updated because it contains references\n    # to nonexisting downloadable or image files\n    assert set(updated) == {'index'}\n\n    sys.modules.pop('autodoc_fodder', None)\n"}, {"start_line": 9000, "end_line": 10634, "belongs_to": {"file_name": "util.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        if not list(self.outdir.iterdir()):\n            # if listdir is empty, do build.\n            super().build(force_all, filenames)\n            # otherwise, we can use built cache\n\n\ndef _clean_up_global_state() -> None:\n    # clean up Docutils global state\n    directives._directives.clear()  # type: ignore[attr-defined]\n    roles._roles.clear()  # type: ignore[attr-defined]\n    for node in additional_nodes:\n        delattr(nodes.GenericNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.GenericNodeVisitor, f'depart_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'visit_{node.__name__}')\n        delattr(nodes.SparseNodeVisitor, f'depart_{node.__name__}')\n    additional_nodes.clear()\n\n    # clean up Sphinx global state\n    sphinx.locale.translators.clear()\n\n    # clean up autodoc global state\n    sphinx.pycode.ModuleAnalyzer.cache.clear()\n\n\n# deprecated name -> (object to return, canonical path or '', removal version)\n_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {\n    'strip_escseq': (\n        strip_escape_sequences,\n        'sphinx.util.console.strip_escape_sequences',\n        (9, 0),\n    ),\n}\n\n\ndef __getattr__(name: str) -> Any:\n    if name not in _DEPRECATED_OBJECTS:\n        msg = f'module {__name__!r} has no attribute {name!r}'\n        raise AttributeError(msg)\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=remove)\n    return deprecated_object\n"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mand line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @final\n    def build(\n        self,\n        docnames: Iterable[str] | None,\n        summary: str | None = None,\n        method: Literal['all', 'specific', 'update'] = 'update',\n    ) -> None:\n        \"\"\"Main build method, usually called by a specific ``build_*`` method.\n\n        First updates the environment, and then calls\n        :meth:`!write`.\n        \"\"\"\n        if summary:\n            logger.info(bold(__('building [%s]: ')) + summary, self.name)  # NoQA: G003\n\n        # while reading, collect all warnings from docutils\n        with (\n            nullcontext()\n            if self._app._exception_on_warning\n            else logging.pending_warnings()\n        ):\n            updated_docnames = set(self.read())\n\n        doccount = len(updated_docnames)\n        logger.info(bold(__('looking for now-outdated files... ')), nonl=True)\n        updated_docnames.update(self.env.check_dependents(self._app, updated_docnames))\n        outdated = len(updated_docnames) - doccount\n        if outdate"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_environment.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/tests/test_environment", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ld()\n    output = strip_escape_sequences(app1.status.getvalue())\n    # assert 'The configuration has changed' not in output\n    assert '[new config] 1 added' in output\n\n    # incremental build (no config changed)\n    app2 = make_app(*args, **kwargs)\n    assert app2.env.config_status == CONFIG_OK\n    app2.build()\n    output = strip_escape_sequences(app2.status.getvalue())\n    assert 'The configuration has changed' not in output\n    assert '0 added, 0 changed, 0 removed' in output\n\n    # incremental build (config entry changed)\n    app3 = make_app(*args, confoverrides={'root_doc': 'indexx'}, **kwargs)\n    fname = app3.srcdir / 'index.rst'\n    other_fname = app3.srcdir / 'indexx.rst'\n    assert fname.is_file()\n    shutil.move(fname, other_fname)\n    assert app3.env.config_status == CONFIG_CHANGED\n    app3.build()\n    shutil.move(other_fname, fname)\n    output = strip_escape_sequences(app3.status.getvalue())\n    assert 'The configuration has changed' in output\n    assert \"[config changed ('master_doc')] 1 added,\" in output\n\n    # incremental build (extension changed)\n    app4 = make_app(\n        *args, confoverrides={'extensions': ['sphinx.ext.autodoc']}, **kwargs\n    )\n    assert app4.env.config_status == CONFIG_EXTENSIONS_CHANGED\n    app4.build()\n    want_str = \"[extensions changed ('sphinx.ext.autodoc')] 1 added\"\n    output = strip_escape_sequences(app4.status.getvalue())\n    assert 'The configuration has changed' not in output\n    assert want_str in output\n\n\n@pytest.mark.sphinx('dummy', testroot='root')\ndef test_images(app: SphinxTestApp) -> None:\n    app.build()\n\n    tree = app.env.get_doctree('images')\n    htmlbuilder = StandaloneHTMLBuilder(app, app.env)\n    htmlbuilder.init()\n    htmlbuilder.imgpath = 'dummy'\n    htmlbuilder.post_process_images(tree)\n    assert set(htmlbuilder.images.keys()) == {\n        'subdir/img.png',\n        'img.png',\n        'subdir/simg.png',\n        'svgimg.svg',\n        'img.foo.png',\n    }\n    assert set(htmlbuilder.images.values()) ="}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "for catalog in repo.catalogs:\n            if catalog.domain in domains and catalog.is_outdated():\n                catalogs.add(catalog)\n        message = __('targets for %d po files that are specified') % len(catalogs)\n        self.compile_catalogs(catalogs, message)\n\n    # TODO(stephenfin): This would make more sense as 'compile_outdated_catalogs'\n    def compile_update_catalogs(self) -> None:\n        repo = CatalogRepository(\n            self.srcdir,\n            self.config.locale_dirs,\n            self.config.language,\n            self.config.source_encoding,\n        )\n        catalogs = {c for c in repo.catalogs if c.is_outdated()}\n        message = __('targets for %d po files that are out of date') % len(catalogs)\n        self.compile_catalogs(catalogs, message)\n\n    # build methods\n\n    @final\n    def build_all(self) -> None:\n        \"\"\"Build all source files.\"\"\"\n        self.compile_all_catalogs()\n\n        self.build(None, summary=__('all source files'), method='all')\n\n    @final\n    def build_specific(self, filenames: Sequence[Path]) -> None:\n        \"\"\"Only rebuild as much as needed for changes in the *filenames*.\"\"\"\n        docnames: list[str] = []\n\n        filenames = [Path(filename).resolve() for filename in filenames]\n        for filename in filenames:\n            if not filename.is_file():\n                logger.warning(\n                    __('file %r given on command line does not exist, '), filename\n                )\n                continue\n\n            if not filename.is_relative_to(self.srcdir):\n                logger.warning(\n                    __(\n                        'file %r given on command line is not under the '\n                        'source directory, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docname = self.env.path2doc(filename)\n            if not docname:\n                logger.warning(\n                    __(\n                        'file %r given on com"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "l\n    def build_specific(self, filenames: Sequence[Path]) -> None:\n        \"\"\"Only rebuild as much as needed for changes in the *filenames*.\"\"\"\n        docnames: list[str] = []\n\n        filenames = [Path(filename).resolve() for filename in filenames]\n        for filename in filenames:\n            if not filename.is_file():\n                logger.warning(\n                    __('file %r given on command line does not exist, '), filename\n                )\n                continue\n\n            if not filename.is_relative_to(self.srcdir):\n                logger.warning(\n                    __(\n                        'file %r given on command line is not under the '\n                        'source directory, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docname = self.env.path2doc(filename)\n            if not docname:\n                logger.warning(\n                    __(\n                        'file %r given on command line is not a valid '\n                        'document, ignoring'\n                    ),\n                    filename,\n                )\n                continue\n\n            docnames.append(docname)\n\n        self.compile_specific_catalogs(filenames)\n\n        self.build(\n            docnames,\n            summary=__('%d source files given on command line') % len(docnames),\n            method='specific',\n        )\n\n    @final\n    def build_update(self) -> None:\n        \"\"\"Only rebuild what was changed or added since last build.\"\"\"\n        self.compile_update_catalogs()\n\n        to_build = self.get_outdated_docs()\n        if isinstance(to_build, str):\n            self.build(['__all__'], summary=to_build, method='update')\n        else:\n            to_build = set(to_build)\n            self.build(\n                to_build,\n                summary=__('targets for %d source files that are out of date')\n                % len(to_build),\n                method='update',\n            )\n\n    @"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif self._warncount == 1:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, 1 warning '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, 1 warning.')\n            else:\n                msg = __('build succeeded, 1 warning.')\n            logger.info(bold(msg))\n        else:\n            if self._fail_on_warnings:\n                self.statuscode = 1\n                msg = __(\n                    'build finished with problems, %s warnings '\n                    '(with warnings treated as errors).'\n                )\n            elif self.statuscode != 0:\n                msg = __('build finished with problems, %s warnings.')\n            else:\n                msg = __('build succeeded, %s warnings.')\n            logger.info(bold(msg), self._warncount)\n\n        if self.statuscode "}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me: Path) -> BuildEnvironment:\n        try:\n            with open(filename, 'rb') as f:\n                env = pickle.load(f)\n            env.setup(self)\n            self._fresh_env_used = False\n        except Exception as err:\n            logger.info(__('failed: %s'), err)\n            env = self._create_fresh_env()\n        return env\n\n    def _post_init_env(self) -> None:\n        if self._fresh_env_used:\n            self.env.find_files(self.config, self.builder)\n\n        self.env._builder_cls = self.builder.__class__\n\n    def preload_builder(self, name: str) -> None:\n        self.registry.preload_builder(self, name)\n\n    def create_builder(self, name: str) -> Builder:\n        if name is None:\n            logger.info(__('No builder selected, using default: html'))\n            name = 'html'\n\n        return self.registry.create_builder(self, name, self.env)\n\n    def _init_builder(self) -> None:\n        self.builder.init()\n        self.events.emit('builder-inited')\n\n    # ---- main \"build\" method -------------------------------------------------\n\n    def build(self, force_all: bool = False, filenames: Sequence[Path] = ()) -> None:\n        self.builder.phase = BuildPhase.READING\n        try:\n            if force_all:\n                self.builder.build_all()\n            elif filenames:\n                self.builder.build_specific(filenames)\n            else:\n                self.builder.build_update()\n\n            self.events.emit('build-finished', None)\n        except Exception as err:\n            # delete the saved env to force a fresh build next time\n            envfile = self.doctreedir / ENV_PICKLE_FILENAME\n            if envfile.is_file():\n                envfile.unlink()\n            self.events.emit('build-finished', err)\n            raise\n\n        if self._warncount == 0:\n            if self.statuscode != 0:\n                logger.info(bold(__('build finished with problems.')))\n            else:\n                logger.info(bold(__('build succeeded.')))\n        elif"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ildinfo.bak'\n                    )\n                    logger.info(bold(__('building [html]: ')) + msg)  # NoQA: G003\n\n                yield from self.env.found_docs\n                return\n\n        if self.templates:\n            template_mtime = int(self.templates.newest_template_mtime() * 10**6)\n            try:\n                old_mtime = _last_modified_time(build_info_path)\n            except Exception:\n                pass\n            else:\n                # Let users know they have a newer template\n                if template_mtime > old_mtime:\n                    logger.info(\n                        bold('building [html]: ')  # NoQA: G003\n                        + __(\n                            'template %s has been changed since the previous build, '\n                            'all docs will be rebuilt'\n                        ),\n                        self.templates.newest_template_name(),\n                    )\n        else:\n            template_mtime = 0\n        for docname in self.env.found_docs:\n            if docname not in self.env.all_docs:\n                logger.debug('[build target] did not in env: %r', docname)\n                yield docname\n                continue\n            target_name = self.get_output_path(docname)\n            try:\n                target_mtime = _last_modified_time(target_name)\n            except OSError:\n                target_mtime = 0\n            try:\n                doc_mtime = _last_modified_time(self.env.doc2path(docname))\n                srcmtime = max(doc_mtime, template_mtime)\n                if srcmtime > target_mtime:\n                    logger.debug(\n                        '[build target] target_name %r(%s), template(%s), docname %r(%s)',\n                        target_name,\n                        _format_rfc3339_microseconds(target_mtime),\n                        _format_rfc3339_microseconds(template_mtime),\n                        docname,\n                        _format_rfc3339_microseconds(doc_mtime),\n     "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders/html", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ose automatically!\n                return None\n\n    def get_outdated_docs(self) -> Iterator[str]:\n        build_info_path = self.outdir / '.buildinfo'\n        try:\n            build_info = BuildInfo.load(build_info_path)\n        except ValueError as exc:\n            logger.warning(__('Failed to read build info file: %r'), exc)\n        except OSError:\n            # ignore errors on reading\n            pass\n        else:\n            if self.build_info != build_info:\n                # log the mismatch and backup the old build info\n                build_info_backup = build_info_path.with_name('.buildinfo.bak')\n                try:\n                    shutil.move(build_info_path, build_info_backup)\n                    self.build_info.dump(build_info_path)\n                except OSError:\n                    pass  # ignore errors\n                else:\n                    # only log on success\n                    msg = __(\n                        'build_info mismatch, copying .buildinfo to .buildinfo.bak'\n                    )\n                    logger.info(bold(__('building [html]: ')) + msg)  # NoQA: G003\n\n                yield from self.env.found_docs\n                return\n\n        if self.templates:\n            template_mtime = int(self.templates.newest_template_mtime() * 10**6)\n            try:\n                old_mtime = _last_modified_time(build_info_path)\n            except Exception:\n                pass\n            else:\n                # Let users know they have a newer template\n                if template_mtime > old_mtime:\n                    logger.info(\n                        bold('building [html]: ')  # NoQA: G003\n                        + __(\n                            'template %s has been changed since the previous build, '\n                            'all docs will be rebuilt'\n                        ),\n                        self.templates.newest_template_name(),\n                    )\n        else:\n            template_mtime = 0\n        for docname"}], "retrieved_count": 10, "cost_time": 0.34467482566833496}
{"question": "How can Sphinx's extension API be used to create custom document processors?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's extension API can be used to create custom document processors through multiple mechanisms that allow extensions to modify and process documents at various stages of the build process. The extension API provides a comprehensive set of tools for document processing.\n\nCustom document processors can be created using the following key mechanisms:\n\n1. **Transform Registration**: Extensions can register custom transforms that are applied to document trees during the transformation phase. These transforms can modify document structure, add content, or perform other document manipulations. Transforms are registered using `app.add_transform()`.\n\n2. **Event-Based Processing**: Extensions can connect to document processing events like 'doctree-read' and 'doctree-resolved' to process documents at specific stages of the build. These events provide access to the document tree and allow for modifications.\n\n3. **Directive Implementation**: Extensions can create custom directives that process specific markup and generate document content. Directives are registered using `app.add_directive()` and can create complex document structures.\n\n4. **Role Implementation**: Extensions can create custom roles that process inline markup and generate reference nodes or other document elements. Roles are registered using `app.add_role()`.\n\n5. **Domain Extension**: Extensions can extend existing domains or create new domains to provide domain-specific document processing capabilities. This includes custom object types, directives, and roles for specific documentation domains.\n\n6. **Builder Integration**: Extensions can integrate with the builder system to add custom processing during the build phase. This can include custom output generation or document modification specific to certain output formats.\n\n7. **Environment Integration**: Extensions can store and retrieve data from the BuildEnvironment, allowing them to maintain state across the build process and implement features like caching and incremental processing.\n\n8. **Configuration Integration**: Extensions can add configuration options that control document processing behavior, allowing users to customize how documents are processed.\n\n9. **Parser Integration**: Extensions can register custom parsers for new input formats, allowing them to process documents written in custom markup languages.\n\n10. **Node Handler Registration**: Extensions can register custom node handlers for translators, allowing them to customize how specific node types are rendered in different output formats.\n\n11. **Cross-Reference Processing**: Extensions can implement custom cross-reference resolution logic, allowing them to handle special types of references or modify how existing references are processed.\n\n12. **Content Generation**: Extensions can generate content programmatically, such as automatic tables of contents, indexes, or other document elements.\n\nThe extension API provides a flexible and powerful framework for creating custom document processors that can integrate seamlessly with Sphinx's build process while maintaining the stability and performance of the core system.", "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "index.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ntries', {})\n\n    def clear_doc(self, docname: str) -> None:\n        self.entries.pop(docname, None)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        for docname in docnames:\n            self.entries[docname] = otherdata['entries'][docname]\n\n    def process_doc(self, env: BuildEnvironment, docname: str, document: Node) -> None:\n        \"\"\"Process a document after it is read by the environment.\"\"\"\n        entries = self.entries.setdefault(env.current_document.docname, [])\n        for node in list(document.findall(addnodes.index)):\n            node_entries = node['entries']\n            try:\n                for entry_type, value, _target_id, _main, _category_key in node_entries:\n                    split_index_msg(entry_type, value)\n            except ValueError as exc:\n                logger.warning(str(exc), location=node, type='index')\n                node.parent.remove(node)\n            else:\n                for entry in node_entries:\n                    entries.append(entry)\n\n\nclass IndexDirective(SphinxDirective):\n    \"\"\"Directive to add entries to the index.\"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec: ClassVar[OptionSpec] = {\n        'name': directives.unchanged,\n    }\n\n    def run(self) -> list[Node]:\n        arguments = self.arguments[0].split('\\n')\n\n        if 'name' in self.options:\n            targetname = self.options['name']\n            targetnode = nodes.target('', '', names=[targetname])\n        else:\n            targetid = 'index-%s' % self.env.new_serialno('index')\n            targetnode = nodes.target('', '', ids=[targetid])\n\n        self.state.document.note_explicit_target(targetnode)\n        indexnode = addnodes.index()\n        indexnode['entries'] = []\n        indexnode['inline'] = False\n        self.set_source_info(indexnode)\n        for entry in arguments:\n            indexnode['entries'].extend(\n            "}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nx.ext.autodoc`\n        extension.  It must be a subclass of\n        :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting\n        new types of objects.  See the source of the autodoc module for\n        examples on how to subclass :class:`~sphinx.ext.autodoc.Documenter`.\n\n        If *override* is True, the given *cls* is forcedly installed even if\n        a documenter having the same name is already installed.\n\n        See :ref:`autodoc_ext_tutorial`.\n\n        .. versionadded:: 0.6\n        .. versionchanged:: 2.2\n           Add *override* keyword.\n        \"\"\"\n        logger.debug('[app] adding autodocumenter: %r', cls)\n        from sphinx.ext.autodoc.directive import AutodocDirective\n\n        self.registry.add_documenter(cls.objtype, cls)\n        self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n\n    def add_autodoc_attrgetter(\n        self, typ: type, getter: Callable[[Any, str, Any], Any]\n    ) -> None:\n        \"\"\"Register a new ``getattr``-like function for the autodoc extension.\n\n        Add *getter*, which must be a function with an interface compatible to\n        the :func:`getattr` builtin, as the autodoc attribute getter for\n        objects that are instances of *typ*.  All cases where autodoc needs to\n        get an attribute of a type are then handled by this function instead of\n        :func:`getattr`.\n\n        .. versionadded:: 0.6\n        \"\"\"\n        logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))\n        self.registry.add_autodoc_attrgetter(typ, getter)\n\n    def add_search_language(self, cls: type[SearchLanguage]) -> None:\n        \"\"\"Register a new language for the HTML search index.\n\n        Add *cls*, which must be a subclass of\n        :class:`sphinx.search.SearchLanguage`, as a support language for\n        building the HTML full-text search index.  The class must have a *lang*\n        attribute that indicates the language it should be used for.  See\n        :confval:`html_search_languag"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/napoleon", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n self._config_values:\n            setattr(self, name, default)\n        for name, value in settings.items():\n            setattr(self, name, value)\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    \"\"\"Sphinx extension setup function.\n\n    When the extension is loaded, Sphinx imports this module and executes\n    the ``setup()`` function, which in turn notifies Sphinx of everything\n    the extension offers.\n\n    Parameters\n    ----------\n    app : sphinx.application.Sphinx\n        Application object representing the Sphinx process\n\n    See Also\n    --------\n    `The Sphinx documentation on Extensions\n    <https://www.sphinx-doc.org/extensions.html>`_\n\n    `The Extension Tutorial <https://www.sphinx-doc.org/extdev/tutorial.html>`_\n\n    `The Extension API <https://www.sphinx-doc.org/extdev/appapi.html>`_\n\n    \"\"\"\n    if not isinstance(app, Sphinx):\n        # probably called by tests\n        return {\n            'version': sphinx.__display_version__,\n            'parallel_read_safe': True,\n        }\n\n    _patch_python_domain()\n\n    app.setup_extension('sphinx.ext.autodoc')\n    app.connect('autodoc-process-docstring', _process_docstring)\n    app.connect('autodoc-skip-member', _skip_member)\n\n    for name, default, rebuild, types in Config._config_values:\n        app.add_config_value(name, default, rebuild, types=types)\n\n    return {\n        'version': sphinx.__display_version__,\n        'parallel_read_safe': True,\n    }\n\n\ndef _patch_python_domain() -> None:\n    from sphinx.domains.python._object import PyObject, PyTypedField\n    from sphinx.locale import _\n\n    for doc_field in PyObject.doc_field_types:\n        if doc_field.name == 'parameter':\n            doc_field.names = ('param', 'parameter', 'arg', 'argument')\n            break\n    PyObject.doc_field_types.append(\n        PyTypedField(\n            'keyword',\n            label=_('Keyword Arguments'),\n            names=('keyword', 'kwarg', 'kwparam'),\n            typerolename='class',\n            typenames=('paramtype'"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hinx\n    from sphinx.config import Config\n    from sphinx.domains.std import StandardDomain\n    from sphinx.environment import BuildEnvironment\n    from sphinx.util.typing import ExtensionMetadata\n\n    _DEFAULT_SUBSTITUTION_NAMES: TypeAlias = Literal[\n        'version',\n        'release',\n        'today',\n        'translation progress',\n    ]\n\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_SUBSTITUTIONS = frozenset({\n    'version',\n    'release',\n    'today',\n    'translation progress',\n})\n\n\nclass SphinxTransform(Transform):\n    \"\"\"A base class of Transforms.\n\n    Compared with ``docutils.transforms.Transform``, this class improves accessibility to\n    Sphinx APIs.\n    \"\"\"\n\n    @property\n    def app(self) -> Sphinx:\n        \"\"\"Reference to the :class:`.Sphinx` object.\"\"\"\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self.env._app\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n        return self.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\"\"\"\n        return self.env.config\n\n\nclass SphinxTransformer(Transformer):\n    \"\"\"A transformer for Sphinx.\"\"\"\n\n    document: nodes.document\n    env: BuildEnvironment | None = None\n\n    def set_environment(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n    def apply_transforms(self) -> None:\n        if isinstance(self.document, nodes.document):\n            if not hasattr(self.document.settings, 'env') and self.env:\n                self.document.settings.env = self.env\n\n            super().apply_transforms()  # type: ignore[misc]\n        else:\n            # wrap the target node by document node during transforming\n            try:\n                from sphinx.util.docutils import new_document\n\n                document = new_document('"}, {"start_line": 57000, "end_line": 59000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ackage('mypackage', 'foo,bar')\n           # => \\usepackage[foo,bar]{mypackage}\n\n        .. versionadded:: 1.3\n        .. versionadded:: 3.1\n\n           *after_hyperref* option.\n        \"\"\"\n        self.registry.add_latex_package(packagename, options, after_hyperref)\n\n    def add_lexer(self, alias: str, lexer: type[Lexer]) -> None:\n        \"\"\"Register a new lexer for source code.\n\n        Use *lexer* to highlight code blocks with the given language *alias*.\n\n        .. versionadded:: 0.6\n        .. versionchanged:: 2.1\n           Take a lexer class as an argument.\n        .. versionchanged:: 4.0\n           Removed support for lexer instances as an argument.\n        \"\"\"\n        logger.debug('[app] adding lexer: %r', (alias, lexer))\n        lexer_classes[alias] = lexer\n\n    def add_autodocumenter(self, cls: type[Documenter], override: bool = False) -> None:\n        \"\"\"Register a new documenter class for the autodoc extension.\n\n        Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n        extension.  It must be a subclass of\n        :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting\n        new types of objects.  See the source of the autodoc module for\n        examples on how to subclass :class:`~sphinx.ext.autodoc.Documenter`.\n\n        If *override* is True, the given *cls* is forcedly installed even if\n        a documenter having the same name is already installed.\n\n        See :ref:`autodoc_ext_tutorial`.\n\n        .. versionadded:: 0.6\n        .. versionchanged:: 2.2\n           Add *override* keyword.\n        \"\"\"\n        logger.debug('[app] adding autodocumenter: %r', cls)\n        from sphinx.ext.autodoc.directive import AutodocDirective\n\n        self.registry.add_documenter(cls.objtype, cls)\n        self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n\n    def add_autodoc_attrgetter(\n        self, typ: type, getter: Callable[[Any, str, Any], Any]\n    ) -> None:\n        \"\"\"Register a new ``getattr``"}, {"start_line": 33000, "end_line": 34721, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/ext/autosummary", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p_extension('sphinx.ext.autodoc')\n    app.add_node(\n        autosummary_toc,\n        html=(autosummary_toc_visit_html, autosummary_noop),\n        latex=(autosummary_noop, autosummary_noop),\n        text=(autosummary_noop, autosummary_noop),\n        man=(autosummary_noop, autosummary_noop),\n        texinfo=(autosummary_noop, autosummary_noop),\n    )\n    app.add_node(\n        autosummary_table,\n        html=(autosummary_table_visit_html, autosummary_noop),\n        latex=(autosummary_noop, autosummary_noop),\n        text=(autosummary_noop, autosummary_noop),\n        man=(autosummary_noop, autosummary_noop),\n        texinfo=(autosummary_noop, autosummary_noop),\n    )\n    app.add_directive('autosummary', Autosummary)\n    app.add_role('autolink', AutoLink())\n    app.connect('builder-inited', process_generate_options)\n    app.add_config_value('autosummary_context', {}, 'env', types=frozenset({dict}))\n    app.add_config_value(\n        'autosummary_filename_map', {}, 'html', types=frozenset({dict})\n    )\n    app.add_config_value(\n        'autosummary_generate', True, 'env', types=frozenset({bool, list})\n    )\n    app.add_config_value(\n        'autosummary_generate_overwrite', True, '', types=frozenset({bool})\n    )\n    app.add_config_value(\n        'autosummary_mock_imports',\n        lambda config: config.autodoc_mock_imports,\n        'env',\n        types=frozenset({list, tuple}),\n    )\n    app.add_config_value(\n        'autosummary_imported_members', False, '', types=frozenset({bool})\n    )\n    app.add_config_value(\n        'autosummary_ignore_module_all', True, 'env', types=frozenset({bool})\n    )\n\n    return {\n        'version': sphinx.__display_version__,\n        'parallel_read_safe': True,\n    }\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docuti"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}], "retrieved_count": 10, "cost_time": 0.3484320640563965}
{"question": "How can Sphinx's Builder API be extended to support new output formats?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's Builder API can be extended to support new output formats by creating custom builder classes that inherit from the appropriate base classes and implement the necessary methods for the new format. The Builder API provides a comprehensive framework for adding new output formats.\n\nNew output formats can be supported by extending the Builder API through the following key mechanisms:\n\n1. **Builder Class Inheritance**: Custom builders should inherit from the appropriate base builder class (typically `Builder` or a specific builder like `StandaloneHTMLBuilder`). This provides access to the core build workflow and common functionality.\n\n2. **Core Method Implementation**: Custom builders must implement the core build methods including `build()`, `read()`, `write()`, and `get_outdated_docs()`. These methods define the build workflow for the new format.\n\n3. **Format-Specific Configuration**: Custom builders can define format-specific configuration options by adding configuration values to the `config_values` dictionary. These options can control various aspects of the output format.\n\n4. **Writer Integration**: Custom builders typically work with custom writer classes that handle the actual output generation. The builder orchestrates the build process while the writer handles format-specific output generation.\n\n5. **Document Tree Processing**: Custom builders can implement format-specific document tree processing by overriding methods like `get_target_uri()` and `get_relative_uri()` to define how documents are linked and organized in the output.\n\n6. **Asset Management**: Custom builders can implement asset management for format-specific resources like images, stylesheets, or other media files that need to be included in the output.\n\n7. **Index Generation**: Custom builders can implement format-specific index generation by overriding methods like `write_genindex()` and `write_searchindex()` to create indexes appropriate for the new format.\n\n8. **Cross-Reference Handling**: Custom builders can implement format-specific cross-reference handling by overriding methods that process cross-references and generate appropriate links for the new format.\n\n9. **Extension Integration**: Custom builders can integrate with Sphinx's extension system by providing extension points and events specific to the new format.\n\n10. **Configuration Integration**: Custom builders can add configuration options that control various aspects of the output format, allowing users to customize the generated output.\n\n11. **Error Handling**: Custom builders should implement appropriate error handling for format-specific issues, providing helpful error messages and graceful degradation when possible.\n\n12. **Performance Optimization**: Custom builders should be designed for performance, with efficient algorithms for processing documents and generating output.\n\n13. **Registration**: Custom builders are registered with Sphinx's component registry using `app.add_builder()`, making them available for use in Sphinx projects.\n\n14. **Documentation**: Custom builders should provide documentation and examples showing how to use the new output format effectively.\n\nThis comprehensive extension mechanism allows developers to add support for new output formats while maintaining compatibility with Sphinx's core architecture and providing a consistent user experience.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n    allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n  "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self.post_transforms: list[type[Transform]] = []\n\n        #: source parsers; file type -> parser class\n        self.source_parsers: dict[str, type[Parser]] = {}\n\n        #: source suffix: suffix -> file type\n        self.source_suffix: dict[str, str] = {}\n\n        #: custom translators; builder name -> translator class\n        self.translators: dict[str, type[nodes.NodeVisitor]] = {}\n\n        #: custom handlers for translators\n        #: a dict of builder name -> dict of node name -> visitor and departure functions\n        self.translation_handlers: dict[str, dict[str, _NodeHandlerPair]] = {}\n\n        #: additional transforms; list of transforms\n        self.transforms: list[type[Transform]] = []\n\n    @property\n    def autodoc_attrgettrs(self) -> dict[type, Callable[[Any, str, Any], Any]]:\n        return self.autodoc_attrgetters\n\n    def add_builder(self, builder: type[Builder], override: bool = False) -> None:\n        logger.debug('[app] adding builder: %r', builder)\n        if not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n   "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f not hasattr(builder, 'name'):\n            raise ExtensionError(\n                __('Builder class %s has no \"name\" attribute') % builder\n            )\n        if builder.name in self.builders and not override:\n            raise ExtensionError(\n                __('Builder %r already exists (in module %s)')\n                % (builder.name, self.builders[builder.name].__module__)\n            )\n        self.builders[builder.name] = builder\n\n    def preload_builder(self, app: Sphinx, name: str) -> None:\n        if name is None:\n            return\n\n        if name not in self.builders:\n            builder_entry_points = entry_points(group='sphinx.builders')\n            try:\n                entry_point = builder_entry_points[name]\n            except KeyError as exc:\n                raise SphinxError(\n                    __(\n                        'Builder name %s not registered or available'\n                        ' through entry point'\n                    )\n                    % name\n                ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.dom"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ative_uri, relpath\nfrom sphinx.util.parallel import (\n    ParallelTasks,\n    SerialTasks,\n    make_chunks,\n    parallel_available,\n)\n\n# side effect: registers roles and directives\nfrom sphinx import directives  # NoQA: F401  isort:skip\nfrom sphinx import roles  # NoQA: F401  isort:skip\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable, Sequence, Set\n    from gettext import NullTranslations\n    from typing import Any, ClassVar, Literal\n\n    from docutils.nodes import Node\n\n    from sphinx.application import Sphinx\n    from sphinx.config import Config\n    from sphinx.environment import (\n        BuildEnvironment,\n    )\n    from sphinx.events import EventManager\n    from sphinx.util.i18n import CatalogInfo\n    from sphinx.util.tags import Tags\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Builder:\n    \"\"\"Builds target formats from the reST sources.\"\"\"\n\n    #: The builder's name.\n    #: This is the value used to select builders on the command line.\n    name: ClassVar[str] = ''\n    #: The builder's output format, or '' if no document output is produced.\n    #: This is commonly the file extension, e.g. \"html\",\n    #: though any string value is accepted.\n    #: The builder's format string can be used by various components\n    #: such as :class:`.SphinxPostTransform` or extensions to determine\n    #: their compatibility with the builder.\n    format: ClassVar[str] = ''\n    #: The message emitted upon successful build completion.\n    #: This can be a printf-style template string\n    #: with the following keys: ``outdir``, ``project``\n    epilog: ClassVar[str] = ''\n\n    #: default translator class for the builder.  This can be overridden by\n    #: :py:meth:`~sphinx.application.Sphinx.set_translator`.\n    default_translator_class: ClassVar[type[nodes.NodeVisitor]]\n    # doctree versioning method\n    versioning_method: ClassVar[str] = 'none'\n    versioning_compare: ClassVar[bool] = False\n    #: Whether it is safe to make parallel :meth:`~.Builder.write_doc` calls.\n   "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " allow_parallel: ClassVar[bool] = False\n    # support translation\n    use_message_catalog: ClassVar[bool] = True\n\n    #: The list of MIME types of image formats supported by the builder.\n    #: Image files are searched in the order in which they appear here.\n    supported_image_types: ClassVar[list[str]] = []\n    #: The builder can produce output documents that may fetch external images when opened.\n    supported_remote_images: ClassVar[bool] = False\n    #: The file format produced by the builder allows images to be embedded using data-URIs.\n    supported_data_uri_images: ClassVar[bool] = False\n\n    phase: BuildPhase = BuildPhase.INITIALIZATION\n\n    srcdir = _StrPathProperty()\n    confdir = _StrPathProperty()\n    outdir = _StrPathProperty()\n    doctreedir = _StrPathProperty()\n\n    def __init__(self, app: Sphinx, env: BuildEnvironment) -> None:\n        self.srcdir = app.srcdir\n        self.confdir = app.confdir\n        self.outdir = app.outdir\n        self.doctreedir = app.doctreedir\n        ensuredir(self.doctreedir)\n\n        self._app: Sphinx = app\n        self.env: BuildEnvironment = env\n        self.env.set_versioning_method(self.versioning_method, self.versioning_compare)\n        self.events: EventManager = app.events\n        self.config: Config = app.config\n        self.tags: Tags = app.tags\n        self.tags.add(self.format)\n        self.tags.add(self.name)\n        self.tags.add(f'format_{self.format}')\n        self.tags.add(f'builder_{self.name}')\n        self._registry = app.registry\n\n        # images that need to be copied over (source -> dest)\n        self.images: dict[str, str] = {}\n        # basename of images directory\n        self.imagedir = ''\n        # relative path to image directory from current docname (used at writing docs)\n        self.imgpath = ''\n\n        # these get set later\n        self.parallel_ok = False\n        self.finish_tasks: Any = None\n\n    @property\n    def app(self) -> Sphinx:\n        cls_module = self.__class__.__module__\n       "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "i18n.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/util", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"Builder superclass for all builders.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport os.path\nimport re\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\n\nimport babel.dates\nfrom babel.messages.mofile import write_mo\nfrom babel.messages.pofile import read_po\n\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util._pathlib import _StrPath\nfrom sphinx.util.osutil import SEP, _last_modified_time\n\nif TYPE_CHECKING:\n    import datetime as dt\n    from collections.abc import Iterator\n    from typing import Protocol, TypeAlias\n\n    from babel.core import Locale\n\n    from sphinx.environment import BuildEnvironment\n\n    class DateFormatter(Protocol):\n        def __call__(\n            self,\n            date: dt.date | None = ...,\n            format: str = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class TimeFormatter(Protocol):\n        def __call__(\n            self,\n            time: dt.time | dt.datetime | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    class DatetimeFormatter(Protocol):\n        def __call__(\n            self,\n            datetime: dt.date | dt.time | float | None = ...,\n            format: str = ...,\n            tzinfo: dt.tzinfo | None = ...,\n            locale: str | Locale | None = ...,\n        ) -> str: ...\n\n    Formatter: TypeAlias = DateFormatter | TimeFormatter | DatetimeFormatter\n\nfrom datetime import UTC\n\nlogger = logging.getLogger(__name__)\n\n\nclass CatalogInfo:\n    __slots__ = 'base_dir', 'domain', 'charset'\n\n    def __init__(\n        self, base_dir: str | os.PathLike[str], domain: str, charset: str\n    ) -> None:\n        self.base_dir = _StrPath(base_dir)\n        self.domain = domain\n        self.charset = charset\n\n    @property\n    def po_file(self) -> str:\n        return f'{self.domain}.po'\n\n    @property\n "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      ensuredir(self.doctreedir)\n\n        self._app: Sphinx = app\n        self.env: BuildEnvironment = env\n        self.env.set_versioning_method(self.versioning_method, self.versioning_compare)\n        self.events: EventManager = app.events\n        self.config: Config = app.config\n        self.tags: Tags = app.tags\n        self.tags.add(self.format)\n        self.tags.add(self.name)\n        self.tags.add(f'format_{self.format}')\n        self.tags.add(f'builder_{self.name}')\n        self._registry = app.registry\n\n        # images that need to be copied over (source -> dest)\n        self.images: dict[str, str] = {}\n        # basename of images directory\n        self.imagedir = ''\n        # relative path to image directory from current docname (used at writing docs)\n        self.imgpath = ''\n\n        # these get set later\n        self.parallel_ok = False\n        self.finish_tasks: Any = None\n\n    @property\n    def app(self) -> Sphinx:\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self._app\n\n    @property\n    def _translator(self) -> NullTranslations | None:\n        return self._app.translator\n\n    def get_translator_class(self, *args: Any) -> type[nodes.NodeVisitor]:\n        \"\"\"Return a class of translator.\"\"\"\n        return self._registry.get_translator_class(self)\n\n    def create_translator(self, *args: Any) -> nodes.NodeVisitor:\n        \"\"\"Return an instance of translator.\n\n        This method returns an instance of ``default_translator_class`` by default.\n        Users can replace the translator class with ``app.set_translator()`` API.\n        \"\"\"\n        return self._registry.create_translator(self, *args)\n\n    # helper methods\n    def init(self) -> None:\n        \"\"\"Load necessary templates and perform initialization.  The default\n        implementation does nothing.\n        \"\"\"\n        pass\n\n    def create_template_bridge(self"}, {"start_line": 30000, "end_line": 32000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hunk in chunks:\n            arg = []\n            for docname in chunk:\n                doctree = self.env.get_and_resolve_doctree(\n                    docname, self, tags=self.tags\n                )\n                self.write_doc_serialized(docname, doctree)\n                arg.append((docname, doctree))\n            tasks.add_task(write_process, arg, on_chunk_done)\n\n        # make sure all threads have finished\n        tasks.join()\n        logger.info('')\n\n    def prepare_writing(self, docnames: Set[str]) -> None:\n        \"\"\"A place where you can add logic before :meth:`write_doc` is run\"\"\"\n        pass\n\n    def copy_assets(self) -> None:\n        \"\"\"Where assets (images, static files, etc) are copied before writing\"\"\"\n        pass\n\n    def write_doc(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Write the output file for the document\n\n        :param docname: the :term:`docname <document name>`.\n        :param doctree: defines the content to be written.\n\n        The output filename must be determined within this method,\n        typically by calling :meth:`~.Builder.get_target_uri`\n        or :meth:`~.Builder.get_relative_uri`.\n        \"\"\"\n        raise NotImplementedError\n\n    def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n        \"\"\"Handle parts of write_doc that must be called in the main process\n        if parallel build is active.\n        \"\"\"\n        pass\n\n    def finish(self) -> None:\n        \"\"\"Finish the building process.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def cleanup(self) -> None:\n        \"\"\"Cleanup any resources.\n\n        The default implementation does nothing.\n        \"\"\"\n        pass\n\n    def get_builder_config(self, option: str, default: str) -> Any:\n        \"\"\"Return a builder specific option.\n\n        This method allows customization of common builder settings by\n        inserting the name of the current builder in the option key.\n        If the key does not"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             ) from exc\n\n            self.load_extension(app, entry_point.module)\n\n    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -> Builder:\n        if name not in self.builders:\n            raise SphinxError(__('Builder name %s not registered') % name)\n\n        return self.builders[name](app, env)\n\n    def add_domain(self, domain: type[Domain], override: bool = False) -> None:\n        logger.debug('[app] adding domain: %r', domain)\n        if domain.name in self.domains and not override:\n            raise ExtensionError(__('domain %s already registered') % domain.name)\n        self.domains[domain.name] = domain\n\n    def has_domain(self, domain: str) -> bool:\n        return domain in self.domains\n\n    def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n        for DomainClass in self.domains.values():\n            domain = DomainClass(env)\n\n            # transplant components added by extensions\n            domain.directives.update(self.domain_directives.get(domain.name, {}))\n            domain.roles.update(self.domain_roles.get(domain.name, {}))\n            domain.indices.extend(self.domain_indices.get(domain.name, []))\n            for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n                domain.add_object_type(name, objtype)\n\n            yield domain\n\n    def add_directive_to_domain(\n        self, domain: str, name: str, cls: type[Directive], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n\n        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(\n            domain, {}\n        )\n        if name in directives and not override:\n            raise ExtensionError(\n                __('The %r directive is already registered to domain %s')\n                % (name, domain)\n         "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/builders", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self._app\n\n    @property\n    def _translator(self) -> NullTranslations | None:\n        return self._app.translator\n\n    def get_translator_class(self, *args: Any) -> type[nodes.NodeVisitor]:\n        \"\"\"Return a class of translator.\"\"\"\n        return self._registry.get_translator_class(self)\n\n    def create_translator(self, *args: Any) -> nodes.NodeVisitor:\n        \"\"\"Return an instance of translator.\n\n        This method returns an instance of ``default_translator_class`` by default.\n        Users can replace the translator class with ``app.set_translator()`` API.\n        \"\"\"\n        return self._registry.create_translator(self, *args)\n\n    # helper methods\n    def init(self) -> None:\n        \"\"\"Load necessary templates and perform initialization.  The default\n        implementation does nothing.\n        \"\"\"\n        pass\n\n    def create_template_bridge(self) -> None:\n        \"\"\"Return the template bridge configured.\"\"\"\n        if self.config.template_bridge:\n            template_bridge_cls = import_object(\n                self.config.template_bridge,\n                source='template_bridge setting',\n            )\n            self.templates = template_bridge_cls()\n        else:\n            from sphinx.jinja2glue import BuiltinTemplateLoader\n\n            self.templates = BuiltinTemplateLoader()\n\n    def get_target_uri(self, docname: str, typ: str | None = None) -> str:\n        \"\"\"Return the target URI for a document name.\n\n        *typ* can be used to qualify the link characteristic for individual\n        builders.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_relative_uri(self, from_: str, to: str, typ: str | None = None) -> str:\n        \"\"\"Return a relative URI between two source filenames.\n\n        :raises: :exc:`!NoUri` if there's no way to return a sensible URI.\n        \"\"\"\n        return relative_uri(\n            self.ge"}], "retrieved_count": 10, "cost_time": 0.3453347682952881}
{"question": "How can Sphinx's Domain API be used to implement custom cross-reference systems?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's Domain API can be used to implement custom cross-reference systems by creating domain classes that provide specialized cross-reference resolution logic for specific types of documentation objects. The Domain API provides a comprehensive framework for implementing domain-specific cross-reference functionality.\n\nCustom cross-reference systems can be implemented using the Domain API through the following key mechanisms:\n\n1. **Domain Class Creation**: Custom domains should inherit from the base `Domain` class and implement the necessary methods for cross-reference resolution. This includes the `resolve_xref()` method which is the core of cross-reference resolution.\n\n2. **Object Type Definition**: Custom domains define object types through the `object_types` attribute, which maps object type names to `ObjType` instances. Each object type specifies which roles can be used to reference objects of that type.\n\n3. **Role Registration**: Custom domains register domain-specific roles that create cross-references to objects within the domain. These roles are registered in the `roles` attribute and are processed during the parsing phase.\n\n4. **Data Storage**: Custom domains store information about documented objects in their `data` attribute, which is stored in the environment's `domaindata`. This data includes object names, locations, and other metadata needed for cross-reference resolution.\n\n5. **Cross-Reference Resolution**: The `resolve_xref()` method implements the core logic for resolving cross-references. This method receives the reference information and returns the appropriate target object or reference node.\n\n6. **Object Description Collection**: Custom domains collect information about documented objects during the reading phase by processing directives and storing object metadata. This information is used during cross-reference resolution.\n\n7. **Index Generation**: Custom domains can provide custom indices for their objects by implementing the `get_objects()` method. This allows for specialized indexing and search functionality.\n\n8. **Cross-Domain References**: Custom domains can implement logic for handling cross-references to objects in other domains, allowing for flexible reference resolution across different documentation domains.\n\n9. **Reference Data Management**: Custom domains manage reference data including object relationships, inheritance hierarchies, and other domain-specific metadata that affects cross-reference resolution.\n\n10. **Error Handling**: Custom domains implement domain-specific error handling for cross-reference resolution, providing helpful error messages for broken references.\n\n11. **Extension Integration**: Custom domains integrate with Sphinx's extension system, allowing extensions to extend existing domains or create new domains with custom cross-reference functionality.\n\n12. **Configuration Integration**: Custom domains can add configuration options that control cross-reference behavior, allowing users to customize how references are resolved.\n\n13. **Performance Optimization**: Custom domains should implement efficient data structures and algorithms for storing and retrieving cross-reference information.\n\n14. **Documentation**: Custom domains should provide documentation and examples showing how to use the custom cross-reference system effectively.\n\nThis comprehensive framework allows developers to implement sophisticated cross-reference systems that are tailored to specific documentation domains while maintaining compatibility with Sphinx's core cross-reference architecture.", "score": null, "retrieved_content": [{"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            declaration.get_newest_id(),\n            contnode,\n            display_name,\n        ), declaration.objectType\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        return self._resolve_xref_inner(\n            env, fromdocname, builder, typ, target, node, contnode\n        )[0]\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        with logging.suppress_logging():\n            retnode, objtype = self._resolve_xref_inner(\n                env, fromdocname, builder, 'any', target, node, contnode\n            )\n        if retnode:\n            return [('c:' + self.role_for_objtype(objtype), retnode)]\n        return []\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        root_symbol = self.data['root_symbol']\n        for symbol in root_symbol.get_all_symbols():\n            if symbol.declaration is None:\n                continue\n            assert symbol.docname\n            full_nested_name = symbol.get_full_nested_name()\n            name = str(full_nested_name).lstrip('.')\n            dispname = full_nested_name.get_display_string().lstrip('.')\n            object_type = symbol.declaration.objectType\n            docname = symbol.docname\n            newest_id = symbol.declaration.get_newest_id()\n            yield name, dispname, object_type, docname, newest_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(CDomain)\n    app.add_config_value('c_id_attributes', [], 'env', types=frozenset({list, tuple}))\n    app.add_config_value(\n        'c_paren_attributes', [], 'env', types=frozenset({list, tuple})\n    )\n    app.add_config_"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# methods that should be overwritten\n\n    def clear_doc(self, docname: str) -> None:\n        \"\"\"Remove traces of a document in the domain-specific inventories.\"\"\"\n        pass\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        \"\"\"Merge in data regarding *docnames* from a different domaindata\n        inventory (coming from a subprocess in parallel builds).\n        \"\"\"\n        msg = (\n            f'merge_domaindata must be implemented in {self.__class__} '\n            'to be able to do parallel builds!'\n        )\n        raise NotImplementedError(msg)\n\n    def process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        \"\"\"Process a document after it is read by the environment.\"\"\"\n        pass\n\n    def check_consistency(self) -> None:\n        \"\"\"Do consistency checks (**experimental**).\"\"\"\n        pass\n\n    def process_field_xref(self, pnode: pending_xref) -> None:\n        \"\"\"Process a pending xref created in a doc field.\n        For example, attach information about the current scope.\n        \"\"\"\n        pass\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        \"\"\"Resolve the pending_xref *node* with the given *typ* and *target*.\n\n        This method should return a new node, to replace the xref node,\n        containing the *contnode* which is the markup content of the\n        cross-reference.\n\n        If no resolution can be found, None can be returned; the xref node will\n        then given to the :event:`missing-reference` event, and if that yields no\n        resolution, replaced by *contnode*.\n\n        The method can also raise :exc:`sphinx.environment.NoUri` to suppress\n        the :event:`missing-reference` event being emitted.\n        \"\"\"\n        pass\n\n    def resolve_"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " xref created in a doc field.\n        For example, attach information about the current scope.\n        \"\"\"\n        pass\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        \"\"\"Resolve the pending_xref *node* with the given *typ* and *target*.\n\n        This method should return a new node, to replace the xref node,\n        containing the *contnode* which is the markup content of the\n        cross-reference.\n\n        If no resolution can be found, None can be returned; the xref node will\n        then given to the :event:`missing-reference` event, and if that yields no\n        resolution, replaced by *contnode*.\n\n        The method can also raise :exc:`sphinx.environment.NoUri` to suppress\n        the :event:`missing-reference` event being emitted.\n        \"\"\"\n        pass\n\n    def resolve_any_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        \"\"\"Resolve the pending_xref *node* with the given *target*.\n\n        The reference comes from an \"any\" or similar role, which means that we\n        don't know the type.  Otherwise, the arguments are the same as for\n        :meth:`resolve_xref`.\n\n        The method must return a list (potentially empty) of tuples\n        ``('domain:role', newnode)``, where ``'domain:role'`` is the name of a\n        role that could have created the same reference, e.g. ``'py:func'``.\n        ``newnode`` is what :meth:`resolve_xref` would return.\n\n        .. versionadded:: 1.3\n        \"\"\"\n        raise NotImplementedError\n\n    def get_objects(self) -> Iterable[tuple[str, str, str, str, str, int]]:\n        \"\"\"Return an iterable of \"object descriptions\".\n\n        Object descri"}, {"start_line": 10000, "end_line": 11280, "belongs_to": {"file_name": "rst.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> list[tuple[str, nodes.reference]]:\n        results: list[tuple[str, nodes.reference]] = []\n        for objtype in self.object_types:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                results.append((\n                    f'rst:{self.role_for_objtype(objtype)}',\n                    make_refnode(\n                        builder,\n                        fromdocname,\n                        todocname,\n                        node_id,\n                        contnode,\n                        f'{target} {objtype}',\n                    ),\n                ))\n        return results\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        for (typ, name), (docname, node_id) in self.data['objects'].items():\n            yield name, name, typ, docname, node_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(ReSTDomain)\n\n    return {\n        'version': 'builtin',\n        'env_version': 2,\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/std", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ch': ('search', '', _('Search Page')),\n        },\n        'anonlabels': {  # labelname -> docname, labelid\n            'genindex': ('genindex', ''),\n            'modindex': ('py-modindex', ''),\n            'search': ('search', ''),\n        },\n    }\n\n    # labelname -> docname, sectionname\n    _virtual_doc_names: Final = {\n        'genindex': ('genindex', _('Index')),\n        'modindex': ('py-modindex', _('Module Index')),\n        'search': ('search', _('Search Page')),\n    }\n\n    dangling_warnings = {\n        'term': 'term not in glossary: %(target)r',\n        'numref': 'undefined label: %(target)r',\n        'keyword': 'unknown keyword: %(target)r',\n        'doc': 'unknown document: %(target)r',\n        'option': 'unknown option: %(target)r',\n    }\n\n    # node_class -> (figtype, title_getter)\n    enumerable_nodes = {\n        nodes.figure: ('figure', None),\n        nodes.table: ('table', None),\n        nodes.container: ('code-block', None),\n    }\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        super().__init__(env)\n\n        # set up enumerable nodes\n\n        # create a copy for this instance\n        self.enumerable_nodes = copy(self.enumerable_nodes)  # type: ignore[misc]\n        for node, settings in env._registry.enumerable_nodes.items():\n            self.enumerable_nodes[node] = settings\n\n    def note_hyperlink_target(\n        self, name: str, docname: str, node_id: str, title: str = ''\n    ) -> None:\n        \"\"\"Add a hyperlink target for cross reference.\n\n        .. warning::\n\n           This is only for internal use.  Please don't use this from your extension.\n           ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to\n           add a hyperlink target to the document.\n\n           This only adds a hyperlink target to the StandardDomain.  And this does not add a\n           node_id to node.  Therefore, it is very fragile to calling this without\n           understanding hyperlink target framework in both docutils "}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "('clear_doc end: %s', docname)\n\n    def process_doc(\n        self, env: BuildEnvironment, docname: str, document: nodes.document\n    ) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('process_doc: %s', docname)\n            logger.debug(self.data['root_symbol'].dump(0))\n            logger.debug('process_doc end: %s', docname)\n\n    def process_field_xref(self, pnode: pending_xref) -> None:\n        pnode.attributes.update(self.env.ref_context)\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        if Symbol.debug_show_tree:\n            logger.debug('merge_domaindata:')\n            logger.debug('\\tself:')\n            logger.debug(self.data['root_symbol'].dump(1))\n            logger.debug('\\tself end')\n            logger.debug('\\tother:')\n            logger.debug(otherdata['root_symbol'].dump(1))\n            logger.debug('\\tother end')\n            logger.debug('merge_domaindata end')\n\n        self.data['root_symbol'].merge_with(\n            otherdata['root_symbol'], docnames, self.env\n        )\n        our_objects = self.data['objects']\n        for fullname, (fn, id_, objtype) in otherdata['objects'].items():\n            if fn in docnames:\n                if fullname not in our_objects:\n                    our_objects[fullname] = (fn, id_, objtype)\n                # no need to warn on duplicates, the symbol merge already does that\n\n    def _resolve_xref_inner(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> tuple[nodes.reference, str] | tuple[None, None]:\n        parser = DefinitionParser(target, location=node, config=env.config)\n        try:\n            name = parser.parse_xref_object()\n        except DefinitionError as e:\n            logger.warning(\n                'Unparseable C cross-reference: %r\\n%s', target, e, location=node\n            )\n            ret"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "rst.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "objtype\n    }\n\n    @property\n    def objects(self) -> dict[tuple[str, str], tuple[str, str]]:\n        # (objtype, fullname) -> (docname, node_id)\n        return self.data.setdefault('objects', {})\n\n    def note_object(\n        self, objtype: str, name: str, node_id: str, location: Any = None\n    ) -> None:\n        if (objtype, name) in self.objects:\n            docname, node_id = self.objects[objtype, name]\n            logger.warning(\n                __('duplicate description of %s %s, other instance in %s'),\n                objtype,\n                name,\n                docname,\n                location=location,\n            )\n\n        self.objects[objtype, name] = (self.env.current_document.docname, node_id)\n\n    def clear_doc(self, docname: str) -> None:\n        for (typ, name), (doc, _node_id) in list(self.objects.items()):\n            if doc == docname:\n                del self.objects[typ, name]\n\n    def merge_domaindata(self, docnames: Set[str], otherdata: dict[str, Any]) -> None:\n        # XXX check duplicates\n        for (typ, name), (doc, node_id) in otherdata['objects'].items():\n            if doc in docnames:\n                self.objects[typ, name] = (doc, node_id)\n\n    def resolve_xref(\n        self,\n        env: BuildEnvironment,\n        fromdocname: str,\n        builder: Builder,\n        typ: str,\n        target: str,\n        node: pending_xref,\n        contnode: Element,\n    ) -> nodes.reference | None:\n        objtypes = self.objtypes_for_role(typ)\n        if not objtypes:\n            return None\n        for objtype in objtypes:\n            result = self.objects.get((objtype, target))\n            if result:\n                todocname, node_id = result\n                return make_refnode(\n                    builder,\n                    fromdocname,\n                    todocname,\n                    node_id,\n                    contnode,\n                    f'{target} {objtype}',\n                )\n        return None\n\n    def resolve_any_xref(\n       "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "arded.\n    \"\"\"\n\n    #: domain name: should be short, but unique\n    name: ClassVar[str] = ''\n    #: domain label: longer, more descriptive (used in messages)\n    label: ClassVar[str] = ''\n    #: type (usually directive) name -> ObjType instance\n    object_types: ClassVar[dict[str, ObjType]] = {}\n    #: directive name -> directive class\n    directives: ClassVar[dict[str, type[Directive]]] = {}\n    #: role name -> role callable\n    roles: ClassVar[dict[str, RoleFunction | XRefRole]] = {}\n    #: a list of Index subclasses\n    indices: ClassVar[list[type[Index]]] = []\n    #: role name -> a warning message if reference is missing\n    dangling_warnings: ClassVar[dict[str, str]] = {}\n    #: node_class -> (enum_node_type, title_getter)\n    enumerable_nodes: ClassVar[dict[type[Node], tuple[str, TitleGetter | None]]] = {}\n    #: data value for a fresh environment\n    initial_data: ClassVar[dict[str, Any]] = {}\n    #: data value\n    data: dict[str, Any]\n    #: data version, bump this when the format of `self.data` changes\n    data_version: ClassVar[int] = 0\n\n    def __init__(self, env: BuildEnvironment) -> None:\n        domain_data: dict[str, dict[str, Any]] = env.domaindata\n        self.env: BuildEnvironment = env\n        self._role_cache: dict[str, RoleFunction] = {}\n        self._directive_cache: dict[str, type[Directive]] = {}\n        self._role2type: dict[str, list[str]] = {}\n        self._type2role: dict[str, str] = {}\n\n        # convert class variables to instance one (to enhance through API)\n        self.object_types = dict(self.object_types)  # type: ignore[misc]\n        self.directives = dict(self.directives)  # type: ignore[misc]\n        self.roles = dict(self.roles)  # type: ignore[misc]\n        self.indices = list(self.indices)  # type: ignore[misc]\n\n        if self.name not in domain_data:\n            assert isinstance(self.initial_data, dict)\n            new_data = copy.deepcopy(self.initial_data)\n            new_data['version'] = self.data_version\n            s"}, {"start_line": 33000, "end_line": 34475, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/domains/c", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "retnode)]\n        return []\n\n    def get_objects(self) -> Iterator[tuple[str, str, str, str, str, int]]:\n        root_symbol = self.data['root_symbol']\n        for symbol in root_symbol.get_all_symbols():\n            if symbol.declaration is None:\n                continue\n            assert symbol.docname\n            full_nested_name = symbol.get_full_nested_name()\n            name = str(full_nested_name).lstrip('.')\n            dispname = full_nested_name.get_display_string().lstrip('.')\n            object_type = symbol.declaration.objectType\n            docname = symbol.docname\n            newest_id = symbol.declaration.get_newest_id()\n            yield name, dispname, object_type, docname, newest_id, 1\n\n\ndef setup(app: Sphinx) -> ExtensionMetadata:\n    app.add_domain(CDomain)\n    app.add_config_value('c_id_attributes', [], 'env', types=frozenset({list, tuple}))\n    app.add_config_value(\n        'c_paren_attributes', [], 'env', types=frozenset({list, tuple})\n    )\n    app.add_config_value(\n        'c_extra_keywords',\n        _macro_keywords,\n        'env',\n        types=frozenset({frozenset, list, set, tuple}),\n    )\n    app.add_config_value(\n        'c_maximum_signature_line_length',\n        None,\n        'env',\n        types=frozenset({int, NoneType}),\n    )\n    app.add_post_transform(AliasTransform)\n\n    return {\n        'version': 'builtin',\n        'env_version': 3,\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }\n"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   )\n        directives[name] = cls\n\n    def add_role_to_domain(\n        self,\n        domain: str,\n        name: str,\n        role: RoleFunction | XRefRole,\n        override: bool = False,\n    ) -> None:\n        logger.debug('[app] adding role to domain: %r', (domain, name, role))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n        roles = self.domain_roles.setdefault(domain, {})\n        if name in roles and not override:\n            raise ExtensionError(\n                __('The %r role is already registered to domain %s') % (name, domain)\n            )\n        roles[name] = role\n\n    def add_index_to_domain(\n        self, domain: str, index: type[Index], override: bool = False\n    ) -> None:\n        logger.debug('[app] adding index to domain: %r', (domain, index))\n        if domain not in self.domains:\n            raise ExtensionError(__('domain %s not yet registered') % domain)\n        indices = self.domain_indices.setdefault(domain, [])\n        if index in indices and not override:\n            raise ExtensionError(\n                __('The %r index is already registered to domain %s')\n                % (index.name, domain)\n            )\n        indices.append(index)\n\n    def add_object_type(\n        self,\n        directivename: str,\n        rolename: str,\n        indextemplate: str = '',\n        parse_node: Callable[[BuildEnvironment, str, addnodes.desc_signature], str]\n        | None = None,\n        ref_nodeclass: type[TextElement] | None = None,\n        objname: str = '',\n        doc_field_types: Sequence[Field] = (),\n        override: bool = False,\n    ) -> None:\n        logger.debug(\n            '[app] adding object type: %r',\n            (\n                directivename,\n                rolename,\n                indextemplate,\n                parse_node,\n                ref_nodeclass,\n                objname,\n                doc_field_types,\n            ),\n        )\n\n        # create a s"}], "retrieved_count": 10, "cost_time": 0.35335469245910645}
{"question": "How can Sphinx's event system API be leveraged for custom document transformations?", "answer": null, "relative_code_list": null, "ground_truth": "Sphinx's event system API can be leveraged for custom document transformations by connecting event handlers to specific events that are emitted during the document processing phases. The event system provides a powerful and flexible mechanism for implementing custom document transformations.\n\nCustom document transformations can be implemented using the event system API through the following key mechanisms:\n\n1. **Event Connection**: Extensions can connect to document processing events using the `app.events.connect()` method. Key events for document transformations include 'doctree-read', 'doctree-resolved', and 'env-before-read-docs'.\n\n2. **Document Tree Access**: Event handlers receive the document tree as an argument, allowing them to traverse and modify the document structure. The document tree is a docutils document object that can be manipulated programmatically.\n\n3. **Node Traversal**: Custom transformations can traverse the document tree using docutils node traversal methods, allowing them to find and modify specific types of nodes or content.\n\n4. **Node Modification**: Event handlers can modify document nodes by adding, removing, or replacing nodes in the document tree. This allows for complex transformations like adding content, restructuring sections, or modifying formatting.\n\n5. **Cross-Reference Processing**: Event handlers can process and modify cross-references by working with reference nodes and the environment's cross-reference data.\n\n6. **Content Generation**: Custom transformations can generate new content programmatically, such as automatic tables of contents, indexes, or other document elements.\n\n7. **Conditional Transformations**: Event handlers can implement conditional logic to apply transformations only under certain conditions, such as specific document types or configuration settings.\n\n8. **Environment Integration**: Event handlers have access to the BuildEnvironment, allowing them to store and retrieve data that persists across the build process.\n\n9. **Configuration Integration**: Custom transformations can be controlled through configuration options, allowing users to enable, disable, or customize transformation behavior.\n\n10. **Error Handling**: Event handlers should implement appropriate error handling to ensure that transformation failures don't break the build process.\n\n11. **Performance Optimization**: Custom transformations should be designed for performance, with efficient algorithms and minimal impact on build times.\n\n12. **Extension Integration**: Custom transformations can integrate with other extension components like directives, roles, and domains to provide comprehensive document processing capabilities.\n\n13. **Documentation**: Custom transformations should provide documentation and examples showing how to use the transformation effectively.\n\n14. **Testing**: Custom transformations should be thoroughly tested to ensure they work correctly with different document types and configurations.\n\nThis comprehensive framework allows developers to implement sophisticated document transformations that integrate seamlessly with Sphinx's build process while maintaining the stability and performance of the core system.", "score": null, "retrieved_content": [{"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tead of null-escapes\n                text = re.sub(r'(?<=\\x00)([-\\\\\\'\".`])', r'\\\\\\1', str(txtnode))\n                yield 'plain', text\n            else:\n                # skip smart quotes\n                yield 'literal', txtnode.astext()\n\n\nclass DoctreeReadEvent(SphinxTransform):\n    \"\"\"Emit :event:`doctree-read` event.\"\"\"\n\n    default_priority = 880\n\n    def apply(self, **kwargs: Any) -> None:\n        self.env.events.emit('doctree-read', self.document)\n\n\nclass GlossarySorter(SphinxTransform):\n    \"\"\"Sort glossaries that have the ``sorted`` flag.\"\"\"\n\n    # This must be done after i18n, therefore not right\n    # away in the glossary directive.\n    default_priority = 500\n\n    def apply(self, **kwargs: Any) -> None:\n        for glossary in self.document.findall(addnodes.glossary):\n            if glossary['sorted']:\n                definition_list = cast('nodes.definition_list', glossary[0])\n                definition_list[:] = sorted(\n                    definition_list,\n                    key=lambda item: unicodedata.normalize(\n                        'NFD', cast('nodes.term', item)[0].astext().lower()\n                    ),\n                )\n\n\nclass ReorderConsecutiveTargetAndIndexNodes(SphinxTransform):\n    \"\"\"Index nodes interspersed between target nodes prevent other\n    Transformations from combining those target nodes,\n    e.g. ``PropagateTargets``.  This transformation reorders them:\n\n    Given the following ``document`` as input::\n\n        <document>\n            <target ids=\"id1\" ...>\n            <index entries=\"...1...\">\n            <target ids=\"id2\" ...>\n            <target ids=\"id3\" ...>\n            <index entries=\"...2...\">\n            <target ids=\"id4\" ...>\n\n    The transformed result will be::\n\n        <document>\n            <index entries=\"...1...\">\n            <index entries=\"...2...\">\n            <target ids=\"id1\" ...>\n            <target ids=\"id2\" ...>\n            <target ids=\"id3\" ...>\n            <target ids=\"id4\" ...>\n    \"\"\"\n\n    # This transf"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ls.parsers.rst.directives'),\n    ('py:mod', 'sphinx.ext'),\n    ('py:obj', 'sphinx.util.relative_uri'),\n    ('rst:role', 'c:any'),\n    ('std:confval', 'autodoc_inherit_docstring'),\n    ('std:confval', 'automodule_skip_lines'),\n    ('std:confval', 'autossummary_imported_members'),\n    ('std:confval', 'gettext_language_team'),\n    ('std:confval', 'gettext_last_translator'),\n    ('std:confval', 'globaltoc_collapse'),\n    ('std:confval', 'globaltoc_includehidden'),\n    ('std:confval', 'globaltoc_maxdepth'),\n}\n\n\n# -- Extension interface -------------------------------------------------------\n\nfrom sphinx import addnodes  # NoQA: E402\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n    from docutils.nodes import Element\n\n    from sphinx.application import Sphinx\n    from sphinx.environment import BuildEnvironment\n\n_event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n\n\ndef parse_event(_env: BuildEnvironment, sig: str, signode: Element) -> str:\n    m = _event_sig_re.match(sig)\n    if m is None:\n        signode += addnodes.desc_name(sig, sig)\n        return sig\n    name, args = m.groups()\n    signode += addnodes.desc_name(name, name)\n    plist = addnodes.desc_parameterlist()\n    for arg in args.split(','):\n        arg = arg.strip()\n        plist += addnodes.desc_parameter(arg, arg)\n    signode += plist\n    return name\n\n\ndef linkify_issues_in_changelog(\n    _app: Sphinx, _path: Path, docname: str, source: list[str]\n) -> None:\n    \"\"\"Linkify issue references like #123 in changelog to GitHub.\"\"\"\n    if docname == 'changes':\n        linkified_changelog = re.sub(r'(?:PR)?#([0-9]+)\\b', _linkify, source[0])\n        source[0] = linkified_changelog\n\n\ndef _linkify(match: re.Match[str], /) -> str:\n    return f'`{match[0]} <https://github.com/sphinx-doc/sphinx/issues/{match[1]}>`__'\n\n\nREDIRECT_TEMPLATE = \"\"\"\n<html>\n    <head>\n        <noscript>\n            <meta http-equiv=\"refresh\" content=\"0; url={{rel_url}}\"/>\n        </noscript>\n    </head>\n    <body>\n        <script>\n            "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hinx\n    from sphinx.config import Config\n    from sphinx.domains.std import StandardDomain\n    from sphinx.environment import BuildEnvironment\n    from sphinx.util.typing import ExtensionMetadata\n\n    _DEFAULT_SUBSTITUTION_NAMES: TypeAlias = Literal[\n        'version',\n        'release',\n        'today',\n        'translation progress',\n    ]\n\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_SUBSTITUTIONS = frozenset({\n    'version',\n    'release',\n    'today',\n    'translation progress',\n})\n\n\nclass SphinxTransform(Transform):\n    \"\"\"A base class of Transforms.\n\n    Compared with ``docutils.transforms.Transform``, this class improves accessibility to\n    Sphinx APIs.\n    \"\"\"\n\n    @property\n    def app(self) -> Sphinx:\n        \"\"\"Reference to the :class:`.Sphinx` object.\"\"\"\n        cls_module = self.__class__.__module__\n        cls_name = self.__class__.__qualname__\n        _deprecation_warning(cls_module, f'{cls_name}.app', remove=(10, 0))\n        return self.env._app\n\n    @property\n    def env(self) -> BuildEnvironment:\n        \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n        return self.document.settings.env\n\n    @property\n    def config(self) -> Config:\n        \"\"\"Reference to the :class:`.Config` object.\"\"\"\n        return self.env.config\n\n\nclass SphinxTransformer(Transformer):\n    \"\"\"A transformer for Sphinx.\"\"\"\n\n    document: nodes.document\n    env: BuildEnvironment | None = None\n\n    def set_environment(self, env: BuildEnvironment) -> None:\n        self.env = env\n\n    def apply_transforms(self) -> None:\n        if isinstance(self.document, nodes.document):\n            if not hasattr(self.document.settings, 'env') and self.env:\n                self.document.settings.env = self.env\n\n            super().apply_transforms()  # type: ignore[misc]\n        else:\n            # wrap the target node by document node during transforming\n            try:\n                from sphinx.util.docutils import new_document\n\n                document = new_document('"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    ('py:class', 'nodes.reference'),\n    ('py:class', 'pygments.lexer.Lexer'),\n    ('py:class', 'sphinx.directives.ObjDescT'),\n    ('py:class', 'sphinx.domains.IndexEntry'),\n    ('py:class', 'sphinx.ext.autodoc.Documenter'),\n    ('py:class', 'sphinx.errors.NoUri'),\n    ('py:class', 'sphinx.roles.XRefRole'),\n    ('py:class', 'sphinx.search.SearchLanguage'),\n    ('py:class', 'sphinx.theming.Theme'),\n    ('py:class', 'sphinx.util._pathlib._StrPath'),  # sphinx.project.Project.doc2path\n    ('py:class', 'sphinxcontrib.websupport.errors.DocumentNotFoundError'),\n    ('py:class', 'sphinxcontrib.websupport.errors.UserNotAuthorizedError'),\n    ('py:exc', 'docutils.nodes.SkipNode'),\n    ('py:exc', 'sphinx.environment.NoUri'),\n    ('py:func', 'setup'),\n    ('py:func', 'sphinx.util.nodes.nested_parse_with_titles'),\n    # Error in sphinxcontrib.websupport.core::WebSupport.add_comment\n    ('py:meth', 'get_comments'),\n    ('py:mod', 'autodoc'),\n    ('py:mod', 'docutils.nodes'),\n    ('py:mod', 'docutils.parsers.rst.directives'),\n    ('py:mod', 'sphinx.ext'),\n    ('py:obj', 'sphinx.util.relative_uri'),\n    ('rst:role', 'c:any'),\n    ('std:confval', 'autodoc_inherit_docstring'),\n    ('std:confval', 'automodule_skip_lines'),\n    ('std:confval', 'autossummary_imported_members'),\n    ('std:confval', 'gettext_language_team'),\n    ('std:confval', 'gettext_last_translator'),\n    ('std:confval', 'globaltoc_collapse'),\n    ('std:confval', 'globaltoc_includehidden'),\n    ('std:confval', 'globaltoc_maxdepth'),\n}\n\n\n# -- Extension interface -------------------------------------------------------\n\nfrom sphinx import addnodes  # NoQA: E402\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n    from docutils.nodes import Element\n\n    from sphinx.application import Sphinx\n    from sphinx.environment import BuildEnvironment\n\n_event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n\n\ndef parse_event(_env: BuildEnvironment, sig: str, signode: Element) -> str:\n    m = _event_sig_re.match(sig)\n    if m is No"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx/transforms", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  __('Footnote [#] is not referenced.'),\n                    type='ref',\n                    subtype='footnote',\n                    location=node,\n                )\n\n\nclass DoctestTransform(SphinxTransform):\n    \"\"\"Set \"doctest\" style to each doctest_block node\"\"\"\n\n    default_priority = 500\n\n    def apply(self, **kwargs: Any) -> None:\n        for node in self.document.findall(nodes.doctest_block):\n            node['classes'].append('doctest')\n\n\nclass FilterSystemMessages(SphinxTransform):\n    \"\"\"Filter system messages from a doctree.\"\"\"\n\n    default_priority = 999\n\n    def apply(self, **kwargs: Any) -> None:\n        filterlevel = 2 if self.config.keep_warnings else 5\n        for node in list(self.document.findall(nodes.system_message)):\n            if node['level'] < filterlevel:\n                logger.debug('%s [filtered system message]', node.astext())\n                node.parent.remove(node)\n\n\nclass SphinxContentsFilter(ContentsFilter):\n    \"\"\"Used with BuildEnvironment.add_toc_from() to discard cross-file links\n    within table-of-contents link nodes.\n    \"\"\"\n\n    visit_pending_xref = ContentsFilter.ignore_node_but_process_children\n\n    def visit_image(self, node: nodes.image) -> None:\n        raise nodes.SkipNode\n\n\nclass SphinxSmartQuotes(SmartQuotes, SphinxTransform):\n    \"\"\"Customized SmartQuotes to avoid transform for some extra node types.\n\n    refs: sphinx.parsers.RSTParser\n    \"\"\"\n\n    default_priority = 750\n\n    def apply(self, **kwargs: Any) -> None:\n        if not self.is_available():\n            return\n\n        # override default settings with :confval:`smartquotes_action`\n        self.smartquotes_action = self.config.smartquotes_action\n\n        super().apply()\n\n    def is_available(self) -> bool:\n        builders = self.config.smartquotes_excludes.get('builders', [])\n        languages = self.config.smartquotes_excludes.get('languages', [])\n\n        if self.document.settings.smart_quotes is False:\n            # disabled by 3rd party extension (worka"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "docutils.transforms import Transform\n\n    from sphinx import addnodes\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.config import Config\n    from sphinx.domains import Domain, Index\n    from sphinx.environment import BuildEnvironment\n    from sphinx.ext.autodoc import Documenter\n    from sphinx.util.docfields import Field\n    from sphinx.util.typing import (\n        ExtensionMetadata,\n        RoleFunction,\n        TitleGetter,\n        _ExtensionSetupFunc,\n    )\n    from sphinx.writers.html5 import HTML5Translator\n\n    # visit/depart function\n    # the parameters should be (SphinxTranslator, Element)\n    # or any subtype of either, but mypy rejects this.\n    _NodeHandler: TypeAlias = Callable[[Any, Any], None]\n    _NodeHandlerPair: TypeAlias = tuple[_NodeHandler, _NodeHandler | None]\n\n    _MathsRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math], None]\n    _MathsBlockRenderer: TypeAlias = Callable[[HTML5Translator, nodes.math_block], None]\n    _MathsInlineRenderers: TypeAlias = tuple[_MathsRenderer, _MathsRenderer | None]\n    _MathsBlockRenderers: TypeAlias = tuple[\n        _MathsBlockRenderer, _MathsBlockRenderer | None\n    ]\n\nlogger = logging.getLogger(__name__)\n\n# list of deprecated extensions. Keys are extension name.\n# Values are Sphinx version that merge the extension.\nEXTENSION_BLACKLIST = {\n    'sphinxjp.themecore': '1.2',\n    'sphinxcontrib-napoleon': '1.3',\n    'sphinxprettysearchresults': '2.0.0',\n}\n\n\nclass SphinxComponentRegistry:\n    def __init__(self) -> None:\n        #: special attrgetter for autodoc; class object -> attrgetter\n        self.autodoc_attrgetters: dict[type, Callable[[Any, str, Any], Any]] = {}\n\n        #: builders; a dict of builder name -> builder class\n        self.builders: dict[str, type[Builder]] = {}\n\n        #: autodoc documenters; a dict of documenter name -> documenter class\n        self.documenters: dict[str, type[Documenter]] = {}\n\n        #: css_files; a list of tup"}, {"start_line": 50000, "end_line": 52000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e standard docutils :class:`~docutils.transforms.Transform`\n        subclass *transform* to the list of transforms that are applied before\n        Sphinx writes a document.\n\n        :param transform: A transform class\n        \"\"\"\n        self.registry.add_post_transform(transform)\n\n    def add_js_file(\n        self,\n        filename: str | None,\n        priority: int = 500,\n        loading_method: str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Register a JavaScript file to include in the HTML output.\n\n        :param filename: The name of a JavaScript file that the default HTML\n                         template will include. It must be relative to the HTML\n                         static path, or a full URI with scheme, or ``None`` .\n                         The ``None`` value is used to create an inline\n                         ``<script>`` tag.  See the description of *kwargs*\n                         below.\n        :param priority: Files are included in ascending order of priority. If\n                         multiple JavaScript files have the same priority,\n                         those files will be included in order of registration.\n                         See list of \"priority range for JavaScript files\" below.\n        :param loading_method: The loading method for the JavaScript file.\n                               Either ``'async'`` or ``'defer'`` are allowed.\n        :param kwargs: Extra keyword arguments are included as attributes of the\n                       ``<script>`` tag.  If the special keyword argument\n                       ``body`` is given, its value will be added as the content\n                       of the  ``<script>`` tag.\n\n        Example::\n\n            app.add_js_file('example.js')\n            # => <script src=\"_static/example.js\"></script>\n\n            app.add_js_file('example.js', loading_method='async')\n            # => <script src=\"_static/example.js\" async=\"async\"></script>\n\n            app.add_js_file(None, body"}, {"start_line": 49000, "end_line": 51000, "belongs_to": {"file_name": "application.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "able:: priority range categories for Sphinx transforms\n           :widths: 20,80\n\n           * - Priority\n             - Main purpose in Sphinx\n           * - 0-99\n             - Fix invalid nodes by docutils. Translate a doctree.\n           * - 100-299\n             - Preparation\n           * - 300-399\n             - early\n           * - 400-699\n             - main\n           * - 700-799\n             - Post processing. Deadline to modify text and referencing.\n           * - 800-899\n             - Collect referencing and referenced nodes. Domain processing.\n           * - 900-999\n             - Finalize and clean up.\n\n        refs: `Transform Priority Range Categories`__\n\n        __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories\n        \"\"\"\n        self.registry.add_transform(transform)\n\n    def add_post_transform(self, transform: type[Transform]) -> None:\n        \"\"\"Register a Docutils transform to be applied before writing.\n\n        Add the standard docutils :class:`~docutils.transforms.Transform`\n        subclass *transform* to the list of transforms that are applied before\n        Sphinx writes a document.\n\n        :param transform: A transform class\n        \"\"\"\n        self.registry.add_post_transform(transform)\n\n    def add_js_file(\n        self,\n        filename: str | None,\n        priority: int = 500,\n        loading_method: str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Register a JavaScript file to include in the HTML output.\n\n        :param filename: The name of a JavaScript file that the default HTML\n                         template will include. It must be relative to the HTML\n                         static path, or a full URI with scheme, or ``None`` .\n                         The ``None`` value is used to create an inline\n                         ``<script>`` tag.  See the description of *kwargs*\n                         below.\n        :param priority: Files are included in ascending"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "conf.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/doc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass', 'Element'),  # sphinx.domains.Domain\n    ('py:class', 'Documenter'),  # sphinx.application.Sphinx.add_autodocumenter\n    ('py:class', 'Field'),  # sphinx.application.Sphinx.add_object_type\n    ('py:class', 'IndexEntry'),  # sphinx.domains.IndexEntry\n    ('py:class', 'Inliner'),  # sphinx.util.docutils.SphinxRole.inliner\n    ('py:class', 'Lexer'),  # sphinx.application.Sphinx.add_lexer\n    ('py:class', 'Node'),  # sphinx.domains.Domain\n    ('py:class', 'NullTranslations'),  # gettext.NullTranslations\n    ('py:class', 'ObjDescT'),  # sphinx.directives.ObjectDescription\n    ('py:class', 'OptionSpec'),  # sphinx.directives.ObjectDescription.option_spec\n    ('py:class', 'Path'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'RoleFunction'),  # sphinx.domains.Domain\n    ('py:class', 'RSTState'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'SearchLanguage'),  # sphinx.application.Sphinx.add_search_language\n    ('py:class', 'StringList'),  # sphinx.utils.parsing.nested_parse_to_nodes\n    ('py:class', 'system_message'),  # sphinx.utils.docutils.SphinxDirective\n    ('py:class', 'Theme'),  # sphinx.application.TemplateBridge\n    ('py:class', 'TitleGetter'),  # sphinx.domains.Domain\n    ('py:class', 'todo_node'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'Transform'),  # sphinx.application.Sphinx.add_transform\n    ('py:class', 'XRefRole'),  # sphinx.domains.Domain\n    ('py:class', 'docutils.nodes.Element'),\n    ('py:class', 'docutils.nodes.Node'),\n    ('py:class', 'docutils.nodes.NodeVisitor'),\n    ('py:class', 'docutils.nodes.TextElement'),\n    ('py:class', 'docutils.nodes.document'),\n    ('py:class', 'docutils.nodes.system_message'),\n    ('py:class', 'docutils.parsers.Parser'),\n    ('py:class', 'docutils.parsers.rst.states.Inliner'),\n    ('py:class', 'docutils.transforms.Transform'),\n    ('py:class', 'nodes.NodeVisitor'),\n    ('py:class', 'nodes.TextElement'),  # sphinx.application.Sphinx.connect\n    ('py:class', 'nodes.document'),"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "io.py", "upper_path": "/data2/raymone/swebench-repos/sphinx/sphinx", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "mer = SphinxTransformer(document)\n        document.transformer.set_environment(self.settings.env)\n\n        # substitute reporter\n        reporter = document.reporter\n        document.reporter = LoggingReporter.from_reporter(reporter)\n\n        return document\n\n\nclass SphinxStandaloneReader(SphinxBaseReader):\n    \"\"\"A basic document reader for Sphinx.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            'sphinx.io.SphinxStandaloneReader is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    def _setup_transforms(self, transforms: list[type[Transform]], /) -> None:\n        self.transforms = self.transforms + transforms\n\n    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:  # type: ignore[type-arg]\n        self.source = source\n        if not self.parser:  # type: ignore[has-type]\n            self.parser = parser\n        self.settings = settings\n        self.input = self.read_source(settings.env)\n        self.parse()\n        return self.document\n\n    def read_source(self, env: BuildEnvironment) -> str:\n        \"\"\"Read content from source and do post-process.\"\"\"\n        content = self.source.read()\n\n        # emit \"source-read\" event\n        arg = [content]\n        env.events.emit('source-read', env.current_document.docname, arg)\n        return arg[0]\n\n\nclass SphinxDummyWriter(UnfilteredWriter):  # type: ignore[type-arg]\n    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        warnings.warn(\n            'sphinx.io.SphinxDummyWriter is deprecated',\n            RemovedInSphinx10Warning,\n            stacklevel=2,\n        )\n\n    supported = ('html',)  # needed to keep \"meta\" nodes\n\n    def translate(self) -> None:\n        pass\n\n\ndef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n    \"\"\"Bypass source object as is to cheat Publ"}], "retrieved_count": 10, "cost_time": 0.34828639030456543}
