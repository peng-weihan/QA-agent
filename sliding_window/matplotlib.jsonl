{"question": "What is Matplotlib's event handling system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event handling system provides a GUI-neutral interface for responding to user interactions like mouse clicks, key presses, and mouse movements. The system is built around the FigureCanvasBase class which manages event connections through methods like mpl_connect() and mpl_disconnect(). Events include LocationEvent (with x, y pixel coordinates and xdata, ydata data coordinates), MouseEvent (with button and key information), KeyEvent, and PickEvent. The system allows callbacks to be connected to specific events, enabling interactive features like panning, zooming, and custom interactive behaviors. Events are processed through an event loop that can be integrated with various GUI toolkits (Qt, Tk, Wx, GTK, macOS) while maintaining a consistent API. The event system also supports object picking for selecting specific artists and provides coordinate transformations between pixel and data coordinates automatically.", "score": null, "retrieved_content": [{"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ering different compared to mpl.\n            button for button, mask in [\n                (MouseButton.LEFT, 1),\n                (MouseButton.RIGHT, 2),\n                (MouseButton.MIDDLE, 4),\n                (MouseButton.BACK, 8),\n                (MouseButton.FORWARD, 16),\n            ] if event['buttons'] & mask  # State *after* press/release.\n        }\n        modifiers = event['modifiers']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        if self.manager:\n            self.send_event('figure_label', label=self.manager.get_window_title())\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       modifiers=self._mpl_modifiers(mods),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        if self.figure is None:\n            return\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      modifiers=self._mpl_modifiers(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ent propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_press_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_release_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\n            \"motion_notify_event\", self, *self._mpl_coords((x, y)),\n            buttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _mpl_buttons(self, controller):\n        # NOTE: This spews \"Broken accounting of active state\" warnings on\n        # right click on macOS.\n        surface = self.get_native().get_surface()\n        is_over, x, y, event_state = surface.get_device_position(\n            self.get_display().get_default_seat().get_pointer())\n        # NOTE: alternatively we could use\n        #   event_state = controller.get_current_event_state()\n        # but for button_press/button_release this would report the state\n        # *prior* to the event rather than after it; the above reports the\n        # state *after* it.\n        mod_table = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, G"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}, {"start_line": 94000, "end_line": 96000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     ax.set_xscale('linear')\n            ax.get_figure(root=True).canvas.draw_idle()\n        elif scalex == 'linear':\n            try:\n                ax.set_xscale('log')\n            except ValueError as exc:\n                _log.warning(str(exc))\n                ax.set_xscale('linear')\n            ax.get_figure(root=True).canvas.draw_idle()\n\n\ndef button_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    The default Matplotlib button actions for extra mouse buttons.\n\n    Parameters are as for `key_press_handler`, except that *event* is a\n    `MouseEvent`.\n    \"\"\"\n    if canvas is None:\n        canvas = event.canvas\n    if toolbar is None:\n        toolbar = canvas.toolbar\n    if toolbar is not None:\n        button_name = str(MouseButton(event.button))\n        if button_name in rcParams['keymap.back']:\n            toolbar.back()\n        elif button_name in rcParams['keymap.forward']:\n            toolbar.forward()\n\n\nclass NonGuiException(Exception):\n    \"\"\"Raised when trying show a figure in a non-GUI backend.\"\"\"\n    pass\n\n\nclass FigureManagerBase:\n    \"\"\"\n    A backend-independent abstraction of a figure container and controller.\n\n    The figure manager is used by pyplot to interact with the window in a\n    backend-independent way. It's an adapter for the real (GUI) framework that\n    represents the visual figure on screen.\n\n    The figure manager is connected to a specific canvas instance, which in turn\n    is connected to a specific figure instance. To access a figure manager for\n    a given figure in user code, you typically use ``fig.canvas.manager``.\n\n    GUI backends derive from this class to translate common operations such\n    as *show* or *resize* to the GUI-specific code. Non-GUI backends do not\n    support these operations and can just use the base class.\n\n    This following basic operations are accessible:\n\n    **Window operations**\n\n    - `~.FigureManagerBase.show`\n    - `~.FigureManagerBase.destroy`\n    - `~.FigureManagerBase.full_screen_toggl"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al implementation uses a Tk canvas,  this routine\n        is intended to hide that fact.\n        \"\"\"\n        return self._tkcanvas\n\n    def _event_mpl_coords(self, event):\n        # calling canvasx/canvasy allows taking scrollbars into account (i.e.\n        # the top of the widget may have been scrolled out of view).\n        return (self._tkcanvas.canvasx(event.x),\n                # flipy so y=0 is bottom of canvas\n                self.figure.bbox.height - self._tkcanvas.canvasy(event.y))\n\n    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, event):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def button_press_event(self, event, dblclick=False):\n        # set focus to the canvas so that it can receive keyboard events\n        self._tkcanvas.focus_set()\n\n        num = getattr(event, 'num', None)\n        if sys.platform == 'darwin':  # 2 and 3 are reversed.\n            num = {2: 3, 3: 2}.get(num, num)\n        MouseEvent(\"button_press_event\", self,\n                   *self._event_mpl_coords(event), num, dblclick=dblclick,\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def button_dblclick_event(self, event):\n        self.button_press_event(event, dblclick=True)\n\n    def button_release_event(self, event):\n        num = "}], "retrieved_count": 10, "cost_time": 1.322394847869873}
{"question": "What are the core components of Matplotlib's plotting system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's core plotting system consists of several key components: 1) Figure - the top-level container that holds all plot elements, 2) Axes - individual plotting areas within a figure that contain the actual data visualization, 3) Artist - the base class for all visual elements (lines, text, patches, etc.), 4) Backend - the rendering system that converts abstract plot descriptions to actual output (GUI, files, etc.), 5) pyplot interface - the MATLAB-like procedural interface for plotting, and 6) Object-oriented API - the explicit interface using Figure and Axes objects directly. The system follows a hierarchical structure where Figure contains Axes, which contain various Artist objects that represent the visual elements of the plot.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplotlib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in whic"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n# :meth:`~matplotlib.axes.Axes.set_xlabel`), and a y-label set via\n# :meth:`~matplotlib.axes.Axes.set_ylabel`).\n#\n# The `~.axes.Axes` methods are the primary interface for configuring\n# most parts of your plot (adding data, controlling axis scales and\n# limits, adding labels etc.).\n#\n# :class:`~matplotlib.axis.Axis`\n# ------------------------------\n#\n# These objects set the scale and limits and generate ticks (the marks\n# on the Axis) and ticklabels (strings labeling the ticks).  The location\n# of the ticks is determined by a `~matplotlib.ticker.Locator` object and the\n# ticklabel strings are formatted by a `~matplotlib.ticker.Formatter`.  The\n# combination of the correct `.Locator` and `.Formatter` gives very fine\n# control over the tick locations and labels.\n#\n# :class:`~matplotlib.artist.Artist`\n# ----------------------------------\n#\n# Basically, everything visible on the Figure is an Artist (even\n# `.Figure`, `Axes <.axes.Axes>`, and `~.axis.Axis` objects).  This includes\n# `.Text` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`\n# objects, etc. When the Figure is rendered, all of the\n# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such\n# an Artist cannot be shared by multiple Axes, or moved from one to another.\n#\n# .. _input_types:\n#\n# Types of inputs to plotting functions\n# =====================================\n#\n# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as\n# input, or objects that can be passed to `numpy.asarray`.\n# Classes that are similar to arrays ('array-like') such as `pandas`\n# data objects and `numpy.matrix` may not work as intended.  Common convention\n# is to convert these to `numpy.array` objects prior to plotting.\n# For example, to convert a `numpy.matrix` ::\n#\n#   b = np.matrix([[1, 2], [3, 4]])\n#   b_asarray = np.asarray(b)\n#\n# Most methods will also parse a string-indexable object like a *dict*, a\n# `structured numpy array`_, or a `pandas.DataFrame`.  Matplotlib allows you\n# t"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of values, the\n# method will create a `matplotlib.lines.Line2D` instance, update the line with\n# all the ``Line2D`` properties passed as keyword arguments, add the line to\n# the ``Axes``, and return it to you:\n#\n# .. sourcecode:: ipython\n#\n#     In [213]: x, y = np.random.rand(2, 100)\n#\n#     In [214]: line, = ax.plot(x, y, '-', color='blue', linewidth=2)\n#\n# ``plot`` returns a list of lines because you can pass in multiple x, y\n# pairs to plot, and we are unpacking the first element of the length\n# one list into the line variable.  The line has been added to the\n# ``Axes.lines`` list:\n#\n# .. sourcecode:: ipython\n#\n#     In [229]: print(ax.lines)\n#     [<matplotlib.lines.Line2D at 0xd378b0c>]\n#\n# Similarly, methods that create patches, like\n# :meth:`~matplotlib.axes.Axes.bar` creates a list of rectangles, will\n# add the patches to the :attr:`!Axes.patches` list:\n#\n# .. sourcecode:: ipython\n#\n#     In [233]: n, bins, rectangles = ax.hist(np.random.randn(1000), 50)\n#\n#     In [234]: rectangl"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}], "retrieved_count": 10, "cost_time": 1.3344604969024658}
{"question": "What dependencies exist between Matplotlib's pyplot interface and the object-oriented API?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's pyplot interface is built on top of the object-oriented API and has several key dependencies: 1) The pyplot module maintains global state (current Figure and Axes) and provides convenience functions that internally create and manipulate Figure and Axes objects, 2) Most pyplot functions are wrappers around Axes methods - for example, plt.plot() calls ax.plot() on the current Axes, 3) Pyplot functions like plt.figure(), plt.subplots(), and plt.subplot() create Figure and Axes objects and manage them in the global state, 4) The pyplot interface depends on the object-oriented API for all actual plotting operations, coordinate transformations, and rendering, 5) Pyplot provides MATLAB-like convenience but ultimately delegates to the explicit object-oriented interface for implementation, 6) Functions like plt.gcf() and plt.gca() return references to the current Figure and Axes objects from the object-oriented API, 7) The pyplot interface is primarily intended for interactive use and simple scripts, while complex customization requires direct use of the object-oriented API. This dependency structure allows pyplot to provide a simpler interface while leveraging the full power and flexibility of the underlying object-oriented system.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) Axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n# %%\n# (In addition, there is a third approach, for the case when embedding\n# Matplotlib in a GUI application, which completely drops pyplot, even for\n# figure creation. See the corresponding section in the gallery for more info:\n# :ref:`user_interfaces`.)\n#\n# Matplotlib's documentation and examples use both the OO and the pyplot\n# styles. In general, we suggest using the OO style, particularly for\n# complicated plots, and functions and scripts that are intended to be reused\n# as part of a larger project. However, the pyplot style can be very convenient\n# for quick interactive work.\n#\n# .. note::\n#\n#    You may find older examples that use the ``pylab`` interface,\n#    via ``from pylab import *``. This approach is strongly deprecated.\n#\n# Making a helper functions\n# -------------------------\n#\n# If you need to make the sa"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    # Check that each call created a new Axes.\n    assert len(created_axes) == 1 + len(projections)\n\n\ndef test_polar_second_call():\n    # the first call creates the axes with polar projection\n    ln1, = plt.polar(0., 1., 'ro')\n    assert isinstance(ln1, mpl.lines.Line2D)\n    # the second call should reuse the existing axes\n    ln2, = plt.polar(1.57, .5, 'bo')\n    assert isinstance(ln2, mpl.lines.Line2D)\n    assert ln1.axes is ln2.axes\n\n\ndef test_fallback_position():\n    # check that position kwarg works if rect not supplied\n    axref = plt.axes([0.2, 0.2, 0.5, 0.5])\n    axtest = plt.axes(position=[0.2, 0.2, 0.5, 0.5])\n    np.testing.assert_allclose(axtest.bbox.get_points(),\n                               axref.bbox.get_points())\n\n    # check that position kwarg ignored if rect is supplied\n    axref = plt.axes([0.2, 0.2, 0.5, 0.5])\n    axtest = plt.axes([0.2, 0.2, 0.5, 0.5], position=[0.1, 0.1, 0.8, 0.8])\n    np.testing.assert_allclose(axtest.bbox.get_points(),\n                               axref.bbox.get_points())\n\n\ndef test_set_current_figure_via_subfigure():\n    fig1 = plt.figure()\n    subfigs = fig1.subfigures(2)\n\n    plt.figure()\n    assert plt.gcf() != fig1\n\n    current = plt.figure(subfigs[1])\n    assert plt.gcf() == fig1\n    assert current == fig1\n\n\ndef test_set_current_axes_on_subfigure():\n    fig = plt.figure()\n    subfigs = fig.subfigures(2)\n\n    ax = subfigs[0].subplots(1, squeeze=True)\n    subfigs[1].subplots(1, squeeze=True)\n\n    assert plt.gca() != ax\n    plt.sca(ax)\n    assert plt.gca() == ax\n\n\ndef test_pylab_integration():\n    IPython = pytest.importorskip(\"IPython\")\n    mpl.testing.subprocess_run_helper(\n        IPython.start_ipython,\n        \"--pylab\",\n        \"-c\",\n        \";\".join((\n            \"import matplotlib.pyplot as plt\",\n            \"assert plt._REPL_DISPLAYHOOK == plt._ReplDisplayHook.IPYTHON\",\n        )),\n        timeout=60,\n    )\n\n\ndef test_doc_pyplot_summary():\n    \"\"\"Test that pyplot_summary lists all the plot functions.\"\"\"\n    pypl"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s import Button, Slider, Widget  # noqa: F401\n\nfrom .ticker import (  # noqa: F401\n    TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,\n    FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,\n    LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,\n    LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)\n\n_log = logging.getLogger(__name__)\n\n\n# Explicit rename instead of import-as for typing's sake.\ncolormaps = _colormaps\ncolor_sequences = _color_sequences\n\n\n@overload\ndef _copy_docstring_and_deprecators(\n    method: Any,\n    func: Literal[None] = None\n) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...\n\n\n@overload\ndef _copy_docstring_and_deprecators(\n    method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...\n\n\ndef _copy_docstring_and_deprecators(\n    method: Any,\n    func: Callable[_P, _R] | None = None\n) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:\n    if func is None:\n        return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',\n                    functools.partial(_copy_docstring_and_deprecators, method))\n    decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [\n        _docstring.copy(method)\n    ]\n    # Check whether the definition of *method* includes @_api.rename_parameter\n    # or @_api.make_keyword_only decorators; if so, propagate them to the\n    # pyplot wrapper as well.\n    while hasattr(method, \"__wrapped__\"):\n        potential_decorator = _api.deprecation.DECORATORS.get(method)\n        if potential_decorator:\n            decorators.append(potential_decorator)\n        method = method.__wrapped__\n    for decorator in decorators[::-1]:\n        func = decorator(func)\n    _add_pyplot_note(func, method)\n    return func\n\n\n_NO_PYPLOT_NOTE = [\n    'FigureBase._gci',  # wrapped_func is private\n    '_AxesBase._sci',  # wrapped_func is private\n    'Artist.findobj',  # not a standard pyplot wrapper because it does not operate\n    "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   with plt.ion():\n            assert mpl.is_interactive()\n    assert not mpl.is_interactive()\n\n    with plt.ioff():\n        plt.ion()\n    assert not mpl.is_interactive()\n\n\ndef test_close():\n    try:\n        plt.close(1.1)\n    except TypeError as e:\n        assert str(e) == (\n            \"'fig' must be an instance of matplotlib.figure.Figure, int, str \"\n            \"or None, not a float\")\n\n\ndef test_subplot_reuse():\n    ax1 = plt.subplot(121)\n    assert ax1 is plt.gca()\n    ax2 = plt.subplot(122)\n    assert ax2 is plt.gca()\n    ax3 = plt.subplot(121)\n    assert ax1 is plt.gca()\n    assert ax1 is ax3\n\n\ndef test_axes_kwargs():\n    # plt.axes() always creates new axes, even if axes kwargs differ.\n    plt.figure()\n    ax = plt.axes()\n    ax1 = plt.axes()\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    plt.figure()\n    ax = plt.axes(projection='polar')\n    ax1 = plt.axes(projection='polar')\n    assert ax is not None\n    assert ax1 is not ax\n    plt.close()\n\n    plt.figure()\n    ax = plt.axes(projection='polar')\n    ax1 = plt.axes()\n    assert ax is not None\n    assert ax1.name == 'rectilinear'\n    assert ax1 is not ax\n    plt.close()\n\n\ndef test_subplot_replace_projection():\n    # plt.subplot() searches for axes with the same subplot spec, and if one\n    # exists, and the kwargs match returns it, create a new one if they do not\n    fig = plt.figure()\n    ax = plt.subplot(1, 2, 1)\n    ax1 = plt.subplot(1, 2, 1)\n    ax2 = plt.subplot(1, 2, 2)\n    ax3 = plt.subplot(1, 2, 1, projection='polar')\n    ax4 = plt.subplot(1, 2, 1, projection='polar')\n    assert ax is not None\n    assert ax1 is ax\n    assert ax2 is not ax\n    assert ax3 is not ax\n    assert ax3 is ax4\n\n    assert ax in fig.axes\n    assert ax2 in fig.axes\n    assert ax3 in fig.axes\n\n    assert ax.name == 'rectilinear'\n    assert ax2.name == 'rectilinear'\n    assert ax3.name == 'polar'\n\n\ndef test_subplot_kwarg_collision():\n    ax1 = plt.subplot(projection='polar', theta_offset=0)\n    ax2 = plt."}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_pylab_helpers.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nManage figures for the pyplot interface.\n\"\"\"\n\nimport atexit\nfrom collections import OrderedDict\n\n\nclass Gcf:\n    \"\"\"\n    Singleton to maintain the relation between figures and their managers, and\n    keep track of and \"active\" figure and manager.\n\n    The canvas of a figure created through pyplot is associated with a figure\n    manager, which handles the interaction between the figure and the backend.\n    pyplot keeps track of figure managers using an identifier, the \"figure\n    number\" or \"manager number\" (which can actually be any hashable value);\n    this number is available as the :attr:`number` attribute of the manager.\n\n    This class is never instantiated; it consists of an `OrderedDict` mapping\n    figure/manager numbers to managers, and a set of class methods that\n    manipulate this `OrderedDict`.\n\n    Attributes\n    ----------\n    figs : OrderedDict\n        `OrderedDict` mapping numbers to managers; the active manager is at the\n        end.\n    \"\"\"\n\n    figs = OrderedDict()\n\n    @classmethod\n    def get_fig_manager(cls, num):\n        \"\"\"\n        If manager number *num* exists, make it the active one and return it;\n        otherwise return *None*.\n        \"\"\"\n        manager = cls.figs.get(num, None)\n        if manager is not None:\n            cls.set_active(manager)\n        return manager\n\n    @classmethod\n    def destroy(cls, num):\n        \"\"\"\n        Destroy manager *num* -- either a manager instance or a manager number.\n\n        In the interactive backends, this is bound to the window \"destroy\" and\n        \"delete\" events.\n\n        It is recommended to pass a manager instance, to avoid confusion when\n        two managers share the same number.\n        \"\"\"\n        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n            manager = num\n            if cls.figs.get(manager.num) is manager:\n                cls.figs.pop(manager.num)\n        else:\n            try:\n                manager = cls.figs.pop(num)\n            except KeyError:\n      "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/lifecycle\n\n=======================\nThe Lifecycle of a Plot\n=======================\n\nThis tutorial aims to show the beginning, middle, and end of a single\nvisualization using Matplotlib. We'll begin with some raw data and\nend by saving a figure of a customized visualization. Along the way we try\nto highlight some neat features and best-practices using Matplotlib.\n\n.. currentmodule:: matplotlib\n\n.. note::\n\n    This tutorial is based on\n    `this excellent blog post\n    <https://pbpython.com/effective-matplotlib.html>`_\n    by Chris Moffitt. It was transformed into this tutorial by Chris Holdgraf.\n\nA note on the explicit vs. implicit interfaces\n==============================================\n\nMatplotlib has two interfaces. For an explanation of the trade-offs between the\nexplicit and implicit interfaces see :ref:`api_interfaces`.\n\nIn the explicit object-oriented (OO) interface we directly utilize instances of\n:class:`axes.Axes` to build up the visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales informat"}], "retrieved_count": 10, "cost_time": 1.3311924934387207}
{"question": "Why does Matplotlib implement a backend system for different output formats instead of a single rendering engine?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements a backend system instead of a single rendering engine to support diverse use cases and output requirements. Different use cases require different capabilities: 1) Interactive backends (Qt, Tk, GTK, Wx, macOS) need GUI integration and event handling for real-time user interaction, 2) File output backends (PNG, PDF, SVG, PS) need specific format optimizations and vector/raster rendering capabilities, 3) Different output formats have fundamentally different requirements - vector formats (PDF, SVG) need scalable graphics while raster formats (PNG) need pixel-perfect rendering, 4) The backend system allows separation of concerns between plotting logic and output mechanism, enabling the same plotting code to work across different environments, 5) Different GUI toolkits have different event loops and integration requirements that require specialized backend implementations, 6) The backend system provides flexibility for users to choose the most appropriate output method for their specific needs (interactive exploration vs. publication-quality output), 7) It allows for backend-specific optimizations and features while maintaining a consistent high-level API. This modular approach enables Matplotlib to support a wide range of use cases from interactive data exploration to batch image generation.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return"}, {"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s, f\"print_{fmt}\"):\n                raise ValueError(\n                    f\"The {backend!r} backend does not support {fmt} output\")\n            canvas = canvas_class(self.figure)\n        elif hasattr(self, f\"print_{fmt}\"):\n            # Return the current canvas if it supports the requested format.\n            canvas = self\n        else:\n            # Return a default canvas for the requested format, if it exists.\n            canvas_class = get_registered_canvas_class(fmt)\n            if canvas_class is None:\n                raise ValueError(\n                    \"Format {!r} is not supported (supported formats: {})\".format(\n                        fmt, \", \".join(sorted(self.get_supported_filetypes()))))\n            canvas = canvas_class(self.figure)\n        canvas._is_saving = self._is_saving\n        meth = getattr(canvas, f\"print_{fmt}\")\n        mod = (meth.func.__module__\n               if hasattr(meth, \"func\")  # partialmethod, e.g. backend_wx.\n               else meth.__module__)\n        if mod.startswith((\"matplotlib.\", \"mpl_toolkits.\")):\n            optional_kws = {  # Passed by print_figure for other renderers.\n                \"dpi\", \"facecolor\", \"edgecolor\", \"orientation\",\n                \"bbox_inches_restore\"}\n            skip = optional_kws - {*inspect.signature(meth).parameters}\n            print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\n                *args, **{k: v for k, v in kwargs.items() if k not in skip}))\n        else:  # Let third-parties do as they see fit.\n            print_method = meth\n        try:\n            yield print_method\n        finally:\n            self.figure.canvas = self\n\n    def print_figure(\n            self, filename, dpi=None, facecolor=None, edgecolor=None,\n            orientation='portrait', format=None, *,\n            bbox_inches=None, pad_inches=None, bbox_extra_artists=None,\n            backend=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy. Set the figure patch face and edge\n      "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 50000, "end_line": 51132, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n\n    def print_svgz(self, filename, **kwargs):\n        with (cbook.open_file_cm(filename, \"wb\") as fh,\n              gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter):\n            return self.print_svg(gzipwriter, **kwargs)\n\n    def get_default_filetype(self):\n        return 'svg'\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()\n\n\nFigureManagerSVG = FigureManagerBase\n\n\nsvgProlog = \"\"\"\\\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\"\"\"\n\n\n@_Backend.export\nclass _BackendSVG(_Backend):\n    backend_version = mpl.__version__\n    FigureCanvas = FigureCanvasSVG\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_mixed.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " `~matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `~matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*se"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "vent, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'\n\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasTemplate\nFigureManager = FigureMana"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 19000, "end_line": 20645, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs, metadata)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs, metadata)\n\n    print_tiff = print_tif\n\n    def print_webp(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs, metadata)\n\n    def print_avif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        if not features.check(\"avif\"):\n            raise RuntimeError(\n                \"The installed pillow version does not support avif. Full \"\n                \"avif support has been added in pillow 11.3.\"\n            )\n        self._print_pil(filename_or_obj, \"avif\", pil_kwargs, metadata)\n\n    (print_gif.__doc__,\n     print_jpg.__doc__,\n     print_tif.__doc__,\n     print_webp.__doc__,\n     print_avif.__doc__) = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        metadata : None\n            Unused for pillow-based writers. All supported options\n            can be passed via *pil_kwargs*.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"GIF\", \"JPEG\", \"TIFF\", \"WebP\", \"AVIF\"])\n\n\n@_Backend.export\nclass _BackendAgg(_Backend):\n    backend_version = 'v2.2'\n    FigureCanvas = FigureCanvasAgg\n    FigureManager = FigureManagerBase\n"}, {"start_line": 17000, "end_line": 18618, "belongs_to": {"file_name": "backend_cairo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e RuntimeError('cairo has not been compiled with PDF '\n                                   'support enabled')\n            surface = cairo.PDFSurface(fobj, width_in_points, height_in_points)\n        elif fmt in ('svg', 'svgz'):\n            if not hasattr(cairo, 'SVGSurface'):\n                raise RuntimeError('cairo has not been compiled with SVG '\n                                   'support enabled')\n            if fmt == 'svgz':\n                if isinstance(fobj, str):\n                    fobj = gzip.GzipFile(fobj, 'wb')\n                else:\n                    fobj = gzip.GzipFile(None, 'wb', fileobj=fobj)\n            surface = cairo.SVGSurface(fobj, width_in_points, height_in_points)\n        else:\n            raise ValueError(f\"Unknown format: {fmt!r}\")\n\n        self._renderer.dpi = self.figure.dpi\n        self._renderer.set_context(cairo.Context(surface))\n        ctx = self._renderer.gc.ctx\n\n        if orientation == 'landscape':\n            ctx.rotate(np.pi / 2)\n            ctx.translate(0, -height_in_points)\n            # Perhaps add an '%%Orientation: Landscape' comment?\n\n        self.figure.draw(self._renderer)\n\n        ctx.show_page()\n        surface.finish()\n        if fmt == 'svgz':\n            fobj.close()\n\n    print_pdf = functools.partialmethod(_save, \"pdf\")\n    print_ps = functools.partialmethod(_save, \"ps\")\n    print_svg = functools.partialmethod(_save, \"svg\")\n    print_svgz = functools.partialmethod(_save, \"svgz\")\n\n\n@_Backend.export\nclass _BackendCairo(_Backend):\n    backend_version = cairo.version\n    FigureCanvas = FigureCanvasCairo\n    FigureManager = FigureManagerBase\n"}], "retrieved_count": 10, "cost_time": 1.3523504734039307}
{"question": "What is the purpose of Matplotlib's \"Artist\" class in the rendering system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist class serves as the abstract base class for all objects that render into a FigureCanvas. It provides the fundamental interface between the high-level plotting API and the low-level rendering system. The Artist class defines the common properties and methods that all visual elements share, including visibility, alpha transparency, z-order, clipping, transforms, and the core draw() method. It acts as the bridge between the plotting logic and the backend renderers, allowing the same Artist objects to work across different output formats (GUI, files, etc.). Artists are organized into two categories: primitives (like Line2D, Rectangle, Text) that represent actual visual elements, and containers (like Figure, Axes, Axis) that organize and manage other Artists. The Artist class handles coordinate transformations, property management, event handling (picking), and provides a consistent interface for customizing the appearance of all plot elements.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(f\"{_nums_to_str(*rect.p0, *rect.size)} rectclip\\n\")\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataS"}, {"start_line": 188000, "end_line": 189117, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re\n        The figure all of the artists belong to (not checked).  We need this\n        because we can at the figure level suppress composition and insert each\n        rasterized artist as its own image.\n\n    artists : List[matplotlib.artist.Artist]\n        The list of Artists to be rasterized.  These are assumed to all\n        be in the same Figure.\n\n    renderer : matplotlib.backendbases.RendererBase\n        The currently active renderer\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    class _MinimalArtist:\n        def get_rasterized(self):\n            return True\n\n        def get_agg_filter(self):\n            return None\n\n        def __init__(self, figure, artists):\n            self.figure = figure\n            self.artists = artists\n\n        def get_figure(self, root=False):\n            if root:\n                return self.figure.get_figure(root=True)\n            else:\n                return self.figure\n\n        @martist.allow_rasterization\n        def draw(self, renderer):\n            for a in self.artists:\n                a.draw(renderer)\n\n    return _MinimalArtist(figure, artists).draw(renderer)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ogenerated_signature = True\n\n        cls.set.__doc__ = (\n            \"Set multiple properties at once.\\n\\n\"\n            \"Supported properties are\\n\\n\"\n            + kwdoc(cls))\n\n    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        d['stale_callback'] = None\n        return d\n\n    def remove(self):\n        \"\"\"\n        Remove the artist from the figure if possible.\n\n        The effect will not be visible until the figure is redrawn, e.g.,\n        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n        update the Axes limits if desired.\n\n        Note: `~.axes.Axes.relim` will not see collections even if the\n        collection was added to the Axes with *autolim* = True.\n\n        Note: there is no support for removing the"}], "retrieved_count": 10, "cost_time": 1.3721301555633545}
{"question": "What is the precise definition of Matplotlib's \"Figure\" concept and its relationship to the overall plotting canvas?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Figure is the top-level Artist container that holds all plot elements and serves as the root of the plotting hierarchy. It is defined as the complete graphical output that contains one or more Axes, along with figure-level elements like titles, legends, and colorbars. The Figure has a direct relationship with the FigureCanvas through the canvas attribute - the Figure is rendered onto the FigureCanvas, which is the backend-specific drawing area that handles the actual output to screen or file. The Figure manages its size (figsize), resolution (dpi), background (facecolor), and layout of its child elements. It also maintains lists of all its contained Artists (axes, lines, patches, texts, images, legends) and provides methods for adding, removing, and managing these elements. The Figure acts as the bridge between the high-level plotting API and the low-level rendering system, coordinating the drawing of all its contained elements onto the canvas.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 61000, "end_line": 63000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ure : `~matplotlib.figure.Figure`\n        A high-level figure instance.\n    \"\"\"\n\n    # Set to one of {\"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\", \"macosx\"} if an\n    # interactive framework is required, or None otherwise.\n    required_interactive_framework = None\n\n    # The manager class instantiated by new_manager.\n    # (This is defined as a classproperty because the manager class is\n    # currently defined *after* the canvas class, but one could also assign\n    # ``FigureCanvasBase.manager_class = FigureManagerBase``\n    # after defining both classes.)\n    manager_class = _api.classproperty(lambda cls: FigureManagerBase)\n\n    events = [\n        'resize_event',\n        'draw_event',\n        'key_press_event',\n        'key_release_event',\n        'button_press_event',\n        'button_release_event',\n        'scroll_event',\n        'motion_notify_event',\n        'pick_event',\n        'figure_enter_event',\n        'figure_leave_event',\n        'axes_enter_event',\n        'axes_leave_event',\n        'close_event'\n    ]\n\n    fixed_dpi = None\n\n    filetypes = _default_filetypes\n\n    @_api.classproperty\n    def supports_blit(cls):\n        \"\"\"If this Canvas sub-class supports blitting.\"\"\"\n        return (hasattr(cls, \"copy_from_bbox\")\n                and hasattr(cls, \"restore_region\"))\n\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than "}, {"start_line": 91000, "end_line": 93000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cstring inherited\n\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n\n        artists = self._get_draw_artists(renderer)\n\n        try:\n            renderer.open_group('subfigure', gid=self.get_gid())\n            self.patch.draw(renderer)\n            mimage._draw_list_compositing_images(\n                renderer, self, artists, self.get_figure(root=True).suppressComposite)\n            renderer.close_group('subfigure')\n\n        finally:\n            self.stale = False\n\n\n@_docstring.interpd\nclass Figure(FigureBase):\n    \"\"\"\n    The top level container for all the plot elements.\n\n    See `matplotlib.figure` for an index of class methods.\n\n    Attributes\n    ----------\n    patch\n        The `.Rectangle` instance representing the figure background patch.\n\n    suppressComposite\n        For multiple images, the figure will make composite images\n        depending on the renderer option_image_nocomposite function.  If\n        *suppressComposite* is a boolean, this will override the renderer.\n    \"\"\"\n\n    # we want to cache the fonts and mathtext at a global level so that when\n    # multiple figures are created we can reuse them.  This helps with a bug on\n    # windows where the creation of too many figures leads to too many open\n    # file handles and improves the performance of parsing mathtext.  However,\n    # these global caches are not thread safe.  The solution here is to let the\n    # Figure acquire a shared lock at the start of the draw, and release it when it\n    # is done.  This allows multiple renderers to share the cached fonts and\n    # parsed text, but only one figure can draw at a time and so the font cache\n    # and mathtext cache are used by only one renderer at a time.\n\n    _render_lock = threading.RLock()\n\n    def __str__(self):\n        return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n\n    def __repr__(self):\n        return \"<{clsname} size {h:g}x{w:g} with {naxes} Axes>\".format(\n        "}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nvas and a manager on the figure.\n\n    Once this is done, :rc:`figure.hooks` are called, one at a time, on the\n    figure; these hooks allow arbitrary customization of the figure (e.g.,\n    attaching callbacks) or of associated elements (e.g., modifying the\n    toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of\n    toolbar customization.\n\n    If you are creating many figures, make sure you explicitly call\n    `.pyplot.close` on the figures you are not using, because this will\n    enable pyplot to properly clean up the memory.\n\n    `~matplotlib.rcParams` defines the default values, which can be modified\n    in the matplotlibrc file.\n    \"\"\"\n    allnums = get_fignums()\n\n    if isinstance(num, FigureBase):\n        # type narrowed to `Figure | SubFigure` by combination of input and isinstance\n        root_fig = num.get_figure(root=True)\n        if root_fig.canvas.manager is None:\n            raise ValueError(\"The passed figure is not managed by pyplot\")\n        elif (any(param is not None for param in [figsize, dpi, facecolor, edgecolor])\n              or not frameon or kwargs) and root_fig.canvas.manager.num in allnums:\n            _api.warn_external(\n                \"Ignoring specified arguments in this call because figure \"\n                f\"with num: {root_fig.canvas.manager.num} already exists\")\n        _pylab_helpers.Gcf.set_active(root_fig.canvas.manager)\n        return root_fig\n\n    next_num = max(allnums) + 1 if allnums else 1\n    fig_label = ''\n    if num is None:\n        num = next_num\n    else:\n        if (any(param is not None for param in [figsize, dpi, facecolor, edgecolor])\n              or not frameon or kwargs) and num in allnums:\n            _api.warn_external(\n                \"Ignoring specified arguments in this call \"\n                f\"because figure with num: {num} already exists\")\n        if isinstance(num, str):\n            fig_label = num\n            all_labels = get_figlabels()\n            if fig_label not in all_labels:\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/usage\n.. redirect-from:: /tutorials/introductory/quick_start\n\n.. _quick_start:\n\n*****************\nQuick start guide\n*****************\n\nThis tutorial covers some basic usage patterns and best practices to\nhelp you get started with Matplotlib.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# sphinx_gallery_thumbnail_number = 3\n\n# %%\n#\n# A simple example\n# ================\n#\n# Matplotlib graphs your data on `.Figure`\\s (e.g., windows, Jupyter\n# widgets, etc.), each of which can contain one or more `~.axes.Axes`, an\n# area where points can be specified in terms of x-y coordinates (or theta-r\n# in a polar plot, x-y-z in a 3D plot, etc.).  The simplest way of\n# creating a Figure with an Axes is using `.pyplot.subplots`. We can then use\n# `.Axes.plot` to draw some data on the Axes, and `~.pyplot.show` to display\n# the figure:\n\nfig, ax = plt.subplots()             # Create a figure containing a single Axes.\nax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gure=fig)\nl2 = lines.Line2D([0, 1], [1, 0], transform=fig.transFigure, figure=fig)\nfig.lines.extend([l1, l2])\n\nplt.show()\n\n# %%\n# Here is a summary of the Artists the Figure contains\n#\n# ================ ============================================================\n# Figure attribute Description\n# ================ ============================================================\n# axes             A list of `~.axes.Axes` instances\n# patch            The `.Rectangle` background\n# images           A list of `.FigureImage` patches -\n#                  useful for raw pixel display\n# legends          A list of Figure `.Legend` instances\n#                  (different from ``Axes.get_legend()``)\n# lines            A list of Figure `.Line2D` instances\n#                  (rarely used, see ``Axes.lines``)\n# patches          A list of Figure `.Patch`\\s\n#                  (rarely used, see ``Axes.patches``)\n# texts            A list Figure `.Text` instances\n# ================ ============================================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of v"}], "retrieved_count": 10, "cost_time": 1.384901523590088}
{"question": "What is the relationship between Matplotlib's event system and the interactive plotting features?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event system is the foundation that enables all interactive plotting features. The relationship works as follows: 1) The event system provides the infrastructure for capturing user interactions (mouse clicks, key presses, mouse movements) and converting them into Matplotlib-specific events with data coordinates, 2) Interactive features like panning, zooming, and data point selection are built on top of the event system by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), 3) The event system enables the NavigationToolbar2 class to provide built-in interactive tools by responding to mouse and keyboard events, 4) Custom interactive behaviors can be implemented by connecting user-defined callback functions to events, allowing for personalized data exploration tools, 5) The event system supports object picking, which allows interactive features to determine which Artist was clicked and respond accordingly, 6) Interactive features rely on the event system's coordinate transformation capabilities to convert between pixel coordinates and data coordinates, enabling precise interaction with plot elements, 7) The event system provides the GUI-neutral interface that allows the same interactive code to work across different GUI toolkits (Qt, Tk, GTK, Wx, macOS), 8) Interactive features use the event system's stale state mechanism to trigger redraws when plot elements are modified through user interaction, 9) The event system enables responsive figure updates during long-running computations by periodically processing events through flush_events(), maintaining interactivity even during intensive calculations. Without the event system, Matplotlib would only support static plotting; the event system is what transforms it into an interactive visualization tool.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 1123, "belongs_to": {"file_name": "coords_demo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/event_handling", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n===========================\nMouse move and click events\n===========================\n\nAn example of how to interact with the plotting canvas by connecting to move\nand click events.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\n\nt = np.arange(0.0, 1.0, 0.01)\ns = np.sin(2 * np.pi * t)\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n\ndef on_move(event):\n    if event.inaxes:\n        print(f'data coords {event.xdata} {event.ydata},',\n              f'pixel coords {event.x} {event.y}')\n\n\ndef on_click(event):\n    if event.button is MouseButton.LEFT:\n        print('disconnecting callback')\n        plt.disconnect(binding_id)\n\n\nbinding_id = plt.connect('motion_notify_event', on_move)\nplt.connect('button_press_event', on_click)\n\nplt.show()\n"}, {"start_line": 110000, "end_line": 112000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    if data is not None:\n                            data_str = a.format_cursor_data(data).rstrip()\n                            if data_str:\n                                s = s + '\\n' + data_str\n                return s\n        return \"\"\n\n    def mouse_move(self, event):\n        self._update_cursor(event)\n        self.set_message(self._mouse_event_to_message(event))\n\n    def _zoom_pan_handler(self, event):\n        if self.mode == _Mode.PAN:\n            if event.name == \"button_press_event\":\n                self.press_pan(event)\n            elif event.name == \"button_release_event\":\n                self.release_pan(event)\n        if self.mode == _Mode.ZOOM:\n            if event.name == \"button_press_event\":\n                self.press_zoom(event)\n            elif event.name == \"button_release_event\":\n                self.release_zoom(event)\n\n    def _start_event_axes_interaction(self, event, *, method):\n\n        def _ax_filter(ax):\n            return (ax.in_axes(event) and\n                    ax.get_navigate() and\n                    getattr(ax, f\"can_{method}\")()\n                    )\n\n        def _capture_events(ax):\n            f = ax.get_forward_navigation_events()\n            if f == \"auto\":  # (capture = patch visibility)\n                f = not ax.patch.get_visible()\n            return not f\n\n        # get all relevant axes for the event\n        axes = list(filter(_ax_filter, self.canvas.figure.get_axes()))\n\n        if len(axes) == 0:\n            return []\n\n        if self._nav_stack() is None:\n            self.push_current()   # Set the home button to this view.\n\n        # group axes by zorder (reverse to trigger later axes first)\n        grps = dict()\n        for ax in reversed(axes):\n            grps.setdefault(ax.get_zorder(), []).append(ax)\n\n        axes_to_trigger = []\n        # go through zorders in reverse until we hit a capturing axes\n        for zorder in sorted(grps, reverse=True):\n            for ax in grps[zorder]:\n                axes_to_trigger"}, {"start_line": 87000, "end_line": 89000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)\n\n    def flush_events(self):\n        \"\"\"\n        Flush the GUI events for the figure.\n\n        Interactive backends need to reimplement this method.\n        \"\"\"\n\n    def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start a blocking event loop.\n\n        Such an event loop is used by interactive functions, such as\n        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n        events.\n\n        The event loop blocks until a callback function triggers\n        `stop_event_loop`, or *timeout* is reached.\n\n        If *timeout* is 0 or negative, never timeout.\n\n        Only interactive backends need to reimplement this method and it relies\n        on `flush_events` being properly implemented.\n\n        Interactive backends should implement this in a more native way.\n        \"\"\"\n        if timeout <= 0:\n            timeout = np.inf\n        timestep = 0.01\n        counter = 0\n        self._looping = True\n        while self._looping and counter * timestep < timeout:\n            self.flush_events()\n            time.sleep(timestep)\n            counter += 1\n\n    def stop_event_loop(self):\n        \"\"\"\n        Stop the current blocking event loop.\n\n        Interactive backends need to reimplement this to match\n        `start_event_loop`\n        \"\"\"\n        self._looping = False\n\n\ndef key_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    Implement the default Matplotlib key bindings for the canvas and toolbar\n    described at :ref:`key-event-handling`.\n\n    Parameters\n    ----------\n    event : `KeyEvent`\n        A key press/release event.\n    canvas : `FigureCanvasBase`, default: ``event.canvas``\n        The backend-specific canvas instance.  This parameter is kept for\n        back-compatibility, but, if set, should always be equal to\n        ``event.canvas``.\n    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n        The navi"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)\n\n    def _mpl_coords(self, event=None):\n        \"\"\"\n        Convert the position of a GTK event, or of the current cursor position\n        if *event* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is "}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    fig.canvas.draw_idle()\n\n\ndef gcf() -> Figure:\n    \"\"\"\n    Get the current figure.\n\n    If there is currently no figure on the pyplot figure stack, a new one is\n    created using `~.pyplot.figure()`.  (To test whether there is currently a\n    figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n    is empty.)\n    \"\"\"\n    manager = _pylab_helpers.Gcf.get_active()\n    if manager is not None:\n        return manager.canvas.figure\n    else:\n        return figure()\n\n\ndef fignum_exists(num: int | str) -> bool:\n    \"\"\"\n    Return whether the figure with the given id exists.\n\n    Parameters\n    ----------\n    num : int or str\n        A figure identifier.\n\n    Returns\n    -------\n    bool\n        Whether or not a figure with id *num* exists.\n    \"\"\"\n    return (\n        _pylab_helpers.Gcf.has_fignum(num)\n        if isinstance(num, int)\n        else num in get_figlabels()\n    )\n\n\ndef get_fignums() -> list[int]:\n    \"\"\"Return a list of existing figure numbers.\"\"\"\n    return sorted(_pylab_helpers.Gcf.figs)\n\n\ndef get_figlabels() -> list[Any]:\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    managers = _pylab_helpers.Gcf.get_all_fig_managers()\n    managers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in managers]\n\n\ndef get_current_fig_manager() -> FigureManagerBase | None:\n    \"\"\"\n    Return the figure manager of the current figure.\n\n    The figure manager is a container for the actual backend-depended window\n    that displays the figure on screen.\n\n    If no current figure exists, a new one is created, and its figure\n    manager is returned.\n\n    Returns\n    -------\n    `.FigureManagerBase` or backend-dependent subclass thereof\n    \"\"\"\n    return gcf().canvas.manager\n\n\n@overload\ndef connect(s: MouseEventType, func: Callable[[MouseEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: KeyEventType, func: Callable[[KeyEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: PickEventType, func: Callable[[PickEvent], Any]) -> int: ."}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "This is necessary because the callback registry\n    maintains only weak-refs to the functions, which are member\n    functions of the widget.  If there are no references to the widget\n    object it may be garbage collected which will disconnect the callbacks.\n\n    Attributes\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The parent Axes for the widget.\n    canvas : `~matplotlib.backend_bases.FigureCanvasBase`\n        The parent figure canvas for the widget.\n    active : bool\n        If False, the widget does not respond to events.\n    \"\"\"\n\n    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n\n    canvas = property(\n        lambda self: getattr(self.ax.get_figure(root=True), 'canvas', None)\n    )\n\n    def connect_event(self, event, callback):\n        \"\"\"\n        Connect a callback function with an event.\n\n        This should be used in lieu of ``figure.canvas.mpl_connect`` since this\n        function stores callback ids for later clean up.\n        \"\"\"\n        cid = self.canvas.mpl_connect(event, callback)\n        self._cids.append(cid)\n\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n\n    def _get_data_coords(self, event):\n        \"\"\"Return *event*'s data coordinates in this widget's Axes.\"\"\"\n        # This method handles the possibility that event.inaxes != self.ax (which may\n        # occur if multiple Axes are overlaid), in which case event.xdata/.ydata will\n        # be wrong.  Note that we still special-case the common case where\n        # event.inaxes == self.ax and avoid re-running the inverse data transform,\n        # because that can introduce floating point errors for synthetic events.\n        return ((event.xdata, event.ydata) if event.inaxes is self.ax\n                else self.ax.transData.inverted().transform((event.x, event.y)))\n\n    def ignore(self, event):\n        # docstring inherited\n        return super()."}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _mpl_buttons(self, controller):\n        # NOTE: This spews \"Broken accounting of active state\" warnings on\n        # right click on macOS.\n        surface = self.get_native().get_surface()\n        is_over, x, y, event_state = surface.get_device_position(\n            self.get_display().get_default_seat().get_pointer())\n        # NOTE: alternatively we could use\n        #   event_state = controller.get_current_event_state()\n        # but for button_press/button_release this would report the state\n        # *prior* to the event rather than after it; the above reports the\n        # state *after* it.\n        mod_table = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, G"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " sorted(_pylab_helpers.Gcf.figs)\n\n\ndef get_figlabels() -> list[Any]:\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    managers = _pylab_helpers.Gcf.get_all_fig_managers()\n    managers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in managers]\n\n\ndef get_current_fig_manager() -> FigureManagerBase | None:\n    \"\"\"\n    Return the figure manager of the current figure.\n\n    The figure manager is a container for the actual backend-depended window\n    that displays the figure on screen.\n\n    If no current figure exists, a new one is created, and its figure\n    manager is returned.\n\n    Returns\n    -------\n    `.FigureManagerBase` or backend-dependent subclass thereof\n    \"\"\"\n    return gcf().canvas.manager\n\n\n@overload\ndef connect(s: MouseEventType, func: Callable[[MouseEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: KeyEventType, func: Callable[[KeyEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: PickEventType, func: Callable[[PickEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: ResizeEventType, func: Callable[[ResizeEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: CloseEventType, func: Callable[[CloseEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: DrawEventType, func: Callable[[DrawEvent], Any]) -> int: ...\n\n\n@_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)\ndef connect(s, func) -> int:\n    return gcf().canvas.mpl_connect(s, func)\n\n\n@_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)\ndef disconnect(cid: int) -> None:\n    gcf().canvas.mpl_disconnect(cid)\n\n\ndef close(fig: None | int | str | Figure | Literal[\"all\"] = None) -> None:\n    \"\"\"\n    Close a figure window, and unregister it from pyplot.\n\n    Parameters\n    ----------\n    fig : None or int or str or `.Figure`\n        The figure to close. There are a number of ways to specify this:\n\n        - *None*: the current figure\n        - `.Figure`: the given `.Figure` instance\n        - ``int``: a figure number\n        - ``str``: a figure name\n    "}], "retrieved_count": 10, "cost_time": 1.36967134475708}
{"question": "Why does Matplotlib use an Artist-based rendering system instead of direct drawing commands?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib uses an Artist-based rendering system instead of direct drawing commands for several key architectural benefits: 1) The Artist system provides a high-level abstraction that separates plotting logic from low-level rendering details, allowing the same plotting code to work across different backends (GUI, file formats), 2) Artists encapsulate both data and visual properties, making it easier to modify plot elements after creation and maintain consistency between data and representation, 3) The hierarchical Artist structure (Figure â Axes â individual Artists) provides a natural organization for complex plots and enables efficient rendering by managing parent-child relationships, 4) Artists support interactive features like picking, selection, and event handling that would be difficult to implement with direct drawing commands, 5) The Artist system enables advanced features like automatic layout, coordinate transformations, and clipping that are handled transparently, 6) Artists can be easily serialized, saved, and restored, supporting features like figure pickling and state management, 7) The system provides a consistent API for all visual elements while allowing backend-specific optimizations through the renderer interface. This design enables Matplotlib to support both simple plotting and complex, interactive visualizations with a unified architecture.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(f\"{_nums_to_str(*rect.p0, *rect.size)} rectclip\\n\")\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataS"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}], "retrieved_count": 10, "cost_time": 1.3633465766906738}
{"question": "What is Matplotlib's backend system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend system is the rendering layer that converts abstract plot descriptions into actual output formats. It consists of two main types: 1) Interactive backends for displaying plots on screen (QtAgg, GTK3Agg, wxAgg, TkAgg, macosx) that work with GUI toolkits, and 2) Non-interactive backends for generating file output (PNG, SVG, PDF, PS) using renderers like Agg (Anti-Grain Geometry), PDF, PS, SVG, and PGF. The backend system separates the plotting logic from the output mechanism, allowing the same plotting code to work across different display environments and file formats. Each backend implements a FigureCanvas class that handles the specific rendering requirements, and the system can be configured through rcParams, environment variables, or the matplotlib.use() function.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplotlib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in whic"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 0, "end_line": 206, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from .registry import BackendFilter, backend_registry  # noqa: F401\n\n# NOTE: plt.switch_backend() (called at import time) will add a \"backend\"\n# attribute here for backcompat.\n_QT_FORCE_QT5_BINDING = False\n"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n    "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from enum import Enum\nimport importlib\n\n\nclass BackendFilter(Enum):\n    \"\"\"\n    Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n    .. versionadded:: 3.9\n    \"\"\"\n    INTERACTIVE = 0\n    NON_INTERACTIVE = 1\n\n\nclass BackendRegistry:\n    \"\"\"\n    Registry of backends available within Matplotlib.\n\n    This is the single source of truth for available backends.\n\n    All use of ``BackendRegistry`` should be via the singleton instance\n    ``backend_registry`` which can be imported from ``matplotlib.backends``.\n\n    Each backend has a name, a module name containing the backend code, and an\n    optional GUI framework that must be running if the backend is interactive.\n    There are three sources of backends: built-in (source code is within the\n    Matplotlib repository), explicit ``module://some.backend`` syntax (backend is\n    obtained by loading the module), or via an entry point (self-registering\n    backend in an external package).\n\n    .. versionadded:: 3.9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of g"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         without prior warning.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    if auto_select:\n        return rcParams['backend']\n    else:\n        backend = rcParams._get('backend')\n        if backend is rcsetup._auto_backend_sentinel:\n            return None\n        else:\n            return backend\n\n\ndef interactive(b):\n    \"\"\"\n    Set whether to redraw after every plotting command (e.g. `.pyplot.xlabel`).\n    \"\"\"\n    rcParams['interactive'] = b\n\n\ndef is_interactive():\n    \"\"\"\n    Return whether to redraw after every plotting command.\n\n    .. note::\n\n        This function is only intended for use in backends. End users should\n        use `.pyplot.isinteractive` instead.\n    \"\"\"\n    return rcParams['interactive']\n\n\ndef _val_or_rc(val, *rc_names):\n    \"\"\"\n    If *val* is None, the first not-None value in ``mpl.rcParams[rc_names[i]]``.\n    If all are None returns ``mpl.rcParams[rc_names[-1]]``.\n    \"\"\"\n    if val is not None:\n        return val\n\n    for rc_name in rc_names[:-1]:\n        if rcParams[rc_name] is not None:\n            return rcParams[rc_name]\n    return rcParams[rc_names[-1]]\n\n\ndef _init_tests():\n    # The version of FreeType to install locally for running the tests. This must match\n    # the value in `meson.build`.\n    LOCAL_FREETYPE_VERSION = '2.6.1'\n\n    from matplotlib import ft2font\n    if (ft2font.__freetype_version__ != LOCAL_FREETYPE_VERSION or\n            ft2font.__freetype_build_type__ != 'local'):\n        _log.warning(\n            \"Matplotlib is not built with the correct FreeType version to run tests.  \"\n            \"Rebuild without setting system-freetype=true in Meson setup options.  \"\n            \"Expect many image comparison failures below.  \"\n            \"Expected freetype version %s.  \"\n            \"Found freetype version %s.  \"\n            \"Freetype build type is %slocal.\",\n            LOCAL_FREETYPE_VERSION,\n            ft2font.__freetype_version__,\n            \"\" if ft2font.__freetype_build_type__ == 'local' else \"not \")\n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n            self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entr"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAbstract base classes define the primitives that renderers and\ngraphics contexts must implement to serve as a Matplotlib backend.\n\n`RendererBase`\n    An abstract base class to handle drawing/rendering operations.\n\n`FigureCanvasBase`\n    The abstraction layer that separates the `.Figure` from the backend\n    specific details like a user interface drawing area.\n\n`GraphicsContextBase`\n    An abstract base class that provides color, line styles, etc.\n\n`Event`\n    The base class for all of the Matplotlib event handling.  Derived classes\n    such as `KeyEvent` and `MouseEvent` store the meta data like keys and\n    buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.\n\n`ShowBase`\n    The base class for the ``Show`` class of each interactive backend; the\n    'show' callable is then set to ``Show.__call__``.\n\n`ToolContainerBase`\n    The base class for the Toolbar class of each interactive backend.\n\"\"\"\n\nfrom collections import namedtuple\nfrom contextlib import ExitStack, contextmanager, nullcontext\nfrom enum import Enum, IntEnum\nimport functools\nimport importlib\nimport inspect\nimport io\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport signal\nimport socket\nimport sys\nimport time\nimport weakref\nfrom weakref import WeakKeyDictionary\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import (\n    _api, backend_tools as tools, cbook, colors, _docstring, text,\n    _tight_bbox, transforms, widgets, is_interactive, rcParams)\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_managers import ToolManager\nfrom matplotlib.cbook import _setattr_cm\nfrom matplotlib.layout_engine import ConstrainedLayoutEngine\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib._enums import JoinStyle, CapStyle\n\n\n_log = logging.getLogger(__name__)\n_default_filetypes = {\n    'eps': 'Encapsulated Postscript',\n    'gif': 'Graphics Interchange Format',\n    'jpg': "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "BUILTIN_BACKEND_TO_GUI_FRAMEWORK]\n\n    def list_gui_frameworks(self):\n        \"\"\"\n        Return list of GUI frameworks used by Matplotlib backends.\n\n        Returns\n        -------\n        list of str\n            GUI framework names.\n        \"\"\"\n        return [k for k in self._GUI_FRAMEWORK_TO_BACKEND if k != \"headless\"]\n\n    def load_backend_module(self, backend):\n        \"\"\"\n        Load and return the module containing the specified backend.\n\n        Parameters\n        ----------\n        backend : str\n            Name of backend to load.\n\n        Returns\n        -------\n        Module\n            Module containing backend.\n        \"\"\"\n        module_name = self._backend_module_name(backend)\n        return importlib.import_module(module_name)\n\n    def resolve_backend(self, backend):\n        \"\"\"\n        Return the backend and GUI framework for the specified backend name.\n\n        If the GUI framework is not yet known then it will be determined by loading the\n        backend module and checking the ``FigureCanvas.required_interactive_framework``\n        attribute.\n\n        This function only loads entry points if they have not already been loaded and\n        the backend is not built-in and not of ``module://some.backend`` format.\n\n        Parameters\n        ----------\n        backend : str or None\n            Name of backend, or None to use the default backend.\n\n        Returns\n        -------\n        backend : str\n            The backend name.\n        framework : str or None\n            The GUI framework, which will be None for a backend that is non-interactive.\n        \"\"\"\n        if isinstance(backend, str):\n            if not backend.startswith(\"module://\"):\n                backend = backend.lower()\n        else:  # Might be _auto_backend_sentinel or None\n            # Use whatever is already running...\n            from matplotlib import get_backend\n            backend = get_backend()\n\n        # Is backend already known (built-in or dynamically loaded)?\n      "}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " and then call switch_backend if\n        # we need to resolve the auto sentinel)\n        switch_backend(rcParams._get(\"backend\"))\n    return cast(type[matplotlib.backend_bases._Backend], _backend_mod)\n\n\ndef switch_backend(newbackend: str) -> None:\n    \"\"\"\n    Set the pyplot backend.\n\n    Switching to an interactive backend is possible only if no event loop for\n    another interactive backend has started.  Switching to and from\n    non-interactive backends is always possible.\n\n    If the new backend is different than the current backend then all open\n    Figures will be closed via ``plt.close('all')``.\n\n    Parameters\n    ----------\n    newbackend : str\n        The case-insensitive name of the backend to use.\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n\n        if (current_framework and\n                (backend := backend_registry.backend_for_gui_framework(\n                    current_framework))):\n            candidates = [backend]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n    old_backend = rcParams._get('backend')  "}], "retrieved_count": 10, "cost_time": 1.4074375629425049}
{"question": "What is the structure of Matplotlib's figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's figure and axes hierarchy follows a parent-child relationship: 1) Figure is the top-level container that holds all plot elements and serves as the root Artist, 2) SubFigure objects can be nested within a Figure to create logical groupings, 3) Axes objects are the primary plotting areas within Figures or SubFigures, containing the actual data visualization, 4) Each Axes contains XAxis and YAxis objects that handle tick marks, labels, and coordinate systems, 5) Individual Artist objects (lines, text, patches, etc.) are contained within Axes. The hierarchy is managed through methods like Figure.add_axes(), Figure.subplots(), and Figure.add_subfigure(), with the Figure maintaining lists of its child Axes and other Artists. This structure allows for complex layouts with multiple subplots, nested figures, and precise control over the positioning and organization of plot elements.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via\n# :meth:`~matplotlib.axes.Axes.set_xlabel`), and a y-label set via\n# :meth:`~matplotlib.axes.Axes.set_ylabel`).\n#\n# The `~.axes.Axes` methods are the primary interface for configuring\n# most parts of your plot (adding data, controlling axis scales and\n# limits, adding labels etc.).\n#\n# :class:`~matplotlib.axis.Axis`\n# ------------------------------\n#\n# These objects set the scale and limits and generate ticks (the marks\n# on the Axis) and ticklabels (strings labeling the ticks).  The location\n# of the ticks is determined by a `~matplotlib.ticker.Locator` object and the\n# ticklabel strings are formatted by a `~matplotlib.ticker.Formatter`.  The\n# combination of the correct `.Locator` and `.Formatter` gives very fine\n# control over the tick locations and labels.\n#\n# :class:`~matplotlib.artist.Artist`\n# ----------------------------------\n#\n# Basically, everything visible on the Figure is an Artist (even\n# `.Figure`, `Axes <.axes.Axes>`, and `~.axis.Axis` objects).  This includes\n# `.Text"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instances you want to customize.  Here is an\n# example which turns all the Axes grids on::\n#\n#     for ax in fig.axes:\n#         ax.grid(True)\n#\n#\n# The figure also has its own ``images``, ``lines``, ``patches`` and ``text``\n# attributes, which you can use to add primitives directly. When doing so, the\n# default coordinate system for the ``Figure`` will simply be in pixels (which\n# is not usually what you want). If you instead use Figure-level methods to add\n# Artists (e.g., using `.Figure.text` to add text), then the default coordinate\n# system will be \"figure coordinates\" where (0, 0) is the bottom-left of the\n# figure and (1, 1) is the top-right of the figure.\n#\n# As with all ``Artist``\\s, you can control this coordinate system by setting\n# the transform property. You can explicitly use \"figure coordinates\" by\n# setting the ``Artist`` transform to :attr:`!fig.transFigure`:\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\n\nl1 = lines.Line2D([0, 1], [0, 1], transform=fig.transFigure, fi"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gure=fig)\nl2 = lines.Line2D([0, 1], [1, 0], transform=fig.transFigure, figure=fig)\nfig.lines.extend([l1, l2])\n\nplt.show()\n\n# %%\n# Here is a summary of the Artists the Figure contains\n#\n# ================ ============================================================\n# Figure attribute Description\n# ================ ============================================================\n# axes             A list of `~.axes.Axes` instances\n# patch            The `.Rectangle` background\n# images           A list of `.FigureImage` patches -\n#                  useful for raw pixel display\n# legends          A list of Figure `.Legend` instances\n#                  (different from ``Axes.get_legend()``)\n# lines            A list of Figure `.Line2D` instances\n#                  (rarely used, see ``Axes.lines``)\n# patches          A list of Figure `.Patch`\\s\n#                  (rarely used, see ``Axes.patches``)\n# texts            A list Figure `.Text` instances\n# ================ ============================================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of v"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a not in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}], "retrieved_count": 10, "cost_time": 1.4149129390716553}
{"question": "What is the role of Matplotlib's \"Backend\" class in the output system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Backend class (specifically FigureCanvasBase and its subclasses) serves as the abstraction layer that handles the conversion of abstract plot descriptions into actual output formats. It provides the interface between the high-level plotting API and the specific rendering engines or GUI toolkits. The Backend class manages the canvas where figures are drawn, handles file output operations, coordinates with GUI event loops, and provides the rendering context for all plot elements. It separates the plotting logic from the output mechanism, allowing the same plotting code to work across different display environments (Qt, Tk, GTK, etc.) and file formats (PNG, PDF, SVG, etc.). The Backend class also manages the relationship between Figures and their display contexts, handles coordinate transformations, and provides methods for saving figures to files with appropriate format-specific options.", "score": null, "retrieved_content": [{"start_line": 133000, "end_line": 134175, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s.modules.get(\"matplotlib.pyplot\"), \"show\", None)\n            ipython_pylab = hasattr(pyplot_show, \"_needmain\")\n            block = not ipython_pylab and not is_interactive()\n        if block:\n            cls.mainloop()\n\n    # This method is the one actually exporting the required methods.\n\n    @staticmethod\n    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls\n\n\nclass ShowBase(_Backend):\n    \"\"\"\n    Simple base class to generate a ``show()`` function in backends.\n\n    Subclass must override ``mainloop()`` method.\n    \"\"\"\n\n    def __call__(self, block=None):\n        return self.show(block=block)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "vent, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'\n\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasTemplate\nFigureManager = FigureMana"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n\n\ndraw_all = _pylab_helpers.Gcf.draw_all\n\n\n# Ensure this appears in the pyplot docs.\n@_copy_docstring_and_deprecators(matplotlib.set_loglevel)\ndef set_loglevel(level: LogLevel) -> None:\n    return matplotlib.set_loglevel(level)\n\n\n@_copy_docstring_and_deprecators(Artist.findobj)\ndef findobj(\n    o: Artist | None = None,\n    match: Callable[[Artist], bool] | type[Artist] | None = None,\n    include_self: bool = True\n) -> list[Artist]:\n    if o is None:\n        o = gcf()\n    return o.findobj(match, include_self=include_self)\n\n\n_backend_mod: type[matplotlib.backend_bases._Backend] | None = None\n\n\ndef _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:\n    \"\"\"\n    Ensure that a backend is selected and return it.\n\n    This is currently private, but may be made public in the future.\n    \"\"\"\n    if _backend_mod is None:\n        # Use rcParams._get(\"backend\") to avoid going through the fallback\n        # logic (which will (re)import pyplot and then call switch_backend if\n        # we need to resolve the auto sentinel)\n        switch_backend(rcParams._get(\"backend\"))\n    return cast(type[matplotlib.backend_bases._Backend], _backend_mod)\n\n\ndef switch_backend(newbackend: str) -> None:\n    \"\"\"\n    Set the pyplot backend.\n\n    Switching to an interactive backend is possible only if no event loop for\n    another interactive backend has started.  Switching to and from\n    non-interactive backends is always possible.\n\n    If the new backend is different than the current backend then all open\n    Figures will be closed via ``plt.close('all')``.\n\n    Parameters\n    ----------\n    newbackend : str\n        The case-insensitive name of the backend to use.\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n\n        if (current_frame"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive() -> None:\n            if matplotlib.is_interactive():\n                manager = _pylab_helpers.Gcf.get_active()\n                if manager:\n                    manager.canvas.draw_idle()\n\n        backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n            new_figure_manager_given_figure)\n        backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n            new_figure_manager)\n        backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n            draw_if_interactive)\n\n    # If the manager explicitly overrides pyplot_show, use it even if a global\n    # show is already present, as the latter may be here for backcompat.\n    manager_class = getattr(canvas_class, \"manager_class\", None)\n    # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n    # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n    # thus always different (being bound to different classes).  We also "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hics context provides the color, line styles, etc.  See the cairo\n    and postscript backends for examples of mapping the graphics context\n    attributes (cap styles, join styles, line widths, colors) to a particular\n    backend.  In cairo this is done by wrapping a cairo.Context object and\n    forwarding the appropriate calls to it using a dictionary mapping styles\n    to gdk constants.  In Postscript, all the work is done by the renderer,\n    mapping line styles to postscript calls.\n\n    If it's more appropriate to do the mapping at the renderer level (as in\n    the postscript backend), you don't need to override any of the GC methods.\n    If it's more appropriate to wrap an instance (as in the cairo backend) and\n    do the mapping here, you'll need to override several of the setter\n    methods.\n\n    The base GraphicsContext stores colors as an RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\n    appropriate for your backend.\n    \"\"\"\n\n\n########################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_e"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#####################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file t"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return"}], "retrieved_count": 10, "cost_time": 1.4065067768096924}
{"question": "Why does Matplotlib implement an event-driven system for interactive plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements an event-driven system for interactive plotting to enable responsive user interactions and support real-time data exploration. The event-driven architecture serves several key purposes: 1) It provides a GUI-neutral interface that works across different GUI toolkits (Qt, Tk, GTK, Wx, macOS) while maintaining consistent behavior, 2) The system converts low-level GUI events (mouse clicks, key presses) into Matplotlib-specific events with data coordinates, enabling precise interaction with plot elements, 3) It supports built-in interactive features like panning, zooming, and data point selection that enhance data exploration capabilities, 4) The event system allows users to create custom interactive behaviors by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), 5) It enables responsive figure updates during long-running computations by periodically processing events through flush_events(), 6) The event-driven approach supports integration with command-line interfaces through input hook mechanisms, allowing both interactive plotting and command-line usage, 7) It provides a foundation for advanced interactive features like picking, selection, and custom data exploration tools. This design enables Matplotlib to support both static plotting and dynamic, interactive visualizations that respond to user input in real-time.", "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al implementation uses a Tk canvas,  this routine\n        is intended to hide that fact.\n        \"\"\"\n        return self._tkcanvas\n\n    def _event_mpl_coords(self, event):\n        # calling canvasx/canvasy allows taking scrollbars into account (i.e.\n        # the top of the widget may have been scrolled out of view).\n        return (self._tkcanvas.canvasx(event.x),\n                # flipy so y=0 is bottom of canvas\n                self.figure.bbox.height - self._tkcanvas.canvasy(event.y))\n\n    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, event):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def button_press_event(self, event, dblclick=False):\n        # set focus to the canvas so that it can receive keyboard events\n        self._tkcanvas.focus_set()\n\n        num = getattr(event, 'num', None)\n        if sys.platform == 'darwin':  # 2 and 3 are reversed.\n            num = {2: 3, 3: 2}.get(num, num)\n        MouseEvent(\"button_press_event\", self,\n                   *self._event_mpl_coords(event), num, dblclick=dblclick,\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def button_dblclick_event(self, event):\n        self.button_press_event(event, dblclick=True)\n\n    def button_release_event(self, event):\n        num = "}, {"start_line": 87000, "end_line": 89000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)\n\n    def flush_events(self):\n        \"\"\"\n        Flush the GUI events for the figure.\n\n        Interactive backends need to reimplement this method.\n        \"\"\"\n\n    def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start a blocking event loop.\n\n        Such an event loop is used by interactive functions, such as\n        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n        events.\n\n        The event loop blocks until a callback function triggers\n        `stop_event_loop`, or *timeout* is reached.\n\n        If *timeout* is 0 or negative, never timeout.\n\n        Only interactive backends need to reimplement this method and it relies\n        on `flush_events` being properly implemented.\n\n        Interactive backends should implement this in a more native way.\n        \"\"\"\n        if timeout <= 0:\n            timeout = np.inf\n        timestep = 0.01\n        counter = 0\n        self._looping = True\n        while self._looping and counter * timestep < timeout:\n            self.flush_events()\n            time.sleep(timestep)\n            counter += 1\n\n    def stop_event_loop(self):\n        \"\"\"\n        Stop the current blocking event loop.\n\n        Interactive backends need to reimplement this to match\n        `start_event_loop`\n        \"\"\"\n        self._looping = False\n\n\ndef key_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    Implement the default Matplotlib key bindings for the canvas and toolbar\n    described at :ref:`key-event-handling`.\n\n    Parameters\n    ----------\n    event : `KeyEvent`\n        A key press/release event.\n    canvas : `FigureCanvasBase`, default: ``event.canvas``\n        The backend-specific canvas instance.  This parameter is kept for\n        back-compatibility, but, if set, should always be equal to\n        ``event.canvas``.\n    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n        The navi"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      # don't recreate the timer in that case.\n        if not self._single and self._timer:\n            if self._interval > 0:\n                self._timer = self.parent.after(self._interval, self._on_timer)\n            else:\n                # Edge case: Tcl after 0 *prepends* events to the queue\n                # so a 0 interval does not allow any other events to run.\n                # This incantation is cancellable and runs as fast as possible\n                # while also allowing events and drawing every frame. GH#18236\n                self._timer = self.parent.after_idle(\n                    lambda: self.parent.after(self._interval, self._on_timer)\n                )\n        else:\n            self._timer = None\n\n\nclass FigureCanvasTk(FigureCanvasBase):\n    required_interactive_framework = \"tk\"\n    manager_class = _api.classproperty(lambda cls: FigureManagerTk)\n\n    def __init__(self, figure=None, master=None):\n        super().__init__(figure)\n        self._idle_draw_id = None\n        self._event_loop_id = None\n        w, h = self.get_width_height(physical=True)\n        self._tkcanvas = tk.Canvas(\n            master=master, background=\"white\",\n            width=w, height=h, borderwidth=0, highlightthickness=0)\n        self._tkphoto = tk.PhotoImage(\n            master=self._tkcanvas, width=w, height=h)\n        self._tkcanvas_image_region = self._tkcanvas.create_image(\n            w//2, h//2, image=self._tkphoto)\n        self._tkcanvas.bind(\"<Configure>\", self.resize)\n        self._tkcanvas.bind(\"<Map>\", self._update_device_pixel_ratio)\n        self._tkcanvas.bind(\"<Key>\", self.key_press)\n        self._tkcanvas.bind(\"<Motion>\", self.motion_notify_event)\n        self._tkcanvas.bind(\"<Enter>\", self.enter_notify_event)\n        self._tkcanvas.bind(\"<Leave>\", self.leave_notify_event)\n        self._tkcanvas.bind(\"<KeyRelease>\", self.key_release)\n        for name in [\"<Button-1>\", \"<Button-2>\", \"<Button-3>\"]:\n            self._tkcanvas.bind(name, self.button_press_event)\n "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", object]\n    \"\"\"\n\n    old_sigint_handler = signal.getsignal(signal.SIGINT)\n    if old_sigint_handler in (None, signal.SIG_IGN, signal.SIG_DFL):\n        yield\n        return\n\n    handler_args = None\n    wsock, rsock = socket.socketpair()\n    wsock.setblocking(False)\n    rsock.setblocking(False)\n    old_wakeup_fd = signal.set_wakeup_fd(wsock.fileno())\n    notifier = prepare_notifier(rsock)\n\n    def save_args_and_handle_sigint(*args):\n        nonlocal handler_args, notifier\n        handler_args = args\n        handle_sigint(notifier)\n        notifier = None\n\n    signal.signal(signal.SIGINT, save_args_and_handle_sigint)\n    try:\n        yield\n    finally:\n        wsock.close()\n        rsock.close()\n        signal.set_wakeup_fd(old_wakeup_fd)\n        signal.signal(signal.SIGINT, old_sigint_handler)\n        if handler_args is not None:\n            old_sigint_handler(*handler_args)\n\n\nclass FigureCanvasBase:\n    \"\"\"\n    The canvas the figure renders into.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level figure instance.\n    \"\"\"\n\n    # Set to one of {\"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\", \"macosx\"} if an\n    # interactive framework is required, or None otherwise.\n    required_interactive_framework = None\n\n    # The manager class instantiated by new_manager.\n    # (This is defined as a classproperty because the manager class is\n    # currently defined *after* the canvas class, but one could also assign\n    # ``FigureCanvasBase.manager_class = FigureManagerBase``\n    # after defining both classes.)\n    manager_class = _api.classproperty(lambda cls: FigureManagerBase)\n\n    events = [\n        'resize_event',\n        'draw_event',\n        'key_press_event',\n        'key_release_event',\n        'button_press_event',\n        'button_release_event',\n        'scroll_event',\n        'motion_notify_event',\n        'pick_event',\n        'figure_enter_event',\n        'figure_leave_event',\n        'axes_enter_event',\n        'axes_leave_event',\n     "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)\n\n    def _mpl_coords(self, event=None):\n        \"\"\"\n        Convert the position of a GTK event, or of the current cursor position\n        if *event* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is "}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 0, 0, visible=False, color=\"k\", lw=1,\n                                transform=mpl.transforms.IdentityTransform())\n\n        self.connect_event('button_press_event', self._click)\n        self.connect_event('button_release_event', self._release)\n        self.connect_event('motion_notify_event', self._motion)\n        self.connect_event('key_press_event', self._keypress)\n        self.connect_event('resize_event', self._resize)\n\n        self.color = color\n        self.hovercolor = hovercolor\n\n        self.capturekeystrokes = False\n\n    @property\n    def text(self):\n        return self.text_disp.get_text()\n\n    def _rendercursor(self):\n        # this is a hack to figure out where the cursor should go.\n        # we draw the text up to where the cursor should go, measure\n        # and save its dimensions, draw the real text, then put the cursor\n        # at the saved dimensions\n\n        # This causes a single extra draw if the figure has never been rendered\n        # yet, which should be fine as we're going to repeatedly re-render the\n        # figure later anyways.\n        fig = self.ax.get_figure(root=True)\n        if fig._get_renderer() is None:\n            fig.canvas.draw()\n\n        text = self.text_disp.get_text()  # Save value before overwriting it.\n        widthtext = text[:self.cursor_index]\n\n        bb_text = self.text_disp.get_window_extent()\n        self.text_disp.set_text(widthtext or \",\")\n        bb_widthtext = self.text_disp.get_window_extent()\n\n        if bb_text.y0 == bb_text.y1:  # Restoring the height if no text.\n            bb_text.y0 -= bb_widthtext.height / 2\n            bb_text.y1 += bb_widthtext.height / 2\n        elif not widthtext:  # Keep width to 0.\n            bb_text.x1 = bb_text.x0\n        else:  # Move the cursor using width of bb_widthtext.\n            bb_text.x1 = bb_text.x0 + bb_widthtext.width\n\n        self.cursor.set(\n            segments=[[(bb_text.x1, bb_text.y0), (bb_text.x1, bb_text.y1)]],\n            visible=True)\n        self.text"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ering different compared to mpl.\n            button for button, mask in [\n                (MouseButton.LEFT, 1),\n                (MouseButton.RIGHT, 2),\n                (MouseButton.MIDDLE, 4),\n                (MouseButton.BACK, 8),\n                (MouseButton.FORWARD, 16),\n            ] if event['buttons'] & mask  # State *after* press/release.\n        }\n        modifiers = event['modifiers']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def"}], "retrieved_count": 10, "cost_time": 1.386826992034912}
{"question": "What is the exact meaning of Matplotlib's \"Axes\" concept and its difference from a subplot?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Axes is the fundamental plotting area that contains the actual data visualization, coordinate systems, and plotting elements. An Axes is an Artist object that represents a single plotting region with its own coordinate system, typically containing XAxis and YAxis objects that define the data coordinate space. The term 'subplot' refers specifically to an Axes that is positioned within a grid of other Axes on a Figure - essentially, a subplot is an Axes that is part of a regular grid layout. While all subplots are Axes, not all Axes are subplots; an Axes can be positioned anywhere on a Figure using methods like Figure.add_axes() with custom coordinates, while subplots are created using methods like Figure.subplots() or pyplot.subplot() that automatically arrange them in a grid. The Axes class provides the main interface for plotting data, setting labels, titles, legends, and configuring the appearance of the plot.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via\n# :meth:`~matplotlib.axes.Axes.set_xlabel`), and a y-label set via\n# :meth:`~matplotlib.axes.Axes.set_ylabel`).\n#\n# The `~.axes.Axes` methods are the primary interface for configuring\n# most parts of your plot (adding data, controlling axis scales and\n# limits, adding labels etc.).\n#\n# :class:`~matplotlib.axis.Axis`\n# ------------------------------\n#\n# These objects set the scale and limits and generate ticks (the marks\n# on the Axis) and ticklabels (strings labeling the ticks).  The location\n# of the ticks is determined by a `~matplotlib.ticker.Locator` object and the\n# ticklabel strings are formatted by a `~matplotlib.ticker.Formatter`.  The\n# combination of the correct `.Locator` and `.Formatter` gives very fine\n# control over the tick locations and labels.\n#\n# :class:`~matplotlib.artist.Artist`\n# ----------------------------------\n#\n# Basically, everything visible on the Figure is an Artist (even\n# `.Figure`, `Axes <.axes.Axes>`, and `~.axis.Axis` objects).  This includes\n# `.Text"}, {"start_line": 49000, "end_line": 51000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   .pyplot.subplots\n\n    Examples\n    --------\n    ::\n\n        # Creating a new full window Axes\n        plt.axes()\n\n        # Creating a new Axes with specified dimensions and a grey background\n        plt.axes((left, bottom, width, height), facecolor='grey')\n    \"\"\"\n    fig = gcf()\n    pos = kwargs.pop('position', None)\n    if arg is None:\n        if pos is None:\n            return fig.add_subplot(**kwargs)\n        else:\n            return fig.add_axes(pos, **kwargs)\n    else:\n        return fig.add_axes(arg, **kwargs)\n\n\ndef delaxes(ax: matplotlib.axes.Axes | None = None) -> None:\n    \"\"\"\n    Remove an `~.axes.Axes` (defaulting to the current Axes) from its figure.\n    \"\"\"\n    if ax is None:\n        ax = gca()\n    ax.remove()\n\n\ndef sca(ax: Axes) -> None:\n    \"\"\"\n    Set the current Axes to *ax* and the current Figure to the parent of *ax*.\n    \"\"\"\n    # Mypy sees ax.figure as potentially None,\n    # but if you are calling this, it won't be None\n    # Additionally the slight difference between `Figure` and `FigureBase` mypy catches\n    fig = ax.get_figure(root=False)\n    figure(fig)  # type: ignore[arg-type]\n    fig.sca(ax)  # type: ignore[union-attr]\n\n\ndef cla() -> None:\n    \"\"\"Clear the current Axes.\"\"\"\n    # Not generated via boilerplate.py to allow a different docstring.\n    return gca().cla()\n\n\n## More ways of creating Axes ##\n\n@overload\ndef subplot(nrows: int, ncols: int, index: int, /, **kwargs): ...\n\n\n@overload\ndef subplot(pos: int | SubplotSpec, /, **kwargs): ...\n\n\n@overload\ndef subplot(**kwargs): ...\n\n\n@_docstring.interpd\ndef subplot(*args, **kwargs) -> Axes:\n    \"\"\"\n    Add an Axes to the current figure or retrieve an existing Axes.\n\n    This is a wrapper of `.Figure.add_subplot` which provides additional\n    behavior when working with the implicit API (see the notes section).\n\n    Call signatures::\n\n       subplot(nrows, ncols, index, **kwargs)\n       subplot(pos, **kwargs)\n       subplot(**kwargs)\n\n    Parameters\n    ----------\n    *args : int, (int, i"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "arranging_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "----------\n\n`~matplotlib.pyplot.subplots`\n    The primary function used to create figures and a grid of Axes.  It\n    creates and places all Axes on the figure at once, and returns an\n    object array with handles for the Axes in the grid.  See\n    `.Figure.subplots`.\n\nor\n\n`~matplotlib.pyplot.subplot_mosaic`\n    A simple way to create figures and a grid of Axes, with the added\n    flexibility that Axes can also span rows or columns. The Axes are returned\n    in a labelled dictionary instead of an array.  See also\n    `.Figure.subplot_mosaic` and\n    :ref:`mosaic`.\n\nSometimes it is natural to have more than one distinct group of Axes grids,\nin which case Matplotlib has the concept of `.SubFigure`:\n\n`~matplotlib.figure.SubFigure`\n    A virtual figure within a figure.\n\nUnderlying tools\n----------------\n\nUnderlying these are the concept of a `~.gridspec.GridSpec` and\na `~.SubplotSpec`:\n\n`~matplotlib.gridspec.GridSpec`\n    Specifies the geometry of the grid that a subplot will be\n    placed. The number of rows and number of columns of the grid\n    need to be set. Optionally, the subplot layout parameters\n    (e.g., left, right, etc.) can be tuned.\n\n`~matplotlib.gridspec.SubplotSpec`\n    Specifies the location of the subplot in the given `.GridSpec`.\n\n.. _fixed_size_axes:\n\nAdding single Axes at a time\n----------------------------\n\nThe above functions create all Axes in a single function call.  It is also\npossible to add Axes one at a time, and this was originally how Matplotlib\nused to work.  Doing so is generally less elegant and flexible, though\nsometimes useful for interactive work or to place an Axes in a custom\nlocation:\n\n`~matplotlib.figure.Figure.add_axes`\n    Adds a single Axes at a location specified by\n    ``[left, bottom, width, height]`` in fractions of figure width or height.\n\n`~matplotlib.pyplot.subplot` or `.Figure.add_subplot`\n    Adds a single subplot on a figure, with 1-based indexing (inherited from\n    Matlab).  Columns and rows can be spanned by speci"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f is patched, so that\n    ``matplotlib.table.table.__qualname__` will also show \"Axes.table\".\n    However, since these functions are not intended to be standalone,\n    this is bearable.\n    \"\"\"\n    func.__qualname__ = f\"Axes.{func.__name__}\"\n    return func\n\n\nclass _GroupedBarReturn:\n    \"\"\"\n    A provisional result object for `.Axes.grouped_bar`.\n\n    This is a placeholder for a future better return type. We try to build in\n    backward compatibility / migration possibilities.\n\n    The only public interfaces are the ``bar_containers`` attribute and the\n    ``remove()`` method.\n    \"\"\"\n    def __init__(self, bar_containers):\n        self.bar_containers = bar_containers\n\n    def remove(self):\n        [b.remove() for b in self.bar_containers]\n\n\n@_docstring.interpd\nclass Axes(_AxesBase):\n    \"\"\"\n    An Axes object encapsulates all the elements of an individual (sub-)plot in\n    a figure.\n\n    It contains most of the (sub-)plot elements: `~.axis.Axis`,\n    `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,\n    and sets the coordinate system.\n\n    Like all visible elements in a figure, Axes is an `.Artist` subclass.\n\n    The `Axes` instance supports callbacks through a callbacks attribute which\n    is a `~.cbook.CallbackRegistry` instance.  The events you can connect to\n    are 'xlim_changed' and 'ylim_changed' and the callback will be called with\n    func(*ax*) where *ax* is the `Axes` instance.\n\n    .. note::\n\n        As a user, you do not instantiate Axes directly, but use Axes creation\n        methods instead; e.g. from `.pyplot` or `.Figure`:\n        `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.\n\n    \"\"\"\n    ### Labelling, legend and texts\n\n    def get_title(self, loc=\"center\"):\n        \"\"\"\n        Get an Axes title.\n\n        Get one of the three available Axes titles. The available titles\n        are positioned above the Axes in the center, flush with the left\n        edge, and flush with the right edge.\n\n        Para"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "~matplotlib.axis` with sharex and/or sharey.\n        The axis will have the same limits, ticks, and scale as the axis\n        of the shared Axes.\n\n    label : str\n        A label for the returned Axes.\n\n    Returns\n    -------\n    `~.axes.Axes`, or a subclass of `~.axes.Axes`\n        The returned Axes class depends on the projection used. It is\n        `~.axes.Axes` if rectilinear projection is used and\n        `.projections.polar.PolarAxes` if polar projection is used.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for\n        the returned Axes class. The keyword arguments for the\n        rectilinear Axes class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used, see the actual Axes\n        class.\n\n        %(Axes:kwdoc)s\n\n    See Also\n    --------\n    .Figure.add_axes\n    .pyplot.subplot\n    .Figure.add_subplot\n    .Figure.subplots\n    .pyplot.subplots\n\n    Examples\n    --------\n    ::\n\n        # Creating a new full window Axes\n        plt.axes()\n\n        # Creating a new Axes with specified dimensions and a grey background\n        plt.axes((left, bottom, width, height), facecolor='grey')\n    \"\"\"\n    fig = gcf()\n    pos = kwargs.pop('position', None)\n    if arg is None:\n        if pos is None:\n            return fig.add_subplot(**kwargs)\n        else:\n            return fig.add_axes(pos, **kwargs)\n    else:\n        return fig.add_axes(arg, **kwargs)\n\n\ndef delaxes(ax: matplotlib.axes.Axes | None = None) -> None:\n    \"\"\"\n    Remove an `~.axes.Axes` (defaulting to the current Axes) from its figure.\n    \"\"\"\n    if ax is None:\n        ax = gca()\n    ax.remove()\n\n\ndef sca(ax: Axes) -> None:\n    \"\"\"\n    Set the current Axes to *ax* and the current Figure to the parent of *ax*.\n    \"\"\"\n    # Mypy sees ax.figure as potentially None,\n    # but if you are calling this, it won't be None\n    # Additionally the slight differenc"}, {"start_line": 53000, "end_line": 55000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt. The keyword arguments\n        for the rectilinear base class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used.\n\n        %(Axes:kwdoc)s\n\n    Notes\n    -----\n    .. versionchanged:: 3.8\n        In versions prior to 3.8, any preexisting Axes that overlap with the new Axes\n        beyond sharing a boundary was deleted. Deletion does not happen in more\n        recent versions anymore. Use `.Axes.remove` explicitly if needed.\n\n    If you do not want this behavior, use the `.Figure.add_subplot` method\n    or the `.pyplot.axes` function instead.\n\n    If no *kwargs* are passed and there exists an Axes in the location\n    specified by *args* then that Axes will be returned rather than a new\n    Axes being created.\n\n    If *kwargs* are passed and there exists an Axes in the location\n    specified by *args*, the projection type is the same, and the\n    *kwargs* match with the existing Axes, then the existing Axes is\n    returned.  Otherwise a new Axes is created with the specified\n    parameters.  We save a reference to the *kwargs* which we use\n    for this comparison.  If any of the values in *kwargs* are\n    mutable we will not detect the case where they are mutated.\n    In these cases we suggest using `.Figure.add_subplot` and the\n    explicit Axes API rather than the implicit pyplot API.\n\n    See Also\n    --------\n    .Figure.add_subplot\n    .pyplot.subplots\n    .pyplot.axes\n    .Figure.subplots\n\n    Examples\n    --------\n    ::\n\n        plt.subplot(221)\n\n        # equivalent but more general\n        ax1 = plt.subplot(2, 2, 1)\n\n        # add a subplot with no frame\n        ax2 = plt.subplot(222, frameon=False)\n\n        # add a polar subplot\n        plt.subplot(223, projection='polar')\n\n        # add a red subplot that shares the x-axis with ax1\n        plt.subplot(224, sharex=ax1, facecolor='red')\n\n        # delete ax2 from the figure\n        plt.delaxes(ax2)\n\n        # add a"}, {"start_line": 50000, "end_line": 52000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e between `Figure` and `FigureBase` mypy catches\n    fig = ax.get_figure(root=False)\n    figure(fig)  # type: ignore[arg-type]\n    fig.sca(ax)  # type: ignore[union-attr]\n\n\ndef cla() -> None:\n    \"\"\"Clear the current Axes.\"\"\"\n    # Not generated via boilerplate.py to allow a different docstring.\n    return gca().cla()\n\n\n## More ways of creating Axes ##\n\n@overload\ndef subplot(nrows: int, ncols: int, index: int, /, **kwargs): ...\n\n\n@overload\ndef subplot(pos: int | SubplotSpec, /, **kwargs): ...\n\n\n@overload\ndef subplot(**kwargs): ...\n\n\n@_docstring.interpd\ndef subplot(*args, **kwargs) -> Axes:\n    \"\"\"\n    Add an Axes to the current figure or retrieve an existing Axes.\n\n    This is a wrapper of `.Figure.add_subplot` which provides additional\n    behavior when working with the implicit API (see the notes section).\n\n    Call signatures::\n\n       subplot(nrows, ncols, index, **kwargs)\n       subplot(pos, **kwargs)\n       subplot(**kwargs)\n\n    Parameters\n    ----------\n    *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n        The position of the subplot described by one of\n\n        - Three integers (*nrows*, *ncols*, *index*). The subplot will take the\n          *index* position on a grid with *nrows* rows and *ncols* columns.\n          *index* starts at 1 in the upper left corner and increases to the\n          right. *index* can also be a two-tuple specifying the (*first*,\n          *last*) indices (1-based, and including *last*) of the subplot, e.g.,\n          ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the\n          upper 2/3 of the figure.\n        - A 3-digit integer. The digits are interpreted as if given separately\n          as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the\n          same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n          if there are no more than 9 subplots.\n        - A `.SubplotSpec`.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', '"}, {"start_line": 0, "end_line": 351, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import _base\nfrom ._axes import Axes\n\n# Backcompat.\nSubplot = Axes\n\n\nclass _SubplotBaseMeta(type):\n    def __instancecheck__(self, obj):\n        return (isinstance(obj, _base._AxesBase)\n                and obj.get_subplotspec() is not None)\n\n\nclass SubplotBase(metaclass=_SubplotBaseMeta):\n    pass\n\n\ndef subplot_class_factory(cls): return cls\n"}], "retrieved_count": 10, "cost_time": 1.4149019718170166}
{"question": "Why does Matplotlib provide a backend system for different output formats (GUI, file, web)?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib provides a backend system for different output formats to support diverse use cases and deployment environments. The backend system addresses several key requirements: 1) Different use cases need different output capabilities - interactive exploration requires GUI backends (Qt, Tk, GTK, Wx, macOS), while publication requires file formats (PNG, PDF, SVG, PS), and web applications need web-compatible outputs, 2) Each output format has specific technical requirements - vector formats (PDF, SVG) need scalable graphics, raster formats (PNG) need pixel-perfect rendering, and GUI backends need event handling and real-time interaction, 3) The backend system enables the same plotting code to work across different environments without modification, supporting portability from development to production, 4) Different GUI toolkits have different event loops and integration requirements that require specialized backend implementations, 5) The system allows users to choose the most appropriate output method for their specific needs - interactive exploration vs. publication-quality output vs. web deployment, 6) Backend-specific optimizations can be implemented while maintaining a consistent high-level API, 7) The modular design enables easy addition of new output formats and GUI toolkits without modifying the core plotting code. This flexibility enables Matplotlib to serve users across different domains from scientific computing to web development to desktop applications.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n    "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "vent, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'\n\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasTemplate\nFigureManager = FigureMana"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "BUILTIN_BACKEND_TO_GUI_FRAMEWORK]\n\n    def list_gui_frameworks(self):\n        \"\"\"\n        Return list of GUI frameworks used by Matplotlib backends.\n\n        Returns\n        -------\n        list of str\n            GUI framework names.\n        \"\"\"\n        return [k for k in self._GUI_FRAMEWORK_TO_BACKEND if k != \"headless\"]\n\n    def load_backend_module(self, backend):\n        \"\"\"\n        Load and return the module containing the specified backend.\n\n        Parameters\n        ----------\n        backend : str\n            Name of backend to load.\n\n        Returns\n        -------\n        Module\n            Module containing backend.\n        \"\"\"\n        module_name = self._backend_module_name(backend)\n        return importlib.import_module(module_name)\n\n    def resolve_backend(self, backend):\n        \"\"\"\n        Return the backend and GUI framework for the specified backend name.\n\n        If the GUI framework is not yet known then it will be determined by loading the\n        backend module and checking the ``FigureCanvas.required_interactive_framework``\n        attribute.\n\n        This function only loads entry points if they have not already been loaded and\n        the backend is not built-in and not of ``module://some.backend`` format.\n\n        Parameters\n        ----------\n        backend : str or None\n            Name of backend, or None to use the default backend.\n\n        Returns\n        -------\n        backend : str\n            The backend name.\n        framework : str or None\n            The GUI framework, which will be None for a backend that is non-interactive.\n        \"\"\"\n        if isinstance(backend, str):\n            if not backend.startswith(\"module://\"):\n                backend = backend.lower()\n        else:  # Might be _auto_backend_sentinel or None\n            # Use whatever is already running...\n            from matplotlib import get_backend\n            backend = get_backend()\n\n        # Is backend already known (built-in or dynamically loaded)?\n      "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplotlib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in whic"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " and then call switch_backend if\n        # we need to resolve the auto sentinel)\n        switch_backend(rcParams._get(\"backend\"))\n    return cast(type[matplotlib.backend_bases._Backend], _backend_mod)\n\n\ndef switch_backend(newbackend: str) -> None:\n    \"\"\"\n    Set the pyplot backend.\n\n    Switching to an interactive backend is possible only if no event loop for\n    another interactive backend has started.  Switching to and from\n    non-interactive backends is always possible.\n\n    If the new backend is different than the current backend then all open\n    Figures will be closed via ``plt.close('all')``.\n\n    Parameters\n    ----------\n    newbackend : str\n        The case-insensitive name of the backend to use.\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n\n        if (current_framework and\n                (backend := backend_registry.backend_for_gui_framework(\n                    current_framework))):\n            candidates = [backend]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n    old_backend = rcParams._get('backend')  "}], "retrieved_count": 10, "cost_time": 1.4063482284545898}
{"question": "Why does Matplotlib implement an Artist hierarchy for flexible plotting components?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements an Artist hierarchy for flexible plotting components to provide a structured and extensible architecture for managing complex visualizations. The hierarchy serves several key purposes: 1) It provides a natural parent-child relationship where Figure contains Axes, which contain individual Artists, enabling logical organization and efficient rendering through the hierarchy, 2) The hierarchy supports different types of Artists - primitives (Line2D, Rectangle, Text) that represent actual visual elements and containers (Figure, Axes, Axis) that organize and manage other Artists, 3) It enables efficient rendering by allowing parent containers to manage their children and coordinate drawing operations, 4) The hierarchy supports automatic layout and positioning where parent containers can arrange their child Artists according to layout algorithms, 5) It provides a consistent API where all Artists share common properties and methods through inheritance from the base Artist class, 6) The hierarchy enables advanced features like coordinate transformations, clipping, and event handling that can be applied at different levels, 7) It supports flexible composition where complex plots can be built by combining simple Artists in a hierarchical structure. This design enables Matplotlib to support both simple plots and complex, multi-layered visualizations while maintaining a clean and extensible architecture.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ist, invalid_types))\n            )\n\n        def __repr__(self):\n            return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n\n        def __len__(self):\n            return sum(self._type_check(artist)\n                       for artist in self._axes._children)\n\n        def __iter__(self):\n            for artist in list(self._axes._children):\n                if self._type_check(artist):\n                    yield artist\n\n        def __getitem__(self, key):\n            return [artist\n                    for artist in self._axes._children\n                    if self._type_check(artist)][key]\n\n        def __add__(self, other):\n            if isinstance(other, (list, _AxesBase.ArtistList)):\n                return [*self, *other]\n            if isinstance(other, (tuple, _AxesBase.ArtistList)):\n                return (*self, *other)\n            return NotImplemented\n\n        def __radd__(self, other):\n            if isinstance(other, list):\n                return other + list(self)\n            if isinstance(other, tuple):\n                return other + tuple(self)\n            return NotImplemented\n\n    @property\n    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n\n    @property\n    def collections(self):\n        return self.ArtistList(self, 'collections',\n                               valid_types=mcoll.Collection)\n\n    @property\n    def images(self):\n        return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n\n    @property\n    def lines(self):\n        return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n\n    @property\n    def patches(self):\n        return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n\n    @property\n    def tables(self):\n        return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n\n    @property\n    def texts(self):\n        return self.Arti"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gure=fig)\nl2 = lines.Line2D([0, 1], [1, 0], transform=fig.transFigure, figure=fig)\nfig.lines.extend([l1, l2])\n\nplt.show()\n\n# %%\n# Here is a summary of the Artists the Figure contains\n#\n# ================ ============================================================\n# Figure attribute Description\n# ================ ============================================================\n# axes             A list of `~.axes.Axes` instances\n# patch            The `.Rectangle` background\n# images           A list of `.FigureImage` patches -\n#                  useful for raw pixel display\n# legends          A list of Figure `.Legend` instances\n#                  (different from ``Axes.get_legend()``)\n# lines            A list of Figure `.Line2D` instances\n#                  (rarely used, see ``Axes.lines``)\n# patches          A list of Figure `.Patch`\\s\n#                  (rarely used, see ``Axes.patches``)\n# texts            A list Figure `.Text` instances\n# ================ ============================================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of v"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}], "retrieved_count": 10, "cost_time": 1.4169504642486572}
{"question": "Why does Matplotlib's Artist hierarchy affect memory usage and rendering speed?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist hierarchy affects memory usage and rendering speed through several key mechanisms in its design. The hierarchical structure impacts performance in several ways: 1) Memory usage scales with the number of Artist objects - each Figure, Axes, and individual Artist (lines, text, patches) consumes memory for storing properties, transforms, and data, with complex plots containing hundreds or thousands of Artist objects, 2) The parent-child relationships in the hierarchy enable efficient rendering by allowing parent containers to manage their children and coordinate drawing operations, reducing redundant calculations, 3) The hierarchy supports optimization features like line segment simplification (path.simplify) and marker subsampling (markevery) that can significantly reduce rendering time for large datasets, 4) Memory allocation patterns are affected by the hierarchy - raster backends like Agg require large pixel buffers proportional to image size and DPI, while the Artist hierarchy determines how these buffers are managed, 5) The hierarchy enables efficient clipping and coordinate transformations by applying them at appropriate levels (Figure, Axes, or individual Artist), avoiding unnecessary calculations, 6) Rendering speed is impacted by the traversal order of the hierarchy - Artists are drawn in z-order, and the hierarchy determines the efficiency of this traversal, 7) The hierarchy supports features like chunking (agg.path.chunksize) that can split large lines into smaller pieces, improving memory usage and rendering performance for complex plots. These effects make the Artist hierarchy a critical factor in both memory efficiency and rendering performance.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 126000, "end_line": 128000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stal"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ist, invalid_types))\n            )\n\n        def __repr__(self):\n            return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n\n        def __len__(self):\n            return sum(self._type_check(artist)\n                       for artist in self._axes._children)\n\n        def __iter__(self):\n            for artist in list(self._axes._children):\n                if self._type_check(artist):\n                    yield artist\n\n        def __getitem__(self, key):\n            return [artist\n                    for artist in self._axes._children\n                    if self._type_check(artist)][key]\n\n        def __add__(self, other):\n            if isinstance(other, (list, _AxesBase.ArtistList)):\n                return [*self, *other]\n            if isinstance(other, (tuple, _AxesBase.ArtistList)):\n                return (*self, *other)\n            return NotImplemented\n\n        def __radd__(self, other):\n            if isinstance(other, list):\n                return other + list(self)\n            if isinstance(other, tuple):\n                return other + tuple(self)\n            return NotImplemented\n\n    @property\n    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n\n    @property\n    def collections(self):\n        return self.ArtistList(self, 'collections',\n                               valid_types=mcoll.Collection)\n\n    @property\n    def images(self):\n        return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n\n    @property\n    def lines(self):\n        return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n\n    @property\n    def patches(self):\n        return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n\n    @property\n    def tables(self):\n        return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n\n    @property\n    def texts(self):\n        return self.Arti"}, {"start_line": 127000, "end_line": 129000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stale = False\n\n    def draw_artist(self, a):\n        \"\"\"\n        Efficiently redraw a single artist.\n        \"\"\"\n        a.draw(self.get_figure(root=True).canvas.get_renderer())\n\n    def redraw_in_frame(self):\n        \"\"\"\n        Efficiently redraw Axes data, but not axis ticks, labels, etc.\n        \"\"\"\n        with ExitStack() as stack:\n            for artist in [*self._axis_map.values(),\n                           self.title, self._left_title, self._right_title]:\n                stack.enter_context(artist._cm_set(visible=False))\n            self.draw(self.get_figure(root=True).canvas.get_renderer())\n\n    # Axes rectangle characteristics\n\n    def get_frame_on(self):\n        \"\"\"Get whether the Axes rectangle patch is drawn.\"\"\"\n        return self._frameon\n\n    def set_frame_on(self, b):\n        \"\"\"\n        Set whether the Axes rectangle patch is drawn.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._frameon = b\n        self.stale = True\n\n    def get_axisbe"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-----\n        get_cursor_data\n        .ToolCursorPosition\n        .NavigationToolbar2\n        \"\"\"\n        self._mouseover = bool(mouseover)\n        ax = self.axes\n        if ax:\n            if self._mouseover:\n                ax._mouseover_set.add(self)\n            else:\n                ax._mouseover_set.discard(self)\n\n    mouseover = property(get_mouseover, set_mouseover)  # backcompat.\n\n\ndef _get_tightbbox_for_layout_only(obj, *args, **kwargs):\n    \"\"\"\n    Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a\n    *for_layout_only* kwarg; this helper tries to use the kwarg but skips it\n    when encountering third-party subclasses that do not support it.\n    \"\"\"\n    try:\n        return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n    except TypeError:\n        return obj.get_tightbbox(*args, **kwargs)\n\n\nclass ArtistInspector:\n    \"\"\"\n    A helper class to inspect an `~matplotlib.artist.Artist` and return\n    information about its settable properties and their current values.\n    \"\"\"\n\n    def __init__(self, o):\n        r\"\"\"\n        Initialize the artist inspector with an `Artist` or an iterable of\n        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n        sequence (all `Artist`\\s are of the same type) and it is your\n        responsibility to make sure this is so.\n        \"\"\"\n        if not isinstance(o, Artist):\n            if np.iterable(o):\n                o = list(o)\n                if len(o):\n                    o = o[0]\n\n        self.oorig = o\n        if not isinstance(o, type):\n            o = type(o)\n        self.o = o\n\n        self.aliasd = self.get_aliases()\n\n    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(s"}], "retrieved_count": 10, "cost_time": 1.4072158336639404}
{"question": "Why does Matplotlib's event system influence interactive plotting responsiveness?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event system influences interactive plotting responsiveness through several key mechanisms that determine how quickly and efficiently user interactions are processed. The event system's impact on responsiveness stems from several factors: 1) Event loop integration - the system must coordinate between GUI toolkit events (Qt, Tk, GTK, Wx, macOS) and Matplotlib's internal event processing, with proper integration ensuring responsive figures while maintaining compatibility with different GUI frameworks, 2) Event processing frequency - methods like FigureCanvasBase.flush_events() process pending UI events, and the frequency of these calls directly affects responsiveness (20-30ms intervals feel responsive while 100ms intervals feel laggy), 3) Event coordinate conversion - the system converts low-level GUI events into Matplotlib-specific events with both pixel coordinates and data coordinates, which requires computational overhead but enables precise interaction, 4) Callback execution - event callbacks must execute quickly to maintain responsiveness, with complex callbacks potentially blocking the event loop and reducing interactivity, 5) Drawing coordination - the event system coordinates with drawing operations through methods like draw_idle() which schedules rendering without blocking the event loop, 6) Stale artist management - the system tracks which artists have changed (stale state) and only redraws when necessary, avoiding unnecessary rendering that could impact responsiveness, 7) Threading considerations - since GUI frameworks require updates on the main thread, the event system must handle thread coordination properly to maintain responsiveness while allowing background computations. These factors make the event system a critical component in determining the overall responsiveness of interactive matplotlib plots.", "score": null, "retrieved_content": [{"start_line": 109000, "end_line": 111000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me = (\n            time.time(), getattr(self, \"_draw_time\", -np.inf))\n        if self._draw_time - last_draw_time > 1:\n            try:\n                self.canvas.set_cursor(tools.Cursors.WAIT)\n                yield\n            finally:\n                self.canvas.set_cursor(self._last_cursor)\n        else:\n            yield\n\n    @staticmethod\n    def _mouse_event_to_message(event):\n        if event.inaxes and event.inaxes.get_navigate():\n            try:\n                s = event.inaxes.format_coord(event.xdata, event.ydata)\n            except (ValueError, OverflowError):\n                pass\n            else:\n                s = s.rstrip()\n                artists = [a for a in event.inaxes._mouseover_set\n                           if a.contains(event)[0] and a.get_visible()]\n                if artists:\n                    a = cbook._topmost_artist(artists)\n                    if a is not event.inaxes.patch:\n                        data = a.get_cursor_data(event)\n                        if data is not None:\n                            data_str = a.format_cursor_data(data).rstrip()\n                            if data_str:\n                                s = s + '\\n' + data_str\n                return s\n        return \"\"\n\n    def mouse_move(self, event):\n        self._update_cursor(event)\n        self.set_message(self._mouse_event_to_message(event))\n\n    def _zoom_pan_handler(self, event):\n        if self.mode == _Mode.PAN:\n            if event.name == \"button_press_event\":\n                self.press_pan(event)\n            elif event.name == \"button_release_event\":\n                self.release_pan(event)\n        if self.mode == _Mode.ZOOM:\n            if event.name == \"button_press_event\":\n                self.press_zoom(event)\n            elif event.name == \"button_release_event\":\n                self.release_zoom(event)\n\n    def _start_event_axes_interaction(self, event, *, method):\n\n        def _ax_filter(ax):\n            return (ax.in_axes(event) and\n            "}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "test_backends_interactive.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "est.mark.parametrize(\"env\", _blit_backends)\n# subprocesses can struggle to get the display, so rerun a few times\n@pytest.mark.flaky(reruns=_retry_count)\ndef test_blitting_events(env):\n    proc = _run_helper(\n        _test_number_of_draws_script, timeout=_test_timeout, extra_env=env)\n    # Count the number of draw_events we got. We could count some initial\n    # canvas draws (which vary in number by backend), but the critical\n    # check here is that it isn't 10 draws, which would be called if\n    # blitting is not properly implemented\n    ndraws = proc.stdout.count(\"DrawEvent\")\n    assert 0 < ndraws < 5\n\n\ndef _fallback_check():\n    import IPython.core.interactiveshell as ipsh\n    import matplotlib.pyplot\n    ipsh.InteractiveShell.instance()\n    matplotlib.pyplot.figure()\n\n\ndef test_fallback_to_different_backend():\n    pytest.importorskip(\"IPython\")\n    # Runs the process that caused the GH issue 23770\n    # making sure that this doesn't crash\n    # since we're supposed to be switching to a different backend instead.\n    response = _run_helper(_fallback_check, timeout=_test_timeout)\n\n\ndef _impl_test_interactive_timers():\n    # A timer with <1 millisecond gets converted to int and therefore 0\n    # milliseconds, which the mac framework interprets as singleshot.\n    # We only want singleshot if we specify that ourselves, otherwise we want\n    # a repeating timer\n    from unittest.mock import Mock\n    import matplotlib.pyplot as plt\n    pause_time = 0.5\n    fig = plt.figure()\n    plt.pause(pause_time)\n    timer = fig.canvas.new_timer(0.1)\n    mock = Mock()\n    timer.add_callback(mock)\n    timer.start()\n    plt.pause(pause_time)\n    timer.stop()\n    assert mock.call_count > 1\n\n    # Now turn it into a single shot timer and verify only one gets triggered\n    mock.call_count = 0\n    timer.single_shot = True\n    timer.start()\n    plt.pause(pause_time)\n    assert mock.call_count == 1\n\n    # Make sure we can start the timer a second time\n    timer.start()\n    plt.pause(pause_"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _mpl_buttons(self, controller):\n        # NOTE: This spews \"Broken accounting of active state\" warnings on\n        # right click on macOS.\n        surface = self.get_native().get_surface()\n        is_over, x, y, event_state = surface.get_device_position(\n            self.get_display().get_default_seat().get_pointer())\n        # NOTE: alternatively we could use\n        #   event_state = controller.get_current_event_state()\n        # but for button_press/button_release this would report the state\n        # *prior* to the event rather than after it; the above reports the\n        # state *after* it.\n        mod_table = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, G"}, {"start_line": 87000, "end_line": 89000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)\n\n    def flush_events(self):\n        \"\"\"\n        Flush the GUI events for the figure.\n\n        Interactive backends need to reimplement this method.\n        \"\"\"\n\n    def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start a blocking event loop.\n\n        Such an event loop is used by interactive functions, such as\n        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n        events.\n\n        The event loop blocks until a callback function triggers\n        `stop_event_loop`, or *timeout* is reached.\n\n        If *timeout* is 0 or negative, never timeout.\n\n        Only interactive backends need to reimplement this method and it relies\n        on `flush_events` being properly implemented.\n\n        Interactive backends should implement this in a more native way.\n        \"\"\"\n        if timeout <= 0:\n            timeout = np.inf\n        timestep = 0.01\n        counter = 0\n        self._looping = True\n        while self._looping and counter * timestep < timeout:\n            self.flush_events()\n            time.sleep(timestep)\n            counter += 1\n\n    def stop_event_loop(self):\n        \"\"\"\n        Stop the current blocking event loop.\n\n        Interactive backends need to reimplement this to match\n        `start_event_loop`\n        \"\"\"\n        self._looping = False\n\n\ndef key_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    Implement the default Matplotlib key bindings for the canvas and toolbar\n    described at :ref:`key-event-handling`.\n\n    Parameters\n    ----------\n    event : `KeyEvent`\n        A key press/release event.\n    canvas : `FigureCanvasBase`, default: ``event.canvas``\n        The backend-specific canvas instance.  This parameter is kept for\n        back-compatibility, but, if set, should always be equal to\n        ``event.canvas``.\n    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n        The navi"}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              (\"button_release_event\", self.on_release),\n                (\"motion_notify_event\", self.on_motion),\n            ]\n        ]\n\n    @staticmethod\n    def _picker(artist, mouseevent):\n        # A custom picker to prevent dragging on mouse scroll events\n        if mouseevent.name == \"scroll_event\":\n            return False, {}\n        return artist.contains(mouseevent)\n\n    # A property, not an attribute, to maintain picklability.\n    canvas = property(lambda self: self.ref_artist.get_figure(root=True).canvas)\n    cids = property(lambda self: [\n        disconnect.args[0] for disconnect in self._disconnectors[:2]])\n\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.get_figure(root=True)._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented():\n            if evt.artist == self.ref_artist:\n                self.mouse_x = evt.mouseevent.x\n                self.mouse_y = evt.mouseevent.y\n                self.save_offset()\n                self.got_artist = True\n            if self.got_artist and self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                fig = self.ref_artist.get_figure(root=False)\n                self.background = self.canvas.copy_from_bbox(fig.bbox)\n                self.ref_artist.draw(fig._get_renderer())\n                self.canvas.blit()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist:\n            self.finalize_offset()\n            self.got_artist = False\n            if self._use_blit:\n                self.canv"}, {"start_line": 110000, "end_line": 112000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    if data is not None:\n                            data_str = a.format_cursor_data(data).rstrip()\n                            if data_str:\n                                s = s + '\\n' + data_str\n                return s\n        return \"\"\n\n    def mouse_move(self, event):\n        self._update_cursor(event)\n        self.set_message(self._mouse_event_to_message(event))\n\n    def _zoom_pan_handler(self, event):\n        if self.mode == _Mode.PAN:\n            if event.name == \"button_press_event\":\n                self.press_pan(event)\n            elif event.name == \"button_release_event\":\n                self.release_pan(event)\n        if self.mode == _Mode.ZOOM:\n            if event.name == \"button_press_event\":\n                self.press_zoom(event)\n            elif event.name == \"button_release_event\":\n                self.release_zoom(event)\n\n    def _start_event_axes_interaction(self, event, *, method):\n\n        def _ax_filter(ax):\n            return (ax.in_axes(event) and\n                    ax.get_navigate() and\n                    getattr(ax, f\"can_{method}\")()\n                    )\n\n        def _capture_events(ax):\n            f = ax.get_forward_navigation_events()\n            if f == \"auto\":  # (capture = patch visibility)\n                f = not ax.patch.get_visible()\n            return not f\n\n        # get all relevant axes for the event\n        axes = list(filter(_ax_filter, self.canvas.figure.get_axes()))\n\n        if len(axes) == 0:\n            return []\n\n        if self._nav_stack() is None:\n            self.push_current()   # Set the home button to this view.\n\n        # group axes by zorder (reverse to trigger later axes first)\n        grps = dict()\n        for ax in reversed(axes):\n            grps.setdefault(ax.get_zorder(), []).append(ax)\n\n        axes_to_trigger = []\n        # go through zorders in reverse until we hit a capturing axes\n        for zorder in sorted(grps, reverse=True):\n            for ax in grps[zorder]:\n                axes_to_trigger"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       modifiers=self._mpl_modifiers(mods),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        if self.figure is None:\n            return\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      modifiers=self._mpl_modifiers(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        if self.manager:\n            self.send_event('figure_label', label=self.manager.get_window_title())\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "This is necessary because the callback registry\n    maintains only weak-refs to the functions, which are member\n    functions of the widget.  If there are no references to the widget\n    object it may be garbage collected which will disconnect the callbacks.\n\n    Attributes\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The parent Axes for the widget.\n    canvas : `~matplotlib.backend_bases.FigureCanvasBase`\n        The parent figure canvas for the widget.\n    active : bool\n        If False, the widget does not respond to events.\n    \"\"\"\n\n    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n\n    canvas = property(\n        lambda self: getattr(self.ax.get_figure(root=True), 'canvas', None)\n    )\n\n    def connect_event(self, event, callback):\n        \"\"\"\n        Connect a callback function with an event.\n\n        This should be used in lieu of ``figure.canvas.mpl_connect`` since this\n        function stores callback ids for later clean up.\n        \"\"\"\n        cid = self.canvas.mpl_connect(event, callback)\n        self._cids.append(cid)\n\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n\n    def _get_data_coords(self, event):\n        \"\"\"Return *event*'s data coordinates in this widget's Axes.\"\"\"\n        # This method handles the possibility that event.inaxes != self.ax (which may\n        # occur if multiple Axes are overlaid), in which case event.xdata/.ydata will\n        # be wrong.  Note that we still special-case the common case where\n        # event.inaxes == self.ax and avoid re-running the inverse data transform,\n        # because that can introduce floating point errors for synthetic events.\n        return ((event.xdata, event.ydata) if event.inaxes is self.ax\n                else self.ax.transData.inverted().transform((event.x, event.y)))\n\n    def ignore(self, event):\n        # docstring inherited\n        return super()."}], "retrieved_count": 10, "cost_time": 1.4070532321929932}
{"question": "What dependencies exist between Matplotlib's Artist system and the backend rendering pipeline?", "answer": null, "relative_code_list": null, "ground_truth": "The Artist system and backend rendering pipeline have several key dependencies: 1) The Artist class defines a draw() method that takes a renderer parameter, creating a direct dependency where Artists must work with backend-specific renderers to produce output, 2) Artists depend on the backend's coordinate transformation system to convert between data coordinates and display coordinates, 3) The backend provides the rendering context (canvas, graphics context) that Artists use to draw themselves, 4) Artists rely on backend-specific features like rasterization support, alpha blending, and clipping capabilities, 5) The backend determines what rendering operations are available (vector vs raster, file formats supported), which constrains what Artists can do, 6) Artists use backend-provided transforms and bounding boxes for layout and positioning, 7) The backend's event handling system integrates with Artists for interactive features like picking and mouse events. This dependency structure allows the same Artist objects to work across different backends while leveraging backend-specific optimizations and capabilities.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(f\"{_nums_to_str(*rect.p0, *rect.size)} rectclip\\n\")\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataS"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " also :doc:`/gallery/misc/rasterization_demo`.\n\n        Parameters\n        ----------\n        rasterized : bool\n        \"\"\"\n        supports_rasterization = getattr(self.draw,\n                                         \"_supports_rasterization\", False)\n        if rasterized and not supports_rasterization:\n            _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n\n        self._rasterized = rasterized\n\n    def get_agg_filter(self):\n        \"\"\"Return filter function to be used for agg filter.\"\"\"\n        return self._agg_filter\n\n    def set_agg_filter(self, filter_func):\n        \"\"\"\n        Set the agg filter.\n\n        Parameters\n        ----------\n        filter_func : callable\n            A filter function, which takes a (m, n, depth) float array\n            and a dpi value, and returns a (m, n, depth) array and two\n            offsets from the bottom left corner of the image\n\n            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n                and a dpi value, and returns a (m, n, 3) array and two offsets\n                from the bottom left corner of the image\n        \"\"\"\n        self._agg_filter = filter_func\n        self.stale = True\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `~matplotlib.backend_bases.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : float or None\n            *alpha* must be within the 0-1 range, inclusive.\n        \"\"\"\n        if alpha is not None "}, {"start_line": 17000, "end_line": 18573, "belongs_to": {"file_name": "test_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     ...\n\n    assert 'draw' not in Gen2.__dict__\n    assert Gen2.draw is Gen1.draw\n\n\ndef test_draw_wraper_forward_input():\n    class TestKlass(martist.Artist):\n        def draw(self, renderer, extra):\n            return extra\n\n    art = TestKlass()\n    renderer = mbackend_bases.RendererBase()\n\n    assert 'aardvark' == art.draw(renderer, 'aardvark')\n    assert 'aardvark' == art.draw(renderer, extra='aardvark')\n\n\ndef test_get_figure():\n    fig = plt.figure()\n    sfig1 = fig.subfigures()\n    sfig2 = sfig1.subfigures()\n    ax = sfig2.subplots()\n\n    assert fig.get_figure(root=True) is fig\n    assert fig.get_figure(root=False) is fig\n\n    assert ax.get_figure() is sfig2\n    assert ax.get_figure(root=False) is sfig2\n    assert ax.get_figure(root=True) is fig\n\n    # SubFigure.get_figure has separate implementation but should give consistent\n    # results to other artists.\n    assert sfig2.get_figure(root=False) is sfig1\n    assert sfig2.get_figure(root=True) is fig\n    # Currently different results by default.\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        assert sfig2.get_figure() is fig\n    # No deprecation warning if root and parent figure are the same.\n    assert sfig1.get_figure() is fig\n\n    # An artist not yet attached to anything has no figure.\n    ln = mlines.Line2D([], [])\n    assert ln.get_figure(root=True) is None\n    assert ln.get_figure(root=False) is None\n\n    # figure attribute is root for (Sub)Figures but parent for other artists.\n    assert ax.figure is sfig2\n    assert fig.figure is fig\n    assert sfig2.figure is fig\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "kref-gc'ed.\n        return self._callbacks.connect(\"pchanged\", lambda: func(self))\n\n    def remove_callback(self, oid):\n        \"\"\"\n        Remove a callback based on its observer id.\n\n        See Also\n        --------\n        add_callback\n        \"\"\"\n        self._callbacks.disconnect(oid)\n\n    def pchanged(self):\n        \"\"\"\n        Call all of the registered callbacks.\n\n        This function is triggered internally when a property is changed.\n\n        See Also\n        --------\n        add_callback\n        remove_callback\n        \"\"\"\n        self._callbacks.process(\"pchanged\")\n\n    def is_transform_set(self):\n        \"\"\"\n        Return whether the Artist has an explicitly set transform.\n\n        This is *True* after `.set_transform` has been called.\n        \"\"\"\n        return self._transformSet\n\n    def set_transform(self, t):\n        \"\"\"\n        Set the artist transform.\n\n        Parameters\n        ----------\n        t : `~matplotlib.transforms.Transform`\n        \"\"\"\n        self._transform = t\n        self._transformSet = True\n        self.pchanged()\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n        if self._transform is None:\n            self._transform = IdentityTransform()\n        elif (not isinstance(self._transform, Transform)\n              and hasattr(self._transform, '_as_mpl_transform')):\n            self._transform = self._transform._as_mpl_transform(self.axes)\n        return self._transform\n\n    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n        return []\n\n    def _different_canvas(self, event):\n        \"\"\"\n        Check whether an *event* occurred on a canvas other that this artist's canvas.\n\n        If this method returns True, the event definitely occurred on a different\n        canvas; if it returns False, either it occurred on the same canvas, or we may\n        not have enough information to know.\n\n        Subclas"}], "retrieved_count": 10, "cost_time": 1.4429786205291748}
{"question": "Where does the data flow when Matplotlib processes plotting commands through the pyplot interface?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib processes plotting commands through the pyplot interface, the data flows through a state-based system that manages global references to the current Figure and Axes. The data flow follows this sequence: 1) The pyplot module maintains global state variables that track the current Figure and Axes objects, accessible through gcf() and gca() functions, 2) When a pyplot function like plt.plot() is called, it first checks if there's a current Figure and Axes, creating them if necessary using the global state, 3) The pyplot function then delegates the actual plotting operation to the corresponding method on the current Axes object - for example, plt.plot() calls ax.plot() on the current Axes, 4) The data (coordinates, colors, styles) flows from the pyplot function parameters to the Axes method, which creates the appropriate Artist objects (Line2D, Text, etc.), 5) The Artist objects are added to the Axes, which maintains lists of its child Artists, 6) The pyplot interface also manages Figure creation through functions like plt.figure(), plt.subplots(), and plt.subplot(), which update the global state, 7) For complex plots with multiple subplots, pyplot functions like plt.subplot() switch the current Axes in the global state, directing subsequent plotting commands to the appropriate subplot, 8) The data flow is essentially a wrapper around the object-oriented API - pyplot functions are convenience wrappers that manage the global state and delegate to the underlying Figure and Axes objects. This design allows users to write simple plotting code without explicitly managing Figure and Axes references, while still providing access to the full power of the object-oriented API when needed.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n  "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/pyplot\n\n.. _pyplot_tutorial:\n\n===============\nPyplot tutorial\n===============\n\nAn introduction to the pyplot interface.  Please also see\n:ref:`quick_start` for an overview of how Matplotlib\nworks and :ref:`api_interfaces` for an explanation of the trade-offs between the\nsupported user APIs.\n\n\"\"\"\n\n# %%\n# Introduction to pyplot\n# ======================\n#\n# :mod:`matplotlib.pyplot` is a collection of functions that make matplotlib\n# work like MATLAB.  Each ``pyplot`` function makes some change to a figure:\n# e.g., creates a figure, creates a plotting area in a figure, plots some lines\n# in a plotting area, decorates the plot with labels, etc.\n#\n# In :mod:`matplotlib.pyplot` various states are preserved\n# across function calls, so that it keeps track of things like\n# the current figure and plotting area, and the plotting\n# functions are directed to the current Axes (please note that we use uppercase\n# Axes to refer to the `~.axes.Axes` concept, which is a central\n# :ref:`part of a figure <figure_parts>`\n# and not only the plural of *axis*).\n#\n# .. note::\n#\n#    The implicit pyplot API is generally less verbose but also not as flexible as the\n#    explicit API.  Most of the function calls you see here can also be called\n#    as methods from an ``Axes`` object. We recommend browsing the tutorials\n#    and examples to see how this works. See :ref:`api_interfaces` for an\n#    explanation of the trade-off of the supported user APIs.\n#\n# Generating visualizations with pyplot is very quick:\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n# You may be wondering why the x-axis ranges from 0-3 and the y-axis\n# from 1-4.  If you provide a single list or array to\n# `~.pyplot.plot`, matplotlib assumes it is a\n# sequence of y values, and automatically generates the x values for\n# you.  Since python ranges start with 0, the default x vector has the\n# same length as y but starts with 0; "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`\n# objects, etc. When the Figure is rendered, all of the\n# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such\n# an Artist cannot be shared by multiple Axes, or moved from one to another.\n#\n# .. _input_types:\n#\n# Types of inputs to plotting functions\n# =====================================\n#\n# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as\n# input, or objects that can be passed to `numpy.asarray`.\n# Classes that are similar to arrays ('array-like') such as `pandas`\n# data objects and `numpy.matrix` may not work as intended.  Common convention\n# is to convert these to `numpy.array` objects prior to plotting.\n# For example, to convert a `numpy.matrix` ::\n#\n#   b = np.matrix([[1, 2], [3, 4]])\n#   b_asarray = np.asarray(b)\n#\n# Most methods will also parse a string-indexable object like a *dict*, a\n# `structured numpy array`_, or a `pandas.DataFrame`.  Matplotlib allows you\n# to provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/lifecycle\n\n=======================\nThe Lifecycle of a Plot\n=======================\n\nThis tutorial aims to show the beginning, middle, and end of a single\nvisualization using Matplotlib. We'll begin with some raw data and\nend by saving a figure of a customized visualization. Along the way we try\nto highlight some neat features and best-practices using Matplotlib.\n\n.. currentmodule:: matplotlib\n\n.. note::\n\n    This tutorial is based on\n    `this excellent blog post\n    <https://pbpython.com/effective-matplotlib.html>`_\n    by Chris Moffitt. It was transformed into this tutorial by Chris Holdgraf.\n\nA note on the explicit vs. implicit interfaces\n==============================================\n\nMatplotlib has two interfaces. For an explanation of the trade-offs between the\nexplicit and implicit interfaces see :ref:`api_interfaces`.\n\nIn the explicit object-oriented (OO) interface we directly utilize instances of\n:class:`axes.Axes` to build up the visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales informat"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in params) + ')'\n    return_statement = 'return ' if has_return_value else ''\n    # Bail out in case of name collision.\n    for reserved in ('gca', 'gci', 'gcf', '__ret'):\n        if reserved in params:\n            raise ValueError(\n                f'Method {called_fullname} has kwarg named {reserved}')\n\n    return template.format(\n        name=name,\n        called_name=called_name,\n        signature=signature,\n        call=call,\n        return_statement=return_statement,\n        **kwargs)\n\n\ndef boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n        'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n        'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        templa"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " function.\n    call = '(' + ', '.join((\n           # Pass \"intended-as-positional\" parameters positionally to avoid\n           # forcing third-party subclasses to reproduce the parameter names.\n           '{0}'\n           if param.kind in [\n               Parameter.POSITIONAL_OR_KEYWORD]\n              and param.default is Parameter.empty else\n           # Only pass the data kwarg if it is actually set, to avoid forcing\n           # third-party subclasses to support it.\n           '**({{\"data\": data}} if data is not None else {{}})'\n           if param.name == \"data\" else\n           '{0}={0}'\n           if param.kind in [\n               Parameter.POSITIONAL_OR_KEYWORD,\n               Parameter.KEYWORD_ONLY] else\n           '{0}'\n           if param.kind is Parameter.POSITIONAL_ONLY else\n           '*{0}'\n           if param.kind is Parameter.VAR_POSITIONAL else\n           '**{0}'\n           if param.kind is Parameter.VAR_KEYWORD else\n           None).format(param.name)\n       for param in params) + ')'\n    return_statement = 'return ' if has_return_value else ''\n    # Bail out in case of name collision.\n    for reserved in ('gca', 'gci', 'gcf', '__ret'):\n        if reserved in params:\n            raise ValueError(\n                f'Method {called_fullname} has kwarg named {reserved}')\n\n    return template.format(\n        name=name,\n        called_name=called_name,\n        signature=signature,\n        call=call,\n        return_statement=return_statement,\n        **kwargs)\n\n\ndef boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n     "}], "retrieved_count": 10, "cost_time": 1.4085817337036133}
{"question": "What is the relationship between Matplotlib's Figure class and Axes class in the plotting hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "The Figure class and Axes class have a parent-child relationship in Matplotlib's plotting hierarchy. The Figure serves as the top-level container that holds all plot elements, while Axes objects are the primary plotting areas within a Figure. A Figure can contain multiple Axes objects, and each Axes represents a single plotting region with its own coordinate system. The Figure manages the overall layout, size, and background, while Axes handle the actual data visualization, coordinate transformations, and individual plot elements. The Figure provides methods like add_axes(), subplots(), and add_subplot() to create and manage Axes objects. Each Axes is tied to its parent Figure through the figure attribute, and the Figure maintains lists of its child Axes through the axes property. This hierarchical structure allows for complex layouts with multiple subplots while maintaining clear separation of concerns between figure-level and axes-level functionality.", "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via\n# :meth:`~matplotlib.axes.Axes.set_xlabel`), and a y-label set via\n# :meth:`~matplotlib.axes.Axes.set_ylabel`).\n#\n# The `~.axes.Axes` methods are the primary interface for configuring\n# most parts of your plot (adding data, controlling axis scales and\n# limits, adding labels etc.).\n#\n# :class:`~matplotlib.axis.Axis`\n# ------------------------------\n#\n# These objects set the scale and limits and generate ticks (the marks\n# on the Axis) and ticklabels (strings labeling the ticks).  The location\n# of the ticks is determined by a `~matplotlib.ticker.Locator` object and the\n# ticklabel strings are formatted by a `~matplotlib.ticker.Formatter`.  The\n# combination of the correct `.Locator` and `.Formatter` gives very fine\n# control over the tick locations and labels.\n#\n# :class:`~matplotlib.artist.Artist`\n# ----------------------------------\n#\n# Basically, everything visible on the Figure is an Artist (even\n# `.Figure`, `Axes <.axes.Axes>`, and `~.axis.Axis` objects).  This includes\n# `.Text"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.image.AxesImage`, respectively).  These helper methods\nwill take your data (e.g., ``numpy`` arrays and strings) and create\nprimitive ``Artist`` instances as needed (e.g., ``Line2D``), add them to\nthe relevant containers, and draw them when requested.  If you want to create\nan ``Axes`` at an arbitrary location, simply use the\n:meth:`~matplotlib.figure.Figure.add_axes` method which takes a list\nof ``[left, bottom, width, height]`` values in 0-1 relative figure\ncoordinates::\n\n    fig2 = plt.figure()\n    ax2 = fig2.add_axes((0.15, 0.1, 0.7, 0.3))\n\nContinuing with our example::\n\n    import numpy as np\n    t = np.arange(0.0, 1.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    line, = ax.plot(t, s, color='blue', lw=2)\n\nIn this example, ``ax`` is the ``Axes`` instance created by the\n``fig.add_subplot`` call above and when you call ``ax.plot``, it creates a\n``Line2D`` instance and\nadds it to the ``Axes``.  In the interactive `IPython <https://ipython.org/>`_\nsession below, yo"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instances you want to customize.  Here is an\n# example which turns all the Axes grids on::\n#\n#     for ax in fig.axes:\n#         ax.grid(True)\n#\n#\n# The figure also has its own ``images``, ``lines``, ``patches`` and ``text``\n# attributes, which you can use to add primitives directly. When doing so, the\n# default coordinate system for the ``Figure`` will simply be in pixels (which\n# is not usually what you want). If you instead use Figure-level methods to add\n# Artists (e.g., using `.Figure.text` to add text), then the default coordinate\n# system will be \"figure coordinates\" where (0, 0) is the bottom-left of the\n# figure and (1, 1) is the top-right of the figure.\n#\n# As with all ``Artist``\\s, you can control this coordinate system by setting\n# the transform property. You can explicitly use \"figure coordinates\" by\n# setting the ``Artist`` transform to :attr:`!fig.transFigure`:\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\n\nl1 = lines.Line2D([0, 1], [0, 1], transform=fig.transFigure, fi"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a not in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of values, the\n# method will create a `matplotlib.lines.Line2D` instance, update the line with\n# all the ``Line2D`` properties passed as keyword arguments, add the line to\n# the ``Axes``, and return it to you:\n#\n# .. sourcecode:: ipython\n#\n#     In [213]: x, y = np.random.rand(2, 100)\n#\n#     In [214]: line, = ax.plot(x, y, '-', color='blue', linewidth=2)\n#\n# ``plot`` returns a list of lines because you can pass in multiple x, y\n# pairs to plot, and we are unpacking the first element of the length\n# one list into the line variable.  The line has been added to the\n# ``Axes.lines`` list:\n#\n# .. sourcecode:: ipython\n#\n#     In [229]: print(ax.lines)\n#     [<matplotlib.lines.Line2D at 0xd378b0c>]\n#\n# Similarly, methods that create patches, like\n# :meth:`~matplotlib.axes.Axes.bar` creates a list of rectangles, will\n# add the patches to the :attr:`!Axes.patches` list:\n#\n# .. sourcecode:: ipython\n#\n#     In [233]: n, bins, rectangles = ax.hist(np.random.randn(1000), 50)\n#\n#     In [234]: rectangl"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gure=fig)\nl2 = lines.Line2D([0, 1], [1, 0], transform=fig.transFigure, figure=fig)\nfig.lines.extend([l1, l2])\n\nplt.show()\n\n# %%\n# Here is a summary of the Artists the Figure contains\n#\n# ================ ============================================================\n# Figure attribute Description\n# ================ ============================================================\n# axes             A list of `~.axes.Axes` instances\n# patch            The `.Rectangle` background\n# images           A list of `.FigureImage` patches -\n#                  useful for raw pixel display\n# legends          A list of Figure `.Legend` instances\n#                  (different from ``Axes.get_legend()``)\n# lines            A list of Figure `.Line2D` instances\n#                  (rarely used, see ``Axes.lines``)\n# patches          A list of Figure `.Patch`\\s\n#                  (rarely used, see ``Axes.patches``)\n# texts            A list Figure `.Text` instances\n# ================ ============================================================\n#\n# .. _axes-container:\n#\n# Axes container\n# --------------\n#\n# The :class:`matplotlib.axes.Axes` is the center of the Matplotlib\n# universe -- it contains the vast majority of all the ``Artists`` used\n# in a figure with many helper methods to create and add these\n# ``Artists`` to itself, as well as helper methods to access and\n# customize the ``Artists`` it contains.  Like the\n# :class:`~matplotlib.figure.Figure`, it contains a\n# :class:`~matplotlib.patches.Patch`\n# :attr:`!matplotlib.axes.Axes.patch` which is a\n# :class:`~matplotlib.patches.Rectangle` for Cartesian coordinates and a\n# :class:`~matplotlib.patches.Circle` for polar coordinates; this patch\n# determines the shape, background and border of the plotting region::\n#\n#     ax = fig.add_subplot()\n#     rect = ax.patch  # a Rectangle instance\n#     rect.set_facecolor('green')\n#\n# When you call a plotting method, e.g., the canonical\n# `~matplotlib.axes.Axes.plot` and pass in arrays or lists of v"}], "retrieved_count": 10, "cost_time": 1.4642295837402344}
{"question": "Why does Matplotlib include an event system for interactive plotting capabilities?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib includes an event system for interactive plotting capabilities to enable responsive user interactions and enhance data exploration. The event system serves several key purposes: 1) It provides a GUI-neutral interface that works across different GUI toolkits (Qt, Tk, GTK, Wx, macOS) while maintaining consistent behavior, allowing the same interactive code to work regardless of the underlying GUI framework, 2) The system converts low-level GUI events (mouse clicks, key presses, mouse movements) into Matplotlib-specific events with data coordinates, enabling precise interaction with plot elements, 3) It supports built-in interactive features like panning, zooming, and data point selection that enhance data exploration capabilities, 4) The event system allows users to create custom interactive behaviors by connecting callback functions to specific events using FigureCanvasBase.mpl_connect(), enabling personalized data exploration tools, 5) It enables responsive figure updates during long-running computations by periodically processing events through flush_events(), maintaining interactivity even during intensive calculations, 6) The event-driven approach supports integration with command-line interfaces through input hook mechanisms, allowing both interactive plotting and command-line usage, 7) It provides a foundation for advanced interactive features like picking, selection, and custom data exploration tools. This design enables Matplotlib to support both static plotting and dynamic, interactive visualizations that respond to user input in real-time.", "score": null, "retrieved_content": [{"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "This is necessary because the callback registry\n    maintains only weak-refs to the functions, which are member\n    functions of the widget.  If there are no references to the widget\n    object it may be garbage collected which will disconnect the callbacks.\n\n    Attributes\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The parent Axes for the widget.\n    canvas : `~matplotlib.backend_bases.FigureCanvasBase`\n        The parent figure canvas for the widget.\n    active : bool\n        If False, the widget does not respond to events.\n    \"\"\"\n\n    def __init__(self, ax):\n        self.ax = ax\n        self._cids = []\n\n    canvas = property(\n        lambda self: getattr(self.ax.get_figure(root=True), 'canvas', None)\n    )\n\n    def connect_event(self, event, callback):\n        \"\"\"\n        Connect a callback function with an event.\n\n        This should be used in lieu of ``figure.canvas.mpl_connect`` since this\n        function stores callback ids for later clean up.\n        \"\"\"\n        cid = self.canvas.mpl_connect(event, callback)\n        self._cids.append(cid)\n\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n\n    def _get_data_coords(self, event):\n        \"\"\"Return *event*'s data coordinates in this widget's Axes.\"\"\"\n        # This method handles the possibility that event.inaxes != self.ax (which may\n        # occur if multiple Axes are overlaid), in which case event.xdata/.ydata will\n        # be wrong.  Note that we still special-case the common case where\n        # event.inaxes == self.ax and avoid re-running the inverse data transform,\n        # because that can introduce floating point errors for synthetic events.\n        return ((event.xdata, event.ydata) if event.inaxes is self.ax\n                else self.ax.transData.inverted().transform((event.x, event.y)))\n\n    def ignore(self, event):\n        # docstring inherited\n        return super()."}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al implementation uses a Tk canvas,  this routine\n        is intended to hide that fact.\n        \"\"\"\n        return self._tkcanvas\n\n    def _event_mpl_coords(self, event):\n        # calling canvasx/canvasy allows taking scrollbars into account (i.e.\n        # the top of the widget may have been scrolled out of view).\n        return (self._tkcanvas.canvasx(event.x),\n                # flipy so y=0 is bottom of canvas\n                self.figure.bbox.height - self._tkcanvas.canvasy(event.y))\n\n    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, event):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def button_press_event(self, event, dblclick=False):\n        # set focus to the canvas so that it can receive keyboard events\n        self._tkcanvas.focus_set()\n\n        num = getattr(event, 'num', None)\n        if sys.platform == 'darwin':  # 2 and 3 are reversed.\n            num = {2: 3, 3: 2}.get(num, num)\n        MouseEvent(\"button_press_event\", self,\n                   *self._event_mpl_coords(event), num, dblclick=dblclick,\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def button_dblclick_event(self, event):\n        self.button_press_event(event, dblclick=True)\n\n    def button_release_event(self, event):\n        num = "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)\n\n    def _mpl_coords(self, event=None):\n        \"\"\"\n        Convert the position of a GTK event, or of the current cursor position\n        if *event* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ial attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not over an Axes.\n    modifiers : frozenset\n        The keyboard modifiers currently being pressed (except for KeyEvent).\n    \"\"\"\n\n    _last_axes_ref = None\n\n    def __init__(self, name, canvas, x, y, guiEvent=None, *, modifiers=None):\n        super().__init__(name, canvas, guiEvent=guiEvent)\n        # x position - pixels from left of canvas\n        self.x = int(x) if x is not None else x\n        # y position - pixels from right of canvas\n        self.y = int(y) if y is not None else y\n        self.inaxes = None  # the Axes instance the mouse is over\n        self.xdata = None   # x coord of mouse in data coords\n        self.ydata = None   # y coord of mouse in data coords\n        self.modifiers = frozenset(modifiers if modifiers is not None else [])\n\n        if x is None or y is None:\n            # cannot check if event was in Axes if no (x, y) info\n            return\n\n        self._set_inaxes(self.canvas.inaxes((x, y))\n                         if self.canvas.mouse_grabber is None else\n    "}, {"start_line": 87000, "end_line": 89000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)\n\n    def flush_events(self):\n        \"\"\"\n        Flush the GUI events for the figure.\n\n        Interactive backends need to reimplement this method.\n        \"\"\"\n\n    def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start a blocking event loop.\n\n        Such an event loop is used by interactive functions, such as\n        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n        events.\n\n        The event loop blocks until a callback function triggers\n        `stop_event_loop`, or *timeout* is reached.\n\n        If *timeout* is 0 or negative, never timeout.\n\n        Only interactive backends need to reimplement this method and it relies\n        on `flush_events` being properly implemented.\n\n        Interactive backends should implement this in a more native way.\n        \"\"\"\n        if timeout <= 0:\n            timeout = np.inf\n        timestep = 0.01\n        counter = 0\n        self._looping = True\n        while self._looping and counter * timestep < timeout:\n            self.flush_events()\n            time.sleep(timestep)\n            counter += 1\n\n    def stop_event_loop(self):\n        \"\"\"\n        Stop the current blocking event loop.\n\n        Interactive backends need to reimplement this to match\n        `start_event_loop`\n        \"\"\"\n        self._looping = False\n\n\ndef key_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    Implement the default Matplotlib key bindings for the canvas and toolbar\n    described at :ref:`key-event-handling`.\n\n    Parameters\n    ----------\n    event : `KeyEvent`\n        A key press/release event.\n    canvas : `FigureCanvasBase`, default: ``event.canvas``\n        The backend-specific canvas instance.  This parameter is kept for\n        back-compatibility, but, if set, should always be equal to\n        ``event.canvas``.\n    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n        The navi"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     line = event.artist\n            xdata, ydata = line.get_data()\n            ind = event.ind\n            print(f'on pick line: {xdata[ind]:.3f}, {ydata[ind]:.3f}')\n\n        cid = fig.canvas.mpl_connect('pick_event', on_pick)\n    \"\"\"\n\n    def __init__(self, name, canvas, mouseevent, artist,\n                 guiEvent=None, **kwargs):\n        if guiEvent is None:\n            guiEvent = mouseevent.guiEvent\n        super().__init__(name, canvas, guiEvent)\n        self.mouseevent = mouseevent\n        self.artist = artist\n        self.__dict__.update(kwargs)\n\n\nclass KeyEvent(LocationEvent):\n    \"\"\"\n    A key event (key press, key release).\n\n    A KeyEvent has a number of special attributes in addition to those defined\n    by the parent `Event` and `LocationEvent` classes.\n\n    Attributes\n    ----------\n    key : None or str\n        The key(s) pressed. Could be *None*, a single case sensitive Unicode\n        character (\"g\", \"G\", \"#\", etc.), a special key (\"control\", \"shift\",\n        \"f1\", \"up\", etc.) or a combination of the above (e.g., \"ctrl+alt+g\",\n        \"ctrl+alt+G\").\n\n    Notes\n    -----\n    Modifier keys will be prefixed to the pressed key and will be in the order\n    \"ctrl\", \"alt\", \"super\". The exception to this rule is when the pressed key\n    is itself a modifier key, therefore \"ctrl+alt\" and \"alt+control\" can both\n    be valid key values.\n\n    Examples\n    --------\n    ::\n\n        def on_key(event):\n            print('you pressed', event.key, event.xdata, event.ydata)\n\n        cid = fig.canvas.mpl_connect('key_press_event', on_key)\n    \"\"\"\n\n    def __init__(self, name, canvas, key, x=0, y=0, guiEvent=None):\n        super().__init__(name, canvas, x, y, guiEvent=guiEvent)\n        self.key = key\n\n    @classmethod\n    def _from_ax_coords(cls, name, ax, xy, key, *args, **kwargs):\n        \"\"\"\n        Generate a synthetic event at a given axes coordinate.\n\n        This method is intended for creating events during testing.  The event\n        can be emitted by calling"}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", object]\n    \"\"\"\n\n    old_sigint_handler = signal.getsignal(signal.SIGINT)\n    if old_sigint_handler in (None, signal.SIG_IGN, signal.SIG_DFL):\n        yield\n        return\n\n    handler_args = None\n    wsock, rsock = socket.socketpair()\n    wsock.setblocking(False)\n    rsock.setblocking(False)\n    old_wakeup_fd = signal.set_wakeup_fd(wsock.fileno())\n    notifier = prepare_notifier(rsock)\n\n    def save_args_and_handle_sigint(*args):\n        nonlocal handler_args, notifier\n        handler_args = args\n        handle_sigint(notifier)\n        notifier = None\n\n    signal.signal(signal.SIGINT, save_args_and_handle_sigint)\n    try:\n        yield\n    finally:\n        wsock.close()\n        rsock.close()\n        signal.set_wakeup_fd(old_wakeup_fd)\n        signal.signal(signal.SIGINT, old_sigint_handler)\n        if handler_args is not None:\n            old_sigint_handler(*handler_args)\n\n\nclass FigureCanvasBase:\n    \"\"\"\n    The canvas the figure renders into.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level figure instance.\n    \"\"\"\n\n    # Set to one of {\"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\", \"macosx\"} if an\n    # interactive framework is required, or None otherwise.\n    required_interactive_framework = None\n\n    # The manager class instantiated by new_manager.\n    # (This is defined as a classproperty because the manager class is\n    # currently defined *after* the canvas class, but one could also assign\n    # ``FigureCanvasBase.manager_class = FigureManagerBase``\n    # after defining both classes.)\n    manager_class = _api.classproperty(lambda cls: FigureManagerBase)\n\n    events = [\n        'resize_event',\n        'draw_event',\n        'key_press_event',\n        'key_release_event',\n        'button_press_event',\n        'button_release_event',\n        'scroll_event',\n        'motion_notify_event',\n        'pick_event',\n        'figure_enter_event',\n        'figure_leave_event',\n        'axes_enter_event',\n        'axes_leave_event',\n     "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " cid = self.canvas.mpl_connect(event, callback)\n        self._cids.append(cid)\n\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n\n    def _get_data_coords(self, event):\n        \"\"\"Return *event*'s data coordinates in this widget's Axes.\"\"\"\n        # This method handles the possibility that event.inaxes != self.ax (which may\n        # occur if multiple Axes are overlaid), in which case event.xdata/.ydata will\n        # be wrong.  Note that we still special-case the common case where\n        # event.inaxes == self.ax and avoid re-running the inverse data transform,\n        # because that can introduce floating point errors for synthetic events.\n        return ((event.xdata, event.ydata) if event.inaxes is self.ax\n                else self.ax.transData.inverted().transform((event.x, event.y)))\n\n    def ignore(self, event):\n        # docstring inherited\n        return super().ignore(event) or self.canvas is None\n\n\nclass Button(AxesWidget):\n    \"\"\"\n    A GUI neutral button.\n\n    For the button to remain responsive you must keep a reference to it.\n    Call `.on_clicked` to connect to the button.\n\n    Attributes\n    ----------\n    ax\n        The `~.axes.Axes` the button renders into.\n    label\n        A `.Text` instance.\n    color\n        The color of the button when not hovering.\n    hovercolor\n        The color of the button when hovering.\n    \"\"\"\n\n    def __init__(self, ax, label, image=None,\n                 color='0.85', hovercolor='0.95', *, useblit=True):\n        \"\"\"\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The `~.axes.Axes` instance the button will be placed into.\n        label : str\n            The button text.\n        image : array-like or PIL Image\n            The image to place in the button, if not *None*.  The parameter is\n            directly forwarded to `~.axes.Axes.imshow`.\n        color : :mpltyp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}], "retrieved_count": 10, "cost_time": 1.4421460628509521}
{"question": "Why does Matplotlib provide both pyplot and object-oriented interfaces?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib provides both pyplot and object-oriented interfaces to serve different use cases and accommodate different programming styles. The dual interface design addresses several key requirements: 1) The pyplot interface provides a MATLAB-like, state-based interface that's convenient for interactive work and simple scripts, while the object-oriented API offers explicit control for complex plots and programmatic use, 2) The pyplot interface maintains global state (current Figure and Axes) which simplifies common operations but can become unwieldy for complex plots with multiple subplots, 3) The object-oriented API provides explicit references to Figure and Axes objects, enabling precise control over plot elements and better code organization for complex visualizations, 4) The separation allows users to choose the appropriate interface for their needs - pyplot for quick exploration and simple plots, object-oriented API for production code and complex customizations, 5) The pyplot interface serves as a convenience layer that reduces boilerplate code for common operations, while the object-oriented API exposes the full power and flexibility of the underlying system, 6) This design supports different programming styles and skill levels, from beginners who prefer the simplicity of pyplot to advanced users who need fine-grained control, 7) The separation enables better code maintainability and allows the core object-oriented system to evolve independently of the convenience interface. This dual approach enables Matplotlib to serve a wide range of users from casual data exploration to complex scientific visualization.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) Axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n# %%\n# (In addition, there is a third approach, for the case when embedding\n# Matplotlib in a GUI application, which completely drops pyplot, even for\n# figure creation. See the corresponding section in the gallery for more info:\n# :ref:`user_interfaces`.)\n#\n# Matplotlib's documentation and examples use both the OO and the pyplot\n# styles. In general, we suggest using the OO style, particularly for\n# complicated plots, and functions and scripts that are intended to be reused\n# as part of a larger project. However, the pyplot style can be very convenient\n# for quick interactive work.\n#\n# .. note::\n#\n#    You may find older examples that use the ``pylab`` interface,\n#    via ``from pylab import *``. This approach is strongly deprecated.\n#\n# Making a helper functions\n# -------------------------\n#\n# If you need to make the sa"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales information for a number of companies.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n# sphinx_gallery_thumbnail_number = 10\nimport numpy as np\n\ndata = {'Barton LLC': 109438.50,\n        'Frami, Hills and Schmidt': 103569.59,\n        'Fritsch, Russel and Anderson': 112214.71,\n        'Jerde-Hilpert': 112591.43,\n        'Keeling LLC': 100934.30,\n        'Koepp Ltd': 103660.54,\n        'Kulas Inc': 137351.96,\n        'Trantow-Barrows': 123381.38,\n        'White-Trantow': 135841.99,\n        'Will LLC': 104437.60}\ngroup_data = list(data.values())\ngroup_names = list(data.keys())\ngroup_mean = np.mean(group_data)\n\n# %%\n# Getting started\n# ===============\n#\n# This data is naturally visualized as a barplot, with one bar per\n# group. To do this with the object-oriented approach, we first generate\n# an instance of :class:`figure.Figure` and\n# :class:`axes.Axes`. The Figure is like a canvas, and the Axes\n# is a part of that canvas on which we will make a particular visualization.\n#\n# .. note::\n#\n#    Figures can ha"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/lifecycle\n\n=======================\nThe Lifecycle of a Plot\n=======================\n\nThis tutorial aims to show the beginning, middle, and end of a single\nvisualization using Matplotlib. We'll begin with some raw data and\nend by saving a figure of a customized visualization. Along the way we try\nto highlight some neat features and best-practices using Matplotlib.\n\n.. currentmodule:: matplotlib\n\n.. note::\n\n    This tutorial is based on\n    `this excellent blog post\n    <https://pbpython.com/effective-matplotlib.html>`_\n    by Chris Moffitt. It was transformed into this tutorial by Chris Holdgraf.\n\nA note on the explicit vs. implicit interfaces\n==============================================\n\nMatplotlib has two interfaces. For an explanation of the trade-offs between the\nexplicit and implicit interfaces see :ref:`api_interfaces`.\n\nIn the explicit object-oriented (OO) interface we directly utilize instances of\n:class:`axes.Axes` to build up the visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales informat"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/pyplot\n\n.. _pyplot_tutorial:\n\n===============\nPyplot tutorial\n===============\n\nAn introduction to the pyplot interface.  Please also see\n:ref:`quick_start` for an overview of how Matplotlib\nworks and :ref:`api_interfaces` for an explanation of the trade-offs between the\nsupported user APIs.\n\n\"\"\"\n\n# %%\n# Introduction to pyplot\n# ======================\n#\n# :mod:`matplotlib.pyplot` is a collection of functions that make matplotlib\n# work like MATLAB.  Each ``pyplot`` function makes some change to a figure:\n# e.g., creates a figure, creates a plotting area in a figure, plots some lines\n# in a plotting area, decorates the plot with labels, etc.\n#\n# In :mod:`matplotlib.pyplot` various states are preserved\n# across function calls, so that it keeps track of things like\n# the current figure and plotting area, and the plotting\n# functions are directed to the current Axes (please note that we use uppercase\n# Axes to refer to the `~.axes.Axes` concept, which is a central\n# :ref:`part of a figure <figure_parts>`\n# and not only the plural of *axis*).\n#\n# .. note::\n#\n#    The implicit pyplot API is generally less verbose but also not as flexible as the\n#    explicit API.  Most of the function calls you see here can also be called\n#    as methods from an ``Axes`` object. We recommend browsing the tutorials\n#    and examples to see how this works. See :ref:`api_interfaces` for an\n#    explanation of the trade-off of the supported user APIs.\n#\n# Generating visualizations with pyplot is very quick:\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n# You may be wondering why the x-axis ranges from 0-3 and the y-axis\n# from 1-4.  If you provide a single list or array to\n# `~.pyplot.plot`, matplotlib assumes it is a\n# sequence of y values, and automatically generates the x values for\n# you.  Since python ranges start with 0, the default x vector has the\n# same length as y but starts with 0; "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`\n# objects, etc. When the Figure is rendered, all of the\n# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such\n# an Artist cannot be shared by multiple Axes, or moved from one to another.\n#\n# .. _input_types:\n#\n# Types of inputs to plotting functions\n# =====================================\n#\n# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as\n# input, or objects that can be passed to `numpy.asarray`.\n# Classes that are similar to arrays ('array-like') such as `pandas`\n# data objects and `numpy.matrix` may not work as intended.  Common convention\n# is to convert these to `numpy.array` objects prior to plotting.\n# For example, to convert a `numpy.matrix` ::\n#\n#   b = np.matrix([[1, 2], [3, 4]])\n#   b_asarray = np.asarray(b)\n#\n# Most methods will also parse a string-indexable object like a *dict*, a\n# `structured numpy array`_, or a `pandas.DataFrame`.  Matplotlib allows you\n# to provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n# %%\n# (In addition, there is a third approach, for the case when embedding\n# Matplotlib in a GUI application, which completely drops pyplot, even for\n# figure creation. See the corresponding section in the gallery for more info:\n# :ref:`user_interfaces`.)\n#\n# Matplotlib's documentation and examples use both the OO and the pyplot\n# styles. In general, we suggest using the OO style, particularly for\n# complicated plots, and functions and scripts that are intended to be reused\n# as part of a larger project. However, the pyplot style can be very convenient\n# for quick interactive work.\n#\n# .. note::\n#\n#    You may find older examples that use the ``pylab`` interface,\n#    via ``from pylab import *``. This approach is strongly deprecated.\n#\n# Making a helper functions\n# -------------------------\n#\n# If you need to make the same plots over and over again with different data\n# sets, or want to easily wrap Matplotlib methods, use the recommended\n# signature function below.\n\n\ndef my_plotter(ax, data1, data2, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data1, data2, **param_dict)\n    return out\n\n# %%\n# which you would then use twice to populate two subplots:\n\ndata1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))\nmy_plotter(ax1, data1, data2, {'marker': 'x'})\nmy_plotter(ax2, data3, data4, {'marker': 'o'})\n\n# %%\n# Note that if you want to install these as a python package, or any other\n# customizations you could use one of the many templates on the web;\n# Matplotlib has one at `mpl-cookiecutter\n# <https://github.com/matplotlib/matplotlib-extension-cookiecutter>`_\n#\n#\n# Styling Artists\n# ===============\n#\n# Most plotting methods have styling options for the Artists, accessible either\n# when a "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}], "retrieved_count": 10, "cost_time": 1.4429786205291748}
{"question": "Why does Matplotlib separate the pyplot interface from the object-oriented API?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib separates the pyplot interface from the object-oriented API to serve different use cases and provide appropriate levels of abstraction. The separation addresses several key design goals: 1) The pyplot interface provides a MATLAB-like, state-based interface that's convenient for interactive work and simple scripts, while the object-oriented API offers explicit control for complex plots and programmatic use, 2) The pyplot interface maintains global state (current Figure and Axes) which simplifies common operations but can become unwieldy for complex plots with multiple subplots, 3) The object-oriented API provides explicit references to Figure and Axes objects, enabling precise control over plot elements and better code organization for complex visualizations, 4) The separation allows users to choose the appropriate interface for their needs - pyplot for quick exploration and simple plots, object-oriented API for production code and complex customizations, 5) The pyplot interface serves as a convenience layer that reduces boilerplate code for common operations, while the object-oriented API exposes the full power and flexibility of the underlying system, 6) This design supports different programming styles and skill levels, from beginners who prefer the simplicity of pyplot to advanced users who need fine-grained control, 7) The separation enables better code maintainability and allows the core object-oriented system to evolve independently of the convenience interface.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) Axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n# %%\n# (In addition, there is a third approach, for the case when embedding\n# Matplotlib in a GUI application, which completely drops pyplot, even for\n# figure creation. See the corresponding section in the gallery for more info:\n# :ref:`user_interfaces`.)\n#\n# Matplotlib's documentation and examples use both the OO and the pyplot\n# styles. In general, we suggest using the OO style, particularly for\n# complicated plots, and functions and scripts that are intended to be reused\n# as part of a larger project. However, the pyplot style can be very convenient\n# for quick interactive work.\n#\n# .. note::\n#\n#    You may find older examples that use the ``pylab`` interface,\n#    via ``from pylab import *``. This approach is strongly deprecated.\n#\n# Making a helper functions\n# -------------------------\n#\n# If you need to make the sa"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/lifecycle\n\n=======================\nThe Lifecycle of a Plot\n=======================\n\nThis tutorial aims to show the beginning, middle, and end of a single\nvisualization using Matplotlib. We'll begin with some raw data and\nend by saving a figure of a customized visualization. Along the way we try\nto highlight some neat features and best-practices using Matplotlib.\n\n.. currentmodule:: matplotlib\n\n.. note::\n\n    This tutorial is based on\n    `this excellent blog post\n    <https://pbpython.com/effective-matplotlib.html>`_\n    by Chris Moffitt. It was transformed into this tutorial by Chris Holdgraf.\n\nA note on the explicit vs. implicit interfaces\n==============================================\n\nMatplotlib has two interfaces. For an explanation of the trade-offs between the\nexplicit and implicit interfaces see :ref:`api_interfaces`.\n\nIn the explicit object-oriented (OO) interface we directly utilize instances of\n:class:`axes.Axes` to build up the visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales informat"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "lifecycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " visualization in an instance of\n:class:`figure.Figure`.  In the implicit interface, inspired by and modeled on\nMATLAB, we use a global state-based interface which is encapsulated in the\n:mod:`.pyplot` module to plot to the \"current Axes\".  See the :ref:`pyplot\ntutorials <pyplot_tutorial>` for a more in-depth look at the\npyplot interface.\n\nMost of the terms are straightforward but the main thing to remember\nis that:\n\n* The `.Figure` is the final image, and may contain one or more `~.axes.Axes`.\n* The `~.axes.Axes` represents an individual plot (not to be confused with\n   `~.axis.Axis`, which refers to the x-, y-, or z-axis of a plot).\n\nWe call methods that do the plotting directly from the Axes, which gives\nus much more flexibility and power in customizing our plot.\n\n.. note::\n\n   In general, use the explicit interface over the implicit pyplot interface\n   for plotting.\n\nOur data\n========\n\nWe'll use the data from the post from which this tutorial was derived.\nIt contains sales information for a number of companies.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n# sphinx_gallery_thumbnail_number = 10\nimport numpy as np\n\ndata = {'Barton LLC': 109438.50,\n        'Frami, Hills and Schmidt': 103569.59,\n        'Fritsch, Russel and Anderson': 112214.71,\n        'Jerde-Hilpert': 112591.43,\n        'Keeling LLC': 100934.30,\n        'Koepp Ltd': 103660.54,\n        'Kulas Inc': 137351.96,\n        'Trantow-Barrows': 123381.38,\n        'White-Trantow': 135841.99,\n        'Will LLC': 104437.60}\ngroup_data = list(data.values())\ngroup_names = list(data.keys())\ngroup_mean = np.mean(group_data)\n\n# %%\n# Getting started\n# ===============\n#\n# This data is naturally visualized as a barplot, with one bar per\n# group. To do this with the object-oriented approach, we first generate\n# an instance of :class:`figure.Figure` and\n# :class:`axes.Axes`. The Figure is like a canvas, and the Axes\n# is a part of that canvas on which we will make a particular visualization.\n#\n# .. note::\n#\n#    Figures can ha"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/pyplot\n\n.. _pyplot_tutorial:\n\n===============\nPyplot tutorial\n===============\n\nAn introduction to the pyplot interface.  Please also see\n:ref:`quick_start` for an overview of how Matplotlib\nworks and :ref:`api_interfaces` for an explanation of the trade-offs between the\nsupported user APIs.\n\n\"\"\"\n\n# %%\n# Introduction to pyplot\n# ======================\n#\n# :mod:`matplotlib.pyplot` is a collection of functions that make matplotlib\n# work like MATLAB.  Each ``pyplot`` function makes some change to a figure:\n# e.g., creates a figure, creates a plotting area in a figure, plots some lines\n# in a plotting area, decorates the plot with labels, etc.\n#\n# In :mod:`matplotlib.pyplot` various states are preserved\n# across function calls, so that it keeps track of things like\n# the current figure and plotting area, and the plotting\n# functions are directed to the current Axes (please note that we use uppercase\n# Axes to refer to the `~.axes.Axes` concept, which is a central\n# :ref:`part of a figure <figure_parts>`\n# and not only the plural of *axis*).\n#\n# .. note::\n#\n#    The implicit pyplot API is generally less verbose but also not as flexible as the\n#    explicit API.  Most of the function calls you see here can also be called\n#    as methods from an ``Axes`` object. We recommend browsing the tutorials\n#    and examples to see how this works. See :ref:`api_interfaces` for an\n#    explanation of the trade-off of the supported user APIs.\n#\n# Generating visualizations with pyplot is very quick:\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n# You may be wondering why the x-axis ranges from 0-3 and the y-axis\n# from 1-4.  If you provide a single list or array to\n# `~.pyplot.plot`, matplotlib assumes it is a\n# sequence of y values, and automatically generates the x values for\n# you.  Since python ranges start with 0, the default x vector has the\n# same length as y but starts with 0; "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "o provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to implicitly create and manage the Figures and Axes, and\n#   use pyplot functions for plotting.\n#\n# See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n# implicit and explicit interfaces.\n#\n# So one can use the OO-style\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.plot(x, x, label='linear')  # Plot some data on the Axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the Axes.\nax.set_ylabel('y label')  # Add a y-label to the Axes.\nax.set_title(\"Simple Plot\")  # Add a title to the Axes.\nax.legend()  # Add a legend.\n\n# %%\n# or the pyplot-style:\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n# %%\n# (In addition, there is a third approach, for the case when embedding\n# Matplotlib in a GUI application, which completely drops pyplot, even for\n# figure creation. See the corresponding section in the gallery for more info:\n# :ref:`user_interfaces`.)\n#\n# Matplotlib's documentation and examples use both the OO and the pyplot\n# styles. In general, we suggest using the OO style, particularly for\n# complicated plots, and functions and scripts that are intended to be reused\n# as part of a larger project. However, the pyplot style can be very convenient\n# for quick interactive work.\n#\n# .. note::\n#\n#    You may find older examples that use the ``pylab`` interface,\n#    via ``from pylab import *``. This approach is strongly deprecated.\n#\n# Making a helper functions\n# -------------------------\n#\n# If you need to make the same plots over and over again with different data\n# sets, or want to easily wrap Matplotlib methods, use the recommended\n# signature function below.\n\n\ndef my_plotter(ax, data1, data2, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data1, data2, **param_dict)\n    return out\n\n# %%\n# which you would then use twice to populate two subplots:\n\ndata1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))\nmy_plotter(ax1, data1, data2, {'marker': 'x'})\nmy_plotter(ax2, data3, data4, {'marker': 'o'})\n\n# %%\n# Note that if you want to install these as a python package, or any other\n# customizations you could use one of the many templates on the web;\n# Matplotlib has one at `mpl-cookiecutter\n# <https://github.com/matplotlib/matplotlib-extension-cookiecutter>`_\n#\n#\n# Styling Artists\n# ===============\n#\n# Most plotting methods have styling options for the Artists, accessible either\n# when a "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`\n# objects, etc. When the Figure is rendered, all of the\n# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such\n# an Artist cannot be shared by multiple Axes, or moved from one to another.\n#\n# .. _input_types:\n#\n# Types of inputs to plotting functions\n# =====================================\n#\n# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as\n# input, or objects that can be passed to `numpy.asarray`.\n# Classes that are similar to arrays ('array-like') such as `pandas`\n# data objects and `numpy.matrix` may not work as intended.  Common convention\n# is to convert these to `numpy.array` objects prior to plotting.\n# For example, to convert a `numpy.matrix` ::\n#\n#   b = np.matrix([[1, 2], [3, 4]])\n#   b_asarray = np.asarray(b)\n#\n# Most methods will also parse a string-indexable object like a *dict*, a\n# `structured numpy array`_, or a `pandas.DataFrame`.  Matplotlib allows you\n# to provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to "}], "retrieved_count": 10, "cost_time": 1.4784629344940186}
{"question": "Why does Matplotlib's backend system impact rendering performance for different output formats?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend system impacts rendering performance for different output formats due to the fundamental differences in how each format is processed and optimized. The performance impact stems from several key factors: 1) Different output formats require different rendering engines - raster formats (PNG, JPEG) use pixel-based rendering through the Agg backend, while vector formats (PDF, SVG, PS) use command-based rendering that generates scalable graphics, 2) Raster backends like Agg must process every pixel and perform anti-aliasing calculations, making them computationally intensive for high-resolution outputs, while vector backends generate mathematical descriptions that are more efficient for complex geometric shapes, 3) Each backend has different optimization strategies - Agg uses the Anti-Grain Geometry library for high-quality raster rendering, PDF uses specialized vector graphics commands, and SVG generates XML markup, 4) Memory usage varies significantly between backends - raster backends require large pixel buffers proportional to image size and DPI, while vector backends use memory proportional to the number of drawing commands, 5) File size and compression also affect performance - raster formats require compression algorithms (PNG, JPEG) while vector formats use different encoding schemes, 6) Backend-specific features like font handling, color management, and clipping operations have different computational costs, 7) The choice of backend affects both rendering speed and output quality, requiring users to balance performance needs with format requirements for their specific use case.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s, f\"print_{fmt}\"):\n                raise ValueError(\n                    f\"The {backend!r} backend does not support {fmt} output\")\n            canvas = canvas_class(self.figure)\n        elif hasattr(self, f\"print_{fmt}\"):\n            # Return the current canvas if it supports the requested format.\n            canvas = self\n        else:\n            # Return a default canvas for the requested format, if it exists.\n            canvas_class = get_registered_canvas_class(fmt)\n            if canvas_class is None:\n                raise ValueError(\n                    \"Format {!r} is not supported (supported formats: {})\".format(\n                        fmt, \", \".join(sorted(self.get_supported_filetypes()))))\n            canvas = canvas_class(self.figure)\n        canvas._is_saving = self._is_saving\n        meth = getattr(canvas, f\"print_{fmt}\")\n        mod = (meth.func.__module__\n               if hasattr(meth, \"func\")  # partialmethod, e.g. backend_wx.\n               else meth.__module__)\n        if mod.startswith((\"matplotlib.\", \"mpl_toolkits.\")):\n            optional_kws = {  # Passed by print_figure for other renderers.\n                \"dpi\", \"facecolor\", \"edgecolor\", \"orientation\",\n                \"bbox_inches_restore\"}\n            skip = optional_kws - {*inspect.signature(meth).parameters}\n            print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\n                *args, **{k: v for k, v in kwargs.items() if k not in skip}))\n        else:  # Let third-parties do as they see fit.\n            print_method = meth\n        try:\n            yield print_method\n        finally:\n            self.figure.canvas = self\n\n    def print_figure(\n            self, filename, dpi=None, facecolor=None, edgecolor=None,\n            orientation='portrait', format=None, *,\n            bbox_inches=None, pad_inches=None, bbox_extra_artists=None,\n            backend=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy. Set the figure patch face and edge\n      "}, {"start_line": 130000, "end_line": 132000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " to render the file, e.g. to render a\n            png file with the \"cairo\" backend rather than the default \"agg\",\n            or a pdf file with the \"pgf\" backend rather than the default\n            \"pdf\".  Note that the default backend is normally sufficient.  See\n            :ref:`the-builtin-backends` for a list of valid backends for each\n            file format.  Custom backends can be referenced as \"module://...\".\n\n        orientation : {'landscape', 'portrait'}\n            Currently only supported by the postscript backend.\n\n        papertype : str\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n\n        \"\"\"\n\n        kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])\n        transparent = mpl._val_or_rc(transparent, 'savefig.transparent')\n\n        with ExitStack() as stack:\n            if transparent:\n                def _recursively_make_subfig_transparent(exit_stack, subfig):\n                    exit_stack.enter_context(\n                        subfig.patch._cm_set(\n                            facecolor=\"none\", edgecolor=\"none\"))\n                    for ax in subfig.axes:\n                        exit_stack.enter_context(\n                            ax.patch._cm_set(\n                                facecolor=\"none\", edgecolor=\"none\"))\n                    for sub_subfig in subfig.subfigs:\n                        _recursively_make_subfig_transparent(\n                            exit_stack, sub_subfig)\n\n                def _recursively_make_axes_transparent(exit_stack, ax):\n                    exit_stack.enter_co"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn `Anti-Grain Geometry`_ (AGG) backend.\n\nFeatures that are implemented:\n\n* capstyles and join styles\n* dashes\n* linewidth\n* lines, rectangles, ellipses\n* clipping to a rectangle\n* output to RGBA and Pillow-supported image formats\n* alpha blending\n* DPI scaling properly - everything scales properly (dashes, linewidths, etc)\n* draw polygon\n* freetype2 w/ ft2font\n\nStill TODO:\n\n* integrate screen dpi w/ ppi and text\n\n.. _Anti-Grain Geometry: http://agg.sourceforge.net/antigrain.com\n\"\"\"\n\nfrom contextlib import nullcontext\nfrom math import radians, cos, sin\n\nimport numpy as np\nfrom PIL import features\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, RendererBase)\nfrom matplotlib.font_manager import fontManager as _fontManager, get_font\nfrom matplotlib.ft2font import LoadFlags\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n     "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_mixed.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import numpy as np\n\nfrom matplotlib import cbook\nfrom .backend_agg import RendererAgg\nfrom matplotlib._tight_bbox import process_figure_for_rasterizing\n\n\nclass MixedModeRenderer:\n    \"\"\"\n    A helper class to implement a renderer that switches between\n    vector and raster drawing.  An example may be a PDF writer, where\n    most things are drawn with PDF vector commands, but some very\n    complex objects, such as quad meshes, are rasterised and then\n    output as images.\n    \"\"\"\n    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `~matplotlib.figure.Figure`\n            The figure instance.\n        width : float\n            The width of the canvas in logical units\n        height : float\n            The height of the canvas in logical units\n        dpi : float\n            The dpi of the canvas\n        vector_renderer : `~matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `~matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.f"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_mixed.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " `~matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `~matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*se"}, {"start_line": 19000, "end_line": 20645, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs, metadata)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs, metadata)\n\n    print_tiff = print_tif\n\n    def print_webp(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs, metadata)\n\n    def print_avif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        if not features.check(\"avif\"):\n            raise RuntimeError(\n                \"The installed pillow version does not support avif. Full \"\n                \"avif support has been added in pillow 11.3.\"\n            )\n        self._print_pil(filename_or_obj, \"avif\", pil_kwargs, metadata)\n\n    (print_gif.__doc__,\n     print_jpg.__doc__,\n     print_tif.__doc__,\n     print_webp.__doc__,\n     print_avif.__doc__) = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        metadata : None\n            Unused for pillow-based writers. All supported options\n            can be passed via *pil_kwargs*.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"GIF\", \"JPEG\", \"TIFF\", \"WebP\", \"AVIF\"])\n\n\n@_Backend.export\nclass _BackendAgg(_Backend):\n    backend_version = 'v2.2'\n    FigureCanvas = FigureCanvasAgg\n    FigureManager = FigureManagerBase\n"}], "retrieved_count": 10, "cost_time": 1.4649131298065186}
{"question": "Where does the control flow when Matplotlib handles user interactions through the event system?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib handles user interactions through the event system, the control flow follows a specific sequence through multiple layers. The control flow proceeds as follows: 1) User interaction (mouse click, key press) is captured by the GUI toolkit (Qt, Tk, GTK, Wx, macOS) and converted into a low-level GUI event, 2) The backend-specific FigureCanvas receives the GUI event and converts it into a Matplotlib-specific event object (MouseEvent, KeyEvent, etc.) with both pixel coordinates and data coordinates, 3) The FigureCanvasBase.mpl_connect() method manages registered callbacks, and when an event occurs, it looks up the appropriate callback functions for that event type, 4) The event object is passed to each registered callback function, which can modify Artist properties, trigger redraws, or perform other actions, 5) If the callback modifies Artists, the 'stale' state is propagated up the Artist hierarchy, marking parent containers as needing redraw, 6) The event system coordinates with the drawing system - if Artists were modified, draw_idle() may be called to schedule a redraw, 7) The control flow returns to the GUI event loop, which continues waiting for the next user interaction, 8) For interactive features like panning and zooming, the event callbacks modify Axes limits and trigger automatic redraws through the stale state mechanism. This event-driven architecture allows Matplotlib to respond to user interactions while maintaining separation between the GUI toolkit layer and the plotting logic, enabling the same interactive code to work across different GUI frameworks.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ent propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ering different compared to mpl.\n            button for button, mask in [\n                (MouseButton.LEFT, 1),\n                (MouseButton.RIGHT, 2),\n                (MouseButton.MIDDLE, 4),\n                (MouseButton.BACK, 8),\n                (MouseButton.FORWARD, 16),\n            ] if event['buttons'] & mask  # State *after* press/release.\n        }\n        modifiers = event['modifiers']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       modifiers=self._mpl_modifiers(mods),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        if self.figure is None:\n            return\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      modifiers=self._mpl_modifiers(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        if self.manager:\n            self.send_event('figure_label', label=self.manager.get_window_title())\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_press_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_release_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\n            \"motion_notify_event\", self, *self._mpl_coords((x, y)),\n            buttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _mpl_buttons(self, controller):\n        # NOTE: This spews \"Broken accounting of active state\" warnings on\n        # right click on macOS.\n        surface = self.get_native().get_surface()\n        is_over, x, y, event_state = surface.get_device_position(\n            self.get_display().get_default_seat().get_pointer())\n        # NOTE: alternatively we could use\n        #   event_state = controller.get_current_event_state()\n        # but for button_press/button_release this would report the state\n        # *prior* to the event rather than after it; the above reports the\n        # state *after* it.\n        mod_table = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, G"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.device_pixel_ratio\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height - y * self.device_pixel_ratio\n        return x, y\n\n    def scroll_event(self, controller, dx, dy):\n        MouseEvent(\n            \"scroll_event\", self, *self._mpl_coords(), step=dy,\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def button_press_event(self, controller, n_press, x, y):\n        MouseEvent(\n            \"button_press_event\", self, *self._mpl_coords((x, y)),\n            controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        self.grab_focus()\n\n    def button_release_event(self, controller, n_press, x, y):\n        MouseEvent(\n            \"button_release_event\", self, *self._mpl_coords((x, y)),\n            controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_press_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_release_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\n            \"motion_notify_event\", self, *self._mpl_coords((x, y)),\n            bu"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is sometimes not\n        # provided (`isNull()`) and is unreliable on X11 (\"xcb\").\n        if (event.pixelDelta().isNull()\n                or QtWidgets.QApplication.instance().platformName() == \"xcb\"):\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n        if steps and self.figure is not None:\n            MouseEvent(\"scroll_event\", self,\n                       *self.mouseEventCoords(event), step=steps,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None and self.figure is not None:\n            KeyEvent(\"key_press_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()\n\n    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None and self.figure is not None:\n            KeyEvent(\"key_r"}, {"start_line": 110000, "end_line": 112000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    if data is not None:\n                            data_str = a.format_cursor_data(data).rstrip()\n                            if data_str:\n                                s = s + '\\n' + data_str\n                return s\n        return \"\"\n\n    def mouse_move(self, event):\n        self._update_cursor(event)\n        self.set_message(self._mouse_event_to_message(event))\n\n    def _zoom_pan_handler(self, event):\n        if self.mode == _Mode.PAN:\n            if event.name == \"button_press_event\":\n                self.press_pan(event)\n            elif event.name == \"button_release_event\":\n                self.release_pan(event)\n        if self.mode == _Mode.ZOOM:\n            if event.name == \"button_press_event\":\n                self.press_zoom(event)\n            elif event.name == \"button_release_event\":\n                self.release_zoom(event)\n\n    def _start_event_axes_interaction(self, event, *, method):\n\n        def _ax_filter(ax):\n            return (ax.in_axes(event) and\n                    ax.get_navigate() and\n                    getattr(ax, f\"can_{method}\")()\n                    )\n\n        def _capture_events(ax):\n            f = ax.get_forward_navigation_events()\n            if f == \"auto\":  # (capture = patch visibility)\n                f = not ax.patch.get_visible()\n            return not f\n\n        # get all relevant axes for the event\n        axes = list(filter(_ax_filter, self.canvas.figure.get_axes()))\n\n        if len(axes) == 0:\n            return []\n\n        if self._nav_stack() is None:\n            self.push_current()   # Set the home button to this view.\n\n        # group axes by zorder (reverse to trigger later axes first)\n        grps = dict()\n        for ax in reversed(axes):\n            grps.setdefault(ax.get_zorder(), []).append(ax)\n\n        axes_to_trigger = []\n        # go through zorders in reverse until we hit a capturing axes\n        for zorder in sorted(grps, reverse=True):\n            for ax in grps[zorder]:\n                axes_to_trigger"}], "retrieved_count": 10, "cost_time": 1.4537756443023682}
{"question": "Where does the data flow when Matplotlib renders a plot from Artist objects to the backend?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib renders a plot, data flows from Artist objects to the backend through a well-defined pipeline. The data flow follows this sequence: 1) Artist objects (Figure, Axes, Line2D, Text, etc.) contain the data and visual properties (coordinates, colors, styles) that define what should be drawn, 2) When rendering is triggered (by draw() or draw_idle()), the Artist hierarchy is traversed starting from the Figure, which calls draw() on its child Axes, 3) Each Artist's draw() method is called with a renderer parameter, passing the Artist's data and properties to the renderer, 4) The renderer (RendererBase subclass like RendererAgg) receives the drawing commands and data from Artists, including path data, colors, transforms, and clipping information, 5) The renderer processes the data through various transformations - coordinate transformations (data coordinates to display coordinates), path simplification, clipping, and anti-aliasing, 6) For raster backends like Agg, the renderer converts the processed data into pixel operations, filling pixel buffers with the appropriate colors and alpha values, 7) The FigureCanvas (backend-specific) receives the rendered pixel data and displays it on screen or saves it to a file, 8) The data flow is unidirectional - Artists provide data and properties to the renderer, which processes and outputs the final visual representation. This architecture separates data representation (Artists) from rendering logic (backends), allowing the same plotting code to work across different output formats.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 188000, "end_line": 189117, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re\n        The figure all of the artists belong to (not checked).  We need this\n        because we can at the figure level suppress composition and insert each\n        rasterized artist as its own image.\n\n    artists : List[matplotlib.artist.Artist]\n        The list of Artists to be rasterized.  These are assumed to all\n        be in the same Figure.\n\n    renderer : matplotlib.backendbases.RendererBase\n        The currently active renderer\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    class _MinimalArtist:\n        def get_rasterized(self):\n            return True\n\n        def get_agg_filter(self):\n            return None\n\n        def __init__(self, figure, artists):\n            self.figure = figure\n            self.artists = artists\n\n        def get_figure(self, root=False):\n            if root:\n                return self.figure.get_figure(root=True)\n            else:\n                return self.figure\n\n        @martist.allow_rasterization\n        def draw(self, renderer):\n            for a in self.artists:\n                a.draw(renderer)\n\n    return _MinimalArtist(figure, artists).draw(renderer)\n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(f\"{_nums_to_str(*rect.p0, *rect.size)} rectclip\\n\")\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataS"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}], "retrieved_count": 10, "cost_time": 1.4646565914154053}
{"question": "Where does Matplotlib implement its Artist hierarchy management?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its Artist hierarchy management across several key locations in the codebase. The main components are: 1) The core Artist class in lib/matplotlib/artist.py defines the base class for all visual elements and provides the fundamental hierarchy management through methods like get_children(), set_figure(), and get_figure(), 2) The Figure class in lib/matplotlib/figure.py manages the top-level hierarchy through its _axstack attribute (implemented by the _AxesStack class) which tracks all Axes objects and manages the current active Axes, 3) The FigureBase class in figure.py provides the base functionality for both Figure and SubFigure classes, including methods for adding and managing child Artists, 4) The Axes class in lib/matplotlib/axes/_axes.py manages its own hierarchy of child Artists (lines, text, patches, etc.) through lists like self.lines, self.texts, self.patches, and methods like add_line(), add_patch(), etc., 5) The parent-child relationships are maintained through the _parent_figure attribute in Artist objects and the axes attribute that links Artists to their containing Axes, 6) The stale state propagation system is implemented in artist.py through the stale_callback mechanism, which automatically propagates changes up the hierarchy when Artists are modified, 7) The rendering hierarchy is managed through the draw() method chain, where Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 8) The Artist API documentation and type hints are provided in lib/matplotlib/artist.pyi, which defines the interface for the hierarchy management methods. This hierarchical system provides a clean separation of concerns while maintaining the relationships necessary for proper rendering, event handling, and state management.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ist, invalid_types))\n            )\n\n        def __repr__(self):\n            return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n\n        def __len__(self):\n            return sum(self._type_check(artist)\n                       for artist in self._axes._children)\n\n        def __iter__(self):\n            for artist in list(self._axes._children):\n                if self._type_check(artist):\n                    yield artist\n\n        def __getitem__(self, key):\n            return [artist\n                    for artist in self._axes._children\n                    if self._type_check(artist)][key]\n\n        def __add__(self, other):\n            if isinstance(other, (list, _AxesBase.ArtistList)):\n                return [*self, *other]\n            if isinstance(other, (tuple, _AxesBase.ArtistList)):\n                return (*self, *other)\n            return NotImplemented\n\n        def __radd__(self, other):\n            if isinstance(other, list):\n                return other + list(self)\n            if isinstance(other, tuple):\n                return other + tuple(self)\n            return NotImplemented\n\n    @property\n    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n\n    @property\n    def collections(self):\n        return self.ArtistList(self, 'collections',\n                               valid_types=mcoll.Collection)\n\n    @property\n    def images(self):\n        return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n\n    @property\n    def lines(self):\n        return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n\n    @property\n    def patches(self):\n        return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n\n    @property\n    def tables(self):\n        return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n\n    @property\n    def texts(self):\n        return self.Arti"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a not in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tainer artist.\n\n    The child artists are meant to be drawn at a relative position to its\n    parent.\n\n    Being an artist itself, all keyword arguments are passed on to `.Artist`.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        self._internal_update(kwargs)\n        # Clipping has not been implemented in the OffsetBox family, so\n        # disable the clip flag for consistency. It can always be turned back\n        # on to zero effect.\n        self.set_clip_on(False)\n        self._children = []\n        self._offset = (0, 0)\n\n    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` for the `.OffsetBox` and all its children.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n        \"\"\"\n        super().set_figure(fig)\n        for c in self.get_children():\n            c.set_figure(fig)\n\n    @martist.Artist.axes.setter\n    def axes(self, ax):\n        # TODO deal with this better\n        martist.Artist.axes.fset(self, ax)\n        for c in self.get_children():\n            if c is not None:\n                c.axes = ax\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Delegate the mouse event contains-check to the children.\n\n        As a container, the `.OffsetBox` does not respond itself to\n        mouseevents.\n\n        Parameters\n        ----------\n        mouseevent : `~matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n\n        See Also\n        --------\n        .Artist.contains\n        \"\"\"\n        if self._different_canvas(mouseevent):\n            return False, {}\n        for c in self.get_children():\n            a, b = c.contains(mouseevent)\n            if a:\n                r"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n\n    def set(self, **kwargs):\n        # docstring and signature are auto-generated via\n        # Artist._update_set_signature_and_docstring() at the end of the\n        # module.\n        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n\n    @contextlib.contextmanager\n    def _cm_set(self, **kwargs):\n        \"\"\"\n        `.Artist.set` context-manager that restores original values at exit.\n        \"\"\"\n        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n        try:\n            self.set(**kwargs)\n            yield\n        finally:\n            self.set(**orig_vals)\n\n    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *None*: Return all objects contained in artist.\n            - A function with signature ``def match(artist: Artist) -> bool``.\n              The result will only contain artists for which the function\n              returns *True*.\n            - A class instance: e.g., `.Line2D`. The result will only contain\n              artists of this class or its subclasses (``isinstance`` check).\n\n        include_self : bool\n            Include *self* in the list to be checked for a match.\n\n        Returns\n        -------\n        list of `.Artist`\n\n        \"\"\"\n        if match is None:  # always return True\n            def matchfunc(x):\n                return True\n        elif isinstance(match, type) and issubclass(match, Artist):\n            def matchfunc(x):\n                return isinstance(x, match)\n        elif callable(match):\n            matchfunc = match\n        else:\n            raise ValueError('match must be None, a matplotlib.artist.Artist '\n                             'subclass, or a call"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-----\n        get_cursor_data\n        .ToolCursorPosition\n        .NavigationToolbar2\n        \"\"\"\n        self._mouseover = bool(mouseover)\n        ax = self.axes\n        if ax:\n            if self._mouseover:\n                ax._mouseover_set.add(self)\n            else:\n                ax._mouseover_set.discard(self)\n\n    mouseover = property(get_mouseover, set_mouseover)  # backcompat.\n\n\ndef _get_tightbbox_for_layout_only(obj, *args, **kwargs):\n    \"\"\"\n    Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a\n    *for_layout_only* kwarg; this helper tries to use the kwarg but skips it\n    when encountering third-party subclasses that do not support it.\n    \"\"\"\n    try:\n        return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n    except TypeError:\n        return obj.get_tightbbox(*args, **kwargs)\n\n\nclass ArtistInspector:\n    \"\"\"\n    A helper class to inspect an `~matplotlib.artist.Artist` and return\n    information about its settable properties and their current values.\n    \"\"\"\n\n    def __init__(self, o):\n        r\"\"\"\n        Initialize the artist inspector with an `Artist` or an iterable of\n        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n        sequence (all `Artist`\\s are of the same type) and it is your\n        responsibility to make sure this is so.\n        \"\"\"\n        if not isinstance(o, Artist):\n            if np.iterable(o):\n                o = list(o)\n                if len(o):\n                    o = o[0]\n\n        self.oorig = o\n        if not isinstance(o, type):\n            o = type(o)\n        self.o = o\n\n        self.aliasd = self.get_aliases()\n\n    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(s"}], "retrieved_count": 10, "cost_time": 1.5398304462432861}
{"question": "Why does Matplotlib's caching mechanism optimize repeated plotting operations?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's caching mechanism optimizes repeated plotting operations by storing and reusing expensive computational results, reducing redundant work and improving performance. The caching system operates at multiple levels: 1) Artist state caching - Artists track their 'stale' state to avoid unnecessary redraws, only updating when properties have actually changed, 2) Background caching for blitting - the animation system caches static background elements (axes, labels, grid) and only redraws changing artists, dramatically improving animation performance, 3) Font and text caching - the TexManager caches compiled TeX output to avoid recompiling identical text strings, storing results in a hierarchical cache directory structure, 4) Path simplification caching - line segments are simplified and cached to reduce rendering complexity for repeated draws, 5) Renderer caching - backend renderers cache expensive operations like coordinate transformations and clipping regions, 6) Figure canvas caching - the canvas caches pixel buffers and only updates regions that have changed, 7) Style and configuration caching - rcParams and style settings are cached to avoid repeated lookups. These caching mechanisms work together to minimize redundant computations, reduce memory allocations, and improve rendering speed, especially for interactive plots and animations where the same elements are drawn repeatedly with only small changes.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "animation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n\n    def _blit_clear(self, artists):\n        # Get a list of the Axes that need clearing from the artists that\n        # have been drawn. Grab the appropriate saved background from the\n        # cache and restore.\n        axes = {a.axes for a in artists}\n        for ax in axes:\n            try:\n                view, bg = self._blit_cache[ax]\n            except KeyError:\n                continue\n            if ax._get_view() == view:\n                ax.figure.canvas.restore_region(bg)\n            else:\n                self._blit_cache.pop(ax)\n\n    def _setup_blit(self):\n        # Setting up the blit requires: a cache of the background for the Axes\n        self._blit_cache = dict()\n        self._drawn_artists = []\n        # _post_draw needs to be called first to initialize the renderer\n        self._post_draw(None, self._blit)\n        # Then we need to clear the Frame for the initial draw\n        # This is typically handled in _on_resize because QT and Tk\n        # emit a resize event on launch, but the macosx backend does not,\n        # thus we force it here for everyone for consistency\n        self._init_draw()\n        # Connect to future resize events\n        self._resize_id = self._fig.canvas.mpl_connect('resize_event',\n                                                       self._on_resize)\n\n    def _on_resize(self, event):\n  "}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "animation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      except KeyError:\n                continue\n            if ax._get_view() == view:\n                ax.figure.canvas.restore_region(bg)\n            else:\n                self._blit_cache.pop(ax)\n\n    def _setup_blit(self):\n        # Setting up the blit requires: a cache of the background for the Axes\n        self._blit_cache = dict()\n        self._drawn_artists = []\n        # _post_draw needs to be called first to initialize the renderer\n        self._post_draw(None, self._blit)\n        # Then we need to clear the Frame for the initial draw\n        # This is typically handled in _on_resize because QT and Tk\n        # emit a resize event on launch, but the macosx backend does not,\n        # thus we force it here for everyone for consistency\n        self._init_draw()\n        # Connect to future resize events\n        self._resize_id = self._fig.canvas.mpl_connect('resize_event',\n                                                       self._on_resize)\n\n    def _on_resize(self, event):\n        # On resize, we need to disable the resize event handling so we don't\n        # get too many events. Also stop the animation events, so that\n        # we're paused. Reset the cache and re-init. Set up an event handler\n        # to catch once the draw has actually taken place.\n        self._fig.canvas.mpl_disconnect(self._resize_id)\n        self.event_source.stop()\n        self._blit_cache.clear()\n        self._init_draw()\n        self._resize_id = self._fig.canvas.mpl_connect('draw_event',\n                                                       self._end_redraw)\n\n    def _end_redraw(self, event):\n        # Now that the redraw has happened, do the post draw flushing and\n        # blit handling. Then re-enable all of the original events.\n        self._post_draw(None, False)\n        self.event_source.start()\n        self._fig.canvas.mpl_disconnect(self._resize_id)\n        self._resize_id = self._fig.canvas.mpl_connect('resize_event',\n                                                  "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e Text._get_layout() call, which is\n    # called within the _get_textbox. So, it would better to move this\n    # function as a method with some refactoring of _get_layout method.\n\n    projected_xs = []\n    projected_ys = []\n\n    theta = np.deg2rad(text.get_rotation())\n    tr = Affine2D().rotate(-theta)\n\n    _, parts, d = text._get_layout(renderer)\n\n    for t, wh, x, y in parts:\n        w, h = wh\n\n        xt1, yt1 = tr.transform((x, y))\n        yt1 -= d\n        xt2, yt2 = xt1 + w, yt1 + h\n\n        projected_xs.extend([xt1, xt2])\n        projected_ys.extend([yt1, yt2])\n\n    xt_box, yt_box = min(projected_xs), min(projected_ys)\n    w_box, h_box = max(projected_xs) - xt_box, max(projected_ys) - yt_box\n\n    x_box, y_box = Affine2D().rotate(theta).transform((xt_box, yt_box))\n\n    return x_box, y_box, w_box, h_box\n\n\ndef _get_text_metrics_with_cache(renderer, text, fontprop, ismath, dpi):\n    \"\"\"Call ``renderer.get_text_width_height_descent``, caching the results.\"\"\"\n    # Cached based on a copy of fontprop so that later in-place mutations of\n    # the passed-in argument do not mess up the cache.\n    return _get_text_metrics_with_cache_impl(\n        weakref.ref(renderer), text, fontprop.copy(), ismath, dpi)\n\n\n@functools.lru_cache(4096)\ndef _get_text_metrics_with_cache_impl(\n        renderer_ref, text, fontprop, ismath, dpi):\n    # dpi is unused, but participates in cache invalidation (via the renderer).\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n\n\n@_docstring.interpd\n@_api.define_aliases({\n    \"color\": [\"c\"],\n    \"fontproperties\": [\"font\", \"font_properties\"],\n    \"fontfamily\": [\"family\"],\n    \"fontname\": [\"name\"],\n    \"fontsize\": [\"size\"],\n    \"fontstretch\": [\"stretch\"],\n    \"fontstyle\": [\"style\"],\n    \"fontvariant\": [\"variant\"],\n    \"fontweight\": [\"weight\"],\n    \"horizontalalignment\": [\"ha\"],\n    \"verticalalignment\": [\"va\"],\n    \"multialignment\": [\"ma\"],\n})\nclass Text(Artist):\n    \"\"\"Handle storing and drawing of text in window or data "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()\n\n    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc\n\n    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=round(size),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)\n\n\nclass GraphicsContextWx(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.\n\n    This class stores a reference to a wxMemoryDC, and a\n    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext\n    seems to be fairly heavy, so these objects are cached based on the\n    bitmap object that is passed in.\n\n    The base GraphicsContext stores colors as an RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\n    since wxPython colour management is rather simple, I have not chosen\n    to implement a separate colour manager class.\n    \"\"\"\n    _capd = {'butt': wx.CAP_BUTT,\n             'projecting': wx.CAP_PROJECTING"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                p.simplify_threshold = path.simplify_threshold\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    msg = (\n                       "}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "animation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d to optimize drawing.\n    \"\"\"\n\n    def __init__(self, fig, artists, *args, **kwargs):\n        # Internal list of artists drawn in the most recent frame.\n        self._drawn_artists = []\n\n        # Use the list of artists as the framedata, which will be iterated\n        # over by the machinery.\n        self._framedata = artists\n        super().__init__(fig, *args, **kwargs)\n\n    def _init_draw(self):\n        super()._init_draw()\n        # Make all the artists involved in *any* frame invisible\n        figs = set()\n        for f in self.new_frame_seq():\n            for artist in f:\n                artist.set_visible(False)\n                artist.set_animated(self._blit)\n                # Assemble a list of unique figures that need flushing\n                if artist.get_figure() not in figs:\n                    figs.add(artist.get_figure())\n\n        # Flush the needed figures\n        for fig in figs:\n            fig.canvas.draw_idle()\n\n    def _pre_draw(self, framedata, blit):\n        \"\"\"Clears artists from the last frame.\"\"\"\n        if blit:\n            # Let blit handle clearing\n            self._blit_clear(self._drawn_artists)\n        else:\n            # Otherwise, make all the artists from the previous frame invisible\n            for artist in self._drawn_artists:\n                artist.set_visible(False)\n\n    def _draw_frame(self, artists):\n        # Save the artists that were passed in as framedata for the other\n        # steps (esp. blitting) to use.\n        self._drawn_artists = artists\n\n        # Make all the artists from the current frame visible\n        for artist in artists:\n            artist.set_visible(True)\n\n\nclass FuncAnimation(TimedAnimation):\n    \"\"\"\n    `TimedAnimation` subclass that makes an animation by repeatedly calling\n    a function *func*.\n\n    .. note::\n\n        You must store the created Animation in a variable that lives as long\n        as the animation should run. Otherwise, the Animation object will be\n        garbage-collected and the a"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "blitting.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/animations", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/advanced/blitting\n\n.. _blitting:\n\n==================================\nFaster rendering by using blitting\n==================================\n\n*Blitting* is a `standard technique\n<https://en.wikipedia.org/wiki/Bit_blit>`__ in raster graphics that,\nin the context of Matplotlib, can be used to (drastically) improve\nperformance of interactive figures. For example, the\n:mod:`.animation` and :mod:`.widgets` modules use blitting\ninternally. Here, we demonstrate how to implement your own blitting, outside\nof these classes.\n\nBlitting speeds up repetitive drawing by rendering all non-changing\ngraphic elements into a background image once. Then, for every draw, only the\nchanging elements need to be drawn onto this background. For example,\nif the limits of an Axes have not changed, we can render the empty Axes\nincluding all ticks and labels once, and only draw the changing data later.\n\nThe strategy is\n\n- Prepare the constant background:\n\n  - Draw the figure, but exclude all artists that you want to animate by\n    marking them as *animated* (see `.Artist.set_animated`).\n  - Save a copy of the RBGA buffer.\n\n- Render the individual images:\n\n  - Restore the copy of the RGBA buffer.\n  - Redraw the animated artists using `.Axes.draw_artist` /\n    `.Figure.draw_artist`.\n  - Show the resulting image on the screen.\n\nOne consequence of this procedure is that your animated artists are always\ndrawn on top of the static artists.\n\nNot all backends support blitting.  You can check if a given canvas does via\nthe `.FigureCanvasBase.supports_blit` property.\n\n.. warning::\n\n   This code does not work with the macosx backend (but does work with other\n   GUI backends on Mac).\n\nMinimal example\n---------------\n\nWe can use the `.FigureCanvasAgg` methods\n`~.FigureCanvasAgg.copy_from_bbox` and\n`~.FigureCanvasAgg.restore_region` in conjunction with setting\n``animated=True`` on our artist to implement a minimal example that\nuses blitting to accelerate rendering\n\n\"\"\"\n\nimport "}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "backend_cairo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        return self.ctx.get_source().get_rgba()[:3]\n\n    def set_joinstyle(self, js):\n        self.ctx.set_line_join(_api.check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js\n\n    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))\n\n\nclass _CairoRegion:\n    def __init__(self, slices, data):\n        self._slices = slices\n        self._data = data\n\n\nclass FigureCanvasCairo(FigureCanvasBase):\n    @property\n    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n\n    def get_renderer(self):\n        return self._renderer\n\n    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)\n\n    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        i"}], "retrieved_count": 10, "cost_time": 1.5735211372375488}
{"question": "Where in Matplotlib is the event handling system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's event handling system is implemented across several key locations in the codebase. The main components are: 1) The core event system is defined in lib/matplotlib/backend_bases.py, which contains the abstract base classes Event, LocationEvent, MouseEvent, KeyEvent, and other event types, along with the callback management system, 2) The FigureCanvasBase class in backend_bases.py provides the mpl_connect() and mpl_disconnect() methods that manage event connections and the callback registry, 3) Backend-specific event handling implementations are located in the respective backend modules - for example, the macOS backend implementation is in src/_macosx.m, which contains Objective-C code for handling mouse clicks, key presses, and other GUI events, 4) The event processing pipeline is implemented in backend_bases.py with functions like _mouse_handler() and _key_handler() that process raw events and convert them into Matplotlib-specific event objects, 5) Event coordinate transformation and axes detection is handled in the LocationEvent class, which converts pixel coordinates to data coordinates and determines which Axes the event occurred in, 6) The interactive features like panning and zooming are implemented in lib/matplotlib/backend_bases.py through the NavigationToolbar2 class and related navigation classes, 7) Event loop integration for different GUI toolkits is handled in the respective backend implementations (Qt, Tk, GTK, Wx, macOS), each providing the necessary glue code to connect GUI toolkit events to Matplotlib's event system, 8) The event system documentation and examples are provided in galleries/users_explain/figure/event_handling.rst and galleries/examples/event_handling/. This architecture provides a GUI-neutral event interface while allowing backend-specific optimizations and integrations.", "score": null, "retrieved_content": [{"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ering different compared to mpl.\n            button for button, mask in [\n                (MouseButton.LEFT, 1),\n                (MouseButton.RIGHT, 2),\n                (MouseButton.MIDDLE, 4),\n                (MouseButton.BACK, 8),\n                (MouseButton.FORWARD, 16),\n            ] if event['buttons'] & mask  # State *after* press/release.\n        }\n        modifiers = event['modifiers']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ent propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       modifiers=self._mpl_modifiers(mods),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        if self.figure is None:\n            return\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      modifiers=self._mpl_modifiers(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        if self.manager:\n            self.send_event('figure_label', label=self.manager.get_window_title())\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_press_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_release_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\n            \"motion_notify_event\", self, *self._mpl_coords((x, y)),\n            buttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _mpl_buttons(self, controller):\n        # NOTE: This spews \"Broken accounting of active state\" warnings on\n        # right click on macOS.\n        surface = self.get_native().get_surface()\n        is_over, x, y, event_state = surface.get_device_position(\n            self.get_display().get_default_seat().get_pointer())\n        # NOTE: alternatively we could use\n        #   event_state = controller.get_current_event_state()\n        # but for button_press/button_release this would report the state\n        # *prior* to the event rather than after it; the above reports the\n        # state *after* it.\n        mod_table = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, G"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al implementation uses a Tk canvas,  this routine\n        is intended to hide that fact.\n        \"\"\"\n        return self._tkcanvas\n\n    def _event_mpl_coords(self, event):\n        # calling canvasx/canvasy allows taking scrollbars into account (i.e.\n        # the top of the widget may have been scrolled out of view).\n        return (self._tkcanvas.canvasx(event.x),\n                # flipy so y=0 is bottom of canvas\n                self.figure.bbox.height - self._tkcanvas.canvasy(event.y))\n\n    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, event):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def button_press_event(self, event, dblclick=False):\n        # set focus to the canvas so that it can receive keyboard events\n        self._tkcanvas.focus_set()\n\n        num = getattr(event, 'num', None)\n        if sys.platform == 'darwin':  # 2 and 3 are reversed.\n            num = {2: 3, 3: 2}.get(num, num)\n        MouseEvent(\"button_press_event\", self,\n                   *self._event_mpl_coords(event), num, dblclick=dblclick,\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def button_dblclick_event(self, event):\n        self.button_press_event(event, dblclick=True)\n\n    def button_release_event(self, event):\n        num = "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ial attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not over an Axes.\n    modifiers : frozenset\n        The keyboard modifiers currently being pressed (except for KeyEvent).\n    \"\"\"\n\n    _last_axes_ref = None\n\n    def __init__(self, name, canvas, x, y, guiEvent=None, *, modifiers=None):\n        super().__init__(name, canvas, guiEvent=guiEvent)\n        # x position - pixels from left of canvas\n        self.x = int(x) if x is not None else x\n        # y position - pixels from right of canvas\n        self.y = int(y) if y is not None else y\n        self.inaxes = None  # the Axes instance the mouse is over\n        self.xdata = None   # x coord of mouse in data coords\n        self.ydata = None   # y coord of mouse in data coords\n        self.modifiers = frozenset(modifiers if modifiers is not None else [])\n\n        if x is None or y is None:\n            # cannot check if event was in Axes if no (x, y) info\n            return\n\n        self._set_inaxes(self.canvas.inaxes((x, y))\n                         if self.canvas.mouse_grabber is None else\n    "}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}], "retrieved_count": 10, "cost_time": 1.5556917190551758}
{"question": "Where does the control flow when Matplotlib manages the figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "When Matplotlib manages the figure and axes hierarchy, the control flow follows a structured parent-child relationship system. The control flow operates as follows: 1) The Figure class serves as the top-level container and manages the overall hierarchy through its _axstack attribute, which tracks all Axes objects in insertion order, 2) When Axes are created (via add_subplot(), add_axes(), or subplots()), they are automatically added to the Figure's _axstack and their parent reference is set to the Figure, 3) The Figure's gca() method returns the current active Axes from the stack, and sca() method sets the current Axes, managing the active state, 4) Each Axes object maintains its own hierarchy of child Artists (lines, text, patches, etc.) and manages their lifecycle through methods like add_line(), add_patch(), etc., 5) The control flow for rendering follows the hierarchy: Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 6) When Artists are modified, the 'stale' state propagates up the hierarchy - if an Artist becomes stale, its parent Axes becomes stale, and if an Axes becomes stale, the parent Figure becomes stale, 7) The Figure manages layout through methods like subplots_adjust() and constrained_layout, which control the positioning and sizing of child Axes, 8) For complex layouts, the Figure can contain SubFigure objects, which themselves can contain Axes, creating a nested hierarchy, 9) The control flow ensures that changes to child objects properly notify their parents, enabling efficient rendering by only redrawing what has changed. This hierarchical management system provides a clean separation of concerns while maintaining the relationships necessary for proper rendering and interaction.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a not in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "port ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n                                   TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 98000, "end_line": 100000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           'button_press_event', button_press_handler)\n\n        self.toolmanager = (ToolManager(canvas.figure)\n                            if mpl.rcParams['toolbar'] == 'toolmanager'\n                            else None)\n        if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n                and self._toolbar2_class):\n            self.toolbar = self._toolbar2_class(self.canvas)\n        elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n                and self._toolmanager_toolbar_class):\n            self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n        else:\n            self.toolbar = None\n\n        if self.toolmanager:\n            tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                tools.add_tools_to_container(self.toolbar)\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current Axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        \"\"\"\n        Create a manager for a given *figure* using a specific *canvas_class*.\n\n        Backends should override this method if they have specific needs for\n        setting up the canvas or the manager.\n        \"\"\"\n        return cls(canvas_class(figure), num)\n\n    @classmethod\n    def start_main_loop(cls):\n        \"\"\"\n        Start the main event loop.\n\n        This method is called by `.FigureManagerBase.pyplot_show`, which is the\n        implementation of `.pyplot.show`.  To customize the behavior of\n        `.pyplot.show`, interactive backends should usually override\n        `~.FigureManagerBase.start_main_loop`; if more customized logic is\n        necessary, `~.FigureManagerBase.pyplot_show` can also be overridden.\n        \"\"\"\n\n    @classmethod\n    def pyplot_show(cls, *, block=None):\n        \"\"\"\n        Show all figures.  This method is the implementation of `."}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_pylab_helpers.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nManage figures for the pyplot interface.\n\"\"\"\n\nimport atexit\nfrom collections import OrderedDict\n\n\nclass Gcf:\n    \"\"\"\n    Singleton to maintain the relation between figures and their managers, and\n    keep track of and \"active\" figure and manager.\n\n    The canvas of a figure created through pyplot is associated with a figure\n    manager, which handles the interaction between the figure and the backend.\n    pyplot keeps track of figure managers using an identifier, the \"figure\n    number\" or \"manager number\" (which can actually be any hashable value);\n    this number is available as the :attr:`number` attribute of the manager.\n\n    This class is never instantiated; it consists of an `OrderedDict` mapping\n    figure/manager numbers to managers, and a set of class methods that\n    manipulate this `OrderedDict`.\n\n    Attributes\n    ----------\n    figs : OrderedDict\n        `OrderedDict` mapping numbers to managers; the active manager is at the\n        end.\n    \"\"\"\n\n    figs = OrderedDict()\n\n    @classmethod\n    def get_fig_manager(cls, num):\n        \"\"\"\n        If manager number *num* exists, make it the active one and return it;\n        otherwise return *None*.\n        \"\"\"\n        manager = cls.figs.get(num, None)\n        if manager is not None:\n            cls.set_active(manager)\n        return manager\n\n    @classmethod\n    def destroy(cls, num):\n        \"\"\"\n        Destroy manager *num* -- either a manager instance or a manager number.\n\n        In the interactive backends, this is bound to the window \"destroy\" and\n        \"delete\" events.\n\n        It is recommended to pass a manager instance, to avoid confusion when\n        two managers share the same number.\n        \"\"\"\n        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n            manager = num\n            if cls.figs.get(manager.num) is manager:\n                cls.figs.pop(manager.num)\n        else:\n            try:\n                manager = cls.figs.pop(num)\n            except KeyError:\n      "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instances you want to customize.  Here is an\n# example which turns all the Axes grids on::\n#\n#     for ax in fig.axes:\n#         ax.grid(True)\n#\n#\n# The figure also has its own ``images``, ``lines``, ``patches`` and ``text``\n# attributes, which you can use to add primitives directly. When doing so, the\n# default coordinate system for the ``Figure`` will simply be in pixels (which\n# is not usually what you want). If you instead use Figure-level methods to add\n# Artists (e.g., using `.Figure.text` to add text), then the default coordinate\n# system will be \"figure coordinates\" where (0, 0) is the bottom-left of the\n# figure and (1, 1) is the top-right of the figure.\n#\n# As with all ``Artist``\\s, you can control this coordinate system by setting\n# the transform property. You can explicitly use \"figure coordinates\" by\n# setting the ``Artist`` transform to :attr:`!fig.transFigure`:\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\n\nl1 = lines.Line2D([0, 1], [0, 1], transform=fig.transFigure, fi"}, {"start_line": 106000, "end_line": 108000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n            may only be shown briefly or not shown at all if you or your\n            environment are not managing an event loop.\n\n            Use cases for `.Figure.show` include running this from a GUI\n            application (where there is persistently an event loop running) or\n            from a shell, like IPython, that install an input hook to allow the\n            interactive shell to accept input while the figure is also being\n            shown and interactive.  Some, but not all, GUI toolkits will\n            register an input hook on import.  See :ref:`cp_integration` for\n            more details.\n\n            If you're in a shell without input hook integration or executing a\n            python script, you should use `matplotlib.pyplot.show` with\n            ``block=True`` instead, which takes care of starting and running\n            the event loop for you.\n\n        Parameters\n        ----------\n        warn : bool, default: True\n            If ``True`` and we are not running headless (i.e. on Linux with an\n            unset DISPLAY), issue warning when called on a non-GUI backend.\n\n        \"\"\"\n        if self.canvas.manager is None:\n            raise AttributeError(\n                \"Figure.show works only for figures managed by pyplot, \"\n                \"normally created by pyplot.figure()\")\n        try:\n            self.canvas.manager.show()\n        except NonGuiException as exc:\n            if warn:\n                _api.warn_external(str(exc))\n\n    @property\n    def axes(self):\n        \"\"\"\n        List of Axes in the Figure. You can access and modify the Axes in the\n        Figure through this list.\n\n        Do not modify the list itself. Instead, use `~Figure.add_axes`,\n        `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.\n\n        Note: The `.Figure.axes` property and `~.Figure.get_axes` method are\n        equivalent.\n        \"\"\"\n        return self._axstack.as_list()\n\n    get_axes = axes.fget\n\n    @property\n    def number(se"}, {"start_line": 98000, "end_line": 100000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_external(\n                    \"The Figure parameters 'tight_layout' and \"\n                    \"'constrained_layout' cannot be used together. Please use \"\n                    \"'layout' parameter\")\n            self.set_layout_engine(layout='tight')\n            if isinstance(tight_layout, dict):\n                self.get_layout_engine().set(**tight_layout)\n        elif constrained_layout is not None:\n            if isinstance(constrained_layout, dict):\n                self.set_layout_engine(layout='constrained')\n                self.get_layout_engine().set(**constrained_layout)\n            elif constrained_layout:\n                self.set_layout_engine(layout='constrained')\n\n        else:\n            # everything is None, so use default:\n            self.set_layout_engine(layout=layout)\n\n        # Callbacks traditionally associated with the canvas (and exposed with\n        # a proxy property), but that actually need to be on the figure for\n        # pickling.\n        self._canvas_callbacks = cbook.CallbackRegistry(\n            signals=FigureCanvasBase.events)\n        connect = self._canvas_callbacks._connect_picklable\n        self._mouse_key_ids = [\n            connect('key_press_event', backend_bases._key_handler),\n            connect('key_release_event', backend_bases._key_handler),\n            connect('key_release_event', backend_bases._key_handler),\n            connect('button_press_event', backend_bases._mouse_handler),\n            connect('button_release_event', backend_bases._mouse_handler),\n            connect('scroll_event', backend_bases._mouse_handler),\n            connect('motion_notify_event', backend_bases._mouse_handler),\n        ]\n        self._button_pick_id = connect('button_press_event', self.pick)\n        self._scroll_pick_id = connect('scroll_event', self.pick)\n\n        figsize = mpl._val_or_rc(figsize, 'figure.figsize')\n        dpi = mpl._val_or_rc(dpi, 'figure.dpi')\n        facecolor = mpl._val_or_rc(facecolor, 'figure.facecolor')\n        edgecol"}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    fig.canvas.draw_idle()\n\n\ndef gcf() -> Figure:\n    \"\"\"\n    Get the current figure.\n\n    If there is currently no figure on the pyplot figure stack, a new one is\n    created using `~.pyplot.figure()`.  (To test whether there is currently a\n    figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n    is empty.)\n    \"\"\"\n    manager = _pylab_helpers.Gcf.get_active()\n    if manager is not None:\n        return manager.canvas.figure\n    else:\n        return figure()\n\n\ndef fignum_exists(num: int | str) -> bool:\n    \"\"\"\n    Return whether the figure with the given id exists.\n\n    Parameters\n    ----------\n    num : int or str\n        A figure identifier.\n\n    Returns\n    -------\n    bool\n        Whether or not a figure with id *num* exists.\n    \"\"\"\n    return (\n        _pylab_helpers.Gcf.has_fignum(num)\n        if isinstance(num, int)\n        else num in get_figlabels()\n    )\n\n\ndef get_fignums() -> list[int]:\n    \"\"\"Return a list of existing figure numbers.\"\"\"\n    return sorted(_pylab_helpers.Gcf.figs)\n\n\ndef get_figlabels() -> list[Any]:\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    managers = _pylab_helpers.Gcf.get_all_fig_managers()\n    managers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in managers]\n\n\ndef get_current_fig_manager() -> FigureManagerBase | None:\n    \"\"\"\n    Return the figure manager of the current figure.\n\n    The figure manager is a container for the actual backend-depended window\n    that displays the figure on screen.\n\n    If no current figure exists, a new one is created, and its figure\n    manager is returned.\n\n    Returns\n    -------\n    `.FigureManagerBase` or backend-dependent subclass thereof\n    \"\"\"\n    return gcf().canvas.manager\n\n\n@overload\ndef connect(s: MouseEventType, func: Callable[[MouseEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: KeyEventType, func: Callable[[KeyEvent], Any]) -> int: ...\n\n\n@overload\ndef connect(s: PickEventType, func: Callable[[PickEvent], Any]) -> int: ."}], "retrieved_count": 10, "cost_time": 1.567556619644165}
{"question": "Where does Matplotlib store its backend implementations?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib stores its backend implementations in several organized locations within the codebase. The main storage locations are: 1) The lib/matplotlib/backends/ directory contains most of the Python-based backend implementations, organized by type - interactive backends (like qt5agg.py, tkagg.py, gtk3agg.py) and non-interactive backends (like pdf.py, svg.py, ps.py), 2) The src/ directory contains C++ implementations for performance-critical backends, particularly the Agg backend in src/_backend_agg.h and src/_backend_agg.cpp, which is the primary raster renderer, 3) The lib/matplotlib/backends/backend_bases.py file contains the abstract base classes (RendererBase, FigureCanvasBase, etc.) that define the interface all backends must implement, 4) Backend-specific wrapper code and bindings are stored in src/_backend_agg_wrapper.cpp for the Agg backend, and similar wrapper files for other C++ backends, 5) The lib/matplotlib/backends/backend_template.py provides a template for creating new backends, serving as documentation and a starting point for custom backend development, 6) Configuration and registration of available backends is handled in lib/matplotlib/backends/__init__.py, which maintains the mapping between backend names and their implementation classes, 7) Some specialized backends like the web backend are stored in lib/matplotlib/backends/web_backend/ with their associated JavaScript and HTML files. This organization separates the abstract interface definitions from the concrete implementations, allowing for easy addition of new backends while maintaining a consistent API across all output formats and GUI toolkits.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n            self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entr"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n    "}, {"start_line": 0, "end_line": 206, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from .registry import BackendFilter, backend_registry  # noqa: F401\n\n# NOTE: plt.switch_backend() (called at import time) will add a \"backend\"\n# attribute here for backcompat.\n_QT_FORCE_QT5_BINDING = False\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entry.name, entry.value) for entry in entry_points]\n\n        # For backward compatibility, if matplotlib-inline and/or ipympl are installed\n        # but too old to include entry points, create them. Do not import ipympl\n        # directly as this calls matplotlib.use() whilst in this function.\n        def backward_compatible_entry_points(\n                entries, module_name, threshold_version, names, target):\n            from matplotlib import _parse_to_version_info\n            try:\n                module_version = im.version(module_name)\n                if _parse_to_version_info(module_version) < threshold_version:\n                    for name in names:\n                        entries.append((name, target))\n            except im.PackageNotFoundError:\n                pass\n\n        names = [entry[0] for entry in entries]\n        if \"inline\" not in names:\n            backward_compatible_entry_points(\n                entries, \"matplotlib_inline\", (0, 1, 7), [\"inline\"],\n                \"matp"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-------\n        list of str\n            Backend names.\n        \"\"\"\n        self._ensure_entry_points_loaded()\n        return [*self.list_builtin(), *self._backend_to_gui_framework]\n\n    def list_builtin(self, filter_=None):\n        \"\"\"\n        Return list of backends that are built into Matplotlib.\n\n        Parameters\n        ----------\n        filter_ : `~.BackendFilter`, optional\n            Filter to apply to returned backends. For example, to return only\n            non-interactive backends use `.BackendFilter.NON_INTERACTIVE`.\n\n        Returns\n        -------\n        list of str\n            Backend names.\n        \"\"\"\n        if filter_ == BackendFilter.INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v != \"headless\"]\n        elif filter_ == BackendFilter.NON_INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v == \"headless\"]\n\n        return [*self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK]\n\n    def list_gui_frameworks(self):\n        \"\"\"\n        Return list of GUI frameworks used by Matplotlib backends.\n\n        Returns\n        -------\n        list of str\n            GUI framework names.\n        \"\"\"\n        return [k for k in self._GUI_FRAMEWORK_TO_BACKEND if k != \"headless\"]\n\n    def load_backend_module(self, backend):\n        \"\"\"\n        Load and return the module containing the specified backend.\n\n        Parameters\n        ----------\n        backend : str\n            Name of backend to load.\n\n        Returns\n        -------\n        Module\n            Module containing backend.\n        \"\"\"\n        module_name = self._backend_module_name(backend)\n        return importlib.import_module(module_name)\n\n    def resolve_backend(self, backend):\n        \"\"\"\n        Return the backend and GUI framework for the specified backend name.\n\n        If the GUI framework is not yet known then it will be determined by loading the\n        backend module a"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from enum import Enum\nimport importlib\n\n\nclass BackendFilter(Enum):\n    \"\"\"\n    Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n    .. versionadded:: 3.9\n    \"\"\"\n    INTERACTIVE = 0\n    NON_INTERACTIVE = 1\n\n\nclass BackendRegistry:\n    \"\"\"\n    Registry of backends available within Matplotlib.\n\n    This is the single source of truth for available backends.\n\n    All use of ``BackendRegistry`` should be via the singleton instance\n    ``backend_registry`` which can be imported from ``matplotlib.backends``.\n\n    Each backend has a name, a module name containing the backend code, and an\n    optional GUI framework that must be running if the backend is interactive.\n    There are three sources of backends: built-in (source code is within the\n    Matplotlib repository), explicit ``module://some.backend`` syntax (backend is\n    obtained by loading the module), or via an entry point (self-registering\n    backend in an external package).\n\n    .. versionadded:: 3.9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of g"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "BUILTIN_BACKEND_TO_GUI_FRAMEWORK]\n\n    def list_gui_frameworks(self):\n        \"\"\"\n        Return list of GUI frameworks used by Matplotlib backends.\n\n        Returns\n        -------\n        list of str\n            GUI framework names.\n        \"\"\"\n        return [k for k in self._GUI_FRAMEWORK_TO_BACKEND if k != \"headless\"]\n\n    def load_backend_module(self, backend):\n        \"\"\"\n        Load and return the module containing the specified backend.\n\n        Parameters\n        ----------\n        backend : str\n            Name of backend to load.\n\n        Returns\n        -------\n        Module\n            Module containing backend.\n        \"\"\"\n        module_name = self._backend_module_name(backend)\n        return importlib.import_module(module_name)\n\n    def resolve_backend(self, backend):\n        \"\"\"\n        Return the backend and GUI framework for the specified backend name.\n\n        If the GUI framework is not yet known then it will be determined by loading the\n        backend module and checking the ``FigureCanvas.required_interactive_framework``\n        attribute.\n\n        This function only loads entry points if they have not already been loaded and\n        the backend is not built-in and not of ``module://some.backend`` format.\n\n        Parameters\n        ----------\n        backend : str or None\n            Name of backend, or None to use the default backend.\n\n        Returns\n        -------\n        backend : str\n            The backend name.\n        framework : str or None\n            The GUI framework, which will be None for a backend that is non-interactive.\n        \"\"\"\n        if isinstance(backend, str):\n            if not backend.startswith(\"module://\"):\n                backend = backend.lower()\n        else:  # Might be _auto_backend_sentinel or None\n            # Use whatever is already running...\n            from matplotlib import get_backend\n            backend = get_backend()\n\n        # Is backend already known (built-in or dynamically loaded)?\n      "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "odule://ipympl.backend_nbagg\": \"widget\",\n            \"module://matplotlib_inline.backend_inline\": \"inline\",\n        }\n        backend = backwards_compat.get(backend, backend)\n\n        if (backend in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK or\n                backend in self._backend_to_gui_framework):\n            return True\n\n        if backend.startswith(\"module://\"):\n            self._backend_to_gui_framework[backend] = \"unknown\"\n            return True\n\n        # Only load entry points if really need to and not already done so.\n        self._ensure_entry_points_loaded()\n        if backend in self._backend_to_gui_framework:\n            return True\n\n        return False\n\n    def list_all(self):\n        \"\"\"\n        Return list of all known backends.\n\n        These include built-in backends and those obtained at runtime either from entry\n        points or explicit ``module://some.backend`` syntax.\n\n        Entry points will be loaded if they haven't been already.\n\n        Returns\n        -------\n        list of str\n            Backend names.\n        \"\"\"\n        self._ensure_entry_points_loaded()\n        return [*self.list_builtin(), *self._backend_to_gui_framework]\n\n    def list_builtin(self, filter_=None):\n        \"\"\"\n        Return list of backends that are built into Matplotlib.\n\n        Parameters\n        ----------\n        filter_ : `~.BackendFilter`, optional\n            Filter to apply to returned backends. For example, to return only\n            non-interactive backends use `.BackendFilter.NON_INTERACTIVE`.\n\n        Returns\n        -------\n        list of str\n            Backend names.\n        \"\"\"\n        if filter_ == BackendFilter.INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v != \"headless\"]\n        elif filter_ == BackendFilter.NON_INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v == \"headless\"]\n\n        return [*self._"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_backend_registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ll()\n    assert 'inline' in backends\n\n\ndef test_entry_points_ipympl():\n    pytest.importorskip('ipympl')\n    backends = backend_registry.list_all()\n    assert 'ipympl' in backends\n    assert 'widget' in backends\n\n\ndef test_entry_point_name_shadows_builtin(clear_backend_registry):\n    with pytest.raises(RuntimeError):\n        backend_registry._validate_and_store_entry_points(\n            [('qtagg', 'module1')])\n\n\ndef test_entry_point_name_duplicate(clear_backend_registry):\n    with pytest.raises(RuntimeError):\n        backend_registry._validate_and_store_entry_points(\n            [('some_name', 'module1'), ('some_name', 'module2')])\n\n\ndef test_entry_point_identical(clear_backend_registry):\n    # Issue https://github.com/matplotlib/matplotlib/issues/28367\n    # Multiple entry points with the same name and value (value is the module)\n    # are acceptable.\n    n = len(backend_registry._name_to_module)\n    backend_registry._validate_and_store_entry_points(\n        [('some_name', 'some.module'), ('some_name', 'some.module')])\n    assert len(backend_registry._name_to_module) == n+1\n    assert backend_registry._name_to_module['some_name'] == 'module://some.module'\n\n\ndef test_entry_point_name_is_module(clear_backend_registry):\n    with pytest.raises(RuntimeError):\n        backend_registry._validate_and_store_entry_points(\n            [('module://backend.something', 'module1')])\n\n\n@pytest.mark.parametrize('backend', [\n    'agg',\n    'module://matplotlib.backends.backend_agg',\n])\ndef test_load_entry_points_only_if_needed(clear_backend_registry, backend):\n    assert not backend_registry._loaded_entry_points\n    check = backend_registry.resolve_backend(backend)\n    assert check == (backend, None)\n    assert not backend_registry._loaded_entry_points\n    backend_registry.list_all()  # Force load of entry points\n    assert backend_registry._loaded_entry_points\n\n\n@pytest.mark.parametrize(\n    'gui_or_backend, expected_backend, expected_gui',\n    [\n        ('agg', 'agg', None),\n     "}], "retrieved_count": 10, "cost_time": 1.5625782012939453}
{"question": "Where in Matplotlib's codebase is the core rendering system implemented?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's core rendering system is implemented across several key locations in the codebase. The main components are: 1) The abstract base class RendererBase in lib/matplotlib/backend_bases.py defines the interface that all renderers must implement, including methods like draw_path(), draw_image(), draw_text(), and draw_markers(), 2) The Agg backend implementation, which is the primary raster renderer, is located in src/_backend_agg.h and src/_backend_agg.cpp, containing the RendererAgg class that implements the actual pixel-level drawing operations using the Anti-Grain Geometry library, 3) The backend wrapper code in src/_backend_agg_wrapper.cpp provides Python bindings for the C++ renderer implementation, 4) Path processing and optimization is implemented in src/path_converters.h, which contains classes like PathNanRemover, PathClipper, PathSnapper, and PathSimplifier that process geometric paths before rendering, 5) Image resampling and transformation is handled in src/_image_resample.h, which implements high-quality image scaling and transformation algorithms, 6) The Artist class in lib/matplotlib/artist.py provides the draw() method interface that connects the high-level plotting objects to the low-level renderers, 7) Backend-specific implementations for different output formats (PDF, SVG, PS) are located in lib/matplotlib/backends/ directory, each implementing the RendererBase interface for their specific format. The core rendering pipeline flows from Artist objects through the renderer interface to the specific backend implementations, with the Agg backend serving as the reference implementation for raster graphics.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s* and *gid* (if set) as id.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def close_group(self, s):\n        \"\"\"\n        Close a grouping element with label *s*.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        \"\"\"Draw a `~.path.Path` instance using the given affine transform.\"\"\"\n        raise NotImplementedError\n\n    def draw_markers(self, gc, marker_path, marker_trans, path,\n                     trans, rgbFace=None):\n        \"\"\"\n        Draw a marker at each of *path*'s vertices (excluding control points).\n\n        The base (fallback) implementation makes multiple calls to `draw_path`.\n        Backends may want to override this method in order to draw the marker\n        only once and reuse it multiple times.\n\n        Parameters\n        ----------\n        gc : `.GraphicsContextBase`\n            The graphics context.\n        marker_path :"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAbstract base classes define the primitives that renderers and\ngraphics contexts must implement to serve as a Matplotlib backend.\n\n`RendererBase`\n    An abstract base class to handle drawing/rendering operations.\n\n`FigureCanvasBase`\n    The abstraction layer that separates the `.Figure` from the backend\n    specific details like a user interface drawing area.\n\n`GraphicsContextBase`\n    An abstract base class that provides color, line styles, etc.\n\n`Event`\n    The base class for all of the Matplotlib event handling.  Derived classes\n    such as `KeyEvent` and `MouseEvent` store the meta data like keys and\n    buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.\n\n`ShowBase`\n    The base class for the ``Show`` class of each interactive backend; the\n    'show' callable is then set to ``Show.__call__``.\n\n`ToolContainerBase`\n    The base class for the Toolbar class of each interactive backend.\n\"\"\"\n\nfrom collections import namedtuple\nfrom contextlib import ExitStack, contextmanager, nullcontext\nfrom enum import Enum, IntEnum\nimport functools\nimport importlib\nimport inspect\nimport io\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport signal\nimport socket\nimport sys\nimport time\nimport weakref\nfrom weakref import WeakKeyDictionary\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import (\n    _api, backend_tools as tools, cbook, colors, _docstring, text,\n    _tight_bbox, transforms, widgets, is_interactive, rcParams)\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_managers import ToolManager\nfrom matplotlib.cbook import _setattr_cm\nfrom matplotlib.layout_engine import ConstrainedLayoutEngine\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib._enums import JoinStyle, CapStyle\n\n\n_log = logging.getLogger(__name__)\n_default_filetypes = {\n    'eps': 'Encapsulated Postscript',\n    'gif': 'Graphics Interchange Format',\n    'jpg': "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#####################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file t"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=\"wx\", obj_type=\"backend\", removal=\"the future\",\n    alternative=\"wxagg\",\n    addendum=\"See the Matplotlib usage FAQ for more info on backends.\")\nclass RendererWx(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles. It acts as the\n    'renderer' instance used by many classes in the hierarchy.\n    \"\"\"\n    # In wxPython, drawing is performed on a wxDC instance, which will\n    # generally be mapped to the client area of the window displaying\n    # the plot. Under wxPython, the wxDC instance has a wx.Pen which\n    # describes the colour and weight of any lines drawn, and a wxBrush\n    # which describes the fill colour of any closed polygon.\n\n    # Font styles, families and weight.\n    fontweights = {\n        100: wx.FONTWEIGHT_LIGHT,\n        200: wx.FONTWEIGHT_LIGHT,\n        300: wx.FONTWEIGHT_LIGHT,\n        400: wx.FONTWEIGHT_NORMAL,\n        500: wx.FONTWEIGHT_NORMAL,\n        600: wx.FONTWEIGHT_NORMAL,\n        700: wx.FONTWEIGHT_BOLD,\n        800: wx.FONTWEIGHT_BOLD,\n        900: wx.FONTWEIGHT_BOLD,\n        'ultralight': wx.FONTWEIGHT_LIGHT,\n        'light': wx.FONTWEIGHT_LIGHT,\n        'normal': wx.FONTWEIGHT_NORMAL,\n        'medium': wx.FONTWEIGHT_NORMAL,\n        'semibold': wx.FONTWEIGHT_NORMAL,\n        'bold': wx.FONTWEIGHT_BOLD,\n        'heavy': wx.FONTWEIGHT_BOLD,\n        'ultrabold': wx.FONTWEIGHT_BOLD,\n        'black': wx.FONTWEIGHT_BOLD,\n    }\n    fontangles = {\n        'italic': wx.FONTSTYLE_ITALIC,\n        'normal': wx.FONTSTYLE_NORMAL,\n        'oblique': wx.FONTSTYLE_SLANT,\n    }\n\n    # wxPython allows for portable font styles, choosing them appropriately for\n    # the target platform. Map some standard font names to the portable styles.\n    # QUESTION: Is it wise to agree to standard fontnames across all backends?\n    fontnames = {\n        'Sans': wx.FONTFAMILY_SWISS,\n        'Roman': wx.FONTFAMILY_ROMAN,\n        'Script': wx.FONTFAMILY_SCRIPT,\n        'Decorative'"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplotlib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in whic"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}], "retrieved_count": 10, "cost_time": 1.5676822662353516}
{"question": "Where are Matplotlib's backend class definitions located?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's backend class definitions are located across several organized locations in the codebase. The main locations are: 1) The abstract base classes are defined in lib/matplotlib/backend_bases.py, which contains RendererBase, FigureCanvasBase, GraphicsContextBase, Event classes, and other fundamental backend interfaces, 2) The lib/matplotlib/backends/ directory contains most of the Python-based backend implementations, organized by type - interactive backends (like qt5agg.py, tkagg.py, gtk3agg.py) and non-interactive backends (like pdf.py, svg.py, ps.py), 3) The src/ directory contains C++ implementations for performance-critical backends, particularly the Agg backend in src/_backend_agg.h and src/_backend_agg.cpp, which defines the RendererAgg class and related C++ backend components, 4) The src/_backend_agg_wrapper.cpp file provides Python bindings for the C++ renderer implementation, 5) The lib/matplotlib/backends/backend_bases.pyi file contains type hints for the backend base classes, 6) Each backend module typically defines its own FigureCanvas, FigureManager, and Renderer classes that inherit from the base classes in backend_bases.py, 7) The backend registration system is managed through the _Backend class in backend_bases.py, which provides the @_Backend.export decorator for registering new backends, 8) Backend-specific event handling implementations are located in their respective backend modules, with the core event system defined in backend_bases.py. This organization allows for clean separation between the abstract backend interface and specific implementations while maintaining consistency across different output formats and GUI toolkits.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 206, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from .registry import BackendFilter, backend_registry  # noqa: F401\n\n# NOTE: plt.switch_backend() (called at import time) will add a \"backend\"\n# attribute here for backcompat.\n_QT_FORCE_QT5_BINDING = False\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAbstract base classes define the primitives that renderers and\ngraphics contexts must implement to serve as a Matplotlib backend.\n\n`RendererBase`\n    An abstract base class to handle drawing/rendering operations.\n\n`FigureCanvasBase`\n    The abstraction layer that separates the `.Figure` from the backend\n    specific details like a user interface drawing area.\n\n`GraphicsContextBase`\n    An abstract base class that provides color, line styles, etc.\n\n`Event`\n    The base class for all of the Matplotlib event handling.  Derived classes\n    such as `KeyEvent` and `MouseEvent` store the meta data like keys and\n    buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.\n\n`ShowBase`\n    The base class for the ``Show`` class of each interactive backend; the\n    'show' callable is then set to ``Show.__call__``.\n\n`ToolContainerBase`\n    The base class for the Toolbar class of each interactive backend.\n\"\"\"\n\nfrom collections import namedtuple\nfrom contextlib import ExitStack, contextmanager, nullcontext\nfrom enum import Enum, IntEnum\nimport functools\nimport importlib\nimport inspect\nimport io\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport signal\nimport socket\nimport sys\nimport time\nimport weakref\nfrom weakref import WeakKeyDictionary\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import (\n    _api, backend_tools as tools, cbook, colors, _docstring, text,\n    _tight_bbox, transforms, widgets, is_interactive, rcParams)\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_managers import ToolManager\nfrom matplotlib.cbook import _setattr_cm\nfrom matplotlib.layout_engine import ConstrainedLayoutEngine\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib._enums import JoinStyle, CapStyle\n\n\n_log = logging.getLogger(__name__)\n_default_filetypes = {\n    'eps': 'Encapsulated Postscript',\n    'gif': 'Graphics Interchange Format',\n    'jpg': "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n    "}, {"start_line": 133000, "end_line": 134175, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s.modules.get(\"matplotlib.pyplot\"), \"show\", None)\n            ipython_pylab = hasattr(pyplot_show, \"_needmain\")\n            block = not ipython_pylab and not is_interactive()\n        if block:\n            cls.mainloop()\n\n    # This method is the one actually exporting the required methods.\n\n    @staticmethod\n    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls\n\n\nclass ShowBase(_Backend):\n    \"\"\"\n    Simple base class to generate a ``show()`` function in backends.\n\n    Subclass must override ``mainloop()`` method.\n    \"\"\"\n\n    def __call__(self, block=None):\n        return self.show(block=block)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from enum import Enum\nimport importlib\n\n\nclass BackendFilter(Enum):\n    \"\"\"\n    Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n    .. versionadded:: 3.9\n    \"\"\"\n    INTERACTIVE = 0\n    NON_INTERACTIVE = 1\n\n\nclass BackendRegistry:\n    \"\"\"\n    Registry of backends available within Matplotlib.\n\n    This is the single source of truth for available backends.\n\n    All use of ``BackendRegistry`` should be via the singleton instance\n    ``backend_registry`` which can be imported from ``matplotlib.backends``.\n\n    Each backend has a name, a module name containing the backend code, and an\n    optional GUI framework that must be running if the backend is interactive.\n    There are three sources of backends: built-in (source code is within the\n    Matplotlib repository), explicit ``module://some.backend`` syntax (backend is\n    obtained by loading the module), or via an entry point (self-registering\n    backend in an external package).\n\n    .. versionadded:: 3.9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of g"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive() -> None:\n            if matplotlib.is_interactive():\n                manager = _pylab_helpers.Gcf.get_active()\n                if manager:\n                    manager.canvas.draw_idle()\n\n        backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n            new_figure_manager_given_figure)\n        backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n            new_figure_manager)\n        backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n            draw_if_interactive)\n\n    # If the manager explicitly overrides pyplot_show, use it even if a global\n    # show is already present, as the latter may be here for backcompat.\n    manager_class = getattr(canvas_class, \"manager_class\", None)\n    # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n    # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n    # thus always different (being bound to different classes).  We also "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n            self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entr"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-------\n        list of str\n            Backend names.\n        \"\"\"\n        self._ensure_entry_points_loaded()\n        return [*self.list_builtin(), *self._backend_to_gui_framework]\n\n    def list_builtin(self, filter_=None):\n        \"\"\"\n        Return list of backends that are built into Matplotlib.\n\n        Parameters\n        ----------\n        filter_ : `~.BackendFilter`, optional\n            Filter to apply to returned backends. For example, to return only\n            non-interactive backends use `.BackendFilter.NON_INTERACTIVE`.\n\n        Returns\n        -------\n        list of str\n            Backend names.\n        \"\"\"\n        if filter_ == BackendFilter.INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v != \"headless\"]\n        elif filter_ == BackendFilter.NON_INTERACTIVE:\n            return [k for k, v in self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK.items()\n                    if v == \"headless\"]\n\n        return [*self._BUILTIN_BACKEND_TO_GUI_FRAMEWORK]\n\n    def list_gui_frameworks(self):\n        \"\"\"\n        Return list of GUI frameworks used by Matplotlib backends.\n\n        Returns\n        -------\n        list of str\n            GUI framework names.\n        \"\"\"\n        return [k for k in self._GUI_FRAMEWORK_TO_BACKEND if k != \"headless\"]\n\n    def load_backend_module(self, backend):\n        \"\"\"\n        Load and return the module containing the specified backend.\n\n        Parameters\n        ----------\n        backend : str\n            Name of backend to load.\n\n        Returns\n        -------\n        Module\n            Module containing backend.\n        \"\"\"\n        module_name = self._backend_module_name(backend)\n        return importlib.import_module(module_name)\n\n    def resolve_backend(self, backend):\n        \"\"\"\n        Return the backend and GUI framework for the specified backend name.\n\n        If the GUI framework is not yet known then it will be determined by loading the\n        backend module a"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hics context provides the color, line styles, etc.  See the cairo\n    and postscript backends for examples of mapping the graphics context\n    attributes (cap styles, join styles, line widths, colors) to a particular\n    backend.  In cairo this is done by wrapping a cairo.Context object and\n    forwarding the appropriate calls to it using a dictionary mapping styles\n    to gdk constants.  In Postscript, all the work is done by the renderer,\n    mapping line styles to postscript calls.\n\n    If it's more appropriate to do the mapping at the renderer level (as in\n    the postscript backend), you don't need to override any of the GC methods.\n    If it's more appropriate to wrap an instance (as in the cairo backend) and\n    do the mapping here, you'll need to override several of the setter\n    methods.\n\n    The base GraphicsContext stores colors as an RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\n    appropriate for your backend.\n    \"\"\"\n\n\n########################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_e"}], "retrieved_count": 10, "cost_time": 0.33594655990600586}
{"question": "Where in Matplotlib's codebase is the \"Figure\" class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The Figure class is defined in lib/matplotlib/figure.py. Specifically, it is defined as a subclass of FigureBase starting at line 2424 in the file. The Figure class inherits from FigureBase, which itself inherits from Artist, and provides the top-level container for all plot elements. The Figure class definition includes its constructor (__init__ method) and all the methods specific to managing figures, such as add_subplot(), subplots(), savefig(), and other figure-level operations. The file also contains the FigureBase class (starting at line 118) which provides the base functionality shared between Figure and SubFigure classes, including methods for adding and managing child Artists. The Figure class is the main entry point for creating plots in Matplotlib and serves as the root of the Artist hierarchy, containing all Axes objects and other plot elements.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 91000, "end_line": 93000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cstring inherited\n\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n\n        artists = self._get_draw_artists(renderer)\n\n        try:\n            renderer.open_group('subfigure', gid=self.get_gid())\n            self.patch.draw(renderer)\n            mimage._draw_list_compositing_images(\n                renderer, self, artists, self.get_figure(root=True).suppressComposite)\n            renderer.close_group('subfigure')\n\n        finally:\n            self.stale = False\n\n\n@_docstring.interpd\nclass Figure(FigureBase):\n    \"\"\"\n    The top level container for all the plot elements.\n\n    See `matplotlib.figure` for an index of class methods.\n\n    Attributes\n    ----------\n    patch\n        The `.Rectangle` instance representing the figure background patch.\n\n    suppressComposite\n        For multiple images, the figure will make composite images\n        depending on the renderer option_image_nocomposite function.  If\n        *suppressComposite* is a boolean, this will override the renderer.\n    \"\"\"\n\n    # we want to cache the fonts and mathtext at a global level so that when\n    # multiple figures are created we can reuse them.  This helps with a bug on\n    # windows where the creation of too many figures leads to too many open\n    # file handles and improves the performance of parsing mathtext.  However,\n    # these global caches are not thread safe.  The solution here is to let the\n    # Figure acquire a shared lock at the start of the draw, and release it when it\n    # is done.  This allows multiple renderers to share the cached fonts and\n    # parsed text, but only one figure can draw at a time and so the font cache\n    # and mathtext cache are used by only one renderer at a time.\n\n    _render_lock = threading.RLock()\n\n    def __str__(self):\n        return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n\n    def __repr__(self):\n        return \"<{clsname} size {h:g}x{w:g} with {naxes} Axes>\".format(\n        "}, {"start_line": 61000, "end_line": 63000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ure : `~matplotlib.figure.Figure`\n        A high-level figure instance.\n    \"\"\"\n\n    # Set to one of {\"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\", \"macosx\"} if an\n    # interactive framework is required, or None otherwise.\n    required_interactive_framework = None\n\n    # The manager class instantiated by new_manager.\n    # (This is defined as a classproperty because the manager class is\n    # currently defined *after* the canvas class, but one could also assign\n    # ``FigureCanvasBase.manager_class = FigureManagerBase``\n    # after defining both classes.)\n    manager_class = _api.classproperty(lambda cls: FigureManagerBase)\n\n    events = [\n        'resize_event',\n        'draw_event',\n        'key_press_event',\n        'key_release_event',\n        'button_press_event',\n        'button_release_event',\n        'scroll_event',\n        'motion_notify_event',\n        'pick_event',\n        'figure_enter_event',\n        'figure_leave_event',\n        'axes_enter_event',\n        'axes_leave_event',\n        'close_event'\n    ]\n\n    fixed_dpi = None\n\n    filetypes = _default_filetypes\n\n    @_api.classproperty\n    def supports_blit(cls):\n        \"\"\"If this Canvas sub-class supports blitting.\"\"\"\n        return (hasattr(cls, \"copy_from_bbox\")\n                and hasattr(cls, \"restore_region\"))\n\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#####################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file t"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " defaults to rc figure.facecolor\n    facecolor: ColorType | None = None,\n    # defaults to rc figure.edgecolor\n    edgecolor: ColorType | None = None,\n    frameon: bool = True,\n    FigureClass: type[Figure] = Figure,\n    clear: bool = False,\n    **kwargs\n) -> Figure:\n    \"\"\"\n    Create a new figure, or activate an existing figure.\n\n    Parameters\n    ----------\n    num : int or str or `.Figure` or `.SubFigure`, optional\n        A unique identifier for the figure.\n\n        If a figure with that identifier already exists, this figure is made\n        active and returned. An integer refers to the ``Figure.number``\n        attribute, a string refers to the figure label.\n\n        If there is no figure with the identifier or *num* is not given, a new\n        figure is created, made active and returned.  If *num* is an int, it\n        will be used for the ``Figure.number`` attribute, otherwise, an\n        auto-generated integer value is used (starting at 1 and incremented\n        for each new figure). If *num* is a string, the figure label and the\n        window title is set to this value.  If num is a ``SubFigure``, its\n        parent ``Figure`` is activated.\n\n    figsize : (float, float) or (float, float, str), default: :rc:`figure.figsize`\n        The figure dimensions. This can be\n\n        - a tuple ``(width, height, unit)``, where *unit* is one of \"inch\", \"cm\",\n          \"px\".\n        - a tuple ``(x, y)``, which is interpreted as ``(x, y, \"inch\")``.\n\n    dpi : float, default: :rc:`figure.dpi`\n        The resolution of the figure in dots-per-inch.\n\n    facecolor : :mpltype:`color`, default: :rc:`figure.facecolor`\n        The background color.\n\n    edgecolor : :mpltype:`color`, default: :rc:`figure.edgecolor`\n        The border color.\n\n    frameon : bool, default: True\n        If False, suppress drawing the figure frame.\n\n    FigureClass : subclass of `~matplotlib.figure.Figure`\n        If set, an instance of this subclass will be created, rather than a\n        plain `.F"}, {"start_line": 120000, "end_line": 122000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".\n\n        See Also\n        --------\n        matplotlib.figure.Figure.set_size_inches\n        matplotlib.figure.Figure.get_figwidth\n        matplotlib.figure.Figure.get_figheight\n\n        Notes\n        -----\n        The size in pixels can be obtained by multiplying with `Figure.dpi`.\n        \"\"\"\n        return np.array(self.bbox_inches.p1)\n\n    def get_figwidth(self):\n        \"\"\"Return the figure width in inches.\"\"\"\n        return self.bbox_inches.width\n\n    def get_figheight(self):\n        \"\"\"Return the figure height in inches.\"\"\"\n        return self.bbox_inches.height\n\n    def get_dpi(self):\n        \"\"\"Return the resolution in dots per inch as a float.\"\"\"\n        return self.dpi\n\n    def set_dpi(self, val):\n        \"\"\"\n        Set the resolution of the figure in dots-per-inch.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self.dpi = val\n        self.stale = True\n\n    def set_figwidth(self, val, forward=True):\n        \"\"\"\n        Set the width of the figure in inches.\n\n        Parameters\n        ----------\n        val : float\n        forward : bool\n            See `set_size_inches`.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.set_figheight\n        matplotlib.figure.Figure.set_size_inches\n        \"\"\"\n        self.set_size_inches(val, self.get_figheight(), forward=forward)\n\n    def set_figheight(self, val, forward=True):\n        \"\"\"\n        Set the height of the figure in inches.\n\n        Parameters\n        ----------\n        val : float\n        forward : bool\n            See `set_size_inches`.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.set_figwidth\n        matplotlib.figure.Figure.set_size_inches\n        \"\"\"\n        self.set_size_inches(self.get_figwidth(), val, forward=forward)\n\n    def clear(self, keep_observers=False):\n        # docstring inherited\n        super().clear(keep_observers=keep_observers)\n        # FigureBase.clear does not clear toolbars, as\n        # only Figure can ha"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplotlib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in whic"}, {"start_line": 95000, "end_line": 97000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ow a figure in a non-GUI backend.\"\"\"\n    pass\n\n\nclass FigureManagerBase:\n    \"\"\"\n    A backend-independent abstraction of a figure container and controller.\n\n    The figure manager is used by pyplot to interact with the window in a\n    backend-independent way. It's an adapter for the real (GUI) framework that\n    represents the visual figure on screen.\n\n    The figure manager is connected to a specific canvas instance, which in turn\n    is connected to a specific figure instance. To access a figure manager for\n    a given figure in user code, you typically use ``fig.canvas.manager``.\n\n    GUI backends derive from this class to translate common operations such\n    as *show* or *resize* to the GUI-specific code. Non-GUI backends do not\n    support these operations and can just use the base class.\n\n    This following basic operations are accessible:\n\n    **Window operations**\n\n    - `~.FigureManagerBase.show`\n    - `~.FigureManagerBase.destroy`\n    - `~.FigureManagerBase.full_screen_toggle`\n    - `~.FigureManagerBase.resize`\n    - `~.FigureManagerBase.get_window_title`\n    - `~.FigureManagerBase.set_window_title`\n\n    **Key and mouse button press handling**\n\n    The figure manager sets up default key and mouse button press handling by\n    hooking up the `.key_press_handler` to the matplotlib event system. This\n    ensures the same shortcuts and mouse actions across backends.\n\n    **Other operations**\n\n    Subclasses will have additional attributes and functions to access\n    additional functionality. This is of course backend-specific. For example,\n    most GUI backends have ``window`` and ``toolbar`` attributes that give\n    access to the native GUI widgets of the respective framework.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvasBase`\n        The backend-specific canvas instance.\n\n    num : int or str\n        The figure number.\n\n    key_press_handler_id : int\n        The default key handler cid, when using the toolmanager.\n        To disable the default k"}, {"start_line": 93000, "end_line": 95000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    clsname=self.__class__.__name__,\n            h=self.bbox.size[0], w=self.bbox.size[1],\n            naxes=len(self.axes),\n        )\n\n    def __init__(self,\n                 figsize=None,\n                 dpi=None,\n                 *,\n                 facecolor=None,\n                 edgecolor=None,\n                 linewidth=0.0,\n                 frameon=None,\n                 subplotpars=None,  # rc figure.subplot.*\n                 tight_layout=None,  # rc figure.autolayout\n                 constrained_layout=None,  # rc figure.constrained_layout.use\n                 layout=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        figsize : (float, float) or (float, float, str), default: :rc:`figure.figsize`\n            The figure dimensions. This can be\n\n            - a tuple ``(width, height, unit)``, where *unit* is one of \"in\" (inch),\n              \"cm\" (centimenter), \"px\" (pixel).\n            - a tuple ``(width, height)``, which is interpreted in inches, i.e. as\n              ``(width, height, \"in\")``.\n\n        dpi : float, default: :rc:`figure.dpi`\n            Dots per inch.\n\n        facecolor : default: :rc:`figure.facecolor`\n            The figure patch facecolor.\n\n        edgecolor : default: :rc:`figure.edgecolor`\n            The figure patch edge color.\n\n        linewidth : float\n            The linewidth of the frame (i.e. the edge linewidth of the figure\n            patch).\n\n        frameon : bool, default: :rc:`figure.frameon`\n            If ``False``, suppress drawing the figure background patch.\n\n        subplotpars : `~matplotlib.gridspec.SubplotParams`\n            Subplot parameters. If not given, the default subplot\n            parameters :rc:`figure.subplot.*` are used.\n\n        tight_layout : bool or dict, default: :rc:`figure.autolayout`\n            Whether to use the tight layout mechanism. See `.set_tight_layout`.\n\n            .. admonition:: Discouraged\n\n                The use of this"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_pylab_helpers.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nManage figures for the pyplot interface.\n\"\"\"\n\nimport atexit\nfrom collections import OrderedDict\n\n\nclass Gcf:\n    \"\"\"\n    Singleton to maintain the relation between figures and their managers, and\n    keep track of and \"active\" figure and manager.\n\n    The canvas of a figure created through pyplot is associated with a figure\n    manager, which handles the interaction between the figure and the backend.\n    pyplot keeps track of figure managers using an identifier, the \"figure\n    number\" or \"manager number\" (which can actually be any hashable value);\n    this number is available as the :attr:`number` attribute of the manager.\n\n    This class is never instantiated; it consists of an `OrderedDict` mapping\n    figure/manager numbers to managers, and a set of class methods that\n    manipulate this `OrderedDict`.\n\n    Attributes\n    ----------\n    figs : OrderedDict\n        `OrderedDict` mapping numbers to managers; the active manager is at the\n        end.\n    \"\"\"\n\n    figs = OrderedDict()\n\n    @classmethod\n    def get_fig_manager(cls, num):\n        \"\"\"\n        If manager number *num* exists, make it the active one and return it;\n        otherwise return *None*.\n        \"\"\"\n        manager = cls.figs.get(num, None)\n        if manager is not None:\n            cls.set_active(manager)\n        return manager\n\n    @classmethod\n    def destroy(cls, num):\n        \"\"\"\n        Destroy manager *num* -- either a manager instance or a manager number.\n\n        In the interactive backends, this is bound to the window \"destroy\" and\n        \"delete\" events.\n\n        It is recommended to pass a manager instance, to avoid confusion when\n        two managers share the same number.\n        \"\"\"\n        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n            manager = num\n            if cls.figs.get(manager.num) is manager:\n                cls.figs.pop(manager.num)\n        else:\n            try:\n                manager = cls.figs.pop(num)\n            except KeyError:\n      "}], "retrieved_count": 10, "cost_time": 0.3425426483154297}
{"question": "Where in Matplotlib's codebase is the \"Artist\" base class defined?", "answer": null, "relative_code_list": null, "ground_truth": "The Artist base class is defined in lib/matplotlib/artist.py. Specifically, it is defined starting at line 110 as the abstract base class for all objects that render into a FigureCanvas. The Artist class serves as the foundation for Matplotlib's rendering system, providing the common interface and properties that all visual elements share. The class definition includes the constructor (__init__ method) and all the fundamental methods and properties that Artists need, such as draw(), get_children(), set_visible(), get_visible(), set_alpha(), get_alpha(), and many others. The file also contains the type hints for the Artist class in lib/matplotlib/artist.pyi, which defines the interface for all Artist methods and properties. The Artist class is the root of Matplotlib's object hierarchy, with Figure, Axes, Line2D, Text, and all other visual elements inheriting from it. This central location in artist.py makes it the primary reference point for understanding how all Matplotlib visual elements work and interact with the rendering system.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "axisline_style.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "get_mutation_scale()  # line_mutation_scale()\n            extended_path = self._extend_path(path_in_disp,\n                                              mutation_size=mutation_size)\n            self._path_original = extended_path\n            return FancyArrowPatch.get_window_extent(self, renderer)\n\n    class FilledArrow(SimpleArrow):\n        \"\"\"The artist class that will be returned for FilledArrow style.\"\"\"\n        _ARROW_STYLE = \"-|>\"\n\n        def __init__(self, axis_artist, line_path, transform,\n                     line_mutation_scale, facecolor):\n            super().__init__(axis_artist, line_path, transform,\n                             line_mutation_scale)\n            self.set_facecolor(facecolor)\n\n\nclass AxislineStyle(_Style):\n    \"\"\"\n    A container class which defines style classes for AxisArtists.\n\n    An instance of any axisline style class is a callable object,\n    whose call signature is ::\n\n       __call__(self, axis_artist, path, transform)\n\n    When called, this should return an `.Artist` with the following methods::\n\n      def set_path(self, path):\n          # set the path for axisline.\n\n      def set_line_mutation_scale(self, scale):\n          # set the scale\n\n      def draw(self, renderer):\n          # draw\n    \"\"\"\n\n    _style_list = {}\n\n    class _Base:\n        # The derived classes are required to be able to be initialized\n        # w/o arguments, i.e., all its argument (except self) must have\n        # the default values.\n\n        def __init__(self):\n            \"\"\"\n            initialization.\n            \"\"\"\n            super().__init__()\n\n        def __call__(self, axis_artist, transform):\n            \"\"\"\n            Given the AxisArtist instance, and transform for the path (set_path\n            method), return the Matplotlib artist for drawing the axis line.\n            \"\"\"\n            return self.new_line(axis_artist, transform)\n\n    class SimpleArrow(_Base):\n        \"\"\"\n        A simple arrow.\n        \"\"\"\n\n        ArrowAxisClass = _FancyAx"}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n\n    def set(self, **kwargs):\n        # docstring and signature are auto-generated via\n        # Artist._update_set_signature_and_docstring() at the end of the\n        # module.\n        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n\n    @contextlib.contextmanager\n    def _cm_set(self, **kwargs):\n        \"\"\"\n        `.Artist.set` context-manager that restores original values at exit.\n        \"\"\"\n        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n        try:\n            self.set(**kwargs)\n            yield\n        finally:\n            self.set(**orig_vals)\n\n    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *None*: Return all objects contained in artist.\n            - A function with signature ``def match(artist: Artist) -> bool``.\n              The result will only contain artists for which the function\n              returns *True*.\n            - A class instance: e.g., `.Line2D`. The result will only contain\n              artists of this class or its subclasses (``isinstance`` check).\n\n        include_self : bool\n            Include *self* in the list to be checked for a match.\n\n        Returns\n        -------\n        list of `.Artist`\n\n        \"\"\"\n        if match is None:  # always return True\n            def matchfunc(x):\n                return True\n        elif isinstance(match, type) and issubclass(match, Artist):\n            def matchfunc(x):\n                return isinstance(x, match)\n        elif callable(match):\n            matchfunc = match\n        else:\n            raise ValueError('match must be None, a matplotlib.artist.Artist '\n                             'subclass, or a call"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos\n            arrow_end = self._get_position_xy(renderer)\n            # The arrow (from arrow_begin to arrow_end) will be first clipped\n            # by patchA and patchB, then shrunk by shrinkA and shrinkB (in\n            # points).  If patch A is not set, self.bbox_patch is used.\n            self.arrow_patch.set_positions(arrow_begin, arrow_end)\n\n            if \"mutation_scale\" in self.arrowprops:\n                mutation_scale = renderer.points_to_pixels(\n                    self.arrowprops[\"mutation_scale\"])\n                # Else, use fontsize-based mutation_scale defined above.\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n            patchA = self.arrowprops.get(\"patchA\", self.patch)\n            self.arrow_patch.set_patchA(patchA)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        renderer.open_group(self.__class__.__name__, gid=self.get_gid())\n        self.update_positions(renderer)\n        if self.arrow_patch is not None:\n            if (self.arrow_patch.get_figure(root=False) is None and\n                    (fig := self.get_figure(root=False)) is not None):\n                self.arrow_patch.set_figure(fig)\n            self.arrow_patch.draw(renderer)\n        self.patch.draw(renderer)\n        self.offsetbox.draw(renderer)\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False\n\n\nclass DraggableBase:\n    \"\"\"\n    Helper base class for a draggable artist (legend, offsetbox).\n\n    Derived classes must override the following methods::\n\n        def save_offset(self):\n            '''\n            Called when the object is picked for dragging; should save the\n            reference position of the artist.\n            '''\n\n        def update_offset(self, dx, dy):\n            '''\n            Called during the dragging; (*dx*, *dy*) is the pixel offset from\n            t"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ogenerated_signature = True\n\n        cls.set.__doc__ = (\n            \"Set multiple properties at once.\\n\\n\"\n            \"Supported properties are\\n\\n\"\n            + kwdoc(cls))\n\n    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self._parent_figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        d['stale_callback'] = None\n        return d\n\n    def remove(self):\n        \"\"\"\n        Remove the artist from the figure if possible.\n\n        The effect will not be visible until the figure is redrawn, e.g.,\n        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n        update the Axes limits if desired.\n\n        Note: `~.axes.Axes.relim` will not see collections even if the\n        collection was added to the Axes with *autolim* = True.\n\n        Note: there is no support for removing the"}], "retrieved_count": 10, "cost_time": 0.3298158645629883}
{"question": "Where is the \"plot\" function defined in Matplotlib's pyplot interface?", "answer": null, "relative_code_list": null, "ground_truth": "The \"plot\" function in Matplotlib's pyplot interface is not defined in a single location but is automatically generated as a wrapper around the Axes.plot() method. The implementation works as follows: 1) The pyplot.plot() function is generated automatically by the boilerplate.py script in lib/matplotlib/boilerplate.py, which creates wrapper functions for all Axes methods, 2) The generated plot() function is located in lib/matplotlib/pyplot.py, where it serves as a convenience wrapper that calls gca().plot() on the current Axes, 3) The actual plotting logic is implemented in the Axes.plot() method, which is defined in lib/matplotlib/axes/_axes.py, 4) The pyplot.plot() function maintains the same signature and parameters as Axes.plot(), but manages the global state (current Figure and Axes) automatically, 5) When plt.plot() is called, it first ensures there's a current Figure and Axes (creating them if necessary), then delegates to the current Axes' plot() method, 6) The pyplot interface provides this wrapper pattern for all major plotting functions (scatter, bar, hist, etc.), making them accessible through the simple plt.function_name() syntax, 7) The boilerplate generation system ensures that pyplot functions stay synchronized with the underlying Axes methods, automatically updating when new parameters or features are added to the Axes methods. This design allows users to use the simple pyplot interface while the actual implementation remains in the object-oriented Axes class.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}, {"start_line": 130000, "end_line": 132000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      center=center,\n        frame=frame,\n        rotatelabels=rotatelabels,\n        normalize=normalize,\n        hatch=hatch,\n        **({\"data\": data} if data is not None else {}),\n    )\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Axes.plot)\ndef plot(\n    *args: float | ArrayLike | str,\n    scalex: bool = True,\n    scaley: bool = True,\n    data=None,\n    **kwargs,\n) -> list[Line2D]:\n    return gca().plot(\n        *args,\n        scalex=scalex,\n        scaley=scaley,\n        **({\"data\": data} if data is not None else {}),\n        **kwargs,\n    )\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Axes.psd)\ndef psd(\n    x: ArrayLike,\n    NFFT: int | None = None,\n    Fs: float | None = None,\n    Fc: int | None = None,\n    detrend: Literal[\"none\", \"mean\", \"linear\"]\n    | Callable[[ArrayLike], ArrayLike]\n    | None = None,\n    window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n    noverlap: int | None = None,\n    pad_to: int | None = None,\n    sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n    scale_by_freq: bool | None = None,\n    return_line: bool | None = None,\n    *,\n    data=None,\n    **kwargs,\n) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:\n    return gca().psd(\n        x,\n        NFFT=NFFT,\n        Fs=Fs,\n        Fc=Fc,\n        detrend=detrend,\n        window=window,\n        noverlap=noverlap,\n        pad_to=pad_to,\n        sides=sides,\n        scale_by_freq=scale_by_freq,\n        return_line=return_line,\n        **({\"data\": data} if data is not None else {}),\n        **kwargs,\n    )\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Axes.quiver)\ndef quiver(*args, data=None, **kwargs) -> Quiver:\n    __ret = gca().quiver(\n        *args, **({\"data\": data} if data is not None else {}), **kwargs\n    )\n    sci(__ret)\n    return __re"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/pyplot\n\n.. _pyplot_tutorial:\n\n===============\nPyplot tutorial\n===============\n\nAn introduction to the pyplot interface.  Please also see\n:ref:`quick_start` for an overview of how Matplotlib\nworks and :ref:`api_interfaces` for an explanation of the trade-offs between the\nsupported user APIs.\n\n\"\"\"\n\n# %%\n# Introduction to pyplot\n# ======================\n#\n# :mod:`matplotlib.pyplot` is a collection of functions that make matplotlib\n# work like MATLAB.  Each ``pyplot`` function makes some change to a figure:\n# e.g., creates a figure, creates a plotting area in a figure, plots some lines\n# in a plotting area, decorates the plot with labels, etc.\n#\n# In :mod:`matplotlib.pyplot` various states are preserved\n# across function calls, so that it keeps track of things like\n# the current figure and plotting area, and the plotting\n# functions are directed to the current Axes (please note that we use uppercase\n# Axes to refer to the `~.axes.Axes` concept, which is a central\n# :ref:`part of a figure <figure_parts>`\n# and not only the plural of *axis*).\n#\n# .. note::\n#\n#    The implicit pyplot API is generally less verbose but also not as flexible as the\n#    explicit API.  Most of the function calls you see here can also be called\n#    as methods from an ``Axes`` object. We recommend browsing the tutorials\n#    and examples to see how this works. See :ref:`api_interfaces` for an\n#    explanation of the trade-off of the supported user APIs.\n#\n# Generating visualizations with pyplot is very quick:\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n# You may be wondering why the x-axis ranges from 0-3 and the y-axis\n# from 1-4.  If you provide a single list or array to\n# `~.pyplot.plot`, matplotlib assumes it is a\n# sequence of y values, and automatically generates the x values for\n# you.  Since python ranges start with 0, the default x vector has the\n# same length as y but starts with 0; "}, {"start_line": 0, "end_line": 110, "belongs_to": {"file_name": "pylab.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from matplotlib.pylab import *  # noqa: F401, F403\nimport matplotlib.pylab\n__doc__ = matplotlib.pylab.__doc__\n"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n  "}, {"start_line": 96000, "end_line": 98000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " likely \"\n                        \"should call 'polar()' before any other pyplot plotting \"\n                        \"commands. \"\n                        \"Support for this scenario is deprecated in %(since)s and \"\n                        \"will raise an error in %(removal)s\"\n            )\n    else:\n        ax = axes(projection=\"polar\")\n    return ax.plot(*args, **kwargs)\n\n\n# If rcParams['backend_fallback'] is true, and an interactive backend is\n# requested, ignore rcParams['backend'] and force selection of a backend that\n# is compatible with the current running interactive framework.\nif rcParams[\"backend_fallback\"]:\n    requested_backend = rcParams._get_backend_or_none()  # type: ignore[attr-defined]\n    requested_backend = None if requested_backend is None else requested_backend.lower()\n    available_backends = backend_registry.list_builtin(BackendFilter.INTERACTIVE)\n    if (\n        requested_backend in (set(available_backends) - {'webagg', 'nbagg'})\n        and cbook._get_running_interactive_framework()\n    ):\n        rcParams._set(\"backend\", rcsetup._auto_backend_sentinel)\n\n# fmt: on\n\n################# REMAINING CONTENT GENERATED BY boilerplate.py ##############\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Figure.figimage)\ndef figimage(\n    X: ArrayLike,\n    xo: int = 0,\n    yo: int = 0,\n    alpha: float | None = None,\n    norm: str | Normalize | None = None,\n    cmap: str | Colormap | None = None,\n    vmin: float | None = None,\n    vmax: float | None = None,\n    origin: Literal[\"upper\", \"lower\"] | None = None,\n    resize: bool = False,\n    *,\n    colorizer: Colorizer | None = None,\n    **kwargs,\n) -> FigureImage:\n    return gcf().figimage(\n        X,\n        xo=xo,\n        yo=yo,\n        alpha=alpha,\n        norm=norm,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        origin=origin,\n        resize=resize,\n        colorizer=colorizer,\n        **kwargs,\n    )\n\n\n# Autogenerated by boilerpl"}, {"start_line": 62000, "end_line": 64000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "biguity in calls where the\n                second label is a valid *fmt*. ``plot('n', 'o', data=obj)``\n                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                ``plot('n', 'o', '', data=obj)``.\n\n        Returns\n        -------\n        list of `.Line2D`\n            A list of lines representing the plotted data.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, default: True\n            These parameters determine if the view limits are adapted to the\n            data limits. The values are passed on to\n            `~.axes.Axes.autoscale_view`.\n\n        **kwargs : `~matplotlib.lines.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you specify multiple lines with one plot call, the kwargs apply\n            to all those lines. In case the label object is iterable, each\n            element is used as labels for each set of data.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(Line2D:kwdoc)s\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n      "}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " are given by *x*, *y*.\n\n        The optional parameter *fmt* is a convenient way for defining basic\n        formatting like color, marker and linestyle. It's a shortcut string\n        notation described in the *Notes* section below.\n\n        >>> plot(x, y)        # plot x and y using default line style and color\n        >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n        >>> plot(y)           # plot y using x as index array 0..N-1\n        >>> plot(y, 'r+')     # ditto, but with red plusses\n\n        You can use `.Line2D` properties as keyword arguments for more\n        control on the appearance. Line properties and *fmt* can be mixed.\n        The following two calls yield identical results:\n\n        >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n        >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n        ...      linewidth=2, markersize=12)\n\n        When conflicting with *fmt*, keyword arguments take precedence.\n\n\n        **Plotting labelled data**\n\n        There's a convenient way for plotting objects with labelled data (i.e.\n        data that can be accessed by index ``obj['y']``). Instead of giving\n        the data in *x* and *y*, you can provide the object in the *data*\n        parameter and just give the labels for *x* and *y*::\n\n        >>> plot('xlabel', 'ylabel', data=obj)\n\n        All indexable objects are supported. This could e.g. be a `dict`, a\n        `pandas.DataFrame` or a structured numpy array.\n\n\n        **Plotting multiple sets of data**\n\n        There are various ways to plot multiple sets of data.\n\n        - The most straight forward way is just to call `plot` multiple times.\n          Example:\n\n          >>> plot(x1, y1, 'bo')\n          >>> plot(x2, y2, 'go')\n\n        - If *x* and/or *y* are 2D arrays, a separate data set will be drawn\n          for every column. If both *x* and *y* are 2D, they must have the\n          same shape. If only one of them is 2D with shape (N, m) the other\n          must have l"}], "retrieved_count": 10, "cost_time": 0.32738256454467773}
{"question": "How does Matplotlib implement its backend system for different output formats?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its backend system for different output formats through a modular architecture that separates rendering logic from output mechanisms. The system works as follows: 1) Abstract base classes in lib/matplotlib/backend_bases.py define the interface that all backends must implement, including RendererBase, FigureCanvasBase, and GraphicsContextBase, 2) The backend registration system in backend_bases.py maps file formats to specific backend modules through the _default_backends dictionary, which associates formats like 'png', 'pdf', 'svg' with their corresponding backend modules, 3) Each backend implements the abstract interface by providing concrete classes that inherit from the base classes - for example, the Agg backend provides RendererAgg for raster output, while PDF and SVG backends provide vector-based renderers, 4) The Figure.savefig() method uses the backend system by calling the appropriate print_* method on the canvas, which automatically selects the correct backend based on the file extension or format parameter, 5) Backends are organized into interactive backends (for GUI display) and non-interactive backends (for file output), with the system supporting both raster formats (PNG, JPEG) through Agg and vector formats (PDF, SVG, PS) through specialized renderers, 6) The backend selection can be configured through rcParams, environment variables, or explicit backend specification in savefig(), allowing users to choose the most appropriate output format for their needs, 7) Each backend implements format-specific optimizations and features while maintaining a consistent interface, enabling the same plotting code to work across different output formats without modification.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n            self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entr"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}, {"start_line": 0, "end_line": 206, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from .registry import BackendFilter, backend_registry  # noqa: F401\n\n# NOTE: plt.switch_backend() (called at import time) will add a \"backend\"\n# attribute here for backcompat.\n_QT_FORCE_QT5_BINDING = False\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "vent, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'\n\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasTemplate\nFigureManager = FigureMana"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# get without triggering backend resolution\n\n    module = backend_registry.load_backend_module(newbackend)\n    canvas_class = module.FigureCanvas\n\n    required_framework = canvas_class.required_interactive_framework\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new_figure_manager() and show() functions from the backend.\n\n    # Classically, backends can directly export these functions.  This should\n    # keep working for backcompat.\n    new_figure_manager = getattr(module, \"new_figure_manager\", None)\n    show = getattr(module, \"show\", None)\n\n    # In that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from enum import Enum\nimport importlib\n\n\nclass BackendFilter(Enum):\n    \"\"\"\n    Filter used with :meth:`~matplotlib.backends.registry.BackendRegistry.list_builtin`\n\n    .. versionadded:: 3.9\n    \"\"\"\n    INTERACTIVE = 0\n    NON_INTERACTIVE = 1\n\n\nclass BackendRegistry:\n    \"\"\"\n    Registry of backends available within Matplotlib.\n\n    This is the single source of truth for available backends.\n\n    All use of ``BackendRegistry`` should be via the singleton instance\n    ``backend_registry`` which can be imported from ``matplotlib.backends``.\n\n    Each backend has a name, a module name containing the backend code, and an\n    optional GUI framework that must be running if the backend is interactive.\n    There are three sources of backends: built-in (source code is within the\n    Matplotlib repository), explicit ``module://some.backend`` syntax (backend is\n    obtained by loading the module), or via an entry point (self-registering\n    backend in an external package).\n\n    .. versionadded:: 3.9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of g"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from entry points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n    "}], "retrieved_count": 10, "cost_time": 0.33862805366516113}
{"question": "How does Matplotlib manage the figure and axes hierarchy?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib manages the figure and axes hierarchy through a structured parent-child relationship system implemented in the Figure and Axes classes. The hierarchy management works as follows: 1) The Figure class serves as the top-level container that manages all Axes objects through its _axstack attribute, which is an instance of the _AxesStack helper class that tracks Axes in insertion order and maintains the current active Axes, 2) The Figure class provides methods like add_axes(), add_subplot(), subplots(), and delaxes() to create and manage Axes objects, with each method automatically adding the new Axes to the _axstack and setting up the parent-child relationship, 3) The _AxesStack class maintains a dictionary mapping Axes to their insertion order and provides methods like current() to get the active Axes, bubble() to move an Axes to the top, and add() to add new Axes, 4) Each Axes object maintains a reference to its parent Figure through the _parent_figure attribute, and the Figure maintains lists of all its child Axes through the _localaxes attribute, 5) The Figure's gca() method returns the current active Axes from the stack, and sca() method sets the current Axes, managing the active state, 6) The hierarchy supports SubFigure objects that can be nested within Figures, creating a multi-level hierarchy where SubFigures can contain their own Axes, 7) The Figure class also manages figure-level Artists (lines, patches, texts, images, legends) that are not associated with any specific Axes, 8) The hierarchy enables efficient rendering by allowing the Figure to coordinate the drawing of all its child Axes and Artists, 9) The system supports automatic layout management through layout engines that can adjust the positions of Axes based on their content and the overall figure size.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a not in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ass:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axes>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instanc"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s>`.  These are also returned by the\n# methods that create them:\n#\n# .. sourcecode:: ipython\n#\n#     In [156]: fig = plt.figure()\n#\n#     In [157]: ax1 = fig.add_subplot(211)\n#\n#     In [158]: ax2 = fig.add_axes((0.1, 0.1, 0.7, 0.3))\n#\n#     In [159]: ax1\n#     Out[159]: <Axes:>\n#\n#     In [160]: print(fig.axes)\n#     [<Axes:>, <matplotlib.axes._axes.Axes object at 0x7f0768702be0>]\n#\n# Because the figure maintains the concept of the \"current Axes\" (see\n# :meth:`Figure.gca <matplotlib.figure.Figure.gca>` and\n# :meth:`Figure.sca <matplotlib.figure.Figure.sca>`) to support the\n# pylab/pyplot state machine, you should not insert or remove Axes\n# directly from the Axes list, but rather use the\n# :meth:`~matplotlib.figure.Figure.add_subplot` and\n# :meth:`~matplotlib.figure.Figure.add_axes` methods to insert, and the\n# `Axes.remove <matplotlib.artist.Artist.remove>` method to delete.  You are\n# free however, to iterate over the list of Axes or index into it to get\n# access to ``Axes`` instances you want to customize.  Here is an\n# example which turns all the Axes grids on::\n#\n#     for ax in fig.axes:\n#         ax.grid(True)\n#\n#\n# The figure also has its own ``images``, ``lines``, ``patches`` and ``text``\n# attributes, which you can use to add primitives directly. When doing so, the\n# default coordinate system for the ``Figure`` will simply be in pixels (which\n# is not usually what you want). If you instead use Figure-level methods to add\n# Artists (e.g., using `.Figure.text` to add text), then the default coordinate\n# system will be \"figure coordinates\" where (0, 0) is the bottom-left of the\n# figure and (1, 1) is the top-right of the figure.\n#\n# As with all ``Artist``\\s, you can control this coordinate system by setting\n# the transform property. You can explicitly use \"figure coordinates\" by\n# setting the ``Artist`` transform to :attr:`!fig.transFigure`:\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\n\nl1 = lines.Line2D([0, 1], [0, 1], transform=fig.transFigure, fi"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "port ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n                                   TransformedBbox)\n\n_log = logging.getLogger(__name__)\n\n\ndef _stale_figure_callback(self, val):\n    if (fig := self.get_figure(root=False)) is not None:\n        fig.stale = val\n\n\nclass _AxesStack:\n    \"\"\"\n    Helper class to track Axes in a figure.\n\n    Axes are tracked both in the order in which they have been added\n    (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n    (which is the index to which they map in the ``self._axes`` dict).\n    \"\"\"\n\n    def __init__(self):\n        self._axes = {}  # Mapping of Axes to \"gca\" order.\n        self._counter = itertools.count()\n\n    def as_list(self):\n        \"\"\"List the Axes that have been added to the figure.\"\"\"\n        return [*self._axes]  # This relies on dict preserving order.\n\n    def remove(self, a):\n        \"\"\"Remove the Axes from the stack.\"\"\"\n        self._axes.pop(a)\n\n    def bubble(self, a):\n        \"\"\"Move an Axes, which must already exist in the stack, to the top.\"\"\"\n        if a n"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ot in self._axes:\n            raise ValueError(\"Axes has not been added yet\")\n        self._axes[a] = next(self._counter)\n\n    def add(self, a):\n        \"\"\"Add an Axes to the stack, ignoring it if already present.\"\"\"\n        if a not in self._axes:\n            self._axes[a] = next(self._counter)\n\n    def current(self):\n        \"\"\"Return the active Axes, or None if the stack is empty.\"\"\"\n        return max(self._axes, key=self._axes.__getitem__, default=None)\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            \"_counter\": max(self._axes.values(), default=0)\n        }\n\n    def __setstate__(self, state):\n        next_counter = state.pop('_counter')\n        vars(self).update(state)\n        self._counter = itertools.count(next_counter)\n\n\nclass FigureBase(Artist):\n    \"\"\"\n    Base class for `.Figure` and `.SubFigure` containing the methods that add\n    artists to the figure or subfigure, create Axes, etc.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an Axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n\n        self._suptitle = None\n        self._supxlabel = None\n        self._supylabel = None\n\n        # groupers to keep track of x, y labels and title we want to align.\n        # see self.align_xlabels, self.align_ylabels,\n        # self.align_titles, and axis._get_tick_boxes_siblings\n        self._align_label_groups = {\n            \"x\": cbook.Grouper(),\n            \"y\": cbook.Grouper(),\n            \"title\": cbook.Grouper()\n        }\n\n        self._localaxes = []  # track all Axes\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        self.subfigs = []\n        self.stale = True\n        self.suppressComposite = None\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n`matplotlib.figure` implements the following classes:\n\n`Figure`\n    Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n    Many methods are implemented in `FigureBase`.\n\n`SubFigure`\n    A logical figure inside a figure, usually added to a figure (or parent `SubFigure`)\n    with `Figure.add_subfigure` or `Figure.subfigures` methods.\n\nFigures are typically created using pyplot methods `~.pyplot.figure`,\n`~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n\n.. plot::\n    :include-source:\n\n    fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n                           layout='constrained')\n    fig.suptitle('Figure')\n    ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n\nSome situations call for directly instantiating a `~.figure.Figure` class,\nusually inside an application of some sort (see :ref:`user_interfaces` for a\nlist of examples) .  More information about Figures can be found at\n:ref:`figure-intro`.\n\"\"\"\n\nfrom contextlib import ExitStack\nimport inspect\nimport itertools\nimport functools\nimport logging\nfrom numbers import Integral\nimport threading\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _blocking_input, backend_bases, _docstring, projections\nfrom matplotlib.artist import (\n    Artist, allow_rasterization, _finalize_rasterization)\nfrom matplotlib.backend_bases import (\n    DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\nimport matplotlib._api as _api\nimport matplotlib.cbook as cbook\nimport matplotlib.colorbar as cbar\nimport matplotlib.image as mimage\n\nfrom matplotlib.axes import Axes\nfrom matplotlib.gridspec import GridSpec, SubplotParams\nfrom matplotlib.layout_engine import (\n    ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n    PlaceHolderLayoutEngine\n)\nimport matplotlib.legend as mlegend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n           "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_pylab_helpers.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nManage figures for the pyplot interface.\n\"\"\"\n\nimport atexit\nfrom collections import OrderedDict\n\n\nclass Gcf:\n    \"\"\"\n    Singleton to maintain the relation between figures and their managers, and\n    keep track of and \"active\" figure and manager.\n\n    The canvas of a figure created through pyplot is associated with a figure\n    manager, which handles the interaction between the figure and the backend.\n    pyplot keeps track of figure managers using an identifier, the \"figure\n    number\" or \"manager number\" (which can actually be any hashable value);\n    this number is available as the :attr:`number` attribute of the manager.\n\n    This class is never instantiated; it consists of an `OrderedDict` mapping\n    figure/manager numbers to managers, and a set of class methods that\n    manipulate this `OrderedDict`.\n\n    Attributes\n    ----------\n    figs : OrderedDict\n        `OrderedDict` mapping numbers to managers; the active manager is at the\n        end.\n    \"\"\"\n\n    figs = OrderedDict()\n\n    @classmethod\n    def get_fig_manager(cls, num):\n        \"\"\"\n        If manager number *num* exists, make it the active one and return it;\n        otherwise return *None*.\n        \"\"\"\n        manager = cls.figs.get(num, None)\n        if manager is not None:\n            cls.set_active(manager)\n        return manager\n\n    @classmethod\n    def destroy(cls, num):\n        \"\"\"\n        Destroy manager *num* -- either a manager instance or a manager number.\n\n        In the interactive backends, this is bound to the window \"destroy\" and\n        \"delete\" events.\n\n        It is recommended to pass a manager instance, to avoid confusion when\n        two managers share the same number.\n        \"\"\"\n        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n            manager = num\n            if cls.figs.get(manager.num) is manager:\n                cls.figs.pop(manager.num)\n        else:\n            try:\n                manager = cls.figs.pop(num)\n            except KeyError:\n      "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n# %%\n#\n# Depending on the environment you are working in, ``plt.show()`` can be left\n# out. This is for example the case with Jupyter notebooks, which\n# automatically show all figures created in a code cell.\n#\n# .. _figure_parts:\n#\n# Parts of a Figure\n# =================\n#\n# Here are the components of a Matplotlib Figure.\n#\n# .. image:: ../../_static/anatomy.png\n#\n# :class:`~matplotlib.figure.Figure`\n# ----------------------------------\n#\n# The **whole** figure.  The Figure keeps\n# track of all the child :class:`~matplotlib.axes.Axes`, a group of\n# 'special' Artists (titles, figure legends, colorbars, etc.), and\n# even nested subfigures.\n#\n# Typically, you'll create a new Figure through one of the following\n# functions::\n#\n#    fig = plt.figure()             # an empty figure with no Axes\n#    fig, ax = plt.subplots()       # a figure with a single Axes\n#    fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes\n#    # a figure with one Axes on the left, and two on the right:\n#    fig, axs = plt.subplot_mosaic([['left', 'right_top'],\n#                                   ['left', 'right_bottom']])\n#\n# `~.pyplot.subplots()` and `~.pyplot.subplot_mosaic` are convenience functions\n# that additionally create Axes objects inside the Figure, but you can also\n# manually add Axes later on.\n#\n# For more on Figures, including panning and zooming, see :ref:`figure-intro`.\n#\n# :class:`~matplotlib.axes.Axes`\n# ------------------------------\n#\n# An Axes is an Artist attached to a Figure that contains a region for\n# plotting data, and usually includes two (or three in the case of 3D)\n# :class:`~matplotlib.axis.Axis` objects (be aware of the difference\n# between **Axes** and **Axis**) that provide ticks and tick labels to\n# provide scales for the data in the Axes. Each :class:`~.axes.Axes` also\n# has a title\n# (set via :meth:`~matplotlib.axes.Axes.set_title`), an x-label (set via"}, {"start_line": 0, "end_line": 351, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from . import _base\nfrom ._axes import Axes\n\n# Backcompat.\nSubplot = Axes\n\n\nclass _SubplotBaseMeta(type):\n    def __instancecheck__(self, obj):\n        return (isinstance(obj, _base._AxesBase)\n                and obj.get_subplotspec() is not None)\n\n\nclass SubplotBase(metaclass=_SubplotBaseMeta):\n    pass\n\n\ndef subplot_class_factory(cls): return cls\n"}], "retrieved_count": 10, "cost_time": 0.33950281143188477}
{"question": "How does Matplotlib implement its event system for interactive plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its event system for interactive plotting through a GUI-neutral architecture that abstracts user interactions across different GUI toolkits. The system works as follows: 1) The core event system is defined in lib/matplotlib/backend_bases.py, which contains abstract base classes like Event, LocationEvent, MouseEvent, and KeyEvent that provide a consistent interface regardless of the underlying GUI framework, 2) The FigureCanvasBase class provides the mpl_connect() and mpl_disconnect() methods that manage event connections and maintain a registry of callback functions for different event types, 3) Backend-specific implementations (Qt, Tk, GTK, Wx, macOS) capture low-level GUI events and convert them into Matplotlib-specific event objects with both pixel coordinates and data coordinates, 4) The event system supports various event types including mouse clicks, key presses, mouse movements, and custom events, with each event containing information about the location (both pixel and data coordinates), the Axes the event occurred in, and any modifiers pressed, 5) Users can connect callback functions to specific events using FigureCanvasBase.mpl_connect(), which returns a connection ID that can be used to disconnect the callback later, 6) The event system integrates with the Artist hierarchy, allowing events to be associated with specific visual elements and enabling features like picking (determining which Artist was clicked), 7) Built-in interactive features like panning and zooming are implemented using this event system, with the backend handling the conversion between GUI toolkit events and Matplotlib's coordinate systems, 8) The event system supports both blocking and non-blocking event loops, allowing for different integration patterns with command-line interfaces and GUI applications, 9) The system provides a framework-independent interface that enables the same interactive code to work across different GUI toolkits while maintaining consistent behavior.", "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ent propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ering different compared to mpl.\n            button for button, mask in [\n                (MouseButton.LEFT, 1),\n                (MouseButton.RIGHT, 2),\n                (MouseButton.MIDDLE, 4),\n                (MouseButton.BACK, 8),\n                (MouseButton.FORWARD, 16),\n            ] if event['buttons'] & mask  # State *after* press/release.\n        }\n        modifiers = event['modifiers']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       modifiers=modifiers, guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_backend_tk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "al implementation uses a Tk canvas,  this routine\n        is intended to hide that fact.\n        \"\"\"\n        return self._tkcanvas\n\n    def _event_mpl_coords(self, event):\n        # calling canvasx/canvasy allows taking scrollbars into account (i.e.\n        # the top of the widget may have been scrolled out of view).\n        return (self._tkcanvas.canvasx(event.x),\n                # flipy so y=0 is bottom of canvas\n                self.figure.bbox.height - self._tkcanvas.canvasy(event.y))\n\n    def motion_notify_event(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._event_mpl_coords(event),\n                   buttons=self._mpl_buttons(event),\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def enter_notify_event(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, event):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._event_mpl_coords(event),\n                      modifiers=self._mpl_modifiers(event),\n                      guiEvent=event)._process()\n\n    def button_press_event(self, event, dblclick=False):\n        # set focus to the canvas so that it can receive keyboard events\n        self._tkcanvas.focus_set()\n\n        num = getattr(event, 'num', None)\n        if sys.platform == 'darwin':  # 2 and 3 are reversed.\n            num = {2: 3, 3: 2}.get(num, num)\n        MouseEvent(\"button_press_event\", self,\n                   *self._event_mpl_coords(event), num, dblclick=dblclick,\n                   modifiers=self._mpl_modifiers(event),\n                   guiEvent=event)._process()\n\n    def button_dblclick_event(self, event):\n        self.button_press_event(event, dblclick=True)\n\n    def button_release_event(self, event):\n        num = "}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       modifiers=self._mpl_modifiers(mods),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        if self.figure is None:\n            return\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      modifiers=self._mpl_modifiers(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        if self.figure is None:\n            return\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   buttons=self._mpl_buttons(event.buttons()),\n                   modifiers=self._mpl_modifiers(),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None and self.figure is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       modifiers=self._mpl_modifiers(),\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is"}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dd_callback as a \"\n                \"functools.partial object.\")\n            self.callbacks.remove((func, args, kwargs))\n        else:\n            funcs = [c[0] for c in self.callbacks]\n            if func in funcs:\n                self.callbacks.pop(funcs.index(func))\n\n    def _timer_set_interval(self):\n        \"\"\"Used to set interval on underlying timer object.\"\"\"\n\n    def _timer_set_single_shot(self):\n        \"\"\"Used to set single shot on underlying timer object.\"\"\"\n\n    def _on_timer(self):\n        \"\"\"\n        Runs all function that have been registered as callbacks. Functions\n        can return False (or 0) if they should not be called any more. If there\n        are no callbacks, the timer is automatically stopped.\n        \"\"\"\n        for func, args, kwargs in self.callbacks:\n            ret = func(*args, **kwargs)\n            # docstring above explains why we use `if ret == 0` here,\n            # instead of `if not ret`.\n            # This will also catch `ret == False` as `False == 0`\n            # but does not annoy the linters\n            # https://docs.python.org/3/library/stdtypes.html#boolean-values\n            if ret == 0:\n                self.callbacks.remove((func, args, kwargs))\n\n        if len(self.callbacks) == 0:\n            self.stop()\n\n\nclass Event:\n    \"\"\"\n    A Matplotlib event.\n\n    The following attributes are defined and shown with their default values.\n    Subclasses may define additional attributes.\n\n    Attributes\n    ----------\n    name : str\n        The event name.\n    canvas : `FigureCanvasBase`\n        The backend-specific canvas instance generating the event.\n    guiEvent\n        The GUI event that triggered the Matplotlib event.\n    \"\"\"\n\n    def __init__(self, name, canvas, guiEvent=None):\n        self.name = name\n        self.canvas = canvas\n        self.guiEvent = guiEvent\n\n    def _process(self):\n        \"\"\"Process this event on ``self.canvas``, then unset ``guiEvent``.\"\"\"\n        self.canvas.callbacks.process(self.name, self)\n  "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   buttons=self._mpl_buttons(event.state),\n                   modifiers=self._mpl_modifiers(event.state),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        gtk_mods = Gdk.Keymap.get_for_display(\n            self.get_display()).get_modifier_state()\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      modifiers=self._mpl_modifiers(gtk_mods),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    @staticmethod\n    def _mpl_buttons(event_state):\n        modifiers = [\n            (MouseButton.LEFT, Gdk.ModifierType.BUTTON1_MASK),\n            (MouseButton.MIDDLE, Gdk.ModifierType.BUTTON2_MASK),\n            (MouseButton.RIGHT, Gdk.ModifierType.BUTTON3_MASK),\n            (MouseButton.BACK, Gdk.ModifierType.BUTTON4_MASK),\n            (MouseButton.FORWARD, Gdk.ModifierType.BUTTON5_MASK),\n        ]\n        # State *before* press/release.\n        return [name for name, mask in"}, {"start_line": 87000, "end_line": 89000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)\n\n    def flush_events(self):\n        \"\"\"\n        Flush the GUI events for the figure.\n\n        Interactive backends need to reimplement this method.\n        \"\"\"\n\n    def start_event_loop(self, timeout=0):\n        \"\"\"\n        Start a blocking event loop.\n\n        Such an event loop is used by interactive functions, such as\n        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n        events.\n\n        The event loop blocks until a callback function triggers\n        `stop_event_loop`, or *timeout* is reached.\n\n        If *timeout* is 0 or negative, never timeout.\n\n        Only interactive backends need to reimplement this method and it relies\n        on `flush_events` being properly implemented.\n\n        Interactive backends should implement this in a more native way.\n        \"\"\"\n        if timeout <= 0:\n            timeout = np.inf\n        timestep = 0.01\n        counter = 0\n        self._looping = True\n        while self._looping and counter * timestep < timeout:\n            self.flush_events()\n            time.sleep(timestep)\n            counter += 1\n\n    def stop_event_loop(self):\n        \"\"\"\n        Stop the current blocking event loop.\n\n        Interactive backends need to reimplement this to match\n        `start_event_loop`\n        \"\"\"\n        self._looping = False\n\n\ndef key_press_handler(event, canvas=None, toolbar=None):\n    \"\"\"\n    Implement the default Matplotlib key bindings for the canvas and toolbar\n    described at :ref:`key-event-handling`.\n\n    Parameters\n    ----------\n    event : `KeyEvent`\n        A key press/release event.\n    canvas : `FigureCanvasBase`, default: ``event.canvas``\n        The backend-specific canvas instance.  This parameter is kept for\n        back-compatibility, but, if set, should always be equal to\n        ``event.canvas``.\n    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n        The navi"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_webagg_core.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       buttons=buttons, modifiers=modifiers, guiEvent=guiEvent,\n                       )._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          modifiers=modifiers, guiEvent=guiEvent)._process()\n\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        if self.manager:\n            self.send_event('figure_label', label=self.manager.get_window_title())\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          controller.get_current_button(),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_press_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\n            \"key_release_event\", self, self._get_key(keyval, keycode, state),\n            *self._mpl_coords(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\n            \"motion_notify_event\", self, *self._mpl_coords((x, y)),\n            buttons=self._mpl_buttons(controller),\n            modifiers=self._mpl_modifiers(controller),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\n            \"figure_enter_event\", self, *self._mpl_coords((x, y)),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\n            \"figure_leave_event\", self, *self._mpl_coords(),\n            modifiers=self._mpl_modifiers(),\n            guiEvent=controller.get_current_event() if _GOBJECT_GE_3_47 else None,\n        )._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n "}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      self.guiEvent = None\n\n\nclass DrawEvent(Event):\n    \"\"\"\n    An event triggered by a draw operation on the canvas.\n\n    In most backends, callbacks subscribed to this event will be fired after\n    the rendering is complete but before the screen is updated. Any extra\n    artists drawn to the canvas's renderer will be reflected without an\n    explicit call to ``blit``.\n\n    .. warning::\n\n       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n       not be safe with all backends and may cause infinite recursion.\n\n    A DrawEvent has a number of special attributes in addition to those defined\n    by the parent `Event` class.\n\n    Attributes\n    ----------\n    renderer : `RendererBase`\n        The renderer for the draw event.\n    \"\"\"\n    def __init__(self, name, canvas, renderer):\n        super().__init__(name, canvas)\n        self.renderer = renderer\n\n\nclass ResizeEvent(Event):\n    \"\"\"\n    An event triggered by a canvas resize.\n\n    A ResizeEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    width : int\n        Width of the canvas in pixels.\n    height : int\n        Height of the canvas in pixels.\n    \"\"\"\n\n    def __init__(self, name, canvas):\n        super().__init__(name, canvas)\n        self.width, self.height = canvas.get_width_height()\n\n\nclass CloseEvent(Event):\n    \"\"\"An event triggered by a figure being closed.\"\"\"\n\n\nclass LocationEvent(Event):\n    \"\"\"\n    An event that has a screen location.\n\n    A LocationEvent has a number of special attributes in addition to those\n    defined by the parent `Event` class.\n\n    Attributes\n    ----------\n    x, y : int or None\n        Event location in pixels from bottom left of canvas.\n    inaxes : `~matplotlib.axes.Axes` or None\n        The `~.axes.Axes` instance over which the mouse is, if any.\n    xdata, ydata : float or None\n        Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n        is not o"}], "retrieved_count": 10, "cost_time": 0.3444809913635254}
{"question": "How does Matplotlib's Artist hierarchy work for rendering plotting components?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib's Artist hierarchy works for rendering plotting components through a structured parent-child relationship system that organizes visual elements and manages the rendering process. The hierarchy operates as follows: 1) The Figure serves as the top-level container that holds all plot elements and manages the overall rendering process through its draw() method, 2) Each Figure contains multiple Axes objects, which are the primary plotting areas that contain the actual data visualization and coordinate systems, 3) Each Axes contains individual Artist objects (lines, text, patches, images, etc.) that represent the visual elements of the plot, 4) The rendering process follows the hierarchy: Figure.draw() calls draw() on each Axes, which in turn calls draw() on each child Artist, 5) The Artist class provides the fundamental interface through its draw() method, which takes a renderer parameter and delegates the actual drawing to backend-specific renderers, 6) The hierarchy supports efficient rendering through features like z-order management (artists are sorted by zorder before drawing), stale state tracking (only redrawing when necessary), and parent-child relationship management, 7) Container Artists (Figure, Axes) manage their child Artists through methods like get_children() and maintain lists of different Artist types (lines, patches, texts, images), 8) The hierarchy enables coordinate transformations, clipping, and other rendering optimizations by allowing parent containers to manage their children's rendering context, 9) The Artist hierarchy also supports interactive features like picking and event handling by maintaining the parent-child relationships that determine which Artists are affected by user interactions.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :class:`~matplotlib.lines.Line2D`) although\n# the containers also have some properties as well -- for example the\n# :class:`~matplotlib.axes.Axes` :class:`~matplotlib.artist.Artist` is a\n# container that contains many of the primitives in your plot, but it\n# also has properties like the ``xscale`` to control whether the xaxis\n# is 'linear' or 'log'.  In this section we'll review where the various\n# container objects store the ``Artists`` that you want to get at.\n#\n# .. _figure-container:\n#\n# Figure container\n# ----------------\n#\n# The top level container ``Artist`` is the\n# :class:`matplotlib.figure.Figure`, and it contains everything in the\n# figure.  The background of the figure is a\n# :class:`~matplotlib.patches.Rectangle` which is stored in\n# :attr:`!Figure.patch`.  As\n# you add subplots (:meth:`~matplotlib.figure.Figure.add_subplot`) and\n# Axes (:meth:`~matplotlib.figure.Figure.add_axes`) to the figure\n# these will be appended to the :attr:`Figure.axes\n# <matplotlib.figure.Figure.axe"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      ax.patches\n# `~.axes.Axes.errorbar` - error bar plots   `.Line2D` and      ax.lines and\n#                                            `.Rectangle`       ax.patches\n# `~.axes.Axes.fill` - shared area           `.Polygon`         ax.patches\n# `~.axes.Axes.hist` - histograms            `.Rectangle`       ax.patches\n# `~.axes.Axes.imshow` - image data          `.AxesImage`       ax.images\n# `~.axes.Axes.legend` - Axes legend         `.Legend`          ax.get_legend()\n# `~.axes.Axes.plot` - xy plots              `.Line2D`          ax.lines\n# `~.axes.Axes.scatter` - scatter charts     `.PolyCollection`  ax.collections\n# `~.axes.Axes.text` - text                  `.Text`            ax.texts\n# =========================================  =================  ===============\n#\n#\n# In addition to all of these ``Artists``, the ``Axes`` contains two\n# important ``Artist`` containers: the :class:`~matplotlib.axis.XAxis`\n# and :class:`~matplotlib.axis.YAxis`, which handle the drawing of the\n# ticks and labels.  These are stored as instance variables\n# :attr:`!matplotlib.axes.Axes.xaxis` and\n# :attr:`!matplotlib.axes.Axes.yaxis`.  The ``XAxis`` and ``YAxis``\n# containers will be detailed below, but note that the ``Axes`` contains\n# many helper methods which forward calls on to the\n# :class:`~matplotlib.axis.Axis` instances, so you often do not need to\n# work with them directly unless you want to.  For example, you can set\n# the font color of the ``XAxis`` ticklabels using the ``Axes`` helper\n# method::\n#\n#     ax.tick_params(axis='x', labelcolor='orange')\n#\n# Below is a summary of the Artists that the `~.axes.Axes` contains\n#\n# ==============    =========================================\n# Axes attribute    Description\n# ==============    =========================================\n# artists           An `.ArtistList` of `.Artist` instances\n# patch             `.Rectangle` instance for Axes background\n# collections       An `.ArtistList` of `.Collection` instances\n# images          "}, {"start_line": 125000, "end_line": 127000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".inverted().transform(\n                        (0., 2 * top - title.get_window_extent(renderer).ymin))\n                    title.set_position((x, y))\n\n        ymax = max(title.get_position()[1] for title in titles)\n        for title in titles:\n            # now line up all the titles at the highest baseline.\n            x, _ = title.get_position()\n            title.set_position((x, ymax))\n\n    # Drawing\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child Axes...\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n     "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "mpl_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         return SimpleChainedObjects(list(self.values()))\n                else:\n                    raise ValueError(\"Unsupported slice\")\n            else:\n                return dict.__getitem__(self, k)\n\n        def __call__(self, *v, **kwargs):\n            return maxes.Axes.axis(self.axes, *v, **kwargs)\n\n    @property\n    def axis(self):\n        return self._axislines\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n        # Init axis artists.\n        self._axislines = self.AxisDict(self)\n        self._axislines.update(\n            bottom=SimpleAxisArtist(self.xaxis, 1, self.spines[\"bottom\"]),\n            top=SimpleAxisArtist(self.xaxis, 2, self.spines[\"top\"]),\n            left=SimpleAxisArtist(self.yaxis, 1, self.spines[\"left\"]),\n            right=SimpleAxisArtist(self.yaxis, 2, self.spines[\"right\"]))\n\n\nclass SimpleAxisArtist(Artist):\n    def __init__(self, axis, axisnum, spine):\n        self._axis = axis\n        self._axisnum = axisnum\n        self.line = spine\n\n        if isinstance(axis, XAxis):\n            self._axis_direction = [\"bottom\", \"top\"][axisnum-1]\n        elif isinstance(axis, YAxis):\n            self._axis_direction = [\"left\", \"right\"][axisnum-1]\n        else:\n            raise ValueError(\n                f\"axis must be instance of XAxis or YAxis, but got {axis}\")\n        super().__init__()\n\n    @property\n    def major_ticks(self):\n        tickline = \"tick%dline\" % self._axisnum\n        return SimpleChainedObjects([getattr(tick, tickline)\n                                     for tick in self._axis.get_major_ticks()])\n\n    @property\n    def major_ticklabels(self):\n        label = \"label%d\" % self._axisnum\n        return SimpleChainedObjects([getattr(tick, label)\n                                     for tick in self._axis.get_major_ticks()])\n\n    @property\n    def label(self):\n        return self._axis.label\n\n    def set_visible(self, b):\n        self.toggle(all=b)\n        self.line.set_visible(b)\n        self._axis.set_v"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ist, invalid_types))\n            )\n\n        def __repr__(self):\n            return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n\n        def __len__(self):\n            return sum(self._type_check(artist)\n                       for artist in self._axes._children)\n\n        def __iter__(self):\n            for artist in list(self._axes._children):\n                if self._type_check(artist):\n                    yield artist\n\n        def __getitem__(self, key):\n            return [artist\n                    for artist in self._axes._children\n                    if self._type_check(artist)][key]\n\n        def __add__(self, other):\n            if isinstance(other, (list, _AxesBase.ArtistList)):\n                return [*self, *other]\n            if isinstance(other, (tuple, _AxesBase.ArtistList)):\n                return (*self, *other)\n            return NotImplemented\n\n        def __radd__(self, other):\n            if isinstance(other, list):\n                return other + list(self)\n            if isinstance(other, tuple):\n                return other + tuple(self)\n            return NotImplemented\n\n    @property\n    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n\n    @property\n    def collections(self):\n        return self.ArtistList(self, 'collections',\n                               valid_types=mcoll.Collection)\n\n    @property\n    def images(self):\n        return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n\n    @property\n    def lines(self):\n        return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n\n    @property\n    def patches(self):\n        return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n\n    @property\n    def tables(self):\n        return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n\n    @property\n    def texts(self):\n        return self.Arti"}], "retrieved_count": 10, "cost_time": 0.3506438732147217}
{"question": "How does Matplotlib implement its caching system for performance optimization?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its caching system for performance optimization through multiple layers of caching mechanisms that store and reuse expensive computational results. The caching system operates as follows: 1) Artist state caching - Artists track their 'stale' state to avoid unnecessary redraws, only updating when properties have actually changed, 2) Background caching for blitting - the animation system caches static background elements (axes, labels, grid) and only redraws changing artists, dramatically improving animation performance, 3) Font and text caching - the TexManager caches compiled TeX output to avoid recompiling identical text strings, storing results in a hierarchical cache directory structure, 4) Path simplification caching - line segments are simplified and cached to reduce rendering complexity for repeated draws, 5) Renderer caching - backend renderers cache expensive operations like coordinate transformations and clipping regions, 6) Figure canvas caching - the canvas caches pixel buffers and only updates regions that have changed, 7) Style and configuration caching - rcParams and style settings are cached to avoid repeated lookups, 8) Font cache management - the Agg backend uses font_cache_manager to cache glyph data and avoid repeated font rendering operations, 9) Memory management - the caching system includes automatic cache cleanup to prevent memory bloat, with cache size limits and LRU eviction policies. These caching mechanisms work together to minimize redundant computations, reduce memory allocations, and improve rendering speed, especially for interactive plots and animations where the same elements are drawn repeatedly with only small changes.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_.\n\nThe module also provides functions for checking whether an object can be\ninterpreted as a color (`is_color_like`), for converting such an object\nto an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the\n\"#rrggbb\" format (`to_hex`), and a sequence of colors to an (n, 4)\nRGBA array (`to_rgba_array`).  Caching is used for efficiency.\n\nColors that Matplotlib recognizes are listed at\n:ref:`colors_def`.\n\n.. _palettable: https://jiffyclub.github.io/palettable/\n.. _xkcd color survey: https://xkcd.com/color/rgb/\n\"\"\"\n\nimport base64\nfrom collections.abc import Sequence, Mapping\nfrom abc import ABC, abstractmethod\nimport functools\nimport importlib\nimport inspect\nimport io\nimport itertools\nfrom numbers import Real\nimport re\n\nfrom PIL import Image\nfrom PIL.PngImagePlugin import PngInfo\n\nimport matplotlib as mpl\nimport numpy as np\nfrom matplotlib import _api, _cm, cbook, scale, _image\nfrom ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS\n\n\nclass _ColorMapping(dict):\n    def __init__(self, mapping):\n        super().__init__(mapping)\n        self.cache = {}\n\n    def __setitem__(self, key, value):\n        super().__setitem__(key, value)\n        self.cache.clear()\n\n    def __delitem__(self, key):\n        super().__delitem__(key)\n        self.cache.clear()\n\n\n_colors_full_map = {}\n# Set by reverse priority order.\n_colors_full_map.update(XKCD_COLORS)\n_colors_full_map.update({k.replace('grey', 'gray'): v\n                         for k, v in XKCD_COLORS.items()\n                         if 'grey' in k})\n_colors_full_map.update(CSS4_COLORS)\n_colors_full_map.update(TABLEAU_COLORS)\n_colors_full_map.update({k.replace('gray', 'grey'): v\n                         for k, v in TABLEAU_COLORS.items()\n                         if 'gray' in k})\n_colors_full_map.update(BASE_COLORS)\n_colors_full_map = _ColorMapping(_colors_full_map)\n\n_REPR_PNG_SIZE = (512, 64)\n_BIVAR_REPR_PNG_SIZE = 256\n\n\ndef get_named_colors_mapping():\n    \"\"\"Return the global mapping of names to nam"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h the :file:`matplotlib`\n    subdirectory is created.\n\nMatplotlib was initially written by John D. Hunter (1968-2012) and is now\ndeveloped and maintained by a host of others.\n\nOccasionally the internal documentation (python docstrings) will refer\nto MATLABÂ®, a registered trademark of The MathWorks, Inc.\n\n\"\"\"\n\n__all__ = [\n    \"__bibtex__\",\n    \"__version__\",\n    \"__version_info__\",\n    \"set_loglevel\",\n    \"ExecutableNotFoundError\",\n    \"get_configdir\",\n    \"get_cachedir\",\n    \"get_data_path\",\n    \"matplotlib_fname\",\n    \"MatplotlibDeprecationWarning\",\n    \"RcParams\",\n    \"rc_params\",\n    \"rc_params_from_file\",\n    \"rcParamsDefault\",\n    \"rcParams\",\n    \"rcParamsOrig\",\n    \"defaultParams\",\n    \"rc\",\n    \"rcdefaults\",\n    \"rc_file_defaults\",\n    \"rc_file\",\n    \"rc_context\",\n    \"use\",\n    \"get_backend\",\n    \"interactive\",\n    \"is_interactive\",\n    \"colormaps\",\n    \"multivar_colormaps\",\n    \"bivar_colormaps\",\n    \"color_sequences\",\n]\n\n\nimport atexit\nfrom collections import namedtuple\nfrom collections.abc import MutableMapping\nimport contextlib\nimport functools\nimport importlib\nimport inspect\nfrom inspect import Parameter\nimport locale\nimport logging\nimport os\nfrom pathlib import Path\nimport pprint\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom packaging.version import parse as parse_version\n\n# cbook must import matplotlib only within function\n# definitions, so it is safe to import from it here.\nfrom . import _api, _version, cbook, _docstring, rcsetup\nfrom matplotlib._api import MatplotlibDeprecationWarning\nfrom matplotlib.colors import _color_sequences as color_sequences\nfrom matplotlib.rcsetup import cycler  # noqa: F401\n\n\n_log = logging.getLogger(__name__)\n\n__bibtex__ = r\"\"\"@Article{Hunter:2007,\n  Author    = {Hunter, J. D.},\n  Title     = {Matplotlib: A 2D graphics environment},\n  Journal   = {Computing in Science \\& Engineering},\n  Volume    = {9},\n  Number    = {3},\n  Pages     = {90--95},\n  abstract  = {Matplotlib is a 2D graphics packa"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e Text._get_layout() call, which is\n    # called within the _get_textbox. So, it would better to move this\n    # function as a method with some refactoring of _get_layout method.\n\n    projected_xs = []\n    projected_ys = []\n\n    theta = np.deg2rad(text.get_rotation())\n    tr = Affine2D().rotate(-theta)\n\n    _, parts, d = text._get_layout(renderer)\n\n    for t, wh, x, y in parts:\n        w, h = wh\n\n        xt1, yt1 = tr.transform((x, y))\n        yt1 -= d\n        xt2, yt2 = xt1 + w, yt1 + h\n\n        projected_xs.extend([xt1, xt2])\n        projected_ys.extend([yt1, yt2])\n\n    xt_box, yt_box = min(projected_xs), min(projected_ys)\n    w_box, h_box = max(projected_xs) - xt_box, max(projected_ys) - yt_box\n\n    x_box, y_box = Affine2D().rotate(theta).transform((xt_box, yt_box))\n\n    return x_box, y_box, w_box, h_box\n\n\ndef _get_text_metrics_with_cache(renderer, text, fontprop, ismath, dpi):\n    \"\"\"Call ``renderer.get_text_width_height_descent``, caching the results.\"\"\"\n    # Cached based on a copy of fontprop so that later in-place mutations of\n    # the passed-in argument do not mess up the cache.\n    return _get_text_metrics_with_cache_impl(\n        weakref.ref(renderer), text, fontprop.copy(), ismath, dpi)\n\n\n@functools.lru_cache(4096)\ndef _get_text_metrics_with_cache_impl(\n        renderer_ref, text, fontprop, ismath, dpi):\n    # dpi is unused, but participates in cache invalidation (via the renderer).\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n\n\n@_docstring.interpd\n@_api.define_aliases({\n    \"color\": [\"c\"],\n    \"fontproperties\": [\"font\", \"font_properties\"],\n    \"fontfamily\": [\"family\"],\n    \"fontname\": [\"name\"],\n    \"fontsize\": [\"size\"],\n    \"fontstretch\": [\"stretch\"],\n    \"fontstyle\": [\"style\"],\n    \"fontvariant\": [\"variant\"],\n    \"fontweight\": [\"weight\"],\n    \"horizontalalignment\": [\"ha\"],\n    \"verticalalignment\": [\"va\"],\n    \"multialignment\": [\"ma\"],\n})\nclass Text(Artist):\n    \"\"\"Handle storing and drawing of text in window or data "}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".environ.get('XDG_CACHE_HOME') or str(Path.home() / \".cache\")\n\n\ndef _get_config_or_cache_dir(xdg_base_getter):\n    configdir = os.environ.get('MPLCONFIGDIR')\n    if configdir:\n        configdir = Path(configdir)\n    elif sys.platform.startswith(('linux', 'freebsd')):\n        # Only call _xdg_base_getter here so that MPLCONFIGDIR is tried first,\n        # as _xdg_base_getter can throw.\n        configdir = Path(xdg_base_getter(), \"matplotlib\")\n    else:\n        configdir = Path.home() / \".matplotlib\"\n    # Resolve the path to handle potential issues with inaccessible symlinks.\n    configdir = configdir.resolve()\n    try:\n        configdir.mkdir(parents=True, exist_ok=True)\n    except OSError as exc:\n        _log.warning(\"mkdir -p failed for path %s: %s\", configdir, exc)\n    else:\n        if os.access(str(configdir), os.W_OK) and configdir.is_dir():\n            return str(configdir)\n        _log.warning(\"%s is not a writable directory\", configdir)\n    # If the config or cache directory cannot be created or is not a writable\n    # directory, create a temporary one.\n    try:\n        tmpdir = tempfile.mkdtemp(prefix=\"matplotlib-\")\n    except OSError as exc:\n        raise OSError(\n            f\"Matplotlib requires access to a writable cache directory, but there \"\n            f\"was an issue with the default path ({configdir}), and a temporary \"\n            f\"directory could not be created; set the MPLCONFIGDIR environment \"\n            f\"variable to a writable directory\") from exc\n    os.environ[\"MPLCONFIGDIR\"] = tmpdir\n    atexit.register(shutil.rmtree, tmpdir)\n    _log.warning(\n        \"Matplotlib created a temporary cache directory at %s because there was \"\n        \"an issue with the default path (%s); it is highly recommended to set the \"\n        \"MPLCONFIGDIR environment variable to a writable directory, in particular to \"\n        \"speed up the import of Matplotlib and to better support multiprocessing.\",\n        tmpdir, configdir)\n    return tmpdir\n\n\n@_logged_cached('"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "cache_zenodo_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   except OSError:\n            pass\n\n    return BytesIO(data)\n\n\ndef _get_xdg_cache_dir():\n    \"\"\"\n    Return the XDG cache directory.\n\n    See\n    https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n    \"\"\"\n    cache_dir = os.environ.get(\"XDG_CACHE_HOME\")\n    if not cache_dir:\n        cache_dir = os.path.expanduser(\"~/.cache\")\n        if cache_dir.startswith(\"~/\"):  # Expansion failed.\n            return None\n    return Path(cache_dir, \"matplotlib\")\n\n\nif __name__ == \"__main__\":\n    data = {\n        \"v3.10.0\": \"14464227\",\n        \"v3.9.4\": \"14436121\",\n        \"v3.9.3\": \"14249941\",\n        \"v3.9.2\": \"13308876\",\n        \"v3.9.1\": \"12652732\",\n        \"v3.9.0\": \"11201097\",\n        \"v3.8.4\": \"10916799\",\n        \"v3.8.3\": \"10661079\",\n        \"v3.8.2\": \"10150955\",\n        \"v3.8.1\": \"10059757\",\n        \"v3.8.0\": \"8347255\",\n        \"v3.7.3\": \"8336761\",\n        \"v3.7.2\": \"8118151\",\n        \"v3.7.1\": \"7697899\",\n        \"v3.7.0\": \"7637593\",\n        \"v3.6.3\": \"7527665\",\n        \"v3.6.2\": \"7275322\",\n        \"v3.6.1\": \"7162185\",\n        \"v3.6.0\": \"7084615\",\n        \"v3.5.3\": \"6982547\",\n        \"v3.5.2\": \"6513224\",\n        \"v3.5.1\": \"5773480\",\n        \"v3.5.0\": \"5706396\",\n        \"v3.4.3\": \"5194481\",\n        \"v3.4.2\": \"4743323\",\n        \"v3.4.1\": \"4649959\",\n        \"v3.4.0\": \"4638398\",\n        \"v3.3.4\": \"4475376\",\n        \"v3.3.3\": \"4268928\",\n        \"v3.3.2\": \"4030140\",\n        \"v3.3.1\": \"3984190\",\n        \"v3.3.0\": \"3948793\",\n        \"v3.2.2\": \"3898017\",\n        \"v3.2.1\": \"3714460\",\n        \"v3.2.0\": \"3695547\",\n        \"v3.1.3\": \"3633844\",\n        \"v3.1.2\": \"3563226\",\n        \"v3.1.1\": \"3264781\",\n        \"v3.1.0\": \"2893252\",\n        \"v3.0.3\": \"2577644\",\n        \"v3.0.2\": \"1482099\",\n        \"v3.0.1\": \"1482098\",\n        \"v2.2.5\": \"3633833\",\n        \"v3.0.0\": \"1420605\",\n        \"v2.2.4\": \"2669103\",\n        \"v2.2.3\": \"1343133\",\n        \"v2.2.2\": \"1202077\",\n        \"v2.2.1\": \"1202050\",\n        \"v2.2.0\": \"1189358\",\n        \"v2.1.2\": \"1154287\",\n        \"v2.1.1\": "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nClasses for including text in a figure.\n\"\"\"\n\nimport functools\nimport logging\nimport math\nfrom numbers import Real\nimport weakref\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, artist, cbook, _docstring\nfrom .artist import Artist\nfrom .font_manager import FontProperties\nfrom .patches import FancyArrowPatch, FancyBboxPatch, Rectangle\nfrom .textpath import TextPath, TextToPath  # noqa # Logically located here\nfrom .transforms import (\n    Affine2D, Bbox, BboxBase, BboxTransformTo, IdentityTransform, Transform)\n\n\n_log = logging.getLogger(__name__)\n\n\ndef _get_textbox(text, renderer):\n    \"\"\"\n    Calculate the bounding box of the text.\n\n    The bbox position takes text rotation into account, but the width and\n    height are those of the unrotated box (unlike `.Text.get_window_extent`).\n    \"\"\"\n    # TODO : This function may move into the Text class as a method. As a\n    # matter of fact, the information from the _get_textbox function\n    # should be available during the Text._get_layout() call, which is\n    # called within the _get_textbox. So, it would better to move this\n    # function as a method with some refactoring of _get_layout method.\n\n    projected_xs = []\n    projected_ys = []\n\n    theta = np.deg2rad(text.get_rotation())\n    tr = Affine2D().rotate(-theta)\n\n    _, parts, d = text._get_layout(renderer)\n\n    for t, wh, x, y in parts:\n        w, h = wh\n\n        xt1, yt1 = tr.transform((x, y))\n        yt1 -= d\n        xt2, yt2 = xt1 + w, yt1 + h\n\n        projected_xs.extend([xt1, xt2])\n        projected_ys.extend([yt1, yt2])\n\n    xt_box, yt_box = min(projected_xs), min(projected_ys)\n    w_box, h_box = max(projected_xs) - xt_box, max(projected_ys) - yt_box\n\n    x_box, y_box = Affine2D().rotate(theta).transform((xt_box, yt_box))\n\n    return x_box, y_box, w_box, h_box\n\n\ndef _get_text_metrics_with_cache(renderer, text, fontprop, ismath, dpi):\n    \"\"\"Call ``renderer.get_text_width_height_descent``, caching the results.\"\"\"\n    # Cached based on a co"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()\n\n    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc\n\n    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=round(size),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)\n\n\nclass GraphicsContextWx(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.\n\n    This class stores a reference to a wxMemoryDC, and a\n    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext\n    seems to be fairly heavy, so these objects are cached based on the\n    bitmap object that is passed in.\n\n    The base GraphicsContext stores colors as an RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\n    since wxPython colour management is rather simple, I have not chosen\n    to implement a separate colour manager class.\n    \"\"\"\n    _capd = {'butt': wx.CAP_BUTT,\n             'projecting': wx.CAP_PROJECTING"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "FT2Font).\n    \"\"\"\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        super().__init__(default_font_prop, load_glyph_flags)\n        # Per-instance cache.\n        self._get_info = functools.cache(self._get_info)  # type: ignore[method-assign]\n        self._fonts = {}\n        self.fontmap: dict[str | int, str] = {}\n\n        filename = findfont(self.default_font_prop)\n        default_font = get_font(filename)\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font\n\n    def _get_font(self, font: str | int) -> FT2Font:\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            # NOTE: An int is only passed by subclasses which have placed int keys into\n            # `self.fontmap`, so we must cast this to confirm it to typing.\n            basename = T.cast(str, font)\n        cached_font = self._fonts.get(basename)\n        if cached_font is None and os.path.exists(basename):\n            cached_font = get_font(basename)\n            self._fonts[basename] = cached_font\n            self._fonts[cached_font.postscript_name] = cached_font\n            self._fonts[cached_font.postscript_name.lower()] = cached_font\n        return T.cast(FT2Font, cached_font)  # FIXME: Not sure this is guaranteed.\n\n    def _get_offset(self, font: FT2Font, glyph: Glyph, fontsize: float,\n                    dpi: float) -> float:\n        if font.postscript_name == 'Cmex10':\n            return (glyph.height / 64 / 2) + (fontsize/3 * dpi/72)\n        return 0.\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        raise NotImplementedError\n\n    # The return value of _get_info is cached per-instance.\n    def _get_info(self, fontname: str, font_class: str, sym: str, fontsize: float,\n                  dpi: float) -> FontInfo:\n        font, num, slanted = self._get_glyph(fontname, font_class, sym)\n        font.set_size(f"}], "retrieved_count": 10, "cost_time": 0.3275260925292969}
{"question": "How does Matplotlib handle coordinate transformations between data and display coordinates?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles coordinate transformations between data and display coordinates through a sophisticated transformation system implemented in the transforms module. The system works as follows: 1) The core transformation system is built around the Transform class hierarchy, with CompositeGenericTransform being the most commonly used type that combines multiple transformations, 2) Each Axes object maintains several key transformation objects: transData (data to display), transAxes (axes coordinates to display), and transFigure (figure coordinates to display), 3) The transData transformation is a composite that combines the data scaling transformation (handling log/linear scales), the axes bounding box transformation, and the figure transformation, 4) Transformations can be inverted using the inverted() method, allowing conversion from display coordinates back to data coordinates, which is essential for event handling and interactive features, 5) The system supports multiple coordinate systems including data coordinates (the actual data values), axes coordinates (0-1 within the axes), figure coordinates (0-1 within the figure), and display coordinates (pixels or points), 6) Transformations are automatically updated when the figure size, DPI, axes limits, or scales change, ensuring that coordinate conversions remain accurate, 7) The transformation system handles both affine transformations (scaling, translation, rotation) and non-affine transformations (log scales, projections), with the latter being decomposed into non-affine and affine components for efficiency, 8) Artists use these transformations through their transform property, with the default being transData for most plotting elements, 9) The system provides utility functions like blended_transform_factory for creating mixed coordinate systems (e.g., data coordinates in x, axes coordinates in y) and supports custom transformations for specialized plotting needs.", "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       |\n+----------------+-----------------------------------+-----------------------------+\n|*display*       |The native coordinate system of the|`None`, or                   |\n|                |output ; (0, 0) is the bottom left |`.IdentityTransform()`       |\n|                |of the window, and (width, height) |                             |\n|                |is top right of the output in      |                             |\n|                |\"display units\".                   |                             |\n|                |                                   |                             |\n|                |\"Display units\" depends on the     |                             |\n|                |backend. For example, Agg uses     |                             |\n|                |pixels, and SVG/PDF use points.    |                             |\n+----------------+-----------------------------------+-----------------------------+\n\nThe `~matplotlib.transforms.Transform` objects are naive to the source and\ndestination coordinate systems, however the objects referred to in the table\nabove are constructed to take inputs in their coordinate system, and transform\nthe input to the *display* coordinate system.  That is why the *display*\ncoordinate system has `None` for the \"Transformation Object\" column -- it\nalready is in *display* coordinates.  The naming and destination conventions\nare an aid to keeping track of the available \"standard\" coordinate systems and\ntransforms.\n\nThe transformations also know how to invert themselves (via\n`.Transform.inverted`) to generate a transform from output coordinate system\nback to the input coordinate system.  For example, ``ax.transData`` converts\nvalues in data coordinates to display coordinates and\n``ax.transData.inverted()`` is a :class:`matplotlib.transforms.Transform` that\ngoes from display coordinates to data coordinates. This is particularly useful\nwhen processing events from the user interface, which typically occur in\ndisplay s"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pace, and you want to know where the mouse click or key-press occurred\nin your *data* coordinate system.\n\nNote that specifying the position of Artists in *display* coordinates may\nchange their relative location if the ``dpi`` or size of the figure changes.\nThis can cause confusion when printing or changing screen resolution, because\nthe object can change location and size.  Therefore, it is most common for\nartists placed in an Axes or figure to have their transform set to something\n*other* than the `~.transforms.IdentityTransform()`; the default when an artist\nis added to an Axes using `~.axes.Axes.add_artist` is for the transform to be\n``ax.transData`` so that you can work and think in *data* coordinates and let\nMatplotlib take care of the transformation to *display*.\n\n.. _data-coords:\n\nData coordinates\n================\n\nLet's start with the most commonly used coordinate, the *data* coordinate\nsystem.  Whenever you add data to the Axes, Matplotlib updates the datalimits,\nmost commonly updated with the :meth:`~matplotlib.axes.Axes.set_xlim` and\n:meth:`~matplotlib.axes.Axes.set_ylim` methods.  For example, in the figure\nbelow, the data limits stretch from 0 to 10 on the x-axis, and -1 to 1 on the\ny-axis.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nplt.show()\n\n# %%\n# You can use the ``ax.transData`` instance to transform from your\n# *data* to your *display* coordinate system, either a single point or a\n# sequence of points as shown below:\n#\n# .. sourcecode:: ipython\n#\n#     In [14]: type(ax.transData)\n#     Out[14]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n#\n#     In [15]: ax.transData.transform((5, 0))\n#     Out[15]: array([ 335.175,  247.   ])\n#\n#     In [16]: ax.transData.transform([(5, 0), (1, 2)])\n#     Out[16]:\n#     array([[ 335.175,  247.   ],\n#    "}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ation, but you may not\n# need to compute the potentially expensive nonlinear scales or\n# projections on simple navigation events.  It is also possible to\n# multiply affine transformation matrices together, and then apply them\n# to coordinates in one step.  This is not true of all possible\n# transformations.\n#\n#\n# Here is how the ``ax.transData`` instance is defined in the basic\n# separable axis :class:`~matplotlib.axes.Axes` class::\n#\n#   self.transData = self.transScale + (self.transLimits + self.transAxes)\n#\n# We've been introduced to the ``transAxes`` instance above in\n# :ref:`axes-coords`, which maps the (0, 0), (1, 1) corners of the\n# Axes or subplot bounding box to *display* space, so let's look at\n# these other two pieces.\n#\n# ``self.transLimits`` is the transformation that takes you from\n# *data* to *axes* coordinates; i.e., it maps your view xlim and ylim\n# to the unit space of the Axes (and ``transAxes`` then takes that unit\n# space to display space).  We can see this in action here\n#\n# .. sourcecode:: ipython\n#\n#     In [80]: ax = plt.subplot()\n#\n#     In [81]: ax.set_xlim(0, 10)\n#     Out[81]: (0, 10)\n#\n#     In [82]: ax.set_ylim(-1, 1)\n#     Out[82]: (-1, 1)\n#\n#     In [84]: ax.transLimits.transform((0, -1))\n#     Out[84]: array([ 0.,  0.])\n#\n#     In [85]: ax.transLimits.transform((10, -1))\n#     Out[85]: array([ 1.,  0.])\n#\n#     In [86]: ax.transLimits.transform((10, 1))\n#     Out[86]: array([ 1.,  1.])\n#\n#     In [87]: ax.transLimits.transform((5, 0))\n#     Out[87]: array([ 0.5,  0.5])\n#\n# and we can use this same inverted transformation to go from the unit\n# *axes* coordinates back to *data* coordinates.\n#\n# .. sourcecode:: ipython\n#\n#     In [90]: inv.transform((0.25, 0.25))\n#     Out[90]: array([ 2.5, -0.5])\n#\n# The final piece is the ``self.transScale`` attribute, which is\n# responsible for the optional non-linear scaling of the data, e.g., for\n# logarithmic axes.  When an Axes is initially setup, this is just set to\n# the identity transform, si"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " updated with the :meth:`~matplotlib.axes.Axes.set_xlim` and\n:meth:`~matplotlib.axes.Axes.set_ylim` methods.  For example, in the figure\nbelow, the data limits stretch from 0 to 10 on the x-axis, and -1 to 1 on the\ny-axis.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nplt.show()\n\n# %%\n# You can use the ``ax.transData`` instance to transform from your\n# *data* to your *display* coordinate system, either a single point or a\n# sequence of points as shown below:\n#\n# .. sourcecode:: ipython\n#\n#     In [14]: type(ax.transData)\n#     Out[14]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n#\n#     In [15]: ax.transData.transform((5, 0))\n#     Out[15]: array([ 335.175,  247.   ])\n#\n#     In [16]: ax.transData.transform([(5, 0), (1, 2)])\n#     Out[16]:\n#     array([[ 335.175,  247.   ],\n#            [ 132.435,  642.2  ]])\n#\n# You can use the :meth:`~matplotlib.transforms.Transform.inverted`\n# method to create a transform which will take you from *display* to *data*\n# coordinates:\n#\n# .. sourcecode:: ipython\n#\n#     In [41]: inv = ax.transData.inverted()\n#\n#     In [42]: type(inv)\n#     Out[42]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n#\n#     In [43]: inv.transform((335.175,  247.))\n#     Out[43]: array([ 5.,  0.])\n#\n# If your are typing along with this tutorial, the exact values of the\n# *display* coordinates may differ if you have a different window size or\n# dpi setting.  Likewise, in the figure below, the display labeled\n# points are probably not the same as in the ipython session because the\n# documentation figure size defaults are different.\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\n# This computing the transform now, if anythin"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         TransformWrapper(\n#                         BlendedAffine2D(\n#                             IdentityTransform(),\n#                             IdentityTransform())))),\n#             BboxTransformTo(\n#                 TransformedBbox(\n#                     Bbox(x0=0.125, y0=0.10999999999999999, x1=0.9, y1=0.88),\n#                     BboxTransformTo(\n#                         TransformedBbox(\n#                             Bbox(x0=0.0, y0=0.0, x1=6.4, y1=4.8),\n#                             Affine2D(\n#                                 [[100.   0.   0.]\n#                                  [  0. 100.   0.]\n#                                  [  0.   0.   1.]])))))))\n#\n#     # the default Axes transformation is ax.transData\n#     In [269]: print(ax.transData)\n#     CompositeGenericTransform(\n#         TransformWrapper(\n#             BlendedAffine2D(\n#                 IdentityTransform(),\n#                 IdentityTransform())),\n#         CompositeGenericTransform(\n#             BboxTransformFrom(\n#                 TransformedBbox(\n#                     Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0),\n#                     TransformWrapper(\n#                         BlendedAffine2D(\n#                             IdentityTransform(),\n#                             IdentityTransform())))),\n#             BboxTransformTo(\n#                 TransformedBbox(\n#                     Bbox(x0=0.125, y0=0.10999999999999999, x1=0.9, y1=0.88),\n#                     BboxTransformTo(\n#                         TransformedBbox(\n#                             Bbox(x0=0.0, y0=0.0, x1=6.4, y1=4.8),\n#                             Affine2D(\n#                                 [[100.   0.   0.]\n#                                  [  0. 100.   0.]\n#                                  [  0.   0.   1.]])))))))\n#\n#     # notice that the xlimits of the Axes have not been changed\n#     In [270]: print(ax.get_xlim())\n#     (0.0, 1.0)\n#\n#     # but the data limits have been updated to encompass the rectangle\n#     In "}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "on here\n#\n# .. sourcecode:: ipython\n#\n#     In [80]: ax = plt.subplot()\n#\n#     In [81]: ax.set_xlim(0, 10)\n#     Out[81]: (0, 10)\n#\n#     In [82]: ax.set_ylim(-1, 1)\n#     Out[82]: (-1, 1)\n#\n#     In [84]: ax.transLimits.transform((0, -1))\n#     Out[84]: array([ 0.,  0.])\n#\n#     In [85]: ax.transLimits.transform((10, -1))\n#     Out[85]: array([ 1.,  0.])\n#\n#     In [86]: ax.transLimits.transform((10, 1))\n#     Out[86]: array([ 1.,  1.])\n#\n#     In [87]: ax.transLimits.transform((5, 0))\n#     Out[87]: array([ 0.5,  0.5])\n#\n# and we can use this same inverted transformation to go from the unit\n# *axes* coordinates back to *data* coordinates.\n#\n# .. sourcecode:: ipython\n#\n#     In [90]: inv.transform((0.25, 0.25))\n#     Out[90]: array([ 2.5, -0.5])\n#\n# The final piece is the ``self.transScale`` attribute, which is\n# responsible for the optional non-linear scaling of the data, e.g., for\n# logarithmic axes.  When an Axes is initially setup, this is just set to\n# the identity transform, since the basic Matplotlib axes has linear\n# scale, but when you call a logarithmic scaling function like\n# :meth:`~matplotlib.axes.Axes.semilogx` or explicitly set the scale to\n# logarithmic with :meth:`~matplotlib.axes.Axes.set_xscale`, then the\n# ``ax.transScale`` attribute is set to handle the nonlinear projection.\n# The scales transforms are properties of the respective ``xaxis`` and\n# ``yaxis`` :class:`~matplotlib.axis.Axis` instances.  For example, when\n# you call ``ax.set_xscale('log')``, the xaxis updates its scale to a\n# :class:`matplotlib.scale.LogScale` instance.\n#\n# For non-separable axes the PolarAxes, there is one more piece to\n# consider, the projection transformation.  The ``transData``\n# :class:`matplotlib.projections.polar.PolarAxes` is similar to that for\n# the typical separable matplotlib Axes, with one additional piece\n# ``transProjection``::\n#\n#        self.transData = (\n#            self.transScale + self.transShift + self.transProjection +\n#            (self.tran"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "assert_array_equal(expected_result, result)\n\n        result = self.stack2.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n\nclass TestTransformPlotInterface:\n    def test_line_extent_axes_coords(self):\n        # a simple line in axes coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transAxes)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, np.inf],\n                                     [-np.inf, -np.inf]]))\n\n    def test_line_extent_data_coords(self):\n        # a simple line in data coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transData)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[0.1,  0.5], [1.2,  0.9]]))\n\n    def test_line_extent_compound_coords1(self):\n        # a simple line in data coordinates in the y component, and in axes\n        # coordinates in the x\n        ax = plt.axes()\n        trans = mtransforms.blended_transform_factory(ax.transAxes,\n                                                      ax.transData)\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, -5.],\n                                     [-np.inf, 35.]]))\n\n    def test_line_extent_predata_transform_coords(self):\n        # a simple line in (offset + data) coordinates\n        ax = plt.axes()\n        trans = mtransforms.Affine2D().scale(10) + ax.transData\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[1., -50.], [12., 350.]]))\n\n    def test_line_extent_compound_coords2(self):\n        # a simple line in (offset + data) coordinates in the y component, and\n        # in axes coordinates in the x\n        ax = plt.axes()\n        trans = mtransforms.blended_transfo"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " case that we have a special helper function to\n#   create it in :func:`matplotlib.transforms.offset_copy`, which returns\n#   a new transform with an added offset. So above we could have done::\n#\n#      shadow_transform = transforms.offset_copy(ax.transData,\n#               fig, dx, dy, units='inches')\n#\n#\n# .. _transformation-pipeline:\n#\n# The transformation pipeline\n# ===========================\n#\n# The ``ax.transData`` transform we have been working with in this\n# tutorial is a composite of three different transformations that\n# comprise the transformation pipeline from *data* -> *display*\n# coordinates.  Michael Droettboom implemented the transformations\n# framework, taking care to provide a clean API that segregated the\n# nonlinear projections and scales that happen in polar and logarithmic\n# plots, from the linear affine transformations that happen when you pan\n# and zoom.  There is an efficiency here, because you can pan and zoom\n# in your Axes which affects the affine transformation, but you may not\n# need to compute the potentially expensive nonlinear scales or\n# projections on simple navigation events.  It is also possible to\n# multiply affine transformation matrices together, and then apply them\n# to coordinates in one step.  This is not true of all possible\n# transformations.\n#\n#\n# Here is how the ``ax.transData`` instance is defined in the basic\n# separable axis :class:`~matplotlib.axes.Axes` class::\n#\n#   self.transData = self.transScale + (self.transLimits + self.transAxes)\n#\n# We've been introduced to the ``transAxes`` instance above in\n# :ref:`axes-coords`, which maps the (0, 0), (1, 1) corners of the\n# Axes or subplot bounding box to *display* space, so let's look at\n# these other two pieces.\n#\n# ``self.transLimits`` is the transformation that takes you from\n# *data* to *axes* coordinates; i.e., it maps your view xlim and ylim\n# to the unit space of the Axes (and ``transAxes`` then takes that unit\n# space to display space).  We can see this in acti"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "np.float64)\n\n        # check we have the expected results from doing the affine part only\n        assert_array_almost_equal(na_pts, na_expected)\n        # check we have the expected results from a full transformation\n        assert_array_almost_equal(all_pts, all_expected)\n        # check we have the expected results from doing the transformation in\n        # two steps\n        assert_array_almost_equal(self.stack1.transform_affine(na_pts),\n                                  all_expected)\n        # check that getting the affine transformation first, then fully\n        # transforming using that yields the same result as before.\n        assert_array_almost_equal(self.stack1.get_affine().transform(na_pts),\n                                  all_expected)\n\n        # check that the affine part of stack1 & stack2 are equivalent\n        # (i.e. the optimization is working)\n        expected_result = (self.ta2 + self.ta3).get_matrix()\n        result = self.stack1.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n        result = self.stack2.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n\nclass TestTransformPlotInterface:\n    def test_line_extent_axes_coords(self):\n        # a simple line in axes coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transAxes)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, np.inf],\n                                     [-np.inf, -np.inf]]))\n\n    def test_line_extent_data_coords(self):\n        # a simple line in data coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transData)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[0.1,  0.5], [1.2,  0.9]]))\n\n    def test_line_extent_compound_coords1(self):\n        # a simple line in data coordinates in the y component, and in axes\n        # coordinates in the x"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "geo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/projections", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "UTION)\n\n        self.transAffine = self._get_affine_transform()\n\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # This is the transform for longitude ticks.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1, self._longitude_cap * 2) \\\n            .translate(0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, 4)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, -4)\n\n        # This is the transform for latitude ticks.\n        yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8, 0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8, 0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        _api"}], "retrieved_count": 10, "cost_time": 0.34838032722473145}
{"question": "How does Matplotlib handle different data types and formats for plotting?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles different data types and formats for plotting through a flexible and extensible data processing system. The system works as follows: 1) Numeric data - Matplotlib accepts numpy arrays, Python lists, and scalars that can be converted to arrays of floating point numbers using numpy.asarray(), with all sequences being converted to numpy arrays internally, 2) Categorical data - Strings and lists of strings are automatically converted to categorical variables using the StrCategoryConverter in lib/matplotlib/category.py, which maps unique string values to integer identifiers, 3) Date/time data - Datetime objects and numpy.datetime64 arrays are handled by built-in date converters that convert dates to floats and add appropriate tick locators and formatters, 4) Structured data - Matplotlib supports pandas DataFrames, structured numpy arrays, and dictionaries through the 'data' keyword argument, allowing users to reference data columns by string names, 5) Multi-dimensional arrays - 2D arrays are supported where columns represent separate datasets, with automatic handling of broadcasting and shape matching, 6) Mixed data types - The system supports combinations of different data types through the unit conversion system in matplotlib.units, which dispatches to appropriate converters based on data type, 7) Color data - Matplotlib accepts various color formats including RGB/RGBA tuples, hex strings, color names, and shorthand notation, with automatic conversion between formats, 8) Unit conversion - The system provides a framework for custom unit converters, allowing downstream libraries to add support for their specific data types, 9) Data validation - The system includes validation to ensure data types are compatible and provides helpful error messages for incompatible data, 10) Performance optimization - The system is designed to handle large datasets efficiently through vectorized operations and optimized data structures. This comprehensive data handling system enables Matplotlib to work with a wide variety of data sources and formats while maintaining performance and providing a consistent API.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ax]`` and specifies the viewport of the\n# Axes.\n#\n# If matplotlib were limited to working with lists, it would be fairly\n# useless for numeric processing.  Generally, you will use `numpy\n# <https://numpy.org/>`_ arrays.  In fact, all sequences are\n# converted to numpy arrays internally.  The example below illustrates\n# plotting several lines with different format styles in one function call\n# using arrays.\n\nimport numpy as np\n\n# evenly sampled time at 200ms intervals\nt = np.arange(0., 5., 0.2)\n\n# red dashes, blue squares and green triangles\nplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')\nplt.show()\n\n# %%\n# .. _plotting-with-keywords:\n#\n# Plotting with keyword strings\n# =============================\n#\n# There are some instances where you have data in a format that lets you\n# access particular variables with strings. For example, with `structured arrays`_\n# or `pandas.DataFrame`.\n#\n# .. _structured arrays: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays\n#\n# Matplotlib allows you to provide such an object with\n# the ``data`` keyword argument. If provided, then you may generate plots with\n# the strings corresponding to these variables.\n\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nplt.scatter('a', 'b', c='c', s='d', data=data)\nplt.xlabel('entry a')\nplt.ylabel('entry b')\nplt.show()\n\n# %%\n# .. _plotting-with-categorical-vars:\n#\n# Plotting with categorical variables\n# ===================================\n#\n# It is also possible to create a plot using categorical variables.\n# Matplotlib allows you to pass categorical variables directly to\n# many plotting functions. For example:\n\nnames = ['group_a', 'group_b', 'group_c']\nvalues = [1, 10, 100]\n\nplt.figure(figsize=(9, 3))\n\nplt.subplot(131)\nplt.bar(names, values)\nplt.subplot(132)\nplt.scatter(names, values)\nplt.subplot(133)\nplt.plot(names, values)\nplt.suptitle('C"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "` objects, `.Line2D` objects, :mod:`.collections` objects, `.Patch`\n# objects, etc. When the Figure is rendered, all of the\n# Artists are drawn to the **canvas**.  Most Artists are tied to an Axes; such\n# an Artist cannot be shared by multiple Axes, or moved from one to another.\n#\n# .. _input_types:\n#\n# Types of inputs to plotting functions\n# =====================================\n#\n# Plotting functions expect `numpy.array` or `numpy.ma.masked_array` as\n# input, or objects that can be passed to `numpy.asarray`.\n# Classes that are similar to arrays ('array-like') such as `pandas`\n# data objects and `numpy.matrix` may not work as intended.  Common convention\n# is to convert these to `numpy.array` objects prior to plotting.\n# For example, to convert a `numpy.matrix` ::\n#\n#   b = np.matrix([[1, 2], [3, 4]])\n#   b_asarray = np.asarray(b)\n#\n# Most methods will also parse a string-indexable object like a *dict*, a\n# `structured numpy array`_, or a `pandas.DataFrame`.  Matplotlib allows you\n# to provide the ``data`` keyword argument and generate plots passing the\n# strings corresponding to the *x* and *y* variables.\n#\n# .. _structured numpy array: https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays  # noqa: E501\n\nnp.random.seed(19680801)  # seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\n# %%\n# .. _coding_styles:\n#\n# Coding styles\n# =============\n#\n# The explicit and the implicit interfaces\n# ----------------------------------------\n#\n# As noted above, there are essentially two ways to use Matplotlib:\n#\n# - Explicitly create Figures and Axes, and call methods on them (the\n#   \"object-oriented (OO) style\").\n# - Rely on pyplot to "}, {"start_line": 307000, "end_line": 309000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " Incompatible nr columns, plot \"nothing\"\n    x = np.ones(10)\n    y = np.ones((10, 0))\n    _, ax = plt.subplots()\n    line = ax.plot(x, y)\n    assert len(line) == 0\n\n    # Ensure plot([],[]) creates line\n    _, ax = plt.subplots()\n    line = ax.plot([], [])\n    assert len(line) == 1\n\n\n@pytest.mark.parametrize('fmt, match', (\n    (\"f\", r\"'f' is not a valid format string \\(unrecognized character 'f'\\)\"),\n    (\"o+\", r\"'o\\+' is not a valid format string \\(two marker symbols\\)\"),\n    (\":-\", r\"':-' is not a valid format string \\(two linestyle symbols\\)\"),\n    (\"rk\", r\"'rk' is not a valid format string \\(two color symbols\\)\"),\n    (\":o-r\", r\"':o-r' is not a valid format string \\(two linestyle symbols\\)\"),\n    (\"C\", r\"'C' is not a valid format string \\('C' must be followed by a number\\)\"),\n    (\".C\", r\"'.C' is not a valid format string \\('C' must be followed by a number\\)\"),\n))\n@pytest.mark.parametrize(\"data\", [None, {\"string\": range(3)}])\ndef test_plot_format_errors(fmt, match, data):\n    fig, ax = plt.subplots()\n    if data is not None:\n        match = match.replace(\"not\", \"neither a data key nor\")\n    with pytest.raises(ValueError, match=r\"\\A\" + match + r\"\\Z\"):\n        ax.plot(\"string\", fmt, data=data)\n\n\ndef test_plot_format():\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1.0')\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert line[0].get_marker() == 'None'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1')\n    assert line[0].get_marker() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1.0', \"1\")\n    fig.canvas.draw()\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert ax.get_yticklabels()[0].get_text() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1', \"1.0\")\n    fig.canvas.draw()\n    assert line[0].get_marker() == '1'\n    assert ax.get_yticklabels()[0].get_text() == '1.0'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], 'k3')\n    assert line[0].get_marker"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "test_category.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ls]\n    assert list(axis.units._mapping.values()) == ticks\n\n\nclass TestPlotBytes:\n    bytes_cases = [('string list', ['a', 'b', 'c']),\n                   ('bytes list', [b'a', b'b', b'c']),\n                   ('bytes ndarray', np.array([b'a', b'b', b'c']))]\n\n    bytes_ids, bytes_data = zip(*bytes_cases)\n\n    @pytest.mark.parametrize(\"plotter\", PLOT_LIST, ids=PLOT_IDS)\n    @pytest.mark.parametrize(\"bdata\", bytes_data, ids=bytes_ids)\n    def test_plot_bytes(self, plotter, bdata):\n        ax = plt.figure().subplots()\n        counts = np.array([4, 6, 5])\n        plotter(ax, bdata, counts)\n        axis_test(ax.xaxis, bdata)\n\n\nclass TestPlotNumlike:\n    numlike_cases = [('string list', ['1', '11', '3']),\n                     ('string ndarray', np.array(['1', '11', '3'])),\n                     ('bytes list', [b'1', b'11', b'3']),\n                     ('bytes ndarray', np.array([b'1', b'11', b'3']))]\n    numlike_ids, numlike_data = zip(*numlike_cases)\n\n    @pytest.mark.parametrize(\"plotter\", PLOT_LIST, ids=PLOT_IDS)\n    @pytest.mark.parametrize(\"ndata\", numlike_data, ids=numlike_ids)\n    def test_plot_numlike(self, plotter, ndata):\n        ax = plt.figure().subplots()\n        counts = np.array([4, 6, 5])\n        plotter(ax, ndata, counts)\n        axis_test(ax.xaxis, ndata)\n\n\nclass TestPlotTypes:\n    @pytest.mark.parametrize(\"plotter\", PLOT_LIST, ids=PLOT_IDS)\n    def test_plot_unicode(self, plotter):\n        ax = plt.figure().subplots()\n        words = ['ÐÐ´ÑÐ°Ð²ÑÑÐ²ÑÐ¹ÑÐµ', 'Ð¿ÑÐ¸Ð²ÐµÑ']\n        plotter(ax, words, [0, 1])\n        axis_test(ax.xaxis, words)\n\n    @pytest.fixture\n    def test_data(self):\n        self.x = [\"hello\", \"happy\", \"world\"]\n        self.xy = [2, 6, 3]\n        self.y = [\"Python\", \"is\", \"fun\"]\n        self.yx = [3, 4, 5]\n\n    @pytest.mark.usefixtures(\"test_data\")\n    @pytest.mark.parametrize(\"plotter\", PLOT_LIST, ids=PLOT_IDS)\n    def test_plot_xaxis(self, test_data, plotter):\n        ax = plt.figure().subplots()\n        plotter(ax, self.x, self.xy)\n        axis_"}, {"start_line": 54000, "end_line": 56000, "belongs_to": {"file_name": "cbook.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ls, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : float or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.to_numpy(), y.to_numpy()\n    except AttributeError:\n        pass\n    try:\n        y = _check_1d(y)\n    except (VisibleDeprecationWarning, ValueError):\n        # NumPy 1.19 will warn on ragged input, and we can't actually use it.\n        pass\n    else:\n        return np.arange(y.shape[0], dtype=float), y\n    raise ValueError('Input could not be cast to an at-least-1D NumPy array')\n\n\ndef safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is a type-independent way of obtaining the first element,\n    supporting both index access and the iterator protocol.\n    \"\"\"\n    if isinstance(obj, collections.abc.Iterator):\n        # needed to accept `array.flat` as input.\n        # np.flatiter reports as an instance of collections.Iterator but can still be\n        # indexed via []. This has the side effect of re-setting the iterator, but\n        # that is acceptable.\n        try:\n            return obj[0]\n        except TypeError:\n            pass\n        raise RuntimeError(\"matplotlib does not support generators as input\")\n    return next(iter(obj))\n\n\ndef _safe_first_finite(obj):\n    \"\"\"\n    Return the first finite element in *obj* if one is available and skip_nonfinite is\n    True. Otherwise, return the first element.\n\n    This is a method for internal use.\n\n    This is a type-independent way of obtaining the first finite element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    def safe_isfinite(val):\n        if val is None:\n            return False\n        try:\n            return math.isfinite(val)\n        except (TypeError, ValueError):\n            # if the outer object is 2d, then val is a 1d array, and\n            # - math.isfinite(num"}, {"start_line": 308000, "end_line": 310000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " ax = plt.subplots()\n    if data is not None:\n        match = match.replace(\"not\", \"neither a data key nor\")\n    with pytest.raises(ValueError, match=r\"\\A\" + match + r\"\\Z\"):\n        ax.plot(\"string\", fmt, data=data)\n\n\ndef test_plot_format():\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1.0')\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert line[0].get_marker() == 'None'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '1')\n    assert line[0].get_marker() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1.0', \"1\")\n    fig.canvas.draw()\n    assert line[0].get_color() == (1.0, 1.0, 1.0, 1.0)\n    assert ax.get_yticklabels()[0].get_text() == '1'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2], [1, 2], '1', \"1.0\")\n    fig.canvas.draw()\n    assert line[0].get_marker() == '1'\n    assert ax.get_yticklabels()[0].get_text() == '1.0'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], 'k3')\n    assert line[0].get_marker() == '3'\n    assert line[0].get_color() == 'k'\n    fig, ax = plt.subplots()\n    line = ax.plot([1, 2, 3], '.C12:')\n    assert line[0].get_marker() == '.'\n    assert line[0].get_color() == mcolors.to_rgba('C12')\n    assert line[0].get_linestyle() == ':'\n\n\ndef test_automatic_legend():\n    fig, ax = plt.subplots()\n    ax.plot(\"a\", \"b\", data={\"d\": 2})\n    leg = ax.legend()\n    fig.canvas.draw()\n    assert leg.get_texts()[0].get_text() == 'a'\n    assert ax.get_yticklabels()[0].get_text() == 'a'\n\n    fig, ax = plt.subplots()\n    ax.plot(\"a\", \"b\", \"c\", data={\"d\": 2})\n    leg = ax.legend()\n    fig.canvas.draw()\n    assert leg.get_texts()[0].get_text() == 'b'\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n    assert ax.get_yticklabels()[0].get_text() == 'b'\n\n\ndef test_plot_errors():\n    with pytest.raises(TypeError, match=r\"plot\\(\\) got an unexpected keyword\"):\n        plt.plot([1, 2, 3], x=1)\n    with pytest.raises(ValueError, match=r\"plot\\(\\) with multiple groups\"):\n        plt.plot([1"}, {"start_line": 153000, "end_line": 155000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_finite(err), np.ndarray)\n            ):\n                # Get the type of the first element\n                atype = type(cbook._safe_first_finite(err))\n                # Promote the outer container to match the inner container\n                if atype is np.ndarray:\n                    # Converts using np.asarray, because data cannot\n                    # be directly passed to init of np.ndarray\n                    return np.asarray(err, dtype=object)\n                # If atype is not np.ndarray, directly pass data to init.\n                # This works for types such as unyts and astropy units\n                return atype(err)\n            # Otherwise wrap it in an object array\n            return np.asarray(err, dtype=object)\n\n        if xerr is not None and not isinstance(xerr, np.ndarray):\n            xerr = _upcast_err(xerr)\n        if yerr is not None and not isinstance(yerr, np.ndarray):\n            yerr = _upcast_err(yerr)\n        x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.\n        if len(x) != len(y):\n            raise ValueError(\"'x' and 'y' must have the same size\")\n\n        everymask = self._errorevery_to_mask(x, errorevery)\n\n        label = kwargs.pop(\"label\", None)\n        kwargs['label'] = '_nolegend_'\n\n        # Create the main line and determine overall kwargs for child artists.\n        # We avoid calling self.plot() directly, or self._get_lines(), because\n        # that would call self._process_unit_info again, and do other indirect\n        # data processing.\n        (data_line, base_style), = self._get_lines._plot_args(\n            self, (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)\n\n        # Do this after creating `data_line` to avoid modifying `base_style`.\n        if barsabove:\n            data_line.set_zorder(kwargs['zorder'] - .1)\n        else:\n            data_line.set_zorder(kwargs['zorder'] + .1)\n\n        # Add line to plot, or throw it away and use it to determine kwargs.\n        if fmt.lower() !="}, {"start_line": 62000, "end_line": 64000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "biguity in calls where the\n                second label is a valid *fmt*. ``plot('n', 'o', data=obj)``\n                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                ``plot('n', 'o', '', data=obj)``.\n\n        Returns\n        -------\n        list of `.Line2D`\n            A list of lines representing the plotted data.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, default: True\n            These parameters determine if the view limits are adapted to the\n            data limits. The values are passed on to\n            `~.axes.Axes.autoscale_view`.\n\n        **kwargs : `~matplotlib.lines.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you specify multiple lines with one plot call, the kwargs apply\n            to all those lines. In case the label object is iterable, each\n            element is used as labels for each set of data.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(Line2D:kwdoc)s\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n      "}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ength N and will be used for every data set m.\n\n          Example:\n\n          >>> x = [1, 2, 3]\n          >>> y = np.array([[1, 2], [3, 4], [5, 6]])\n          >>> plot(x, y)\n\n          is equivalent to:\n\n          >>> for col in range(y.shape[1]):\n          ...     plot(x, y[:, col])\n\n        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n          groups::\n\n          >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n\n          In this case, any additional keyword argument applies to all\n          datasets. Also, this syntax cannot be combined with the *data*\n          parameter.\n\n        By default, each line is assigned a different style specified by a\n        'style cycle'. The *fmt* and line property parameters are only\n        necessary if you want explicit deviations from these defaults.\n        Alternatively, you can also change the style cycle using\n        :rc:`axes.prop_cycle`.\n\n\n        Parameters\n        ----------\n        x, y : array-like or float\n            The horizontal / vertical coordinates of the data points.\n            *x* values are optional and default to ``range(len(y))``.\n\n            Commonly, these parameters are 1D arrays.\n\n            They can also be scalars, or two-dimensional (in that case, the\n            columns represent separate data sets).\n\n            These arguments cannot be passed as keywords.\n\n        fmt : str, optional\n            A format string, e.g. 'ro' for red circles. See the *Notes*\n            section for a full description of the format strings.\n\n            Format strings are just an abbreviation for quickly setting\n            basic line properties. All of these and more can also be\n            controlled by keyword arguments.\n\n            This argument cannot be passed as keyword.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n            .. note::\n                Technically there's a slight am"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "axes_units.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "im(0.5, 2.5)\nax.set_xlabel('limits set with floats')\n\n# %%\n#\n# The category axes are helpful for some plot types, but can lead to confusion\n# if data is read in as a list of strings, even if it is meant to be a list of\n# floats or dates.  This sometimes happens when reading comma-separated value\n# (CSV) files. The categorical locator and formatter will put a tick at every\n# string value and label each one as well:\n\nfig, ax = plt.subplots(figsize=(5.4, 2.5), layout='constrained')\nx = [str(xx) for xx in np.arange(100)]  # list of strings\nax.plot(x, np.arange(100))\nax.set_xlabel('x is list of strings')\n\n# %%\n#\n# If this is not desired, then simply convert the data to floats before plotting:\n\nfig, ax = plt.subplots(figsize=(5.4, 2.5), layout='constrained')\nx = np.asarray(x, dtype='float')  # array of float.\nax.plot(x, np.arange(100))\nax.set_xlabel('x is array of floats')\n\n# %%\n#\n# Determine converter, formatter, and locator on an axis\n# ======================================================\n#\n# Sometimes it is helpful to be able to debug what Matplotlib is using to\n# convert the incoming data.  We can do that by querying the ``converter``\n# property on the axis.  We can also query the formatters and locators using\n# `~.axis.Axis.get_major_locator` and `~.axis.Axis.get_major_formatter`.\n#\n# Note that by default the converter is *None*.\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\nx = np.arange(100)\nax = axs[0]\nax.plot(x, x)\nlabel = f'Converter: {ax.xaxis.get_converter()}\\n '\nlabel += f'Locator: {ax.xaxis.get_major_locator()}\\n'\nlabel += f'Formatter: {ax.xaxis.get_major_formatter()}\\n'\nax.set_xlabel(label)\n\nax = axs[1]\ntime = np.arange('1980-01-01', '1980-06-25', dtype='datetime64[D]')\nx = np.arange(len(time))\nax.plot(time, x)\nlabel = f'Converter: {ax.xaxis.get_converter()}\\n '\nlabel += f'Locator: {ax.xaxis.get_major_locator()}\\n'\nlabel += f'Formatter: {ax.xaxis.get_major_formatter()}\\n'\nax.set_xlabel(label)\n\nax = axs[2]\ndata = {'apple': 10, 'ora"}], "retrieved_count": 10, "cost_time": 0.33782362937927246}
{"question": "How does Matplotlib implement its rendering pipeline from Artist objects to backend output?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its rendering pipeline from Artist objects to backend output through a multi-layered architecture that separates high-level plotting logic from low-level rendering. The pipeline works as follows: 1) The rendering process starts when Figure.draw() is called, which initiates the top-level rendering pipeline that coordinates all drawing operations, 2) The Figure's draw() method calls _get_draw_artists() to collect all visible Artists, sorts them by z-order, and then calls draw() on each Artist in sequence, 3) Each Artist's draw() method takes a renderer parameter and delegates the actual drawing to backend-specific renderers through the RendererBase interface, 4) The renderer (like RendererAgg for the Agg backend) receives drawing commands from Artists and converts them into low-level graphics operations, 5) For the Agg backend, the RendererAgg class in src/_backend_agg.cpp implements the actual pixel-level drawing using the Anti-Grain Geometry library, handling operations like draw_path(), draw_markers(), draw_image(), and draw_text_image(), 6) The rendering pipeline supports various drawing primitives including paths, markers, images, text, and collections, with each primitive being processed through specialized rendering methods, 7) The pipeline handles coordinate transformations, clipping, anti-aliasing, and other rendering optimizations automatically, 8) The renderer maintains internal state like the current graphics context (colors, line styles, etc.) and manages the pixel buffer or vector output, 9) The final output is either written to a file (for non-interactive backends) or displayed on screen (for interactive backends), with the backend handling the specific output format requirements (PNG, PDF, SVG, etc.).", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 188000, "end_line": 189117, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re\n        The figure all of the artists belong to (not checked).  We need this\n        because we can at the figure level suppress composition and insert each\n        rasterized artist as its own image.\n\n    artists : List[matplotlib.artist.Artist]\n        The list of Artists to be rasterized.  These are assumed to all\n        be in the same Figure.\n\n    renderer : matplotlib.backendbases.RendererBase\n        The currently active renderer\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    class _MinimalArtist:\n        def get_rasterized(self):\n            return True\n\n        def get_agg_filter(self):\n            return None\n\n        def __init__(self, figure, artists):\n            self.figure = figure\n            self.artists = artists\n\n        def get_figure(self, root=False):\n            if root:\n                return self.figure.get_figure(root=True)\n            else:\n                return self.figure\n\n        @martist.allow_rasterization\n        def draw(self, renderer):\n            for a in self.artists:\n                a.draw(renderer)\n\n    return _MinimalArtist(figure, artists).draw(renderer)\n"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from collections import namedtuple\nimport contextlib\nfrom functools import cache, reduce, wraps\nimport inspect\nfrom inspect import Signature, Parameter\nimport logging\nfrom numbers import Number, Real\nimport operator\nimport re\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom . import _api, cbook\nfrom .path import Path\nfrom .transforms import (BboxBase, Bbox, IdentityTransform, Transform, TransformedBbox,\n                         TransformedPatchPath, TransformedPath)\n\n_log = logging.getLogger(__name__)\n\n\ndef _prevent_rasterization(draw):\n    # We assume that by default artists are not allowed to rasterize (unless\n    # its draw method is explicitly decorated). If it is being drawn after a\n    # rasterized artist and it has reached a raster_depth of 0, we stop\n    # rasterization so that it does not affect the behavior of normal artist\n    # (e.g., change in dpi).\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        if renderer._raster_depth == 0 and renderer._rasterizing:\n            # Only stop when we are not in a rasterized parent\n            # and something has been rasterized since last stop.\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n\n        return draw(artist, renderer, *args, **kwargs)\n\n    draw_wrapper._supports_rasterization = False\n    return draw_wrapper\n\n\ndef allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing ="}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(f\"{_nums_to_str(*rect.p0, *rect.size)} rectclip\\n\")\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataS"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d or aa = False\n#       bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n#       capstyle = butt\n#       children = []\n#       clip_box = None\n#       clip_on = True\n#       clip_path = None\n#       contains = None\n#       data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n#       edgecolor or ec = (1.0, 1.0, 1.0, 1.0)\n#       extents = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n#       figure = Figure(640x480)\n#       fill = True\n#       gid = None\n#       hatch = None\n#       height = 1\n#       in_layout = False\n#       joinstyle = miter\n#       label =\n#       linestyle or ls = solid\n#       linewidth or lw = 0.0\n#       patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n#       path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n#       path_effects = []\n#       picker = None\n#       rasterized = None\n#       sketch_params = None\n#       snap = None\n#       transform = CompositeGenericTransform(     CompositeGenericTra...\n#       transformed_clip_path_and_affine = (None, None)\n#       url = None\n#       verts = [[  0.   0.]  [640.   0.]  [640. 480.]  [  0. 480....\n#       visible = True\n#       width = 1\n#       window_extent = Bbox(x0=0.0, y0=0.0, x1=640.0, y1=480.0)\n#       x = 0\n#       xy = (0, 0)\n#       y = 0\n#       zorder = 1\n#\n# The docstrings for all of the classes also contain the ``Artist``\n# properties, so you can consult the interactive \"help\" or the\n# :ref:`artist-api` for a listing of properties for a given object.\n#\n# .. _object-containers:\n#\n# Object containers\n# =================\n#\n#\n# Now that we know how to inspect and set the properties of a given\n# object we want to configure, we need to know how to get at that object.\n# As mentioned in the introduction, there are two kinds of objects:\n# primitives and containers.  The primitives are usually the things you\n# want to configure (the font of a :class:`~matplotlib.text.Text`\n# instance, the width of a :cl"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s* and *gid* (if set) as id.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def close_group(self, s):\n        \"\"\"\n        Close a grouping element with label *s*.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        \"\"\"Draw a `~.path.Path` instance using the given affine transform.\"\"\"\n        raise NotImplementedError\n\n    def draw_markers(self, gc, marker_path, marker_trans, path,\n                     trans, rgbFace=None):\n        \"\"\"\n        Draw a marker at each of *path*'s vertices (excluding control points).\n\n        The base (fallback) implementation makes multiple calls to `draw_path`.\n        Backends may want to override this method in order to draw the marker\n        only once and reuse it multiple times.\n\n        Parameters\n        ----------\n        gc : `.GraphicsContextBase`\n            The graphics context.\n        marker_path :"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    def start_filter(self):\n        \"\"\"\n        Switch to a temporary renderer for image filtering effects.\n\n        Currently only supported by the agg renderer.\n        \"\"\"\n\n    def stop_filter(self, filter_func):\n        \"\"\"\n        Switch back to the original renderer.  The contents of the temporary\n        renderer is processed with the *filter_func* and is drawn on the\n        original renderer as an image.\n\n        Currently only supported by the agg renderer.\n        \"\"\"\n\n    def _draw_disabled(self):\n        \"\"\"\n        Context manager to temporary disable drawing.\n\n        This is used for getting the drawn size of Artists.  This lets us\n        run the draw process to update any Python state but does not pay the\n        cost of the draw_XYZ calls on the canvas.\n        \"\"\"\n        no_ops = {\n            meth_name: functools.update_wrapper(lambda *args, **kwargs: None,\n                                                getattr(RendererBase, meth_name))\n            for meth_name in dir(RendererBase)\n            if (meth_name.startswith(\"draw_\")\n                or meth_name in [\"open_group\", \"close_group\"])\n        }\n\n        return _setattr_cm(self, **no_ops)\n\n\nclass GraphicsContextBase:\n    \"\"\"An abstract base class that provides color, line styles, etc.\"\"\"\n\n    def __init__(self):\n        self._alpha = 1.0\n        self._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        self._antialiased = 1  # use 0, 1 not True, False for extension code\n        self._capstyle = CapStyle('butt')\n        self._cliprect = None\n        self._clippath = None\n        self._dashes = 0, None\n        self._joinstyle = JoinStyle('round')\n        self._linestyle = 'solid'\n        self._linewidth = 1\n        self._rgb = (0.0, 0.0, 0.0, 1.0)\n        self._hatch = None\n        self._hatch_color = None\n        self._hatch_linewidth = rcParams['hatch.linewidth']\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = None\n\n    d"}], "retrieved_count": 10, "cost_time": 0.35079336166381836}
{"question": "How does Matplotlib implement its pyplot interface for simple plotting commands?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its pyplot interface for simple plotting commands through a state-based system that provides a MATLAB-like, implicit interface. The pyplot interface works as follows: 1) The pyplot module maintains global state variables that track the current Figure and Axes objects, accessible through gcf() and gca() functions, 2) Most pyplot functions are automatically generated wrappers around Axes methods using the boilerplate.py script, which creates functions like plt.plot() that internally call gca().plot() on the current Axes, 3) The pyplot interface provides convenience functions for creating figures and axes (plt.figure(), plt.subplots(), plt.subplot()) that manage the global state and return the created objects, 4) When a pyplot function like plt.plot() is called, it first checks if there's a current Figure and Axes, creating them if necessary using the global state, 5) The pyplot functions delegate the actual plotting operations to the corresponding methods on the current Axes object, maintaining the same function signatures and parameters, 6) The interface supports both simple plotting commands (plt.plot(x, y)) and more complex operations (plt.subplot(2, 2, 1)) while hiding the underlying object management, 7) The pyplot module also provides functions for figure management (plt.show(), plt.savefig()) and global configuration (plt.rcParams), 8) The interface is designed for interactive use and simple scripts, providing a convenient way to create plots without explicitly managing Figure and Axes references, 9) The pyplot interface is built on top of the object-oriented API, serving as a convenience layer that reduces boilerplate code while still providing access to the full power of the underlying system when needed.", "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/introductory/pyplot\n\n.. _pyplot_tutorial:\n\n===============\nPyplot tutorial\n===============\n\nAn introduction to the pyplot interface.  Please also see\n:ref:`quick_start` for an overview of how Matplotlib\nworks and :ref:`api_interfaces` for an explanation of the trade-offs between the\nsupported user APIs.\n\n\"\"\"\n\n# %%\n# Introduction to pyplot\n# ======================\n#\n# :mod:`matplotlib.pyplot` is a collection of functions that make matplotlib\n# work like MATLAB.  Each ``pyplot`` function makes some change to a figure:\n# e.g., creates a figure, creates a plotting area in a figure, plots some lines\n# in a plotting area, decorates the plot with labels, etc.\n#\n# In :mod:`matplotlib.pyplot` various states are preserved\n# across function calls, so that it keeps track of things like\n# the current figure and plotting area, and the plotting\n# functions are directed to the current Axes (please note that we use uppercase\n# Axes to refer to the `~.axes.Axes` concept, which is a central\n# :ref:`part of a figure <figure_parts>`\n# and not only the plural of *axis*).\n#\n# .. note::\n#\n#    The implicit pyplot API is generally less verbose but also not as flexible as the\n#    explicit API.  Most of the function calls you see here can also be called\n#    as methods from an ``Axes`` object. We recommend browsing the tutorials\n#    and examples to see how this works. See :ref:`api_interfaces` for an\n#    explanation of the trade-off of the supported user APIs.\n#\n# Generating visualizations with pyplot is very quick:\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n# You may be wondering why the x-axis ranges from 0-3 and the y-axis\n# from 1-4.  If you provide a single list or array to\n# `~.pyplot.plot`, matplotlib assumes it is a\n# sequence of y values, and automatically generates the x values for\n# you.  Since python ranges start with 0, the default x vector has the\n# same length as y but starts with 0; "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# Note: The first part of this file can be modified in place, but the latter\n# part is autogenerated by the boilerplate.py script.\n\n\"\"\"\n`matplotlib.pyplot` is a state-based interface to matplotlib. It provides\nan implicit,  MATLAB-like, way of plotting.  It also opens figures on your\nscreen, and acts as the figure GUI manager.\n\npyplot is mainly intended for interactive plots and simple cases of\nprogrammatic plot generation::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    plt.plot(x, y)\n    plt.show()\n\nThe explicit object-oriented API is recommended for complex plots, though\npyplot is still usually used to create the figure and often the Axes in the\nfigure. See `.pyplot.figure`, `.pyplot.subplots`, and\n`.pyplot.subplot_mosaic` to create figures, and\n:doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    x = np.arange(0, 5, 0.1)\n    y = np.sin(x)\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n  "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in params) + ')'\n    return_statement = 'return ' if has_return_value else ''\n    # Bail out in case of name collision.\n    for reserved in ('gca', 'gci', 'gcf', '__ret'):\n        if reserved in params:\n            raise ValueError(\n                f'Method {called_fullname} has kwarg named {reserved}')\n\n    return template.format(\n        name=name,\n        called_name=called_name,\n        signature=signature,\n        call=call,\n        return_statement=return_statement,\n        **kwargs)\n\n\ndef boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n        'autoscale',\n        'axhline',\n        'axhspan',\n        'axis',\n        'axline',\n        'axvline',\n        'axvspan',\n        'bar',\n        'barbs',\n        'barh',\n        'bar_label',\n        'boxplot',\n        'broken_barh',\n        'clabel',\n        'cohere',\n        'contour',\n        'contourf',\n        'csd',\n        'ecdf',\n        'errorbar',\n        'eventplot',\n        'fill',\n        'fill_between',\n        'fill_betweenx',\n        'grid',\n        'grouped_bar',\n        'hexbin',\n        'hist',\n        'stairs',\n        'hist2d',\n        'hlines',\n        'imshow',\n        'legend',\n        'locator_params',\n        'loglog',\n        'magnitude_spectrum',\n        'margins',\n        'minorticks_off',\n        'minorticks_on',\n        'pcolor',\n        'pcolormesh',\n        'phase_spectrum',\n        'pie',\n        'plot',\n        'psd',\n        'quiver',\n        'quiverkey',\n        'scatter',\n        'semilogx',\n        'semilogy',\n        'specgram',\n        'spy',"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    plt.show()\n\n\nSee :ref:`api_interfaces` for an explanation of the tradeoffs between the\nimplicit and explicit interfaces.\n\"\"\"\n\n# fmt: off\n\nfrom __future__ import annotations\n\nfrom contextlib import AbstractContextManager, ExitStack\nfrom enum import Enum\nimport functools\nimport importlib\nimport inspect\nimport logging\nimport sys\nimport threading\nimport time\nfrom typing import IO, TYPE_CHECKING, cast, overload\n\nfrom cycler import cycler  # noqa: F401\nimport matplotlib\nimport matplotlib.colorbar\nimport matplotlib.image\nfrom matplotlib import _api\n# Re-exported (import x as x) for typing.\nfrom matplotlib import get_backend as get_backend, rcParams as rcParams\nfrom matplotlib import cm as cm  # noqa: F401\nfrom matplotlib import style as style  # noqa: F401\nfrom matplotlib import _pylab_helpers\nfrom matplotlib import interactive  # noqa: F401\nfrom matplotlib import cbook\nfrom matplotlib import _docstring\nfrom matplotlib.backend_bases import (\n    FigureCanvasBase, FigureManagerBase, MouseButton)\nfrom matplotlib.figure import Figure, FigureBase, figaspect\nfrom matplotlib.gridspec import GridSpec, SubplotSpec\nfrom matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\nfrom matplotlib.artist import Artist\nfrom matplotlib.axes import Axes\nfrom matplotlib.axes import Subplot  # noqa: F401\nfrom matplotlib.backends import BackendFilter, backend_registry\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.colorizer import _ColorizerInterface, ColorizingArtist, Colorizer\nfrom matplotlib import mlab  # for detrend_none, window_hanning\nfrom matplotlib.scale import get_scale_names  # noqa: F401\n\nfrom matplotlib.cm import _colormaps\nfrom matplotlib.colors import _color_sequences, Colormap\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Hashable, Iterable, Sequence\n    import pathlib\n    import os\n    from typing import Any, BinaryIO, Literal, TypeVar\n    from typing_extensions import ParamSp"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nAn object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the explicit object-oriented library is\nencouraged when programming; the implicit pyplot interface is primarily for\nworking interactively. The exceptions to this suggestion are the pyplot\nfunctions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n`.pyplot.savefig`, which can greatly simplify scripting.  See\n:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\nand explicit interfaces.\n\nModules include:\n\n:mod:`matplotlib.axes`\n    The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n    `~.axes.Axes` methods.  The axes module is the highest level of OO\n    access to the library.\n\n:mod:`matplotlib.figure`\n    The `.Figure` class.\n\n:mod:`matplotlib.artist`\n    The `.Artist` base class for all classes that draw things.\n\n:mod:`matplotlib.lines`\n    The `.Line2D` class for drawing lines and markers.\n\n:mod:`matplotlib.patches`\n    Classes for drawing polygons.\n\n:mod:`matplotlib.text`\n    The `.Text` and `.Annotation` classes.\n\n:mod:`matplotlib.image`\n    The `.AxesImage` and `.FigureImage` classes.\n\n:mod:`matplotlib.collections`\n    Classes for efficient drawing of groups of lines or polygons.\n\n:mod:`matplotlib.colors`\n    Color specifications and making colormaps.\n\n:mod:`matplotlib.cm`\n    Colormaps, and the `.ScalarMappable` mixin class for providing color\n    mapping functionality to other classes.\n\n:mod:`matplotlib.ticker`\n    Calculation of tick mark locations and formatting of tick labels.\n\n:mod:`matplotlib.backends`\n    A subpackage with modules for various GUI libraries and output formats.\n\nThe base matplotlib namespace includes:\n\n`~matplot"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " function.\n    call = '(' + ', '.join((\n           # Pass \"intended-as-positional\" parameters positionally to avoid\n           # forcing third-party subclasses to reproduce the parameter names.\n           '{0}'\n           if param.kind in [\n               Parameter.POSITIONAL_OR_KEYWORD]\n              and param.default is Parameter.empty else\n           # Only pass the data kwarg if it is actually set, to avoid forcing\n           # third-party subclasses to support it.\n           '**({{\"data\": data}} if data is not None else {{}})'\n           if param.name == \"data\" else\n           '{0}={0}'\n           if param.kind in [\n               Parameter.POSITIONAL_OR_KEYWORD,\n               Parameter.KEYWORD_ONLY] else\n           '{0}'\n           if param.kind is Parameter.POSITIONAL_ONLY else\n           '*{0}'\n           if param.kind is Parameter.VAR_POSITIONAL else\n           '**{0}'\n           if param.kind is Parameter.VAR_KEYWORD else\n           None).format(param.name)\n       for param in params) + ')'\n    return_statement = 'return ' if has_return_value else ''\n    # Bail out in case of name collision.\n    for reserved in ('gca', 'gci', 'gcf', '__ret'):\n        if reserved in params:\n            raise ValueError(\n                f'Method {called_fullname} has kwarg named {reserved}')\n\n    return template.format(\n        name=name,\n        called_name=called_name,\n        signature=signature,\n        call=call,\n        return_statement=return_statement,\n        **kwargs)\n\n\ndef boilerplate_gen():\n    \"\"\"Generator of lines for the automated part of pyplot.\"\"\"\n\n    _figure_commands = (\n        'figimage',\n        'figtext:text',\n        'gca',\n        'gci:_gci',\n        'ginput',\n        'subplots_adjust',\n        'suptitle',\n        'tight_layout',\n        'waitforbuttonpress',\n    )\n\n    # These methods are all simple wrappers of Axes methods by the same name.\n    _axes_commands = (\n        'acorr',\n        'angle_spectrum',\n        'annotate',\n        'arrow',\n     "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        template = (AXES_CMAPPABLE_METHOD_TEMPLATE if name in cmappable else\n                    AXES_METHOD_TEMPLATE)\n        yield generate_function(name, f'Axes.{called_name}', template,\n                                sci_command=cmappable.get(name))\n\n    cmaps = (\n        'autumn',\n        'bone',\n        'cool',\n        'copper',\n        'flag',\n        'gray',\n        'hot',\n        'hsv',\n        'jet',\n        'pink',\n        'prism',\n        'spring',\n        'summer',\n        'winter',\n        'magma',\n        'inferno',\n        'plasma',\n        'viridis',\n        \"nipy_spectral\"\n    )\n    # add all the colormaps (autumn, hsv, ....)\n    for name in cmaps:\n        yield AUTOGEN_MSG\n        yield CMAP_TEMPLATE.format(name=name)\n\n\ndef build_pyplot(pyplot_path):\n    pyplot_orig = pyplot_path.read_text().splitlines(keepends=True)\n    try:\n        pyplot_orig = pyplot_orig[:pyplot_orig.index(PYPLOT_MAGIC_HEADER) + 1]\n    except IndexError as err:\n        raise ValueError('The pyplot.py file *m"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        'stackplot',\n        'stem',\n        'step',\n        'streamplot',\n        'table',\n        'text',\n        'tick_params',\n        'ticklabel_format',\n        'tricontour',\n        'tricontourf',\n        'tripcolor',\n        'triplot',\n        'violinplot',\n        'vlines',\n        'xcorr',\n        # pyplot name : real name\n        'sci:_sci',\n        'title:set_title',\n        'xlabel:set_xlabel',\n        'ylabel:set_ylabel',\n        'xscale:set_xscale',\n        'yscale:set_yscale',\n    )\n\n    cmappable = {\n        'contour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'contourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'hexbin': 'sci(__ret)',\n        'scatter': 'sci(__ret)',\n        'pcolor': 'sci(__ret)',\n        'pcolormesh': 'sci(__ret)',\n        'hist2d': 'sci(__ret[-1])',\n        'imshow': 'sci(__ret)',\n        'spy': (\n            'if isinstance(__ret, _ColorizerInterface):\\n'\n            '        sci(__ret)'\n        ),\n        'quiver': 'sci(__ret)',\n        'specgram': 'sci(__ret[-1])',\n        'streamplot': 'sci(__ret.lines)',\n        'tricontour': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tricontourf': (\n            'if __ret._A is not None:  # type: ignore[attr-defined]\\n'\n            '        sci(__ret)'\n        ),\n        'tripcolor': 'sci(__ret)',\n    }\n\n    for spec in _figure_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n        yield generate_function(name, f'Figure.{called_name}',\n                                FIGURE_METHOD_TEMPLATE)\n\n    for spec in _axes_commands:\n        if ':' in spec:\n            name, called_name = spec.split(':')\n        else:\n            name = called_name = spec\n\n        templa"}, {"start_line": 0, "end_line": 110, "belongs_to": {"file_name": "pylab.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from matplotlib.pylab import *  # noqa: F401, F403\nimport matplotlib.pylab\n__doc__ = matplotlib.pylab.__doc__\n"}], "retrieved_count": 10, "cost_time": 0.3443470001220703}
{"question": "How does Matplotlib support custom Artist classes for specialized plotting needs?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib supports custom Artist classes for specialized plotting needs through its extensible Artist hierarchy system. The support works as follows: 1) All custom Artists must inherit from the base Artist class in lib/matplotlib/artist.py, which provides the fundamental interface and properties that all visual elements share, 2) Custom Artists can be created by subclassing existing Artist types (like Line2D, Rectangle, Text) or by creating completely new Artist classes that implement the required interface, 3) The Artist class provides a comprehensive set of base methods and properties including draw(), get_children(), set_visible(), get_visible(), set_alpha(), get_alpha(), and many others that custom Artists inherit, 4) Custom Artists can be added to Axes using methods like add_artist(), add_line(), add_patch(), or by creating custom helper methods on Axes, 5) The Artist system supports automatic property management through the set() method, which allows custom Artists to define their own properties and have them automatically handled, 6) Custom Artists can implement specialized drawing logic by overriding the draw() method, which receives a renderer parameter for backend-specific rendering, 7) The Artist hierarchy supports parent-child relationships, allowing custom Artists to contain other Artists and manage their lifecycle, 8) Custom Artists can integrate with Matplotlib's event system by implementing methods like contains() for picking and event handling, 9) The system provides hooks for coordinate transformations, clipping, and other rendering features that custom Artists can leverage, 10) Custom Artists can be serialized and saved with figures, supporting features like figure pickling and state management. This extensible architecture enables users to create specialized plotting elements while maintaining compatibility with Matplotlib's rendering system and interactive features.", "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        # rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._updat"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "line_with_text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/text_labels_and_annotations", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n=======================\nArtist within an artist\n=======================\n\nOverride basic methods so an artist can contain another\nartist.  In this case, the line contains a Text instance to label it.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.lines as lines\nimport matplotlib.text as mtext\nimport matplotlib.transforms as mtransforms\n\n\nclass MyLine(lines.Line2D):\n    def __init__(self, *args, **kwargs):\n        # we'll update the position when the line data is set\n        self.text = mtext.Text(0, 0, '')\n        super().__init__(*args, **kwargs)\n\n        # we can't access the label attr until *after* the line is\n        # initiated\n        self.text.set_text(self.get_label())\n\n    def set_figure(self, figure):\n        self.text.set_figure(figure)\n        super().set_figure(figure)\n\n    # Override the Axes property setter to set Axes on our children as well.\n    @lines.Line2D.axes.setter\n    def axes(self, new_axes):\n        self.text.axes = new_axes\n        lines.Line2D.axes.fset(self, new_axes)  # Call the superclass property setter.\n\n    def set_transform(self, transform):\n        # 2 pixel offset\n        texttrans = transform + mtransforms.Affine2D().translate(2, 2)\n        self.text.set_transform(texttrans)\n        super().set_transform(transform)\n\n    def set_data(self, x, y):\n        if len(x):\n            self.text.set_position((x[-1], y[-1]))\n\n        super().set_data(x, y)\n\n    def draw(self, renderer):\n        # draw my label at the end of the line with 2 pixel offset\n        super().draw(renderer)\n        self.text.draw(renderer)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nx, y = np.random.rand(2, 20)\nline = MyLine(x, y, mfc='red', ms=12, label='line label')\nline.text.set_color('red')\nline.text.set_fontsize(16)\n\nax.add_line(line)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this exa"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and (fig := artist.get_figure(root=True)) and\n                    fig.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper\n\n\ndef _finalize_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n    Figure, to finish up if the render is still in rasterized mode.\n    \"\"\"\n    @wraps(draw)\n    def draw_wrapper(artist, renderer, *args, **kwargs):\n        result = draw(artist, renderer, *args, **kwargs)\n        if renderer._rasterizing:\n            renderer.stop_rasterizing()\n            renderer._rasterizing = False\n        return result\n    return draw_wrapper\n\n\ndef _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val\n\n\n_XYPair = namedtuple(\"_XYPair\", \"x y\")\n\n\nclass Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n\n        # Decorate draw() method so that all artists are able to stop\n        "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/artists\n\n.. _artists_tutorial:\n\n===============\nArtist tutorial\n===============\n\nUsing Artist objects to render on the canvas.\n\nThere are three layers to the Matplotlib API.\n\n* the :class:`!matplotlib.backend_bases.FigureCanvas` is the area onto which\n  the figure is drawn\n* the :class:`!matplotlib.backend_bases.Renderer` is the object which knows how\n  to draw on the :class:`!matplotlib.backend_bases.FigureCanvas`\n* and the :class:`matplotlib.artist.Artist` is the object that knows how to use\n  a renderer to paint onto the canvas.\n\nThe :class:`!matplotlib.backend_bases.FigureCanvas` and\n:class:`!matplotlib.backend_bases.Renderer` handle all the details of\ntalking to user interface toolkits like `wxPython\n<https://www.wxpython.org>`_ or drawing languages like PostScriptÂ®, and\nthe ``Artist`` handles all the high level constructs like representing\nand laying out the figure, text, and lines.  The typical user will\nspend 95% of their time working with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not nece"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ing with the ``Artists``.\n\nThere are two types of ``Artists``: primitives and containers.  The primitives\nrepresent the standard graphical objects we want to paint onto our canvas:\n:class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.patches.Rectangle`,\n:class:`~matplotlib.text.Text`, :class:`~matplotlib.image.AxesImage`, etc., and\nthe containers are places to put them (:class:`~matplotlib.axis.Axis`,\n:class:`~matplotlib.axes.Axes` and :class:`~matplotlib.figure.Figure`).  The\nstandard use is to create a :class:`~matplotlib.figure.Figure` instance, use\nthe ``Figure`` to create one or more :class:`~matplotlib.axes.Axes`\ninstances, and use the ``Axes`` instance\nhelper methods to create the primitives.  In the example below, we create a\n``Figure`` instance using :func:`matplotlib.pyplot.figure`, which is a\nconvenience method for instantiating ``Figure`` instances and connecting them\nwith your user interface or drawing toolkit ``FigureCanvas``.  As we will\ndiscuss below, this is not necessary -- you can work directly with PostScript,\nPDF Gtk+, or wxPython ``FigureCanvas`` instances, instantiate your ``Figures``\ndirectly and connect them yourselves -- but since we are focusing here on the\n``Artist`` API we'll let :mod:`~matplotlib.pyplot` handle some of those details\nfor us::\n\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot\n\nThe :class:`~matplotlib.axes.Axes` is probably the most important\nclass in the Matplotlib API, and the one you will be working with most\nof the time.  This is because the ``Axes`` is the plotting area into\nwhich most of the objects go, and the ``Axes`` has many special helper\nmethods (:meth:`~matplotlib.axes.Axes.plot`,\n:meth:`~matplotlib.axes.Axes.text`,\n:meth:`~matplotlib.axes.Axes.hist`,\n:meth:`~matplotlib.axes.Axes.imshow`) to create the most common\ngraphics primitives (:class:`~matplotlib.lines.Line2D`,\n:class:`~matplotlib.text.Text`,\n:class:`~matplotlib.patches.Re"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ist, invalid_types))\n            )\n\n        def __repr__(self):\n            return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n\n        def __len__(self):\n            return sum(self._type_check(artist)\n                       for artist in self._axes._children)\n\n        def __iter__(self):\n            for artist in list(self._axes._children):\n                if self._type_check(artist):\n                    yield artist\n\n        def __getitem__(self, key):\n            return [artist\n                    for artist in self._axes._children\n                    if self._type_check(artist)][key]\n\n        def __add__(self, other):\n            if isinstance(other, (list, _AxesBase.ArtistList)):\n                return [*self, *other]\n            if isinstance(other, (tuple, _AxesBase.ArtistList)):\n                return (*self, *other)\n            return NotImplemented\n\n        def __radd__(self, other):\n            if isinstance(other, list):\n                return other + list(self)\n            if isinstance(other, tuple):\n                return other + tuple(self)\n            return NotImplemented\n\n    @property\n    def artists(self):\n        return self.ArtistList(self, 'artists', invalid_types=(\n            mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n            mtable.Table, mtext.Text))\n\n    @property\n    def collections(self):\n        return self.ArtistList(self, 'collections',\n                               valid_types=mcoll.Collection)\n\n    @property\n    def images(self):\n        return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n\n    @property\n    def lines(self):\n        return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n\n    @property\n    def patches(self):\n        return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n\n    @property\n    def tables(self):\n        return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n\n    @property\n    def texts(self):\n        return self.Arti"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "_docstring.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "c.__doc__:\n            func.__doc__ = inspect.cleandoc(func.__doc__) % self.params\n        return func\n\n\nclass _ArtistKwdocLoader(dict):\n    def __missing__(self, key):\n        if not key.endswith(\":kwdoc\"):\n            raise KeyError(key)\n        name = key[:-len(\":kwdoc\")]\n        from matplotlib.artist import Artist, kwdoc\n        try:\n            cls, = (cls for cls in _api.recursive_subclasses(Artist)\n                    if cls.__name__ == name)\n        except ValueError as e:\n            raise KeyError(key) from e\n        return self.setdefault(key, kwdoc(cls))\n\n\nclass _ArtistPropertiesSubstitution:\n    \"\"\"\n    A class to substitute formatted placeholders in docstrings.\n\n    This is realized in a single instance ``_docstring.interpd``.\n\n    Use `~._ArtistPropertiesSubstition.register` to define placeholders and\n    their substitution, e.g. ``_docstring.interpd.register(name=\"some value\")``.\n\n    Use this as a decorator to apply the substitution::\n\n        @_docstring.interpd\n        def some_func():\n            '''Replace %(name)s.'''\n\n    Decorating a class triggers substitution both on the class docstring and\n    on the class' ``__init__`` docstring (which is a commonly required\n    pattern for Artist subclasses).\n\n    Substitutions of the form ``%(classname:kwdoc)s`` (ending with the\n    literal \":kwdoc\" suffix) trigger lookup of an Artist subclass with the\n    given *classname*, and are substituted with the `.kwdoc` of that class.\n    \"\"\"\n\n    def __init__(self):\n        self.params = _ArtistKwdocLoader()\n\n    def register(self, **kwargs):\n        \"\"\"\n        Register substitutions.\n\n        ``_docstring.interpd.register(name=\"some value\")`` makes \"name\" available\n        as a named parameter that will be replaced by \"some value\".\n        \"\"\"\n        self.params.update(**kwargs)\n\n    def __call__(self, obj):\n        if obj.__doc__:\n            obj.__doc__ = inspect.cleandoc(obj.__doc__) % self.params\n        if isinstance(obj, type) and obj.__init__ != obj"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "mpl_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axes_grid1", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         return SimpleChainedObjects(list(self.values()))\n                else:\n                    raise ValueError(\"Unsupported slice\")\n            else:\n                return dict.__getitem__(self, k)\n\n        def __call__(self, *v, **kwargs):\n            return maxes.Axes.axis(self.axes, *v, **kwargs)\n\n    @property\n    def axis(self):\n        return self._axislines\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n        # Init axis artists.\n        self._axislines = self.AxisDict(self)\n        self._axislines.update(\n            bottom=SimpleAxisArtist(self.xaxis, 1, self.spines[\"bottom\"]),\n            top=SimpleAxisArtist(self.xaxis, 2, self.spines[\"top\"]),\n            left=SimpleAxisArtist(self.yaxis, 1, self.spines[\"left\"]),\n            right=SimpleAxisArtist(self.yaxis, 2, self.spines[\"right\"]))\n\n\nclass SimpleAxisArtist(Artist):\n    def __init__(self, axis, axisnum, spine):\n        self._axis = axis\n        self._axisnum = axisnum\n        self.line = spine\n\n        if isinstance(axis, XAxis):\n            self._axis_direction = [\"bottom\", \"top\"][axisnum-1]\n        elif isinstance(axis, YAxis):\n            self._axis_direction = [\"left\", \"right\"][axisnum-1]\n        else:\n            raise ValueError(\n                f\"axis must be instance of XAxis or YAxis, but got {axis}\")\n        super().__init__()\n\n    @property\n    def major_ticks(self):\n        tickline = \"tick%dline\" % self._axisnum\n        return SimpleChainedObjects([getattr(tick, tickline)\n                                     for tick in self._axis.get_major_ticks()])\n\n    @property\n    def major_ticklabels(self):\n        label = \"label%d\" % self._axisnum\n        return SimpleChainedObjects([getattr(tick, label)\n                                     for tick in self._axis.get_major_ticks()])\n\n    @property\n    def label(self):\n        return self._axis.label\n\n    def set_visible(self, b):\n        self.toggle(all=b)\n        self.line.set_visible(b)\n        self._axis.set_v"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "legend_guide.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " method which returns a single artist for the\n# legend to use. The required signature for ``legend_artist`` is documented at\n# `~.legend_handler.HandlerBase.legend_artist`.\n\nimport matplotlib.patches as mpatches\n\n\nclass AnyObject:\n    pass\n\n\nclass AnyObjectHandler:\n    def legend_artist(self, legend, orig_handle, fontsize, handlebox):\n        x0, y0 = handlebox.xdescent, handlebox.ydescent\n        width, height = handlebox.width, handlebox.height\n        patch = mpatches.Rectangle([x0, y0], width, height, facecolor='red',\n                                   edgecolor='black', hatch='xx', lw=3,\n                                   transform=handlebox.get_transform())\n        handlebox.add_artist(patch)\n        return patch\n\nfig, ax = plt.subplots()\n\nax.legend([AnyObject()], ['My first handler'],\n          handler_map={AnyObject: AnyObjectHandler()})\n\n# %%\n# Alternatively, had we wanted to globally accept ``AnyObject`` instances\n# without needing to manually set the *handler_map* keyword all the time, we\n# could have registered the new handler with::\n#\n#     from matplotlib.legend import Legend\n#     Legend.update_default_handler_map({AnyObject: AnyObjectHandler()})\n#\n# Whilst the power here is clear, remember that there are already many handlers\n# implemented and what you want to achieve may already be easily possible with\n# existing classes. For example, to produce elliptical legend keys, rather than\n# rectangular ones:\n\nfrom matplotlib.legend_handler import HandlerPatch\n\n\nclass HandlerEllipse(HandlerPatch):\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        center = 0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent\n        p = mpatches.Ellipse(xy=center, width=width + xdescent,\n                             height=height + ydescent)\n        self.update_prop(p, orig_handle, legend)\n        p.set_transform(trans)\n        return [p]\n\n\nc = mpatches.Circle((0.5, 0.5), 0.25, facecolo"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "quick_start.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "me plots over and over again with different data\n# sets, or want to easily wrap Matplotlib methods, use the recommended\n# signature function below.\n\n\ndef my_plotter(ax, data1, data2, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data1, data2, **param_dict)\n    return out\n\n# %%\n# which you would then use twice to populate two subplots:\n\ndata1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))\nmy_plotter(ax1, data1, data2, {'marker': 'x'})\nmy_plotter(ax2, data3, data4, {'marker': 'o'})\n\n# %%\n# Note that if you want to install these as a python package, or any other\n# customizations you could use one of the many templates on the web;\n# Matplotlib has one at `mpl-cookiecutter\n# <https://github.com/matplotlib/matplotlib-extension-cookiecutter>`_\n#\n#\n# Styling Artists\n# ===============\n#\n# Most plotting methods have styling options for the Artists, accessible either\n# when a plotting method is called, or from a \"setter\" on the Artist.  In the\n# plot below we manually set the *color*, *linewidth*, and *linestyle* of the\n# Artists created by `~.Axes.plot`, and we set the linestyle of the second line\n# after the fact with `~.Line2D.set_linestyle`.\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nx = np.arange(len(data1))\nax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--')\nl, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2)\nl.set_linestyle(':')\n\n# %%\n# Colors\n# ------\n#\n# Matplotlib has a very flexible array of colors that are accepted for most\n# Artists; see :ref:`allowable color definitions <colors_def>` for a\n# list of specifications. Some Artists will take multiple colors.  i.e. for\n# a `~.Axes.scatter` plot, the edge of the markers can be different colors\n# from the interior:\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.scatter(data1, data2, s=50, facecolor='C0', edgecolor='k')\n\n# %%\n# Linewidths, linestyles, and markersizes\n# ----"}], "retrieved_count": 10, "cost_time": 0.33920812606811523}
{"question": "How does Matplotlib implement its backend API for third-party rendering engines?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib implements its backend API for third-party rendering engines through a well-defined abstract interface system that allows external rendering engines to integrate with the plotting framework. The backend API works as follows: 1) The core backend interface is defined in lib/matplotlib/backend_bases.py, which contains abstract base classes like RendererBase, FigureCanvasBase, and GraphicsContextBase that define the contract that all backends must implement, 2) The backend registration system allows third-party backends to register themselves using the register_backend() function, which maps file formats to backend modules through the _default_backends dictionary, 3) Third-party backends can implement the RendererBase interface by providing concrete implementations of methods like draw_path(), draw_image(), draw_text(), and draw_markers(), 4) The backend API supports both interactive backends (for GUI display) and non-interactive backends (for file output), with different requirements for each type, 5) Backends can be registered for specific file formats using register_backend(), allowing users to choose the most appropriate rendering engine for their output needs, 6) The API provides hooks for coordinate transformations, clipping, and other rendering features that third-party engines can leverage, 7) Backends can implement format-specific optimizations and features while maintaining compatibility with the core plotting system, 8) The system supports both raster and vector rendering engines, with different capabilities and performance characteristics, 9) Third-party backends can integrate with Matplotlib's event system and interactive features by implementing the appropriate event handling methods, 10) The backend API enables the same plotting code to work across different rendering engines without modification, providing flexibility for users to choose the most appropriate output method for their specific needs. This modular architecture allows Matplotlib to support a wide range of rendering engines while maintaining a consistent high-level API.", "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "as a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                 "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nA fully functional, do-nothing backend intended as a template for backend\nwriters.  It is fully functional in that you can select it as a backend e.g.\nwith ::\n\n    import matplotlib\n    matplotlib.use(\"template\")\n\nand your program will (should!) run without error, though no output is\nproduced.  This provides a starting point for backend writers; you can\nselectively implement drawing methods (`~.RendererTemplate.draw_path`,\n`~.RendererTemplate.draw_image`, etc.) and slowly see your figure come to life\ninstead having to have a full-blown implementation before getting any results.\n\nCopy this file to a directory outside the Matplotlib source tree, somewhere\nwhere Python can import it (by adding the directory to your ``sys.path`` or by\npackaging it as a normal Python package); if the backend is importable as\n``import my.backend`` you can then select it using ::\n\n    import matplotlib\n    matplotlib.use(\"module://my.backend\")\n\nIf your backend implements support for saving figures (i.e. has a ``print_xyz`` method),\nyou can register it as the default handler for a given file type::\n\n    from matplotlib.backend_bases import register_backend\n    register_backend('xyz', 'my_backend', 'XYZ File Format')\n    ...\n    plt.savefig(\"figure.xyz\")\n\"\"\"\n\nfrom matplotlib import _api\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)\nfrom matplotlib.figure import Figure\n\n\nclass RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "': 'matplotlib.backends.backend_svg',\n    'svgz': 'matplotlib.backends.backend_svg',\n    'tif': 'matplotlib.backends.backend_agg',\n    'tiff': 'matplotlib.backends.backend_agg',\n    'webp': 'matplotlib.backends.backend_agg',\n    'avif': 'matplotlib.backends.backend_agg',\n}\n\n\ndef register_backend(format, backend, description=None):\n    \"\"\"\n    Register a backend for saving to a given file format.\n\n    Parameters\n    ----------\n    format : str\n        File extension\n    backend : module string or canvas class\n        Backend for handling file output\n    description : str, default: \"\"\n        Description of the file type.\n    \"\"\"\n    if description is None:\n        description = ''\n    _default_backends[format] = backend\n    _default_filetypes[format] = description\n\n\ndef get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class\n\n\nclass RendererBase:\n    \"\"\"\n    An abstract base class to handle drawing/rendering operations.\n\n    The following methods must be implemented in the backend for full\n    functionality (though just implementing `draw_path` alone would give a\n    highly capable backend):\n\n    * `draw_path`\n    * `draw_image`\n    * `draw_gouraud_triangles`\n\n    The following methods *should* be implemented in the backend for\n    optimization reasons:\n\n    * `draw_text`\n    * `draw_markers`\n    * `draw_path_collection`\n    * `draw_quad_mesh`\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = text.TextToPath()\n        self._raster_depth = 0\n        self._rasterizing = False\n\n    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s* and *gid* (if set) as id.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def close_group(self, s):\n        \"\"\"\n        Close a grouping element with label *s*.\n\n        Only used by the SVG renderer.\n        \"\"\"\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        \"\"\"Draw a `~.path.Path` instance using the given affine transform.\"\"\"\n        raise NotImplementedError\n\n    def draw_markers(self, gc, marker_path, marker_trans, path,\n                     trans, rgbFace=None):\n        \"\"\"\n        Draw a marker at each of *path*'s vertices (excluding control points).\n\n        The base (fallback) implementation makes multiple calls to `draw_path`.\n        Backends may want to override this method in order to draw the marker\n        only once and reuse it multiple times.\n\n        Parameters\n        ----------\n        gc : `.GraphicsContextBase`\n            The graphics context.\n        marker_path :"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "vent, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'\n\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasTemplate\nFigureManager = FigureMana"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_mixed.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " `~matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `~matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*se"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "backend_template.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#####################################################################\n#\n# The following functions and classes are for pyplot and implement\n# window/figure managers, etc.\n#\n########################################################################\n\n\nclass FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.  For\n    interactive backends, see the documentation of the `.FigureManagerBase`\n    class for the list of methods that can/should be overridden.\n    \"\"\"\n\n\nclass FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `~matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file t"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_agg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t Bbox, BboxBase\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\n\n\ndef get_hinting_flag():\n    mapping = {\n        'default': LoadFlags.DEFAULT,\n        'no_autohint': LoadFlags.NO_AUTOHINT,\n        'force_autohint': LoadFlags.FORCE_AUTOHINT,\n        'no_hinting': LoadFlags.NO_HINTING,\n        True: LoadFlags.FORCE_AUTOHINT,\n        False: LoadFlags.NO_HINTING,\n        'either': LoadFlags.DEFAULT,\n        'native': LoadFlags.NO_AUTOHINT,\n        'auto': LoadFlags.FORCE_AUTOHINT,\n        'none': LoadFlags.NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring in"}, {"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s, f\"print_{fmt}\"):\n                raise ValueError(\n                    f\"The {backend!r} backend does not support {fmt} output\")\n            canvas = canvas_class(self.figure)\n        elif hasattr(self, f\"print_{fmt}\"):\n            # Return the current canvas if it supports the requested format.\n            canvas = self\n        else:\n            # Return a default canvas for the requested format, if it exists.\n            canvas_class = get_registered_canvas_class(fmt)\n            if canvas_class is None:\n                raise ValueError(\n                    \"Format {!r} is not supported (supported formats: {})\".format(\n                        fmt, \", \".join(sorted(self.get_supported_filetypes()))))\n            canvas = canvas_class(self.figure)\n        canvas._is_saving = self._is_saving\n        meth = getattr(canvas, f\"print_{fmt}\")\n        mod = (meth.func.__module__\n               if hasattr(meth, \"func\")  # partialmethod, e.g. backend_wx.\n               else meth.__module__)\n        if mod.startswith((\"matplotlib.\", \"mpl_toolkits.\")):\n            optional_kws = {  # Passed by print_figure for other renderers.\n                \"dpi\", \"facecolor\", \"edgecolor\", \"orientation\",\n                \"bbox_inches_restore\"}\n            skip = optional_kws - {*inspect.signature(meth).parameters}\n            print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\n                *args, **{k: v for k, v in kwargs.items() if k not in skip}))\n        else:  # Let third-parties do as they see fit.\n            print_method = meth\n        try:\n            yield print_method\n        finally:\n            self.figure.canvas = self\n\n    def print_figure(\n            self, filename, dpi=None, facecolor=None, edgecolor=None,\n            orientation='portrait', format=None, *,\n            bbox_inches=None, pad_inches=None, bbox_extra_artists=None,\n            backend=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy. Set the figure patch face and edge\n      "}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# get without triggering backend resolution\n\n    module = backend_registry.load_backend_module(newbackend)\n    canvas_class = module.FigureCanvas\n\n    required_framework = canvas_class.required_interactive_framework\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new_figure_manager() and show() functions from the backend.\n\n    # Classically, backends can directly export these functions.  This should\n    # keep working for backcompat.\n    new_figure_manager = getattr(module, \"new_figure_manager\", None)\n    show = getattr(module, \"show\", None)\n\n    # In that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive"}], "retrieved_count": 10, "cost_time": 0.3328258991241455}
{"question": "How does Matplotlib handle configuration and customization through its rcParams system?", "answer": null, "relative_code_list": null, "ground_truth": "Matplotlib handles configuration and customization through its rcParams system, which provides a comprehensive framework for managing default settings and styling. The rcParams system works as follows: 1) The core configuration is managed through the RcParams class in lib/matplotlib/__init__.py, which is a dict-like object that stores all configurable parameters with validation, 2) The global rcParams instance contains all the default settings for Matplotlib, including backend selection, line styles, colors, fonts, axes properties, and many other visual elements, 3) Configuration can be set at multiple levels: runtime through direct modification of rcParams, through style sheets using matplotlib.style.use(), or through matplotlibrc files, with runtime settings taking precedence over style sheets, which take precedence over rc files, 4) The rc() function provides a convenient way to set multiple related parameters at once using group-based access (e.g., rc('lines', linewidth=2, color='red')), 5) The rc_context() context manager allows temporary changes to rcParams that are automatically reverted when the context exits, enabling localized customization without affecting global state, 6) Style sheets provide a way to package related rcParams settings together, allowing users to easily switch between different visual styles (like 'ggplot', 'dark_background', etc.), 7) The system supports validation of parameter values through the rcsetup module, ensuring that only valid values are accepted, 8) Configuration files can be loaded from multiple locations, with user-specific settings in ~/.config/matplotlib/matplotlibrc taking precedence over system defaults, 9) The rcParams system supports aliases for common parameters (like 'lw' for 'linewidth', 'c' for 'color') to reduce typing for interactive use, 10) The system provides functions like rcdefaults() and rc_file_defaults() to restore default settings, and rcParams can be copied and modified for creating custom configurations. This flexible system enables users to customize Matplotlib's appearance and behavior at multiple levels while maintaining consistency and providing sensible defaults.", "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lib.rcParams`\n    Default configuration settings; their defaults may be overridden using\n    a :file:`matplotlibrc` file.\n\n`~matplotlib.use`\n    Setting the Matplotlib backend.  This should be called before any\n    figure is created, because it is not possible to switch between\n    different GUI backends after that.\n\nThe following environment variables can be used to customize the behavior:\n\n:envvar:`MPLBACKEND`\n    This optional variable can be set to choose the Matplotlib backend. See\n    :ref:`what-is-a-backend`.\n\n:envvar:`MPLCONFIGDIR`\n    This is the directory used to store user customizations to\n    Matplotlib, as well as some caches to improve performance. If\n    :envvar:`MPLCONFIGDIR` is not defined, :file:`{HOME}/.config/matplotlib`\n    and :file:`{HOME}/.cache/matplotlib` are used on Linux, and\n    :file:`{HOME}/.matplotlib` on other platforms, if they are\n    writable. Otherwise, the Python standard library's `tempfile.gettempdir`\n    is used to find a base directory in which the :file:`matplotlib`\n    subdirectory is created.\n\nMatplotlib was initially written by John D. Hunter (1968-2012) and is now\ndeveloped and maintained by a host of others.\n\nOccasionally the internal documentation (python docstrings) will refer\nto MATLABÂ®, a registered trademark of The MathWorks, Inc.\n\n\"\"\"\n\n__all__ = [\n    \"__bibtex__\",\n    \"__version__\",\n    \"__version_info__\",\n    \"set_loglevel\",\n    \"ExecutableNotFoundError\",\n    \"get_configdir\",\n    \"get_cachedir\",\n    \"get_data_path\",\n    \"matplotlib_fname\",\n    \"MatplotlibDeprecationWarning\",\n    \"RcParams\",\n    \"rc_params\",\n    \"rc_params_from_file\",\n    \"rcParamsDefault\",\n    \"rcParams\",\n    \"rcParamsOrig\",\n    \"defaultParams\",\n    \"rc\",\n    \"rcdefaults\",\n    \"rc_file_defaults\",\n    \"rc_file\",\n    \"rc_context\",\n    \"use\",\n    \"get_backend\",\n    \"interactive\",\n    \"is_interactive\",\n    \"colormaps\",\n    \"multivar_colormaps\",\n    \"bivar_colormaps\",\n    \"color_sequences\",\n]\n\n\nimport atexit\nfrom collections import namedtuple\nfrom "}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rent working directory\n        # which can fail if the user has ended up with a cwd that is\n        # non-existent.\n        yield 'matplotlibrc'\n        try:\n            matplotlibrc = os.environ['MATPLOTLIBRC']\n        except KeyError:\n            pass\n        else:\n            yield matplotlibrc\n            yield os.path.join(matplotlibrc, 'matplotlibrc')\n        yield os.path.join(get_configdir(), 'matplotlibrc')\n        yield os.path.join(get_data_path(), 'matplotlibrc')\n\n    for fname in gen_candidates():\n        if os.path.exists(fname) and not os.path.isdir(fname):\n            return fname\n\n    raise RuntimeError(\"Could not find matplotlibrc file; your Matplotlib \"\n                       \"install is broken\")\n\n\n@_docstring.Substitution(\n    \"\\n\".join(map(\"- {}\".format, sorted(rcsetup._validators, key=str.lower)))\n)\nclass RcParams(MutableMapping, dict):\n    \"\"\"\n    A dict-like key-value store for config parameters, including validation.\n\n    Validating functions are defined and associated with rc parameters in\n    :mod:`matplotlib.rcsetup`.\n\n    The list of rcParams is:\n\n    %s\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n    \"\"\"\n\n    validate = rcsetup._validators\n\n    # validate values on the way in\n    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)\n\n    def _set(self, key, val):\n        \"\"\"\n        Directly write data bypassing deprecation and validation logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``rcParams[key] = val`` and not ``_set()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__setitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._set(key, val)``.\n\n        Even though private, we guarantee API stability for ``rcParams._set``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta pu"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sociated with rc parameters in\n    :mod:`matplotlib.rcsetup`.\n\n    The list of rcParams is:\n\n    %s\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n    \"\"\"\n\n    validate = rcsetup._validators\n\n    # validate values on the way in\n    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)\n\n    def _set(self, key, val):\n        \"\"\"\n        Directly write data bypassing deprecation and validation logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``rcParams[key] = val`` and not ``_set()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__setitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._set(key, val)``.\n\n        Even though private, we guarantee API stability for ``rcParams._set``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta public:\n        \"\"\"\n        dict.__setitem__(self, key, val)\n\n    def _get(self, key):\n        \"\"\"\n        Directly read data bypassing deprecation, backend and validation\n        logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``val = rcParams[key]`` and not ``_get()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__getitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._get(key)``.\n\n        Even though private, we guarantee API stability for ``rcParams._get``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta public:\n        \"\"\"\n        return dict.__getitem__(self, key)\n\n    def _update_raw(self, other_params):\n        \"\"\"\n        Directly update the data from *other_params*, bypassing deprecation,\n        backend and validation logic on both sides.\n\n        This ``rcParams"}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "*****************************\n\"\"\", '\\n'.join(config['text.latex.preamble']))\n    _log.debug('loaded rc file %s', fname)\n\n    return config\n\n\nrcParamsDefault = _rc_params_in_file(\n    cbook._get_data_path(\"matplotlibrc\"),\n    # Strip leading comment.\n    transform=lambda line: line[1:] if line.startswith(\"#\") else line,\n    fail_on_error=True)\nrcParamsDefault._update_raw(rcsetup._hardcoded_defaults)\nrcParamsDefault._ensure_has_backend()\n\nrcParams = RcParams()  # The global instance.\nrcParams._update_raw(rcParamsDefault)\nrcParams._update_raw(_rc_params_in_file(matplotlib_fname()))\nrcParamsOrig = rcParams.copy()\nwith _api.suppress_matplotlib_deprecation_warning():\n    # This also checks that all rcParams are indeed listed in the template.\n    # Assigning to rcsetup.defaultParams is left only for backcompat.\n    defaultParams = rcsetup.defaultParams = {\n        # We want to resolve deprecated rcParams, but not backend...\n        key: [(rcsetup._auto_backend_sentinel if key == \"backend\" else\n               rcParamsDefault[key]),\n              validator]\n        for key, validator in rcsetup._validators.items()}\nif rcParams['axes.formatter.use_locale']:\n    locale.setlocale(locale.LC_ALL, '')\n\n\ndef rc(group, **kwargs):\n    \"\"\"\n    Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,\n    for ``lines.linewidth`` the group is ``lines``, for\n    ``axes.facecolor``, the group is ``axes``, and so on.  Group may\n    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n    *kwargs* is a dictionary attribute name/value pairs, e.g.,::\n\n      rc('lines', linewidth=2, color='r')\n\n    sets the current `.rcParams` and is equivalent to::\n\n      rcParams['lines.linewidth'] = 2\n      rcParams['lines.color'] = 'r'\n\n    The following aliases are available to save typing for interactive users:\n\n    ======  =================\n    Alias   Property\n    ======  =================\n    'lw'    'linewidth'\n    'ls'    'linestyle'\n    'c'     'color'\n    'fc'    'faceco"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "customizing.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in(np.linspace(0, 2 * np.pi)), 'r-o')\nplt.show()\n\n# %%\n# .. _customizing-with-matplotlibrc-files:\n#\n# The :file:`matplotlibrc` file\n# =============================\n#\n# Matplotlib uses :file:`matplotlibrc` configuration files to customize all\n# kinds of properties, which we call 'rc settings' or 'rc parameters'. You can\n# control the defaults of almost every property in Matplotlib: figure size and\n# DPI, line width, color and style, Axes, axis and grid properties, text and\n# font properties and so on. The :file:`matplotlibrc` is read at startup to\n# configure Matplotlib. Matplotlib looks for :file:`matplotlibrc` in four\n# locations, in the following order:\n#\n# 1. :file:`matplotlibrc` in the current working directory, usually used for\n#    specific customizations that you do not want to apply elsewhere.\n#\n# 2. :file:`$MATPLOTLIBRC` if it is a file, else\n#    :file:`$MATPLOTLIBRC/matplotlibrc`.\n#\n# 3. It next looks in a user-specific place, depending on your platform:\n#\n#    - On Linux and FreeBSD, it looks in\n#      :file:`.config/matplotlib/matplotlibrc` (or\n#      :file:`$XDG_CONFIG_HOME/matplotlib/matplotlibrc`) if you've customized\n#      your environment.\n#\n#    - On other platforms, it looks in :file:`.matplotlib/matplotlibrc`.\n#\n#    See :ref:`locating-matplotlib-config-dir`.\n#\n# 4. :file:`{INSTALL}/matplotlib/mpl-data/matplotlibrc`, where\n#    :file:`{INSTALL}` is something like\n#    :file:`/usr/lib/python3.10/site-packages` on Linux, and maybe\n#    :file:`C:\\\\Python310\\\\Lib\\\\site-packages` on Windows. Every time you\n#    install matplotlib, this file will be overwritten, so if you want\n#    your customizations to be saved, please move this file to your\n#    user-specific matplotlib directory.\n#\n# Once a :file:`matplotlibrc` file has been found, it will *not* search\n# any of the other paths. When a\n# :ref:`style sheet<customizing-with-style-sheets>` is given with\n# ``style.use('<path>/<style-name>.mplstyle')``, settings specified in\n# the style sheet take prec"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h the :file:`matplotlib`\n    subdirectory is created.\n\nMatplotlib was initially written by John D. Hunter (1968-2012) and is now\ndeveloped and maintained by a host of others.\n\nOccasionally the internal documentation (python docstrings) will refer\nto MATLABÂ®, a registered trademark of The MathWorks, Inc.\n\n\"\"\"\n\n__all__ = [\n    \"__bibtex__\",\n    \"__version__\",\n    \"__version_info__\",\n    \"set_loglevel\",\n    \"ExecutableNotFoundError\",\n    \"get_configdir\",\n    \"get_cachedir\",\n    \"get_data_path\",\n    \"matplotlib_fname\",\n    \"MatplotlibDeprecationWarning\",\n    \"RcParams\",\n    \"rc_params\",\n    \"rc_params_from_file\",\n    \"rcParamsDefault\",\n    \"rcParams\",\n    \"rcParamsOrig\",\n    \"defaultParams\",\n    \"rc\",\n    \"rcdefaults\",\n    \"rc_file_defaults\",\n    \"rc_file\",\n    \"rc_context\",\n    \"use\",\n    \"get_backend\",\n    \"interactive\",\n    \"is_interactive\",\n    \"colormaps\",\n    \"multivar_colormaps\",\n    \"bivar_colormaps\",\n    \"color_sequences\",\n]\n\n\nimport atexit\nfrom collections import namedtuple\nfrom collections.abc import MutableMapping\nimport contextlib\nimport functools\nimport importlib\nimport inspect\nfrom inspect import Parameter\nimport locale\nimport logging\nimport os\nfrom pathlib import Path\nimport pprint\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom packaging.version import parse as parse_version\n\n# cbook must import matplotlib only within function\n# definitions, so it is safe to import from it here.\nfrom . import _api, _version, cbook, _docstring, rcsetup\nfrom matplotlib._api import MatplotlibDeprecationWarning\nfrom matplotlib.colors import _color_sequences as color_sequences\nfrom matplotlib.rcsetup import cycler  # noqa: F401\n\n\n_log = logging.getLogger(__name__)\n\n__bibtex__ = r\"\"\"@Article{Hunter:2007,\n  Author    = {Hunter, J. D.},\n  Title     = {Matplotlib: A 2D graphics environment},\n  Journal   = {Computing in Science \\& Engineering},\n  Volume    = {9},\n  Number    = {3},\n  Pages     = {90--95},\n  abstract  = {Matplotlib is a 2D graphics packa"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "customizing.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ary-like variable called\n:data:`matplotlib.rcParams`, which is global to the matplotlib package.\nSee `matplotlib.rcParams` for a full list of configurable rcParams.\nrcParams can be modified directly, for example:\n\"\"\"\n\nfrom cycler import cycler\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\nmpl.rcParams['lines.linewidth'] = 2\nmpl.rcParams['lines.linestyle'] = '--'\ndata = np.random.randn(50)\nplt.plot(data)\n\n# %%\n# Note, that in order to change the usual `~.Axes.plot` color you have to\n# change the *prop_cycle* property of *axes*:\n\nmpl.rcParams['axes.prop_cycle'] = cycler(color=['r', 'g', 'b', 'y'])\nplt.plot(data)  # first color is red\n\n# %%\n# Matplotlib also provides a couple of convenience functions for modifying rc\n# settings. `matplotlib.rc` can be used to modify multiple\n# settings in a single group at once, using keyword arguments:\n\nmpl.rc('lines', linewidth=4, linestyle='-.')\nplt.plot(data)\n\n# %%\n# Temporary rc settings\n# ---------------------\n#\n# The :data:`matplotlib.rcParams` object can also be changed temporarily using\n# the `matplotlib.rc_context` context manager:\n\nwith mpl.rc_context({'lines.linewidth': 2, 'lines.linestyle': ':'}):\n    plt.plot(data)\n\n# %%\n# `matplotlib.rc_context` can also be used as a decorator to modify the\n# defaults within a function:\n\n\n@mpl.rc_context({'lines.linewidth': 3, 'lines.linestyle': '-'})\ndef plotting_function():\n    plt.plot(data)\n\nplotting_function()\n\n# %%\n# `matplotlib.rcdefaults` will restore the standard Matplotlib\n# default settings.\n#\n# There is some degree of validation when setting the values of rcParams, see\n# :mod:`matplotlib.rcsetup` for details.\n\n# %%\n# .. _customizing-with-style-sheets:\n#\n# Using style sheets\n# ==================\n#\n# Another way to change the visual appearance of plots is to set the\n# rcParams in a so-called style sheet and import that style sheet with\n# `matplotlib.style.use`. In this way you can switch easily between\n# different styles by simply changing the i"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_rcparams.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "assert mpl.rcParams['lines.linewidth'] == 33\n\n\ndef test_RcParams_class():\n    rc = mpl.RcParams({'font.cursive': ['Apple Chancery',\n                                        'Textile',\n                                        'Zapf Chancery',\n                                        'cursive'],\n                       'font.family': 'sans-serif',\n                       'font.weight': 'normal',\n                       'font.size': 12})\n\n    expected_repr = \"\"\"\nRcParams({'font.cursive': ['Apple Chancery',\n                           'Textile',\n                           'Zapf Chancery',\n                           'cursive'],\n          'font.family': ['sans-serif'],\n          'font.size': 12.0,\n          'font.weight': 'normal'})\"\"\".lstrip()\n\n    assert expected_repr == repr(rc)\n\n    expected_str = \"\"\"\nfont.cursive: ['Apple Chancery', 'Textile', 'Zapf Chancery', 'cursive']\nfont.family: ['sans-serif']\nfont.size: 12.0\nfont.weight: normal\"\"\".lstrip()\n\n    assert expected_str == str(rc)\n\n    # test the find_all functionality\n    assert ['font.cursive', 'font.size'] == sorted(rc.find_all('i[vz]'))\n    assert ['font.family'] == list(rc.find_all('family'))\n\n\ndef test_rcparams_update():\n    rc = mpl.RcParams({'figure.figsize': (3.5, 42)})\n    bad_dict = {'figure.figsize': (3.5, 42, 1)}\n    # make sure validation happens on input\n    with pytest.raises(ValueError):\n        rc.update(bad_dict)\n\n\ndef test_rcparams_init():\n    with pytest.raises(ValueError):\n        mpl.RcParams({'figure.figsize': (3.5, 42, 1)})\n\n\ndef test_nargs_cycler():\n    from matplotlib.rcsetup import cycler as ccl\n    with pytest.raises(TypeError, match='3 were given'):\n        # cycler() takes 0-2 arguments.\n        ccl(ccl(color=list('rgb')), 2, 3)\n\n\ndef test_Bug_2543():\n    # Test that it possible to add all values to itself / deepcopy\n    # https://github.com/matplotlib/matplotlib/issues/2543\n    # We filter warnings at this stage since a number of them are raised\n    # for deprecated rcparams as they should. W"}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "update({k: rc_from_file[k] for k in rc_from_file\n                         if k not in STYLE_BLACKLIST})\n\n\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    The :rc:`backend` will not be reset by the context manager.\n\n    rcParams changed both through the context manager invocation and\n    in the body of the context will be reset on context exit.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    Setting in the context body::\n\n        with mpl.rc_context():\n            # will be reset\n            mpl.rcParams['lines.linewidth'] = 5\n            plt.plot(x, y)\n\n    \"\"\"\n    orig = dict(rcParams.copy())\n    del orig['backend']\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        rcParams._update_raw(orig)  # Revert to the original rcs.\n\n\ndef use(backend, *, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    If pyplot is already imported, `~matplotlib.pyplot.switch_backend` is used\n    and if the new backend is different than the current backend, all Figures\n    will be closed.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backen"}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "{k: rcParamsOrig[k] for k in rcParamsOrig\n                         if k not in STYLE_BLACKLIST})\n\n\ndef rc_file(fname, *, use_default_template=True):\n    \"\"\"\n    Update `.rcParams` from file.\n\n    Style-blacklisted `.rcParams` (defined in\n    ``matplotlib.style.core.STYLE_BLACKLIST``) are not updated.\n\n    Parameters\n    ----------\n    fname : str or path-like\n        A file with Matplotlib rc settings.\n\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the current configuration persists\n        and only the parameters specified in the file are updated.\n    \"\"\"\n    # Deprecation warnings were already handled in rc_params_from_file, no need\n    # to reemit them here.\n    with _api.suppress_matplotlib_deprecation_warning():\n        from .style.core import STYLE_BLACKLIST\n        rc_from_file = rc_params_from_file(\n            fname, use_default_template=use_default_template)\n        rcParams.update({k: rc_from_file[k] for k in rc_from_file\n                         if k not in STYLE_BLACKLIST})\n\n\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    The :rc:`backend` will not be reset by the context manager.\n\n    rcParams changed both through the context manager invocation and\n    in the body of the context will be reset on context exit.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n          "}], "retrieved_count": 10, "cost_time": 0.4878811836242676}
