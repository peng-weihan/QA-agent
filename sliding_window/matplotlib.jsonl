{"question": "What is the coordination mechanism of the LockableBbox class between the invalidation mechanism and the masked array operations that ensures changes to locked points trigger proper cache invalidation in the child bbox dependency chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n    def contains(self, x, y):\n        # Docstring inherited.\n        return self._bbox.contains(*self._transform.inverted().transform((x, y)))\n\n    def fully_contains(self, x, y):\n        # Docstring inherited.\n        return self._bbox.fully_contains(*self._transform.inverted().transform((x, y)))\n\n\nclass LockableBbox(BboxBase):\n    \"\"\"\n    A `Bbox` where some elements may be locked at certain values.\n\n    When the child bounding box changes, the bounds of this bbox will update\n    accordingly with the exception of the locked elements.\n    \"\"\"\n    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1"}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_bbox.contains(*self._transform.inverted().transform((x, y)))\n\n    def fully_contains(self, x, y):\n        # Docstring inherited.\n        return self._bbox.fully_contains(*self._transform.inverted().transform((x, y)))\n\n\nclass LockableBbox(BboxBase):\n    \"\"\"\n    A `Bbox` where some elements may be locked at certain values.\n\n    When the child bounding box changes, the bounds of this bbox will update\n    accordingly with the exception of the locked elements.\n    \"\"\"\n    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1, or None to leave unlocked.\n\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self.set_children(bbox)\n        self._points = None\n        fp = [x0, y0, x1, y1]\n        mask = [val is None for val in fp]\n        self._locked_points = np.ma.array(fp, float, mask=mask).reshape((2, 2))\n\n    __str__ = _make_str_method(\"_bbox\", \"_locked_points\")\n\n    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._bbox.get_points()\n            self._points = np.where(self._locked_points.mask,\n                                    points,\n                                    self._locked_points)\n            self._invalid = 0\n        return self._points\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n    @property\n    def locked_x0(self):\n        "}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", or None to leave unlocked.\n\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self.set_children(bbox)\n        self._points = None\n        fp = [x0, y0, x1, y1]\n        mask = [val is None for val in fp]\n        self._locked_points = np.ma.array(fp, float, mask=mask).reshape((2, 2))\n\n    __str__ = _make_str_method(\"_bbox\", \"_locked_points\")\n\n    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._bbox.get_points()\n            self._points = np.where(self._locked_points.mask,\n                                    points,\n                                    self._locked_points)\n            self._invalid = 0\n        return self._points\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n    @property\n    def locked_x0(self):\n        \"\"\"\n        float or None: The value used for the locked x0.\n        \"\"\"\n        if self._locked_points.mask[0, 0]:\n            return None\n        else:\n            return self._locked_points[0, 0]\n\n    @locked_x0.setter\n    def locked_x0(self, x0):\n        self._locked_points.mask[0, 0] = x0 is None\n        self._locked_points.data[0, 0] = x0\n        self.invalidate()\n\n    @property\n    def locked_y0(self):\n        \"\"\"\n        float or None: The value used for the locked y0.\n        \"\"\"\n        if self._locked_points.mask[0, 1]:\n            return None\n        else:\n            return self._locked_points[0, 1]\n\n    @locked_y0.setter\n    def locked_y0(self, y0):\n        self._locked_points.mask[0, 1] = y0 is None\n        self._locked_points.data[0, 1] = y0\n        self.invalidate()\n\n    @property\n    def locked_x1(self):\n        \"\"\"\n        float or None: The value used for the locked x1.\n        \"\"\"\n        if self._locked_points.mask[1, 0]:\n            return None\n        else:\n    "}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # If we are already more invalid than the currently propagated invalidation,\n        # then we don't need to do anything.\n        if level <= self._invalid and not self.pass_through:\n            return\n        self._invalid = level\n        for parent in list(self._parents.values()):\n            parent = parent()  # Dereference the weak reference.\n            if parent is not None:\n                parent._invalidate_internal(level=level, invalidating_node=self)\n\n    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the children won't\n        # keep them alive.\n        id_self = id(self)\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(\n                self, lambda _, pop=child._parents.pop, k=id_self: pop(k))\n            child._parents[id_self] = ref\n\n    def frozen(self):\n        \"\"\"\n        Return a frozen copy of this transform node.  The frozen copy will not\n        be updated when its children change.  Useful for storing a previously\n        known state of a transform where ``copy.deepcopy()`` might normally be\n        used.\n        \"\"\"\n        return self\n\n\nclass BboxBase(TransformNode):\n    \"\"\"\n    The base class of all bounding boxes.\n\n    This class is immutable; `Bbox` is a mutable subclass.\n\n    The canonical representation is as two points, with no\n    restric"}, {"start_line": 99000, "end_line": 101000, "belongs_to": {"file_name": "collections.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "[1:, 1:] | mask[0:-1, 1:] | mask[1:, 0:-1])\n        arr = self.get_array()\n        if arr is not None:\n            arr = np.ma.getmaskarray(arr)\n            if arr.ndim == 3:\n                # RGB(A) case\n                mask |= np.any(arr, axis=-1)\n            elif arr.ndim == 2:\n                mask |= arr\n            else:\n                mask |= arr.reshape(self._coordinates[:-1, :-1, :].shape[:2])\n        return ~mask\n\n    def _set_unmasked_verts(self):\n        X = self._coordinates[..., 0]\n        Y = self._coordinates[..., 1]\n\n        unmask = self._get_unmasked_polys()\n        X1 = np.ma.filled(X[:-1, :-1])[unmask]\n        Y1 = np.ma.filled(Y[:-1, :-1])[unmask]\n        X2 = np.ma.filled(X[1:, :-1])[unmask]\n        Y2 = np.ma.filled(Y[1:, :-1])[unmask]\n        X3 = np.ma.filled(X[1:, 1:])[unmask]\n        Y3 = np.ma.filled(Y[1:, 1:])[unmask]\n        X4 = np.ma.filled(X[:-1, 1:])[unmask]\n        Y4 = np.ma.filled(Y[:-1, 1:])[unmask]\n        npoly = len(X1)\n\n        xy = np.ma.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)\n        verts = xy.reshape((npoly, 5, 2))\n        self.set_verts(verts)\n\n    def get_edgecolor(self):\n        # docstring inherited\n        # We only want to return the facecolors of the polygons\n        # that were drawn.\n        ec = super().get_edgecolor()\n        unmasked_polys = self._get_unmasked_polys().ravel()\n        if len(ec) != len(unmasked_polys):\n            # Mapping is off\n            return ec\n        return ec[unmasked_polys, :]\n\n    def get_facecolor(self):\n        # docstring inherited\n        # We only want to return the facecolors of the polygons\n        # that were drawn.\n        fc = super().get_facecolor()\n        unmasked_polys = self._get_unmasked_polys().ravel()\n        if len(fc) != len(unmasked_polys):\n            # Mapping is off\n            return fc\n        return fc[unmasked_polys, :]\n\n    def set_array(self, A):\n        # docstring inherited\n        prev_unmask = self._get_unmasked_polys()\n        s"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ildren won't\n        # keep them alive.\n        id_self = id(self)\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(\n                self, lambda _, pop=child._parents.pop, k=id_self: pop(k))\n            child._parents[id_self] = ref\n\n    def frozen(self):\n        \"\"\"\n        Return a frozen copy of this transform node.  The frozen copy will not\n        be updated when its children change.  Useful for storing a previously\n        known state of a transform where ``copy.deepcopy()`` might normally be\n        used.\n        \"\"\"\n        return self\n\n\nclass BboxBase(TransformNode):\n    \"\"\"\n    The base class of all bounding boxes.\n\n    This class is immutable; `Bbox` is a mutable subclass.\n\n    The canonical representation is as two points, with no\n    restrictions on their ordering.  Convenience properties are\n    provided to get the left, bottom, right and top edges and width\n    and height, but these are not stored explicitly.\n    \"\"\"\n\n    is_affine = True\n\n    if DEBUG:\n        @staticmethod\n        def _check(points):\n            if isinstance(points, np.ma.MaskedArray):\n                _api.warn_external(\"Bbox bounds are a masked array.\")\n            points = np.asarray(points)\n            if any((points[1, :] - points[0, :]) == 0):\n                _api.warn_external(\"Singular Bbox.\")\n\n    def frozen(self):\n        return Bbox(self.get_points().copy())\n    frozen.__doc__ = TransformNode.__doc__\n\n    def __array__(self, *args, **kwargs):\n        return self.get_points()\n\n    @property\n    def x0(self):\n        \"\"\"\n        The first of the pair of *x* coordinates that define the bounding box.\n\n        This is not guaranteed to be less than :attr:`x1` (for that, use\n        :attr:`~BboxBase.xmin`).\n        \"\"\"\n        return self.get_poi"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._points = points\n            self.invalidate()\n\n    def set(self, other):\n        \"\"\"\n        Set this bounding box from the \"frozen\" bounds of another `Bbox`.\n        \"\"\"\n        if np.any(self._points != other.get_points()):\n            self._points = other.get_points()\n            self.invalidate()\n\n    def mutated(self):\n        \"\"\"Return whether the bbox has changed since init.\"\"\"\n        return self.mutatedx() or self.mutatedy()\n\n    def mutatedx(self):\n        \"\"\"Return whether the x-limits have changed since init.\"\"\"\n        return (self._points[0, 0] != self._points_orig[0, 0] or\n                self._points[1, 0] != self._points_orig[1, 0])\n\n    def mutatedy(self):\n        \"\"\"Return whether the y-limits have changed since init.\"\"\"\n        return (self._points[0, 1] != self._points_orig[0, 1] or\n                self._points[1, 1] != self._points_orig[1, 1])\n\n\nclass TransformedBbox(BboxBase):\n    \"\"\"\n    A `Bbox` that is automatically transformed by a given\n    transform.  When either the child bounding box or transform\n    changes, the bounds of this bbox will update accordingly.\n    \"\"\"\n\n    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n        transform : `Transform`\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        _api.check_isinstance(Transform, transform=transform)\n        if transform.input_dims != 2 or transform.output_dims != 2:\n            raise ValueError(\n                \"The input and output dimensions of 'transform' must be 2\")\n\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None\n\n    __str__ = _make_str_method(\"_bbox\", \"_transform\")\n\n    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n        "}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  When either the child bounding box or transform\n    changes, the bounds of this bbox will update accordingly.\n    \"\"\"\n\n    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n        transform : `Transform`\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        _api.check_isinstance(Transform, transform=transform)\n        if transform.input_dims != 2 or transform.output_dims != 2:\n            raise ValueError(\n                \"The input and output dimensions of 'transform' must be 2\")\n\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None\n\n    __str__ = _make_str_method(\"_bbox\", \"_transform\")\n\n    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n            # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n    def contains(self, x, y):\n        # Docstring inherited.\n        return self."}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\n        float or None: The value used for the locked x0.\n        \"\"\"\n        if self._locked_points.mask[0, 0]:\n            return None\n        else:\n            return self._locked_points[0, 0]\n\n    @locked_x0.setter\n    def locked_x0(self, x0):\n        self._locked_points.mask[0, 0] = x0 is None\n        self._locked_points.data[0, 0] = x0\n        self.invalidate()\n\n    @property\n    def locked_y0(self):\n        \"\"\"\n        float or None: The value used for the locked y0.\n        \"\"\"\n        if self._locked_points.mask[0, 1]:\n            return None\n        else:\n            return self._locked_points[0, 1]\n\n    @locked_y0.setter\n    def locked_y0(self, y0):\n        self._locked_points.mask[0, 1] = y0 is None\n        self._locked_points.data[0, 1] = y0\n        self.invalidate()\n\n    @property\n    def locked_x1(self):\n        \"\"\"\n        float or None: The value used for the locked x1.\n        \"\"\"\n        if self._locked_points.mask[1, 0]:\n            return None\n        else:\n            return self._locked_points[1, 0]\n\n    @locked_x1.setter\n    def locked_x1(self, x1):\n        self._locked_points.mask[1, 0] = x1 is None\n        self._locked_points.data[1, 0] = x1\n        self.invalidate()\n\n    @property\n    def locked_y1(self):\n        \"\"\"\n        float or None: The value used for the locked y1.\n        \"\"\"\n        if self._locked_points.mask[1, 1]:\n            return None\n        else:\n            return self._locked_points[1, 1]\n\n    @locked_y1.setter\n    def locked_y1(self, y1):\n        self._locked_points.mask[1, 1] = y1 is None\n        self._locked_points.data[1, 1] = y1\n        self.invalidate()\n\n\nclass Transform(TransformNode):\n    \"\"\"\n    The base class of all `TransformNode` instances that\n    actually perform a transformation.\n\n    All non-affine transformations should be subclasses of this class.\n    New affine transformations should be subclasses of `Affine2D`.\n\n    Subclasses of this class should override the following members (at\n    minimum):\n\n"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "cbook.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2 and 4 if `numpy.isfinite`\n    does not yield a Boolean array.  Category 3 is included to\n    support RGB or RGBA ndarrays, which are assumed to have only\n    valid values and which are passed through unchanged.\n\n    All input arguments that are not passed unchanged are returned\n    as masked arrays if any masked points are found, otherwise as\n    ndarrays.\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []  # Output args; some may be modified.\n    seqlist = [False] * len(args)  # Flags: True if output will be masked.\n    masks = []    # List of masks.\n    for i, x in enumerate(args):\n        if is_scalar_or_string(x) or len(x) != nrecs:\n            margs.append(x)  # Leave it unmodified.\n        else:\n            if isinstance(x, np.ma.MaskedArray) and x.ndim > 1:\n                raise ValueError(\"Masked arrays must be 1-D\")\n            try:\n                x = np.asanyarray(x)\n            except (VisibleDeprecationWarning, ValueError):\n                # NumPy 1.19 raises a warning about ragged arrays, but we want\n                # to accept basically anything here.\n                x = np.asanyarray(x, dtype=object)\n            if x.ndim == 1:\n                x = safe_masked_invalid(x)\n                seqlist[i] = True\n                if np.ma.is_masked(x):\n                    masks.append(np.ma.getmaskarray(x))\n            margs.append(x)  # Possibly modified.\n    if len(masks):\n        mask = np.logical_or.reduce(masks)\n        for i, x in enumerate(margs):\n            if seqlist[i]:\n                margs[i] = np.ma.array(x, mask=mask)\n    return margs\n\n\ndef _broadcast_with_masks(*args, compress=False):\n    \"\"\"\n    Broadcast inputs, combining all masked arrays.\n\n    Paramete"}], "retrieved_count": 10, "cost_time": 3.106147050857544}
{"question": "What is the architectural separation enforced by the TestLogLocator test suite between the tick locator's core logarithmic computation logic and its integration with matplotlib's axis scaling system, particularly when handling edge cases like polar projections and shared axes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "array([1e-5, 1e-3, 1e-1, 1e+1, 1e+3, 1e+5, 1e+7])\n        assert_almost_equal(loc.tick_values(0.001, 1.1e5), test_value)\n\n        loc = mticker.LogLocator(base=2)\n        test_value = np.array([.5, 1., 2., 4., 8., 16., 32., 64., 128.])\n        assert_almost_equal(loc.tick_values(1, 100), test_value)\n\n    def test_polar_axes(self):\n        \"\"\"\n        Polar Axes have a different ticking logic.\n        \"\"\"\n        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n        ax.set_yscale('log')\n        ax.set_ylim(1, 100)\n        assert_array_equal(ax.get_yticks(), [10, 100, 1000])\n\n    def test_switch_to_autolocator(self):\n        loc = mticker.LogLocator(subs=\"all\")\n        assert_array_equal(loc.tick_values(0.45, 0.55),\n                           [0.44, 0.46, 0.48, 0.5, 0.52, 0.54, 0.56])\n        # check that we *skip* 1.0, and 10, because this is a minor locator\n        loc = mticker.LogLocator(subs=np.arange(2, 10))\n        assert 1.0 not in loc.tick_values(0.9, 20.)\n        assert 10.0 not in loc.tick_values(0.9, 20.)\n        # don't switch if there's already one major and one minor tick (10 & 20)\n        loc = mticker.LogLocator(subs=\"auto\")\n        tv = loc.tick_values(10, 20)\n        assert_array_equal(tv[(10 <= tv) & (tv <= 20)], [20])\n\n    def test_set_params(self):\n        \"\"\"\n        Create log locator with default value, base=10.0, subs=[1.0],\n        numticks=15 and change it to something else.\n        See if change was successful. Should not raise exception.\n        \"\"\"\n        loc = mticker.LogLocator()\n        loc.set_params(numticks=7, subs=[2.0], base=4)\n        assert loc.numticks == 7\n        assert loc._base == 4\n        assert list(loc._subs) == [2.0]\n\n    def test_tick_values_correct(self):\n        ll = mticker.LogLocator(subs=(1, 2, 5))\n        test_value = np.array([1.e-01, 2.e-01, 5.e-01, 1.e+00, 2.e+00, 5.e+00,\n                               1.e+01, 2.e+01, 5.e+01, 1.e+02, 2.e+02, 5.e+02,\n                               1.e+03, 2.e+03"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", 5.e+03, 1.e+04, 2.e+04, 5.e+04,\n                               1.e+05, 2.e+05, 5.e+05, 1.e+06, 2.e+06, 5.e+06,\n                               1.e+07, 2.e+07, 5.e+07])\n        assert_almost_equal(ll.tick_values(1, 1e7), test_value)\n\n    def test_tick_values_not_empty(self):\n        mpl.rcParams['_internal.classic_mode'] = False\n        ll = mticker.LogLocator(subs=(1, 2, 5))\n        test_value = np.array([1.e-01, 2.e-01, 5.e-01, 1.e+00, 2.e+00, 5.e+00,\n                               1.e+01, 2.e+01, 5.e+01, 1.e+02, 2.e+02, 5.e+02,\n                               1.e+03, 2.e+03, 5.e+03, 1.e+04, 2.e+04, 5.e+04,\n                               1.e+05, 2.e+05, 5.e+05, 1.e+06, 2.e+06, 5.e+06,\n                               1.e+07, 2.e+07, 5.e+07, 1.e+08, 2.e+08, 5.e+08])\n        assert_almost_equal(ll.tick_values(1, 1e8), test_value)\n\n    def test_multiple_shared_axes(self):\n        rng = np.random.default_rng(19680801)\n        dummy_data = [rng.normal(size=100), [], []]\n        fig, axes = plt.subplots(len(dummy_data), sharex=True, sharey=True)\n\n        for ax, data in zip(axes.flatten(), dummy_data):\n            ax.hist(data, bins=10)\n            ax.set_yscale('log', nonpositive='clip')\n\n        for ax in axes.flatten():\n            assert all(ax.get_yticks() == axes[0].get_yticks())\n            assert ax.get_ylim() == axes[0].get_ylim()\n\n\nclass TestNullLocator:\n    def test_set_params(self):\n        \"\"\"\n        Create null locator, and attempt to call set_params() on it.\n        Should not exception, and should raise a warning.\n        \"\"\"\n        loc = mticker.NullLocator()\n        with pytest.warns(UserWarning):\n            loc.set_params()\n\n\nclass _LogitHelper:\n    @staticmethod\n    def isclose(x, y):\n        return (np.isclose(-np.log(1/x-1), -np.log(1/y-1))\n                if 0 < x < 1 and 0 < y < 1 else False)\n\n    @staticmethod\n    def assert_almost_equal(x, y):\n        ax = np.array(x)\n        ay = np.array(y)\n        assert np.all(ax > 0) and np.all(ax < 1)\n   "}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f_minor_ticks_int(self, n, lim, ref, use_rcparam):\n        if use_rcparam:\n            context = {'xtick.minor.ndivs': n, 'ytick.minor.ndivs': n}\n            kwargs = {}\n        else:\n            context = {}\n            kwargs = {'n': n}\n\n        with mpl.rc_context(context):\n            fig, ax = plt.subplots()\n            ax.set_xlim(*lim)\n            ax.set_ylim(*lim)\n            ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n            ax.xaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            ax.yaxis.set_major_locator(mticker.MultipleLocator(1))\n            ax.yaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            assert_almost_equal(ax.xaxis.get_ticklocs(minor=True), ref)\n            assert_almost_equal(ax.yaxis.get_ticklocs(minor=True), ref)\n\n\nclass TestLogLocator:\n    def test_basic(self):\n        loc = mticker.LogLocator(numticks=5)\n        with pytest.raises(ValueError):\n            loc.tick_values(0, 1000)\n\n        test_value = np.array([1e-5, 1e-3, 1e-1, 1e+1, 1e+3, 1e+5, 1e+7])\n        assert_almost_equal(loc.tick_values(0.001, 1.1e5), test_value)\n\n        loc = mticker.LogLocator(base=2)\n        test_value = np.array([.5, 1., 2., 4., 8., 16., 32., 64., 128.])\n        assert_almost_equal(loc.tick_values(1, 100), test_value)\n\n    def test_polar_axes(self):\n        \"\"\"\n        Polar Axes have a different ticking logic.\n        \"\"\"\n        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n        ax.set_yscale('log')\n        ax.set_ylim(1, 100)\n        assert_array_equal(ax.get_yticks(), [10, 100, 1000])\n\n    def test_switch_to_autolocator(self):\n        loc = mticker.LogLocator(subs=\"all\")\n        assert_array_equal(loc.tick_values(0.45, 0.55),\n                           [0.44, 0.46, 0.48, 0.5, 0.52, 0.54, 0.56])\n        # check that we *skip* 1.0, and 10, because this is a minor locator\n        loc = mticker.LogLocator(subs=np.arange(2, 10))\n        assert 1.0 not in loc.tick_values(0.9, 20.)\n        a"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lt.subplots(len(dummy_data), sharex=True, sharey=True)\n\n        for ax, data in zip(axes.flatten(), dummy_data):\n            ax.hist(data, bins=10)\n            ax.set_yscale('log', nonpositive='clip')\n\n        for ax in axes.flatten():\n            assert all(ax.get_yticks() == axes[0].get_yticks())\n            assert ax.get_ylim() == axes[0].get_ylim()\n\n\nclass TestNullLocator:\n    def test_set_params(self):\n        \"\"\"\n        Create null locator, and attempt to call set_params() on it.\n        Should not exception, and should raise a warning.\n        \"\"\"\n        loc = mticker.NullLocator()\n        with pytest.warns(UserWarning):\n            loc.set_params()\n\n\nclass _LogitHelper:\n    @staticmethod\n    def isclose(x, y):\n        return (np.isclose(-np.log(1/x-1), -np.log(1/y-1))\n                if 0 < x < 1 and 0 < y < 1 else False)\n\n    @staticmethod\n    def assert_almost_equal(x, y):\n        ax = np.array(x)\n        ay = np.array(y)\n        assert np.all(ax > 0) and np.all(ax < 1)\n        assert np.all(ay > 0) and np.all(ay < 1)\n        lx = -np.log(1/ax-1)\n        ly = -np.log(1/ay-1)\n        assert_almost_equal(lx, ly)\n\n\nclass TestLogitLocator:\n    ref_basic_limits = [\n        (5e-2, 1 - 5e-2),\n        (5e-3, 1 - 5e-3),\n        (5e-4, 1 - 5e-4),\n        (5e-5, 1 - 5e-5),\n        (5e-6, 1 - 5e-6),\n        (5e-7, 1 - 5e-7),\n        (5e-8, 1 - 5e-8),\n        (5e-9, 1 - 5e-9),\n    ]\n\n    ref_basic_major_ticks = [\n        1 / (10 ** np.arange(1, 3)),\n        1 / (10 ** np.arange(1, 4)),\n        1 / (10 ** np.arange(1, 5)),\n        1 / (10 ** np.arange(1, 6)),\n        1 / (10 ** np.arange(1, 7)),\n        1 / (10 ** np.arange(1, 8)),\n        1 / (10 ** np.arange(1, 9)),\n        1 / (10 ** np.arange(1, 10)),\n    ]\n\n    ref_maxn_limits = [(0.4, 0.6), (5e-2, 2e-1), (1 - 2e-1, 1 - 5e-2)]\n\n    @pytest.mark.parametrize(\n        \"lims, expected_low_ticks\",\n        zip(ref_basic_limits, ref_basic_major_ticks),\n    )\n    def test_basic_major(self, lims, expected_low_ticks):\n    "}, {"start_line": 19000, "end_line": 20675, "belongs_to": {"file_name": "test_polar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cator_wrapping():\n    # Check that the locator is always wrapped inside a RadialLocator\n    # and that RaidialAxis.isDefault_majloc is set correctly.\n    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n\n    # set an explicit locator\n    locator = mticker.MaxNLocator(3)\n    ax.yaxis.set_major_locator(locator)\n    assert not ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert ax.yaxis.get_major_locator().base is locator\n\n    ax.clear()  # reset to the default locator\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n\n    ax.set_rticks([0, 1, 2, 3])  # implicitly sets a FixedLocator\n    assert not ax.yaxis.isDefault_majloc  # because of the fixed ticks\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.FixedLocator)\n\n    ax.clear()\n\n    ax.set_rgrids([0, 1, 2, 3])  # implicitly sets a FixedLocator\n    assert not ax.yaxis.isDefault_majloc  # because of the fixed ticks\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.FixedLocator)\n\n    ax.clear()\n\n    ax.set_yscale(\"log\")  # implicitly sets a LogLocator\n    # Note that the LogLocator is still considered the default locator\n    # for the log scale\n    assert ax.yaxis.isDefault_majloc\n    assert isinstance(ax.yaxis.get_major_locator(), RadialLocator)\n    assert isinstance(ax.yaxis.get_major_locator().base, mticker.LogLocator)\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ssert 10.0 not in loc.tick_values(0.9, 20.)\n        # don't switch if there's already one major and one minor tick (10 & 20)\n        loc = mticker.LogLocator(subs=\"auto\")\n        tv = loc.tick_values(10, 20)\n        assert_array_equal(tv[(10 <= tv) & (tv <= 20)], [20])\n\n    def test_set_params(self):\n        \"\"\"\n        Create log locator with default value, base=10.0, subs=[1.0],\n        numticks=15 and change it to something else.\n        See if change was successful. Should not raise exception.\n        \"\"\"\n        loc = mticker.LogLocator()\n        loc.set_params(numticks=7, subs=[2.0], base=4)\n        assert loc.numticks == 7\n        assert loc._base == 4\n        assert list(loc._subs) == [2.0]\n\n    def test_tick_values_correct(self):\n        ll = mticker.LogLocator(subs=(1, 2, 5))\n        test_value = np.array([1.e-01, 2.e-01, 5.e-01, 1.e+00, 2.e+00, 5.e+00,\n                               1.e+01, 2.e+01, 5.e+01, 1.e+02, 2.e+02, 5.e+02,\n                               1.e+03, 2.e+03, 5.e+03, 1.e+04, 2.e+04, 5.e+04,\n                               1.e+05, 2.e+05, 5.e+05, 1.e+06, 2.e+06, 5.e+06,\n                               1.e+07, 2.e+07, 5.e+07])\n        assert_almost_equal(ll.tick_values(1, 1e7), test_value)\n\n    def test_tick_values_not_empty(self):\n        mpl.rcParams['_internal.classic_mode'] = False\n        ll = mticker.LogLocator(subs=(1, 2, 5))\n        test_value = np.array([1.e-01, 2.e-01, 5.e-01, 1.e+00, 2.e+00, 5.e+00,\n                               1.e+01, 2.e+01, 5.e+01, 1.e+02, 2.e+02, 5.e+02,\n                               1.e+03, 2.e+03, 5.e+03, 1.e+04, 2.e+04, 5.e+04,\n                               1.e+05, 2.e+05, 5.e+05, 1.e+06, 2.e+06, 5.e+06,\n                               1.e+07, 2.e+07, 5.e+07, 1.e+08, 2.e+08, 5.e+08])\n        assert_almost_equal(ll.tick_values(1, 1e8), test_value)\n\n    def test_multiple_shared_axes(self):\n        rng = np.random.default_rng(19680801)\n        dummy_data = [rng.normal(size=100), [], []]\n        fig, axes = p"}, {"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".set_params(subs=sub)\n\n\n@pytest.mark.parametrize(\"numticks, lims, ticks\", [\n    (1, (.5, 5), [.1, 1, 10]),\n    (2, (.5, 5), [.1, 1, 10]),\n    (3, (.5, 5), [.1, 1, 10]),\n    (9, (.5, 5), [.1, 1, 10]),\n    (1, (.5, 50), [.1, 10, 1_000]),\n    (2, (.5, 50), [.1, 1, 10, 100]),\n    (3, (.5, 50), [.1, 1, 10, 100]),\n    (9, (.5, 50), [.1, 1, 10, 100]),\n    (1, (.5, 500), [.1, 10, 1_000]),\n    (2, (.5, 500), [.01, 1, 100, 10_000]),\n    (3, (.5, 500), [.1, 1, 10, 100, 1_000]),\n    (9, (.5, 500), [.1, 1, 10, 100, 1_000]),\n    (1, (.5, 5000), [.1, 100, 100_000]),\n    (2, (.5, 5000), [.001, 1, 1_000, 1_000_000]),\n    (3, (.5, 5000), [.001, 1, 1_000, 1_000_000]),\n    (9, (.5, 5000), [.1, 1, 10, 100, 1_000, 10_000]),\n])\n@mpl.style.context('default')\ndef test_small_range_loglocator(numticks, lims, ticks):\n    ll = mticker.LogLocator(numticks=numticks)\n    assert_array_equal(ll.tick_values(*lims), ticks)\n\n\n@mpl.style.context('default')\ndef test_loglocator_properties():\n    # Test that LogLocator returns ticks satisfying basic desirable properties\n    # for a wide range of inputs.\n    max_numticks = 8\n    pow_end = 20\n    for numticks, (lo, hi) in itertools.product(\n            range(1, max_numticks + 1), itertools.combinations(range(pow_end), 2)):\n        ll = mticker.LogLocator(numticks=numticks)\n        decades = np.log10(ll.tick_values(10**lo, 10**hi)).round().astype(int)\n        # There are no more ticks than the requested number, plus exactly one\n        # tick below and one tick above the limits.\n        assert len(decades) <= numticks + 2\n        assert decades[0] < lo <= decades[1]\n        assert decades[-2] <= hi < decades[-1]\n        stride, = {*np.diff(decades)}  # Extract the (constant) stride.\n        # Either the ticks are on integer multiples of the stride...\n        if not (decades % stride == 0).all():\n            # ... or (for this given stride) no offset would be acceptable,\n            # i.e. they would either result in fewer ticks than the selected\n            #"}, {"start_line": 75000, "end_line": 77000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s ticks satisfying basic desirable properties\n    # for a wide range of inputs.\n    max_numticks = 8\n    pow_end = 20\n    for numticks, (lo, hi) in itertools.product(\n            range(1, max_numticks + 1), itertools.combinations(range(pow_end), 2)):\n        ll = mticker.LogLocator(numticks=numticks)\n        decades = np.log10(ll.tick_values(10**lo, 10**hi)).round().astype(int)\n        # There are no more ticks than the requested number, plus exactly one\n        # tick below and one tick above the limits.\n        assert len(decades) <= numticks + 2\n        assert decades[0] < lo <= decades[1]\n        assert decades[-2] <= hi < decades[-1]\n        stride, = {*np.diff(decades)}  # Extract the (constant) stride.\n        # Either the ticks are on integer multiples of the stride...\n        if not (decades % stride == 0).all():\n            # ... or (for this given stride) no offset would be acceptable,\n            # i.e. they would either result in fewer ticks than the selected\n            # solution, or more than the requested number of ticks.\n            for offset in range(0, stride):\n                alt_decades = range(lo + offset, hi + 1, stride)\n                assert len(alt_decades) < len(decades) or len(alt_decades) > numticks\n\n\ndef test_NullFormatter():\n    formatter = mticker.NullFormatter()\n    assert formatter(1.0) == ''\n    assert formatter.format_data(1.0) == ''\n    assert formatter.format_data_short(1.0) == ''\n\n\n@pytest.mark.parametrize('formatter', (\n    mticker.FuncFormatter(lambda a: f'val: {a}'),\n    mticker.FixedFormatter(('foo', 'bar'))))\ndef test_set_offset_string(formatter):\n    assert formatter.get_offset() == ''\n    formatter.set_offset_string('mpl')\n    assert formatter.get_offset() == 'mpl'\n\n\ndef test_minorticks_on_multi_fig():\n    \"\"\"\n    Turning on minor gridlines in a multi-Axes Figure\n    that contains more than one boxplot and shares the x-axis\n    should not raise an exception.\n    \"\"\"\n    fig, ax = plt.subplots()\n\n    ax.boxplot(np.arang"}, {"start_line": 108000, "end_line": 110000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t(121, projection=prj)\n    assert type(ax) is PolarAxes\n    plt.close()\n\n\ndef test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)\n\n\ndef test_log_scales():\n    fig, ax = plt.subplots()\n    ax.plot(np.log(np.linspace(0.1, 100)))\n    ax.set_yscale('log', base=5.5)\n    ax.invert_yaxis()\n    ax.set_xscale('log', base=9.0)\n    xticks, yticks = (\n        [(t.get_loc(), t.label1.get_text()) for t in axis._update_ticks()]\n        for axis in [ax.xaxis, ax.yaxis]\n    )\n    assert xticks == [\n        (1.0, '$\\\\mathdefault{9^{0}}$'),\n        (9.0, '$\\\\mathdefault{9^{1}}$'),\n        (81.0, '$\\\\mathdefault{9^{2}}$'),\n        (2.0, ''),\n        (3.0, ''),\n        (4.0, ''),\n        (5.0, ''),\n        (6.0, ''),\n        (7.0, ''),\n        (8.0, ''),\n        (18.0, ''),\n        (27.0, ''),\n        (36.0, ''),\n        (45.0, ''),\n        (54.0, ''),\n        (63.0, ''),\n        (72.0, ''),\n    ]\n    assert yticks == [\n        (0.18181818181818182, '$\\\\mathdefault{5.5^{-1}}$'),\n        (1.0, '$\\\\mathdefault{5.5^{0}}$'),\n        (5.5, '$\\\\mathdefault{5.5^{1}}$'),\n        (0.36363636363636365, ''),\n        (0.5454545454545454, ''),\n        (0.7272727272727273, ''),\n        (0.9090909090909092, ''),\n        (2.0, ''),\n        (3.0, ''),\n        (4.0, ''),\n        (5.0, ''),\n    ]\n\n\ndef test_log_scales_no_data():\n    _, ax = plt.subplots()\n    ax.set(xscale=\"log\", yscale=\"log\")\n    ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n    assert ax.get_xlim() == ax.get_ylim() == (1, 10)\n\n\ndef test_log_scales_invalid():\n    fig, ax = plt.subplots()\n    ax.set_xscale('log')\n    with pytest.warns(UserWarning, match='Attempt to set non-positive'):\n        ax.set_xlim(-1, 10)\n    ax.set_yscale('log')\n    with pytest.warns(UserWarning, match='Attempt to set non-positive'):\n        ax.set_ylim(-1, 10)\n\n\n@image_"}, {"start_line": 73000, "end_line": 75000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "r_ticks(15)\n    if remove_overlapping_locs is not None:\n        ax.xaxis.remove_overlapping_locs = remove_overlapping_locs\n\n    # check that getter/setter exists\n    current = ax.xaxis.remove_overlapping_locs\n    assert (current == ax.xaxis.get_remove_overlapping_locs())\n    plt.setp(ax.xaxis, remove_overlapping_locs=current)\n    new = ax.xaxis.remove_overlapping_locs\n    assert (new == ax.xaxis.remove_overlapping_locs)\n\n    # check that the accessors filter correctly\n    # this is the method that does the actual filtering\n    assert len(ax.xaxis.get_minorticklocs()) == expected_num\n    # these three are derivative\n    assert len(ax.xaxis.get_minor_ticks()) == expected_num\n    assert len(ax.xaxis.get_minorticklabels()) == expected_num\n    assert len(ax.xaxis.get_minorticklines()) == expected_num*2\n\n\n@pytest.mark.parametrize('sub', [\n    ['hi', 'aardvark'],\n    np.zeros((2, 2))])\ndef test_bad_locator_subs(sub):\n    ll = mticker.LogLocator()\n    with pytest.raises(ValueError):\n        ll.set_params(subs=sub)\n\n\n@pytest.mark.parametrize(\"numticks, lims, ticks\", [\n    (1, (.5, 5), [.1, 1, 10]),\n    (2, (.5, 5), [.1, 1, 10]),\n    (3, (.5, 5), [.1, 1, 10]),\n    (9, (.5, 5), [.1, 1, 10]),\n    (1, (.5, 50), [.1, 10, 1_000]),\n    (2, (.5, 50), [.1, 1, 10, 100]),\n    (3, (.5, 50), [.1, 1, 10, 100]),\n    (9, (.5, 50), [.1, 1, 10, 100]),\n    (1, (.5, 500), [.1, 10, 1_000]),\n    (2, (.5, 500), [.01, 1, 100, 10_000]),\n    (3, (.5, 500), [.1, 1, 10, 100, 1_000]),\n    (9, (.5, 500), [.1, 1, 10, 100, 1_000]),\n    (1, (.5, 5000), [.1, 100, 100_000]),\n    (2, (.5, 5000), [.001, 1, 1_000, 1_000_000]),\n    (3, (.5, 5000), [.001, 1, 1_000, 1_000_000]),\n    (9, (.5, 5000), [.1, 1, 10, 100, 1_000, 10_000]),\n])\n@mpl.style.context('default')\ndef test_small_range_loglocator(numticks, lims, ticks):\n    ll = mticker.LogLocator(numticks=numticks)\n    assert_array_equal(ll.tick_values(*lims), ticks)\n\n\n@mpl.style.context('default')\ndef test_loglocator_properties():\n    # Test that LogLocator return"}], "retrieved_count": 10, "cost_time": 3.2457799911499023}
{"question": "What are the cascading effects that would occur in the axis rendering pipeline if modifications to the GridHelperCurveLinear's grid information structure propagate through FixedAxisArtistHelper's tick iteration logic?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "grid_helper_curvelinear.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "x)[good]\n                missing &= ~good\n                eps_p *= 2\n        return thetas_dp\n\n    thetas_dx = calc_thetas(lambda eps_p, eps_q: func(xs + eps_p, ys + eps_q),\n                            xs, xeps, xeps_max, yeps)\n    thetas_dy = calc_thetas(lambda eps_p, eps_q: func(xs + eps_q, ys + eps_p),\n                            ys, yeps, yeps_max, xeps)\n    return (val, thetas_dx, thetas_dy)\n\n\nclass FixedAxisArtistHelper(_FixedAxisArtistHelperBase):\n    \"\"\"\n    Helper class for a fixed axis.\n    \"\"\"\n\n    def __init__(self, grid_helper, side, nth_coord_ticks=None):\n        \"\"\"\n        nth_coord = along which coordinate value varies.\n         nth_coord = 0 ->  x axis, nth_coord = 1 -> y axis\n        \"\"\"\n\n        super().__init__(loc=side)\n\n        self.grid_helper = grid_helper\n        if nth_coord_ticks is None:\n            nth_coord_ticks = self.nth_coord\n        self.nth_coord_ticks = nth_coord_ticks\n\n        self.side = side\n\n    def update_lim(self, axes):\n        self.grid_helper.update_lim(axes)\n\n    def get_tick_transform(self, axes):\n        return axes.transData\n\n    def get_tick_iterators(self, axes):\n        \"\"\"tick_loc, tick_angle, tick_label\"\"\"\n        v1, v2 = axes.get_ylim() if self.nth_coord == 0 else axes.get_xlim()\n        if v1 > v2:  # Inverted limits.\n            side = {\"left\": \"right\", \"right\": \"left\",\n                    \"top\": \"bottom\", \"bottom\": \"top\"}[self.side]\n        else:\n            side = self.side\n\n        angle_tangent = dict(left=90, right=90, bottom=0, top=0)[side]\n\n        def iter_major():\n            for nth_coord, show_labels in [\n                    (self.nth_coord_ticks, True), (1 - self.nth_coord_ticks, False)]:\n                gi = self.grid_helper._grid_info[[\"lon\", \"lat\"][nth_coord]]\n                for tick in gi[\"ticks\"][side]:\n                    yield (*tick[\"loc\"], angle_tangent,\n                           (tick[\"label\"] if show_labels else \"\"))\n\n        return iter_major(), iter([])\n\n\nclass FloatingAxisArtistH"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "floating_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er2)\n\n    def new_fixed_axis(\n            self, loc, nth_coord=None, axis_direction=None, offset=None, axes=None):\n        if axes is None:\n            axes = self.axes\n        if axis_direction is None:\n            axis_direction = loc\n        # This is not the same as the FixedAxisArtistHelper class used by\n        # grid_helper_curvelinear.GridHelperCurveLinear.new_fixed_axis!\n        helper = FixedAxisArtistHelper(\n            self, loc, nth_coord_ticks=nth_coord)\n        axisline = AxisArtist(axes, helper, axis_direction=axis_direction)\n        # Perhaps should be moved to the base class?\n        axisline.line.set_clip_on(True)\n        axisline.line.set_clip_box(axisline.axes.bbox)\n        return axisline\n\n    # new_floating_axis will inherit the grid_helper's extremes.\n\n    # def new_floating_axis(self, nth_coord, value, axes=None, axis_direction=\"bottom\"):\n    #     axis = super(GridHelperCurveLinear,\n    #                  self).new_floating_axis(nth_coord,\n    #                                          value, axes=axes,\n    #                                          axis_direction=axis_direction)\n    #     # set extreme values of the axis helper\n    #     if nth_coord == 1:\n    #         axis.get_helper().set_extremes(*self._extremes[:2])\n    #     elif nth_coord == 0:\n    #         axis.get_helper().set_extremes(*self._extremes[2:])\n    #     return axis\n\n    def _update_grid(self, bbox):\n        if self._grid_info is None:\n            self._grid_info = dict()\n\n        grid_info = self._grid_info\n\n        grid_finder = self.grid_finder\n        tbbox = grid_finder.extreme_finder._find_transformed_bbox(\n            grid_finder.get_transform().inverted(), bbox)\n\n        lon_min, lat_min, lon_max, lat_max = tbbox.extents\n        grid_info[\"extremes\"] = tbbox\n\n        lon_levs, lon_n, lon_factor = grid_finder.grid_locator1(lon_min, lon_max)\n        lon_levs = np.asarray(lon_levs)\n        lat_levs, lat_n, lat_factor = grid_finder.grid_locator2(lat_min, lat_max)\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "floating_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                           value, axes=axes,\n    #                                          axis_direction=axis_direction)\n    #     # set extreme values of the axis helper\n    #     if nth_coord == 1:\n    #         axis.get_helper().set_extremes(*self._extremes[:2])\n    #     elif nth_coord == 0:\n    #         axis.get_helper().set_extremes(*self._extremes[2:])\n    #     return axis\n\n    def _update_grid(self, bbox):\n        if self._grid_info is None:\n            self._grid_info = dict()\n\n        grid_info = self._grid_info\n\n        grid_finder = self.grid_finder\n        tbbox = grid_finder.extreme_finder._find_transformed_bbox(\n            grid_finder.get_transform().inverted(), bbox)\n\n        lon_min, lat_min, lon_max, lat_max = tbbox.extents\n        grid_info[\"extremes\"] = tbbox\n\n        lon_levs, lon_n, lon_factor = grid_finder.grid_locator1(lon_min, lon_max)\n        lon_levs = np.asarray(lon_levs)\n        lat_levs, lat_n, lat_factor = grid_finder.grid_locator2(lat_min, lat_max)\n        lat_levs = np.asarray(lat_levs)\n\n        grid_info[\"lon_info\"] = lon_levs, lon_n, lon_factor\n        grid_info[\"lat_info\"] = lat_levs, lat_n, lat_factor\n\n        grid_info[\"lon_labels\"] = grid_finder._format_ticks(\n            1, \"bottom\", lon_factor, lon_levs)\n        grid_info[\"lat_labels\"] = grid_finder._format_ticks(\n            2, \"bottom\", lat_factor, lat_levs)\n\n        lon_values = lon_levs[:lon_n] / lon_factor\n        lat_values = lat_levs[:lat_n] / lat_factor\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            lon_values[(lon_min < lon_values) & (lon_values < lon_max)],\n            lat_values[(lat_min < lat_values) & (lat_values < lat_max)],\n            tbbox)\n\n        grid_info[\"lon_lines\"] = lon_lines\n        grid_info[\"lat_lines\"] = lat_lines\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            tbbox.intervalx, tbbox.intervaly, tbbox)\n\n        grid_info[\"lon_lines0\"] = lon_lines\n        grid_info[\"lat_lines0\"] = lat_l"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "grid_finder.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             tick_formatter1=None,\n                 tick_formatter2=None):\n        if extreme_finder is None:\n            extreme_finder = ExtremeFinderSimple(20, 20)\n        if grid_locator1 is None:\n            grid_locator1 = MaxNLocator()\n        if grid_locator2 is None:\n            grid_locator2 = MaxNLocator()\n        if tick_formatter1 is None:\n            tick_formatter1 = FormatterPrettyPrint()\n        if tick_formatter2 is None:\n            tick_formatter2 = FormatterPrettyPrint()\n        self.extreme_finder = extreme_finder\n        self.grid_locator1 = grid_locator1\n        self.grid_locator2 = grid_locator2\n        self.tick_formatter1 = tick_formatter1\n        self.tick_formatter2 = tick_formatter2\n        self.set_transform(transform)\n\n    def _format_ticks(self, idx, direction, factor, levels):\n        \"\"\"\n        Helper to support both standard formatters (inheriting from\n        `.mticker.Formatter`) and axisartist-specific ones; should be called instead of\n        directly calling ``self.tick_formatter1`` and ``self.tick_formatter2``.  This\n        method should be considered as a temporary workaround which will be removed in\n        the future at the same time as axisartist-specific formatters.\n        \"\"\"\n        fmt = _api.check_getitem(\n            {1: self.tick_formatter1, 2: self.tick_formatter2}, idx=idx)\n        return (fmt.format_ticks(levels) if isinstance(fmt, mticker.Formatter)\n                else fmt(direction, factor, levels))\n\n    def get_grid_info(self, *args, **kwargs):\n        \"\"\"\n        Compute positioning information for grid lines and ticks, given the\n        axes' data *bbox*.\n        \"\"\"\n        params = _api.select_matching_signature(\n            [lambda x1, y1, x2, y2: locals(), lambda bbox: locals()], *args, **kwargs)\n        if \"x1\" in params:\n            _api.warn_deprecated(\"3.11\", message=(\n                \"Passing extents as separate arguments to get_grid_info is deprecated \"\n                \"since %(since)s and su"}, {"start_line": 12000, "end_line": 13506, "belongs_to": {"file_name": "grid_helper_curvelinear.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "revalidation.\n\n    def new_fixed_axis(\n        self, loc, *, axis_direction=None, offset=None, axes=None, nth_coord=None\n    ):\n        if axes is None:\n            axes = self.axes\n        if axis_direction is None:\n            axis_direction = loc\n        helper = FixedAxisArtistHelper(self, loc, nth_coord_ticks=nth_coord)\n        axisline = AxisArtist(axes, helper, axis_direction=axis_direction)\n        # Why is clip not set on axisline, unlike in new_floating_axis or in\n        # the floating_axig.GridHelperCurveLinear subclass?\n        return axisline\n\n    def new_floating_axis(self, nth_coord, value, axes=None, axis_direction=\"bottom\"):\n        if axes is None:\n            axes = self.axes\n        helper = FloatingAxisArtistHelper(\n            self, nth_coord, value, axis_direction)\n        axisline = AxisArtist(axes, helper)\n        axisline.line.set_clip_on(True)\n        axisline.line.set_clip_box(axisline.axes.bbox)\n        # axisline.major_ticklabels.set_visible(True)\n        # axisline.minor_ticklabels.set_visible(False)\n        return axisline\n\n    def _update_grid(self, bbox):\n        self._grid_info = self.grid_finder.get_grid_info(bbox)\n\n    def get_gridlines(self, which=\"major\", axis=\"both\"):\n        grid_lines = []\n        if axis in [\"both\", \"x\"]:\n            grid_lines.extend([gl.T for gl in self._grid_info[\"lon\"][\"lines\"]])\n        if axis in [\"both\", \"y\"]:\n            grid_lines.extend([gl.T for gl in self._grid_info[\"lat\"][\"lines\"]])\n        return grid_lines\n"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "axislines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le_tangent = {0: (90, 0), 1: (0, 90)}[self.nth_coord]\n\n        major = self.axis.major\n        major_locs = major.locator()\n        major_labels = major.formatter.format_ticks(major_locs)\n\n        minor = self.axis.minor\n        minor_locs = minor.locator()\n        minor_labels = minor.formatter.format_ticks(minor_locs)\n\n        data_to_axes = axes.transData - axes.transAxes\n\n        def _f(locs, labels):\n            for loc, label in zip(locs, labels):\n                c = self._to_xy(loc, const=self._value)\n                c1, c2 = data_to_axes.transform(c)\n                if 0 <= c1 <= 1 and 0 <= c2 <= 1:\n                    yield c, angle_normal, angle_tangent, label\n\n        return _f(major_locs, major_labels), _f(minor_locs, minor_labels)\n\n\nclass AxisArtistHelper:  # Backcompat.\n    Fixed = _FixedAxisArtistHelperBase\n    Floating = _FloatingAxisArtistHelperBase\n\n\nclass AxisArtistHelperRectlinear:  # Backcompat.\n    Fixed = FixedAxisArtistHelperRectilinear\n    Floating = FloatingAxisArtistHelperRectilinear\n\n\nclass GridHelperBase:\n\n    def __init__(self):\n        self._old_limits = None\n        super().__init__()\n\n    def update_lim(self, axes):\n        x1, x2 = axes.get_xlim()\n        y1, y2 = axes.get_ylim()\n        if self._old_limits != (x1, x2, y1, y2):\n            self._update_grid(Bbox.from_extents(x1, y1, x2, y2))\n            self._old_limits = (x1, x2, y1, y2)\n\n    def _update_grid(self, bbox):\n        \"\"\"Cache relevant computations when the axes limits have changed.\"\"\"\n\n    def get_gridlines(self, which, axis):\n        \"\"\"\n        Return list of grid lines as a list of paths (list of points).\n\n        Parameters\n        ----------\n        which : {\"both\", \"major\", \"minor\"}\n        axis : {\"both\", \"x\", \"y\"}\n        \"\"\"\n        return []\n\n\nclass GridHelperRectlinear(GridHelperBase):\n\n    def __init__(self, axes):\n        super().__init__()\n        self.axes = axes\n\n    def new_fixed_axis(\n        self, loc, *, axis_direction=None, offset=None, axes=None\n "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "floating_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        lat_levs = np.asarray(lat_levs)\n\n        grid_info[\"lon_info\"] = lon_levs, lon_n, lon_factor\n        grid_info[\"lat_info\"] = lat_levs, lat_n, lat_factor\n\n        grid_info[\"lon_labels\"] = grid_finder._format_ticks(\n            1, \"bottom\", lon_factor, lon_levs)\n        grid_info[\"lat_labels\"] = grid_finder._format_ticks(\n            2, \"bottom\", lat_factor, lat_levs)\n\n        lon_values = lon_levs[:lon_n] / lon_factor\n        lat_values = lat_levs[:lat_n] / lat_factor\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            lon_values[(lon_min < lon_values) & (lon_values < lon_max)],\n            lat_values[(lat_min < lat_values) & (lat_values < lat_max)],\n            tbbox)\n\n        grid_info[\"lon_lines\"] = lon_lines\n        grid_info[\"lat_lines\"] = lat_lines\n\n        lon_lines, lat_lines = grid_finder._get_raw_grid_lines(\n            tbbox.intervalx, tbbox.intervaly, tbbox)\n\n        grid_info[\"lon_lines0\"] = lon_lines\n        grid_info[\"lat_lines0\"] = lat_lines\n\n    def get_gridlines(self, which=\"major\", axis=\"both\"):\n        grid_lines = []\n        if axis in [\"both\", \"x\"]:\n            grid_lines.extend(map(np.transpose, self._grid_info[\"lon_lines\"]))\n        if axis in [\"both\", \"y\"]:\n            grid_lines.extend(map(np.transpose, self._grid_info[\"lat_lines\"]))\n        return grid_lines\n\n\nclass FloatingAxesBase:\n\n    def __init__(self, *args, grid_helper, **kwargs):\n        _api.check_isinstance(GridHelperCurveLinear, grid_helper=grid_helper)\n        super().__init__(*args, grid_helper=grid_helper, **kwargs)\n        self.set_aspect(1.)\n\n    def _gen_axes_patch(self):\n        # docstring inherited\n        x0, x1, y0, y1 = self.get_grid_helper().grid_finder.extreme_finder(*[None] * 5)\n        patch = mpatches.Polygon([(x0, y0), (x1, y0), (x1, y1), (x0, y1)])\n        patch.get_path()._interpolation_steps = 100\n        return patch\n\n    def clear(self):\n        super().clear()\n        self.patch.set_transform(\n            self.get_grid_hel"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "grid_finder.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         (2, \"lat\", lat_levs, lat_factor, lat_values, lat_lines),\n        ]:\n            grid_info[lon_or_lat] = gi = {\n                \"lines\": lines,\n                \"ticks\": {\"left\": [], \"right\": [], \"bottom\": [], \"top\": []},\n            }\n            for xys, v, level in zip(lines, values, levs):\n                all_crossings = _find_line_box_crossings(xys, bbox_expanded)\n                for side, crossings in zip(\n                        [\"left\", \"right\", \"bottom\", \"top\"], all_crossings):\n                    for crossing in crossings:\n                        gi[\"ticks\"][side].append({\"level\": level, \"loc\": crossing})\n            for side in gi[\"ticks\"]:\n                levs = [tick[\"level\"] for tick in gi[\"ticks\"][side]]\n                labels = self._format_ticks(idx, side, factor, levs)\n                for tick, label in zip(gi[\"ticks\"][side], labels):\n                    tick[\"label\"] = label\n\n        return grid_info\n\n    def _get_raw_grid_lines(self, lon_values, lat_values, bbox):\n        trans = self.get_transform()\n        lons = np.linspace(bbox.x0, bbox.x1, 100)  # for interpolation\n        lats = np.linspace(bbox.y0, bbox.y1, 100)\n        lon_lines = [trans.transform(np.column_stack([np.full_like(lats, lon), lats]))\n                     for lon in lon_values]\n        lat_lines = [trans.transform(np.column_stack([lons, np.full_like(lons, lat)]))\n                     for lat in lat_values]\n        return lon_lines, lat_lines\n\n    def set_transform(self, aux_trans):\n        if isinstance(aux_trans, Transform):\n            self._aux_transform = aux_trans\n        elif len(aux_trans) == 2 and all(map(callable, aux_trans)):\n            self._aux_transform = _User2DTransform(*aux_trans)\n        else:\n            raise TypeError(\"'aux_trans' must be either a Transform \"\n                            \"instance or a pair of callables\")\n\n    def get_transform(self):\n        return self._aux_transform\n\n    update_transform = set_transform  # backcompat alias.\n\n    @"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "grid_helper_curvelinear.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "broadcast_arrays(x, y))).T\n\n        # find angles\n        if self.nth_coord == 0:\n            mask = (e0 <= yy0) & (yy0 <= e1)\n            (xx1, yy1), angle_normal, angle_tangent = _value_and_jac_angle(\n                trf_xy, self.value, yy0[mask], (-np.inf, np.inf), (e0, e1))\n            labels = self._grid_info[\"lat_labels\"]\n\n        elif self.nth_coord == 1:\n            mask = (e0 <= xx0) & (xx0 <= e1)\n            (xx1, yy1), angle_tangent, angle_normal = _value_and_jac_angle(\n                trf_xy, xx0[mask], self.value, (-np.inf, np.inf), (e0, e1))\n            labels = self._grid_info[\"lon_labels\"]\n\n        labels = [l for l, m in zip(labels, mask) if m]\n        tick_to_axes = self.get_tick_transform(axes) - axes.transAxes\n        in_01 = functools.partial(\n            mpl.transforms._interval_contains_close, (0, 1))\n\n        def iter_major():\n            for x, y, normal, tangent, lab \\\n                    in zip(xx1, yy1, angle_normal, angle_tangent, labels):\n                c2 = tick_to_axes.transform((x, y))\n                if in_01(c2[0]) and in_01(c2[1]):\n                    yield [x, y], *np.rad2deg([normal, tangent]), lab\n\n        return iter_major(), iter([])\n\n    def get_line_transform(self, axes):\n        return axes.transData\n\n    def get_line(self, axes):\n        self.update_lim(axes)\n        return Path(self._grid_info[\"line_xy\"])\n\n\nclass GridHelperCurveLinear(GridHelperBase):\n    def __init__(self, aux_trans,\n                 extreme_finder=None,\n                 grid_locator1=None,\n                 grid_locator2=None,\n                 tick_formatter1=None,\n                 tick_formatter2=None):\n        \"\"\"\n        Parameters\n        ----------\n        aux_trans : `.Transform` or tuple[Callable, Callable]\n            The transform from curved coordinates to rectilinear coordinate:\n            either a `.Transform` instance (which provides also its inverse),\n            or a pair of callables ``(trans, inv_trans)`` that define the\n            t"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "grid_helper_curvelinear.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2 = tick_to_axes.transform((x, y))\n                if in_01(c2[0]) and in_01(c2[1]):\n                    yield [x, y], *np.rad2deg([normal, tangent]), lab\n\n        return iter_major(), iter([])\n\n    def get_line_transform(self, axes):\n        return axes.transData\n\n    def get_line(self, axes):\n        self.update_lim(axes)\n        return Path(self._grid_info[\"line_xy\"])\n\n\nclass GridHelperCurveLinear(GridHelperBase):\n    def __init__(self, aux_trans,\n                 extreme_finder=None,\n                 grid_locator1=None,\n                 grid_locator2=None,\n                 tick_formatter1=None,\n                 tick_formatter2=None):\n        \"\"\"\n        Parameters\n        ----------\n        aux_trans : `.Transform` or tuple[Callable, Callable]\n            The transform from curved coordinates to rectilinear coordinate:\n            either a `.Transform` instance (which provides also its inverse),\n            or a pair of callables ``(trans, inv_trans)`` that define the\n            transform and its inverse.  The callables should have signature::\n\n                x_rect, y_rect = trans(x_curved, y_curved)\n                x_curved, y_curved = inv_trans(x_rect, y_rect)\n\n        extreme_finder\n\n        grid_locator1, grid_locator2\n            Grid locators for each axis.\n\n        tick_formatter1, tick_formatter2\n            Tick formatters for each axis.\n        \"\"\"\n        super().__init__()\n        self._grid_info = None\n        self.grid_finder = GridFinder(aux_trans,\n                                      extreme_finder,\n                                      grid_locator1,\n                                      grid_locator2,\n                                      tick_formatter1,\n                                      tick_formatter2)\n\n    def update_grid_finder(self, aux_trans=None, **kwargs):\n        if aux_trans is not None:\n            self.grid_finder.update_transform(aux_trans)\n        self.grid_finder.update(**kwargs)\n        self._old_limits = None  # Force "}], "retrieved_count": 10, "cost_time": 3.317599296569824}
{"question": "What is the architectural pattern of StreamMask's trajectory recording and rollback mechanism that decouples the concerns of spatial discretization from streamline collision detection, and what architectural implications does this separation have for handling concurrent or adaptive trajectory generation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rid,\n      where N and M match the shape of the input data.\n    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask,\n      where N and M are user-specified to control the density of streamlines.\n\n    This class also has methods for adding trajectories to the StreamMask.\n    Before adding a trajectory, run `start_trajectory` to keep track of regions\n    crossed by a given trajectory. Later, if you decide the trajectory is bad\n    (e.g., if the trajectory is very short) just call `undo_trajectory`.\n    \"\"\"\n\n    def __init__(self, grid, mask):\n        self.grid = grid\n        self.mask = mask\n        # Constants for conversion between grid- and mask-coordinates\n        self.x_grid2mask = (mask.nx - 1) / (grid.nx - 1)\n        self.y_grid2mask = (mask.ny - 1) / (grid.ny - 1)\n\n        self.x_mask2grid = 1. / self.x_grid2mask\n        self.y_mask2grid = 1. / self.y_grid2mask\n\n        self.x_data2grid = 1. / grid.dx\n        self.y_data2grid = 1. / grid.dy\n\n    def grid2mask(self, xi, yi):\n        \"\"\"Return nearest space in mask-coords from given grid-coords.\"\"\"\n        return round(xi * self.x_grid2mask), round(yi * self.y_grid2mask)\n\n    def mask2grid(self, xm, ym):\n        return xm * self.x_mask2grid, ym * self.y_mask2grid\n\n    def data2grid(self, xd, yd):\n        return xd * self.x_data2grid, yd * self.y_data2grid\n\n    def grid2data(self, xg, yg):\n        return xg / self.x_data2grid, yg / self.y_data2grid\n\n    def start_trajectory(self, xg, yg, broken_streamlines=True):\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._start_trajectory(xm, ym, broken_streamlines)\n\n    def reset_start_point(self, xg, yg):\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._current_xy = (xm, ym)\n\n    def update_trajectory(self, xg, yg, broken_streamlines=True):\n        if not self.grid.within_grid(xg, yg):\n            raise InvalidIndexError\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._update_trajectory(xm, ym, broken_streamlines)\n\n    def undo_t"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s crossed by streamlines.\n\n    The resolution of this grid determines the approximate spacing between\n    trajectories. Streamlines are only allowed to pass through zeroed cells:\n    When a streamline enters a cell, that cell is set to 1, and no new\n    streamlines are allowed to enter.\n    \"\"\"\n\n    def __init__(self, density):\n        try:\n            self.nx, self.ny = (30 * np.broadcast_to(density, 2)).astype(int)\n        except ValueError as err:\n            raise ValueError(\"'density' must be a scalar or be of length \"\n                             \"2\") from err\n        if self.nx < 0 or self.ny < 0:\n            raise ValueError(\"'density' must be positive\")\n        self._mask = np.zeros((self.ny, self.nx))\n        self.shape = self._mask.shape\n\n        self._current_xy = None\n\n    def __getitem__(self, args):\n        return self._mask[args]\n\n    def _start_trajectory(self, xm, ym, broken_streamlines=True):\n        \"\"\"Start recording streamline trajectory\"\"\"\n        self._traj = []\n        self._update_trajectory(xm, ym, broken_streamlines)\n\n    def _undo_trajectory(self):\n        \"\"\"Remove current trajectory from mask\"\"\"\n        for t in self._traj:\n            self._mask[t] = 0\n\n    def _update_trajectory(self, xm, ym, broken_streamlines=True):\n        \"\"\"\n        Update current trajectory position in mask.\n\n        If the new position has already been filled, raise `InvalidIndexError`.\n        \"\"\"\n        if self._current_xy != (xm, ym):\n            if self[ym, xm] == 0:\n                self._traj.append((ym, xm))\n                self._mask[ym, xm] = 1\n                self._current_xy = (xm, ym)\n            else:\n                if broken_streamlines:\n                    raise InvalidIndexError\n                else:\n                    pass\n\n\nclass InvalidIndexError(Exception):\n    pass\n\n\nclass TerminateTrajectory(Exception):\n    pass\n\n\n# Integrator definitions\n# =======================\n\ndef _get_integrator(u, v, dmap, minlength, maxlength, integration_direct"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        self._update_trajectory(xm, ym, broken_streamlines)\n\n    def _undo_trajectory(self):\n        \"\"\"Remove current trajectory from mask\"\"\"\n        for t in self._traj:\n            self._mask[t] = 0\n\n    def _update_trajectory(self, xm, ym, broken_streamlines=True):\n        \"\"\"\n        Update current trajectory position in mask.\n\n        If the new position has already been filled, raise `InvalidIndexError`.\n        \"\"\"\n        if self._current_xy != (xm, ym):\n            if self[ym, xm] == 0:\n                self._traj.append((ym, xm))\n                self._mask[ym, xm] = 1\n                self._current_xy = (xm, ym)\n            else:\n                if broken_streamlines:\n                    raise InvalidIndexError\n                else:\n                    pass\n\n\nclass InvalidIndexError(Exception):\n    pass\n\n\nclass TerminateTrajectory(Exception):\n    pass\n\n\n# Integrator definitions\n# =======================\n\ndef _get_integrator(u, v, dmap, minlength, maxlength, integration_direction):\n\n    # rescale velocity onto grid-coordinates for integrations.\n    u, v = dmap.data2grid(u, v)\n\n    # speed (path length) will be in axes-coordinates\n    u_ax = u / (dmap.grid.nx - 1)\n    v_ax = v / (dmap.grid.ny - 1)\n    speed = np.ma.sqrt(u_ax ** 2 + v_ax ** 2)\n\n    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds\n\n    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi\n\n    def integrate(x0, y0, broken_streamlines=True, integration_max_step_scale=1.0,\n                  integration_max_error_scale=1.0):\n        \"\"\"\n        Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from st"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "arting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, xy_traj = 0., []\n\n        try:\n            dmap.start_trajectory(x0, y0, broken_streamlines)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xyt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength,\n                                     broken_streamlines,\n                                     integration_max_step_scale,\n                                     integration_max_error_scale)\n            stotal += s\n            xy_traj += xyt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xyt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength,\n                                     broken_streamlines,\n                                     integration_max_step_scale,\n                                     integration_max_error_scale)\n            stotal += s\n            xy_traj += xyt[1:]\n\n        if stotal > minlength:\n            return np.broadcast_arrays(xy_traj, np.empty((1, 2)))[0]\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None\n\n    return integrate\n\n\nclass OutOfBounds(IndexError):\n    pass\n\n\ndef _integrate_rk12(x0, y0, dmap, f, maxlength, broken_streamlines=True,\n                    integration_max_step_scale=1.0,\n                    integration_max_error_scale=1.0):\n    \"\"\"\n    2nd-order Runge-Kutta algorithm with adaptive step size.\n\n    This method is also referred to as the improved Euler's method, or Heun's\n    method. This method is favored over higher-order methods because:\n\n    1. To get decent looking trajectories and to sample every mask cell\n       o"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s.x[:] = [grid.x_origin, grid.x_origin + grid.width]\n    lc.sticky_edges.y[:] = [grid.y_origin, grid.y_origin + grid.height]\n    if use_multicolor_lines:\n        lc.set_array(np.ma.hstack(line_colors))\n        lc.set_cmap(cmap)\n        lc.set_norm(norm)\n    axes.add_collection(lc)\n\n    ac = mcollections.PatchCollection(arrows)\n    # Adding the collection itself is broken; see #2341.\n    for p in arrows:\n        axes.add_patch(p)\n\n    axes.autoscale_view()\n    stream_container = StreamplotSet(lc, ac)\n    return stream_container\n\n\nclass StreamplotSet:\n\n    def __init__(self, lines, arrows):\n        self.lines = lines\n        self.arrows = arrows\n\n\n# Coordinate definitions\n# ========================\n\nclass DomainMap:\n    \"\"\"\n    Map representing different coordinate systems.\n\n    Coordinate definitions:\n\n    * axes-coordinates goes from 0 to 1 in the domain.\n    * data-coordinates are specified by the input x-y coordinates.\n    * grid-coordinates goes from 0 to N and 0 to M for an N x M grid,\n      where N and M match the shape of the input data.\n    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask,\n      where N and M are user-specified to control the density of streamlines.\n\n    This class also has methods for adding trajectories to the StreamMask.\n    Before adding a trajectory, run `start_trajectory` to keep track of regions\n    crossed by a given trajectory. Later, if you decide the trajectory is bad\n    (e.g., if the trajectory is very short) just call `undo_trajectory`.\n    \"\"\"\n\n    def __init__(self, grid, mask):\n        self.grid = grid\n        self.mask = mask\n        # Constants for conversion between grid- and mask-coordinates\n        self.x_grid2mask = (mask.nx - 1) / (grid.nx - 1)\n        self.y_grid2mask = (mask.ny - 1) / (grid.ny - 1)\n\n        self.x_mask2grid = 1. / self.x_grid2mask\n        self.y_mask2grid = 1. / self.y_grid2mask\n\n        self.x_data2grid = 1. / grid.dx\n        self.y_data2grid = 1. / grid.dy\n\n    def grid2mask(self, x"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t be strictly increasing\")\n\n        self.nx = len(x)\n        self.ny = len(y)\n\n        self.dx = x[1] - x[0]\n        self.dy = y[1] - y[0]\n\n        self.x_origin = x[0]\n        self.y_origin = y[0]\n\n        self.width = x[-1] - x[0]\n        self.height = y[-1] - y[0]\n\n        if not np.allclose(np.diff(x), self.width / (self.nx - 1)):\n            raise ValueError(\"'x' values must be equally spaced\")\n        if not np.allclose(np.diff(y), self.height / (self.ny - 1)):\n            raise ValueError(\"'y' values must be equally spaced\")\n\n    @property\n    def shape(self):\n        return self.ny, self.nx\n\n    def within_grid(self, xi, yi):\n        \"\"\"Return whether (*xi*, *yi*) is a valid index of the grid.\"\"\"\n        # Note that xi/yi can be floats; so, for example, we can't simply check\n        # `xi < self.nx` since *xi* can be `self.nx - 1 < xi < self.nx`\n        return 0 <= xi <= self.nx - 1 and 0 <= yi <= self.ny - 1\n\n\nclass StreamMask:\n    \"\"\"\n    Mask to keep track of discrete regions crossed by streamlines.\n\n    The resolution of this grid determines the approximate spacing between\n    trajectories. Streamlines are only allowed to pass through zeroed cells:\n    When a streamline enters a cell, that cell is set to 1, and no new\n    streamlines are allowed to enter.\n    \"\"\"\n\n    def __init__(self, density):\n        try:\n            self.nx, self.ny = (30 * np.broadcast_to(density, 2)).astype(int)\n        except ValueError as err:\n            raise ValueError(\"'density' must be a scalar or be of length \"\n                             \"2\") from err\n        if self.nx < 0 or self.ny < 0:\n            raise ValueError(\"'density' must be positive\")\n        self._mask = np.zeros((self.ny, self.nx))\n        self.shape = self._mask.shape\n\n        self._current_xy = None\n\n    def __getitem__(self, args):\n        return self._mask[args]\n\n    def _start_trajectory(self, xm, ym, broken_streamlines=True):\n        \"\"\"Start recording streamline trajectory\"\"\"\n        self._traj = []"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 'v' must match the shape of the (x, y) grid\")\n\n    u = np.ma.masked_invalid(u)\n    v = np.ma.masked_invalid(v)\n\n    integrate = _get_integrator(u, v, dmap, minlength, maxlength,\n                                integration_direction)\n\n    trajectories = []\n    if start_points is None:\n        for xm, ym in _gen_starting_points(mask.shape):\n            if mask[ym, xm] == 0:\n                xg, yg = dmap.mask2grid(xm, ym)\n                t = integrate(xg, yg, broken_streamlines,\n                              integration_max_step_scale,\n                              integration_max_error_scale)\n                if t is not None:\n                    trajectories.append(t)\n    else:\n        sp2 = np.asanyarray(start_points, dtype=float).copy()\n\n        # Check if start_points are outside the data boundaries\n        for xs, ys in sp2:\n            if not (grid.x_origin <= xs <= grid.x_origin + grid.width and\n                    grid.y_origin <= ys <= grid.y_origin + grid.height):\n                raise ValueError(f\"Starting point ({xs}, {ys}) outside of \"\n                                 \"data boundaries\")\n\n        # Convert start_points from data to array coords\n        # Shift the seed points from the bottom left of the data so that\n        # data2grid works properly.\n        sp2[:, 0] -= grid.x_origin\n        sp2[:, 1] -= grid.y_origin\n\n        for xs, ys in sp2:\n            xg, yg = dmap.data2grid(xs, ys)\n            # Floating point issues can cause xg, yg to be slightly out of\n            # bounds for xs, ys on the upper boundaries. Because we have\n            # already checked that the starting points are within the original\n            # grid, clip the xg, yg to the grid to work around this issue\n            xg = np.clip(xg, 0, grid.nx - 1)\n            yg = np.clip(yg, 0, grid.ny - 1)\n\n            t = integrate(xg, yg, broken_streamlines, integration_max_step_scale,\n                          integration_max_error_scale)\n            if t is not None:\n                t"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   raise ValueError(f\"Starting point ({xs}, {ys}) outside of \"\n                                 \"data boundaries\")\n\n        # Convert start_points from data to array coords\n        # Shift the seed points from the bottom left of the data so that\n        # data2grid works properly.\n        sp2[:, 0] -= grid.x_origin\n        sp2[:, 1] -= grid.y_origin\n\n        for xs, ys in sp2:\n            xg, yg = dmap.data2grid(xs, ys)\n            # Floating point issues can cause xg, yg to be slightly out of\n            # bounds for xs, ys on the upper boundaries. Because we have\n            # already checked that the starting points are within the original\n            # grid, clip the xg, yg to the grid to work around this issue\n            xg = np.clip(xg, 0, grid.nx - 1)\n            yg = np.clip(yg, 0, grid.ny - 1)\n\n            t = integrate(xg, yg, broken_streamlines, integration_max_step_scale,\n                          integration_max_error_scale)\n            if t is not None:\n                trajectories.append(t)\n\n    if use_multicolor_lines:\n        if norm is None:\n            norm = mcolors.Normalize(color.min(), color.max())\n        cmap = cm._ensure_cmap(cmap)\n\n    streamlines = []\n    arrows = []\n    for t in trajectories:\n        tgx, tgy = t.T\n        # Rescale from grid-coordinates to data-coordinates.\n        tx, ty = dmap.grid2data(tgx, tgy)\n        tx += grid.x_origin\n        ty += grid.y_origin\n\n        # Create multiple tiny segments if varying width or color is given\n        if isinstance(linewidth, np.ndarray) or use_multicolor_lines:\n            points = np.transpose([tx, ty]).reshape(-1, 1, 2)\n            streamlines.extend(np.hstack([points[:-1], points[1:]]))\n        else:\n            points = np.transpose([tx, ty])\n            streamlines.append(points)\n\n        # Distance along streamline\n        s = np.cumsum(np.hypot(np.diff(tx), np.diff(ty)))\n        if isinstance(linewidth, np.ndarray):\n            line_widths = interpgrid(linewidth, tgx, tgy)[:-1"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "th':\n        maxlength /= 2.\n\n    use_multicolor_lines = isinstance(color, np.ndarray)\n    if use_multicolor_lines:\n        if color.shape != grid.shape:\n            raise ValueError(\"If 'color' is given, it must match the shape of \"\n                             \"the (x, y) grid\")\n        line_colors = [[]]  # Empty entry allows concatenation of zero arrays.\n        color = np.ma.masked_invalid(color)\n    else:\n        line_kw['color'] = color\n        arrow_kw['color'] = color\n\n    if isinstance(linewidth, np.ndarray):\n        if linewidth.shape != grid.shape:\n            raise ValueError(\"If 'linewidth' is given, it must match the \"\n                             \"shape of the (x, y) grid\")\n        line_kw['linewidth'] = []\n    else:\n        line_kw['linewidth'] = linewidth\n        arrow_kw['linewidth'] = linewidth\n\n    line_kw['zorder'] = zorder\n    arrow_kw['zorder'] = zorder\n\n    # Sanity checks.\n    if u.shape != grid.shape or v.shape != grid.shape:\n        raise ValueError(\"'u' and 'v' must match the shape of the (x, y) grid\")\n\n    u = np.ma.masked_invalid(u)\n    v = np.ma.masked_invalid(v)\n\n    integrate = _get_integrator(u, v, dmap, minlength, maxlength,\n                                integration_direction)\n\n    trajectories = []\n    if start_points is None:\n        for xm, ym in _gen_starting_points(mask.shape):\n            if mask[ym, xm] == 0:\n                xg, yg = dmap.mask2grid(xm, ym)\n                t = integrate(xg, yg, broken_streamlines,\n                              integration_max_step_scale,\n                              integration_max_error_scale)\n                if t is not None:\n                    trajectories.append(t)\n    else:\n        sp2 = np.asanyarray(start_points, dtype=float).copy()\n\n        # Check if start_points are outside the data boundaries\n        for xs, ys in sp2:\n            if not (grid.x_origin <= xs <= grid.x_origin + grid.width and\n                    grid.y_origin <= ys <= grid.y_origin + grid.height):\n             "}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "streamplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " based on step error\n        if error == 0:\n            ds = maxds\n        else:\n            ds = min(maxds, 0.85 * ds * (maxerror / error) ** 0.5)\n\n    return stotal, xyf_traj\n\n\ndef _euler_step(xyf_traj, dmap, f):\n    \"\"\"Simple Euler integration step that extends streamline to boundary.\"\"\"\n    ny, nx = dmap.grid.shape\n    xi, yi = xyf_traj[-1]\n    cx, cy = f(xi, yi)\n    if cx == 0:\n        dsx = np.inf\n    elif cx < 0:\n        dsx = xi / -cx\n    else:\n        dsx = (nx - 1 - xi) / cx\n    if cy == 0:\n        dsy = np.inf\n    elif cy < 0:\n        dsy = yi / -cy\n    else:\n        dsy = (ny - 1 - yi) / cy\n    ds = min(dsx, dsy)\n    xyf_traj.append((xi + cx * ds, yi + cy * ds))\n    return ds, xyf_traj\n\n\n# Utility functions\n# ========================\n\ndef interpgrid(a, xi, yi):\n    \"\"\"Fast 2D, linear interpolation on an integer grid\"\"\"\n\n    Ny, Nx = np.shape(a)\n    if isinstance(xi, np.ndarray):\n        x = xi.astype(int)\n        y = yi.astype(int)\n        # Check that xn, yn don't exceed max index\n        xn = np.clip(x + 1, 0, Nx - 1)\n        yn = np.clip(y + 1, 0, Ny - 1)\n    else:\n        x = int(xi)\n        y = int(yi)\n        # conditional is faster than clipping for integers\n        if x == (Nx - 1):\n            xn = x\n        else:\n            xn = x + 1\n        if y == (Ny - 1):\n            yn = y\n        else:\n            yn = y + 1\n\n    a00 = a[y, x]\n    a01 = a[y, xn]\n    a10 = a[yn, x]\n    a11 = a[yn, xn]\n    xt = xi - x\n    yt = yi - y\n    a0 = a00 * (1 - xt) + a01 * xt\n    a1 = a10 * (1 - xt) + a11 * xt\n    ai = a0 * (1 - yt) + a1 * yt\n\n    if not isinstance(xi, np.ndarray):\n        if np.ma.is_masked(ai):\n            raise TerminateTrajectory\n\n    return ai\n\n\ndef _gen_starting_points(shape):\n    \"\"\"\n    Yield starting points for streamlines.\n\n    Trying points on the boundary first gives higher quality streamlines.\n    This algorithm starts with a point on the mask corner and spirals inward.\n    This algorithm is inefficient, but fast compared to rest of "}], "retrieved_count": 10, "cost_time": 3.416419744491577}
{"question": "What are the cascading side effects that occur when a LayoutEngine subclass fails to properly initialize the _colorbar_gridspec and _adjust_compatible class attributes before the colorbar_gridspec and adjust_compatible properties are accessed during figure rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "layout_engine.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hether to make the\n       axes using the gridspec method (see `.colorbar.make_axes_gridspec`) or\n       not (see `.colorbar.make_axes`);\n    - ``engine.adjust_compatible`` stops `.Figure.subplots_adjust` from being\n        run if it is not compatible with the layout engine.\n\n    To implement a custom `LayoutEngine`:\n\n    1. override ``_adjust_compatible`` and ``_colorbar_gridspec``\n    2. override `LayoutEngine.set` to update *self._params*\n    3. override `LayoutEngine.execute` with your implementation\n\n    \"\"\"\n    # override these in subclass\n    _adjust_compatible = None\n    _colorbar_gridspec = None\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._params = {}\n\n    def set(self, **kwargs):\n        \"\"\"\n        Set the parameters for the layout engine.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def colorbar_gridspec(self):\n        \"\"\"\n        Return a boolean if the layout engine creates colorbars using a\n        gridspec.\n        \"\"\"\n        if self._colorbar_gridspec is None:\n            raise NotImplementedError\n        return self._colorbar_gridspec\n\n    @property\n    def adjust_compatible(self):\n        \"\"\"\n        Return a boolean if the layout engine is compatible with\n        `~.Figure.subplots_adjust`.\n        \"\"\"\n        if self._adjust_compatible is None:\n            raise NotImplementedError\n        return self._adjust_compatible\n\n    def get(self):\n        \"\"\"\n        Return copy of the parameters for the layout engine.\n        \"\"\"\n        return dict(self._params)\n\n    def execute(self, fig):\n        \"\"\"\n        Execute the layout on the figure given by *fig*.\n        \"\"\"\n        # subclasses must implement this.\n        raise NotImplementedError\n\n\nclass PlaceHolderLayoutEngine(LayoutEngine):\n    \"\"\"\n    This layout engine does not adjust the figure layout at all.\n\n    The purpose of this `.LayoutEngine` is to act as a placeholder when the user removes\n    a layout engine to ensure an incompatib"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "layout_engine.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   \"\"\"\n        if self._colorbar_gridspec is None:\n            raise NotImplementedError\n        return self._colorbar_gridspec\n\n    @property\n    def adjust_compatible(self):\n        \"\"\"\n        Return a boolean if the layout engine is compatible with\n        `~.Figure.subplots_adjust`.\n        \"\"\"\n        if self._adjust_compatible is None:\n            raise NotImplementedError\n        return self._adjust_compatible\n\n    def get(self):\n        \"\"\"\n        Return copy of the parameters for the layout engine.\n        \"\"\"\n        return dict(self._params)\n\n    def execute(self, fig):\n        \"\"\"\n        Execute the layout on the figure given by *fig*.\n        \"\"\"\n        # subclasses must implement this.\n        raise NotImplementedError\n\n\nclass PlaceHolderLayoutEngine(LayoutEngine):\n    \"\"\"\n    This layout engine does not adjust the figure layout at all.\n\n    The purpose of this `.LayoutEngine` is to act as a placeholder when the user removes\n    a layout engine to ensure an incompatible `.LayoutEngine` cannot be set later.\n\n    Parameters\n    ----------\n    adjust_compatible, colorbar_gridspec : bool\n        Allow the PlaceHolderLayoutEngine to mirror the behavior of whatever\n        layout engine it is replacing.\n\n    \"\"\"\n    def __init__(self, adjust_compatible, colorbar_gridspec, **kwargs):\n        self._adjust_compatible = adjust_compatible\n        self._colorbar_gridspec = colorbar_gridspec\n        super().__init__(**kwargs)\n\n    def execute(self, fig):\n        \"\"\"\n        Do nothing.\n        \"\"\"\n        return\n\n\nclass TightLayoutEngine(LayoutEngine):\n    \"\"\"\n    Implements the ``tight_layout`` geometry management.  See\n    :ref:`tight_layout_guide` for details.\n    \"\"\"\n    _adjust_compatible = True\n    _colorbar_gridspec = True\n\n    def __init__(self, *, pad=1.08, h_pad=None, w_pad=None,\n                 rect=(0, 0, 1, 1), **kwargs):\n        \"\"\"\n        Initialize tight_layout engine.\n\n        Parameters\n        ----------\n        pad : float, default: 1.08\n "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "layout_engine.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ne`.\n\"\"\"\n\nfrom contextlib import nullcontext\n\nimport matplotlib as mpl\n\nfrom matplotlib._constrained_layout import do_constrained_layout\nfrom matplotlib._tight_layout import (get_subplotspec_list,\n                                      get_tight_layout_figure)\n\n\nclass LayoutEngine:\n    \"\"\"\n    Base class for Matplotlib layout engines.\n\n    A layout engine can be passed to a figure at instantiation or at any time\n    with `~.figure.Figure.set_layout_engine`.  Once attached to a figure, the\n    layout engine ``execute`` function is called at draw time by\n    `~.figure.Figure.draw`, providing a special draw-time hook.\n\n    .. note::\n\n       However, note that layout engines affect the creation of colorbars, so\n       `~.figure.Figure.set_layout_engine` should be called before any\n       colorbars are created.\n\n    Currently, there are two properties of `LayoutEngine` classes that are\n    consulted while manipulating the figure:\n\n    - ``engine.colorbar_gridspec`` tells `.Figure.colorbar` whether to make the\n       axes using the gridspec method (see `.colorbar.make_axes_gridspec`) or\n       not (see `.colorbar.make_axes`);\n    - ``engine.adjust_compatible`` stops `.Figure.subplots_adjust` from being\n        run if it is not compatible with the layout engine.\n\n    To implement a custom `LayoutEngine`:\n\n    1. override ``_adjust_compatible`` and ``_colorbar_gridspec``\n    2. override `LayoutEngine.set` to update *self._params*\n    3. override `LayoutEngine.execute` with your implementation\n\n    \"\"\"\n    # override these in subclass\n    _adjust_compatible = None\n    _colorbar_gridspec = None\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._params = {}\n\n    def set(self, **kwargs):\n        \"\"\"\n        Set the parameters for the layout engine.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def colorbar_gridspec(self):\n        \"\"\"\n        Return a boolean if the layout engine creates colorbars using a\n        gridspec.\n     "}, {"start_line": 100000, "end_line": 102000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "or = mpl._val_or_rc(edgecolor, 'figure.edgecolor')\n        frameon = mpl._val_or_rc(frameon, 'figure.frameon')\n\n        figsize = _parse_figsize(figsize, dpi)\n\n        if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():\n            raise ValueError('figure size must be positive finite not '\n                             f'{figsize}')\n        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n\n        self.dpi_scale_trans = Affine2D().scale(dpi)\n        # do not use property as it will trigger\n        self._dpi = dpi\n        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n        self.figbbox = self.bbox\n        self.transFigure = BboxTransformTo(self.bbox)\n        self.transSubfigure = self.transFigure\n\n        self.patch = Rectangle(\n            xy=(0, 0), width=1, height=1, visible=frameon,\n            facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n            # Don't let the figure patch influence bbox calculation.\n            in_layout=False)\n        self._set_artist_props(self.patch)\n        self.patch.set_antialiased(False)\n\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n\n        self._axstack = _AxesStack()  # track all figure Axes and current Axes\n        self.clear()\n\n    def pick(self, mouseevent):\n        if not self.canvas.widgetlock.locked():\n            super().pick(mouseevent)\n\n    def _check_layout_engines_compat(self, old, new):\n        \"\"\"\n        Helper for set_layout engine\n\n        If the figure has used the old engine and added a colorbar then the\n        value of colorbar_gridspec must be the same on the new engine.\n        \"\"\"\n        if old is None or new is None:\n            return True\n        if old.colorbar_gridspec == new.colorbar_gridspec:\n            return True\n        # colorbar layout different, so check if any colorbars are on the\n        # figure...\n        for "}, {"start_line": 101000, "end_line": 103000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ayout=False)\n        self._set_artist_props(self.patch)\n        self.patch.set_antialiased(False)\n\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n\n        self._axstack = _AxesStack()  # track all figure Axes and current Axes\n        self.clear()\n\n    def pick(self, mouseevent):\n        if not self.canvas.widgetlock.locked():\n            super().pick(mouseevent)\n\n    def _check_layout_engines_compat(self, old, new):\n        \"\"\"\n        Helper for set_layout engine\n\n        If the figure has used the old engine and added a colorbar then the\n        value of colorbar_gridspec must be the same on the new engine.\n        \"\"\"\n        if old is None or new is None:\n            return True\n        if old.colorbar_gridspec == new.colorbar_gridspec:\n            return True\n        # colorbar layout different, so check if any colorbars are on the\n        # figure...\n        for ax in self.axes:\n            if hasattr(ax, '_colorbar'):\n                # colorbars list themselves as a colorbar.\n                return False\n        return True\n\n    def set_layout_engine(self, layout=None, **kwargs):\n        \"\"\"\n        Set the layout engine for this figure.\n\n        Parameters\n        ----------\n        layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}\n\n            - 'constrained' will use `~.ConstrainedLayoutEngine`\n            - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with\n              a correction that attempts to make a good layout for fixed-aspect\n              ratio Axes.\n            - 'tight' uses `~.TightLayoutEngine`\n            - 'none' removes layout engine.\n\n            If a `.LayoutEngine` instance, that instance will be used.\n\n            If `None`, the behavior is controlled by :rc:`figure.autolayout`\n            (which if `True` behaves as if 'tight' was passed) and\n            :rc:`figure.constra"}, {"start_line": 48000, "end_line": 50000, "belongs_to": {"file_name": "figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s add_{axes,subplot} which changes gca; undo that.\n            fig.sca(current_ax)\n            cax.grid(visible=False, which='both', axis='both')\n\n        if (hasattr(mappable, \"get_figure\") and\n                (mappable_host_fig := mappable.get_figure(root=True)) is not None):\n            # Warn in case of mismatch\n            if mappable_host_fig is not self._root_figure:\n                _api.warn_external(\n                        f'Adding colorbar to a different Figure '\n                        f'{repr(mappable_host_fig)} than '\n                        f'{repr(self._root_figure)} which '\n                        f'fig.colorbar is called on.')\n\n        NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar\n            'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']\n        cb = cbar.Colorbar(cax, mappable, **{\n            k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})\n        cax.get_figure(root=False).stale = True\n        return cb\n\n    def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n                        wspace=None, hspace=None):\n        \"\"\"\n        Adjust the subplot layout parameters.\n\n        Unset parameters are left unmodified; initial values are given by\n        :rc:`figure.subplot.[name]`.\n\n        .. plot:: _embedded_plots/figure_subplots_adjust.py\n\n        Parameters\n        ----------\n        left : float, optional\n            The position of the left edge of the subplots,\n            as a fraction of the figure width.\n        right : float, optional\n            The position of the right edge of the subplots,\n            as a fraction of the figure width.\n        bottom : float, optional\n            The position of the bottom edge of the subplots,\n            as a fraction of the figure height.\n        top : float, optional\n            The position of the top edge of the subplots,\n            as a fraction of the figure height.\n        wspace : float, optional\n            The width o"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "layout_engine.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nClasses to layout elements in a `.Figure`.\n\nFigures have a ``layout_engine`` property that holds a subclass of\n`~.LayoutEngine` defined here (or *None* for no layout).  At draw time\n``figure.get_layout_engine().execute()`` is called, the goal of which is\nusually to rearrange Axes on the figure to produce a pleasing layout. This is\nlike a ``draw`` callback but with two differences.  First, when printing we\ndisable the layout engine for the final draw. Second, it is useful to know the\nlayout engine while the figure is being created.  In particular, colorbars are\nmade differently with different layout engines (for historical reasons).\n\nMatplotlib has two built-in layout engines:\n\n- `.TightLayoutEngine` was the first layout engine added to Matplotlib.\n  See also :ref:`tight_layout_guide`.\n- `.ConstrainedLayoutEngine` is more modern and generally gives better results.\n  See also :ref:`constrainedlayout_guide`.\n\nThird parties can create their own layout engine by subclassing `.LayoutEngine`.\n\"\"\"\n\nfrom contextlib import nullcontext\n\nimport matplotlib as mpl\n\nfrom matplotlib._constrained_layout import do_constrained_layout\nfrom matplotlib._tight_layout import (get_subplotspec_list,\n                                      get_tight_layout_figure)\n\n\nclass LayoutEngine:\n    \"\"\"\n    Base class for Matplotlib layout engines.\n\n    A layout engine can be passed to a figure at instantiation or at any time\n    with `~.figure.Figure.set_layout_engine`.  Once attached to a figure, the\n    layout engine ``execute`` function is called at draw time by\n    `~.figure.Figure.draw`, providing a special draw-time hook.\n\n    .. note::\n\n       However, note that layout engines affect the creation of colorbars, so\n       `~.figure.Figure.set_layout_engine` should be called before any\n       colorbars are created.\n\n    Currently, there are two properties of `LayoutEngine` classes that are\n    consulted while manipulating the figure:\n\n    - ``engine.colorbar_gridspec`` tells `.Figure.colorbar` w"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "layout_engine.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le `.LayoutEngine` cannot be set later.\n\n    Parameters\n    ----------\n    adjust_compatible, colorbar_gridspec : bool\n        Allow the PlaceHolderLayoutEngine to mirror the behavior of whatever\n        layout engine it is replacing.\n\n    \"\"\"\n    def __init__(self, adjust_compatible, colorbar_gridspec, **kwargs):\n        self._adjust_compatible = adjust_compatible\n        self._colorbar_gridspec = colorbar_gridspec\n        super().__init__(**kwargs)\n\n    def execute(self, fig):\n        \"\"\"\n        Do nothing.\n        \"\"\"\n        return\n\n\nclass TightLayoutEngine(LayoutEngine):\n    \"\"\"\n    Implements the ``tight_layout`` geometry management.  See\n    :ref:`tight_layout_guide` for details.\n    \"\"\"\n    _adjust_compatible = True\n    _colorbar_gridspec = True\n\n    def __init__(self, *, pad=1.08, h_pad=None, w_pad=None,\n                 rect=(0, 0, 1, 1), **kwargs):\n        \"\"\"\n        Initialize tight_layout engine.\n\n        Parameters\n        ----------\n        pad : float, default: 1.08\n            Padding between the figure edge and the edges of subplots, as a\n            fraction of the font size.\n        h_pad, w_pad : float\n            Padding (height/width) between edges of adjacent subplots.\n            Defaults to *pad*.\n        rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1).\n            rectangle in normalized figure coordinates that the subplots\n            (including labels) will fit into.\n        \"\"\"\n        super().__init__(**kwargs)\n        for td in ['pad', 'h_pad', 'w_pad', 'rect']:\n            # initialize these in case None is passed in above:\n            self._params[td] = None\n        self.set(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n\n    def execute(self, fig):\n        \"\"\"\n        Execute tight_layout.\n\n        This decides the subplot parameters given the padding that\n        will allow the Axes labels to not be covered by other labels\n        and Axes.\n\n        Parameters\n        ----------\n        fig : `.Figure` to perform l"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "test_figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lt.subplots(layout=\"tight\")\n    pc = ax.pcolormesh(np.random.randn(2, 2))\n    fig.colorbar(pc)\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"constrained\")\n    fig.set_layout_engine(\"none\")\n    assert isinstance(fig.get_layout_engine(), PlaceHolderLayoutEngine)\n\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"constrained\")\n\n\n@check_figures_equal()\ndef test_tightlayout_autolayout_deconflict(fig_test, fig_ref):\n    for fig, autolayout in zip([fig_ref, fig_test], [False, True]):\n        with mpl.rc_context({'figure.autolayout': autolayout}):\n            axes = fig.subplots(ncols=2)\n            fig.tight_layout(w_pad=10)\n        assert isinstance(fig.get_layout_engine(), PlaceHolderLayoutEngine)\n\n\n@pytest.mark.parametrize('layout', ['constrained', 'compressed'])\ndef test_layout_change_warning(layout):\n    \"\"\"\n    Raise a warning when a previously assigned layout changes to tight using\n    plt.tight_layout().\n    \"\"\"\n    fig, ax = plt.subplots(layout=layout)\n    with pytest.warns(UserWarning, match='The figure layout has changed to'):\n        plt.tight_layout()\n\n\ndef test_repeated_tightlayout():\n    fig = Figure()\n    fig.tight_layout()\n    # subsequent calls should not warn\n    fig.tight_layout()\n    fig.tight_layout()\n\n\n@check_figures_equal(extensions=[\"png\", \"pdf\"])\ndef test_add_artist(fig_test, fig_ref):\n    fig_test.dpi = 100\n    fig_ref.dpi = 100\n\n    fig_test.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], gid='l1')\n    l2 = plt.Line2D([.2, .7], [.8, .8], gid='l2')\n    r1 = plt.Circle((20, 20), 100, transform=None, gid='C1')\n    r2 = plt.Circle((.7, .5), .05, gid='C2')\n    r3 = plt.Circle((4.5, .8), .55, transform=fig_test.dpi_scale_trans,\n                    facecolor='crimson', gid='C3')\n    for a in [l1, l2, r1, r2, r3]:\n        fig_test.add_artist(a)\n    l2.remove()\n\n    ax2 = fig_ref.subplots()\n    l1 = plt.Line2D([.2, .7], [.7, .7], tra"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "test_figure.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.get_tight_layout()\n    assert not fig.get_constrained_layout()\n\n    fig = Figure(layout='constrained')\n    assert not fig.get_tight_layout()\n    assert fig.get_constrained_layout()\n\n\ndef test_invalid_layouts():\n    fig, ax = plt.subplots(layout=\"constrained\")\n    with pytest.warns(UserWarning):\n        # this should warn,\n        fig.subplots_adjust(top=0.8)\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    # Using layout + (tight|constrained)_layout warns, but the former takes\n    # precedence.\n    wst = \"The Figure parameters 'layout' and 'tight_layout'\"\n    with pytest.warns(UserWarning, match=wst):\n        fig = Figure(layout='tight', tight_layout=False)\n    assert isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    wst = \"The Figure parameters 'layout' and 'constrained_layout'\"\n    with pytest.warns(UserWarning, match=wst):\n        fig = Figure(layout='constrained', constrained_layout=False)\n    assert not isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    with pytest.raises(ValueError,\n                       match=\"Invalid value for 'layout'\"):\n        Figure(layout='foobar')\n\n    # test that layouts can be swapped if no colorbar:\n    fig, ax = plt.subplots(layout=\"constrained\")\n    fig.set_layout_engine(\"tight\")\n    assert isinstance(fig.get_layout_engine(), TightLayoutEngine)\n    fig.set_layout_engine(\"constrained\")\n    assert isinstance(fig.get_layout_engine(), ConstrainedLayoutEngine)\n\n    # test that layouts cannot be swapped if there is a colorbar:\n    fig, ax = plt.subplots(layout=\"constrained\")\n    pc = ax.pcolormesh(np.random.randn(2, 2))\n    fig.colorbar(pc)\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"tight\")\n    fig.set_layout_engine(\"none\")\n    with pytest.raises(RuntimeError, match='Colorbar layout of new layout'):\n        fig.set_layout_engine(\"tight\")\n\n    fig, ax = p"}], "retrieved_count": 10, "cost_time": 3.459707021713257}
{"question": "What dependencies does the _Edge_integer class's __init__ method establish with the Locator hierarchy to ensure tick calculation consistency across different axis scaling scenarios?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n an axis' edge* (this typically occurs when\n            :rc:`axes.autolimit_mode` is 'round_numbers').  Removing such ticks\n            is mostly useful for stacked or ganged plots, where the upper tick\n            of an Axes overlaps with the lower tick of the axes above it.\n\n        min_n_ticks : int, default: 2\n            Relax *nbins* and *integer* constraints if necessary to obtain\n            this minimum number of ticks.\n        \"\"\"\n        if nbins is not None:\n            kwargs['nbins'] = nbins\n        self.set_params(**{**self.default_params, **kwargs})\n\n    @staticmethod\n    def _validate_steps(steps):\n        if not np.iterable(steps):\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        steps = np.asarray(steps)\n        if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        if steps[0] != 1:\n            steps = np.concatenate([[1], steps])\n        if steps[-1] != 10:\n            steps = np.concatenate([steps, [10]])\n        return steps\n\n    @staticmethod\n    def _staircase(steps):\n        # Make an extended staircase within which the needed step will be\n        # found.  This is probably much larger than necessary.\n        return np.concatenate([0.1 * steps[:-1], steps, [10 * steps[1]]])\n\n    def set_params(self, **kwargs):\n        \"\"\"\n        Set parameters for this locator.\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            see `.MaxNLocator`\n        steps : array-like, optional\n            see `.MaxNLocator`\n        integer : bool, optional\n            see `.MaxNLocator`\n        symmetric : bool, optional\n            see `.MaxNLocator`\n        prune : {'lower', 'upper', 'both', None}, optional\n            see `.MaxNLocator`\n        min_n_tick"}, {"start_line": 69000, "end_line": 71000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     base : float > 0, optional\n            Interval between ticks.\n        offset : float, optional\n            Value added to each multiple of *base*.\n\n            .. versionadded:: 3.8\n        \"\"\"\n        if base is not None:\n            self._edge = _Edge_integer(base, 0)\n        if offset is not None:\n            self._offset = offset\n\n    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        step = self._edge.step\n        vmin -= self._offset\n        vmax -= self._offset\n        vmin = self._edge.ge(vmin) * step\n        n = (vmax - vmin + 0.001 * step) // step\n        locs = vmin - step + np.arange(n + 3) * step + self._offset\n        return self.raise_if_exceeds(locs)\n\n    def view_limits(self, dmin, dmax):\n        \"\"\"\n        Set the view limits to the nearest tick values that contain the data.\n        \"\"\"\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = self._edge.le(dmin - self._offset) * self._edge.step + self._offset\n            vmax = self._edge.ge(dmax - self._offset) * self._edge.step + self._offset\n            if vmin == vmax:\n                vmin -= 1\n                vmax += 1\n        else:\n            vmin = dmin\n            vmax = dmax\n\n        return mtransforms.nonsingular(vmin, vmax)\n\n\ndef scale_range(vmin, vmax, n=1, threshold=100):\n    dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.\n    meanv = (vmax + vmin) / 2\n    if abs(meanv) / dv < threshold:\n        offset = 0\n    else:\n        offset = math.copysign(10 ** (math.log10(abs(meanv)) // 1), meanv)\n    scale = 10 ** (math.log10(dv / n) // 1)\n    return scale, offset\n\n\nclass _Edge_integer:\n    \"\"\"\n    Helper for `.MaxNLocator`, `.MultipleLocator`, etc.\n\n    Take floating-point precision limitations into account when calculating\n"}, {"start_line": 71000, "end_line": 73000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    tick locations as integer multiples of a step.\n    \"\"\"\n\n    def __init__(self, step, offset):\n        \"\"\"\n        Parameters\n        ----------\n        step : float > 0\n            Interval between ticks.\n        offset : float\n            Offset subtracted from the data limits prior to calculating tick\n            locations.\n        \"\"\"\n        if step <= 0:\n            raise ValueError(\"'step' must be positive\")\n        self.step = step\n        self._offset = abs(offset)\n\n    def closeto(self, ms, edge):\n        # Allow more slop when the offset is large compared to the step.\n        if self._offset > 0:\n            digits = np.log10(self._offset / self.step)\n            tol = max(1e-10, 10 ** (digits - 12))\n            tol = min(0.4999, tol)\n        else:\n            tol = 1e-10\n        return abs(ms - edge) < tol\n\n    def le(self, x):\n        \"\"\"Return the largest n: n*step <= x.\"\"\"\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 1):\n            return d + 1\n        return d\n\n    def ge(self, x):\n        \"\"\"Return the smallest n: n*step >= x.\"\"\"\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 0):\n            return d\n        return d + 1\n\n\nclass MaxNLocator(Locator):\n    \"\"\"\n    Place evenly spaced ticks, with a cap on the total number of ticks.\n\n    Finds nice tick locations with no more than :math:`nbins + 1` ticks being within the\n    view limits. Locations beyond the limits are added to support autoscaling.\n    \"\"\"\n    default_params = dict(nbins=10,\n                          steps=None,\n                          integer=False,\n                          symmetric=False,\n                          prune=None,\n                          min_n_ticks=2)\n\n    def __init__(self, nbins=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        nbins : int or 'auto', default: 10\n            Maximum number of intervals; one less than max number of\n            ticks.  If the string 'auto', the num"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "el ticks only at integer powers of base.\n        This is normally True for major ticks and False for minor ticks.\n\n    minor_thresholds : (subset, all), default: (1, 0.4)\n        If labelOnlyBase is False, these two numbers control\n        the labeling of ticks that are not at integer powers of\n        base; normally these are the minor ticks.\n\n        The first number (*subset*) is the largest number of major ticks for\n        which minor ticks are labeled; e.g., the default, 1, means that minor\n        ticks are labeled as long as there is no more than 1 major tick.  (It\n        is assumed that major ticks are at integer powers of *base*.)\n\n        The second number (*all*) is a threshold, in log-units of the axis\n        limit range, over which only a subset of the minor ticks are labeled,\n        so as to avoid crowding; e.g., with the default value (0.4) and the\n        usual ``base=10``, all minor ticks are shown only if the axis limit\n        range spans less than 0.4 decades.\n\n    linthresh : None or float, default: None\n        If a symmetric log scale is in use, its ``linthresh``\n        parameter must be supplied here.\n\n    Notes\n    -----\n    The `set_locs` method must be called to enable the subsetting\n    logic controlled by the ``minor_thresholds`` parameter.\n\n    In some cases such as the colorbar, there is no distinction between\n    major and minor ticks; the tick locations might be set manually,\n    or by a locator that puts ticks at integer powers of base and\n    at intermediate locations.  For this situation, disable the\n    minor_thresholds logic by using ``minor_thresholds=(np.inf, np.inf)``,\n    so that all ticks will be labeled.\n\n    To disable labeling of minor ticks when 'labelOnlyBase' is False,\n    use ``minor_thresholds=(0, 0)``.  This is the default for the\n    \"classic\" style.\n\n    Examples\n    --------\n    To label a subset of minor ticks when there are up to 2 major ticks,\n    and all of the ticks when zoomed in to 0.5 decades or les"}, {"start_line": 67000, "end_line": 69000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tor.\"\"\"\n        if presets is not None:\n            self.presets = presets\n        if numticks is not None:\n            self.numticks = numticks\n\n    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n\n        if (vmin, vmax) in self.presets:\n            return self.presets[(vmin, vmax)]\n\n        if self.numticks == 0:\n            return []\n        ticklocs = np.linspace(vmin, vmax, self.numticks)\n\n        return self.raise_if_exceeds(ticklocs)\n\n    def view_limits(self, vmin, vmax):\n        \"\"\"Try to choose the view limits intelligently.\"\"\"\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if vmin == vmax:\n            vmin -= 1\n            vmax += 1\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            exponent, remainder = divmod(\n                math.log10(vmax - vmin), math.log10(max(self.numticks - 1, 1)))\n            exponent -= (remainder < .5)\n            scale = max(self.numticks - 1, 1) ** (-exponent)\n            vmin = math.floor(scale * vmin) / scale\n            vmax = math.ceil(scale * vmax) / scale\n\n        return mtransforms.nonsingular(vmin, vmax)\n\n\nclass MultipleLocator(Locator):\n    \"\"\"\n    Place ticks at every integer multiple of a base plus an offset.\n    \"\"\"\n\n    def __init__(self, base=1.0, offset=0.0):\n        \"\"\"\n        Parameters\n        ----------\n        base : float > 0, default: 1.0\n            Interval between ticks.\n        offset : float, default: 0.0\n            Value added to each multiple of *base*.\n\n            .. versionadded:: 3.8\n        \"\"\"\n        self._edge = _Edge_integer(base, 0)\n        self._offset = offset\n\n    def set_params(self, base=None, offset=None):\n        \"\"\"\n        Set parameters within this locator.\n\n        Parameters\n        ----------\n   "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ic(self, vmin, vmax, expected):\n        loc = mticker.MaxNLocator(nbins=5)\n        assert_almost_equal(loc.tick_values(vmin, vmax), expected)\n\n    @pytest.mark.parametrize('vmin, vmax, steps, expected', integer_data)\n    def test_integer(self, vmin, vmax, steps, expected):\n        loc = mticker.MaxNLocator(nbins=5, integer=True, steps=steps)\n        assert_almost_equal(loc.tick_values(vmin, vmax), expected)\n\n    @pytest.mark.parametrize('kwargs, errortype, match', [\n        ({'foo': 0}, TypeError,\n         re.escape(\"set_params() got an unexpected keyword argument 'foo'\")),\n        ({'steps': [2, 1]}, ValueError, \"steps argument must be an increasing\"),\n        ({'steps': 2}, ValueError, \"steps argument must be an increasing\"),\n        ({'steps': [2, 11]}, ValueError, \"steps argument must be an increasing\"),\n    ])\n    def test_errors(self, kwargs, errortype, match):\n        with pytest.raises(errortype, match=match):\n            mticker.MaxNLocator(**kwargs)\n\n    @pytest.mark.parametrize('steps, result', [\n        ([1, 2, 10], [1, 2, 10]),\n        ([2, 10], [1, 2, 10]),\n        ([1, 2], [1, 2, 10]),\n        ([2], [1, 2, 10]),\n    ])\n    def test_padding(self, steps, result):\n        loc = mticker.MaxNLocator(steps=steps)\n        assert (loc._steps == result).all()\n\n\nclass TestLinearLocator:\n    def test_basic(self):\n        loc = mticker.LinearLocator(numticks=3)\n        test_value = np.array([-0.8, -0.3, 0.2])\n        assert_almost_equal(loc.tick_values(-0.8, 0.2), test_value)\n\n    def test_zero_numticks(self):\n        loc = mticker.LinearLocator(numticks=0)\n        loc.tick_values(-0.8, 0.2) == []\n\n    def test_set_params(self):\n        \"\"\"\n        Create linear locator with presets={}, numticks=2 and change it to\n        something else. See if change was successful. Should not exception.\n        \"\"\"\n        loc = mticker.LinearLocator(numticks=2)\n        loc.set_params(numticks=8, presets={(0, 1): []})\n        assert loc.numticks == 8\n        assert loc.presets "}, {"start_line": 79000, "end_line": 81000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " the raw step, and check\n        # if it provides enough ticks. If not, work backwards through\n        # smaller steps until one is found that provides enough ticks.\n        for step in steps[:istep+1][::-1]:\n\n            if (self._integer and\n                    np.floor(_vmax) - np.ceil(_vmin) >= self._min_n_ticks - 1):\n                step = max(1, step)\n            best_vmin = (_vmin // step) * step\n\n            # Find tick locations spanning the vmin-vmax range, taking into\n            # account degradation of precision when there is a large offset.\n            # The edge ticks beyond vmin and/or vmax are needed for the\n            # \"round_numbers\" autolimit mode.\n            edge = _Edge_integer(step, offset)\n            low = edge.le(_vmin - best_vmin)\n            high = edge.ge(_vmax - best_vmin)\n            ticks = np.arange(low, high + 1) * step + best_vmin\n            # Count only the ticks that will be displayed.\n            nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()\n            if nticks >= self._min_n_ticks:\n                break\n        return ticks + offset\n\n    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        if self._symmetric:\n            vmax = max(abs(vmin), abs(vmax))\n            vmin = -vmax\n        vmin, vmax = mtransforms.nonsingular(\n            vmin, vmax, expander=1e-13, tiny=1e-14)\n        locs = self._raw_ticks(vmin, vmax)\n\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return self.raise_if_exceeds(locs)\n\n    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            dmax = max(abs(dmin), abs(dmax))\n            dmin = -dmax\n\n        dmin, dmax = mtransforms.nonsingular(\n            dmin, dmax, expander=1e-12, tiny=1e-13)\n\n        if mp"}, {"start_line": 68000, "end_line": 70000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "der = divmod(\n                math.log10(vmax - vmin), math.log10(max(self.numticks - 1, 1)))\n            exponent -= (remainder < .5)\n            scale = max(self.numticks - 1, 1) ** (-exponent)\n            vmin = math.floor(scale * vmin) / scale\n            vmax = math.ceil(scale * vmax) / scale\n\n        return mtransforms.nonsingular(vmin, vmax)\n\n\nclass MultipleLocator(Locator):\n    \"\"\"\n    Place ticks at every integer multiple of a base plus an offset.\n    \"\"\"\n\n    def __init__(self, base=1.0, offset=0.0):\n        \"\"\"\n        Parameters\n        ----------\n        base : float > 0, default: 1.0\n            Interval between ticks.\n        offset : float, default: 0.0\n            Value added to each multiple of *base*.\n\n            .. versionadded:: 3.8\n        \"\"\"\n        self._edge = _Edge_integer(base, 0)\n        self._offset = offset\n\n    def set_params(self, base=None, offset=None):\n        \"\"\"\n        Set parameters within this locator.\n\n        Parameters\n        ----------\n        base : float > 0, optional\n            Interval between ticks.\n        offset : float, optional\n            Value added to each multiple of *base*.\n\n            .. versionadded:: 3.8\n        \"\"\"\n        if base is not None:\n            self._edge = _Edge_integer(base, 0)\n        if offset is not None:\n            self._offset = offset\n\n    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        step = self._edge.step\n        vmin -= self._offset\n        vmax -= self._offset\n        vmin = self._edge.ge(vmin) * step\n        n = (vmax - vmin + 0.001 * step) // step\n        locs = vmin - step + np.arange(n + 3) * step + self._offset\n        return self.raise_if_exceeds(locs)\n\n    def view_limits(self, dmin, dmax):\n        \"\"\"\n        Set the view limits to the nearest tic"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      gridOn = False\n\n        self.set_figure(axes.get_figure(root=False))\n        self.axes = axes\n\n        self._loc = loc\n        self._major = major\n\n        name = self.__name__\n        major_minor = \"major\" if major else \"minor\"\n        self._size = mpl._val_or_rc(size, f\"{name}.{major_minor}.size\")\n        self._width = mpl._val_or_rc(width, f\"{name}.{major_minor}.width\")\n        self._base_pad = mpl._val_or_rc(pad, f\"{name}.{major_minor}.pad\")\n        color = mpl._val_or_rc(color, f\"{name}.color\")\n        labelcolor = mpl._val_or_rc(labelcolor, f\"{name}.labelcolor\")\n        if cbook._str_equal(labelcolor, 'inherit'):\n            # inherit from tick color\n            labelcolor = mpl.rcParams[f\"{name}.color\"]\n        labelsize = mpl._val_or_rc(labelsize, f\"{name}.labelsize\")\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        grid_color = mpl._val_or_rc(\n            grid_color,\n            f\"grid.{major_minor}.color\",\n            \"grid.color\",\n        )\n        grid_linestyle = mpl._val_or_rc(\n            grid_linestyle,\n            f\"grid.{major_minor}.linestyle\",\n            \"grid.linestyle\",\n        )\n        grid_linewidth = mpl._val_or_rc(\n            grid_linewidth,\n            f\"grid.{major_minor}.linewidth\",\n            \"grid.linewidth\",\n        )\n        if grid_alpha is None and not mcolors._has_alpha_channel(grid_color):\n            # alpha precedence: kwarg > color alpha > rcParams['grid.alpha']\n            # Note: only resolve to rcParams if the color does not have alpha\n            # otherwise `grid(color=(1, 1, 1, 0.5))` would work like\n            #   grid(color=(1, 1, 1, 0.5), alpha=rcParams['grid.alpha'])\n            # so the that the rcParams default would override color alpha.\n            grid_alpha = mpl._val_or_rc(\n                # grid_a"}, {"start_line": 80000, "end_line": 82000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "um()\n            if nticks >= self._min_n_ticks:\n                break\n        return ticks + offset\n\n    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        if self._symmetric:\n            vmax = max(abs(vmin), abs(vmax))\n            vmin = -vmax\n        vmin, vmax = mtransforms.nonsingular(\n            vmin, vmax, expander=1e-13, tiny=1e-14)\n        locs = self._raw_ticks(vmin, vmax)\n\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return self.raise_if_exceeds(locs)\n\n    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            dmax = max(abs(dmin), abs(dmax))\n            dmin = -dmax\n\n        dmin, dmax = mtransforms.nonsingular(\n            dmin, dmax, expander=1e-12, tiny=1e-13)\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            return self._raw_ticks(dmin, dmax)[[0, -1]]\n        else:\n            return dmin, dmax\n\n\ndef _is_decade(x, *, base=10, rtol=None):\n    \"\"\"Return True if *x* is an integer power of *base*.\"\"\"\n    if not np.isfinite(x):\n        return False\n    if x == 0.0:\n        return True\n    lx = np.log(abs(x)) / np.log(base)\n    if rtol is None:\n        return np.isclose(lx, np.round(lx))\n    else:\n        return np.isclose(lx, np.round(lx), rtol=rtol)\n\n\ndef _decade_less_equal(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less or equal to *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_greater_equal(-x, base) if x < 0 else\n            base ** np.floor(np.log(x) / np.log(base)))\n\n\ndef _decade_greater_equal(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater or equal to *x*.\n\n    If *x* is negative, the expon"}], "retrieved_count": 10, "cost_time": 3.5128142833709717}
{"question": "What is the separation of concerns maintained by the ToolbarGTK4 class between UI state management and event handling through its set_message method within the broader GTK4 backend architecture?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    except Exception as e:\n                msg = Gtk.MessageDialog(\n                    transient_for=self.canvas.get_root(),\n                    message_type=Gtk.MessageType.ERROR,\n                    buttons=Gtk.ButtonsType.OK, modal=True,\n                    text=str(e))\n                msg.show()\n\n        dialog.show()\n        return self.UNKNOWN_SAVED_STATUS\n\n\nclass ToolbarGTK4(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self._tool_box.append(sep)\n\n    def set_message(self, s):\n        self._message.set_label(s)\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK4)\nclass SaveFigureGTK4(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classi"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n"}, {"start_line": 128000, "end_line": 130000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        toggle : bool\n            * `True` : The button is a toggle (change the pressed/unpressed\n              state between consecutive clicks).\n            * `False` : The button is a normal button (returns to unpressed\n              state after release).\n        \"\"\"\n        raise NotImplementedError\n\n    def toggle_toolitem(self, name, toggled):\n        \"\"\"\n        A hook to toggle a toolitem without firing an event.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to silently toggle a toolbar element.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolManager.trigger_tool` or `.ToolContainerBase.trigger_tool`\n            (which are equivalent).\n\n        Parameters\n        ----------\n        name : str\n            Id of the tool to toggle.\n        toggled : bool\n            Whether to set this tool as toggled or not.\n        \"\"\"\n        raise NotImplementedError\n\n    def remove_toolitem(self, name):\n        \"\"\"\n        A hook to remove a toolitem from the container.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to remove an element from the toolbar; it is\n        called when `.ToolManager` emits a ``tool_removed_event``.\n\n        Because some tools are present only on the `.ToolManager` but not on\n        the `ToolContainerBase`, this method must be a no-op when called on a tool\n        absent from the container.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolManager.remove_tool`.\n\n        Parameters\n        ----------\n        name : str\n            Name of the tool to remove.\n        \"\"\"\n        raise NotImplementedError\n\n    def set_message(self, s):\n        \"\"\"\n        Display a message on the toolbar.\n\n      "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self._tool_box.append(sep)\n\n    def set_message(self, s):\n        self._message.set_label(s)\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK4)\nclass SaveFigureGTK4(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK4)\nclass HelpGTK4(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK4._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK4._get_key`).\n    "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "_backend_gtk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          self.window.unfullscreen()\n        else:\n            self.window.fullscreen()\n\n    def get_window_title(self):\n        return self.window.get_title()\n\n    def set_window_title(self, title):\n        self.window.set_title(title)\n\n    def resize(self, width, height):\n        width = int(width / self.canvas.device_pixel_ratio)\n        height = int(height / self.canvas.device_pixel_ratio)\n        if self.toolbar:\n            min_size, nat_size = self.toolbar.get_preferred_size()\n            height += nat_size.height\n        canvas_size = self.canvas.get_allocation()\n        if self._gtk_ver >= 4 or canvas_size.width == canvas_size.height == 1:\n            # A canvas size of (1, 1) cannot exist in most cases, because\n            # window decorations would prevent such a small window. This call\n            # must be before the window has been mapped and widgets have been\n            # sized, so just change the window's starting size.\n            self.window.set_default_size(width, height)\n        else:\n            self.window.resize(width, height)\n\n\nclass _NavigationToolbar2GTK(NavigationToolbar2):\n    # Must be implemented in GTK3/GTK4 backends:\n    # * __init__\n    # * save_figure\n\n    def set_message(self, s):\n        escaped = GLib.markup_escape_text(s)\n        self.message.set_markup(f'<small>{escaped}</small>')\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas._draw_rubberband(rect)\n\n    def remove_rubberband(self):\n        self.canvas._draw_rubberband(None)\n\n    def _update_buttons_checked(self):\n        for name, active in [(\"Pan\", \"PAN\"), (\"Zoom\", \"ZOOM\")]:\n            button = self._gtk_ids.get(name)\n            if button:\n                with button.handler_block(button._signal_handler):\n                    button.set_active(self.mode.name == active)\n\n    def pan(self,"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(lw)\n        ctx.set_dash((dash, dash), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((dash, dash), dash)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK4Agg or GTK4Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)\n\n\nclass NavigationToolbar2GTK4(_NavigationToolbar2GTK, Gtk.Box):\n    def __init__(self, canvas):\n        Gtk.Box.__init__(self)\n\n        self.add_css_class('toolbar')\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.append(Gtk.Separator())\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))))\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleButton() if callback in ['zoom', 'pan'] else\n                Gtk.Button())\n            button.set_child(image)\n            button.add_css_class('flat')\n            button.add_css_class('image-button')\n            # Save the handler id, so that we can block it as needed.\n       "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "_backend_gtk.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eight)\n        else:\n            self.window.resize(width, height)\n\n\nclass _NavigationToolbar2GTK(NavigationToolbar2):\n    # Must be implemented in GTK3/GTK4 backends:\n    # * __init__\n    # * save_figure\n\n    def set_message(self, s):\n        escaped = GLib.markup_escape_text(s)\n        self.message.set_markup(f'<small>{escaped}</small>')\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas._draw_rubberband(rect)\n\n    def remove_rubberband(self):\n        self.canvas._draw_rubberband(None)\n\n    def _update_buttons_checked(self):\n        for name, active in [(\"Pan\", \"PAN\"), (\"Zoom\", \"ZOOM\")]:\n            button = self._gtk_ids.get(name)\n            if button:\n                with button.handler_block(button._signal_handler):\n                    button.set_active(self.mode.name == active)\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack) - 1\n        if 'Back' in self._gtk_ids:\n            self._gtk_ids['Back'].set_sensitive(can_backward)\n        if 'Forward' in self._gtk_ids:\n            self._gtk_ids['Forward'].set_sensitive(can_forward)\n\n\nclass RubberbandGTK(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        _NavigationToolbar2GTK.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        _NavigationToolbar2GTK.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())\n\n\nclass ConfigureSubplotsGTK(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        _Navig"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.pack_start(sep, False, True, 0)\n        sep.show_all()\n\n    def set_message(self, s):\n        self._message.set_label(s)\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK3)\nclass SaveFigureGTK3(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK3.save_figure(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK3)\nclass HelpGTK3(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK3._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod "}], "retrieved_count": 10, "cost_time": 3.544264554977417}
{"question": "What is the effect of the conditional branching in AutoLocator's __init__ method based on the '_internal.classic_mode' rcParam on the tick placement algorithm's behavior when transitioning between classic and modern matplotlib rendering modes, and what are the implications for backward compatibility when the steps parameter changes from [1, 2, 5, 10] to [1, 2, 2.5, 5, 10]?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 108000, "end_line": 110000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "            # updated with data, so for now we use 1 - minpos as a substitute.\n            if vmax >= 1:\n                vmax = 1 - minpos\n            if vmin == vmax:\n                vmin, vmax = 0.1 * vmin, 1 - 0.1 * vmin\n\n        return vmin, vmax\n\n\nclass AutoLocator(MaxNLocator):\n    \"\"\"\n    Place evenly spaced ticks, with the step size and maximum number of ticks chosen\n    automatically.\n\n    This is a subclass of `~matplotlib.ticker.MaxNLocator`, with parameters\n    *nbins = 'auto'* and *steps = [1, 2, 2.5, 5, 10]*.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        To know the values of the non-public parameters, please have a\n        look to the defaults of `~matplotlib.ticker.MaxNLocator`.\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            nbins = 9\n            steps = [1, 2, 5, 10]\n        else:\n            nbins = 'auto'\n            steps = [1, 2, 2.5, 5, 10]\n        super().__init__(nbins=nbins, steps=steps)\n\n\nclass AutoMinorLocator(Locator):\n    \"\"\"\n    Place evenly spaced minor ticks, with the step size and maximum number of ticks\n    chosen automatically.\n\n    The Axis must use a linear scale and have evenly spaced major ticks.\n    \"\"\"\n\n    def __init__(self, n=None):\n        \"\"\"\n        Parameters\n        ----------\n        n : int or 'auto', default: :rc:`xtick.minor.ndivs` or :rc:`ytick.minor.ndivs`\n            The number of subdivisions of the interval between major ticks;\n            e.g., n=2 will place a single minor tick midway between major ticks.\n\n            If *n* is 'auto', it will be set to 4 or 5: if the distance\n            between the major ticks equals 1, 2.5, 5 or 10 it can be perfectly\n            divided in 5 equidistant sub-intervals with a length multiple of\n            0.05; otherwise, it is divided in 4 sub-intervals.\n        \"\"\"\n        self.ndivs = n\n\n    def __call__(self):\n        # docstring inherited\n        if self.axis.get_scale() == 'log':\n            _api.warn_external('AutoMinorLocator does"}, {"start_line": 107000, "end_line": 109000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       vmin, vmax = initial_range  # Initial range, no data plotted yet.\n        elif vmax <= 0 or vmin >= 1:\n            # vmax <= 0 occurs when all values are negative\n            # vmin >= 1 occurs when all values are greater than one\n            _api.warn_external(\n                \"Data has no values between 0 and 1, and therefore cannot be \"\n                \"logit-scaled.\"\n            )\n            vmin, vmax = initial_range\n        else:\n            minpos = (\n                self.axis.get_minpos()\n                if self.axis is not None\n                else standard_minpos\n            )\n            if not np.isfinite(minpos):\n                minpos = standard_minpos  # This should never take effect.\n            if vmin <= 0:\n                vmin = minpos\n            # NOTE: for vmax, we should query a property similar to get_minpos,\n            # but related to the maximal, less-than-one data point.\n            # Unfortunately, Bbox._minpos is defined very deep in the BBox and\n            # updated with data, so for now we use 1 - minpos as a substitute.\n            if vmax >= 1:\n                vmax = 1 - minpos\n            if vmin == vmax:\n                vmin, vmax = 0.1 * vmin, 1 - 0.1 * vmin\n\n        return vmin, vmax\n\n\nclass AutoLocator(MaxNLocator):\n    \"\"\"\n    Place evenly spaced ticks, with the step size and maximum number of ticks chosen\n    automatically.\n\n    This is a subclass of `~matplotlib.ticker.MaxNLocator`, with parameters\n    *nbins = 'auto'* and *steps = [1, 2, 2.5, 5, 10]*.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        To know the values of the non-public parameters, please have a\n        look to the defaults of `~matplotlib.ticker.MaxNLocator`.\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            nbins = 9\n            steps = [1, 2, 5, 10]\n        else:\n            nbins = 'auto'\n            steps = [1, 2, 2.5, 5, 10]\n        super().__init__(nbins=nbins, steps=steps)\n\n\nclass AutoMinorLocator(Locator):\n    \""}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                (2.5, 5),\n                                (5, 5),\n                                (10, 5)]\n\n    # This test is meant to verify the parameterization for\n    # test_number_of_minor_ticks\n    def test_using_all_default_major_steps(self):\n        with mpl.rc_context({'_internal.classic_mode': False}):\n            majorsteps = [x[0] for x in self.majorstep_minordivisions]\n            np.testing.assert_allclose(majorsteps,\n                                       mticker.AutoLocator()._steps)\n\n    @pytest.mark.parametrize('major_step, expected_nb_minordivisions',\n                             majorstep_minordivisions)\n    def test_number_of_minor_ticks(\n            self, major_step, expected_nb_minordivisions):\n        fig, ax = plt.subplots()\n        xlims = (0, major_step)\n        ax.set_xlim(*xlims)\n        ax.set_xticks(xlims)\n        ax.minorticks_on()\n        ax.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n        nb_minor_divisions = len(ax.xaxis.get_minorticklocs()) + 1\n        assert nb_minor_divisions == expected_nb_minordivisions\n\n    limits = [(0, 1.39), (0, 0.139),\n              (0, 0.11e-19), (0, 0.112e-12),\n              (-2.0e-07, -3.3e-08), (1.20e-06, 1.42e-06),\n              (-1.34e-06, -1.44e-06), (-8.76e-07, -1.51e-06)]\n\n    reference = [\n        [0.05, 0.1, 0.15, 0.25, 0.3, 0.35, 0.45, 0.5, 0.55, 0.65, 0.7,\n         0.75, 0.85, 0.9, 0.95, 1.05, 1.1, 1.15, 1.25, 1.3, 1.35],\n        [0.005, 0.01, 0.015, 0.025, 0.03, 0.035, 0.045, 0.05, 0.055, 0.065,\n         0.07, 0.075, 0.085, 0.09, 0.095, 0.105, 0.11, 0.115, 0.125, 0.13,\n         0.135],\n        [5.00e-22, 1.00e-21, 1.50e-21, 2.50e-21, 3.00e-21, 3.50e-21, 4.50e-21,\n         5.00e-21, 5.50e-21, 6.50e-21, 7.00e-21, 7.50e-21, 8.50e-21, 9.00e-21,\n         9.50e-21, 1.05e-20, 1.10e-20],\n        [5.00e-15, 1.00e-14, 1.50e-14, 2.50e-14, 3.00e-14, 3.50e-14, 4.50e-14,\n         5.00e-14, 5.50e-14, 6.50e-14, 7.00e-14, 7.50e-14, 8.50e-14, 9.00e-14,\n         9.50e-14, 1.05e-13, 1.10e-13],\n     "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sert_almost_equal(ax.xaxis.get_ticklocs(minor=True), test_value)\n\n        ax.set_xlim(-5, 5)\n        test_value = np.array([-5.0, -4.5, -3.5, -3.0, -2.5, -1.5, -1.0, -0.5,\n                               0.5, 1.0, 1.5, 2.5, 3.0, 3.5, 4.5, 5.0])\n        assert_almost_equal(ax.xaxis.get_ticklocs(minor=True), test_value)\n\n    @pytest.mark.parametrize('nb_majorticks, expected_nb_minorticks', params)\n    def test_low_number_of_majorticks(\n            self, nb_majorticks, expected_nb_minorticks):\n        # This test is related to issue #8804\n        fig, ax = plt.subplots()\n        xlims = (0, 5)  # easier to test the different code paths\n        ax.set_xlim(*xlims)\n        ax.set_xticks(np.linspace(xlims[0], xlims[1], nb_majorticks))\n        ax.minorticks_on()\n        ax.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n        assert len(ax.xaxis.get_minorticklocs()) == expected_nb_minorticks\n\n    majorstep_minordivisions = [(1, 5),\n                                (2, 4),\n                                (2.5, 5),\n                                (5, 5),\n                                (10, 5)]\n\n    # This test is meant to verify the parameterization for\n    # test_number_of_minor_ticks\n    def test_using_all_default_major_steps(self):\n        with mpl.rc_context({'_internal.classic_mode': False}):\n            majorsteps = [x[0] for x in self.majorstep_minordivisions]\n            np.testing.assert_allclose(majorsteps,\n                                       mticker.AutoLocator()._steps)\n\n    @pytest.mark.parametrize('major_step, expected_nb_minordivisions',\n                             majorstep_minordivisions)\n    def test_number_of_minor_ticks(\n            self, major_step, expected_nb_minordivisions):\n        fig, ax = plt.subplots()\n        xlims = (0, major_step)\n        ax.set_xlim(*xlims)\n        ax.set_xticks(xlims)\n        ax.minorticks_on()\n        ax.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n        nb_minor_divisions = len(ax.xaxis.get_minorticklocs("}, {"start_line": 67000, "end_line": 69000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tor.\"\"\"\n        if presets is not None:\n            self.presets = presets\n        if numticks is not None:\n            self.numticks = numticks\n\n    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n\n        if (vmin, vmax) in self.presets:\n            return self.presets[(vmin, vmax)]\n\n        if self.numticks == 0:\n            return []\n        ticklocs = np.linspace(vmin, vmax, self.numticks)\n\n        return self.raise_if_exceeds(ticklocs)\n\n    def view_limits(self, vmin, vmax):\n        \"\"\"Try to choose the view limits intelligently.\"\"\"\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if vmin == vmax:\n            vmin -= 1\n            vmax += 1\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            exponent, remainder = divmod(\n                math.log10(vmax - vmin), math.log10(max(self.numticks - 1, 1)))\n            exponent -= (remainder < .5)\n            scale = max(self.numticks - 1, 1) ** (-exponent)\n            vmin = math.floor(scale * vmin) / scale\n            vmax = math.ceil(scale * vmax) / scale\n\n        return mtransforms.nonsingular(vmin, vmax)\n\n\nclass MultipleLocator(Locator):\n    \"\"\"\n    Place ticks at every integer multiple of a base plus an offset.\n    \"\"\"\n\n    def __init__(self, base=1.0, offset=0.0):\n        \"\"\"\n        Parameters\n        ----------\n        base : float > 0, default: 1.0\n            Interval between ticks.\n        offset : float, default: 0.0\n            Value added to each multiple of *base*.\n\n            .. versionadded:: 3.8\n        \"\"\"\n        self._edge = _Edge_integer(base, 0)\n        self._offset = offset\n\n    def set_params(self, base=None, offset=None):\n        \"\"\"\n        Set parameters within this locator.\n\n        Parameters\n        ----------\n   "}, {"start_line": 78000, "end_line": 80000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   raw_step = ((_vmax - _vmin) / nbins)\n        if hasattr(self.axis, \"axes\") and self.axis.axes.name == '3d':\n            # Due to the change in automargin behavior in mpl3.9, we need to\n            # adjust the raw step to match the mpl3.8 appearance. The zoom\n            # factor of 2/48, gives us the 23/24 modifier.\n            raw_step = raw_step * 23/24\n        large_steps = steps >= raw_step\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            # Classic round_numbers mode may require a larger step.\n            # Get first multiple of steps that are <= _vmin\n            floored_vmins = (_vmin // steps) * steps\n            floored_vmaxs = floored_vmins + steps * nbins\n            large_steps = large_steps & (floored_vmaxs >= _vmax)\n\n        # Find index of smallest large step\n        if any(large_steps):\n            istep = np.nonzero(large_steps)[0][0]\n        else:\n            istep = len(steps) - 1\n\n        # Start at smallest of the steps greater than the raw step, and check\n        # if it provides enough ticks. If not, work backwards through\n        # smaller steps until one is found that provides enough ticks.\n        for step in steps[:istep+1][::-1]:\n\n            if (self._integer and\n                    np.floor(_vmax) - np.ceil(_vmin) >= self._min_n_ticks - 1):\n                step = max(1, step)\n            best_vmin = (_vmin // step) * step\n\n            # Find tick locations spanning the vmin-vmax range, taking into\n            # account degradation of precision when there is a large offset.\n            # The edge ticks beyond vmin and/or vmax are needed for the\n            # \"round_numbers\" autolimit mode.\n            edge = _Edge_integer(step, offset)\n            low = edge.le(_vmin - best_vmin)\n            high = edge.ge(_vmax - best_vmin)\n            ticks = np.arange(low, high + 1) * step + best_vmin\n            # Count only the ticks that will be displayed.\n            nticks = ((ticks <= _vmax) & (ticks >= _vmin)).s"}, {"start_line": 74000, "end_line": 76000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n an axis' edge* (this typically occurs when\n            :rc:`axes.autolimit_mode` is 'round_numbers').  Removing such ticks\n            is mostly useful for stacked or ganged plots, where the upper tick\n            of an Axes overlaps with the lower tick of the axes above it.\n\n        min_n_ticks : int, default: 2\n            Relax *nbins* and *integer* constraints if necessary to obtain\n            this minimum number of ticks.\n        \"\"\"\n        if nbins is not None:\n            kwargs['nbins'] = nbins\n        self.set_params(**{**self.default_params, **kwargs})\n\n    @staticmethod\n    def _validate_steps(steps):\n        if not np.iterable(steps):\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        steps = np.asarray(steps)\n        if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        if steps[0] != 1:\n            steps = np.concatenate([[1], steps])\n        if steps[-1] != 10:\n            steps = np.concatenate([steps, [10]])\n        return steps\n\n    @staticmethod\n    def _staircase(steps):\n        # Make an extended staircase within which the needed step will be\n        # found.  This is probably much larger than necessary.\n        return np.concatenate([0.1 * steps[:-1], steps, [10 * steps[1]]])\n\n    def set_params(self, **kwargs):\n        \"\"\"\n        Set parameters for this locator.\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            see `.MaxNLocator`\n        steps : array-like, optional\n            see `.MaxNLocator`\n        integer : bool, optional\n            see `.MaxNLocator`\n        symmetric : bool, optional\n            see `.MaxNLocator`\n        prune : {'lower', 'upper', 'both', None}, optional\n            see `.MaxNLocator`\n        min_n_tick"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "from contextlib import nullcontext\nimport itertools\nimport locale\nimport logging\nimport re\nfrom packaging.version import parse as parse_version\n\nimport numpy as np\nfrom numpy.testing import assert_almost_equal, assert_array_equal\nimport pytest\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\n\n\nclass TestMaxNLocator:\n    basic_data = [\n        (20, 100, np.array([20., 40., 60., 80., 100.])),\n        (0.001, 0.0001, np.array([0., 0.0002, 0.0004, 0.0006, 0.0008, 0.001])),\n        (-1e15, 1e15, np.array([-1.0e+15, -5.0e+14, 0e+00, 5e+14, 1.0e+15])),\n        (0, 0.85e-50, np.arange(6) * 2e-51),\n        (-0.85e-50, 0, np.arange(-5, 1) * 2e-51),\n    ]\n\n    integer_data = [\n        (-0.1, 1.1, None, np.array([-1, 0, 1, 2])),\n        (-0.1, 0.95, None, np.array([-0.25, 0, 0.25, 0.5, 0.75, 1.0])),\n        (1, 55, [1, 1.5, 5, 6, 10], np.array([0, 15, 30, 45, 60])),\n    ]\n\n    @pytest.mark.parametrize('vmin, vmax, expected', basic_data)\n    def test_basic(self, vmin, vmax, expected):\n        loc = mticker.MaxNLocator(nbins=5)\n        assert_almost_equal(loc.tick_values(vmin, vmax), expected)\n\n    @pytest.mark.parametrize('vmin, vmax, steps, expected', integer_data)\n    def test_integer(self, vmin, vmax, steps, expected):\n        loc = mticker.MaxNLocator(nbins=5, integer=True, steps=steps)\n        assert_almost_equal(loc.tick_values(vmin, vmax), expected)\n\n    @pytest.mark.parametrize('kwargs, errortype, match', [\n        ({'foo': 0}, TypeError,\n         re.escape(\"set_params() got an unexpected keyword argument 'foo'\")),\n        ({'steps': [2, 1]}, ValueError, \"steps argument must be an increasing\"),\n        ({'steps': 2}, ValueError, \"steps argument must be an increasing\"),\n        ({'steps': [2, 11]}, ValueError, \"steps argument must be an increasing\"),\n    ])\n    def test_errors(self, kwargs, errortype, match):\n        with pytest.raises(errortype, match=match):\n            mticker.MaxNLocator(**kwargs)\n\n    @pytest.mark.parametr"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cks_auto(self, lim, ref, use_rcparam):\n        if use_rcparam:\n            context = {'xtick.minor.ndivs': 'auto', 'ytick.minor.ndivs': 'auto'}\n            kwargs = {}\n        else:\n            context = {}\n            kwargs = {'n': 'auto'}\n\n        with mpl.rc_context(context):\n            fig, ax = plt.subplots()\n            ax.set_xlim(*lim)\n            ax.set_ylim(*lim)\n            ax.xaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            ax.yaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            assert_almost_equal(ax.xaxis.get_ticklocs(minor=True), ref)\n            assert_almost_equal(ax.yaxis.get_ticklocs(minor=True), ref)\n\n    @pytest.mark.parametrize('use_rcparam', [False, True])\n    @pytest.mark.parametrize(\n        'n, lim, ref', [\n            (2, (0, 4), [0.5, 1.5, 2.5, 3.5]),\n            (4, (0, 2), [0.25, 0.5, 0.75, 1.25, 1.5, 1.75]),\n            (10, (0, 1), [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]),\n        ])\n    def test_number_of_minor_ticks_int(self, n, lim, ref, use_rcparam):\n        if use_rcparam:\n            context = {'xtick.minor.ndivs': n, 'ytick.minor.ndivs': n}\n            kwargs = {}\n        else:\n            context = {}\n            kwargs = {'n': n}\n\n        with mpl.rc_context(context):\n            fig, ax = plt.subplots()\n            ax.set_xlim(*lim)\n            ax.set_ylim(*lim)\n            ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n            ax.xaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            ax.yaxis.set_major_locator(mticker.MultipleLocator(1))\n            ax.yaxis.set_minor_locator(mticker.AutoMinorLocator(**kwargs))\n            assert_almost_equal(ax.xaxis.get_ticklocs(minor=True), ref)\n            assert_almost_equal(ax.yaxis.get_ticklocs(minor=True), ref)\n\n\nclass TestLogLocator:\n    def test_basic(self):\n        loc = mticker.LogLocator(numticks=5)\n        with pytest.raises(ValueError):\n            loc.tick_values(0, 1000)\n\n        test_value = np."}, {"start_line": 80000, "end_line": 82000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "um()\n            if nticks >= self._min_n_ticks:\n                break\n        return ticks + offset\n\n    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        if self._symmetric:\n            vmax = max(abs(vmin), abs(vmax))\n            vmin = -vmax\n        vmin, vmax = mtransforms.nonsingular(\n            vmin, vmax, expander=1e-13, tiny=1e-14)\n        locs = self._raw_ticks(vmin, vmax)\n\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return self.raise_if_exceeds(locs)\n\n    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            dmax = max(abs(dmin), abs(dmax))\n            dmin = -dmax\n\n        dmin, dmax = mtransforms.nonsingular(\n            dmin, dmax, expander=1e-12, tiny=1e-13)\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            return self._raw_ticks(dmin, dmax)[[0, -1]]\n        else:\n            return dmin, dmax\n\n\ndef _is_decade(x, *, base=10, rtol=None):\n    \"\"\"Return True if *x* is an integer power of *base*.\"\"\"\n    if not np.isfinite(x):\n        return False\n    if x == 0.0:\n        return True\n    lx = np.log(abs(x)) / np.log(base)\n    if rtol is None:\n        return np.isclose(lx, np.round(lx))\n    else:\n        return np.isclose(lx, np.round(lx), rtol=rtol)\n\n\ndef _decade_less_equal(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less or equal to *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_greater_equal(-x, base) if x < 0 else\n            base ** np.floor(np.log(x) / np.log(base)))\n\n\ndef _decade_greater_equal(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater or equal to *x*.\n\n    If *x* is negative, the expon"}], "retrieved_count": 10, "cost_time": 3.583068609237671}
{"question": "What is the shared axes mechanism in matplotlib that ensures sticky edge settings propagate correctly between leader and follower axes when pcolormesh is called on different axes in the sharing relationship?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 274000, "end_line": 276000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " as the corresponding polygons do not\n        exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual\n        polygon, it also supports applying hatches and linestyles to the collection.\n\n        Another difference is the support of Gouraud shading in\n        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.\n\n        \"\"\"\n        shading = mpl._val_or_rc(shading, 'pcolor.shading').lower()\n        kwargs.setdefault('edgecolors', 'none')\n\n        X, Y, C, shading = self._pcolorargs('pcolormesh', *args,\n                                            shading=shading, kwargs=kwargs)\n        coords = np.stack([X, Y], axis=-1)\n\n        kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])\n\n        collection = mcoll.QuadMesh(\n            coords, antialiased=antialiased, shading=shading,\n            array=C, cmap=cmap, norm=norm, colorizer=colorizer, alpha=alpha, **kwargs)\n        collection._check_exclusionary_keywords(colorizer, vmin=vmin, vmax=vmax)\n        collection._scale_norm(norm, vmin, vmax)\n\n        coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y\n        self._update_pcolor_lims(collection, coords)\n        return collection\n\n    def _update_pcolor_lims(self, collection, coords):\n        \"\"\"\n        Common code for updating lims in pcolor() and pcolormesh() methods.\n        \"\"\"\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n                hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            coords = trans_to_data.transform(coords)\n\n        self.add_collection(collection, autolim=False)\n\n        minx, miny = np.min(coords, axis=0)\n        maxx, maxy = np.max(coords, axis=0)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] ="}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " assert_allclose(ax2.get_ylim(), (x[0], x[-1]))\n\n\n@mpl.style.context('default')\ndef test_use_sticky_edges():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]], origin='lower')\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n    ax.use_sticky_edges = False\n    ax.autoscale()\n    xlim = (-0.5 - 2 * ax._xmargin, 1.5 + 2 * ax._xmargin)\n    ylim = (-0.5 - 2 * ax._ymargin, 1.5 + 2 * ax._ymargin)\n    assert_allclose(ax.get_xlim(), xlim)\n    assert_allclose(ax.get_ylim(), ylim)\n    # Make sure it is reversible:\n    ax.use_sticky_edges = True\n    ax.autoscale()\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n\n\n@check_figures_equal()\ndef test_sticky_shared_axes(fig_test, fig_ref):\n    # Check that sticky edges work whether they are set in an Axes that is a\n    # \"leader\" in a share, or an Axes that is a \"follower\".\n    Z = np.arange(15).reshape(3, 5)\n\n    ax0 = fig_test.add_subplot(211)\n    ax1 = fig_test.add_subplot(212, sharex=ax0)\n    ax1.pcolormesh(Z)\n\n    ax0 = fig_ref.add_subplot(212)\n    ax1 = fig_ref.add_subplot(211, sharex=ax0)\n    ax0.pcolormesh(Z)\n\n\n@image_comparison(['sticky_tolerance.png'], remove_text=True, style=\"mpl20\")\ndef test_sticky_tolerance():\n    fig, axs = plt.subplots(2, 2)\n\n    width = .1\n\n    axs.flat[0].bar(x=0, height=width, bottom=20000.6)\n    axs.flat[0].bar(x=1, height=width, bottom=20000.1)\n\n    axs.flat[1].bar(x=0, height=-width, bottom=20000.6)\n    axs.flat[1].bar(x=1, height=-width, bottom=20000.1)\n\n    axs.flat[2].barh(y=0, width=-width, left=-20000.6)\n    axs.flat[2].barh(y=1, width=-width, left=-20000.1)\n\n    axs.flat[3].barh(y=0, width=width, left=-20000.6)\n    axs.flat[3].barh(y=1, width=width, left=-20000.1)\n\n\n@image_comparison(['sticky_tolerance_cf.png'], remove_text=True, style=\"mpl20\")\ndef test_sticky_tolerance_contourf():\n    fig, ax = plt.subplots()\n\n    x = y = [14496.71, 14496.75]\n    data = [[0, 1], [2, 3]]\n\n    ax.contourf"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", 3.15))\n    assert_allclose(ax.get_ylim(), (1.0, 4.0))\n\n    # Check that autoscale is on\n    assert ax.get_autoscalex_on()\n    assert ax.get_autoscaley_on()\n    assert ax.get_autoscale_on()\n    # Set enable to None\n    ax.autoscale(enable=None)\n    # Same limits\n    assert_allclose(ax.get_xlim(), (-0.15, 3.15))\n    assert_allclose(ax.get_ylim(), (1.0, 4.0))\n    # autoscale still on\n    assert ax.get_autoscalex_on()\n    assert ax.get_autoscaley_on()\n    assert ax.get_autoscale_on()\n\n\n@mpl.style.context('default')\ndef test_autoscale_log_shared():\n    # related to github #7587\n    # array starts at zero to trigger _minpos handling\n    x = np.arange(100, dtype=float)\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.loglog(x, x)\n    ax2.semilogx(x, x)\n    ax1.autoscale(tight=True)\n    ax2.autoscale(tight=True)\n    plt.draw()\n    lims = (x[1], x[-1])\n    assert_allclose(ax1.get_xlim(), lims)\n    assert_allclose(ax1.get_ylim(), lims)\n    assert_allclose(ax2.get_xlim(), lims)\n    assert_allclose(ax2.get_ylim(), (x[0], x[-1]))\n\n\n@mpl.style.context('default')\ndef test_use_sticky_edges():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]], origin='lower')\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n    ax.use_sticky_edges = False\n    ax.autoscale()\n    xlim = (-0.5 - 2 * ax._xmargin, 1.5 + 2 * ax._xmargin)\n    ylim = (-0.5 - 2 * ax._ymargin, 1.5 + 2 * ax._ymargin)\n    assert_allclose(ax.get_xlim(), xlim)\n    assert_allclose(ax.get_ylim(), ylim)\n    # Make sure it is reversible:\n    ax.use_sticky_edges = True\n    ax.autoscale()\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n\n\n@check_figures_equal()\ndef test_sticky_shared_axes(fig_test, fig_ref):\n    # Check that sticky edges work whether they are set in an Axes that is a\n    # \"leader\" in a share, or an Axes that is a \"follower\".\n    Z = np.arange(15).reshape(3, 5)\n\n    ax0 = fig_test.add_subplot(211)\n    "}, {"start_line": 295000, "end_line": 297000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ick in axis.get_major_ticks():\n            assert tick.label1.get_size() == axis._get_tick_label_size(name)\n\n\ndef test_multiplot_autoscale():\n    fig = plt.figure()\n    ax1, ax2 = fig.subplots(2, 1, sharex='all')\n    ax1.plot([18000, 18250, 18500, 18750], [2, 3, 2, 3])\n    ax2.axhspan(-5, 5)\n    xlim = ax1.get_xlim()\n    assert np.allclose(xlim, [18000, 18800])\n\n\ndef test_sharing_does_not_link_positions():\n    fig = plt.figure()\n    ax0 = fig.add_subplot(221)\n    ax1 = fig.add_axes((.6, .6, .3, .3), sharex=ax0)\n    init_pos = ax1.get_position()\n    fig.subplots_adjust(left=0)\n    assert (ax1.get_position().get_points() == init_pos.get_points()).all()\n\n\n@check_figures_equal(extensions=[\"pdf\"])\ndef test_2dcolor_plot(fig_test, fig_ref):\n    color = np.array([0.1, 0.2, 0.3])\n    # plot with 1D-color:\n    axs = fig_test.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape(-1))\n    with pytest.warns(match=\"argument looks like a single numeric RGB\"):\n        axs[1].scatter([1, 2], [1, 2], c=color.reshape(-1))\n    axs[2].step([1, 2], [1, 2], c=color.reshape(-1))\n    axs[3].hist(np.arange(10), color=color.reshape(-1))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape(-1))\n    # plot with 2D-color:\n    axs = fig_ref.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[1].scatter([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[2].step([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n\n\n@check_figures_equal()\ndef test_shared_axes_clear(fig_test, fig_ref):\n    x = np.arange(0.0, 2*np.pi, 0.01)\n    y = np.sin(x)\n\n    axs = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.plot(x, y)\n\n    axs = fig_test.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.clear()\n        ax.plot(x, y)\n\n\ndef test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, "}, {"start_line": 296000, "end_line": 298000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2], c=color.reshape(-1))\n    axs[2].step([1, 2], [1, 2], c=color.reshape(-1))\n    axs[3].hist(np.arange(10), color=color.reshape(-1))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape(-1))\n    # plot with 2D-color:\n    axs = fig_ref.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[1].scatter([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[2].step([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n\n\n@check_figures_equal()\ndef test_shared_axes_clear(fig_test, fig_ref):\n    x = np.arange(0.0, 2*np.pi, 0.01)\n    y = np.sin(x)\n\n    axs = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.plot(x, y)\n\n    axs = fig_test.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.clear()\n        ax.plot(x, y)\n\n\ndef test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n\n    for ax in axs.flat:\n        ax.plot([0, 2], 'o-')\n\n    axs[0, 0].set_xticks([-0.5, 0, 1, 1.5])  # should affect all axes xlims\n    for ax in axs.flat:\n        assert ax.get_xlim() == axs[0, 0].get_xlim()\n\n    axs[0, 0].set_yticks([-0.5, 0, 2, 2.5])  # should affect all axes ylims\n    for ax in axs.flat:\n        assert ax.get_ylim() == axs[0, 0].get_ylim()\n\n\n@pytest.mark.parametrize('ha', ['left', 'center', 'right'])\ndef test_ylabel_ha_with_position(ha):\n    fig = Figure()\n    ax = fig.subplots()\n    ax.set_ylabel(\"test\", y=1, ha=ha)\n    ax.yaxis.set_label_position(\"right\")\n    assert ax.yaxis.label.get_ha() == ha\n\n\ndef test_bar_label_location_vertical():\n    ax = plt.gca()\n    xs, heights = [1, 2], [3, -4]\n    rects = ax.bar(xs, heights)\n    labels = ax.bar_label(rects)\n    assert labels[0].xy == (xs[0], heights[0])\n    assert labels[0].get_horizontalalignment() == 'center'\n    assert labels[0].get_verticalalignment() == 'bottom'\n    assert labels[1].xy"}, {"start_line": 273000, "end_line": 275000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e lies in the created object and internal data\n        handling:\n        While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`\n        returns a `.QuadMesh`. The latter is more specialized for the given\n        purpose and thus is faster. It should almost always be preferred.\n\n        There is also a slight difference in the handling of masked arrays.\n        Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays\n        for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*\n        and *Y*. The reason lies in the internal handling of the masked values.\n        `~.Axes.pcolor` leaves out the respective polygons from the\n        PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked\n        elements to transparent. You can see the difference when using\n        edgecolors. While all edges are drawn irrespective of masking in a\n        QuadMesh, the edge between two adjacent masked quadrilaterals in\n        `~.Axes.pcolor` is not drawn as the corresponding polygons do not\n        exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual\n        polygon, it also supports applying hatches and linestyles to the collection.\n\n        Another difference is the support of Gouraud shading in\n        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.\n\n        \"\"\"\n        shading = mpl._val_or_rc(shading, 'pcolor.shading').lower()\n        kwargs.setdefault('edgecolors', 'none')\n\n        X, Y, C, shading = self._pcolorargs('pcolormesh', *args,\n                                            shading=shading, kwargs=kwargs)\n        coords = np.stack([X, Y], axis=-1)\n\n        kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])\n\n        collection = mcoll.QuadMesh(\n            coords, antialiased=antialiased, shading=shading,\n            array=C, cmap=cmap, norm=norm, colorizer=colorizer, alpha=alpha, **kwargs)\n        collection._check_exclusionary_keywords(colorizer, vmin=vmin, vmax=vmax)\n        co"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p.arange(16))\n    colors[:, 3] = 0.5 + 0.5*np.sin(np.arange(16))\n    cmap = mcolors.ListedColormap(colors)\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n    for ax in ax1, ax2, ax3, ax4:\n        ax.add_patch(mpatches.Rectangle(\n            (0, -1.5), 1.5, 3, facecolor=[.7, .1, .1, .5], zorder=0\n        ))\n    # ax1, ax2: constant alpha\n    ax1.pcolormesh(Qx, Qy, Z[:-1, :-1], cmap=vir, alpha=0.4,\n                   shading='flat', zorder=1)\n    ax2.pcolormesh(Qx, Qy, Z, cmap=vir, alpha=0.4, shading='gouraud', zorder=1)\n    # ax3, ax4: alpha from colormap\n    ax3.pcolormesh(Qx, Qy, Z[:-1, :-1], cmap=cmap, shading='flat', zorder=1)\n    ax4.pcolormesh(Qx, Qy, Z, cmap=cmap, shading='gouraud', zorder=1)\n\n\n@pytest.mark.parametrize(\"dims,alpha\", [(3, 1), (4, 0.5)])\n@check_figures_equal()\ndef test_pcolormesh_rgba(fig_test, fig_ref, dims, alpha):\n    ax = fig_test.subplots()\n    c = np.ones((5, 6, dims), dtype=float) / 2\n    ax.pcolormesh(c)\n\n    ax = fig_ref.subplots()\n    ax.pcolormesh(c[..., 0], cmap=\"gray\", vmin=0, vmax=1, alpha=alpha)\n\n\n@check_figures_equal()\ndef test_pcolormesh_nearest_noargs(fig_test, fig_ref):\n    x = np.arange(4)\n    y = np.arange(7)\n    X, Y = np.meshgrid(x, y)\n    C = X + Y\n\n    ax = fig_test.subplots()\n    ax.pcolormesh(C, shading=\"nearest\")\n\n    ax = fig_ref.subplots()\n    ax.pcolormesh(x, y, C, shading=\"nearest\")\n\n\n@check_figures_equal()\ndef test_pcolormesh_log_scale(fig_test, fig_ref):\n    \"\"\"\n    Check that setting a log scale sets good default axis limits\n    when using pcolormesh.\n    \"\"\"\n    x = np.linspace(0, 1, 11)\n    y = np.linspace(1, 2, 5)\n    X, Y = np.meshgrid(x, y)\n    C = X + Y\n\n    ax = fig_test.subplots()\n    ax.pcolormesh(X, Y, C)\n    ax.set_xscale('log')\n\n    ax = fig_ref.subplots()\n    ax.pcolormesh(X, Y, C)\n    ax.set_xlim(1e-2, 1e1)\n    ax.set_xscale('log')\n\n\n@image_comparison(['pcolormesh_datetime_axis.png'], style='mpl20')\ndef test_pcolormesh_datetime_axis():\n    # Remove this line when this test image is regene"}, {"start_line": 261000, "end_line": 263000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "way between the adjacent grid centers.  The\n              dimensions of *X* and *Y* must be the same as *C*.\n            - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one\n              larger than *C*.  Choose 'nearest' if dimensions are the same.\n\n            See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`\n            for more description.\n\n        %(cmap_doc)s\n\n        %(norm_doc)s\n\n        %(vmin_vmax_doc)s\n\n        %(colorizer_doc)s\n\n        edgecolors : {'none', None, 'face', color, color sequence}, optional\n            The color of the edges. Defaults to 'none'. Possible values:\n\n            - 'none' or '': No edge.\n            - *None*: :rc:`patch.edgecolor` will be used. Note that currently\n              :rc:`patch.force_edgecolor` has to be True for this to work.\n            - 'face': Use the adjacent face color.\n            - A color or sequence of colors will set the edge color.\n\n            The singular form *edgecolor* works as an alias.\n\n        alpha : float, default: None\n            The alpha blending value of the face color, between 0 (transparent)\n            and 1 (opaque). Note: The edgecolor is currently not affected by\n            this.\n\n        snap : bool, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        `matplotlib.collections.PolyQuadMesh`\n\n        Other Parameters\n        ----------------\n        antialiaseds : bool, default: False\n            The default *antialiaseds* is False if the default\n            *edgecolors*\\ =\"none\" is used.  This eliminates artificial lines\n            at patch boundaries, and works regardless of the value of alpha.\n            If *edgecolors* is not \"none\", then the default *antialiaseds*\n            is taken from :rc:`patch.antialiased`.\n            Stroking the edges may be preferred if *alpha* is 1, but will\n            cause artifacts otherwise.\n\n        data : indexable object, optional\n            DATA_PARAMETER_"}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sh(c[..., 0], cmap=\"gray\", vmin=0, vmax=1, alpha=alpha)\n\n\n@check_figures_equal()\ndef test_pcolormesh_nearest_noargs(fig_test, fig_ref):\n    x = np.arange(4)\n    y = np.arange(7)\n    X, Y = np.meshgrid(x, y)\n    C = X + Y\n\n    ax = fig_test.subplots()\n    ax.pcolormesh(C, shading=\"nearest\")\n\n    ax = fig_ref.subplots()\n    ax.pcolormesh(x, y, C, shading=\"nearest\")\n\n\n@check_figures_equal()\ndef test_pcolormesh_log_scale(fig_test, fig_ref):\n    \"\"\"\n    Check that setting a log scale sets good default axis limits\n    when using pcolormesh.\n    \"\"\"\n    x = np.linspace(0, 1, 11)\n    y = np.linspace(1, 2, 5)\n    X, Y = np.meshgrid(x, y)\n    C = X + Y\n\n    ax = fig_test.subplots()\n    ax.pcolormesh(X, Y, C)\n    ax.set_xscale('log')\n\n    ax = fig_ref.subplots()\n    ax.pcolormesh(X, Y, C)\n    ax.set_xlim(1e-2, 1e1)\n    ax.set_xscale('log')\n\n\n@image_comparison(['pcolormesh_datetime_axis.png'], style='mpl20')\ndef test_pcolormesh_datetime_axis():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolormesh(x[:-1], y[:-1], z[:-1, :-1])\n    plt.subplot(222)\n    plt.pcolormesh(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolormesh(x[:-1, :-1], y[:-1, :-1], z[:-1, :-1])\n    plt.subplot(224)\n    plt.pcolormesh(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)\n\n\n@image_comparison(['pcolor_datetime_axis.png'], style='mpl20')\ndef test_pcolor_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n"}, {"start_line": 275000, "end_line": 277000, "belongs_to": {"file_name": "_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "llection._scale_norm(norm, vmin, vmax)\n\n        coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y\n        self._update_pcolor_lims(collection, coords)\n        return collection\n\n    def _update_pcolor_lims(self, collection, coords):\n        \"\"\"\n        Common code for updating lims in pcolor() and pcolormesh() methods.\n        \"\"\"\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n                hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            coords = trans_to_data.transform(coords)\n\n        self.add_collection(collection, autolim=False)\n\n        minx, miny = np.min(coords, axis=0)\n        maxx, maxy = np.max(coords, axis=0)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] = [miny, maxy]\n        self.update_datalim(coords)\n        self._request_autoscale_view()\n\n    @_preprocess_data()\n    @_docstring.interpd\n    def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n                   vmax=None, colorizer=None, **kwargs):\n        \"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n            ax.pcolorfast([X, Y], C, /, **kwargs)\n\n        The arguments *X*, *Y*, *C* are positional-only.\n\n        This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.\n        It's designed to provide the fastest pcolor-type plotting with the\n        Agg backend. To achieve this, it uses different algorithms internally\n        depending on the complexity of the input grid (regular rectangular,\n        non-regular rectangular or arbitrary quadrilateral).\n\n        .. warning::\n\n            This method is experimental. Compared to `~.Axes.pcolor` or\n            `~.Axes.pcolormesh` it has some limit"}], "retrieved_count": 10, "cost_time": 3.601829767227173}
{"question": "What is the synchronization mechanism of the _expect method that integrates with the broader LatexManager architecture to maintain process state consistency across asynchronous LaTeX subprocess communication?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     return cls()\n\n    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n\n    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        self._setup_latex_process(expect_reply=False)\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache(self._get_box_metrics)\n\n    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with or `wait()` on\n        # it.\n        "}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nsure a clean startup of the subprocess\n        self._setup_latex_process(expect_reply=False)\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache(self._get_box_metrics)\n\n    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with or `wait()` on\n        # it.\n        try:\n            self.latex = subprocess.Popen(\n                [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{mpl.rcParams['pgf.texsystem']!r} not found; install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX implementation\"\n            ) from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting {mpl.rcParams['pgf.texsystem']!r}\") from err\n\n        def finalize_latex(latex):\n            latex.kill()\n            try:\n                latex.communicate()\n            except RuntimeError:\n                latex.wait()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._bu"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e in `.rcParams`.\n    \"\"\"\n\n    @staticmethod\n    def _build_latex_header():\n        latex_header = [\n            _DOCUMENTCLASS,\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            _get_preamble(),\n            r\"\\begin{document}\",\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n\n    @classmethod\n    def _get_cached_or_new(cls):\n        \"\"\"\n        Return the previous LatexManager if the header and tex system did not\n        change, or a new instance otherwise.\n        \"\"\"\n        return cls._get_cached_or_new_impl(cls._build_latex_header())\n\n    @classmethod\n    @functools.lru_cache(1)\n    def _get_cached_or_new_impl(cls, header):  # Helper for _get_cached_or_new.\n        return cls()\n\n    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n\n    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to e"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   return lambda pdffile, pngfile, dpi: subprocess.check_output(\n            [gs_info.executable,\n             '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',\n             '-dUseCIEColor', '-dTextAlphaBits=4',\n             '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE',\n             '-sDEVICE=pngalpha', '-sOutputFile=%s' % pngfile,\n             '-r%d' % dpi, pdffile],\n            stderr=subprocess.STDOUT)\n    raise RuntimeError(\"No suitable pdf to png renderer found.\")\n\n\nclass LatexError(Exception):\n    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output\n\n    def __str__(self):\n        s, = self.args\n        if self.latex_output:\n            s += \"\\n\" + self.latex_output\n        return s\n\n\nclass LatexManager:\n    \"\"\"\n    The LatexManager opens an instance of the LaTeX application for\n    determining the metrics of text elements. The LaTeX environment can be\n    modified by setting fonts and/or a custom preamble in `.rcParams`.\n    \"\"\"\n\n    @staticmethod\n    def _build_latex_header():\n        latex_header = [\n            _DOCUMENTCLASS,\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            _get_preamble(),\n            r\"\\begin{document}\",\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n\n    @classmethod\n    def _get_cached_or_new(cls):\n        \"\"\"\n        Return the previous LatexManager if the header and tex system did not\n        change, or a new instance otherwise.\n        \"\"\"\n        return cls._get_cached_or_new_impl(cls._build_latex_header())\n\n    @classmethod\n    @functools.lru_cache(1)\n    def _get_cached_or_new_impl(cls, header):  # Helper for _get_cached_or_new.\n   "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try:\n            self.latex = subprocess.Popen(\n                [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{mpl.rcParams['pgf.texsystem']!r} not found; install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX implementation\"\n            ) from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting {mpl.rcParams['pgf.texsystem']!r}\") from err\n\n        def finalize_latex(latex):\n            latex.kill()\n            try:\n                latex.communicate()\n            except RuntimeError:\n                latex.wait()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        if expect_reply:  # read until 'pgf_backend_query_start' token appears\n            self._expect(\"*pgf_backend_query_start\")\n            self._expect_prompt()\n\n    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height, and descent (in TeX points) for a text\n        typeset by the current LaTeX environment.\n        \"\"\"\n        return self._get_box_metrics(_escape_and_apply_props(text, prop))\n\n    def _get_box_metrics(self, tex):\n        \"\"\"\n        Get the width, total height and descent (in TeX points) for a TeX\n        command's output in the current LaTeX environment.\n        \"\"\"\n        # This method gets wrapped in __init__ for per-instance caching.\n        self._stdin_writeln(  # Send textbox to TeX & request metrics typeout.\n            # \\sbox doesn't handle catcode assignments inside its argument,\n            # so repeat the assignment of the catcode of \"^\" and \"%\" outside.\n            r\"{\\catcode`\\^=\\active\\c"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "compare.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ill()\n            self._proc.wait()\n            for stream in filter(None, [self._proc.stdin,\n                                        self._proc.stdout,\n                                        self._proc.stderr]):\n                stream.close()\n            self._proc = None\n\n    def _read_until(self, terminator):\n        \"\"\"Read until the prompt is reached.\"\"\"\n        buf = bytearray()\n        while True:\n            c = self._proc.stdout.read(1)\n            if not c:\n                raise _ConverterError(os.fsdecode(bytes(buf)))\n            buf.extend(c)\n            if buf.endswith(terminator):\n                return bytes(buf)\n\n\nclass _MagickConverter:\n    def __call__(self, orig, dest):\n        try:\n            subprocess.run(\n                [mpl._get_executable_info(\"magick\").executable, orig, dest],\n                check=True)\n        except subprocess.CalledProcessError as e:\n            raise _ConverterError() from e\n\n\nclass _GSConverter(_Converter):\n    def __call__(self, orig, dest):\n        if not self._proc:\n            self._proc = subprocess.Popen(\n                [mpl._get_executable_info(\"gs\").executable,\n                 \"-dNOSAFER\", \"-dNOPAUSE\", \"-dEPSCrop\", \"-sDEVICE=png16m\"],\n                # As far as I can see, ghostscript never outputs to stderr.\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n            try:\n                self._read_until(b\"\\nGS\")\n            except _ConverterError as e:\n                raise OSError(f\"Failed to start Ghostscript:\\n\\n{e.args[0]}\") from None\n\n        def encode_and_escape(name):\n            return (os.fsencode(name)\n                    .replace(b\"\\\\\", b\"\\\\\\\\\")\n                    .replace(b\"(\", br\"\\(\")\n                    .replace(b\")\", br\"\\)\"))\n\n        self._proc.stdin.write(\n            b\"<< /OutputFile (\"\n            + encode_and_escape(dest)\n            + b\") >> setpagedevice (\"\n            + encode_and_escape(orig)\n            + b\") run flush\\n\")\n        self._proc.stdin.flush()\n      "}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "compare.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ref.finalize(self._tmpdir, self.__del__)\n        if (not self._proc  # First run.\n                or self._proc.poll() is not None):  # Inkscape terminated.\n            if self._proc is not None and self._proc.poll() is not None:\n                for stream in filter(None, [self._proc.stdin,\n                                            self._proc.stdout,\n                                            self._proc.stderr]):\n                    stream.close()\n            env = {\n                **os.environ,\n                # If one passes e.g. a png file to Inkscape, it will try to\n                # query the user for conversion options via a GUI (even with\n                # `--without-gui`).  Unsetting `DISPLAY` prevents this (and\n                # causes GTK to crash and Inkscape to terminate, but that'll\n                # just be reported as a regular exception below).\n                \"DISPLAY\": \"\",\n                # Do not load any user options.\n                \"INKSCAPE_PROFILE_DIR\": self._tmpdir.name,\n            }\n            # Old versions of Inkscape (e.g. 0.48.3.1) seem to sometimes\n            # deadlock when stderr is redirected to a pipe, so we redirect it\n            # to a temporary file instead.  This is not necessary anymore as of\n            # Inkscape 0.92.1.\n            stderr = TemporaryFile()\n            self._proc = subprocess.Popen(\n                [\"inkscape\", \"--without-gui\", \"--shell\"] if old_inkscape else\n                [\"inkscape\", \"--shell\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=stderr,\n                env=env, cwd=self._tmpdir.name)\n            # Slight abuse, but makes shutdown handling easier.\n            self._proc.stderr = stderr\n            try:\n                self._read_until(terminator)\n            except _ConverterError as err:\n                raise OSError(\n                    \"Failed to start Inkscape in interactive mode:\\n\\n\"\n                    + err.args[0]) from err\n\n        # Inkscape's shell m"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "compare.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/testing", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 20):\n    sha256 = hashlib.sha256(usedforsecurity=False)\n    with open(path, 'rb') as fd:\n        while True:\n            data = fd.read(block_size)\n            if not data:\n                break\n            sha256.update(data)\n\n    if Path(path).suffix == '.pdf':\n        sha256.update(str(mpl._get_executable_info(\"gs\").version).encode('utf-8'))\n    elif Path(path).suffix == '.svg':\n        sha256.update(str(mpl._get_executable_info(\"inkscape\").version).encode('utf-8'))\n\n    return sha256.hexdigest()\n\n\nclass _ConverterError(Exception):\n    pass\n\n\nclass _Converter:\n    def __init__(self):\n        self._proc = None\n        # Explicitly register deletion from an atexit handler because if we\n        # wait until the object is GC'd (which occurs later), then some module\n        # globals (e.g. signal.SIGKILL) has already been set to None, and\n        # kill() doesn't work anymore...\n        atexit.register(self.__del__)\n\n    def __del__(self):\n        if self._proc:\n            self._proc.kill()\n            self._proc.wait()\n            for stream in filter(None, [self._proc.stdin,\n                                        self._proc.stdout,\n                                        self._proc.stderr]):\n                stream.close()\n            self._proc = None\n\n    def _read_until(self, terminator):\n        \"\"\"Read until the prompt is reached.\"\"\"\n        buf = bytearray()\n        while True:\n            c = self._proc.stdout.read(1)\n            if not c:\n                raise _ConverterError(os.fsdecode(bytes(buf)))\n            buf.extend(c)\n            if buf.endswith(terminator):\n                return bytes(buf)\n\n\nclass _MagickConverter:\n    def __call__(self, orig, dest):\n        try:\n            subprocess.run(\n                [mpl._get_executable_info(\"magick\").executable, orig, dest],\n                check=True)\n        except subprocess.CalledProcessError as e:\n            raise _ConverterError() from e\n\n\nclass _GSConverter(_Converter):\n    def __call__(self, orig"}, {"start_line": 80000, "end_line": 82000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " float], float] = {}\n        try:\n            result = self._expression.parse_string(s)\n        except ParseBaseException as err:\n            # explain becomes a plain method on pyparsing 3 (err.explain(0)).\n            raise ValueError(\"\\n\" + ParseException.explain(err, 0)) from None\n        self._state_stack = []\n        self._in_subscript_or_superscript = False\n        # prevent operator spacing from leaking into a new expression\n        self._em_width_cache = {}\n        ParserElement.reset_cache()\n        return T.cast(Hlist, result[0])  # Known return type from main.\n\n    def get_state(self) -> ParserState:\n        \"\"\"Get the current `State` of the parser.\"\"\"\n        return self._state_stack[-1]\n\n    def pop_state(self) -> None:\n        \"\"\"Pop a `State` off of the stack.\"\"\"\n        self._state_stack.pop()\n\n    def push_state(self) -> None:\n        \"\"\"Push a new `State` onto the stack, copying the current state.\"\"\"\n        self._state_stack.append(self.get_state().copy())\n\n    def main(self, toks: ParseResults) -> list[Hlist]:\n        return [Hlist(toks.as_list())]\n\n    def math_string(self, toks: ParseResults) -> ParseResults:\n        return self._math_expression.parse_string(toks[0][1:-1], parse_all=True)\n\n    def math(self, toks: ParseResults) -> T.Any:\n        hlist = Hlist(toks.as_list())\n        self.pop_state()\n        return [hlist]\n\n    def non_math(self, toks: ParseResults) -> T.Any:\n        s = toks[0].replace(r'\\$', '$')\n        symbols = [Char(c, self.get_state()) for c in s]\n        hlist = Hlist(symbols)\n        # We're going into math now, so set font to 'it'\n        self.push_state()\n        self.get_state().font = mpl.rcParams['mathtext.default']\n        return [hlist]\n\n    float_literal = staticmethod(pyparsing_common.convert_to_float)\n\n    def text(self, toks: ParseResults) -> T.Any:\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        hlist = Hlist([Char(c, state) for c in toks[1]])\n        self.pop_st"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "backend_nbagg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)\n\n    def is_open(self):\n        return not (self._ext_close or self.comm._closed)\n\n    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass\n\n    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})\n\n    def send_binary(self, blob):\n        if self.supports_binary:\n            self.comm.send({'blob': 'image/png'}, buffers=[blob])\n        else:\n            # The comm is ASCII, so we send the image in base64 encoded data\n            # URL form.\n            data = b64encode(blob).decode('ascii')\n            data_uri = f\"data:image/png;base64,{data}\"\n            self.comm.send({'data': data_uri})\n\n    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)\n\n\n@_Backend.export\nclass _BackendNbAgg(_Backend):\n    FigureCanvas = FigureCanvasNbAgg\n    FigureManager = FigureManagerNbAgg\n"}], "retrieved_count": 10, "cost_time": 3.6631290912628174}
{"question": "What is the coordinate transformation pipeline in get_center_in_pixels that reconciles the semantic difference between data coordinates stored in self._xydata and the pixel coordinate system required for screen-space rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "angle_annotation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/text_labels_and_annotations", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       return self.size * factor\n\n    def set_size(self, size):\n        self.size = size\n\n    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n\n    def set_center(self, xy):\n        \"\"\"set center in data coordinates\"\"\"\n        self._xydata = xy\n\n    def get_theta(self, vec):\n        vec_in_pixels = self.ax.transData.transform(vec) - self._center\n        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))\n\n    def get_theta1(self):\n        return self.get_theta(self.vec1)\n\n    def get_theta2(self):\n        return self.get_theta(self.vec2)\n\n    def set_theta(self, angle):\n        pass\n\n    # Redefine attributes of the Arc to always give values in pixel space\n    _center = property(get_center_in_pixels, set_center)\n    theta1 = property(get_theta1, set_theta)\n    theta2 = property(get_theta2, set_theta)\n    width = property(get_size, set_size)\n    height = property(get_size, set_size)\n\n    # The following two methods are needed to update the text position.\n    def draw(self, renderer):\n        self.update_text()\n        super().draw(renderer)\n\n    def update_text(self):\n        c = self._center\n        s = self.get_size()\n        angle_span = (self.theta2 - self.theta1) % 360\n        angle = np.deg2rad(self.theta1 + angle_span / 2)\n        r = s / 2\n        if self.textposition == \"inside\":\n            r = s / np.interp(angle_span, [60, 90, 135, 180],\n                                          [3.3, 3.5, 3.8, 4])\n        self.text.xy = c + r * np.array([np.cos(angle), np.sin(angle)])\n        if self.textposition == \"outside\":\n            def R90(a, r, w, h):\n                if a < np.arctan(h/2/(r+w/2)):\n                    return np.sqrt((r+w/2)**2 + (np.tan(a)*(r+w/2))**2)\n                else:\n                    c = np.sqrt((w/2)**2+(h/2)**2)\n                    T = np.arcsin(c * np.cos(np.pi/2 - a + np.arcsin(h/2/c))/r)\n                    xy = r * np.array([np.cos(a + T), n"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "angle_annotation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/text_labels_and_annotations", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     self.textposition = textposition\n\n        super().__init__(self._xydata, size, size, angle=0.0,\n                         theta1=self.theta1, theta2=self.theta2, **kwargs)\n\n        self.set_transform(IdentityTransform())\n        self.ax.add_patch(self)\n\n        self.kw = dict(ha=\"center\", va=\"center\",\n                       xycoords=IdentityTransform(),\n                       xytext=(0, 0), textcoords=\"offset points\",\n                       annotation_clip=True)\n        self.kw.update(text_kw or {})\n        self.text = ax.annotate(text, xy=self._center, **self.kw)\n\n    def get_size(self):\n        factor = 1.\n        if self.unit == \"points\":\n            factor = self.ax.figure.dpi / 72.\n        elif self.unit[:4] == \"axes\":\n            b = TransformedBbox(Bbox.unit(), self.ax.transAxes)\n            dic = {\"max\": max(b.width, b.height),\n                   \"min\": min(b.width, b.height),\n                   \"width\": b.width, \"height\": b.height}\n            factor = dic[self.unit[5:]]\n        return self.size * factor\n\n    def set_size(self, size):\n        self.size = size\n\n    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n\n    def set_center(self, xy):\n        \"\"\"set center in data coordinates\"\"\"\n        self._xydata = xy\n\n    def get_theta(self, vec):\n        vec_in_pixels = self.ax.transData.transform(vec) - self._center\n        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))\n\n    def get_theta1(self):\n        return self.get_theta(self.vec1)\n\n    def get_theta2(self):\n        return self.get_theta(self.vec2)\n\n    def set_theta(self, angle):\n        pass\n\n    # Redefine attributes of the Arc to always give values in pixel space\n    _center = property(get_center_in_pixels, set_center)\n    theta1 = property(get_theta1, set_theta)\n    theta2 = property(get_theta2, set_theta)\n    width = property(get_size, set_size)\n    height = property(get_size, set_size)\n\n    # The fo"}, {"start_line": 161000, "end_line": 163000, "belongs_to": {"file_name": "patches.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f True, draw annotation only if self.xy is inside the Axes\n        self._annotation_clip = None\n\n    def _get_xy(self, xy, s, axes=None):\n        \"\"\"Calculate the pixel position of given point.\"\"\"\n        s0 = s  # For the error message, if needed.\n        if axes is None:\n            axes = self.axes\n\n        # preserve mixed type input (such as str, int)\n        x = np.array(xy[0])\n        y = np.array(xy[1])\n\n        fig = self.get_figure(root=False)\n        if s in [\"figure points\", \"axes points\"]:\n            x = x * fig.dpi / 72\n            y = y * fig.dpi / 72\n            s = s.replace(\"points\", \"pixels\")\n        elif s == \"figure fraction\":\n            s = fig.transFigure\n        elif s == \"subfigure fraction\":\n            s = fig.transSubfigure\n        elif s == \"axes fraction\":\n            s = axes.transAxes\n\n        if s == 'data':\n            trans = axes.transData\n            x = cbook._to_unmasked_float_array(axes.xaxis.convert_units(x))\n            y = cbook._to_unmasked_float_array(axes.yaxis.convert_units(y))\n            return trans.transform((x, y))\n        elif s == 'offset points':\n            if self.xycoords == 'offset points':  # prevent recursion\n                return self._get_xy(self.xy, 'data')\n            return (\n                self._get_xy(self.xy, self.xycoords)  # converted data point\n                + xy * self.get_figure(root=True).dpi / 72)  # converted offset\n        elif s == 'polar':\n            theta, r = x, y\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            trans = axes.transData\n            return trans.transform((x, y))\n        elif s == 'figure pixels':\n            # pixels from the lower left corner of the figure\n            bb = self.get_figure(root=False).figbbox\n            x = bb.x0 + x if x >= 0 else bb.x1 + x\n            y = bb.y0 + y if y >= 0 else bb.y1 + y\n            return x, y\n        elif s == 'subfigure pixels':\n            # pixels from the lower left corner of the figure\n  "}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "a':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, coords).transform((x, y))\n\n    def _get_xy_transform(self, renderer, coords):\n\n        if isinstance(coords, tuple):\n            xcoord, ycoord = coords\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, xcoord)\n            tr2 = self._get_xy_transform(renderer, ycoord)\n            return blended_transform_factory(tr1, tr2)\n        elif callable(coords):\n            tr = coords(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise TypeError(\n                    f\"xycoords callable must return a BboxBase or Transform, not a \"\n                    f\"{type(tr).__name__}\")\n        elif isinstance(coords, Artist):\n            bbox = coords.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(coords, BboxBase):\n            return BboxTransformTo(coords)\n        elif isinstance(coords, Transform):\n            return coords\n        elif not isinstance(coords, str):\n            raise TypeError(\n                f\"'xycoords' must be an instance of str, tuple[str, str], Artist, \"\n                f\"Transform, or Callable, not a {type(coords).__name__}\")\n\n        if coords == 'data':\n            return self.axes.transData\n        elif coords == 'polar':\n            from matplotlib.projections import PolarAxes\n            return PolarAxes.PolarTransform() + self.axes.transData\n\n        try:\n            bbox_name, unit = coords.split()\n        except ValueError:  # i.e. len(coords.split()) != 2.\n            raise ValueError(f\"{coords!r} is not a valid coordinate\") from None\n\n        bbox0, xy0 = None, None\n\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.get_figure(root=False).figbbox\n "}, {"start_line": 162000, "end_line": 164000, "belongs_to": {"file_name": "patches.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_float_array(axes.yaxis.convert_units(y))\n            return trans.transform((x, y))\n        elif s == 'offset points':\n            if self.xycoords == 'offset points':  # prevent recursion\n                return self._get_xy(self.xy, 'data')\n            return (\n                self._get_xy(self.xy, self.xycoords)  # converted data point\n                + xy * self.get_figure(root=True).dpi / 72)  # converted offset\n        elif s == 'polar':\n            theta, r = x, y\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            trans = axes.transData\n            return trans.transform((x, y))\n        elif s == 'figure pixels':\n            # pixels from the lower left corner of the figure\n            bb = self.get_figure(root=False).figbbox\n            x = bb.x0 + x if x >= 0 else bb.x1 + x\n            y = bb.y0 + y if y >= 0 else bb.y1 + y\n            return x, y\n        elif s == 'subfigure pixels':\n            # pixels from the lower left corner of the figure\n            bb = self.get_figure(root=False).bbox\n            x = bb.x0 + x if x >= 0 else bb.x1 + x\n            y = bb.y0 + y if y >= 0 else bb.y1 + y\n            return x, y\n        elif s == 'axes pixels':\n            # pixels from the lower left corner of the Axes\n            bb = axes.bbox\n            x = bb.x0 + x if x >= 0 else bb.x1 + x\n            y = bb.y0 + y if y >= 0 else bb.y1 + y\n            return x, y\n        elif isinstance(s, transforms.Transform):\n            return s.transform(xy)\n        else:\n            raise ValueError(f\"{s0} is not a valid coordinate transformation\")\n\n    def set_annotation_clip(self, b):\n        \"\"\"\n        Set the annotation's clipping behavior.\n\n        Parameters\n        ----------\n        b : bool or None\n            - True: The annotation will be clipped when ``self.xy`` is\n              outside the Axes.\n            - False: The annotation will always be drawn.\n            - None: The annotation will be clipped when ``self.xy`` is\n       "}, {"start_line": 50000, "end_line": 52000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".width * xf\n            y = bbox.y0 + bbox.height * yf\n        elif isinstance(self._artist, Transform):\n            x, y = self._artist.transform(self._ref_coord)\n        else:\n            _api.check_isinstance((Artist, BboxBase, Transform), artist=self._artist)\n        scale = 1 if self._unit == \"pixels\" else renderer.points_to_pixels(1)\n        return Affine2D().scale(scale).translate(x, y)\n\n\nclass _AnnotationBase:\n    def __init__(self,\n                 xy,\n                 xycoords='data',\n                 annotation_clip=None):\n\n        x, y = xy  # Make copy when xy is an array (and check the shape).\n        self.xy = x, y\n        self.xycoords = xycoords\n        self.set_annotation_clip(annotation_clip)\n\n        self._draggable = None\n\n    def _get_xy(self, renderer, xy, coords):\n        x, y = xy\n        xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n        if xcoord == 'data':\n            x = float(self.convert_xunits(x))\n        if ycoord == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, coords).transform((x, y))\n\n    def _get_xy_transform(self, renderer, coords):\n\n        if isinstance(coords, tuple):\n            xcoord, ycoord = coords\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, xcoord)\n            tr2 = self._get_xy_transform(renderer, ycoord)\n            return blended_transform_factory(tr1, tr2)\n        elif callable(coords):\n            tr = coords(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise TypeError(\n                    f\"xycoords callable must return a BboxBase or Transform, not a \"\n                    f\"{type(tr).__name__}\")\n        elif isinstance(coords, Artist):\n            bbox = coords.get_window_extent(renderer)\n          "}, {"start_line": 49000, "end_line": 51000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ts', 'pixels'}\n        \"\"\"\n        _api.check_in_list([\"points\", \"pixels\"], unit=unit)\n        self._unit = unit\n\n    def get_unit(self):\n        \"\"\"Return the unit for input to the transform used by ``__call__``.\"\"\"\n        return self._unit\n\n    def __call__(self, renderer):\n        \"\"\"\n        Return the offset transform.\n\n        Parameters\n        ----------\n        renderer : `RendererBase`\n            The renderer to use to compute the offset\n\n        Returns\n        -------\n        `Transform`\n            Maps (x, y) in pixel or point units to screen units\n            relative to the given artist.\n        \"\"\"\n        if isinstance(self._artist, Artist):\n            bbox = self._artist.get_window_extent(renderer)\n            xf, yf = self._ref_coord\n            x = bbox.x0 + bbox.width * xf\n            y = bbox.y0 + bbox.height * yf\n        elif isinstance(self._artist, BboxBase):\n            bbox = self._artist\n            xf, yf = self._ref_coord\n            x = bbox.x0 + bbox.width * xf\n            y = bbox.y0 + bbox.height * yf\n        elif isinstance(self._artist, Transform):\n            x, y = self._artist.transform(self._ref_coord)\n        else:\n            _api.check_isinstance((Artist, BboxBase, Transform), artist=self._artist)\n        scale = 1 if self._unit == \"pixels\" else renderer.points_to_pixels(1)\n        return Affine2D().scale(scale).translate(x, y)\n\n\nclass _AnnotationBase:\n    def __init__(self,\n                 xy,\n                 xycoords='data',\n                 annotation_clip=None):\n\n        x, y = xy  # Make copy when xy is an array (and check the shape).\n        self.xy = x, y\n        self.xycoords = xycoords\n        self.set_annotation_clip(annotation_clip)\n\n        self._draggable = None\n\n    def _get_xy(self, renderer, xy, coords):\n        x, y = xy\n        xcoord, ycoord = coords if isinstance(coords, tuple) else (coords, coords)\n        if xcoord == 'data':\n            x = float(self.convert_xunits(x))\n        if ycoord == 'dat"}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_int]\n                buf += f10 * ac[A.shape[1]:][idx_int]\n                buf += f01 * ac[1:][idx_int]\n                buf += f11 * ac[A.shape[1] + 1:][idx_int]\n                im[:, :, chan] = buf  # Implicitly casts to uint8.\n        return im, l, b, IdentityTransform()\n\n    def set_data(self, x, y, A):\n        \"\"\"\n        Set the grid for the pixel centers, and the pixel values.\n\n        Parameters\n        ----------\n        x, y : 1D array-like\n            Monotonic arrays of shapes (N,) and (M,), respectively, specifying\n            pixel centers.\n        A : array-like\n            (M, N) `~numpy.ndarray` or masked array of values to be\n            colormapped, or (M, N, 3) RGB array, or (M, N, 4) RGBA array.\n        \"\"\"\n        A = self._normalize_image_array(A)\n        x = np.array(x, np.float32)\n        y = np.array(y, np.float32)\n        if not (x.ndim == y.ndim == 1 and A.shape[:2] == y.shape + x.shape):\n            raise TypeError(\"Axes don't match array shape\")\n        self._A = A\n        self._Ax = x\n        self._Ay = y\n        self._imcache = None\n        self.stale = True\n\n    def set_array(self, *args):\n        raise NotImplementedError('Method not supported')\n\n    def set_interpolation(self, s):\n        \"\"\"\n        Parameters\n        ----------\n        s : {'nearest', 'bilinear'} or None\n            If None, use :rc:`image.interpolation`.\n        \"\"\"\n        if s is not None and s not in ('nearest', 'bilinear'):\n            raise NotImplementedError('Only nearest neighbor and '\n                                      'bilinear interpolations are supported')\n        super().set_interpolation(s)\n\n    def get_extent(self):\n        if self._A is None:\n            raise RuntimeError('Must set data first')\n        return self._Ax[0], self._Ax[-1], self._Ay[0], self._Ay[-1]\n\n    def set_filternorm(self, filternorm):\n        pass\n\n    def set_filterrad(self, filterrad):\n        pass\n\n    def set_norm(self, norm):\n        if self._A is not None:\n           "}, {"start_line": 43000, "end_line": 45000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rted(y_pix) - 1, 0, len(self._Ay) - 2)\n            idx_int = np.add.outer(y_int * A.shape[1], x_int)\n            x_frac = np.clip(\n                np.divide(x_pix - self._Ax[x_int], np.diff(self._Ax)[x_int],\n                          dtype=np.float32),  # Downcasting helps with speed.\n                0, 1)\n            y_frac = np.clip(\n                np.divide(y_pix - self._Ay[y_int], np.diff(self._Ay)[y_int],\n                          dtype=np.float32),\n                0, 1)\n            f00 = np.outer(1 - y_frac, 1 - x_frac)\n            f10 = np.outer(y_frac, 1 - x_frac)\n            f01 = np.outer(1 - y_frac, x_frac)\n            f11 = np.outer(y_frac, x_frac)\n            im = np.empty((height, width, 4), np.uint8)\n            for chan in range(4):\n                ac = A[:, :, chan].reshape(-1)  # reshape(-1) avoids a copy.\n                # Shifting the buffer start (`ac[offset:]`) avoids an array\n                # addition (`ac[idx_int + offset]`).\n                buf = f00 * ac[idx_int]\n                buf += f10 * ac[A.shape[1]:][idx_int]\n                buf += f01 * ac[1:][idx_int]\n                buf += f11 * ac[A.shape[1] + 1:][idx_int]\n                im[:, :, chan] = buf  # Implicitly casts to uint8.\n        return im, l, b, IdentityTransform()\n\n    def set_data(self, x, y, A):\n        \"\"\"\n        Set the grid for the pixel centers, and the pixel values.\n\n        Parameters\n        ----------\n        x, y : 1D array-like\n            Monotonic arrays of shapes (N,) and (M,), respectively, specifying\n            pixel centers.\n        A : array-like\n            (M, N) `~numpy.ndarray` or masked array of values to be\n            colormapped, or (M, N, 3) RGB array, or (M, N, 4) RGBA array.\n        \"\"\"\n        A = self._normalize_image_array(A)\n        x = np.array(x, np.float32)\n        y = np.array(y, np.float32)\n        if not (x.ndim == y.ndim == 1 and A.shape[:2] == y.shape + x.shape):\n            raise TypeError(\"Axes don't match array shape\")\n        se"}, {"start_line": 125000, "end_line": 127000, "belongs_to": {"file_name": "widgets.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "selection_artist.get_bbox().bounds\n\n    def _set_aspect_ratio_correction(self):\n        aspect_ratio = self.ax._get_aspect_ratio()\n        self._selection_artist._aspect_ratio_correction = aspect_ratio\n        if self._use_data_coordinates:\n            self._aspect_ratio_correction = 1\n        else:\n            self._aspect_ratio_correction = aspect_ratio\n\n    def _get_rotation_transform(self):\n        aspect_ratio = self.ax._get_aspect_ratio()\n        return Affine2D().translate(-self.center[0], -self.center[1]) \\\n                .scale(1, aspect_ratio) \\\n                .rotate(self._rotation) \\\n                .scale(1, 1 / aspect_ratio) \\\n                .translate(*self.center)\n\n    @property\n    def corners(self):\n        \"\"\"\n        Corners of rectangle in data coordinates from lower left,\n        moving clockwise.\n        \"\"\"\n        x0, y0, width, height = self._rect_bbox\n        xc = x0, x0 + width, x0 + width, x0\n        yc = y0, y0, y0 + height, y0 + height\n        transform = self._get_rotation_transform()\n        coords = transform.transform(np.array([xc, yc]).T).T\n        return coords[0], coords[1]\n\n    @property\n    def edge_centers(self):\n        \"\"\"\n        Midpoint of rectangle edges in data coordinates from left,\n        moving anti-clockwise.\n        \"\"\"\n        x0, y0, width, height = self._rect_bbox\n        w = width / 2.\n        h = height / 2.\n        xe = x0, x0 + w, x0 + width, x0 + w\n        ye = y0 + h, y0, y0 + h, y0 + height\n        transform = self._get_rotation_transform()\n        coords = transform.transform(np.array([xe, ye]).T).T\n        return coords[0], coords[1]\n\n    @property\n    def center(self):\n        \"\"\"Center of rectangle in data coordinates.\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        return x0 + width / 2., y0 + height / 2.\n\n    @property\n    def extents(self):\n        \"\"\"\n        Return (xmin, xmax, ymin, ymax) in data coordinates as defined by the\n        bounding box before rotation.\n        \"\"\"\n    "}], "retrieved_count": 10, "cost_time": 3.6935324668884277}
{"question": "How does the TextArea.get_text() method's delegation pattern to self._text.get_text() enable framework-agnostic text retrieval while maintaining compatibility with matplotlib's text rendering API?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " The\n    width and height of the TextArea instance is the width and height of its\n    child text.\n    \"\"\"\n\n    def __init__(self, s,\n                 *,\n                 textprops=None,\n                 multilinebaseline=False,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            The text to be displayed.\n        textprops : dict, default: {}\n            Dictionary of keyword parameters to be passed to the `.Text`\n            instance in the TextArea.\n        multilinebaseline : bool, default: False\n            Whether the baseline for multiline text is adjusted so that it\n            is (approximately) center-aligned with single-line text.\n        \"\"\"\n        if textprops is None:\n            textprops = {}\n        self._text = mtext.Text(0, 0, s, **textprops)\n        super().__init__()\n        self._children = [self._text]\n        self.offset_transform = mtransforms.Affine2D()\n        self._baseline_transform = mtransforms.Affine2D()\n        self._text.set_transform(self.offset_transform +\n                                 self._baseline_transform)\n        self._multilinebaseline = multilinebaseline\n\n    def set_text(self, s):\n        \"\"\"Set the text of this area as a string.\"\"\"\n        self._text.set_text(s)\n        self.stale = True\n\n    def get_text(self):\n        \"\"\"Return the string representation of this area's text.\"\"\"\n        return self._text.get_text()\n\n    def set_multilinebaseline(self, t):\n        \"\"\"\n        Set multilinebaseline.\n\n        If True, the baseline for multiline text is adjusted so that it is\n        (approximately) center-aligned with single-line text.  This is used\n        e.g. by the legend implementation so that single-line labels are\n        baseline-aligned, but multiline labels are \"center\"-aligned with them.\n        \"\"\"\n        self._multilinebaseline = t\n        self.stale = True\n\n    def get_multilinebaseline(self):\n        \"\"\"\n        Get multilinebaseline.\n        \"\"\"\n        return"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ef draw(self, renderer):\n        # docstring inherited\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        self.dpi_transform.clear()\n        self.dpi_transform.scale(dpi_cor)\n\n        # At this point the DrawingArea has a transform\n        # to the display space so the path created is\n        # good for clipping children\n        tpath = mtransforms.TransformedPath(\n            mpath.Path([[0, 0], [0, self.height],\n                        [self.width, self.height],\n                        [self.width, 0]]),\n            self.get_transform())\n        for c in self._children:\n            if self._clip_children and not (c.clipbox or c._clippath):\n                c.set_clip_path(tpath)\n            c.draw(renderer)\n\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass TextArea(OffsetBox):\n    \"\"\"\n    The TextArea is a container artist for a single Text instance.\n\n    The text is placed at (0, 0) with baseline+left alignment, by default. The\n    width and height of the TextArea instance is the width and height of its\n    child text.\n    \"\"\"\n\n    def __init__(self, s,\n                 *,\n                 textprops=None,\n                 multilinebaseline=False,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            The text to be displayed.\n        textprops : dict, default: {}\n            Dictionary of keyword parameters to be passed to the `.Text`\n            instance in the TextArea.\n        multilinebaseline : bool, default: False\n            Whether the baseline for multiline text is adjusted so that it\n            is (approximately) center-aligned with single-line text.\n        \"\"\"\n        if textprops is None:\n            textprops = {}\n        self._text = mtext.Text(0, 0, s, **textprops)\n        super().__init__()\n        self._children = [self._text]\n        self.offset_transform = mtransforms.Affine2D()\n        self._baseline_transform = mtransforms.Affine2D()\n     "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " locations.\n        x = float(self.convert_xunits(self._x))\n        y = float(self.convert_yunits(self._y))\n        return x, y\n\n    def get_position(self):\n        \"\"\"Return the (x, y) position of the text.\"\"\"\n        # This should return the same data (possible unitized) as was\n        # specified with 'set_x' and 'set_y'.\n        return self._x, self._y\n\n    def get_text(self):\n        \"\"\"Return the text string.\"\"\"\n        return self._text\n\n    def get_verticalalignment(self):\n        \"\"\"\n        Return the vertical alignment as a string.  Will be one of\n        'top', 'center', 'bottom', 'baseline' or 'center_baseline'.\n        \"\"\"\n        return self._verticalalignment\n\n    def get_window_extent(self, renderer=None, dpi=None):\n        \"\"\"\n        Return the `.Bbox` bounding the text, in display units.\n\n        In addition to being used internally, this is useful for specifying\n        clickable regions in a png file on a web page.\n\n        Parameters\n        ----------\n        renderer : Renderer, optional\n            A renderer is needed to compute the bounding box.  If the artist\n            has already been drawn, the renderer is cached; thus, it is only\n            necessary to pass this argument when calling `get_window_extent`\n            before the first draw.  In practice, it is usually easier to\n            trigger a draw first, e.g. by calling\n            `~.Figure.draw_without_rendering` or ``plt.show()``.\n\n        dpi : float, optional\n            The dpi value for computing the bbox, defaults to\n            ``self.get_figure(root=True).dpi`` (*not* the renderer dpi); should be set\n            e.g. if to match regions with a figure saved with a custom dpi value.\n        \"\"\"\n        if not self.get_visible():\n            return Bbox.unit()\n\n        fig = self.get_figure(root=True)\n        if dpi is None:\n            dpi = fig.dpi\n        if self.get_text() == '':\n            with cbook._setattr_cm(fig, dpi=dpi):\n                tx, ty = self._get_xy"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n\n                if self.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line,\n                                          self._fontproperties, angle,\n                                          mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line,\n                                           self._fontproperties, angle,\n                                           ismath=ismath, mtext=mtext)\n\n        gc.restore()\n        renderer.close_group('text')\n        self.stale = False\n\n    def get_color(self):\n        \"\"\"Return the color of the text.\"\"\"\n        return self._color\n\n    def get_fontproperties(self):\n        \"\"\"Return the `.font_manager.FontProperties`.\"\"\"\n        return self._fontproperties\n\n    def get_fontfamily(self):\n        \"\"\"\n        Return the list of font families used for font lookup.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_family\n        \"\"\"\n        return self._fontproperties.get_family()\n\n    def get_fontname(self):\n        \"\"\"\n        Return the font name as a string.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_name\n        \"\"\"\n        return self._fontproperties.get_name()\n\n    def get_fontstyle(self):\n        \"\"\"\n        Return the font style as a string.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_style\n        \"\"\"\n        return self._fontproperties.get_style()\n\n    def get_fontsize(self):\n        \"\"\"\n        Return the font size as an integer.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_size_in_points\n        \"\"\"\n        return self._fontproperties.get_size_in_points()\n\n    def get_fontvariant(self):\n        \"\"\"\n        Return the font variant as a string.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_variant\n    "}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   self._text.set_transform(self.offset_transform +\n                                 self._baseline_transform)\n        self._multilinebaseline = multilinebaseline\n\n    def set_text(self, s):\n        \"\"\"Set the text of this area as a string.\"\"\"\n        self._text.set_text(s)\n        self.stale = True\n\n    def get_text(self):\n        \"\"\"Return the string representation of this area's text.\"\"\"\n        return self._text.get_text()\n\n    def set_multilinebaseline(self, t):\n        \"\"\"\n        Set multilinebaseline.\n\n        If True, the baseline for multiline text is adjusted so that it is\n        (approximately) center-aligned with single-line text.  This is used\n        e.g. by the legend implementation so that single-line labels are\n        baseline-aligned, but multiline labels are \"center\"-aligned with them.\n        \"\"\"\n        self._multilinebaseline = t\n        self.stale = True\n\n    def get_multilinebaseline(self):\n        \"\"\"\n        Get multilinebaseline.\n        \"\"\"\n        return self._multilinebaseline\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"Return offset of the container.\"\"\"\n        return self._offset\n\n    def get_bbox(self, renderer):\n        _, h_, d_ = mtext._get_text_metrics_with_cache(\n            renderer, \"lp\", self._text._fontproperties,\n            ismath=\"TeX\" if self._text.get_usetex() else False,\n            dpi=self.get_figure(root=True).dpi)\n\n        bbox, info, yd = self._text._get_layout(renderer)\n        w, h = bbox.size\n\n        self._baseline_transform.clear()\n\n        if len(info) > "}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e Text._get_layout() call, which is\n    # called within the _get_textbox. So, it would better to move this\n    # function as a method with some refactoring of _get_layout method.\n\n    projected_xs = []\n    projected_ys = []\n\n    theta = np.deg2rad(text.get_rotation())\n    tr = Affine2D().rotate(-theta)\n\n    _, parts, d = text._get_layout(renderer)\n\n    for t, wh, x, y in parts:\n        w, h = wh\n\n        xt1, yt1 = tr.transform((x, y))\n        yt1 -= d\n        xt2, yt2 = xt1 + w, yt1 + h\n\n        projected_xs.extend([xt1, xt2])\n        projected_ys.extend([yt1, yt2])\n\n    xt_box, yt_box = min(projected_xs), min(projected_ys)\n    w_box, h_box = max(projected_xs) - xt_box, max(projected_ys) - yt_box\n\n    x_box, y_box = Affine2D().rotate(theta).transform((xt_box, yt_box))\n\n    return x_box, y_box, w_box, h_box\n\n\ndef _get_text_metrics_with_cache(renderer, text, fontprop, ismath, dpi):\n    \"\"\"Call ``renderer.get_text_width_height_descent``, caching the results.\"\"\"\n    # Cached based on a copy of fontprop so that later in-place mutations of\n    # the passed-in argument do not mess up the cache.\n    return _get_text_metrics_with_cache_impl(\n        weakref.ref(renderer), text, fontprop.copy(), ismath, dpi)\n\n\n@functools.lru_cache(4096)\ndef _get_text_metrics_with_cache_impl(\n        renderer_ref, text, fontprop, ismath, dpi):\n    # dpi is unused, but participates in cache invalidation (via the renderer).\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n\n\n@_docstring.interpd\n@_api.define_aliases({\n    \"color\": [\"c\"],\n    \"fontproperties\": [\"font\", \"font_properties\"],\n    \"fontfamily\": [\"family\"],\n    \"fontname\": [\"name\"],\n    \"fontsize\": [\"size\"],\n    \"fontstretch\": [\"stretch\"],\n    \"fontstyle\": [\"style\"],\n    \"fontvariant\": [\"variant\"],\n    \"fontweight\": [\"weight\"],\n    \"horizontalalignment\": [\"ha\"],\n    \"verticalalignment\": [\"va\"],\n    \"multialignment\": [\"ma\"],\n})\nclass Text(Artist):\n    \"\"\"Handle storing and drawing of text in window or data "}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e\n                    line = ' '.join(sub_words[:i])\n                    current_width = self._get_rendered_text_width(line)\n\n                    # If all these words are too wide, append all not including\n                    # last word\n                    if current_width > line_width:\n                        wrapped_lines.append(' '.join(sub_words[:i - 1]))\n                        sub_words = sub_words[i - 1:]\n                        break\n\n                    # Otherwise if all words fit in the width, append them all\n                    elif i == len(sub_words):\n                        wrapped_lines.append(' '.join(sub_words[:i]))\n                        sub_words = []\n                        break\n\n        return '\\n'.join(wrapped_lines)\n\n    @artist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if self.get_text() == '':\n            return\n\n        renderer.open_group('text', self.get_gid())\n\n        with self._cm_set(text=self._get_wrapped_text()):\n            bbox, info, descent = self._get_layout(renderer)\n            trans = self.get_transform()\n\n            # don't use self.get_position here, which refers to text\n            # position in Text:\n            x, y = self._x, self._y\n            if np.ma.is_masked(x):\n                x = np.nan\n            if np.ma.is_masked(y):\n                y = np.nan\n            posx = float(self.convert_xunits(x))\n            posy = float(self.convert_yunits(y))\n            posx, posy = trans.transform((posx, posy))\n            if np.isnan(posx) or np.isnan(posy):\n                return  # don't throw a warning here\n            if not np.isfinite(posx) or not np.isfinite(posy):\n                _log.warning(\"posx and posy should be finite values\")\n                return\n            canvasw, canvash = renderer.get_canvas_width_height()\n\n            # Update "}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "the location and size of the bbox\n            # (`.patches.FancyBboxPatch`), and draw it.\n            if self._bbox_patch:\n                self.update_bbox_position_size(renderer)\n                self._bbox_patch.draw(renderer)\n\n            gc = renderer.new_gc()\n            gc.set_foreground(self.get_color())\n            gc.set_alpha(self.get_alpha())\n            gc.set_url(self._url)\n            gc.set_antialiased(self._antialiased)\n            self._set_gc_clip(gc)\n\n            angle = self.get_rotation()\n\n            for line, wh, x, y in info:\n\n                mtext = self if len(info) == 1 else None\n                x = x + posx\n                y = y + posy\n                if renderer.flipy():\n                    y = canvash - y\n                clean_line, ismath = self._preprocess_math(line)\n\n                if self.get_path_effects():\n                    from matplotlib.patheffects import PathEffectRenderer\n                    textrenderer = PathEffectRenderer(\n                        self.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n\n                if self.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line,\n                                          self._fontproperties, angle,\n                                          mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line,\n                                           self._fontproperties, angle,\n                                           ismath=ismath, mtext=mtext)\n\n        gc.restore()\n        renderer.close_group('text')\n        self.stale = False\n\n    def get_color(self):\n        \"\"\"Return the color of the text.\"\"\"\n        return self._color\n\n    def get_fontproperties(self):\n        \"\"\"Return the `.font_manager.FontProperties`.\"\"\"\n        return self._fontproperties\n\n    def get_fontfamily(self):\n        \"\"\"\n        Return the list of font families used for font lookup.\n\n        See Als"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rm_angles(\n                [self._rotation], [self.get_unitless_position()]).item(0)\n        else:\n            return self._rotation\n\n    def get_transform_rotates_text(self):\n        \"\"\"\n        Return whether rotations of the transform affect the text direction.\n        \"\"\"\n        return self._transform_rotates_text\n\n    def set_rotation_mode(self, m):\n        \"\"\"\n        Set text rotation mode.\n\n        Parameters\n        ----------\n        m : {None, 'default', 'anchor', 'xtick', 'ytick'}\n            If ``\"default\"``, the text will be first rotated, then aligned according\n            to their horizontal and vertical alignments.  If ``\"anchor\"``, then\n            alignment occurs before rotation. \"xtick\" and \"ytick\" adjust the\n            horizontal/vertical alignment so that the text is visually pointing\n            towards its anchor point. This is primarily used for rotated tick\n            labels and positions them nicely towards their ticks. Passing\n            ``None`` will set the rotation mode to ``\"default\"``.\n        \"\"\"\n        if m is None:\n            m = \"default\"\n        else:\n            _api.check_in_list((\"anchor\", \"default\", \"xtick\", \"ytick\"), rotation_mode=m)\n        self._rotation_mode = m\n        self.stale = True\n\n    def get_rotation_mode(self):\n        \"\"\"Return the text rotation mode.\"\"\"\n        return self._rotation_mode\n\n    def set_antialiased(self, antialiased):\n        \"\"\"\n        Set whether to use antialiased rendering.\n\n        Parameters\n        ----------\n        antialiased : bool\n\n        Notes\n        -----\n        Antialiasing will be determined by :rc:`text.antialiased`\n        and the parameter *antialiased* will have no effect if the text contains\n        math expressions.\n        \"\"\"\n        self._antialiased = antialiased\n        self.stale = True\n\n    def get_antialiased(self):\n        \"\"\"Return whether antialiased rendering is used.\"\"\"\n        return self._antialiased\n\n    def update_from(self, other):\n        # doc"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        # Not fit to handle breaking up latex syntax correctly, so\n        # ignore latex for now.\n        if self.get_usetex():\n            return self.get_text()\n\n        # Build the line incrementally, for a more accurate measure of length\n        line_width = self._get_wrap_line_width()\n        wrapped_lines = []\n\n        # New lines in the user's text force a split\n        unwrapped_lines = self.get_text().split('\\n')\n\n        # Now wrap each individual unwrapped line\n        for unwrapped_line in unwrapped_lines:\n\n            sub_words = unwrapped_line.split(' ')\n            # Remove items from sub_words as we go, so stop when empty\n            while len(sub_words) > 0:\n                if len(sub_words) == 1:\n                    # Only one word, so just add it to the end\n                    wrapped_lines.append(sub_words.pop(0))\n                    continue\n\n                for i in range(2, len(sub_words) + 1):\n                    # Get width of all words up to and including here\n                    line = ' '.join(sub_words[:i])\n                    current_width = self._get_rendered_text_width(line)\n\n                    # If all these words are too wide, append all not including\n                    # last word\n                    if current_width > line_width:\n                        wrapped_lines.append(' '.join(sub_words[:i - 1]))\n                        sub_words = sub_words[i - 1:]\n                        break\n\n                    # Otherwise if all words fit in the width, append them all\n                    elif i == len(sub_words):\n                        wrapped_lines.append(' '.join(sub_words[:i]))\n                        sub_words = []\n                        break\n\n        return '\\n'.join(wrapped_lines)\n\n    @artist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if self.get_text() ="}], "retrieved_count": 10, "cost_time": 3.691087245941162}
{"question": "How should the `contains` method in `OffsetBox` be refactored to decouple the canvas validation logic from the child delegation logic while maintaining testability of each responsibility?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        for c in self.get_children():\n            if c is not None:\n                c.axes = ax\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Delegate the mouse event contains-check to the children.\n\n        As a container, the `.OffsetBox` does not respond itself to\n        mouseevents.\n\n        Parameters\n        ----------\n        mouseevent : `~matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n\n        See Also\n        --------\n        .Artist.contains\n        \"\"\"\n        if self._different_canvas(mouseevent):\n            return False, {}\n        for c in self.get_children():\n            a, b = c.contains(mouseevent)\n            if a:\n                return a, b\n        return False, {}\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset.\n\n        Parameters\n        ----------\n        xy : (float, float) or callable\n            The (x, y) coordinates of the offset in display units. These can\n            either be given explicitly as a tuple (x, y), or by providing a\n            function that converts the extent into the offset. This function\n            must have the signature::\n\n                def offset(width, height, xdescent, ydescent, renderer) \\\n-> (float, float)\n        \"\"\"\n        self._offset = xy\n        self.stale = True\n\n    @_compat_get_offset\n    def get_offset(self, bbox, renderer):\n        \"\"\"\n        Return the offset as a tuple (x, y).\n\n        The extent parameters have to be provided to handle the case where the\n        offset is dynamically determined by a callable (see\n        `~.OffsetBox.set_offset`).\n\n        Parameters\n        ----------\n        bbox : `.Bbox`\n        renderer : `.RendererBas"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tainer artist.\n\n    The child artists are meant to be drawn at a relative position to its\n    parent.\n\n    Being an artist itself, all keyword arguments are passed on to `.Artist`.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        self._internal_update(kwargs)\n        # Clipping has not been implemented in the OffsetBox family, so\n        # disable the clip flag for consistency. It can always be turned back\n        # on to zero effect.\n        self.set_clip_on(False)\n        self._children = []\n        self._offset = (0, 0)\n\n    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` for the `.OffsetBox` and all its children.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n        \"\"\"\n        super().set_figure(fig)\n        for c in self.get_children():\n            c.set_figure(fig)\n\n    @martist.Artist.axes.setter\n    def axes(self, ax):\n        # TODO deal with this better\n        martist.Artist.axes.fset(self, ax)\n        for c in self.get_children():\n            if c is not None:\n                c.axes = ax\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Delegate the mouse event contains-check to the children.\n\n        As a container, the `.OffsetBox` does not respond itself to\n        mouseevents.\n\n        Parameters\n        ----------\n        mouseevent : `~matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n\n        See Also\n        --------\n        .Artist.contains\n        \"\"\"\n        if self._different_canvas(mouseevent):\n            return False, {}\n        for c in self.get_children():\n            a, b = c.contains(mouseevent)\n            if a:\n                r"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ses should start their definition of `contains` as follows::\n\n            if self._different_canvas(mouseevent):\n                return False, {}\n            # subclass-specific implementation follows\n        \"\"\"\n        return (getattr(event, \"canvas\", None) is not None\n                and (fig := self.get_figure(root=True)) is not None\n                and event.canvas is not fig.canvas)\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the artist contains the mouse event.\n\n        Parameters\n        ----------\n        mouseevent : `~matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n        \"\"\"\n        _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n        return False, {}\n\n    def pickable(self):\n        \"\"\"\n        Return whether the artist is pickable.\n\n        See Also\n        --------\n        .Artist.set_picker, .Artist.get_picker, .Artist.pick\n        \"\"\"\n        return self.get_figure(root=False) is not None and self._picker is not None\n\n    def pick(self, mouseevent):\n        \"\"\"\n        Process a pick event.\n\n        Each child artist will fire a pick event if *mouseevent* is over\n        the artist and the artist has picker set.\n\n        See Also\n        --------\n        .Artist.set_picker, .Artist.get_picker, .Artist.pickable\n        \"\"\"\n        from .backend_bases import PickEvent  # Circular import.\n        # Pick self\n        if self.pickable():\n            picker = self.get_picker()\n            if callable(picker):\n                inside, prop = picker(self, mouseevent)\n            else:\n                inside, prop = self.contains(mouseevent)\n            if inside:\n                PickEvent"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "init__()\n        self.width = width\n        self.height = height\n        self.xdescent = xdescent\n        self.ydescent = ydescent\n        self._clip_children = clip\n        self.offset_transform = mtransforms.Affine2D()\n        self.dpi_transform = mtransforms.Affine2D()\n\n    @property\n    def clip_children(self):\n        \"\"\"\n        If the children of this DrawingArea should be clipped\n        by DrawingArea bounding box.\n        \"\"\"\n        return self._clip_children\n\n    @clip_children.setter\n    def clip_children(self, val):\n        self._clip_children = bool(val)\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"\n        Return the `~matplotlib.transforms.Transform` applied to the children.\n        \"\"\"\n        return self.dpi_transform + self.offset_transform\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"Return offset of the container.\"\"\"\n        return self._offset\n\n    def get_bbox(self, renderer):\n        # docstring inherited\n        dpi_cor = renderer.points_to_pixels(1.)\n        return Bbox.from_bounds(\n            -self.xdescent * dpi_cor, -self.ydescent * dpi_cor,\n            self.width * dpi_cor, self.height * dpi_cor)\n\n    def add_artist(self, a):\n        \"\"\"Add an `.Artist` to the container box.\"\"\"\n        self._children.append(a)\n        if not a.is_transform_set():\n            a.set_transform(self.get_transform())\n        if self.axes is not None:\n            a.axes = self.axes\n        fig = self.get_figure(root=False)\n        if fig is not None:\n            a.set_figure(fig)\n\n    d"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e` subclass\n        \"\"\"\n        return (\n            self._offset(bbox.width, bbox.height, -bbox.x0, -bbox.y0, renderer)\n            if callable(self._offset)\n            else self._offset)\n\n    def set_width(self, width):\n        \"\"\"\n        Set the width of the box.\n\n        Parameters\n        ----------\n        width : float\n        \"\"\"\n        self.width = width\n        self.stale = True\n\n    def set_height(self, height):\n        \"\"\"\n        Set the height of the box.\n\n        Parameters\n        ----------\n        height : float\n        \"\"\"\n        self.height = height\n        self.stale = True\n\n    def get_visible_children(self):\n        r\"\"\"Return a list of the visible child `.Artist`\\s.\"\"\"\n        return [c for c in self._children if c.get_visible()]\n\n    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s.\"\"\"\n        return self._children\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        \"\"\"\n        Return the bbox of the offsetbox and the child offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n\n    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n        bbox = self.get_bbox(renderer)\n        try:  # Some subclasses redefine get_offset to take no args.\n            px, py = self.get_offset(bbox, renderer)\n        except TypeError:\n            px, py = self.get_offset()\n        return bbox.translated(px, py)\n\n  "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ntinel)\n        ret.extend(super().update(kwargs))\n        if bbox is not sentinel:\n            ret.append(self.set_bbox(bbox))\n        return ret\n\n    def __getstate__(self):\n        d = super().__getstate__()\n        # remove the cached _renderer (if it exists)\n        d['_renderer'] = None\n        return d\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Return whether the mouse event occurred inside the axis-aligned\n        bounding-box of the text.\n        \"\"\"\n        if (self._different_canvas(mouseevent) or not self.get_visible()\n                or self._renderer is None):\n            return False, {}\n        # Explicitly use Text.get_window_extent(self) and not\n        # self.get_window_extent() so that Annotation.contains does not\n        # accidentally cover the entire annotation bounding box.\n        bbox = Text.get_window_extent(self)\n        inside = (bbox.x0 <= mouseevent.x <= bbox.x1\n                  and bbox.y0 <= mouseevent.y <= bbox.y1)\n        cattr = {}\n        # if the text has a surrounding patch, also check containment for it,\n        # and merge the results with the results for the text.\n        if self._bbox_patch:\n            patch_inside, patch_cattr = self._bbox_patch.contains(mouseevent)\n            inside = inside or patch_inside\n            cattr[\"bbox_patch\"] = patch_cattr\n        return inside, cattr\n\n    def _get_xy_display(self):\n        \"\"\"\n        Get the (possibly unit converted) transformed x, y in display coords.\n        \"\"\"\n        x, y = self.get_unitless_position()\n        return self.get_transform().transform((x, y))\n\n    def _get_multialignment(self):\n        if self._multialignment is not None:\n            return self._multialignment\n        else:\n            return self._horizontalalignment\n\n    def _char_index_at(self, x):\n        \"\"\"\n        Calculate the index closest to the coordinate x in display space.\n\n        The position of text[index] is assumed to be the sum of the widths\n        of all preceding cha"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n        self.stale = True\n\n    def draw_frame(self, renderer):\n        # update the location and size of the legend\n        self.update_frame(self.get_window_extent(renderer))\n        self.patch.draw(renderer)\n\n\nclass DrawingArea(OffsetBox):\n    \"\"\"\n    The DrawingArea can contain any Artist as a child. The DrawingArea\n    has a fixed width and height. The position of children relative to\n    the parent is fixed. The children can be clipped at the\n    boundaries of the parent.\n    \"\"\"\n\n    def __init__(self, width, height, xdescent=0., ydescent=0., clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        width, height : float\n            Width and height of the container box.\n        xdescent, ydescent : float\n            Descent of the box in x- and y-direction.\n        clip : bool\n            Whether to clip the children to the box.\n        \"\"\"\n        super().__init__()\n        self.width = width\n        self.height = height\n        self.xdescent = xdescent\n        self.ydescent = ydescent\n        self._clip_children = clip\n        self.offset_transform = mtransforms.Affine2D()\n        self.dpi_transform = mtransforms.Affine2D()\n\n    @property\n    def clip_children(self):\n        \"\"\"\n        If the children of this DrawingArea should be clipped\n        by DrawingArea bounding box.\n        \"\"\"\n        return self._clip_children\n\n    @clip_children.setter\n    def clip_children(self, val):\n        self._clip_children = bool(val)\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"\n        Return the `~matplotlib.transforms.Transform` applied to the children.\n        \"\"\"\n        return self.dpi_transform + self.offset_transform\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "collections.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "en(), paths, self.get_transforms())\n                    for xo, yo, path_id, gc0, rgbFace in renderer._iter_collection(\n                        gc, list(path_ids), *args, hatchcolors=self.get_hatchcolor(),\n                    ):\n                        path, transform = path_id\n                        if xo != 0 or yo != 0:\n                            transform = transform.frozen()\n                            transform.translate(xo, yo)\n                        renderer.draw_path(gc0, path, transform, rgbFace)\n\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False\n\n    def set_pickradius(self, pickradius):\n        \"\"\"\n        Set the pick radius used for containment tests.\n\n        Parameters\n        ----------\n        pickradius : float\n            Pick radius, in points.\n        \"\"\"\n        if not isinstance(pickradius, Real):\n            raise ValueError(\n                f\"pickradius must be a real-valued number, not {pickradius!r}\")\n        self._pickradius = pickradius\n\n    def get_pickradius(self):\n        return self._pickradius\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred in the collection.\n\n        Returns ``bool, dict(ind=itemlist)``, where every item in itemlist\n        contains the event.\n        \"\"\"\n        if self._different_canvas(mouseevent) or not self.get_visible():\n            return False, {}\n        pickradius = (\n            float(self._picker)\n            if isinstance(self._picker, Number) and\n               self._picker is not True  # the bool, not just nonzero or 1\n            else self._pickradius)\n        if self.axes:\n            self.axes._unstale_viewLim()\n        transform, offset_trf, offsets, paths = self._prepare_points()\n        # Tests if the point is contained on one of the polygons formed\n        # by the control points of each of the paths. A point is considered\n        # \"on\" a path if it would lie within a stroke of width 2*pickr"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ght=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=1,  # self.prop.get_size_in_points(),\n            snap=True,\n            visible=draw_frame,\n            boxstyle=\"square,pad=0\",\n        )\n        if patch_attrs is not None:\n            self.patch.update(patch_attrs)\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited.\n        pad = self.pad * renderer.points_to_pixels(1.)\n        return (self._children[0].get_bbox(renderer).padded(pad), [(0, 0)])\n\n    def draw(self, renderer):\n        # docstring inherited\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n\n        self.draw_frame(renderer)\n\n        for c in self.get_visible_children():\n            c.draw(renderer)\n\n        self.stale = False\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n        self.stale = True\n\n    def draw_frame(self, renderer):\n        # update the location and size of the legend\n        self.update_frame(self.get_window_extent(renderer))\n        self.patch.draw(renderer)\n\n\nclass DrawingArea(OffsetBox):\n    \"\"\"\n    The DrawingArea can contain any Artist as a child. The DrawingArea\n    has a fixed width and height. The position of children relative to\n    the parent is fixed. The children can be clipped at the\n    boundaries of the parent.\n    \"\"\"\n\n    def __init__(self, width, height, xdescent=0., ydescent=0., clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        width, height : float\n            Width and height of the container box.\n        xdescent, ydescent : float\n            Descent of the box in x- and y-direction.\n        clip : bool\n            Whether to clip the children to the box.\n        \"\"\"\n        super().__"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "elled out by the later offsetting.)\n\n    `AuxTransformBox` is similar to `.DrawingArea`, except that the extent of\n    the box is not predetermined but calculated from the window extent of its\n    children, and the extent of the children will be calculated in the\n    transformed coordinate.\n    \"\"\"\n    def __init__(self, aux_transform):\n        self.aux_transform = aux_transform\n        super().__init__()\n        self.offset_transform = mtransforms.Affine2D()\n        # ref_offset_transform makes offset_transform always relative to the\n        # lower-left corner of the bbox of its children.\n        self.ref_offset_transform = mtransforms.Affine2D()\n\n    def add_artist(self, a):\n        \"\"\"Add an `.Artist` to the container box.\"\"\"\n        self._children.append(a)\n        a.set_transform(self.get_transform())\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"Return the `.Transform` applied to the children.\"\"\"\n        return (self.aux_transform\n                + self.ref_offset_transform\n                + self.offset_transform)\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"Return offset of the container.\"\"\"\n        return self._offset\n\n    def get_bbox(self, renderer):\n        # clear the offset transforms\n        _off = self.offset_transform.get_matrix()  # to be restored later\n        self.ref_offset_transform.clear()\n        self.offset_transform.clear()\n        # calculate the extent\n        bboxes = [c.get_window_extent(renderer) for c in self._children]\n        ub = Bbox.union(bboxes)\n        # adj"}], "retrieved_count": 10, "cost_time": 3.7224316596984863}
{"question": "How does the _Style class leverage __new__ method interception combined with string parsing to implement a factory pattern that defers style instantiation until runtime, and what are the implications of this design choice on error handling for malformed style specifications?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 77000, "end_line": 79000, "belongs_to": {"file_name": "patches.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e_and_accepts)s\n        # - %(ConnectionStyle:table_and_accepts)s\n        # - %(ArrowStyle:table_and_accepts)s\n        _docstring.interpd.register(**{\n            f\"{cls.__name__}:table\": cls.pprint_styles(),\n            f\"{cls.__name__}:table_and_accepts\": (\n                cls.pprint_styles()\n                + \"\\n\\n    .. ACCEPTS: [\"\n                + \"|\".join(map(\" '{}' \".format, cls._style_list))\n                + \"]\")\n        })\n\n    def __new__(cls, stylename, **kwargs):\n        \"\"\"Return the instance of the subclass with the given style name.\"\"\"\n        # The \"class\" should have the _style_list attribute, which is a mapping\n        # of style names to style classes.\n        _list = stylename.replace(\" \", \"\").split(\",\")\n        _name = _list[0].lower()\n        try:\n            _cls = cls._style_list[_name]\n        except KeyError as err:\n            raise ValueError(f\"Unknown style: {stylename!r}\") from err\n        try:\n            _args_pair = [cs.split(\"=\") for cs in _list[1:]]\n            _args = {k: float(v) for k, v in _args_pair}\n        except ValueError as err:\n            raise ValueError(\n                f\"Incorrect style argument: {stylename!r}\") from err\n        return _cls(**{**_args, **kwargs})\n\n    @classmethod\n    def get_styles(cls):\n        \"\"\"Return a dictionary of available styles.\"\"\"\n        return cls._style_list\n\n    @classmethod\n    def pprint_styles(cls):\n        \"\"\"Return the available styles as pretty-printed string.\"\"\"\n        table = [('Class', 'Name', 'Parameters'),\n                 *[(cls.__name__,\n                    # Add backquotes, as - and | have special meaning in reST.\n                    f'``{name}``',\n                    # [1:-1] drops the surrounding parentheses.\n                    str(inspect.signature(cls))[1:-1] or 'None')\n                   for name, cls in cls._style_list.items()]]\n        # Convert to rst table.\n        col_len = [max(len(cell) for cell in column) for column in zip(*table)]\n        table_formatst"}, {"start_line": 78000, "end_line": 80000, "belongs_to": {"file_name": "patches.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n            _args = {k: float(v) for k, v in _args_pair}\n        except ValueError as err:\n            raise ValueError(\n                f\"Incorrect style argument: {stylename!r}\") from err\n        return _cls(**{**_args, **kwargs})\n\n    @classmethod\n    def get_styles(cls):\n        \"\"\"Return a dictionary of available styles.\"\"\"\n        return cls._style_list\n\n    @classmethod\n    def pprint_styles(cls):\n        \"\"\"Return the available styles as pretty-printed string.\"\"\"\n        table = [('Class', 'Name', 'Parameters'),\n                 *[(cls.__name__,\n                    # Add backquotes, as - and | have special meaning in reST.\n                    f'``{name}``',\n                    # [1:-1] drops the surrounding parentheses.\n                    str(inspect.signature(cls))[1:-1] or 'None')\n                   for name, cls in cls._style_list.items()]]\n        # Convert to rst table.\n        col_len = [max(len(cell) for cell in column) for column in zip(*table)]\n        table_formatstr = '  '.join('=' * cl for cl in col_len)\n        rst_table = '\\n'.join([\n            '',\n            table_formatstr,\n            '  '.join(cell.ljust(cl) for cell, cl in zip(table[0], col_len)),\n            table_formatstr,\n            *['  '.join(cell.ljust(cl) for cell, cl in zip(row, col_len))\n              for row in table[1:]],\n            table_formatstr,\n        ])\n        return textwrap.indent(rst_table, prefix=' ' * 4)\n\n    @classmethod\n    @_api.deprecated(\n        '3.10.0',\n        message=\"This method is never used internally.\",\n        alternative=\"No replacement.  Please open an issue if you use this.\"\n    )\n    def register(cls, name, style):\n        \"\"\"Register a new style.\"\"\"\n        if not issubclass(style, cls._Base):\n            raise ValueError(f\"{style} must be a subclass of {cls._Base}\")\n        cls._style_list[name] = style\n\n\ndef _register_style(style_list, cls=None, *, name=None):\n    \"\"\"Class decorator that stashes a class in a (style) dictionary.\"\"\"\n    if"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/style", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cification:\n\n    %s\n    \"\"\"\n    if isinstance(style, (str, Path)) or hasattr(style, 'keys'):\n        # If name is a single str, Path or dict, make it a single element list.\n        styles = [style]\n    else:\n        styles = style\n\n    style_alias = {'mpl20': 'default', 'mpl15': 'classic'}\n\n    for style in styles:\n        if isinstance(style, str):\n            style = style_alias.get(style, style)\n            if style == \"default\":\n                # Deprecation warnings were already handled when creating\n                # rcParamsDefault, no need to reemit them here.\n                with _api.suppress_matplotlib_deprecation_warning():\n                    # don't trigger RcParams.__getitem__('backend')\n                    style = {k: rcParamsDefault[k] for k in rcParamsDefault\n                             if k not in _STYLE_BLACKLIST}\n            elif style in library:\n                style = library[style]\n            elif \".\" in style:\n                pkg, _, name = style.rpartition(\".\")\n                try:\n                    path = importlib.resources.files(pkg) / f\"{name}.{_STYLE_EXTENSION}\"\n                    style = rc_params_from_file(path, use_default_template=False)\n                except (ModuleNotFoundError, OSError, TypeError) as exc:\n                    # There is an ambiguity whether a dotted name refers to a\n                    # package.style_name or to a dotted file path.  Currently,\n                    # we silently try the first form and then the second one;\n                    # in the future, we may consider forcing file paths to\n                    # either use Path objects or be prepended with \"./\" and use\n                    # the slash as marker for file paths.\n                    pass\n        if isinstance(style, (str, Path)):\n            try:\n                style = rc_params_from_file(style, use_default_template=False)\n            except OSError as err:\n                raise OSError(\n                    f\"{style!r} is not a valid packa"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/style", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e.available` (a builtin style or\n              a style installed in the user library path).\n\n            - A dotted name of the form \"package.style_name\"; in that case,\n              \"package\" should be an importable Python package name, e.g. at\n              ``/path/to/package/__init__.py``; the loaded style file is\n              ``/path/to/package/style_name.mplstyle``.  (Style files in\n              subpackages are likewise supported.)\n\n            - The path or URL to a style file, which gets loaded by\n              `.rc_params_from_file`.\n\n        dict\n            A mapping of key/value pairs for `matplotlib.rcParams`.\n\n        Path\n            The path to a style file, which gets loaded by\n            `.rc_params_from_file`.\n\n        list\n            A list of style specifiers (str, Path or dict), which are applied\n            from first to last in the list.\n\n    Notes\n    -----\n    The following `.rcParams` are not related to style and will be ignored if\n    found in a style specification:\n\n    %s\n    \"\"\"\n    if isinstance(style, (str, Path)) or hasattr(style, 'keys'):\n        # If name is a single str, Path or dict, make it a single element list.\n        styles = [style]\n    else:\n        styles = style\n\n    style_alias = {'mpl20': 'default', 'mpl15': 'classic'}\n\n    for style in styles:\n        if isinstance(style, str):\n            style = style_alias.get(style, style)\n            if style == \"default\":\n                # Deprecation warnings were already handled when creating\n                # rcParamsDefault, no need to reemit them here.\n                with _api.suppress_matplotlib_deprecation_warning():\n                    # don't trigger RcParams.__getitem__('backend')\n                    style = {k: rcParamsDefault[k] for k in rcParamsDefault\n                             if k not in _STYLE_BLACKLIST}\n            elif style in library:\n                style = library[style]\n            elif \".\" in style:\n                pkg, _, name = style.rpartition("}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "er. This is expressed by\n    returning 'None' for the respective quantity.\n\n    See Also\n    --------\n    matplotlib.Line2D.lineStyles, matplotlib.colors.cnames\n        All possible styles and color format strings.\n    \"\"\"\n\n    linestyle = None\n    marker = None\n    color = None\n\n    # First check whether fmt is just a colorspec, but specifically exclude the\n    # grayscale string \"1\" (not \"1.0\"), which is interpreted as the tri_down\n    # marker \"1\".  The grayscale string \"0\" could be unambiguously understood\n    # as a color (black) but also excluded for consistency.\n    if fmt not in [\"0\", \"1\"]:\n        try:\n            color = mcolors.to_rgba(fmt)\n            return linestyle, marker, color\n        except ValueError:\n            pass\n\n    errfmt = (\"{!r} is neither a data key nor a valid format string ({})\"\n              if ambiguous_fmt_datakey else\n              \"{!r} is not a valid format string ({})\")\n\n    i = 0\n    while i < len(fmt):\n        c = fmt[i]\n        if fmt[i:i+2] in mlines.lineStyles:  # First, the two-char styles.\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = fmt[i:i+2]\n            i += 2\n        elif c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = c\n            i += 1\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(errfmt.format(fmt, \"two marker symbols\"))\n            marker = c\n            i += 1\n        elif c in mcolors.get_named_colors_mapping():\n            if color is not None:\n                raise ValueError(errfmt.format(fmt, \"two color symbols\"))\n            color = c\n            i += 1\n        elif c == \"C\":\n            cn_color = re.match(r\"C\\d+\", fmt[i:])\n            if not cn_color:\n                raise ValueError(errfmt.format(fmt, \"'C' must be followed by a number"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/style", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " dotted name of the form \"package.style_name\"; in that case,\n              \"package\" should be an importable Python package name, e.g. at\n              ``/path/to/package/__init__.py``; the loaded style file is\n              ``/path/to/package/style_name.mplstyle``.  (Style files in\n              subpackages are likewise supported.)\n\n            - The path or URL to a style file, which gets loaded by\n              `.rc_params_from_file`.\n        dict\n            A mapping of key/value pairs for `matplotlib.rcParams`.\n\n        Path\n            The path to a style file, which gets loaded by\n            `.rc_params_from_file`.\n\n        list\n            A list of style specifiers (str, Path or dict), which are applied\n            from first to last in the list.\n\n    after_reset : bool\n        If True, apply style after resetting settings to their defaults;\n        otherwise, apply style on top of the current settings.\n    \"\"\"\n    with mpl.rc_context():\n        if after_reset:\n            mpl.rcdefaults()\n        use(style)\n        yield\n\n\ndef _update_user_library(library):\n    \"\"\"Update style library with user-defined rc files.\"\"\"\n    for stylelib_path in map(os.path.expanduser, USER_LIBRARY_PATHS):\n        styles = _read_style_directory(stylelib_path)\n        _update_nested_dict(library, styles)\n    return library\n\n\n@_api.deprecated(\"3.11\")\ndef update_user_library(library):\n    return _update_user_library(library)\n\n\ndef _read_style_directory(style_dir):\n    \"\"\"Return dictionary of styles defined in *style_dir*.\"\"\"\n    styles = dict()\n    for path in Path(style_dir).glob(f\"*.{_STYLE_EXTENSION}\"):\n        with warnings.catch_warnings(record=True) as warns:\n            styles[path.stem] = rc_params_from_file(path, use_default_template=False)\n        for w in warns:\n            _log.warning('In %s: %s', path, w.message)\n    return styles\n\n\n@_api.deprecated(\"3.11\")\ndef read_style_directory(style_dir):\n    return _read_style_directory(style_dir)\n\n\ndef _update_nested_dict(mai"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/style", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\".\")\n                try:\n                    path = importlib.resources.files(pkg) / f\"{name}.{_STYLE_EXTENSION}\"\n                    style = rc_params_from_file(path, use_default_template=False)\n                except (ModuleNotFoundError, OSError, TypeError) as exc:\n                    # There is an ambiguity whether a dotted name refers to a\n                    # package.style_name or to a dotted file path.  Currently,\n                    # we silently try the first form and then the second one;\n                    # in the future, we may consider forcing file paths to\n                    # either use Path objects or be prepended with \"./\" and use\n                    # the slash as marker for file paths.\n                    pass\n        if isinstance(style, (str, Path)):\n            try:\n                style = rc_params_from_file(style, use_default_template=False)\n            except OSError as err:\n                raise OSError(\n                    f\"{style!r} is not a valid package style, path of style \"\n                    f\"file, URL of style file, or library style name (library \"\n                    f\"styles are listed in `style.available`)\") from err\n        filtered = {}\n        for k in style:  # don't trigger RcParams.__getitem__('backend')\n            if k in _STYLE_BLACKLIST:\n                _api.warn_external(\n                    f\"Style includes a parameter, {k!r}, that is not \"\n                    f\"related to style.  Ignoring this parameter.\")\n            else:\n                filtered[k] = style[k]\n        mpl.rcParams.update(filtered)\n\n\n@contextlib.contextmanager\ndef context(style, after_reset=False):\n    \"\"\"\n    Context manager for using style settings temporarily.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        str\n            - One of the style names in `.style.available` (a builtin style or\n              a style installed in the user library path).\n\n            - A"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "instance(s, str):\n        s = s.lower()\n    if s in ('none', None, 'false', False):\n        return None\n    else:\n        return ValidateInStrings('ps.usedistiller', ['ghostscript', 'xpdf'])(s)\n\n\n# A validator dedicated to the named line styles, based on the items in\n# ls_mapper, and a list of possible strings read from Line2D.set_linestyle\n_validate_named_linestyle = ValidateInStrings(\n    'linestyle',\n    [*ls_mapper.keys(), *ls_mapper.values(), 'None', 'none', ' ', ''],\n    ignorecase=True)\n\n\ndef _validate_linestyle(ls):\n    \"\"\"\n    A validator for all possible line styles, the named ones *and*\n    the on-off ink sequences.\n    \"\"\"\n    if isinstance(ls, str):\n        try:  # Look first for a valid named line style, like '--' or 'solid'.\n            return _validate_named_linestyle(ls)\n        except ValueError:\n            pass\n        try:\n            ls = ast.literal_eval(ls)  # Parsing matplotlibrc.\n        except (SyntaxError, ValueError):\n            pass  # Will error with the ValueError at the end.\n\n    def _is_iterable_not_string_like(x):\n        # Explicitly exclude bytes/bytearrays so that they are not\n        # nonsensically interpreted as sequences of numbers (codepoints).\n        return np.iterable(x) and not isinstance(x, (str, bytes, bytearray))\n\n    if _is_iterable_not_string_like(ls):\n        if len(ls) == 2 and _is_iterable_not_string_like(ls[1]):\n            # (offset, (on, off, on, off, ...))\n            offset, onoff = ls\n        else:\n            # For backcompat: (on, off, on, off, ...); the offset is implicit.\n            offset = 0\n            onoff = ls\n\n        if (isinstance(offset, Real)\n                and len(onoff) % 2 == 0\n                and all(isinstance(elem, Real) for elem in onoff)):\n            return (offset, onoff)\n\n    raise ValueError(f\"linestyle {ls!r} is not a valid on-off ink sequence.\")\n\n\ndef _validate_linestyle_or_None(s):\n    if s is None or cbook._str_equal(s, \"None\"):\n        return None\n\n    return _validate_li"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "raise ValueError(f'{s!r} is neither a color sequence name nor can '\n                             'it be interpreted as a list of colors')\n\n    return colors\n\n\n@lru_cache\ndef _listify_validator(scalar_validator, allow_stringlist=False, *,\n                       n=None, doc=None):\n    def f(s):\n        if isinstance(s, str):\n            try:\n                val = [scalar_validator(v.strip()) for v in s.split(',')\n                       if v.strip()]\n            except Exception:\n                if allow_stringlist:\n                    # Special handling for colors\n                    val = _single_string_color_list(s, scalar_validator)\n                else:\n                    raise\n        # Allow any ordered sequence type -- generators, np.ndarray, pd.Series\n        # -- but not sets, whose iteration order is non-deterministic.\n        elif np.iterable(s) and not isinstance(s, (set, frozenset)):\n            # The condition on this list comprehension will preserve the\n            # behavior of filtering out any empty strings (behavior was\n            # from the original validate_stringlist()), while allowing\n            # any non-string/text scalar values such as numbers and arrays.\n            val = [scalar_validator(v) for v in s\n                   if not isinstance(v, str) or v]\n        else:\n            raise ValueError(\n                f\"Expected str or other non-set iterable, but got {s}\")\n        if n is not None and len(val) != n:\n            raise ValueError(\n                f\"Expected {n} values, but there are {len(val)} values in {s}\")\n        return val\n\n    try:\n        f.__name__ = f\"{scalar_validator.__name__}list\"\n    except AttributeError:  # class instance.\n        f.__name__ = f\"{type(scalar_validator).__name__}List\"\n    f.__qualname__ = f.__qualname__.rsplit(\".\", 1)[0] + \".\" + f.__name__\n    f.__doc__ = doc if doc is not None else scalar_validator.__doc__\n    return f\n\n\ndef validate_any(s):\n    return s\nvalidate_anylist = _listify_validator(valida"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n    if weight not in weight_dict:\n        weight = 'normal'\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif any(word in fontname for word in ['narrow', 'cond']):\n        stretch = 'condensed'\n    elif any(word in fontname for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)\n\n\ndef _cleanup_fontproperties_init(init_method):\n    \"\"\"\n    A decorator to limit the call signature to single a positional argument\n    or alternatively only keyword arguments.\n\n    We still accept but deprecate all other call signatures.\n\n    When the deprecation expires we can switch the signature to::\n\n        __init__(self, pattern=None, /, *, family=None, style=None, ...)\n\n    plus a runtime check that pattern is not used alongside with the\n    keyword arguments. Th"}], "retrieved_count": 10, "cost_time": 3.8083903789520264}
{"question": "How does the LightSource class coordinate the transformation of azimuth and elevation angles through the direction property to ensure correct light vector computation across different blend modes that depend on this directional information?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 125000, "end_line": 127000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n        See the documentation for `blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    @property\n    def direction(self):\n        \"\"\"The unit vector direction towards the light source.\"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n        return np.array([\n            np.cos(az) * np.cos(alt),\n            np.sin(az) * np.cos(alt),\n            np.sin(alt)\n        ])\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculate the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        This computes the normal vectors for the surface, and then passes them\n        on to `shade_normals`\n\n        Parameters\n        ----------\n        elevation : 2D array-like\n            The height values used to generate an illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid"}, {"start_line": 124000, "end_line": 126000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : float, default: 315 degrees (from the northwest)\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source.\n        altdeg : float, default: 45 degrees\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.\n        hsv_min_val : number, default: 0\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_max_val : number, default: 1\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_min_sat : number, default: 1\n            The minimum saturation value that the *intensity* map can shift the output\n            image to.\n        hsv_max_sat : number, default: 0\n            The maximum saturation value that the *intensity* map can shift the output\n            image to.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n        See the documentation for `blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    @property\n    def direction(self):\n        \"\"\"The unit vector direction towards the light source.\"\"\"\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n        return np.array([\n            np.cos(az) * np.cos(alt),\n            np.sin(az) * np.c"}, {"start_line": 123000, "end_line": 125000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e(arr):\n    # things that don't work here:\n    #  * np.linalg.norm: drops mask from ma.array\n    #  * np.sum: drops mask from ma.array unless entire vector is masked\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += arr[..., i, np.newaxis] ** 2\n    return np.sqrt(sum_sq)\n\n\nclass LightSource:\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    `shade` is used to produce \"shaded\" RGB values for a data array.\n    `shade_rgb` can be used to combine an RGB image with an elevation map.\n    `hillshade` produces an illumination map of a surface.\n    \"\"\"\n\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : float, default: 315 degrees (from the northwest)\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source.\n        altdeg : float, default: 45 degrees\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.\n        hsv_min_val : number, default: 0\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_max_val : number, default: 1\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift the\n            output image to.\n        hsv_min_sat : number, default: 1\n            The minimum saturation value that the *intensity* map can shift the output\n            image to.\n        hsv_max_sat : number, default: 0\n            The maximum saturation value that the *intensity* map can shift the output\n            image to.\n\n        Notes\n   "}, {"start_line": 134000, "end_line": 136000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "te the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            (M, N, 3) RGB array of floats (ranging 0 to 1) with an (M, N, 1)\n            hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate syste"}, {"start_line": 122000, "end_line": 124000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".float32),  # Don't work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.stack([r, g, b], axis=-1)\n\n    return rgb.reshape(in_shape)\n\n\ndef _vector_magnitude(arr):\n    # things that don't work here:\n    #  * np.linalg.norm: drops mask from ma.array\n    #  * np.sum: drops mask from ma.array unless entire vector is masked\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += arr[..., i, np.newaxis] ** 2\n    return np.sqrt(sum_sq)\n\n\nclass LightSource:\n    \"\"\"\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    `shade` is used to produce \"shaded\" RGB values for a data array.\n    `shade_rgb` can be used to combine an RGB image with an elevation map.\n    `hillshade` produces an illumination map of a surface.\n    \"\"\"\n\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of"}, {"start_line": 126000, "end_line": 128000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "os(alt),\n            np.sin(alt)\n        ])\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculate the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        This computes the normal vectors for the surface, and then passes them\n        on to `shade_normals`\n\n        Parameters\n        ----------\n        elevation : 2D array-like\n            The height values used to generate an illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            A 2D array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        # compute the normal vectors from the partial derivatives\n        e_dy, e_d"}, {"start_line": 128000, "end_line": 130000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "x = np.gradient(vert_exag * elevation, dy, dx)\n\n        # .view is to keep subclasses\n        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n        normal[..., 0] = -e_dx\n        normal[..., 1] = -e_dy\n        normal[..., 2] = 1\n        normal /= _vector_magnitude(normal)\n\n        return self.shade_normals(normal, fraction)\n\n    def shade_normals(self, normals, fraction=1.):\n        \"\"\"\n        Calculate the illumination intensity for the normal vectors of a\n        surface using the defined azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            A 2D array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        intensity = normals.dot(self.direction)\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # i"}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "test_colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n\n        # Make a plane at a range of angles to the illumination\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))\n\n\ndef test_color_names():\n    assert mcolors.to_hex(\"blue\") == \"#0000ff\"\n    assert mcolors.to_hex(\"xkcd:blue\") == \"#0343df\"\n    assert mcolors.to_hex(\"tab:blue\") == \"#1f77b4\"\n\n\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z\n\n\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi\n\n\ndef test_pandas_iterable(pd):\n    # Using a list or series yields equivalent\n    # colormaps, i.e the series isn't seen as\n    # a single color\n    lst = ['red', 'blue', 'green']\n    s = pd.Series(lst)\n    cm1 = mcolors.ListedColormap(lst)\n    cm2 = mcolors.ListedColormap(s)\n    assert_array_equal(cm1.colors, cm2.colors)\n\n\n@pytest.mark.parametrize('name', sorted(mpl.colormaps()))\ndef test_colormap_reversing(name):\n    \"\"\"\n    Check the generated _lut data of a colormap and corresponding reversed\n    colormap if they are almost the same.\n    \"\"\"\n    cmap = mpl.colormaps[name]\n    cmap_r = cmap.reversed()\n    if not cmap_r._isinit:\n        cmap._init()\n        cmap_r._init()\n    assert_array_almost_equal(cm"}, {"start_line": 136000, "end_line": 138000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of '\n                                 f'{lookup.keys}') from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if np.ma.is_masked(intensity):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot th"}, {"start_line": 133000, "end_line": 135000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "reases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (M, N, 4) array of floats ranging between 0-1.\n        \"\"\"\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical "}], "retrieved_count": 10, "cost_time": 3.865147829055786}
{"question": "How does the get_offset method compute the final pixel offset by integrating borderpad unpacking, fontsize conversion, and the _get_anchored_bbox algorithm to position the child box relative to its anchor point?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "pixels = renderer.points_to_pixels(self.prop.get_size_in_points())\n        try:\n            borderpad_x, borderpad_y = self.borderpad\n        except TypeError:\n            borderpad_x = self.borderpad\n            borderpad_y = self.borderpad\n        pad_x_pixels = borderpad_x * fontsize_in_pixels\n        pad_y_pixels = borderpad_y * fontsize_in_pixels\n        bbox_to_anchor = self.get_bbox_to_anchor()\n        x0, y0 = _get_anchored_bbox(\n            self.loc,\n            Bbox.from_bounds(0, 0, bbox.width, bbox.height),\n            bbox_to_anchor,\n            pad_x_pixels,\n            pad_y_pixels\n        )\n        return x0 - bbox.x0, y0 - bbox.y0\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n\n        # update the location and size of the legend\n        bbox = self.get_window_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self.update_frame(bbox, fontsize)\n        self.patch.draw(renderer)\n\n        px, py = self.get_offset(self.get_bbox(renderer), renderer)\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False\n\n\ndef _get_anchored_bbox(loc, bbox, parentbbox, pad_x, pad_y):\n    \"\"\"\n    Return the (x, y) position of the *bbox* anchored at the *parentbbox* with\n    the *loc* code with the *borderpad* and padding *pad_x*, *pad_y*.\n    \"\"\"\n    # This is only called internally and *loc* should already have been\n    # validated.  If 0 (None), we just let ``bbox.anchored`` raise.\n    c = [None, \"NE\", \"NW\", \"SW\", \"SE\", \"E\", \"W\", \"E\", \"S\", \"N\", \"C\"][loc]\n    container = parentbbox.padded(-pad_x, -pad_y)\n    return bbox.anchored(c, container=container).p0\n\n\nclass AnchoredText(AnchoredOffsetbox):\n    \"\"\"\n    AnchoredOffsetbox with Text.\n"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "Padding between the offsetbox frame and the *bbox_to_anchor*.\n            If a float, the same padding is used for both x and y.\n            If a tuple of two floats, it specifies the (x, y) padding.\n\n            .. versionadded:: 3.11\n               The *borderpad* parameter now accepts a tuple of (x, y) paddings.\n        child : `.OffsetBox`\n            The box that will be anchored.\n        prop : `.FontProperties`\n            This is only used as a reference for paddings. If not given,\n            :rc:`legend.fontsize` is used.\n        frameon : bool\n            Whether to draw a frame around the box.\n        bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n            Box that is used to position the legend in conjunction with *loc*.\n        bbox_transform : None or :class:`matplotlib.transforms.Transform`\n            The transform for the bounding box (*bbox_to_anchor*).\n        **kwargs\n            All other parameters are passed on to `.OffsetBox`.\n\n        Notes\n        -----\n        See `.Legend` for a detailed description of the anchoring mechanism.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        if isinstance(loc, str):\n            loc = _api.check_getitem(self.codes, loc=loc)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=mpl.rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True,\n            visible=frameon,\n            boxstyle=\"square,pad=0\",\n        )\n\n    def"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ld offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n\n    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n        bbox = self.get_bbox(renderer)\n        try:  # Some subclasses redefine get_offset to take no args.\n            px, py = self.get_offset(bbox, renderer)\n        except TypeError:\n            px, py = self.get_offset()\n        return bbox.translated(px, py)\n\n    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass PackerBase(OffsetBox):\n    def __init__(self, pad=0., sep=0., width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\", children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, default: 0.0\n            The boundary padding in points.\n\n        sep : float, default: 0.0\n            The spacing between items in points.\n\n        width, height : float, optional\n            Width and height of the container box in pixels, calculated if\n    "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     -----\n        See `.Legend` for a detailed description of the anchoring mechanism.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        if isinstance(loc, str):\n            loc = _api.check_getitem(self.codes, loc=loc)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=mpl.rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True,\n            visible=frameon,\n            boxstyle=\"square,pad=0\",\n        )\n\n    def set_child(self, child):\n        \"\"\"Set the child to be anchored.\"\"\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True\n\n    def get_child(self):\n        \"\"\"Return the child.\"\"\"\n        return self._child\n\n    def get_children(self):\n        \"\"\"Return the list of children.\"\"\"\n        return [self._child]\n\n    def get_bbox(self, renderer):\n        # docstring inherited\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return self.get_child().get_bbox(renderer).padded(pad)\n\n    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " textprops=prop)\n        fp = self.txt._text.get_fontproperties()\n        super().__init__(\n            loc, pad=pad, borderpad=borderpad, child=self.txt, prop=fp,\n            **kwargs)\n\n\nclass OffsetImage(OffsetBox):\n\n    def __init__(self, arr, *,\n                 zoom=1,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=True,\n                 filterrad=4.0,\n                 resample=False,\n                 dpi_cor=True,\n                 **kwargs\n                 ):\n\n        super().__init__()\n        self._dpi_cor = dpi_cor\n\n        self.image = BboxImage(bbox=self.get_window_extent,\n                               cmap=cmap,\n                               norm=norm,\n                               interpolation=interpolation,\n                               origin=origin,\n                               filternorm=filternorm,\n                               filterrad=filterrad,\n                               resample=resample,\n                               **kwargs\n                               )\n\n        self._children = [self.image]\n\n        self.set_zoom(zoom)\n        self.set_data(arr)\n\n    def set_data(self, arr):\n        self._data = np.asarray(arr)\n        self.image.set_data(self._data)\n        self.stale = True\n\n    def get_data(self):\n        return self._data\n\n    def set_zoom(self, zoom):\n        self._zoom = zoom\n        self.stale = True\n\n    def get_zoom(self):\n        return self._zoom\n\n    def get_offset(self):\n        \"\"\"Return offset of the container.\"\"\"\n        return self._offset\n\n    def get_children(self):\n        return [self.image]\n\n    def get_bbox(self, renderer):\n        dpi_cor = renderer.points_to_pixels(1.) if self._dpi_cor else 1.\n        zoom = self.get_zoom()\n        data = self.get_data()\n        ny, nx = data.shape[:2]\n        w, h = dpi_cor * nx * zoom, dpi_cor * ny * zoom\n        return Bbox.from_bounds(0, 0, w, h)\n\n    def draw"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ust ref_offset_transform\n        self.ref_offset_transform.translate(-ub.x0, -ub.y0)\n        # restore offset transform\n        self.offset_transform.set_matrix(_off)\n        return Bbox.from_bounds(0, 0, ub.width, ub.height)\n\n    def draw(self, renderer):\n        # docstring inherited\n        for c in self._children:\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass AnchoredOffsetbox(OffsetBox):\n    \"\"\"\n    An OffsetBox placed according to location *loc*.\n\n    AnchoredOffsetbox has a single child.  When multiple children are needed,\n    use an extra OffsetBox to enclose them.  By default, the offset box is\n    anchored against its parent Axes. You may explicitly specify the\n    *bbox_to_anchor*.\n    \"\"\"\n    zorder = 5  # zorder of the legend\n\n    # Location codes\n    codes = {'upper right': 1,\n             'upper left': 2,\n             'lower left': 3,\n             'lower right': 4,\n             'right': 5,\n             'center left': 6,\n             'center right': 7,\n             'lower center': 8,\n             'upper center': 9,\n             'center': 10,\n             }\n\n    def __init__(self, loc, *,\n                 pad=0.4, borderpad=0.5,\n                 child=None, prop=None, frameon=True,\n                 bbox_to_anchor=None,\n                 bbox_transform=None,\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        loc : str\n            The box location.  Valid locations are\n            'upper left', 'upper center', 'upper right',\n            'center left', 'center', 'center right',\n            'lower left', 'lower center', 'lower right'.\n            For backward compatibility, numeric values are accepted as well.\n            See the parameter *loc* of `.Legend` for details.\n        pad : float, default: 0.4\n            Padding around the child as fraction of the fontsize.\n        borderpad : float or (float, float), default: 0.5\n            "}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " set_child(self, child):\n        \"\"\"Set the child to be anchored.\"\"\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True\n\n    def get_child(self):\n        \"\"\"Return the child.\"\"\"\n        return self._child\n\n    def get_children(self):\n        \"\"\"Return the list of children.\"\"\"\n        return [self._child]\n\n    def get_bbox(self, renderer):\n        # docstring inherited\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return self.get_child().get_bbox(renderer).padded(pad)\n\n    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor, transform)\n\n    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the box is anchored to.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True\n\n    @_compat_get_offset\n    def get_offset(self, bbox, renderer):\n        # docstring inherited\n        fontsize_in_"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "box = self.get_window_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self.update_frame(bbox, fontsize)\n        self.patch.draw(renderer)\n\n        px, py = self.get_offset(self.get_bbox(renderer), renderer)\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False\n\n\ndef _get_anchored_bbox(loc, bbox, parentbbox, pad_x, pad_y):\n    \"\"\"\n    Return the (x, y) position of the *bbox* anchored at the *parentbbox* with\n    the *loc* code with the *borderpad* and padding *pad_x*, *pad_y*.\n    \"\"\"\n    # This is only called internally and *loc* should already have been\n    # validated.  If 0 (None), we just let ``bbox.anchored`` raise.\n    c = [None, \"NE\", \"NW\", \"SW\", \"SE\", \"E\", \"W\", \"E\", \"S\", \"N\", \"C\"][loc]\n    container = parentbbox.padded(-pad_x, -pad_y)\n    return bbox.anchored(c, container=container).p0\n\n\nclass AnchoredText(AnchoredOffsetbox):\n    \"\"\"\n    AnchoredOffsetbox with Text.\n    \"\"\"\n\n    def __init__(self, s, loc, *, pad=0.4, borderpad=0.5, prop=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            Text.\n\n        loc : str\n            Location code. See `AnchoredOffsetbox`.\n\n        pad : float, default: 0.4\n            Padding around the text as fraction of the fontsize.\n\n        borderpad : float, default: 0.5\n            Spacing between the offsetbox frame and the *bbox_to_anchor*.\n\n        prop : dict, optional\n            Dictionary of keyword parameters to be passed to the\n            `~matplotlib.text.Text` instance contained inside AnchoredText.\n\n        **kwargs\n            All other parameters are passed to `AnchoredOffsetbox`.\n        \"\"\"\n\n        if prop is None:\n            prop = {}\n        badkwargs = {'va', 'verticalalignment'}\n        if badkwargs & set(prop):\n            raise ValueError(\n                'Mixing verticalalignment with AnchoredText is not supported.')\n\n        self.txt = TextArea(s,"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e` subclass\n        \"\"\"\n        return (\n            self._offset(bbox.width, bbox.height, -bbox.x0, -bbox.y0, renderer)\n            if callable(self._offset)\n            else self._offset)\n\n    def set_width(self, width):\n        \"\"\"\n        Set the width of the box.\n\n        Parameters\n        ----------\n        width : float\n        \"\"\"\n        self.width = width\n        self.stale = True\n\n    def set_height(self, height):\n        \"\"\"\n        Set the height of the box.\n\n        Parameters\n        ----------\n        height : float\n        \"\"\"\n        self.height = height\n        self.stale = True\n\n    def get_visible_children(self):\n        r\"\"\"Return a list of the visible child `.Artist`\\s.\"\"\"\n        return [c for c in self._children if c.get_visible()]\n\n    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s.\"\"\"\n        return self._children\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        \"\"\"\n        Return the bbox of the offsetbox and the child offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n\n    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n        bbox = self.get_bbox(renderer)\n        try:  # Some subclasses redefine get_offset to take no args.\n            px, py = self.get_offset(bbox, renderer)\n        except TypeError:\n            px, py = self.get_offset()\n        return bbox.translated(px, py)\n\n  "}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "offset_transform\n                + self.offset_transform)\n\n    def set_transform(self, t):\n        \"\"\"\n        set_transform is ignored.\n        \"\"\"\n\n    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True\n\n    def get_offset(self):\n        \"\"\"Return offset of the container.\"\"\"\n        return self._offset\n\n    def get_bbox(self, renderer):\n        # clear the offset transforms\n        _off = self.offset_transform.get_matrix()  # to be restored later\n        self.ref_offset_transform.clear()\n        self.offset_transform.clear()\n        # calculate the extent\n        bboxes = [c.get_window_extent(renderer) for c in self._children]\n        ub = Bbox.union(bboxes)\n        # adjust ref_offset_transform\n        self.ref_offset_transform.translate(-ub.x0, -ub.y0)\n        # restore offset transform\n        self.offset_transform.set_matrix(_off)\n        return Bbox.from_bounds(0, 0, ub.width, ub.height)\n\n    def draw(self, renderer):\n        # docstring inherited\n        for c in self._children:\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass AnchoredOffsetbox(OffsetBox):\n    \"\"\"\n    An OffsetBox placed according to location *loc*.\n\n    AnchoredOffsetbox has a single child.  When multiple children are needed,\n    use an extra OffsetBox to enclose them.  By default, the offset box is\n    anchored against its parent Axes. You may explicitly specify the\n    *bbox_to_anchor*.\n    \"\"\"\n    zorder = 5  # zorder of the legend\n\n    # Location codes\n    codes = {'upper right': 1,\n             'upper left': 2,\n             'lower left': 3,\n             'lower right': 4,\n             'right'"}], "retrieved_count": 10, "cost_time": 3.8903157711029053}
{"question": "What is the semantic contract established by the LaTeX preamble configuration in test_font_bitstream_charter between the text rendering pipeline and the PDF backend's glyph subsetting mechanism?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "test_usetex.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "} is not a Type 1 font\"\n            )\n\n            # Subsetted font names have a 6-character tag followed by a '+'\n            base_font = str(font[\"/BaseFont\"]).removeprefix(\"/\")\n            assert re.match(r\"^[A-Z]{6}\\+\", base_font), (\n                f\"Font {font_name}={base_font} lacks a subset indicator tag\"\n            )\n            assert \"/FontFile\" in font.FontDescriptor, (\n                f\"Type 1 font {font_name}={base_font} is not embedded\"\n            )\n            _, original_name = base_font.split(\"+\", 1)\n            length[original_name] = len(bytes(font[\"/FontDescriptor\"][\"/FontFile\"]))\n\n    print(\"Embedded font stream lengths:\", length)\n    # We should have several fonts, each much smaller than the original.\n    # I get under 10kB on my system for each font, but allow 15kB in case\n    # of differences in the font files.\n    assert {\n        'CMEX10',\n        'CMMI12',\n        'CMR12',\n        'CMSY10',\n        'CMSY8',\n        'EUFM10',\n        'MSAM10',\n        'MSBM10',\n    }.issubset(length), \"Missing expected fonts in the PDF\"\n    for font_name, length in length.items():\n        assert length < 15_000, (\n            f\"Font {font_name}={length} is larger than expected\"\n        )\n\n    # For comparison, lengths without subsetting on my system:\n    #  'CMEX10': 29686\n    #  'CMMI12': 36176\n    #  'CMR12': 32157\n    #  'CMSY10': 32004\n    #  'CMSY8': 32061\n    #  'EUFM10': 20546\n    #  'MSAM10': 31199\n    #  'MSBM10': 34129\n\n\ntry:\n    _old_gs_version = mpl._get_executable_info('gs').version < parse_version('9.55')\nexcept mpl.ExecutableNotFoundError:\n    _old_gs_version = True\n\n\n@image_comparison(baseline_images=['rotation'], extensions=['eps', 'pdf', 'png', 'svg'],\n                  style='mpl20', tol=3.91 if _old_gs_version else 0)\ndef test_rotation():\n    mpl.rcParams['text.usetex'] = True\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax.set(xlim=(-0.5, 5), xticks=[], ylim=(-0.5, 3), yticks=[], frame_on=False)\n\n    text = {val: v"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_usetex.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e=None))\n    mpl.rcParams['text.usetex'] = True\n    fig, ax = plt.subplots()\n    ax.text(0.5, 0.5, 'hello')\n    with TemporaryFile() as tmpfile, pytest.raises(ValueError):\n        fig.savefig(tmpfile, format=fmt)\n\n\ndef test_pdf_type1_font_subsetting():\n    \"\"\"Test that fonts in PDF output are properly subset.\"\"\"\n    pikepdf = pytest.importorskip(\"pikepdf\")\n\n    mpl.rcParams[\"text.usetex\"] = True\n    mpl.rcParams[\"text.latex.preamble\"] = r\"\\usepackage{amssymb}\"\n    fig, ax = plt.subplots()\n    ax.text(0.2, 0.7, r\"$\\int_{-\\infty}^{\\aleph}\\sqrt{\\alpha\\beta\\gamma}\\mathrm{d}x$\")\n    ax.text(0.2, 0.5, r\"$\\mathfrak{x}\\circledcirc\\mathfrak{y}\\in\\mathbb{R}$\")\n\n    with TemporaryFile() as tmpfile:\n        fig.savefig(tmpfile, format=\"pdf\")\n        tmpfile.seek(0)\n        pdf = pikepdf.Pdf.open(tmpfile)\n\n        length = {}\n        page = pdf.pages[0]\n        for font_name, font in page.Resources.Font.items():\n            assert font.Subtype == \"/Type1\", (\n                f\"Font {font_name}={font} is not a Type 1 font\"\n            )\n\n            # Subsetted font names have a 6-character tag followed by a '+'\n            base_font = str(font[\"/BaseFont\"]).removeprefix(\"/\")\n            assert re.match(r\"^[A-Z]{6}\\+\", base_font), (\n                f\"Font {font_name}={base_font} lacks a subset indicator tag\"\n            )\n            assert \"/FontFile\" in font.FontDescriptor, (\n                f\"Type 1 font {font_name}={base_font} is not embedded\"\n            )\n            _, original_name = base_font.split(\"+\", 1)\n            length[original_name] = len(bytes(font[\"/FontDescriptor\"][\"/FontFile\"]))\n\n    print(\"Embedded font stream lengths:\", length)\n    # We should have several fonts, each much smaller than the original.\n    # I get under 10kB on my system for each font, but allow 15kB in case\n    # of differences in the font files.\n    assert {\n        'CMEX10',\n        'CMMI12',\n        'CMR12',\n        'CMSY10',\n        'CMSY8',\n        'EUFM10',\n        'MSAM10',\n        'MSBM"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "_backend_pdf_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rop_tables += [\n        'FFTM',  # FontForge Timestamp.\n        'PfEd',  # FontForge personal table.\n        'BDF',  # X11 BDF header.\n        'meta',  # Metadata stores design/supported languages (meaningless for subsets).\n        'MERG',  # Merge Table.\n        'TSIV',  # Microsoft Visual TrueType extension.\n        'Zapf',  # Information about the individual glyphs in the font.\n        'bdat',  # The bitmap data table.\n        'bloc',  # The bitmap location table.\n        'cidg',  # CID to Glyph ID table (Apple Advanced Typography).\n        'fdsc',  # The font descriptors table.\n        'feat',  # Feature name table (Apple Advanced Typography).\n        'fmtx',  # The Font Metrics Table.\n        'fond',  # Data-fork font information (Apple Advanced Typography).\n        'just',  # The justification table (Apple Advanced Typography).\n        'kerx',  # An extended kerning table (Apple Advanced Typography).\n        'ltag',  # Language Tag.\n        'morx',  # Extended Glyph Metamorphosis Table.\n        'trak',  # Tracking table.\n        'xref',  # The cross-reference table (some Apple font tooling information).\n    ]\n    # if fontfile is a ttc, specify font number\n    if fontfile.endswith(\".ttc\"):\n        options.font_number = 0\n\n    font = subset.load_font(fontfile, options)\n    subsetter = subset.Subsetter(options=options)\n    subsetter.populate(text=characters)\n    subsetter.subset(font)\n    return font\n\n\ndef font_as_file(font):\n    \"\"\"\n    Convert a TTFont object into a file-like object.\n\n    Parameters\n    ----------\n    font : fontTools.ttLib.ttFont.TTFont\n        A font object\n\n    Returns\n    -------\n    BytesIO\n        A file object with the font saved into it\n    \"\"\"\n    fh = BytesIO()\n    font.save(fh, reorderTables=False)\n    return fh\n\n\nclass CharacterTracker:\n    \"\"\"\n    Helper for font subsetting by the pdf and ps backends.\n\n    Maintains a mapping of font paths to the set of character codepoints that\n    are being used from that font.\n    \"\"\"\n\n    def "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "_backend_pdf_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " Table.\n        'trak',  # Tracking table.\n        'xref',  # The cross-reference table (some Apple font tooling information).\n    ]\n    # if fontfile is a ttc, specify font number\n    if fontfile.endswith(\".ttc\"):\n        options.font_number = 0\n\n    font = subset.load_font(fontfile, options)\n    subsetter = subset.Subsetter(options=options)\n    subsetter.populate(text=characters)\n    subsetter.subset(font)\n    return font\n\n\ndef font_as_file(font):\n    \"\"\"\n    Convert a TTFont object into a file-like object.\n\n    Parameters\n    ----------\n    font : fontTools.ttLib.ttFont.TTFont\n        A font object\n\n    Returns\n    -------\n    BytesIO\n        A file object with the font saved into it\n    \"\"\"\n    fh = BytesIO()\n    font.save(fh, reorderTables=False)\n    return fh\n\n\nclass CharacterTracker:\n    \"\"\"\n    Helper for font subsetting by the pdf and ps backends.\n\n    Maintains a mapping of font paths to the set of character codepoints that\n    are being used from that font.\n    \"\"\"\n\n    def __init__(self):\n        self.used = {}\n\n    def track(self, font, s):\n        \"\"\"Record that string *s* is being typeset using font *font*.\"\"\"\n        char_to_font = font._get_fontmap(s)\n        for _c, _f in char_to_font.items():\n            self.used.setdefault(_f.fname, set()).add(ord(_c))\n\n    def track_glyph(self, font, glyph):\n        \"\"\"Record that codepoint *glyph* is being typeset using font *font*.\"\"\"\n        self.used.setdefault(font.fname, set()).add(glyph)\n\n\nclass RendererPDFPSBase(RendererBase):\n    # The following attributes must be defined by the subclasses:\n    # - _afm_font_dir\n    # - _use_afm_rc_name\n\n    def __init__(self, width, height):\n        super().__init__()\n        self.width = width\n        self.height = height\n\n    def flipy(self):\n        # docstring inherited\n        return False  # y increases from bottom to top.\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True  # PDF and PS support arbitrary image scaling.\n\n    def "}, {"start_line": 7000, "end_line": 8991, "belongs_to": {"file_name": "test_usetex.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "10',\n    }.issubset(length), \"Missing expected fonts in the PDF\"\n    for font_name, length in length.items():\n        assert length < 15_000, (\n            f\"Font {font_name}={length} is larger than expected\"\n        )\n\n    # For comparison, lengths without subsetting on my system:\n    #  'CMEX10': 29686\n    #  'CMMI12': 36176\n    #  'CMR12': 32157\n    #  'CMSY10': 32004\n    #  'CMSY8': 32061\n    #  'EUFM10': 20546\n    #  'MSAM10': 31199\n    #  'MSBM10': 34129\n\n\ntry:\n    _old_gs_version = mpl._get_executable_info('gs').version < parse_version('9.55')\nexcept mpl.ExecutableNotFoundError:\n    _old_gs_version = True\n\n\n@image_comparison(baseline_images=['rotation'], extensions=['eps', 'pdf', 'png', 'svg'],\n                  style='mpl20', tol=3.91 if _old_gs_version else 0)\ndef test_rotation():\n    mpl.rcParams['text.usetex'] = True\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax.set(xlim=(-0.5, 5), xticks=[], ylim=(-0.5, 3), yticks=[], frame_on=False)\n\n    text = {val: val[0] for val in ['top', 'center', 'bottom', 'left', 'right']}\n    text['baseline'] = 'B'\n    text['center_baseline'] = 'C'\n\n    for i, va in enumerate(['top', 'center', 'bottom', 'baseline', 'center_baseline']):\n        for j, ha in enumerate(['left', 'center', 'right']):\n            for k, angle in enumerate([0, 90, 180, 270]):\n                k //= 2\n                x = i + k / 2\n                y = j + k / 2\n                ax.plot(x, y, '+', c=f'C{k}', markersize=20, markeredgewidth=0.5)\n                # 'My' checks full height letters plus descenders.\n                ax.text(x, y, f\"$\\\\mathrm{{My {text[ha]}{text[va]} {angle}}}$\",\n                        rotation=angle, horizontalalignment=ha, verticalalignment=va)\n\n\ndef test_unicode_sizing():\n    tp = mpl.textpath.TextToPath()\n    scale1 = tp.get_glyphs_tex(mpl.font_manager.FontProperties(), \"W\")[0][0][3]\n    scale2 = tp.get_glyphs_tex(mpl.font_manager.FontProperties(), r\"\\textwon\")[0][0][3]\n    assert scale1 == scale2\n"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_backend_pdf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ap = subfont.get_charmap()\n\n    # all unique chars must be available in subsetted font\n    assert {*chars} == {chr(key) for key in subcmap}\n\n    # subsetted font's charmap should have less entries\n    assert len(subcmap) < len(nosubcmap)\n\n    # since both objects are assigned same characters\n    assert subfont.get_num_glyphs() == nosubfont.get_num_glyphs()\n\n\n@image_comparison([\"multi_font_type3.pdf\"])\ndef test_multi_font_type3():\n    fonts, test_str = _gen_multi_font_text()\n    plt.rc('font', family=fonts, size=16)\n    plt.rc('pdf', fonttype=3)\n\n    fig = plt.figure()\n    fig.text(0.5, 0.5, test_str,\n             horizontalalignment='center', verticalalignment='center')\n\n\n@image_comparison([\"multi_font_type42.pdf\"])\ndef test_multi_font_type42():\n    fonts, test_str = _gen_multi_font_text()\n    plt.rc('font', family=fonts, size=16)\n    plt.rc('pdf', fonttype=42)\n\n    fig = plt.figure()\n    fig.text(0.5, 0.5, test_str,\n             horizontalalignment='center', verticalalignment='center')\n\n\n@pytest.mark.parametrize('family_name, file_name',\n                         [(\"Noto Sans\", \"NotoSans-Regular.otf\"),\n                          (\"FreeMono\", \"FreeMono.otf\")])\ndef test_otf_font_smoke(family_name, file_name):\n    # checks that there's no segfault\n    fp = fm.FontProperties(family=[family_name])\n    if Path(fm.findfont(fp)).name != file_name:\n        pytest.skip(f\"Font {family_name} may be missing\")\n\n    plt.rc('font', family=[family_name], size=27)\n\n    fig = plt.figure()\n    fig.text(0.15, 0.475, \" !\")\n    fig.savefig(io.BytesIO(), format=\"pdf\")\n\n\n@image_comparison([\"truetype-conversion.pdf\"])\n# mpltest.ttf does not have \"l\"/\"p\" glyphs so we get a warning when trying to\n# get the font extents.\ndef test_truetype_conversion(recwarn):\n    mpl.rcParams['pdf.fonttype'] = 3\n    fig, ax = plt.subplots()\n    ax.text(0, 0, \"ABCDE\",\n            font=Path(__file__).parent / \"data/mpltest.ttf\", fontsize=80)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\n@pytest.mark.skipi"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "backend_pdf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "SUBSET %s characters: %s\", filename, subset_str)\n            with _backend_pdf_ps.get_glyphs_subset(filename, subset_str) as subset:\n                fontdata = _backend_pdf_ps.font_as_file(subset)\n            _log.debug(\n                \"SUBSET %s %d -> %d\", filename,\n                os.stat(filename).st_size, fontdata.getbuffer().nbytes\n            )\n\n            # We need this ref for XObjects\n            full_font = font\n\n            # reload the font object from the subset\n            # (all the necessary data could probably be obtained directly\n            # using fontLib.ttLib)\n            font = FT2Font(fontdata)\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            self.outputStream(\n                fontfileObject, fontdata.getvalue(),\n                extra={'Length1': fontdata.getbuffer().nbytes})\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n    "}, {"start_line": 14000, "end_line": 15783, "belongs_to": {"file_name": "test_backend_pdf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f(not _has_tex_package(\"heuristica\"),\n                    reason=\"LaTeX lacks heuristica package\")\n@image_comparison([\"font-heuristica.pdf\"])\ndef test_font_heuristica():\n    # Heuristica uses the callothersubr operator for some glyphs\n    mpl.rcParams['text.latex.preamble'] = '\\n'.join((\n        r'\\usepackage{heuristica}',\n        r'\\usepackage[T1]{fontenc}',\n        r'\\usepackage[utf8]{inputenc}'\n    ))\n    fig, ax = plt.subplots()\n    ax.text(0.1, 0.1, r\"BHTem fi ffl 1234\", usetex=True, fontsize=50)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\n@pytest.mark.skipif(not _has_tex_package(\"DejaVuSans\"),\n                    reason=\"LaTeX lacks DejaVuSans package\")\n@image_comparison([\"font-dejavusans.pdf\"])\ndef test_font_dejavusans():\n    # DejaVuSans uses the seac operator to compose characters with diacritics\n    mpl.rcParams['text.latex.preamble'] = '\\n'.join((\n        r'\\usepackage{DejaVuSans}',\n        r'\\usepackage[T1]{fontenc}',\n        r'\\usepackage[utf8]{inputenc}'\n    ))\n\n    fig, ax = plt.subplots()\n    ax.text(0.1, 0.1, r\"\\textsf{ ABCDabcd}\", usetex=True, fontsize=50)\n    ax.text(0.1, 0.3, r\"\\textsf{fi ffl 1234}\", usetex=True, fontsize=50)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\n@pytest.mark.skipif(not _has_tex_package(\"charter\"),\n                    reason=\"LaTeX lacks charter package\")\n@image_comparison([\"font-bitstream-charter.pdf\"])\ndef test_font_bitstream_charter():\n    mpl.rcParams['text.latex.preamble'] = '\\n'.join((\n        r'\\usepackage{charter}',\n        r'\\usepackage[T1]{fontenc}',\n        r'\\usepackage[utf8]{inputenc}'\n    ))\n    fig, ax = plt.subplots()\n    ax.text(0.1, 0.1, r\" ABCDabcd\", usetex=True, fontsize=50)\n    ax.text(0.1, 0.3, r\"fi ffl 1234\", usetex=True, fontsize=50)\n    ax.set_xticks([])\n    ax.set_yticks([])\n"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_usetex.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t.mark.parametrize(\n    \"preamble\",\n    [r\"\\usepackage[full]{textcomp}\", r\"\\usepackage{underscore}\"],\n)\ndef test_latex_pkg_already_loaded(preamble):\n    plt.rcParams[\"text.latex.preamble\"] = preamble\n    fig = plt.figure()\n    fig.text(.5, .5, \"hello, world\", usetex=True)\n    fig.canvas.draw()\n\n\ndef test_usetex_with_underscore():\n    plt.rcParams[\"text.usetex\"] = True\n    df = {\"a_b\": range(5)[::-1], \"c\": range(5)}\n    fig, ax = plt.subplots()\n    ax.plot(\"c\", \"a_b\", data=df)\n    ax.legend()\n    ax.text(0, 0, \"foo_bar\", usetex=True)\n    plt.draw()\n\n\n@pytest.mark.flaky(reruns=3)  # Tends to hit a TeX cache lock on AppVeyor.\n@pytest.mark.parametrize(\"fmt\", [\"pdf\", \"svg\"])\ndef test_missing_psfont(fmt, monkeypatch):\n    \"\"\"An error is raised if a TeX font lacks a Type-1 equivalent\"\"\"\n    monkeypatch.setattr(\n        dviread.PsfontsMap, '__getitem__',\n        lambda self, k: dviread.PsFont(\n            texname=b'texfont', psname=b'Some Font',\n            effects=None, encoding=None, filename=None))\n    mpl.rcParams['text.usetex'] = True\n    fig, ax = plt.subplots()\n    ax.text(0.5, 0.5, 'hello')\n    with TemporaryFile() as tmpfile, pytest.raises(ValueError):\n        fig.savefig(tmpfile, format=fmt)\n\n\ndef test_pdf_type1_font_subsetting():\n    \"\"\"Test that fonts in PDF output are properly subset.\"\"\"\n    pikepdf = pytest.importorskip(\"pikepdf\")\n\n    mpl.rcParams[\"text.usetex\"] = True\n    mpl.rcParams[\"text.latex.preamble\"] = r\"\\usepackage{amssymb}\"\n    fig, ax = plt.subplots()\n    ax.text(0.2, 0.7, r\"$\\int_{-\\infty}^{\\aleph}\\sqrt{\\alpha\\beta\\gamma}\\mathrm{d}x$\")\n    ax.text(0.2, 0.5, r\"$\\mathfrak{x}\\circledcirc\\mathfrak{y}\\in\\mathbb{R}$\")\n\n    with TemporaryFile() as tmpfile:\n        fig.savefig(tmpfile, format=\"pdf\")\n        tmpfile.seek(0)\n        pdf = pikepdf.Pdf.open(tmpfile)\n\n        length = {}\n        page = pdf.pages[0]\n        for font_name, font in page.Resources.Font.items():\n            assert font.Subtype == \"/Type1\", (\n                f\"Font {font_name}={font"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "test_backend_pdf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s call\"\"\"\n    plt.xlabel(\"$22_2_2$\", usetex=True)  # This fails with \"Double subscript\"\n    with pytest.raises(RuntimeError):\n        plt.savefig(io.BytesIO(), format=\"pdf\")\n\n\ndef test_empty_rasterized():\n    # Check that empty figures that are rasterised save to pdf files fine\n    fig, ax = plt.subplots()\n    ax.plot([], [], rasterized=True)\n    fig.savefig(io.BytesIO(), format=\"pdf\")\n\n\n@image_comparison(['kerning.pdf'])\ndef test_kerning():\n    fig = plt.figure()\n    s = \"AVAVAVAVAVAVAVAVAAVV\"\n    fig.text(0, .25, s, size=5)\n    fig.text(0, .75, s, size=20)\n\n\ndef test_glyphs_subset():\n    fpath = str(_get_data_path(\"fonts/ttf/DejaVuSerif.ttf\"))\n    chars = \"these should be subsetted! 1234567890\"\n\n    # non-subsetted FT2Font\n    nosubfont = FT2Font(fpath)\n    nosubfont.set_text(chars)\n\n    # subsetted FT2Font\n    with get_glyphs_subset(fpath, chars) as subset:\n        subfont = FT2Font(font_as_file(subset))\n    subfont.set_text(chars)\n\n    nosubcmap = nosubfont.get_charmap()\n    subcmap = subfont.get_charmap()\n\n    # all unique chars must be available in subsetted font\n    assert {*chars} == {chr(key) for key in subcmap}\n\n    # subsetted font's charmap should have less entries\n    assert len(subcmap) < len(nosubcmap)\n\n    # since both objects are assigned same characters\n    assert subfont.get_num_glyphs() == nosubfont.get_num_glyphs()\n\n\n@image_comparison([\"multi_font_type3.pdf\"])\ndef test_multi_font_type3():\n    fonts, test_str = _gen_multi_font_text()\n    plt.rc('font', family=fonts, size=16)\n    plt.rc('pdf', fonttype=3)\n\n    fig = plt.figure()\n    fig.text(0.5, 0.5, test_str,\n             horizontalalignment='center', verticalalignment='center')\n\n\n@image_comparison([\"multi_font_type42.pdf\"])\ndef test_multi_font_type42():\n    fonts, test_str = _gen_multi_font_text()\n    plt.rc('font', family=fonts, size=16)\n    plt.rc('pdf', fonttype=42)\n\n    fig = plt.figure()\n    fig.text(0.5, 0.5, test_str,\n             horizontalalignment='center', verticalalignment='center'"}], "retrieved_count": 10, "cost_time": 3.952167510986328}
{"question": "How does the blend_mode parameter in shade_rgb implement a plugin-like architecture that allows both predefined blending strategies and custom callable functions, including error handling for invalid modes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 136000, "end_line": 138000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "m and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of '\n                                 f'{lookup.keys}') from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if np.ma.is_masked(intensity):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot th"}, {"start_line": 137000, "end_line": 139000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of '\n                                 f'{lookup.keys}') from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if np.ma.is_masked(intensity):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s, v)\n        values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : `~numpy.ndarray`\n            An (M, N, 3) RGB array of floats ranging from 0 to 1 (color image).\n        intensity : `~numpy.ndarray`\n            An (M, N, 1) array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the output\n            image to. If not provided, use the value provided upon initialization.\n        hsv_min_sat : number, "}, {"start_line": 134000, "end_line": 136000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "te the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            (M, N, 3) RGB array of floats (ranging 0 to 1) with an (M, N, 1)\n            hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate syste"}, {"start_line": 135000, "end_line": 137000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            (M, N, 3) RGB array of floats (ranging 0 to 1) with an (M, N, 1)\n            hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n    "}, {"start_line": 130000, "end_line": 132000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1)\n\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : 2D array-like\n            The height values used to generate a shaded map.\n        cmap : `~matplotlib.colors.Colormap`\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in ``cmap='gist_earth'``, use\n            ``cmap=plt.get_cmap('gist_earth')`` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            \"overlay\".  Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an (M, N, 3) RGB array of floats (ranging 0 to 1) with\n            an (M, N, 1) hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : float or None, optional\n            The minimum value used in colormapp"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "test_colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "336. Previously fully masked data would trigger a ValueError.\n    data = np.ma.masked_all((12, 20))\n    plt.pcolor(data)\n    plt.draw()\n\n\n@image_comparison(['light_source_shading_topo.png'])\ndef test_light_source_topo_surface():\n    \"\"\"Shades a DEM using different v.e.'s and blend modes.\"\"\"\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n    dx, dy = dem['dx'], dem['dy']\n    # Get the true cellsize in meters for accurate vertical exaggeration\n    # Convert from decimal degrees to meters\n    dx = 111320.0 * dx * np.cos(dem['ymin'])\n    dy = 111320.0 * dy\n\n    ls = mcolors.LightSource(315, 45)\n    cmap = cm.gist_earth\n\n    fig, axs = plt.subplots(nrows=3, ncols=3)\n    for row, mode in zip(axs, ['hsv', 'overlay', 'soft']):\n        for ax, ve in zip(row, [0.1, 1, 10]):\n            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,\n                           blend_mode=mode)\n            ax.imshow(rgb)\n            ax.set(xticks=[], yticks=[])\n\n\ndef test_light_source_shading_default():\n    \"\"\"\n    Array comparison test for the default \"hsv\" blend mode. Ensure the\n    default result doesn't change without warning.\n    \"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.colormaps[\"copper\"]\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.45, 0.90, 0.90, 0.82, 0.62, 0.28, 0.00],\n          [0.45, 0.94, 0.99, 1.00, 1.00, 0.96, 0.65, 0.17],\n          [0.90, 0.99, 1.00, 1.00, 1.00, 1.00, 0.94, 0.35],\n          [0.90, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.49],\n          [0.82, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.41],\n          [0.62, 0.96, 1.00, 1.00, 1.00, 1.00, 0.90, 0.07],\n          [0.28, 0.65, 0.94, 1.00, 1.00, 0.90, 0.35, 0.01],\n          [0.00, 0.17, 0.35, 0.49, 0.41, 0.07, 0.01, 0.00]],\n\n         [[0.00, 0.28, 0.59, 0.72, 0.62, 0.40, 0.18, 0.00],\n       "}, {"start_line": 133000, "end_line": 135000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "reases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        **kwargs\n            Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        `~numpy.ndarray`\n            An (M, N, 4) array of floats ranging between 0-1.\n        \"\"\"\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical "}, {"start_line": 2000, "end_line": 3273, "belongs_to": {"file_name": "topographic_hillshading.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/specialty_plots", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(nrows=4, ncols=3, figsize=(8, 9))\nplt.setp(axs.flat, xticks=[], yticks=[])\n\n# Vary vertical exaggeration and blend mode and plot all combinations\nfor col, ve in zip(axs.T, [0.1, 1, 10]):\n    # Show the hillshade intensity image in the first row\n    col[0].imshow(ls.hillshade(z, vert_exag=ve, dx=dx, dy=dy), cmap='gray')\n\n    # Place hillshaded plots with different blend modes in the rest of the rows\n    for ax, mode in zip(col[1:], ['hsv', 'overlay', 'soft']):\n        rgb = ls.shade(z, cmap=cmap, blend_mode=mode,\n                       vert_exag=ve, dx=dx, dy=dy)\n        ax.imshow(rgb)\n\n# Label rows and columns\nfor ax, ve in zip(axs[0], [0.1, 1, 10]):\n    ax.set_title(f'{ve}', size=18)\nfor ax, mode in zip(axs[:, 0], ['Hillshade', 'hsv', 'overlay', 'soft']):\n    ax.set_ylabel(mode, size=18)\n\n# Group labels...\naxs[0, 1].annotate('Vertical Exaggeration', (0.5, 1), xytext=(0, 30),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='center', va='bottom', size=20)\naxs[2, 0].annotate('Blend Mode', (0, 0.5), xytext=(-30, 0),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='right', va='center', size=20, rotation=90)\nfig.subplots_adjust(bottom=0.05, right=0.95)\n\nplt.show()\n"}, {"start_line": 131000, "end_line": 133000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            \"overlay\".  Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an (M, N, 3) RGB array of floats (ranging 0 to 1) with\n            an (M, N, 1) hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : float or None, optional\n            The minimum value used in colormapping *data*. If *None* the\n            minimum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vmax : float or None, optional\n            The maximum value used in colormapping *data*. If *None* the\n            maximum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Inc"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "test_colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "levels_and_colors(levels, colors[0:i1],\n                                                    extend=extend)\n        cmap.set_bad(bad)\n        for d_val, expected_color in cases.items():\n            if d_val == masked_value:\n                d_val = np.ma.array([1], mask=True)\n            else:\n                d_val = [d_val]\n            assert_array_equal(expected_color, cmap(norm(d_val))[0],\n                               f'With extend={extend!r} and data '\n                               f'value={d_val!r}')\n\n    with pytest.raises(ValueError):\n        mcolors.from_levels_and_colors(levels, colors)\n\n\ndef test_rgb_hsv_round_trip():\n    for a_shape in [(500, 500, 3), (500, 3), (1, 3), (3,)]:\n        np.random.seed(0)\n        tt = np.random.random(a_shape)\n        assert_array_almost_equal(\n            tt, mcolors.hsv_to_rgb(mcolors.rgb_to_hsv(tt)))\n        assert_array_almost_equal(\n            tt, mcolors.rgb_to_hsv(mcolors.hsv_to_rgb(tt)))\n\n\ndef test_autoscale_masked():\n    # Test for #2336. Previously fully masked data would trigger a ValueError.\n    data = np.ma.masked_all((12, 20))\n    plt.pcolor(data)\n    plt.draw()\n\n\n@image_comparison(['light_source_shading_topo.png'])\ndef test_light_source_topo_surface():\n    \"\"\"Shades a DEM using different v.e.'s and blend modes.\"\"\"\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n    dx, dy = dem['dx'], dem['dy']\n    # Get the true cellsize in meters for accurate vertical exaggeration\n    # Convert from decimal degrees to meters\n    dx = 111320.0 * dx * np.cos(dem['ymin'])\n    dy = 111320.0 * dy\n\n    ls = mcolors.LightSource(315, 45)\n    cmap = cm.gist_earth\n\n    fig, axs = plt.subplots(nrows=3, ncols=3)\n    for row, mode in zip(axs, ['hsv', 'overlay', 'soft']):\n        for ax, ve in zip(row, [0.1, 1, 10]):\n            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,\n                           blend_mode=mode)\n            ax.imshow(rgb)\n            ax.set(xticks=[], yticks=[])\n\n\ndef "}], "retrieved_count": 10, "cost_time": 3.982013702392578}
{"question": "Why does the RendererSVG class employ a deferred rendering strategy where clip paths and hatches are written only during finalization rather than immediately when encountered?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lf.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clip_path_ids = {}\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width=f'{str_width}pt',\n            height=f'{str_height}pt',\n            viewBox=f'0 0 {str_width} {str_height}',\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            id=mpl.rcParams['svg.id'],\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def _get_clippath_id(self, clippath):\n        \"\"\"\n        Returns a stable and unique identifier for the *clippath* argument\n        object within the current rendering context.\n\n        This allows plots that include custom clip paths to produce identical\n        SVG output on each render, provided that the :rc:`svg.hashsalt` config\n        setting and the ``SOURCE_DATE_EPOCH`` build-time environment variable\n        are set to fixed values.\n        \"\"\"\n        if clippath not in self._clip_path_ids:\n            self._clip_path_ids[clippath] = len(self._clip_path_ids)\n        return self._clip_path_ids[clippath]\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush("}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rg/2000/svg\",\n            version=\"1.1\",\n            id=mpl.rcParams['svg.id'],\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def _get_clippath_id(self, clippath):\n        \"\"\"\n        Returns a stable and unique identifier for the *clippath* argument\n        object within the current rendering context.\n\n        This allows plots that include custom clip paths to produce identical\n        SVG output on each render, provided that the :rc:`svg.hashsalt` config\n        setting and the ``SOURCE_DATE_EPOCH`` build-time environment variable\n        are set to fixed values.\n        \"\"\"\n        if clippath not in self._clip_path_ids:\n            self._clip_path_ids[clippath] = len(self._clip_path_ids)\n        return self._clip_path_ids[clippath]\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [da"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ake_flip_transform(clippath_trans)\n            dictkey = (self._get_clippath_id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return {}\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            _, oid = clip\n        return {'clip-path': f'url(#{oid})'}\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=f\"{s}_{self._groupd[s]:d}\")\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f._get_clip_attrs(gc))\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': f'#{oid}'}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        if gc.get_url() is not None:\n            self.writer.end('a')\n        writer.end('g')\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position, *, hatchcolors=None):\n        if hatchcolors is None:\n            hatchcolors = []\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position, hatchcolors=hatchcolors)\n\n   "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.sha256()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return f'{type}{m.hexdigest()[:10]}'\n\n    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        lw = gc.get_hatch_linewidth()\n        dictkey = (gc.get_hatch(), rgbFace, edge, lw)\n        oid = self._hatchd.get(dictkey)\n        if oid is None:\n            oid = self._make_id('h', dictkey)\n            self._hatchd[dictkey] = ((gc.get_hatch_path(), rgbFace, edge, lw), oid)\n        else:\n            _, oid = oid\n        return oid\n\n    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke, lw), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " writer.start('cc:Agent')\n                writer.element('dc:title', text=agent)\n                writer.end('cc:Agent')\n            writer.end(f'dc:{key.lower()}')\n\n        # Multiple values.\n        keywords = metadata.pop('Keywords', None)\n        if keywords is not None:\n            if isinstance(keywords, str):\n                keywords = [keywords]\n            _check_is_iterable_of_str(keywords, 'Keywords')\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start('dc:subject')\n            writer.start('rdf:Bag')\n            for keyword in keywords:\n                writer.element('rdf:li', text=keyword)\n            writer.end('rdf:Bag')\n            writer.end('dc:subject')\n\n        if mid is not None:\n            writer.close(mid)\n\n        if metadata:\n            raise ValueError('Unknown metadata key(s) passed to SVG writer: ' +\n                             ','.join(metadata))\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.sha256()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return f'{type}{m.hexdigest()[:10]}'\n\n    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        lw = gc.get_hatch_l"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=f\"{s}_{self._groupd[s]:d}\")\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self"}, {"start_line": 56000, "end_line": 58000, "belongs_to": {"file_name": "backend_pdf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          'BBox': [0, 0, 1, 1]\n            },\n            [Name('S'), Op.shading]\n        ))\n        return name\n\n    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )\n\n    def _write_soft_mask_groups(self):\n        for ob, attributes, content in self._soft_mask_groups:\n            self.beginStream(ob.id, None, attributes)\n            self.output(*content)\n            self.endStream()\n\n    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        edge, face, hatch, lw = hatch_style\n        if edge is not None:\n            edge = tuple(edge)\n        if face is not None:\n            face = tuple(face)\n        hatch_style = (edge, face, hatch, lw)\n\n        pattern = self._hatch_patterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self._hatch_patterns[hatch_style] = name\n        return name\n\n    hatchPatterns = _api.deprecated(\"3.10\")(property(lambda self: {\n        k: (e, f, h) for k, (e, f, h, l) in self._hatch_patterns.items()\n    }))\n\n    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self._hatch_patterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Mat"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n            _writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    _writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    _writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                _writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                _writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def _print_pgf_clip(self, gc):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle()\n        if bbox:\n            p1, p2 = bbox.get_points()\n            w, h = p2 - p1\n            coords = p1[0] * f, p1[1] * f, w * f, h * f\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                     % coords)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n        # check for clip path\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            self._print_pgf_path(gc, clippath, clippath_trans)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n    def _print_pgf_path_styles(self, gc, rgbFace):\n        # cap style\n        capstyles = {\"but"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C{:x}_{:x}_{}'.format(\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position, hatchcolors=hatchcolors):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': f'#{path_id}',\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n\n    def _draw_gouraud_triangle(self, transformed_points, colors):\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the sto"}], "retrieved_count": 10, "cost_time": 4.016308784484863}
{"question": "How does TransformWrapper's set() method maintain invalidation state consistency when replacing a child transform, and what is the significance of the double invalidation pattern with _invalid flag reset?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ict__)\n        # If `c = a + b; a1 = copy(a)`, then modifications to `a1` do not\n        # propagate back to `c`, i.e. we need to clear the parents of `a1`.\n        other._parents = {}\n        # If `c = a + b; c1 = copy(c)`, then modifications to `a` also need to\n        # be propagated to `c1`.\n        for key, val in vars(self).items():\n            if isinstance(val, TransformNode) and id(self) in val._parents:\n                other.set_children(val)  # val == getattr(other, key)\n        return other\n\n    def invalidate(self):\n        \"\"\"\n        Invalidate this `TransformNode` and triggers an invalidation of its\n        ancestors.  Should be called any time the transform changes.\n        \"\"\"\n        return self._invalidate_internal(\n            level=self._INVALID_AFFINE_ONLY if self.is_affine else self._INVALID_FULL,\n            invalidating_node=self)\n\n    def _invalidate_internal(self, level, invalidating_node):\n        \"\"\"\n        Called by :meth:`invalidate` and subsequently ascends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # If we are already more invalid than the currently propagated invalidation,\n        # then we don't need to do anything.\n        if level <= self._invalid and not self.pass_through:\n            return\n        self._invalid = level\n        for parent in list(self._parents.values()):\n            parent = parent()  # Dereference the weak reference.\n            if parent is not None:\n                parent._invalidate_internal(level=level, invalidating_node=self)\n\n    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the ch"}, {"start_line": 59000, "end_line": 61000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "(self):\n        # docstring inherited\n        return self._child.frozen()\n\n    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        if hasattr(self, \"_child\"):  # Absent during init.\n            self.invalidate()\n            new_dims = (child.input_dims, child.output_dims)\n            old_dims = (self._child.input_dims, self._child.output_dims)\n            if new_dims != old_dims:\n                raise ValueError(\n                    f\"The input and output dims of the new child {new_dims} \"\n                    f\"do not match those of current child {old_dims}\")\n            self._child._parents.pop(id(self), None)\n\n        self._child = child\n        self.set_children(child)\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = child.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix\n        # note we do not wrap other properties here since the transform's\n        # child can be changed with WrappedTransform.set and so checking\n        # is_affine and other such properties may be dangerous.\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0\n\n    input_dims = property(lambda self: self._child.input_dims)\n    output_dims = property(lambda self: self._child.output_dims)\n    is_affine = property(lambda self: self._child.is_affine)\n    is_separable = property(lambda self: self._child.is_separable)\n    has_inverse = property(lambda self: self._child.has_inverse)\n\n\nclass AffineBase(Transform):\n    \"\"\"\n    The base"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # If we are already more invalid than the currently propagated invalidation,\n        # then we don't need to do anything.\n        if level <= self._invalid and not self.pass_through:\n            return\n        self._invalid = level\n        for parent in list(self._parents.values()):\n            parent = parent()  # Dereference the weak reference.\n            if parent is not None:\n                parent._invalidate_internal(level=level, invalidating_node=self)\n\n    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the children won't\n        # keep them alive.\n        id_self = id(self)\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(\n                self, lambda _, pop=child._parents.pop, k=id_self: pop(k))\n            child._parents[id_self] = ref\n\n    def frozen(self):\n        \"\"\"\n        Return a frozen copy of this transform node.  The frozen copy will not\n        be updated when its children change.  Useful for storing a previously\n        known state of a transform where ``copy.deepcopy()`` might normally be\n        used.\n        \"\"\"\n        return self\n\n\nclass BboxBase(TransformNode):\n    \"\"\"\n    The base class of all bounding boxes.\n\n    This class is immutable; `Bbox` is a mutable subclass.\n\n    The canonical representation is as two points, with no\n    restric"}, {"start_line": 58000, "end_line": 60000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  raise NotImplementedError()\n\n\nclass TransformWrapper(Transform):\n    \"\"\"\n    A helper class that holds a single child transform and acts\n    equivalently to it.\n\n    This is useful if a node of the transform tree must be replaced at\n    run time with a transform of a different type.  This class allows\n    that replacement to correctly trigger invalidation.\n\n    `TransformWrapper` instances must have the same input and output dimensions\n    during their entire lifetime, so the child transform may only be replaced\n    with another child transform of the same dimensions.\n    \"\"\"\n\n    pass_through = True\n\n    def __init__(self, child):\n        \"\"\"\n        *child*: A `Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        _api.check_isinstance(Transform, child=child)\n        super().__init__()\n        self.set(child)\n\n    def __eq__(self, other):\n        return self._child.__eq__(other)\n\n    __str__ = _make_str_method(\"_child\")\n\n    def frozen(self):\n        # docstring inherited\n        return self._child.frozen()\n\n    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        if hasattr(self, \"_child\"):  # Absent during init.\n            self.invalidate()\n            new_dims = (child.input_dims, child.output_dims)\n            old_dims = (self._child.input_dims, self._child.output_dims)\n            if new_dims != old_dims:\n                raise ValueError(\n                    f\"The input and output dims of the new child {new_dims} \"\n                    f\"do not match those of current child {old_dims}\")\n            self._child._parents.pop(id(self), None)\n\n        self._child = child\n        self.set_children(child)\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = chil"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self._shorthand_name = shorthand_name or ''\n\n    if DEBUG:\n        def __str__(self):\n            # either just return the name of this TransformNode, or its repr\n            return self._shorthand_name or repr(self)\n\n    def __getstate__(self):\n        # turn the dictionary with weak values into a normal dictionary\n        return {**self.__dict__,\n                '_parents': {k: v() for k, v in self._parents.items()}}\n\n    def __setstate__(self, data_dict):\n        self.__dict__ = data_dict\n        # turn the normal dictionary back into a dictionary with weak values\n        # The extra lambda is to provide a callback to remove dead\n        # weakrefs from the dictionary when garbage collection is done.\n        self._parents = {\n            k: weakref.ref(v, lambda _, pop=self._parents.pop, k=k: pop(k))\n            for k, v in self._parents.items() if v is not None}\n\n    def __copy__(self):\n        cls = type(self)\n        other = cls.__new__(cls)\n        other.__dict__.update(self.__dict__)\n        # If `c = a + b; a1 = copy(a)`, then modifications to `a1` do not\n        # propagate back to `c`, i.e. we need to clear the parents of `a1`.\n        other._parents = {}\n        # If `c = a + b; c1 = copy(c)`, then modifications to `a` also need to\n        # be propagated to `c1`.\n        for key, val in vars(self).items():\n            if isinstance(val, TransformNode) and id(self) in val._parents:\n                other.set_children(val)  # val == getattr(other, key)\n        return other\n\n    def invalidate(self):\n        \"\"\"\n        Invalidate this `TransformNode` and triggers an invalidation of its\n        ancestors.  Should be called any time the transform changes.\n        \"\"\"\n        return self._invalidate_internal(\n            level=self._INVALID_AFFINE_ONLY if self.is_affine else self._INVALID_FULL,\n            invalidating_node=self)\n\n    def _invalidate_internal(self, level, invalidating_node):\n        \"\"\"\n        Called by :meth:`invalidate` and subsequently as"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "alidation may affect only the affine part.  If the\n    # invalidation was \"affine-only\", the _invalid member is set to\n    # INVALID_AFFINE_ONLY\n\n    # Possible values for the _invalid attribute.\n    _VALID, _INVALID_AFFINE_ONLY, _INVALID_FULL = range(3)\n\n    # Some metadata about the transform, used to determine whether an\n    # invalidation is affine-only\n    is_affine = False\n\n    pass_through = False\n    \"\"\"\n    If pass_through is True, all ancestors will always be\n    invalidated, even if 'self' is already invalid.\n    \"\"\"\n\n    def __init__(self, shorthand_name=None):\n        \"\"\"\n        Parameters\n        ----------\n        shorthand_name : str\n            A string representing the \"name\" of the transform. The name carries\n            no significance other than to improve the readability of\n            ``str(transform)`` when DEBUG=True.\n        \"\"\"\n        self._parents = {}\n        # Initially invalid, until first computation.\n        self._invalid = self._INVALID_FULL\n        self._shorthand_name = shorthand_name or ''\n\n    if DEBUG:\n        def __str__(self):\n            # either just return the name of this TransformNode, or its repr\n            return self._shorthand_name or repr(self)\n\n    def __getstate__(self):\n        # turn the dictionary with weak values into a normal dictionary\n        return {**self.__dict__,\n                '_parents': {k: v() for k, v in self._parents.items()}}\n\n    def __setstate__(self, data_dict):\n        self.__dict__ = data_dict\n        # turn the normal dictionary back into a dictionary with weak values\n        # The extra lambda is to provide a callback to remove dead\n        # weakrefs from the dictionary when garbage collection is done.\n        self._parents = {\n            k: weakref.ref(v, lambda _, pop=self._parents.pop, k=k: pop(k))\n            for k, v in self._parents.items() if v is not None}\n\n    def __copy__(self):\n        cls = type(self)\n        other = cls.__new__(cls)\n        other.__dict__.update(self.__d"}, {"start_line": 57000, "end_line": 59000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "There must be as many 'angles' as 'pts'\")\n        # Convert to radians if desired\n        if not radians:\n            angles = np.deg2rad(angles)\n        # Move a short distance away\n        pts2 = pts + pushoff * np.column_stack([np.cos(angles),\n                                                np.sin(angles)])\n        # Transform both sets of points\n        tpts = self.transform(pts)\n        tpts2 = self.transform(pts2)\n        # Calculate transformed angles\n        d = tpts2 - tpts\n        a = np.arctan2(d[:, 1], d[:, 0])\n        # Convert back to degrees if desired\n        if not radians:\n            a = np.rad2deg(a)\n        return a\n\n    def inverted(self):\n        \"\"\"\n        Return the corresponding inverse transformation.\n\n        It holds ``x == self.inverted().transform(self.transform(x))``.\n\n        The return value of this method should be treated as\n        temporary.  An update to *self* does not cause a corresponding\n        update to its inverted copy.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass TransformWrapper(Transform):\n    \"\"\"\n    A helper class that holds a single child transform and acts\n    equivalently to it.\n\n    This is useful if a node of the transform tree must be replaced at\n    run time with a transform of a different type.  This class allows\n    that replacement to correctly trigger invalidation.\n\n    `TransformWrapper` instances must have the same input and output dimensions\n    during their entire lifetime, so the child transform may only be replaced\n    with another child transform of the same dimensions.\n    \"\"\"\n\n    pass_through = True\n\n    def __init__(self, child):\n        \"\"\"\n        *child*: A `Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        _api.check_isinstance(Transform, child=child)\n        super().__init__()\n        self.set(child)\n\n    def __eq__(self, other):\n        return self._child.__eq__(other)\n\n    __str__ = _make_str_method(\"_child\")\n\n    def frozen"}, {"start_line": 80000, "end_line": 82000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       self._a.frozen(), self._b.frozen())\n        if not isinstance(frozen, CompositeGenericTransform):\n            return frozen.frozen()\n        return frozen\n\n    def _invalidate_internal(self, level, invalidating_node):\n        # When the left child is invalidated at AFFINE_ONLY level and the right child is\n        # non-affine, the composite transform is FULLY invalidated.\n        if invalidating_node is self._a and not self._b.is_affine:\n            level = Transform._INVALID_FULL\n        super()._invalidate_internal(level, invalidating_node)\n\n    def __eq__(self, other):\n        if isinstance(other, (CompositeGenericTransform, CompositeAffine2D)):\n            return self is other or (self._a == other._a\n                                     and self._b == other._b)\n        else:\n            return False\n\n    def _iter_break_from_left_to_right(self):\n        for left, right in self._a._iter_break_from_left_to_right():\n            yield left, right + self._b\n        for left, right in self._b._iter_break_from_left_to_right():\n            yield self._a + left, right\n\n    def contains_branch_seperately(self, other_transform):\n        # docstring inherited\n        if self.output_dims != 2:\n            raise ValueError('contains_branch_seperately only supports '\n                             'transforms with 2 output dimensions')\n        if self == other_transform:\n            return (True, True)\n        return self._b.contains_branch_seperately(other_transform)\n\n    depth = property(lambda self: self._a.depth + self._b.depth)\n    is_affine = property(lambda self: self._a.is_affine and self._b.is_affine)\n    is_separable = property(\n        lambda self: self._a.is_separable and self._b.is_separable)\n    has_inverse = property(\n        lambda self: self._a.has_inverse and self._b.has_inverse)\n\n    __str__ = _make_str_method(\"_a\", \"_b\")\n\n    def transform_affine(self, values):\n        # docstring inherited\n        return self.get_affine().transform(values)\n\n    def tr"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      b1 = copy.copy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n    def test_deepcopy(self):\n        a = mtransforms.Affine2D()\n        b = mtransforms.Affine2D()\n        s = a + b\n        # Updating a dependee shouldn't invalidate a deepcopy of the dependent.\n        s.get_matrix()  # resolve it.\n        s1 = copy.deepcopy(s)\n        assert not s._invalid and not s1._invalid\n        a.translate(1, 2)\n        assert s._invalid and not s1._invalid\n        assert_array_equal(s1.get_matrix(), mtransforms.Affine2D().get_matrix())\n        # Updating a deepcopy of a dependee shouldn't invalidate a dependent.\n        s.get_matrix()  # resolve it.\n        b1 = copy.deepcopy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n\nclass TestAffineDeltaTransform:\n    def test_invalidate(self):\n        before = np.array([[1.0, 4.0, 0.0],\n                           [5.0, 1.0, 0.0],\n                           [0.0, 0.0, 1.0]])\n        after = np.array([[1.0, 3.0, 0.0],\n                          [5.0, 1.0, 0.0],\n                          [0.0, 0.0, 1.0]])\n\n        # Translation and skew present\n        base = mtransforms.Affine2D.from_values(1, 5, 4, 1, 2, 3)\n        t = mtransforms.AffineDeltaTransform(base)\n        assert_array_equal(t.get_matrix(), before)\n\n        # Mess with the internal structure of `base` without invalidating\n        # This should not affect this transform because it's a passthrough:\n        # it's always invalid\n        base.get_matrix()[0, 1:] = 3\n        assert_array_equal(t.get_matrix(), after)\n\n        # Invalidate the base\n        base.invalidate()\n        assert_array_equal(t.get_matrix(), after)\n\n\ndef test_non_affine_caching():\n    class AssertingNonAffineTransform(mtransforms.Transform):\n        \"\"\"\n        This transform raises an assertion error when called when it\n        shouldn't be and ``self.raise_on_t"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes\n                and len(x) > self._subslice_optim_min_size\n                and _path.is_sorted_and_has_non_nan(x)\n                and self.axes.name == 'rectilinear'\n                and self.axes.get_xscale() == 'linear'\n                and self._markevery is None\n                and self.get_clip_on()\n                and self.get_transform() == self.axes.transData):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(\n                    indices[nanmask], indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False\n\n    def _transform_path(self, subslice=None):\n        \"\"\"\n        Put a TransformedPath instance at self._transformed_path;\n        all invalidation of the transform is then handled by the\n        TransformedPath instance.\n        \"\"\"\n        # Masked arrays are now handled by the Path class itself\n        if subslice is not None:\n            xy = STEP_LOOKUP_MA"}], "retrieved_count": 10, "cost_time": 4.06166672706604}
{"question": "How does the matplotlib ticker module enforce architectural separation between formatter and locator responsibilities to prevent type mismatches at the API boundary?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly\n\n\nclass Ticker:\n    \"\"\"\n    A container for the objects defining tick position and format.\n\n    Attributes\n    ----------\n    locator : `~matplotlib.ticker.Locator` subclass\n        Determines the positions of the ticks.\n    formatter : `~matplotlib.ticker.Formatter` subclass\n        Determines the format of the tick labels.\n    \"\"\"\n\n    def __init__(self):\n        self._locator = None\n        self._formatter = None\n        self._locator_is_default = True\n        self._formatter_is_default = True\n\n    @property\n    def locator(self):\n        return self._locator\n\n    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            raise TypeError('locator must be a subclass of '\n                            'matplotlib.ticker.Locator')\n        self._locator = locator\n\n    @property\n    def formatter(self):\n        return self._formatter\n\n    @formatter.setter\n    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            raise TypeError('formatter must be a subclass of '\n                            'matplotlib.ticker.Formatter')\n        self._formatter = formatter\n\n\nclass _LazyTickList:\n    \"\"\"\n    A descriptor for lazy instantiation of tick lists.\n\n    See comment above definition of the ``majorTicks`` and ``minorTicks``\n    attributes.\n    \"\"\"\n\n    def __init__(self, major):\n        self._major = major\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance temporarily\n            # to an empty list. Then create the tick; not"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ral\nimport string\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook\nfrom matplotlib import transforms as mtransforms\n\n_log = logging.getLogger(__name__)\n\n__all__ = ('TickHelper', 'Formatter', 'FixedFormatter',\n           'NullFormatter', 'FuncFormatter', 'FormatStrFormatter',\n           'StrMethodFormatter', 'ScalarFormatter', 'LogFormatter',\n           'LogFormatterExponent', 'LogFormatterMathtext',\n           'LogFormatterSciNotation',\n           'LogitFormatter', 'EngFormatter', 'PercentFormatter',\n           'Locator', 'IndexLocator', 'FixedLocator', 'NullLocator',\n           'LinearLocator', 'LogLocator', 'AutoLocator',\n           'MultipleLocator', 'MaxNLocator', 'AutoMinorLocator',\n           'SymmetricalLogLocator', 'AsinhLocator', 'LogitLocator')\n\n\nclass _DummyAxis:\n    __name__ = \"dummy\"\n\n    def __init__(self, minpos=0):\n        self._data_interval = (0, 1)\n        self._view_interval = (0, 1)\n        self._minpos = minpos\n\n    def get_view_interval(self):\n        return self._view_interval\n\n    def set_view_interval(self, vmin, vmax):\n        self._view_interval = (vmin, vmax)\n\n    def get_minpos(self):\n        return self._minpos\n\n    def get_data_interval(self):\n        return self._data_interval\n\n    def set_data_interval(self, vmin, vmax):\n        self._data_interval = (vmin, vmax)\n\n    def get_tick_space(self):\n        # Just use the long-standing default of nbins==9\n        return 9\n\n\nclass TickHelper:\n    axis = None\n\n    def set_axis(self, axis):\n        self.axis = axis\n\n    def create_dummy_axis(self, **kwargs):\n        if self.axis is None:\n            self.axis = _DummyAxis(**kwargs)\n\n\nclass Formatter(TickHelper):\n    \"\"\"\n    Create a string based on a tick value and location.\n    \"\"\"\n    # some classes want to see all the locs to help format\n    # individual ones\n    locs = []\n\n    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x* at position pos.\n        ``pos=None`` ind"}, {"start_line": 11000, "end_line": 12732, "belongs_to": {"file_name": "grid_finder.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "im argument has no effect. It has been left for API compatibility\n        super().__init__(nbins, steps=steps, integer=integer,\n                         symmetric=symmetric, prune=prune)\n        self.create_dummy_axis()\n\n    def __call__(self, v1, v2):\n        locs = super().tick_values(v1, v2)\n        return np.array(locs), len(locs), 1  # 1: factor (see angle_helper)\n\n\nclass FixedLocator:\n    def __init__(self, locs):\n        self._locs = locs\n\n    def __call__(self, v1, v2):\n        v1, v2 = sorted([v1, v2])\n        locs = np.array([l for l in self._locs if v1 <= l <= v2])\n        return locs, len(locs), 1  # 1: factor (see angle_helper)\n\n\n# Tick Formatter\n\nclass FormatterPrettyPrint:\n    def __init__(self, useMathText=True):\n        self._fmt = mticker.ScalarFormatter(\n            useMathText=useMathText, useOffset=False)\n        self._fmt.create_dummy_axis()\n\n    def __call__(self, direction, factor, values):\n        return self._fmt.format_ticks(values)\n\n\nclass DictFormatter:\n    def __init__(self, format_dict, formatter=None):\n        \"\"\"\n        format_dict : dictionary for format strings to be used.\n        formatter : fall-back formatter\n        \"\"\"\n        super().__init__()\n        self._format_dict = format_dict\n        self._fallback_formatter = formatter\n\n    def __call__(self, direction, factor, values):\n        \"\"\"\n        factor is ignored if value is found in the dictionary\n        \"\"\"\n        if self._fallback_formatter:\n            fallback_strings = self._fallback_formatter(\n                direction, factor, values)\n        else:\n            fallback_strings = [\"\"] * len(values)\n        return [self._format_dict.get(k, v)\n                for k, v in zip(values, fallback_strings)]\n"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "grid_finder.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_api.deprecated(\"3.11\", alternative=\"grid_finder.get_transform()\")\n    def transform_xy(self, x, y):\n        return self._aux_transform.transform(np.column_stack([x, y])).T\n\n    @_api.deprecated(\"3.11\", alternative=\"grid_finder.get_transform().inverted()\")\n    def inv_transform_xy(self, x, y):\n        return self._aux_transform.inverted().transform(\n            np.column_stack([x, y])).T\n\n    def update(self, **kwargs):\n        for k, v in kwargs.items():\n            if k in [\"extreme_finder\",\n                     \"grid_locator1\",\n                     \"grid_locator2\",\n                     \"tick_formatter1\",\n                     \"tick_formatter2\"]:\n                setattr(self, k, v)\n            else:\n                raise ValueError(f\"Unknown update property {k!r}\")\n\n\nclass MaxNLocator(mticker.MaxNLocator):\n    def __init__(self, nbins=10, steps=None,\n                 trim=True,\n                 integer=False,\n                 symmetric=False,\n                 prune=None):\n        # trim argument has no effect. It has been left for API compatibility\n        super().__init__(nbins, steps=steps, integer=integer,\n                         symmetric=symmetric, prune=prune)\n        self.create_dummy_axis()\n\n    def __call__(self, v1, v2):\n        locs = super().tick_values(v1, v2)\n        return np.array(locs), len(locs), 1  # 1: factor (see angle_helper)\n\n\nclass FixedLocator:\n    def __init__(self, locs):\n        self._locs = locs\n\n    def __call__(self, v1, v2):\n        v1, v2 = sorted([v1, v2])\n        locs = np.array([l for l in self._locs if v1 <= l <= v2])\n        return locs, len(locs), 1  # 1: factor (see angle_helper)\n\n\n# Tick Formatter\n\nclass FormatterPrettyPrint:\n    def __init__(self, useMathText=True):\n        self._fmt = mticker.ScalarFormatter(\n            useMathText=useMathText, useOffset=False)\n        self._fmt.create_dummy_axis()\n\n    def __call__(self, direction, factor, values):\n        return self._fmt.format_ticks(values)\n\n\nclass DictFormatter:\n   "}, {"start_line": 71000, "end_line": 73000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "if isinstance(formatter, str):\n            formatter = mticker.StrMethodFormatter(formatter)\n        # Don't allow any other TickHelper to avoid easy-to-make errors,\n        # like using a Locator instead of a Formatter.\n        elif (callable(formatter) and\n              not isinstance(formatter, mticker.TickHelper)):\n            formatter = mticker.FuncFormatter(formatter)\n        else:\n            _api.check_isinstance(mticker.Formatter, formatter=formatter)\n\n        if (isinstance(formatter, mticker.FixedFormatter)\n                and len(formatter.seq) > 0\n                and not isinstance(level.locator, mticker.FixedLocator)):\n            _api.warn_external('FixedFormatter should only be used together '\n                               'with FixedLocator')\n\n        if level == self.major:\n            self.isDefault_majfmt = False\n        else:\n            self.isDefault_minfmt = False\n\n        level.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_pickradius(self, pickrad"}, {"start_line": 68000, "end_line": 70000, "belongs_to": {"file_name": "test_ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "expected):\n        fmt = mticker.PercentFormatter(symbol='\\\\{t}%', is_latex=is_latex)\n        with mpl.rc_context(rc={'text.usetex': usetex}):\n            assert fmt.format_pct(50, 100) == expected\n\n\ndef _impl_locale_comma():\n    try:\n        locale.setlocale(locale.LC_ALL, 'de_DE.UTF-8')\n    except locale.Error:\n        print('SKIP: Locale de_DE.UTF-8 is not supported on this machine')\n        return\n    ticks = mticker.ScalarFormatter(useMathText=True, useLocale=True)\n    fmt = '$\\\\mathdefault{%1.1f}$'\n    x = ticks._format_maybe_minus_and_locale(fmt, 0.5)\n    assert x == '$\\\\mathdefault{0{,}5}$'\n    # Do not change , in the format string\n    fmt = ',$\\\\mathdefault{,%1.1f},$'\n    x = ticks._format_maybe_minus_and_locale(fmt, 0.5)\n    assert x == ',$\\\\mathdefault{,0{,}5},$'\n    # Make sure no brackets are added if not using math text\n    ticks = mticker.ScalarFormatter(useMathText=False, useLocale=True)\n    fmt = '%1.1f'\n    x = ticks._format_maybe_minus_and_locale(fmt, 0.5)\n    assert x == '0,5'\n\n\ndef test_locale_comma():\n    # On some systems/pytest versions, `pytest.skip` in an exception handler\n    # does not skip, but is treated as an exception, so directly running this\n    # test can incorrectly fail instead of skip.\n    # Instead, run this test in a subprocess, which avoids the problem, and the\n    # need to fix the locale after.\n    proc = mpl.testing.subprocess_run_helper(_impl_locale_comma, timeout=60,\n                                             extra_env={'MPLBACKEND': 'Agg'})\n    skip_msg = next((line[len('SKIP:'):].strip()\n                     for line in proc.stdout.splitlines()\n                     if line.startswith('SKIP:')),\n                    '')\n    if skip_msg:\n        pytest.skip(skip_msg)\n\n\ndef test_majformatter_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.xaxis.set_major_formatter(mticker.LogLocator())\n\n\ndef test_minformatter_type():\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n     "}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "icates an unspecified location.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def format_ticks(self, values):\n        \"\"\"Return the tick labels for all the ticks at once.\"\"\"\n        self.set_locs(values)\n        return [self(value, i) for i, value in enumerate(values)]\n\n    def format_data(self, value):\n        \"\"\"\n        Return the full string representation of the value with the\n        position unspecified.\n        \"\"\"\n        return self.__call__(value)\n\n    def format_data_short(self, value):\n        \"\"\"\n        Return a short string version of the tick value.\n\n        Defaults to the position-independent long value.\n        \"\"\"\n        return self.format_data(value)\n\n    def get_offset(self):\n        return ''\n\n    def set_locs(self, locs):\n        \"\"\"\n        Set the locations of the ticks.\n\n        This method is called before computing the tick labels because some\n        formatters need to know all tick locations to do so.\n        \"\"\"\n        self.locs = locs\n\n    @staticmethod\n    def fix_minus(s):\n        \"\"\"\n        Some classes may want to replace a hyphen for minus with the proper\n        Unicode symbol (U+2212) for typographical correctness.  This is a\n        helper method to perform such a replacement when it is enabled via\n        :rc:`axes.unicode_minus`.\n        \"\"\"\n        return (s.replace('-', '\\N{MINUS SIGN}')\n                if mpl.rcParams['axes.unicode_minus']\n                else s)\n\n    def _set_locator(self, locator):\n        \"\"\"Subclasses may want to override this to set a locator.\"\"\"\n        pass\n\n\nclass NullFormatter(Formatter):\n    \"\"\"Always return the empty string.\"\"\"\n\n    def __call__(self, x, pos=None):\n        # docstring inherited\n        return ''\n\n\nclass FixedFormatter(Formatter):\n    \"\"\"\n    Return fixed strings for tick labels based only on position, not value.\n\n    .. note::\n        `.FixedFormatter` should only be used together with `.FixedLocator`.\n        Otherwise, the labels may end up "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n\n    def _get_text1_transform(self):\n        return self.axes.get_yaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)\n\n    def _apply_tickdir(self, tickdir):\n        # docstring inherited\n        super()._apply_tickdir(tickdir)\n        mark1, mark2 = {\n            'out': (mlines.TICKLEFT, mlines.TICKRIGHT),\n            'in': (mlines.TICKRIGHT, mlines.TICKLEFT),\n            'inout': ('_', '_'),\n        }[self._tickdir]\n        self.tick1line.set_marker(mark1)\n        self.tick2line.set_marker(mark2)\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly\n\n\nclass Ticker:\n    \"\"\"\n    A container for the objects defining tick position and format.\n\n    Attributes\n    ----------\n    locator : `~matplotlib.ticker.Locator` subclass\n        Determines the positions of the ticks.\n    formatter : `~matplotlib.ticker.Formatter` subclass\n        Determines the format of the tick labels.\n    \"\"\"\n\n    def __init__(self):\n        self._locator = None\n        self._formatter = None\n        self._locator_is_default = True\n        self._formatter_is_default = True\n\n    @property\n    def locator(self):\n        return self._locator\n\n    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            raise TypeError('locator must be a subclass of '\n                            'matplotlib.ticker.Locator')\n        self._locator = locator\n\n    @property\n    def formatter(self):\n        return sel"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_call__`` method. The formatter class has\naccess to the axis view and data limits.\n\nTo control the major and minor tick label formats, use one of the\nfollowing methods::\n\n  ax.xaxis.set_major_formatter(xmajor_formatter)\n  ax.xaxis.set_minor_formatter(xminor_formatter)\n  ax.yaxis.set_major_formatter(ymajor_formatter)\n  ax.yaxis.set_minor_formatter(yminor_formatter)\n\nIn addition to a `.Formatter` instance, `~.Axis.set_major_formatter` and\n`~.Axis.set_minor_formatter` also accept a ``str`` or function.  ``str`` input\nwill be internally replaced with an autogenerated `.StrMethodFormatter` with\nthe input ``str``. For function input, a `.FuncFormatter` with the input\nfunction will be generated and used.\n\nSee :doc:`/gallery/ticks/major_minor_demo` for an example of setting major\nand minor ticks. See the :mod:`matplotlib.dates` module for more information\nand examples of using date locators and formatters.\n\"\"\"\n\nimport itertools\nimport logging\nimport locale\nimport math\nfrom numbers import Integral\nimport string\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook\nfrom matplotlib import transforms as mtransforms\n\n_log = logging.getLogger(__name__)\n\n__all__ = ('TickHelper', 'Formatter', 'FixedFormatter',\n           'NullFormatter', 'FuncFormatter', 'FormatStrFormatter',\n           'StrMethodFormatter', 'ScalarFormatter', 'LogFormatter',\n           'LogFormatterExponent', 'LogFormatterMathtext',\n           'LogFormatterSciNotation',\n           'LogitFormatter', 'EngFormatter', 'PercentFormatter',\n           'Locator', 'IndexLocator', 'FixedLocator', 'NullLocator',\n           'LinearLocator', 'LogLocator', 'AutoLocator',\n           'MultipleLocator', 'MaxNLocator', 'AutoMinorLocator',\n           'SymmetricalLogLocator', 'AsinhLocator', 'LogitLocator')\n\n\nclass _DummyAxis:\n    __name__ = \"dummy\"\n\n    def __init__(self, minpos=0):\n        self._data_interval = (0, 1)\n        self._view_interval = (0, 1)\n        self._minpos = minpos\n\n    def get_view_int"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "ticker.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "erval(self):\n        return self._view_interval\n\n    def set_view_interval(self, vmin, vmax):\n        self._view_interval = (vmin, vmax)\n\n    def get_minpos(self):\n        return self._minpos\n\n    def get_data_interval(self):\n        return self._data_interval\n\n    def set_data_interval(self, vmin, vmax):\n        self._data_interval = (vmin, vmax)\n\n    def get_tick_space(self):\n        # Just use the long-standing default of nbins==9\n        return 9\n\n\nclass TickHelper:\n    axis = None\n\n    def set_axis(self, axis):\n        self.axis = axis\n\n    def create_dummy_axis(self, **kwargs):\n        if self.axis is None:\n            self.axis = _DummyAxis(**kwargs)\n\n\nclass Formatter(TickHelper):\n    \"\"\"\n    Create a string based on a tick value and location.\n    \"\"\"\n    # some classes want to see all the locs to help format\n    # individual ones\n    locs = []\n\n    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x* at position pos.\n        ``pos=None`` indicates an unspecified location.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def format_ticks(self, values):\n        \"\"\"Return the tick labels for all the ticks at once.\"\"\"\n        self.set_locs(values)\n        return [self(value, i) for i, value in enumerate(values)]\n\n    def format_data(self, value):\n        \"\"\"\n        Return the full string representation of the value with the\n        position unspecified.\n        \"\"\"\n        return self.__call__(value)\n\n    def format_data_short(self, value):\n        \"\"\"\n        Return a short string version of the tick value.\n\n        Defaults to the position-independent long value.\n        \"\"\"\n        return self.format_data(value)\n\n    def get_offset(self):\n        return ''\n\n    def set_locs(self, locs):\n        \"\"\"\n        Set the locations of the ticks.\n\n        This method is called before computing the tick labels because some\n        formatters need to know all tick locations to do so.\n        \"\"\"\n        se"}], "retrieved_count": 10, "cost_time": 4.094682455062866}
{"question": "Why does the ParserState class use a property decorator for the font attribute instead of direct attribute access, and how does this design choice enable the coupling between font and font_class state management?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 62000, "end_line": 64000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in vlist\")\n\n    assert isinstance(box, Hlist)\n    hlist_out(box)\n    return output\n\n\n##############################################################################\n# PARSER\n\n\ndef Error(msg: str) -> ParserElement:\n    \"\"\"Helper class to raise parser errors.\"\"\"\n    def raise_error(s: str, loc: int, toks: ParseResults) -> T.Any:\n        raise ParseFatalException(s, loc, msg)\n\n    return Empty().set_parse_action(raise_error)\n\n\nclass ParserState:\n    \"\"\"\n    Parser state.\n\n    States are pushed and popped from a stack as necessary, and the \"current\"\n    state is always at the top of the stack.\n\n    Upon entering and leaving a group { } or math/non-math, the stack is pushed\n    and popped accordingly.\n    \"\"\"\n\n    def __init__(self, fontset: Fonts, font: str, font_class: str, fontsize: float,\n                 dpi: float):\n        self.fontset = fontset\n        self._font = font\n        self.font_class = font_class\n        self.fontsize = fontsize\n        self.dpi = dpi\n\n    def copy(self) -> ParserState:\n        return copy.copy(self)\n\n    @property\n    def font(self) -> str:\n        return self._font\n\n    @font.setter\n    def font(self, name: str) -> None:\n        if name in ('rm', 'it', 'bf', 'bfit'):\n            self.font_class = name\n        self._font = name\n\n    def get_current_underline_thickness(self) -> float:\n        \"\"\"Return the underline thickness for this state.\"\"\"\n        return self.fontset.get_underline_thickness(\n            self.font, self.fontsize, self.dpi)\n\n\ndef cmd(expr: str, args: ParserElement) -> ParserElement:\n    r\"\"\"\n    Helper to define TeX commands.\n\n    ``cmd(\"\\cmd\", args)`` is equivalent to\n    ``\"\\cmd\" - (args | Error(\"Expected \\cmd{arg}{...}\"))`` where the names in\n    the error message are taken from element names in *args*.  If *expr*\n    already includes arguments (e.g. \"\\cmd{arg}{...}\"), then they are stripped\n    w"}, {"start_line": 63000, "end_line": 65000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "font\n        self.font_class = font_class\n        self.fontsize = fontsize\n        self.dpi = dpi\n\n    def copy(self) -> ParserState:\n        return copy.copy(self)\n\n    @property\n    def font(self) -> str:\n        return self._font\n\n    @font.setter\n    def font(self, name: str) -> None:\n        if name in ('rm', 'it', 'bf', 'bfit'):\n            self.font_class = name\n        self._font = name\n\n    def get_current_underline_thickness(self) -> float:\n        \"\"\"Return the underline thickness for this state.\"\"\"\n        return self.fontset.get_underline_thickness(\n            self.font, self.fontsize, self.dpi)\n\n\ndef cmd(expr: str, args: ParserElement) -> ParserElement:\n    r\"\"\"\n    Helper to define TeX commands.\n\n    ``cmd(\"\\cmd\", args)`` is equivalent to\n    ``\"\\cmd\" - (args | Error(\"Expected \\cmd{arg}{...}\"))`` where the names in\n    the error message are taken from element names in *args*.  If *expr*\n    already includes arguments (e.g. \"\\cmd{arg}{...}\"), then they are stripped\n    when constructing the parse element, but kept (and *expr* is used as is) in\n    the error message.\n    \"\"\"\n\n    def names(elt: ParserElement) -> T.Generator[str, None, None]:\n        if isinstance(elt, ParseExpression):\n            for expr in elt.exprs:\n                yield from names(expr)\n        elif elt.resultsName:\n            yield elt.resultsName\n\n    csname = expr.split(\"{\", 1)[0]\n    err = (csname + \"\".join(\"{%s}\" % name for name in names(args))\n           if expr == csname else expr)\n    return csname - (args | Error(f\"Expected {err}\"))\n\n\nclass Parser:\n    \"\"\"\n    A pyparsing-based parser for strings containing math expressions.\n\n    Raw text may also appear outside of pairs of ``$``.\n\n    The grammar is based directly on that in TeX, though it cuts a few corners.\n    \"\"\"\n\n    class _MathStyle(enum.Enum):\n        DISPLAYSTYLE = 0\n        TEXTSTYLE = 1\n        SCRIPTSTYLE = 2\n        SCRIPTSCRIPTSTYLE = 3\n\n    _binary_operators = set(\n      '+ * - \\N{MINUS SIGN}'\n      r'''\n "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "aclass(frozen=True)\nclass FontEntry:\n    \"\"\"\n    A class for storing Font properties.\n\n    It is used when populating the font lookup dictionary.\n    \"\"\"\n\n    fname: str = ''\n    name: str = ''\n    style: str = 'normal'\n    variant: str = 'normal'\n    weight: str | int = 'normal'\n    stretch: str = 'normal'\n    size: str = 'medium'\n\n    def _repr_html_(self) -> str:\n        png_stream = self._repr_png_()\n        png_b64 = b64encode(png_stream).decode()\n        return f\"<img src=\\\"data:image/png;base64, {png_b64}\\\" />\"\n\n    def _repr_png_(self) -> bytes:\n        from matplotlib.figure import Figure  # Circular import.\n        fig = Figure()\n        font_path = Path(self.fname) if self.fname != '' else None\n        fig.text(0, 0, self.name, font=font_path)\n        with BytesIO() as buf:\n            fig.savefig(buf, bbox_inches='tight', transparent=True)\n            return buf.getvalue()\n\n\ndef ttfFontProperty(font):\n    \"\"\"\n    Extract information from a TrueType font file.\n\n    Parameters\n    ----------\n    font : `.FT2Font`\n        The TrueType font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n\n    \"\"\"\n    name = font.family_name\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    sfnt = font.get_sfnt()\n    mac_key = (1,  # platform: macintosh\n               0,  # id: roman\n               0)  # langid: english\n    ms_key = (3,  # platform: microsoft\n              1,  # id: unicode_cs\n              0x0409)  # langid: english_united_states\n\n    # These tables are actually mac_roman-encoded, but mac_roman support may be\n    # missing in some alternative Python implementations and we are only going\n    # to look for ASCII substrings, where any ASCII-compatible encoding works\n    # - or big-endian UTF-16, since important Microsoft fonts use that.\n    sfnt2 = (sfnt.get((*mac_key, 2), b'').decode('latin-1').lower() or\n             sfnt.get((*ms_key, 2), b'').decode('utf_16_be').lowe"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "is results eventually in the two possible\n    call signatures::\n\n        FontProperties(pattern)\n        FontProperties(family=..., size=..., ...)\n\n    \"\"\"\n    @functools.wraps(init_method)\n    def wrapper(self, *args, **kwargs):\n        # multiple args with at least some positional ones\n        if len(args) > 1 or len(args) == 1 and kwargs:\n            # Note: Both cases were previously handled as individual properties.\n            # Therefore, we do not mention the case of font properties here.\n            _api.warn_deprecated(\n                \"3.10\",\n                message=\"Passing individual properties to FontProperties() \"\n                        \"positionally was deprecated in Matplotlib %(since)s and \"\n                        \"will be removed in %(removal)s. Please pass all properties \"\n                        \"via keyword arguments.\"\n            )\n        # single non-string arg -> clearly a family not a pattern\n        if len(args) == 1 and not kwargs and not cbook.is_scalar_or_string(args[0]):\n            # Case font-family list passed as single argument\n            _api.warn_deprecated(\n                \"3.10\",\n                message=\"Passing family as positional argument to FontProperties() \"\n                        \"was deprecated in Matplotlib %(since)s and will be removed \"\n                        \"in %(removal)s. Please pass family names as keyword\"\n                        \"argument.\"\n            )\n        # Note on single string arg:\n        # This has been interpreted as pattern so far. We are already raising if a\n        # non-pattern compatible family string was given. Therefore, we do not need\n        # to warn for this case.\n        return init_method(self, *args, **kwargs)\n\n    return wrapper\n\n\nclass FontProperties:\n    \"\"\"\n    A class for storing and manipulating font properties.\n\n    The font properties are the six properties described in the\n    `W3C Cascading Style Sheet, Level 1\n    <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ font\n "}, {"start_line": 80000, "end_line": 82000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " float], float] = {}\n        try:\n            result = self._expression.parse_string(s)\n        except ParseBaseException as err:\n            # explain becomes a plain method on pyparsing 3 (err.explain(0)).\n            raise ValueError(\"\\n\" + ParseException.explain(err, 0)) from None\n        self._state_stack = []\n        self._in_subscript_or_superscript = False\n        # prevent operator spacing from leaking into a new expression\n        self._em_width_cache = {}\n        ParserElement.reset_cache()\n        return T.cast(Hlist, result[0])  # Known return type from main.\n\n    def get_state(self) -> ParserState:\n        \"\"\"Get the current `State` of the parser.\"\"\"\n        return self._state_stack[-1]\n\n    def pop_state(self) -> None:\n        \"\"\"Pop a `State` off of the stack.\"\"\"\n        self._state_stack.pop()\n\n    def push_state(self) -> None:\n        \"\"\"Push a new `State` onto the stack, copying the current state.\"\"\"\n        self._state_stack.append(self.get_state().copy())\n\n    def main(self, toks: ParseResults) -> list[Hlist]:\n        return [Hlist(toks.as_list())]\n\n    def math_string(self, toks: ParseResults) -> ParseResults:\n        return self._math_expression.parse_string(toks[0][1:-1], parse_all=True)\n\n    def math(self, toks: ParseResults) -> T.Any:\n        hlist = Hlist(toks.as_list())\n        self.pop_state()\n        return [hlist]\n\n    def non_math(self, toks: ParseResults) -> T.Any:\n        s = toks[0].replace(r'\\$', '$')\n        symbols = [Char(c, self.get_state()) for c in s]\n        hlist = Hlist(symbols)\n        # We're going into math now, so set font to 'it'\n        self.push_state()\n        self.get_state().font = mpl.rcParams['mathtext.default']\n        return [hlist]\n\n    float_literal = staticmethod(pyparsing_common.convert_to_float)\n\n    def text(self, toks: ParseResults) -> T.Any:\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        hlist = Hlist([Char(c, state) for c in toks[1]])\n        self.pop_st"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "or_string(args[0]):\n            # Case font-family list passed as single argument\n            _api.warn_deprecated(\n                \"3.10\",\n                message=\"Passing family as positional argument to FontProperties() \"\n                        \"was deprecated in Matplotlib %(since)s and will be removed \"\n                        \"in %(removal)s. Please pass family names as keyword\"\n                        \"argument.\"\n            )\n        # Note on single string arg:\n        # This has been interpreted as pattern so far. We are already raising if a\n        # non-pattern compatible family string was given. Therefore, we do not need\n        # to warn for this case.\n        return init_method(self, *args, **kwargs)\n\n    return wrapper\n\n\nclass FontProperties:\n    \"\"\"\n    A class for storing and manipulating font properties.\n\n    The font properties are the six properties described in the\n    `W3C Cascading Style Sheet, Level 1\n    <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ font\n    specification and *math_fontfamily* for math fonts:\n\n    - family: A list of font names in decreasing order of priority.\n      The items may include a generic font family name, either 'sans-serif',\n      'serif', 'cursive', 'fantasy', or 'monospace'.  In that case, the actual\n      font to be used will be looked up from the associated rcParam during the\n      search process in `.findfont`. Default: :rc:`font.family`\n\n    - style: Either 'normal', 'italic' or 'oblique'.\n      Default: :rc:`font.style`\n\n    - variant: Either 'normal' or 'small-caps'.\n      Default: :rc:`font.variant`\n\n    - stretch: A numeric value in the range 0-1000 or one of\n      'ultra-condensed', 'extra-condensed', 'condensed',\n      'semi-condensed', 'normal', 'semi-expanded', 'expanded',\n      'extra-expanded' or 'ultra-expanded'. Default: :rc:`font.stretch`\n\n    - weight: A numeric value in the range 0-1000 or one of\n      'ultralight', 'light', 'normal', 'regular', 'book', 'medium',\n      'roman', 'semibold'"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ",\n        'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold',\n        'heavy', 'extra bold', 'black'\n        \"\"\"\n        return self._weight\n\n    def get_stretch(self):\n        \"\"\"\n        Return the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'.\n        \"\"\"\n        return self._stretch\n\n    def get_size(self):\n        \"\"\"\n        Return the font size.\n        \"\"\"\n        return self._size\n\n    def get_file(self):\n        \"\"\"\n        Return the filename of the associated font.\n        \"\"\"\n        return self._file\n\n    def get_fontconfig_pattern(self):\n        \"\"\"\n        Get a fontconfig_ pattern_ suitable for looking up the font as\n        specified with fontconfig's ``fc-match`` utility.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        return generate_fontconfig_pattern(self)\n\n    def set_family(self, family):\n        \"\"\"\n        Change the font family.  Can be either an alias (generic name\n        is CSS parlance), such as: 'serif', 'sans-serif', 'cursive',\n        'fantasy', or 'monospace', a real font name or a list of real\n        font names.  Real font names are not supported when\n        :rc:`text.usetex` is `True`. Default: :rc:`font.family`\n        \"\"\"\n        family = mpl._val_or_rc(family, 'font.family')\n        if isinstance(family, str):\n            family = [family]\n        self._family = family\n\n    def set_style(self, style):\n        \"\"\"\n        Set the font style.\n\n        Parameters\n        ----------\n        style : {'normal', 'italic', 'oblique'}, default: :rc:`font.style`\n        \"\"\"\n        style = mpl._val_or_rc(style, 'font.style')\n        _api.check_in_list(['normal', 'italic', 'oblique'], style=style)\n        self._slant = style\n\n    def set_variant(self, variant):\n        \"\"\"\n        Set the font"}, {"start_line": 61000, "end_line": 63000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           rule_height += rule_depth\n                if rule_height > 0 and rule_depth > 0:\n                    cur_v += rule_height\n                    p.render(output,\n                             cur_h + off_h, cur_v + off_v,\n                             rule_width, rule_height)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                rule_height = glue_spec.width - cur_g\n                if glue_sign != 0:  # normal\n                    if glue_sign == 1:  # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(box.glue_set * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:  # shrinking\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(box.glue_set * cur_glue))\n                rule_height += cur_g\n                cur_v += rule_height\n            elif isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in vlist\")\n\n    assert isinstance(box, Hlist)\n    hlist_out(box)\n    return output\n\n\n##############################################################################\n# PARSER\n\n\ndef Error(msg: str) -> ParserElement:\n    \"\"\"Helper class to raise parser errors.\"\"\"\n    def raise_error(s: str, loc: int, toks: ParseResults) -> T.Any:\n        raise ParseFatalException(s, loc, msg)\n\n    return Empty().set_parse_action(raise_error)\n\n\nclass ParserState:\n    \"\"\"\n    Parser state.\n\n    States are pushed and popped from a stack as necessary, and the \"current\"\n    state is always at the top of the stack.\n\n    Upon entering and leaving a group { } or math/non-math, the stack is pushed\n    and popped accordingly.\n    \"\"\"\n\n    def __init__(self, fontset: Fonts, font: str, font_class: str, fontsize: float,\n                 dpi: float):\n        self.fontset = fontset\n        self._font = "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "font_manager.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n    if weight not in weight_dict:\n        weight = 'normal'\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif any(word in fontname for word in ['narrow', 'cond']):\n        stretch = 'condensed'\n    elif any(word in fontname for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)\n\n\ndef _cleanup_fontproperties_init(init_method):\n    \"\"\"\n    A decorator to limit the call signature to single a positional argument\n    or alternatively only keyword arguments.\n\n    We still accept but deprecate all other call signatures.\n\n    When the deprecation expires we can switch the signature to::\n\n        __init__(self, pattern=None, /, *, family=None, style=None, ...)\n\n    plus a runtime check that pattern is not used alongside with the\n    keyword arguments. Th"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "_fontconfig_pattern.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    ('weight', 'light'),\n    'ultralight':     ('weight', 'light'),\n    'light':          ('weight', 'light'),\n    'book':           ('weight', 'book'),\n    'regular':        ('weight', 'regular'),\n    'normal':         ('weight', 'normal'),\n    'medium':         ('weight', 'medium'),\n    'demibold':       ('weight', 'demibold'),\n    'semibold':       ('weight', 'semibold'),\n    'bold':           ('weight', 'bold'),\n    'extrabold':      ('weight', 'extra bold'),\n    'black':          ('weight', 'black'),\n    'heavy':          ('weight', 'heavy'),\n    'roman':          ('slant', 'normal'),\n    'italic':         ('slant', 'italic'),\n    'oblique':        ('slant', 'oblique'),\n    'ultracondensed': ('width', 'ultra-condensed'),\n    'extracondensed': ('width', 'extra-condensed'),\n    'condensed':      ('width', 'condensed'),\n    'semicondensed':  ('width', 'semi-condensed'),\n    'expanded':       ('width', 'expanded'),\n    'extraexpanded':  ('width', 'extra-expanded'),\n    'ultraexpanded':  ('width', 'ultra-expanded'),\n}\n\n\n@cache  # The parser instance is a singleton.\ndef _make_fontconfig_parser():\n    def comma_separated(elem):\n        return elem + ZeroOrMore(Suppress(\",\") + elem)\n\n    family = Regex(fr\"([^{_family_punc}]|(\\\\[{_family_punc}]))*\")\n    size = Regex(r\"([0-9]+\\.?[0-9]*|\\.[0-9]+)\")\n    name = Regex(r\"[a-z]+\")\n    value = Regex(fr\"([^{_value_punc}]|(\\\\[{_value_punc}]))*\")\n    prop = Group((name + Suppress(\"=\") + comma_separated(value)) | one_of(_CONSTANTS))\n    return (\n        Optional(comma_separated(family)(\"families\"))\n        + Optional(\"-\" + comma_separated(size)(\"sizes\"))\n        + ZeroOrMore(\":\" + prop(\"properties*\"))\n        + StringEnd()\n    )\n\n\n# `parse_fontconfig_pattern` is a bottleneck during the tests because it is\n# repeatedly called when the rcParams are reset (to validate the default\n# fonts).  In practice, the cache size doesn't grow beyond a few dozen entries\n# during the test suite.\n@lru_cache\ndef parse_fontconfig_pattern(pattern):\n   "}], "retrieved_count": 10, "cost_time": 4.095985651016235}
{"question": "Why would using a singleton pattern versus repeatedly instantiating the _Unset class throughout matplotlib's codebase impact memory overhead in scenarios with thousands of default parameter checks?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/_api", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nHelper functions for managing the Matplotlib API.\n\nThis documentation is only relevant for Matplotlib developers, not for users.\n\n.. warning::\n\n    This module and its submodules are for internal use only.  Do not use them\n    in your own code.  We may change the API at any time with no warning.\n\n\"\"\"\n\nimport difflib\nimport functools\nimport itertools\nimport pathlib\nimport re\nimport sys\nimport warnings\n\nfrom .deprecation import (  # noqa: F401\n    deprecated, warn_deprecated,\n    rename_parameter, delete_parameter, make_keyword_only,\n    deprecate_method_override, deprecate_privatize_attribute,\n    suppress_matplotlib_deprecation_warning,\n    MatplotlibDeprecationWarning)\n\n\n# A sentinel value for optional arguments, when None cannot be used as\n# default because we need to distinguish between None passed explicitly\n# and parameter not given. Usage: def foo(arg=_api.UNSET):\nclass _Unset:\n    def __repr__(self):\n        return \"<UNSET>\"\nUNSET = _Unset()\n\n\nclass classproperty:\n    \"\"\"\n    Like `property`, but also triggers on access via the class, and it is the\n    *class* that's passed as argument.\n\n    Examples\n    --------\n    ::\n\n        class C:\n            @classproperty\n            def foo(cls):\n                return cls.__name__\n\n        assert C.foo == \"C\"\n    \"\"\"\n\n    def __init__(self, fget, fset=None, fdel=None, doc=None):\n        self._fget = fget\n        if fset is not None or fdel is not None:\n            raise ValueError('classproperty only implements fget.')\n        self.fset = fset\n        self.fdel = fdel\n        # docs are ignored for now\n        self._doc = doc\n\n    def __get__(self, instance, owner):\n        return self._fget(owner)\n\n    @property\n    def fget(self):\n        return self._fget\n\n\n# In the following check_foo() functions, the first parameter is positional-only to make\n# e.g. `_api.check_isinstance([...], types=foo)` work.\n\ndef check_isinstance(types, /, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *valu"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rent working directory\n        # which can fail if the user has ended up with a cwd that is\n        # non-existent.\n        yield 'matplotlibrc'\n        try:\n            matplotlibrc = os.environ['MATPLOTLIBRC']\n        except KeyError:\n            pass\n        else:\n            yield matplotlibrc\n            yield os.path.join(matplotlibrc, 'matplotlibrc')\n        yield os.path.join(get_configdir(), 'matplotlibrc')\n        yield os.path.join(get_data_path(), 'matplotlibrc')\n\n    for fname in gen_candidates():\n        if os.path.exists(fname) and not os.path.isdir(fname):\n            return fname\n\n    raise RuntimeError(\"Could not find matplotlibrc file; your Matplotlib \"\n                       \"install is broken\")\n\n\n@_docstring.Substitution(\n    \"\\n\".join(map(\"- {}\".format, sorted(rcsetup._validators, key=str.lower)))\n)\nclass RcParams(MutableMapping, dict):\n    \"\"\"\n    A dict-like key-value store for config parameters, including validation.\n\n    Validating functions are defined and associated with rc parameters in\n    :mod:`matplotlib.rcsetup`.\n\n    The list of rcParams is:\n\n    %s\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n    \"\"\"\n\n    validate = rcsetup._validators\n\n    # validate values on the way in\n    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)\n\n    def _set(self, key, val):\n        \"\"\"\n        Directly write data bypassing deprecation and validation logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``rcParams[key] = val`` and not ``_set()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__setitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._set(key, val)``.\n\n        Even though private, we guarantee API stability for ``rcParams._set``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta pu"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "__init__.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sociated with rc parameters in\n    :mod:`matplotlib.rcsetup`.\n\n    The list of rcParams is:\n\n    %s\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n    \"\"\"\n\n    validate = rcsetup._validators\n\n    # validate values on the way in\n    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)\n\n    def _set(self, key, val):\n        \"\"\"\n        Directly write data bypassing deprecation and validation logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``rcParams[key] = val`` and not ``_set()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__setitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._set(key, val)``.\n\n        Even though private, we guarantee API stability for ``rcParams._set``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta public:\n        \"\"\"\n        dict.__setitem__(self, key, val)\n\n    def _get(self, key):\n        \"\"\"\n        Directly read data bypassing deprecation, backend and validation\n        logic.\n\n        Notes\n        -----\n        As end user or downstream library you almost always should use\n        ``val = rcParams[key]`` and not ``_get()``.\n\n        There are only very few special cases that need direct data access.\n        These cases previously used ``dict.__getitem__(rcParams, key, val)``,\n        which is now deprecated and replaced by ``rcParams._get(key)``.\n\n        Even though private, we guarantee API stability for ``rcParams._get``,\n        i.e. it is subject to Matplotlib's API and deprecation policy.\n\n        :meta public:\n        \"\"\"\n        return dict.__getitem__(self, key)\n\n    def _update_raw(self, other_params):\n        \"\"\"\n        Directly update the data from *other_params*, bypassing deprecation,\n        backend and validation logic on both sides.\n\n        This ``rcParams"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      kw = {**kw, **kwargs}  # Don't modify the original kw.\n        self._setdefaults(self._getdefaults(kw), kw)\n        seg = mlines.Line2D(x, y, **kw)\n        return seg, kw\n\n    def _make_coordinates(self, axes, x, y, kw, kwargs):\n        kw = {**kw, **kwargs}  # Don't modify the original kw.\n        self._setdefaults(self._getdefaults(kw), kw)\n        return (x, y), kw\n\n    def _make_polygon(self, axes, x, y, kw, kwargs):\n        # Polygon doesn't directly support unitized inputs.\n        x = axes.convert_xunits(x)\n        y = axes.convert_yunits(y)\n\n        kw = kw.copy()  # Don't modify the original kw.\n        kwargs = kwargs.copy()\n\n        # Ignore 'marker'-related properties as they aren't Polygon\n        # properties, but they are Line2D properties, and so they are\n        # likely to appear in the default cycler construction.\n        # This is done here to the defaults dictionary as opposed to the\n        # other two dictionaries because we do want to capture when a\n        # *user* explicitly specifies a marker which should be an error.\n        # We also want to prevent advancing the cycler if there are no\n        # defaults needed after ignoring the given properties.\n        ignores = ({'marker', 'markersize', 'markeredgecolor',\n                    'markerfacecolor', 'markeredgewidth'}\n                   # Also ignore anything provided by *kwargs*.\n                   | {k for k, v in kwargs.items() if v is not None})\n\n        # Only using the first dictionary to use as basis\n        # for getting defaults for back-compat reasons.\n        # Doing it with both seems to mess things up in\n        # various places (probably due to logic bugs elsewhere).\n        default_dict = self._getdefaults(kw, ignores)\n        self._setdefaults(default_dict, kw)\n\n        # Looks like we don't want \"color\" to be interpreted to\n        # mean both facecolor and edgecolor for some reason.\n        # So the \"kw\" dictionary is thrown out, and only its\n        # 'color' value"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nThe rcsetup module contains the validation code for customization using\nMatplotlib's rc settings.\n\nEach rc setting is assigned a function used to validate any attempted changes\nto that setting.  The validation functions are defined in the rcsetup module,\nand are used to construct the rcParams global object which stores the settings\nand is referenced throughout Matplotlib.\n\nThe default values of the rc settings are set in the default matplotlibrc file.\nAny additions or deletions to the parameter set listed here should also be\npropagated to the :file:`lib/matplotlib/mpl-data/matplotlibrc` in Matplotlib's\nroot source directory.\n\"\"\"\n\nimport ast\nfrom functools import lru_cache, reduce\nfrom numbers import Real\nimport operator\nimport os\nimport re\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook\nfrom matplotlib.backends import backend_registry\nfrom matplotlib.cbook import ls_mapper\nfrom matplotlib.colors import Colormap, is_color_like\nfrom matplotlib._fontconfig_pattern import parse_fontconfig_pattern\nfrom matplotlib._enums import JoinStyle, CapStyle\n\n# Don't let the original cycler collide with our validating cycler\nfrom cycler import Cycler, cycler as ccycler\n\n\nclass ValidateInStrings:\n    def __init__(self, key, valid, ignorecase=False, *,\n                 _deprecated_since=None):\n        \"\"\"*valid* is a list of legal strings.\"\"\"\n        self.key = key\n        self.ignorecase = ignorecase\n        self._deprecated_since = _deprecated_since\n\n        def func(s):\n            if ignorecase:\n                return s.lower()\n            else:\n                return s\n        self.valid = {func(k): k for k in valid}\n\n    def __call__(self, s):\n        if self._deprecated_since:\n            name, = (k for k, v in globals().items() if v is self)\n            _api.warn_deprecated(\n                self._deprecated_since, name=name, obj_type=\"function\")\n        if self.ignorecase and isinstance(s, str):\n            s = s.lower()\n        if s in sel"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s \"\n                             f\"{prop!r} in the same prop_cycle\")\n        if norm_prop in checker:\n            raise ValueError(f\"Another property was already aliased to \"\n                             f\"{norm_prop!r}. Collision normalizing {prop!r}.\")\n        checker.update([norm_prop])\n\n    # This is just an extra-careful check, just in case there is some\n    # edge-case I haven't thought of.\n    assert len(checker) == len(cycler_inst.keys)\n\n    # Now, it should be safe to mutate this cycler\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        cycler_inst.change_key(prop, norm_prop)\n\n    for key, vals in cycler_inst.by_key().items():\n        _prop_validators[key](vals)\n\n    return cycler_inst\n\n\ndef validate_hist_bins(s):\n    valid_strs = [\"auto\", \"sturges\", \"fd\", \"doane\", \"scott\", \"rice\", \"sqrt\"]\n    if isinstance(s, str) and s in valid_strs:\n        return s\n    try:\n        return int(s)\n    except (TypeError, ValueError):\n        pass\n    try:\n        return validate_floatlist(s)\n    except ValueError:\n        pass\n    raise ValueError(f\"'hist.bins' must be one of {valid_strs}, an int or\"\n                     \" a sequence of floats\")\n\n\nclass _ignorecase(list):\n    \"\"\"A marker class indicating that a list-of-str is case-insensitive.\"\"\"\n\n\ndef _convert_validator_spec(key, conv):\n    if isinstance(conv, list):\n        ignorecase = isinstance(conv, _ignorecase)\n        return ValidateInStrings(key, conv, ignorecase=ignorecase)\n    else:\n        return conv\n\n\n# Mapping of rcParams to validators.\n# Converters given as lists or _ignorecase are converted to ValidateInStrings\n# immediately below.\n# The rcParams defaults are defined in lib/matplotlib/mpl-data/matplotlibrc, which\n# gets copied to matplotlib/mpl-data/matplotlibrc by the setup script.\n_validators = {\n    \"backend\":           validate_backend,\n    \"backend_fallback\":  validate_bool,\n    \"figure.hooks\":      validate_stringlist,\n    \"toolbar\":           _validate_toolba"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "scale.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " the value `None` is injected\n    as the first argument.\n\n    Examples\n    --------\n    >>> from matplotlib.scale import ScaleBase\n    >>> class CustomScale(ScaleBase):\n    ...     @_make_axis_parameter_optional\n    ...     def __init__(self, axis, custom_param=1):\n    ...         self.custom_param = custom_param\n    \"\"\"\n    @wraps(init_func)\n    def wrapper(self, *args, **kwargs):\n        if args and isinstance(args[0], mpl.axis.Axis):\n            return init_func(self, *args, **kwargs)\n        else:\n            # Remove 'axis' from kwargs to avoid double assignment\n            axis = kwargs.pop('axis', None)\n            return init_func(self, axis, *args, **kwargs)\n    return wrapper\n\n\nclass LinearScale(ScaleBase):\n    \"\"\"\n    The default linear scale.\n    \"\"\"\n\n    name = 'linear'\n\n    @_make_axis_parameter_optional\n    def __init__(self, axis):\n        # This method is present only to prevent inheritance of the base class'\n        # constructor docstring, which would otherwise end up interpolated into\n        # the docstring of Axis.set_scale.\n        \"\"\"\n        \"\"\"  # noqa: D419\n\n    def set_default_locators_and_formatters(self, axis):\n        # docstring inherited\n        axis.set_major_locator(AutoLocator())\n        axis.set_major_formatter(ScalarFormatter())\n        axis.set_minor_formatter(NullFormatter())\n        # update the minor locator for x and y axis based on rcParams\n        if (axis.axis_name == 'x' and mpl.rcParams['xtick.minor.visible'] or\n                axis.axis_name == 'y' and mpl.rcParams['ytick.minor.visible']):\n            axis.set_minor_locator(AutoMinorLocator())\n        else:\n            axis.set_minor_locator(NullLocator())\n\n    def get_transform(self):\n        \"\"\"\n        Return the transform for linear scaling, which is just the\n        `~matplotlib.transforms.IdentityTransform`.\n        \"\"\"\n        return IdentityTransform()\n\n\nclass FuncTransform(Transform):\n    \"\"\"\n    A simple transform that takes and arbitrary function for the\n  "}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "boilerplate.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap({name!r})\n'''  # Colormap functions.\n\n\nclass value_formatter:\n    \"\"\"\n    Format function default values as needed for inspect.formatargspec.\n    The interesting part is a hard-coded list of functions used\n    as defaults in pyplot methods.\n    \"\"\"\n\n    def __init__(self, value):\n        if value is mlab.detrend_none:\n            self._repr = \"mlab.detrend_none\"\n        elif value is mlab.window_hanning:\n            self._repr = \"mlab.window_hanning\"\n        elif value is np.mean:\n            self._repr = \"np.mean\"\n        elif value is _api.deprecation._deprecated_parameter:\n            self._repr = \"_api.deprecation._deprecated_parameter\"\n        elif isinstance(value, Enum):\n            # Enum str is Class.Name whereas their repr is <Class.Name: value>.\n            self._repr = f'{type(value).__name__}.{value.name}'\n        else:\n            self._repr = repr(value)\n\n    def __repr__(self):\n        return self._repr\n\n\nclass direct_repr:\n    \"\"\"\n    A placeholder class to destringify annotations from ast\n    \"\"\"\n    def __init__(self, value):\n        self._repr = value\n\n    def __repr__(self):\n        return self._repr\n\n\ndef generate_function(name, called_fullname, template, **kwargs):\n    \"\"\"\n    Create a wrapper function *pyplot_name* calling *call_name*.\n\n    Parameters\n    ----------\n    name : str\n        The function to be created.\n    called_fullname : str\n        The method to be wrapped in the format ``\"Class.method\"``.\n    template : str\n        The template to be used. The template must contain {}-style format\n        placeholders. The following placeholders are filled in:\n\n        - name: The function name.\n        - signature: The function signature (including parentheses).\n        - called_name: The name of the called function.\n        - call: Parameters passed to *called_name* (including parentheses).\n\n    **kwargs\n        Additional parameters are passed to ``template.form"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " contextmanager, nullcontext\nfrom enum import Enum, IntEnum\nimport functools\nimport importlib\nimport inspect\nimport io\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport signal\nimport socket\nimport sys\nimport time\nimport weakref\nfrom weakref import WeakKeyDictionary\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import (\n    _api, backend_tools as tools, cbook, colors, _docstring, text,\n    _tight_bbox, transforms, widgets, is_interactive, rcParams)\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_managers import ToolManager\nfrom matplotlib.cbook import _setattr_cm\nfrom matplotlib.layout_engine import ConstrainedLayoutEngine\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib._enums import JoinStyle, CapStyle\n\n\n_log = logging.getLogger(__name__)\n_default_filetypes = {\n    'eps': 'Encapsulated Postscript',\n    'gif': 'Graphics Interchange Format',\n    'jpg': 'Joint Photographic Experts Group',\n    'jpeg': 'Joint Photographic Experts Group',\n    'pdf': 'Portable Document Format',\n    'pgf': 'PGF code for LaTeX',\n    'png': 'Portable Network Graphics',\n    'ps': 'Postscript',\n    'raw': 'Raw RGBA bitmap',\n    'rgba': 'Raw RGBA bitmap',\n    'svg': 'Scalable Vector Graphics',\n    'svgz': 'Scalable Vector Graphics',\n    'tif': 'Tagged Image File Format',\n    'tiff': 'Tagged Image File Format',\n    'webp': 'WebP Image Format',\n    'avif': 'AV1 Image File Format',\n}\n_default_backends = {\n    'eps': 'matplotlib.backends.backend_ps',\n    'gif': 'matplotlib.backends.backend_agg',\n    'jpg': 'matplotlib.backends.backend_agg',\n    'jpeg': 'matplotlib.backends.backend_agg',\n    'pdf': 'matplotlib.backends.backend_pdf',\n    'pgf': 'matplotlib.backends.backend_pgf',\n    'png': 'matplotlib.backends.backend_agg',\n    'ps': 'matplotlib.backends.backend_ps',\n    'raw': 'matplotlib.backends.backend_agg',\n    'rgba': 'matplotlib.backends.backend_agg',\n    'svg"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# rastrization when necessary. If the artist's draw method is already\n        # decorated (has a `_supports_rasterization` attribute), it won't be\n        # decorated.\n\n        if not hasattr(cls.draw, \"_supports_rasterization\"):\n            cls.draw = _prevent_rasterization(cls.draw)\n\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._update_set_signature_and_docstring()\n\n    _PROPERTIES_EXCLUDED_FROM_SET = [\n        'navigate_mode',  # not a user-facing function\n        'figure',         # changing the figure is such a profound operation\n                          # that we don't want this in set()\n        '3d_properties',  # cannot be used as a keyword due to leading digit\n    ]\n\n    @classmethod\n    def _update_set_signature_and_docstring(cls):\n        \"\"\"\n        Update the signature of the set function to list all properties\n        as keyword arguments.\n\n        Property aliases are not listed in the signature for brevity, but\n        are still accepted as keyword arguments.\n        \"\"\"\n        cls.set.__signature__ = Signature(\n            [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n             *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_api.UNSET)\n               for prop in ArtistInspector(cls).get_setters()\n               if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n        cls.set._aut"}], "retrieved_count": 10, "cost_time": 4.1149280071258545}
{"question": "How does the Ticks class maintain consistency between its marker-based rendering system and the inherited Line2D interface while supporting dynamic attribute delegation through the AttributeCopier pattern?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eCollection\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import (\n    Affine2D, Bbox, IdentityTransform, ScaledTranslation)\n\nfrom .axisline_style import AxislineStyle\n\n\nclass AttributeCopier:\n    def get_ref_artist(self):\n        \"\"\"\n        Return the underlying artist that actually defines some properties\n        (e.g., color) of this artist.\n        \"\"\"\n        raise RuntimeError(\"get_ref_artist must overridden\")\n\n    def get_attribute_from_ref_artist(self, attr_name):\n        getter = methodcaller(\"get_\" + attr_name)\n        prop = getter(super())\n        return getter(self.get_ref_artist()) if prop == \"auto\" else prop\n\n\nclass Ticks(AttributeCopier, Line2D):\n    \"\"\"\n    Ticks are derived from `.Line2D`, and note that ticks themselves\n    are markers. Thus, you should use set_mec, set_mew, etc.\n\n    To change the tick size (length), you need to use\n    `set_ticksize`. To change the direction of the ticks (ticks are\n    in opposite direction of ticklabels by default), use\n    ``set_tick_out(False)``\n    \"\"\"\n\n    def __init__(self, ticksize, tick_out=False, *, axis=None, **kwargs):\n        self._ticksize = ticksize\n        self.locs_angles_labels = []\n\n        self.set_tick_out(tick_out)\n\n        self._axis = axis\n        if self._axis is not None:\n            if \"color\" not in kwargs:\n                kwargs[\"color\"] = \"auto\"\n            if \"mew\" not in kwargs and \"markeredgewidth\" not in kwargs:\n                kwargs[\"markeredgewidth\"] = \"auto\"\n\n        Line2D.__init__(self, [0.], [0.], **kwargs)\n        self.set_snap(True)\n\n    def get_ref_artist(self):\n        # docstring inherited\n        return self._axis.majorTicks[0].tick1line\n\n    def set_color(self, color):\n        # docstring inherited\n        # Unlike the base Line2D.set_color, this also supports \"auto\".\n        if not cbook._str_equal(color, \"auto\"):\n            mcolors._check_color_like(color=color)\n        sel"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e     90     0        -90    180\naxislabel angle     180    0        0      180\nticklabel va        center baseline center baseline\naxislabel va        center top      center bottom\nticklabel ha        right  center   right  center\naxislabel ha        right  center   right  center\n=================== ====== ======== ====== ========\n\nTicks are by default direct opposite side of the ticklabels. To make ticks to\nthe same side of the ticklabels, ::\n\n  ax.axis[\"bottom\"].major_ticks.set_tick_out(True)\n\nThe following attributes can be customized (use the ``set_xxx`` methods):\n\n* `Ticks`: ticksize, tick_out\n* `TickLabels`: pad\n* `AxisLabel`: pad\n\"\"\"\n\n# FIXME :\n# angles are given in data coordinate - need to convert it to canvas coordinate\n\n\nfrom operator import methodcaller\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook\nimport matplotlib.artist as martist\nimport matplotlib.colors as mcolors\nimport matplotlib.text as mtext\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import (\n    Affine2D, Bbox, IdentityTransform, ScaledTranslation)\n\nfrom .axisline_style import AxislineStyle\n\n\nclass AttributeCopier:\n    def get_ref_artist(self):\n        \"\"\"\n        Return the underlying artist that actually defines some properties\n        (e.g., color) of this artist.\n        \"\"\"\n        raise RuntimeError(\"get_ref_artist must overridden\")\n\n    def get_attribute_from_ref_artist(self, attr_name):\n        getter = methodcaller(\"get_\" + attr_name)\n        prop = getter(super())\n        return getter(self.get_ref_artist()) if prop == \"auto\" else prop\n\n\nclass Ticks(AttributeCopier, Line2D):\n    \"\"\"\n    Ticks are derived from `.Line2D`, and note that ticks themselves\n    are markers. Thus, you should use set_mec, set_mew, etc.\n\n    To change the tick size (length), you need to use\n    `set_ticksize`. To change the direction "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "of the ticks (ticks are\n    in opposite direction of ticklabels by default), use\n    ``set_tick_out(False)``\n    \"\"\"\n\n    def __init__(self, ticksize, tick_out=False, *, axis=None, **kwargs):\n        self._ticksize = ticksize\n        self.locs_angles_labels = []\n\n        self.set_tick_out(tick_out)\n\n        self._axis = axis\n        if self._axis is not None:\n            if \"color\" not in kwargs:\n                kwargs[\"color\"] = \"auto\"\n            if \"mew\" not in kwargs and \"markeredgewidth\" not in kwargs:\n                kwargs[\"markeredgewidth\"] = \"auto\"\n\n        Line2D.__init__(self, [0.], [0.], **kwargs)\n        self.set_snap(True)\n\n    def get_ref_artist(self):\n        # docstring inherited\n        return self._axis.majorTicks[0].tick1line\n\n    def set_color(self, color):\n        # docstring inherited\n        # Unlike the base Line2D.set_color, this also supports \"auto\".\n        if not cbook._str_equal(color, \"auto\"):\n            mcolors._check_color_like(color=color)\n        self._color = color\n        self.stale = True\n\n    def get_color(self):\n        return self.get_attribute_from_ref_artist(\"color\")\n\n    def get_markeredgecolor(self):\n        return self.get_attribute_from_ref_artist(\"markeredgecolor\")\n\n    def get_markeredgewidth(self):\n        return self.get_attribute_from_ref_artist(\"markeredgewidth\")\n\n    def set_tick_out(self, b):\n        \"\"\"Set whether ticks are drawn inside or outside the axes.\"\"\"\n        self._tick_out = b\n\n    def get_tick_out(self):\n        \"\"\"Return whether ticks are drawn inside or outside the axes.\"\"\"\n        return self._tick_out\n\n    def set_ticksize(self, ticksize):\n        \"\"\"Set length of the ticks in points.\"\"\"\n        self._ticksize = ticksize\n\n    def get_ticksize(self):\n        \"\"\"Return length of the ticks in points.\"\"\"\n        return self._ticksize\n\n    def set_locs_angles(self, locs_angles):\n        self.locs_angles = locs_angles\n\n    _tickvert_path = Path([[0., 0.], [1., 0.]])\n\n    def draw(self, renderer):\n    "}, {"start_line": 17000, "end_line": 18390, "belongs_to": {"file_name": "patheffects.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ick, s, y)\n\n            # Find unit vectors in local direction of curve\n            delta_s = self._spacing * .001\n            u = (np.interp(s_tick + delta_s, s, x) - x_tick) / delta_s\n            v = (np.interp(s_tick + delta_s, s, y) - y_tick) / delta_s\n\n            # Normalize slope into unit slope vector.\n            n = np.hypot(u, v)\n            mask = n == 0\n            n[mask] = 1.0\n\n            uv = np.array([u / n, v / n]).T\n            uv[mask] = np.array([0, 0]).T\n\n            # Rotate and scale unit vector into tick vector\n            dxy = np.dot(uv, trans_matrix) * self._length * spacing_px\n\n            # Build tick endpoints\n            x_end = x_tick + dxy[:, 0]\n            y_end = y_tick + dxy[:, 1]\n\n            # Interleave ticks to form Path vertices\n            xyt = np.empty((2 * num, 2), dtype=x_tick.dtype)\n            xyt[0::2, 0] = x_tick\n            xyt[1::2, 0] = x_end\n            xyt[0::2, 1] = y_tick\n            xyt[1::2, 1] = y_end\n\n            # Build up vector of Path codes\n            codes = np.tile([Path.MOVETO, Path.LINETO], num)\n\n            # Construct and draw resulting path\n            h = Path(xyt, codes)\n            # Transform back to data space during render\n            renderer.draw_path(gc0, h, affine.inverted() + trans, rgbFace)\n\n        gc0.restore()\n\n\nwithTickedStroke = _subclass_with_normal(effect_class=TickedStroke)\n"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "polar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/projections", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.get_figure(root=False).dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)\n\n    def _apply_params(self, **kwargs):\n        super()._apply_params(**kwargs)\n        # Ensure transform is correct; sometimes this gets reset.\n        trans = self.label1.get_transform()\n        if not trans.contains_branch(self._text1_translate):\n            self.label1.set_transform(trans + self._text1_translate)\n        trans = self.label2.get_transform()\n        if not trans.contains_branch(self._text2_translate):\n            self.label2.set_transform(trans + self._text2_translate)\n\n    def _update_padding(self, pad, angle):\n        padx = pad * np.cos(angle) / 72\n        pady = pad * np.sin(angle) / 72\n        self._text1_translate._t = (padx, pady)\n        self._text1_translate.invalidate()\n        self._text2_translate._t = (-padx, -pady)\n        self._text2_translate.invalidate()\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_mark"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       .get_transformed_points_and_affine())\n            else:\n                tpath, affine = (self._get_transformed_path()\n                                 .get_transformed_points_and_affine())\n\n            if len(tpath.vertices):\n                # subsample the markers if markevery is not None\n                markevery = self.get_markevery()\n                if markevery is not None:\n                    subsampled = _mark_every_path(\n                        markevery, tpath, affine, self.axes)\n                else:\n                    subsampled = tpath\n\n                snap = marker.get_snap_threshold()\n                if isinstance(snap, Real):\n                    snap = renderer.points_to_pixels(self._markersize) >= snap\n                gc.set_snap(snap)\n                gc.set_joinstyle(marker.get_joinstyle())\n                gc.set_capstyle(marker.get_capstyle())\n                marker_path = marker.get_path()\n                marker_trans = marker.get_transform()\n                w = renderer.points_to_pixels(self._markersize)\n\n                if cbook._str_equal(marker.get_marker(), \",\"):\n                    gc.set_linewidth(0)\n                else:\n                    # Don't scale for pixels, and don't stroke them\n                    marker_trans = marker_trans.scale(w)\n                renderer.draw_markers(gc, marker_path, marker_trans,\n                                      subsampled, affine.frozen(),\n                                      fc_rgba)\n\n                alt_marker_path = marker.get_alt_path()\n                if alt_marker_path:\n                    alt_marker_trans = marker.get_alt_transform()\n                    alt_marker_trans = alt_marker_trans.scale(w)\n                    renderer.draw_markers(\n                            gc, alt_marker_path, alt_marker_trans, subsampled,\n                            affine.frozen(), fcalt_rgba)\n\n            gc.restore()\n\n        renderer.close_group('line2d')\n        self.stale = False\n\n    def get_antialias"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "w = renderer.points_to_pixels(self._markersize)\n\n                if cbook._str_equal(marker.get_marker(), \",\"):\n                    gc.set_linewidth(0)\n                else:\n                    # Don't scale for pixels, and don't stroke them\n                    marker_trans = marker_trans.scale(w)\n                renderer.draw_markers(gc, marker_path, marker_trans,\n                                      subsampled, affine.frozen(),\n                                      fc_rgba)\n\n                alt_marker_path = marker.get_alt_path()\n                if alt_marker_path:\n                    alt_marker_trans = marker.get_alt_transform()\n                    alt_marker_trans = alt_marker_trans.scale(w)\n                    renderer.draw_markers(\n                            gc, alt_marker_path, alt_marker_trans, subsampled,\n                            affine.frozen(), fcalt_rgba)\n\n            gc.restore()\n\n        renderer.close_group('line2d')\n        self.stale = False\n\n    def get_antialiased(self):\n        \"\"\"Return whether antialiased rendering is used.\"\"\"\n        return self._antialiased\n\n    def get_color(self):\n        \"\"\"\n        Return the line color.\n\n        See also `~.Line2D.set_color`.\n        \"\"\"\n        return self._color\n\n    def get_drawstyle(self):\n        \"\"\"\n        Return the drawstyle.\n\n        See also `~.Line2D.set_drawstyle`.\n        \"\"\"\n        return self._drawstyle\n\n    def get_gapcolor(self):\n        \"\"\"\n        Return the line gapcolor.\n\n        See also `~.Line2D.set_gapcolor`.\n        \"\"\"\n        return self._gapcolor\n\n    def get_linestyle(self):\n        \"\"\"\n        Return the linestyle.\n\n        See also `~.Line2D.set_linestyle`.\n        \"\"\"\n        return self._linestyle\n\n    def get_linewidth(self):\n        \"\"\"\n        Return the linewidth in points.\n\n        See also `~.Line2D.set_linewidth`.\n        \"\"\"\n        return self._linewidth\n\n    def get_marker(self):\n        \"\"\"\n        Return the line marker.\n\n        See also `~.Line2D.set"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tist_helper.get_line_transform(self.axes)\n                + self.offset_transform)\n\n        axisline_style = self.get_axisline_style()\n        if axisline_style is None:\n            self.line = PathPatch(\n                self._axis_artist_helper.get_line(self.axes),\n                color=mpl.rcParams['axes.edgecolor'],\n                fill=False,\n                linewidth=mpl.rcParams['axes.linewidth'],\n                capstyle=mpl.rcParams['lines.solid_capstyle'],\n                joinstyle=mpl.rcParams['lines.solid_joinstyle'],\n                transform=tran)\n        else:\n            self.line = axisline_style(self, transform=tran)\n\n    def _draw_line(self, renderer):\n        self.line.set_path(self._axis_artist_helper.get_line(self.axes))\n        if self.get_axisline_style() is not None:\n            self.line.set_line_mutation_scale(self.major_ticklabels.get_size())\n        self.line.draw(renderer)\n\n    def _init_ticks(self, **kwargs):\n        axis_name = self.axis.axis_name\n\n        trans = (self._axis_artist_helper.get_tick_transform(self.axes)\n                 + self.offset_transform)\n\n        self.major_ticks = Ticks(\n            kwargs.get(\n                \"major_tick_size\",\n                mpl.rcParams[f\"{axis_name}tick.major.size\"]),\n            axis=self.axis, transform=trans)\n        self.minor_ticks = Ticks(\n            kwargs.get(\n                \"minor_tick_size\",\n                mpl.rcParams[f\"{axis_name}tick.minor.size\"]),\n            axis=self.axis, transform=trans)\n\n        size = mpl.rcParams[f\"{axis_name}tick.labelsize\"]\n        self.major_ticklabels = TickLabels(\n            axis=self.axis,\n            axis_direction=self._axis_direction,\n            figure=self.axes.get_figure(root=False),\n            transform=trans,\n            fontsize=size,\n            pad=kwargs.get(\n                \"major_tick_pad\", mpl.rcParams[f\"{axis_name}tick.major.pad\"]),\n        )\n        self.minor_ticklabels = TickLabels(\n            axis=self.axis,\n            a"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f._color = color\n        self.stale = True\n\n    def get_color(self):\n        return self.get_attribute_from_ref_artist(\"color\")\n\n    def get_markeredgecolor(self):\n        return self.get_attribute_from_ref_artist(\"markeredgecolor\")\n\n    def get_markeredgewidth(self):\n        return self.get_attribute_from_ref_artist(\"markeredgewidth\")\n\n    def set_tick_out(self, b):\n        \"\"\"Set whether ticks are drawn inside or outside the axes.\"\"\"\n        self._tick_out = b\n\n    def get_tick_out(self):\n        \"\"\"Return whether ticks are drawn inside or outside the axes.\"\"\"\n        return self._tick_out\n\n    def set_ticksize(self, ticksize):\n        \"\"\"Set length of the ticks in points.\"\"\"\n        self._ticksize = ticksize\n\n    def get_ticksize(self):\n        \"\"\"Return length of the ticks in points.\"\"\"\n        return self._ticksize\n\n    def set_locs_angles(self, locs_angles):\n        self.locs_angles = locs_angles\n\n    _tickvert_path = Path([[0., 0.], [1., 0.]])\n\n    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        gc = renderer.new_gc()\n        gc.set_foreground(self.get_markeredgecolor())\n        gc.set_linewidth(self.get_markeredgewidth())\n        gc.set_alpha(self._alpha)\n\n        path_trans = self.get_transform()\n        marker_transform = (Affine2D()\n                            .scale(renderer.points_to_pixels(self._ticksize)))\n        if self.get_tick_out():\n            marker_transform.rotate_deg(180)\n\n        for loc, angle in self.locs_angles:\n            locs = path_trans.transform_non_affine(np.array([loc]))\n            if self.axes and not self.axes.viewLim.contains(*locs[0]):\n                continue\n            renderer.draw_markers(\n                gc, self._tickvert_path,\n                marker_transform + Affine2D().rotate_deg(angle),\n                Path(locs), path_trans.get_affine())\n\n        gc.restore()\n\n\nclass LabelBase(mtext.Text):\n    \"\"\"\n    A base class for `.AxisLabel` and `.TickLabels`. The position and\n    a"}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "().update_from(other)\n        self._linestyle = other._linestyle\n        self._linewidth = other._linewidth\n        self._color = other._color\n        self._gapcolor = other._gapcolor\n        self._markersize = other._markersize\n        self._markerfacecolor = other._markerfacecolor\n        self._markerfacecoloralt = other._markerfacecoloralt\n        self._markeredgecolor = other._markeredgecolor\n        self._markeredgewidth = other._markeredgewidth\n        self._unscaled_dash_pattern = other._unscaled_dash_pattern\n        self._dash_pattern = other._dash_pattern\n        self._dashcapstyle = other._dashcapstyle\n        self._dashjoinstyle = other._dashjoinstyle\n        self._solidcapstyle = other._solidcapstyle\n        self._solidjoinstyle = other._solidjoinstyle\n\n        self._marker = MarkerStyle(marker=other._marker)\n        self._drawstyle = other._drawstyle\n\n    @_docstring.interpd\n    def set_dash_joinstyle(self, s):\n        \"\"\"\n        How to join segments of the line if it `~Line2D.is_dashed`.\n\n        The default joinstyle is :rc:`lines.dash_joinstyle`.\n\n        Parameters\n        ----------\n        s : `.JoinStyle` or %(JoinStyle)s\n        \"\"\"\n        js = JoinStyle(s)\n        if self._dashjoinstyle != js:\n            self.stale = True\n        self._dashjoinstyle = js\n\n    @_docstring.interpd\n    def set_solid_joinstyle(self, s):\n        \"\"\"\n        How to join segments if the line is solid (not `~Line2D.is_dashed`).\n\n        The default joinstyle is :rc:`lines.solid_joinstyle`.\n\n        Parameters\n        ----------\n        s : `.JoinStyle` or %(JoinStyle)s\n        \"\"\"\n        js = JoinStyle(s)\n        if self._solidjoinstyle != js:\n            self.stale = True\n        self._solidjoinstyle = js\n\n    def get_dash_joinstyle(self):\n        \"\"\"\n        Return the `.JoinStyle` for dashed lines.\n\n        See also `~.Line2D.set_dash_joinstyle`.\n        \"\"\"\n        return self._dashjoinstyle.name\n\n    def get_solid_joinstyle(self):\n        \"\"\"\n        Return th"}], "retrieved_count": 10, "cost_time": 4.17954683303833}
{"question": "Why does the LayoutGrid class leverage the kiwisolver constraint system to maintain consistent spatial relationships between parent and child grids while allowing dynamic margin adjustments?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " -\n                    self.margins['leftcb'][i])\n                  ]\n            for c in hc:\n                self.solver.addConstraint(c | 'required')\n\n        for i in range(self.nrows):\n            hc = [self.tops[i] >= self.bottoms[i],\n                  (self.tops[i] - self.margins['top'][i] -\n                    self.margins['topcb'][i] >=\n                    self.bottoms[i] - self.margins['bottom'][i] -\n                    self.margins['bottomcb'][i])\n                  ]\n            for c in hc:\n                self.solver.addConstraint(c | 'required')\n\n    def add_child(self, child, i=0, j=0):\n        # np.ix_ returns the cross product of i and j indices\n        self.children[np.ix_(np.atleast_1d(i), np.atleast_1d(j))] = child\n\n    def parent_constraints(self, parent):\n        # constraints that are due to the parent...\n        # i.e. the first column's left is equal to the\n        # parent's left, the last column right equal to the\n        # parent's right...\n        if not isinstance(parent, LayoutGrid):\n            # specify a rectangle in figure coordinates\n            hc = [self.lefts[0] == parent[0],\n                  self.rights[-1] == parent[0] + parent[2],\n                  # top and bottom reversed order...\n                  self.tops[0] == parent[1] + parent[3],\n                  self.bottoms[-1] == parent[1]]\n        else:\n            rows, cols = self.parent_pos\n            rows = np.atleast_1d(rows)\n            cols = np.atleast_1d(cols)\n\n            left = parent.lefts[cols[0]]\n            right = parent.rights[cols[-1]]\n            top = parent.tops[rows[0]]\n            bottom = parent.bottoms[rows[-1]]\n            if self.parent_inner:\n                # the layout grid is contained inside the inner\n                # grid of the parent.\n                left += parent.margins['left'][cols[0]]\n                left += parent.margins['leftcb'][cols[0]]\n                right -= parent.margins['right'][cols[-1]]\n                right -= parent.marg"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "youtGrid\n            # allows specifying a rectangle to contain the layout.\n            self.solver = kiwi.Solver()\n        else:\n            parent.add_child(self, *parent_pos)\n            self.solver = parent.solver\n        # keep track of artist associated w/ this layout.  Can be none\n        self.artists = np.empty((nrows, ncols), dtype=object)\n        self.children = np.empty((nrows, ncols), dtype=object)\n\n        self.margins = {}\n        self.margin_vals = {}\n        # all the boxes in each column share the same left/right margins:\n        for todo in ['left', 'right', 'leftcb', 'rightcb']:\n            # track the value so we can change only if a margin is larger\n            # than the current value\n            self.margin_vals[todo] = np.zeros(ncols)\n\n        sol = self.solver\n\n        self.lefts = [Variable(f'{sn}lefts[{i}]') for i in range(ncols)]\n        self.rights = [Variable(f'{sn}rights[{i}]') for i in range(ncols)]\n        for todo in ['left', 'right', 'leftcb', 'rightcb']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(ncols)]\n            for i in range(ncols):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = np.empty((nrows), dtype=object)\n            self.margin_vals[todo] = np.zeros(nrows)\n\n        self.bottoms = [Variable(f'{sn}bottoms[{i}]') for i in range(nrows)]\n        self.tops = [Variable(f'{sn}tops[{i}]') for i in range(nrows)]\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(nrows)]\n            for i in range(nrows):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        # set these margins to zero by default. They will be edited as\n        # children are filled.\n        self.reset_margins()\n        s"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ins['rightcb'][cols[-1]]\n                top -= parent.margins['top'][rows[0]]\n                top -= parent.margins['topcb'][rows[0]]\n                bottom += parent.margins['bottom'][rows[-1]]\n                bottom += parent.margins['bottomcb'][rows[-1]]\n            hc = [self.lefts[0] == left,\n                  self.rights[-1] == right,\n                  # from top to bottom\n                  self.tops[0] == top,\n                  self.bottoms[-1] == bottom]\n        for c in hc:\n            self.solver.addConstraint(c | 'required')\n\n    def grid_constraints(self):\n        # constrain the ratio of the inner part of the grids\n        # to be the same (relative to width_ratios)\n\n        # constrain widths:\n        w = (self.rights[0] - self.margins['right'][0] -\n             self.margins['rightcb'][0])\n        w = (w - self.lefts[0] - self.margins['left'][0] -\n             self.margins['leftcb'][0])\n        w0 = w / self.width_ratios[0]\n        # from left to right\n        for i in range(1, self.ncols):\n            w = (self.rights[i] - self.margins['right'][i] -\n                 self.margins['rightcb'][i])\n            w = (w - self.lefts[i] - self.margins['left'][i] -\n                 self.margins['leftcb'][i])\n            c = (w == w0 * self.width_ratios[i])\n            self.solver.addConstraint(c | 'strong')\n            # constrain the grid cells to be directly next to each other.\n            c = (self.rights[i - 1] == self.lefts[i])\n            self.solver.addConstraint(c | 'strong')\n\n        # constrain heights:\n        h = self.tops[0] - self.margins['top'][0] - self.margins['topcb'][0]\n        h = (h - self.bottoms[0] - self.margins['bottom'][0] -\n             self.margins['bottomcb'][0])\n        h0 = h / self.height_ratios[0]\n        # from top to bottom:\n        for i in range(1, self.nrows):\n            h = (self.tops[i] - self.margins['top'][i] -\n                 self.margins['topcb'][i])\n            h = (h - self.bottoms[i] - self.margins['bottom'][i] "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "instance(parent, LayoutGrid):\n            # specify a rectangle in figure coordinates\n            hc = [self.lefts[0] == parent[0],\n                  self.rights[-1] == parent[0] + parent[2],\n                  # top and bottom reversed order...\n                  self.tops[0] == parent[1] + parent[3],\n                  self.bottoms[-1] == parent[1]]\n        else:\n            rows, cols = self.parent_pos\n            rows = np.atleast_1d(rows)\n            cols = np.atleast_1d(cols)\n\n            left = parent.lefts[cols[0]]\n            right = parent.rights[cols[-1]]\n            top = parent.tops[rows[0]]\n            bottom = parent.bottoms[rows[-1]]\n            if self.parent_inner:\n                # the layout grid is contained inside the inner\n                # grid of the parent.\n                left += parent.margins['left'][cols[0]]\n                left += parent.margins['leftcb'][cols[0]]\n                right -= parent.margins['right'][cols[-1]]\n                right -= parent.margins['rightcb'][cols[-1]]\n                top -= parent.margins['top'][rows[0]]\n                top -= parent.margins['topcb'][rows[0]]\n                bottom += parent.margins['bottom'][rows[-1]]\n                bottom += parent.margins['bottomcb'][rows[-1]]\n            hc = [self.lefts[0] == left,\n                  self.rights[-1] == right,\n                  # from top to bottom\n                  self.tops[0] == top,\n                  self.bottoms[-1] == bottom]\n        for c in hc:\n            self.solver.addConstraint(c | 'required')\n\n    def grid_constraints(self):\n        # constrain the ratio of the inner part of the grids\n        # to be the same (relative to width_ratios)\n\n        # constrain widths:\n        w = (self.rights[0] - self.margins['right'][0] -\n             self.margins['rightcb'][0])\n        w = (w - self.lefts[0] - self.margins['left'][0] -\n             self.margins['leftcb'][0])\n        w0 = w / self.width_ratios[0]\n        # from left to right\n        for i in r"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "id:\n    \"\"\"\n    Analogous to a gridspec, and contained in another LayoutGrid.\n    \"\"\"\n\n    def __init__(self, parent=None, parent_pos=(0, 0),\n                 parent_inner=False, name='', ncols=1, nrows=1,\n                 h_pad=None, w_pad=None, width_ratios=None,\n                 height_ratios=None):\n        Variable = kiwi.Variable\n        self.parent_pos = parent_pos\n        self.parent_inner = parent_inner\n        self.name = name + seq_id()\n        if isinstance(parent, LayoutGrid):\n            self.name = f'{parent.name}.{self.name}'\n        self.nrows = nrows\n        self.ncols = ncols\n        self.height_ratios = np.atleast_1d(height_ratios)\n        if height_ratios is None:\n            self.height_ratios = np.ones(nrows)\n        self.width_ratios = np.atleast_1d(width_ratios)\n        if width_ratios is None:\n            self.width_ratios = np.ones(ncols)\n\n        sn = self.name + '_'\n        if not isinstance(parent, LayoutGrid):\n            # parent can be a rect if not a LayoutGrid\n            # allows specifying a rectangle to contain the layout.\n            self.solver = kiwi.Solver()\n        else:\n            parent.add_child(self, *parent_pos)\n            self.solver = parent.solver\n        # keep track of artist associated w/ this layout.  Can be none\n        self.artists = np.empty((nrows, ncols), dtype=object)\n        self.children = np.empty((nrows, ncols), dtype=object)\n\n        self.margins = {}\n        self.margin_vals = {}\n        # all the boxes in each column share the same left/right margins:\n        for todo in ['left', 'right', 'leftcb', 'rightcb']:\n            # track the value so we can change only if a margin is larger\n            # than the current value\n            self.margin_vals[todo] = np.zeros(ncols)\n\n        sol = self.solver\n\n        self.lefts = [Variable(f'{sn}lefts[{i}]') for i in range(ncols)]\n        self.rights = [Variable(f'{sn}rights[{i}]') for i in range(ncols)]\n        for todo in ['left', 'right', 'leftcb', 'rightc"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "_constrained_layout.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "in the grid\n        # match in margin size.\n        match_submerged_margins(layoutgrids, fig)\n\n        # update all the variables in the layout.\n        layoutgrids[fig].update_variables()\n\n        warn_collapsed = ('constrained_layout not applied because '\n                          'axes sizes collapsed to zero.  Try making '\n                          'figure larger or Axes decorations smaller.')\n        if check_no_collapsed_axes(layoutgrids, fig):\n            reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                            w_pad=w_pad, hspace=hspace, wspace=wspace)\n            if compress:\n                layoutgrids = compress_fixed_aspect(layoutgrids, fig)\n                layoutgrids[fig].update_variables()\n                if check_no_collapsed_axes(layoutgrids, fig):\n                    reposition_axes(layoutgrids, fig, renderer, h_pad=h_pad,\n                                    w_pad=w_pad, hspace=hspace, wspace=wspace)\n                else:\n                    _api.warn_external(warn_collapsed)\n\n                if ((suptitle := fig._suptitle) is not None and\n                        suptitle.get_in_layout() and suptitle._autopos):\n                    x, _ = suptitle.get_position()\n                    suptitle.set_position(\n                        (x, layoutgrids[fig].get_inner_bbox().y1 + h_pad))\n                    suptitle.set_verticalalignment('bottom')\n        else:\n            _api.warn_external(warn_collapsed)\n        reset_margins(layoutgrids, fig)\n    return layoutgrids\n\n\ndef make_layoutgrids(fig, layoutgrids, rect=(0, 0, 1, 1)):\n    \"\"\"\n    Make the layoutgrid tree.\n\n    (Sub)Figures get a layoutgrid so we can have figure margins.\n\n    Gridspecs that are attached to Axes get a layoutgrid so Axes\n    can have margins.\n    \"\"\"\n\n    if layoutgrids is None:\n        layoutgrids = dict()\n        layoutgrids['hasgrids'] = False\n    if not hasattr(fig, '_parent'):\n        # top figure;  pass rect as parent to allow user-specified\n        #"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "constrainedlayout_guide.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " draw.\n# 2. There is a bug - in which case open an issue at\n#    https://github.com/matplotlib/matplotlib/issues.\n#\n# If there is a bug, please report with a self-contained example that does\n# not require outside data or dependencies (other than numpy).\n\n# %%\n# .. _cl_notes_on_algorithm:\n#\n# Notes on the algorithm\n# ======================\n#\n# The algorithm for the constraint is relatively straightforward, but\n# has some complexity due to the complex ways we can lay out a figure.\n#\n# Layout in Matplotlib is carried out with gridspecs\n# via the `.GridSpec` class. A gridspec is a logical division of the figure\n# into rows and columns, with the relative width of the Axes in those\n# rows and columns set by *width_ratios* and *height_ratios*.\n#\n# In *constrained layout*, each gridspec gets a *layoutgrid* associated with\n# it.  The *layoutgrid* has a series of ``left`` and ``right`` variables\n# for each column, and ``bottom`` and ``top`` variables for each row, and\n# further it has a margin for each of left, right, bottom and top.  In each\n# row, the bottom/top margins are widened until all the decorators\n# in that row are accommodated.  Similarly, for columns and the left/right\n# margins.\n#\n#\n# Simple case: one Axes\n# ---------------------\n#\n# For a single Axes the layout is straight forward.  There is one parent\n# layoutgrid for the figure consisting of one column and row, and\n# a child layoutgrid for the gridspec that contains the Axes, again\n# consisting of one row and column. Space is made for the \"decorations\" on\n# each side of the Axes.  In the code, this is accomplished by the entries in\n# ``do_constrained_layout()`` like::\n#\n#     gridspec._layoutgrid[0, 0].edit_margin_min('left',\n#           -bbox.x0 + pos.x0 + w_pad)\n#\n# where ``bbox`` is the tight bounding box of the Axes, and ``pos`` its\n# position.  Note how the four margins encompass the Axes decorations.\n\nfrom matplotlib._layoutgrid import plot_children\n\nfig, ax = plt.subplots(layout=\"constrained\")\nexample_"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_constrained_layout.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  _api.warn_external(warn_collapsed)\n\n                if ((suptitle := fig._suptitle) is not None and\n                        suptitle.get_in_layout() and suptitle._autopos):\n                    x, _ = suptitle.get_position()\n                    suptitle.set_position(\n                        (x, layoutgrids[fig].get_inner_bbox().y1 + h_pad))\n                    suptitle.set_verticalalignment('bottom')\n        else:\n            _api.warn_external(warn_collapsed)\n        reset_margins(layoutgrids, fig)\n    return layoutgrids\n\n\ndef make_layoutgrids(fig, layoutgrids, rect=(0, 0, 1, 1)):\n    \"\"\"\n    Make the layoutgrid tree.\n\n    (Sub)Figures get a layoutgrid so we can have figure margins.\n\n    Gridspecs that are attached to Axes get a layoutgrid so Axes\n    can have margins.\n    \"\"\"\n\n    if layoutgrids is None:\n        layoutgrids = dict()\n        layoutgrids['hasgrids'] = False\n    if not hasattr(fig, '_parent'):\n        # top figure;  pass rect as parent to allow user-specified\n        # margins\n        layoutgrids[fig] = mlayoutgrid.LayoutGrid(parent=rect, name='figlb')\n    else:\n        # subfigure\n        gs = fig._subplotspec.get_gridspec()\n        # it is possible the gridspec containing this subfigure hasn't\n        # been added to the tree yet:\n        layoutgrids = make_layoutgrids_gs(layoutgrids, gs)\n        # add the layoutgrid for the subfigure:\n        parentlb = layoutgrids[gs]\n        layoutgrids[fig] = mlayoutgrid.LayoutGrid(\n            parent=parentlb,\n            name='panellb',\n            parent_inner=True,\n            nrows=1, ncols=1,\n            parent_pos=(fig._subplotspec.rowspan,\n                        fig._subplotspec.colspan))\n    # recursively do all subfigures in this figure...\n    for sfig in fig.subfigs:\n        layoutgrids = make_layoutgrids(sfig, layoutgrids)\n\n    # for each Axes at the local level add its gridspec:\n    for ax in fig._localaxes:\n        gs = ax.get_gridspec()\n        if gs is not None:\n            layoutgrids = make_"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\"\"\"\nA layoutgrid is a nrows by ncols set of boxes, meant to be used by\n`._constrained_layout`, each box is analogous to a subplotspec element of\na gridspec.\n\nEach box is defined by left[ncols], right[ncols], bottom[nrows] and top[nrows],\nand by two editable margins for each side.  The main margin gets its value\nset by the size of ticklabels, titles, etc on each Axes that is in the figure.\nThe outer margin is the padding around the Axes, and space for any\ncolorbars.\n\nThe \"inner\" widths and heights of these boxes are then constrained to be the\nsame (relative the values of `width_ratios[ncols]` and `height_ratios[nrows]`).\n\nThe layoutgrid is then constrained to be contained within a parent layoutgrid,\nits column(s) and row(s) specified when it is created.\n\"\"\"\n\nimport itertools\nimport kiwisolver as kiwi\nimport logging\nimport numpy as np\n\nimport matplotlib as mpl\nimport matplotlib.patches as mpatches\nfrom matplotlib.transforms import Bbox\n\n_log = logging.getLogger(__name__)\n\n\nclass LayoutGrid:\n    \"\"\"\n    Analogous to a gridspec, and contained in another LayoutGrid.\n    \"\"\"\n\n    def __init__(self, parent=None, parent_pos=(0, 0),\n                 parent_inner=False, name='', ncols=1, nrows=1,\n                 h_pad=None, w_pad=None, width_ratios=None,\n                 height_ratios=None):\n        Variable = kiwi.Variable\n        self.parent_pos = parent_pos\n        self.parent_inner = parent_inner\n        self.name = name + seq_id()\n        if isinstance(parent, LayoutGrid):\n            self.name = f'{parent.name}.{self.name}'\n        self.nrows = nrows\n        self.ncols = ncols\n        self.height_ratios = np.atleast_1d(height_ratios)\n        if height_ratios is None:\n            self.height_ratios = np.ones(nrows)\n        self.width_ratios = np.atleast_1d(width_ratios)\n        if width_ratios is None:\n            self.width_ratios = np.ones(ncols)\n\n        sn = self.name + '_'\n        if not isinstance(parent, LayoutGrid):\n            # parent can be a rect if not a La"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "_layoutgrid.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "b']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(ncols)]\n            for i in range(ncols):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = np.empty((nrows), dtype=object)\n            self.margin_vals[todo] = np.zeros(nrows)\n\n        self.bottoms = [Variable(f'{sn}bottoms[{i}]') for i in range(nrows)]\n        self.tops = [Variable(f'{sn}tops[{i}]') for i in range(nrows)]\n        for todo in ['bottom', 'top', 'bottomcb', 'topcb']:\n            self.margins[todo] = [Variable(f'{sn}margins[{todo}][{i}]')\n                                  for i in range(nrows)]\n            for i in range(nrows):\n                sol.addEditVariable(self.margins[todo][i], 'strong')\n\n        # set these margins to zero by default. They will be edited as\n        # children are filled.\n        self.reset_margins()\n        self.add_constraints(parent)\n\n        self.h_pad = h_pad\n        self.w_pad = w_pad\n\n    def __repr__(self):\n        str = f'LayoutBox: {self.name:25s} {self.nrows}x{self.ncols},\\n'\n        for i in range(self.nrows):\n            for j in range(self.ncols):\n                str += f'{i}, {j}: '\\\n                       f'L{self.lefts[j].value():1.3f}, ' \\\n                       f'B{self.bottoms[i].value():1.3f}, ' \\\n                       f'R{self.rights[j].value():1.3f}, ' \\\n                       f'T{self.tops[i].value():1.3f}, ' \\\n                       f'ML{self.margins[\"left\"][j].value():1.3f}, ' \\\n                       f'MR{self.margins[\"right\"][j].value():1.3f}, ' \\\n                       f'MB{self.margins[\"bottom\"][i].value():1.3f}, ' \\\n                       f'MT{self.margins[\"top\"][i].value():1.3f}, \\n'\n        return str\n\n    def reset_margins(self):\n        \"\"\"\n        Reset all the margins to zero.  Must do this after changing\n        figure size, for instance, because the r"}], "retrieved_count": 10, "cost_time": 4.160600900650024}
{"question": "Why does the repeated instantiation of CanvasFrame objects within MyApp's OnInit method impact memory allocation and garbage collection overhead in long-running wxPython applications with multiple frame creations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "memleak.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s: 10d}, \"\n              f\"nobjs {nobjs: 10d}, garbage {garbage: 4d}, \"\n              f\"files: {open_files: 4d}\")\n        if i == starti:\n            print(f'{\" warmup done \":-^86s}')\n        malloc_arr[i] = malloc\n        rss_arr[i] = rss\n        if rss > rss_peak:\n            rss_peak = rss\n        rss_peaks[i] = rss_peak\n        nobjs_arr[i] = nobjs\n        garbage_arr[i] = garbage\n        open_files_arr[i] = open_files\n\n    print('Average memory consumed per loop: {:1.4f} bytes\\n'.format(\n        np.sum(rss_peaks[starti+1:] - rss_peaks[starti:-1]) / (endi - starti)))\n\n    from matplotlib import pyplot as plt\n    from matplotlib.ticker import EngFormatter\n    bytes_formatter = EngFormatter(unit='B')\n    fig, (ax1, ax2, ax3) = plt.subplots(3)\n    for ax in (ax1, ax2, ax3):\n        ax.axvline(starti, linestyle='--', color='k')\n    ax1b = ax1.twinx()\n    ax1b.yaxis.set_major_formatter(bytes_formatter)\n    ax1.plot(malloc_arr, 'C0')\n    ax1b.plot(rss_arr, 'C1', label='rss')\n    ax1b.plot(rss_peaks, 'C1', linestyle='--', label='rss max')\n    ax1.set_ylabel('pymalloc', color='C0')\n    ax1b.set_ylabel('rss', color='C1')\n    ax1b.legend()\n\n    ax2b = ax2.twinx()\n    ax2.plot(nobjs_arr, 'C0')\n    ax2b.plot(garbage_arr, 'C1')\n    ax2.set_ylabel('total objects', color='C0')\n    ax2b.set_ylabel('garbage objects', color='C1')\n\n    ax3.plot(open_files_arr)\n    ax3.set_ylabel('open file handles')\n\n    if not report.endswith('.pdf'):\n        report = report + '.pdf'\n    fig.tight_layout()\n    fig.savefig(report, format='pdf')\n\n\nclass MemleakTest:\n    def __init__(self, empty):\n        self.empty = empty\n\n    def __call__(self):\n        import matplotlib.pyplot as plt\n\n        fig = plt.figure(1)\n\n        if not self.empty:\n            t1 = np.arange(0.0, 2.0, 0.01)\n            y1 = np.sin(2 * np.pi * t1)\n            y2 = np.random.rand(len(t1))\n            X = np.random.rand(50, 50)\n\n            ax = fig.add_subplot(221)\n            ax.plot(t1, y1, '-')\n            ax.plot(t1, y"}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        self.canvas = canvas_class(self, -1, fig)\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(self.FromDIP(wx.Size(w, h)))\n        self.canvas.SetMinSize(self.FromDIP(wx.Size(2, 2)))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)\n\n    def _on_close(self, event):\n        _log.debug(\"%s - on_close()\", type(self))\n        CloseEvent(\"close_event\", self.canvas)._process()\n        self.canvas.stop_event_loop()\n        # set FigureManagerWx.frame to None to prevent repeated attempts to\n        # close this frame from FigureManagerWx.destroy()\n        self.canvas.manager.frame = None\n        # remove figure manager from Gcf.figs\n        Gcf.destroy(self.canvas.manager)\n        try:  # See issue 2941338.\n            self.canvas.mpl_disconnect(self.canvas.toolbar._id_drag)\n        except AttributeError:  # If there's no toolbar.\n            pass\n        # Carry on with close event propagation, frame & children destruction\n        event.Skip()\n\n\nclass FigureManagerWx(FigureManagerBase):\n    \"\"\"\n    Container/controller for the FigureCanvas and GUI frame.\n\n    It is instantiated by Gcf whenever a new figure is created.  Gcf is\n    responsible for managing multiple instances of FigureManagerWx.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        a FigureCanvasWx(wx.Panel) instance\n    window : wxFrame\n        a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html\n    \"\"\"\n\n    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __in"}, {"start_line": 1000, "end_line": 2475, "belongs_to": {"file_name": "embedding_in_wx4_sgskip.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/user_interfaces", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        # random color\n        ax = self.canvas.figure.axes[0]\n        x, y = np.random.rand(2)  # generate a random location\n        rgb = np.random.rand(3)  # generate a random color\n        ax.text(x, y, 'You clicked me', transform=ax.transAxes, color=rgb)\n        self.canvas.draw()\n        event.Skip()\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure(figsize=(5, 4), dpi=100)\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n\n        self.toolbar = MyNavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n            self.Refresh()\n\n    print_bmp = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_BMP)\n    print_jpeg = print_jpg = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_JPEG)\n    print_pcx = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PCX)\n    print_png = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PNG)\n    print_tiff = print_tif = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_TIF)\n    print_xpm = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_XPM)\n\n\nclass FigureFrameWx(wx.Frame):\n    def __init__(self, num, fig, *, canvas_class):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        self.canvas = canvas_class(self, -1, fig)\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(self.FromDIP(wx.Size(w, h)))\n        self.canvas.SetMinSize(self.FromDIP(wx.Size(2, 2)))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)\n\n    def _on_close(self, event):\n        _log.debug(\"%s - on_close()\", type(self))\n        CloseEvent(\"close_event\", self.canvas)._process()\n        self.canvas.stop_event_loop()\n        # set FigureManagerWx.frame to None to prevent repeated attemp"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ts to\n        # close this frame from FigureManagerWx.destroy()\n        self.canvas.manager.frame = None\n        # remove figure manager from Gcf.figs\n        Gcf.destroy(self.canvas.manager)\n        try:  # See issue 2941338.\n            self.canvas.mpl_disconnect(self.canvas.toolbar._id_drag)\n        except AttributeError:  # If there's no toolbar.\n            pass\n        # Carry on with close event propagation, frame & children destruction\n        event.Skip()\n\n\nclass FigureManagerWx(FigureManagerBase):\n    \"\"\"\n    Container/controller for the FigureCanvas and GUI frame.\n\n    It is instantiated by Gcf whenever a new figure is created.  Gcf is\n    responsible for managing multiple instances of FigureManagerWx.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        a FigureCanvasWx(wx.Panel) instance\n    window : wxFrame\n        a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html\n    \"\"\"\n\n    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager\n\n    @classmethod\n    def start_main_loop(cls):\n        if not wx.App.IsMainLoopRunning():\n            wxapp = wx.GetApp()\n            if wxapp is not None:\n                wxapp.MainLoop()\n\n    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()\n\n    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.fram"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "it__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager\n\n    @classmethod\n    def start_main_loop(cls):\n        if not wx.App.IsMainLoopRunning():\n            wxapp = wx.GetApp()\n            if wxapp is not None:\n                wxapp.MainLoop()\n\n    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()\n\n    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            # As this can be called from non-GUI thread from plt.close use\n            # wx.CallAfter to ensure thread safety.\n            wx.CallAfter(frame.Close)\n\n    def full_screen_toggle(self):\n        # docstring inherited\n        self.frame.ShowFullScreen(not self.frame.IsFullScreen())\n\n    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()\n\n    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)\n\n    def resize(self, width, height):\n        # docstring inherited\n        # Directly using SetClientSize doesn't handle the toolbar on Windows.\n        self.window.SetSize(self.window.ClientToWindowSize(wx.Size(\n            math.ceil(width), math.ceil(height))))\n\n\ndef _load_bitmap(filename):\n    \"\"\"\n    Load a wx.Bitmap from a file in the \"images\" directory of the Matplotlib\n    data.\n    \"\"\"\n    return wx.Bitmap("}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "memleak.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t(rss_peaks, 'C1', linestyle='--', label='rss max')\n    ax1.set_ylabel('pymalloc', color='C0')\n    ax1b.set_ylabel('rss', color='C1')\n    ax1b.legend()\n\n    ax2b = ax2.twinx()\n    ax2.plot(nobjs_arr, 'C0')\n    ax2b.plot(garbage_arr, 'C1')\n    ax2.set_ylabel('total objects', color='C0')\n    ax2b.set_ylabel('garbage objects', color='C1')\n\n    ax3.plot(open_files_arr)\n    ax3.set_ylabel('open file handles')\n\n    if not report.endswith('.pdf'):\n        report = report + '.pdf'\n    fig.tight_layout()\n    fig.savefig(report, format='pdf')\n\n\nclass MemleakTest:\n    def __init__(self, empty):\n        self.empty = empty\n\n    def __call__(self):\n        import matplotlib.pyplot as plt\n\n        fig = plt.figure(1)\n\n        if not self.empty:\n            t1 = np.arange(0.0, 2.0, 0.01)\n            y1 = np.sin(2 * np.pi * t1)\n            y2 = np.random.rand(len(t1))\n            X = np.random.rand(50, 50)\n\n            ax = fig.add_subplot(221)\n            ax.plot(t1, y1, '-')\n            ax.plot(t1, y2, 's')\n\n            ax = fig.add_subplot(222)\n            ax.imshow(X)\n\n            ax = fig.add_subplot(223)\n            ax.scatter(np.random.rand(50), np.random.rand(50),\n                       s=100 * np.random.rand(50), c=np.random.rand(50))\n\n            ax = fig.add_subplot(224)\n            ax.pcolor(10 * np.random.rand(50, 50))\n\n        fig.savefig(BytesIO(), dpi=75)\n        fig.canvas.flush_events()\n        plt.close(1)\n\n\nif __name__ == '__main__':\n    import argparse\n\n    parser = argparse.ArgumentParser('Run memory leak tests')\n    parser.add_argument('backend', type=str, nargs=1,\n                        help='backend to test')\n    parser.add_argument('iterations', type=int, nargs=1,\n                        help='number of iterations')\n    parser.add_argument('report', type=str, nargs=1,\n                        help='filename to save report')\n    parser.add_argument('--empty', action='store_true',\n                        help=\"Don't plot any content, just test creating \"\n    "}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "memleak.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "#!/usr/bin/env python\n\nimport gc\nfrom io import BytesIO\nimport tracemalloc\n\ntry:\n    import psutil\nexcept ImportError as err:\n    raise ImportError(\"This script requires psutil\") from err\n\nimport numpy as np\n\n\ndef run_memleak_test(bench, iterations, report):\n    tracemalloc.start()\n\n    starti = min(50, iterations // 2)\n    endi = iterations\n\n    malloc_arr = np.empty(endi, dtype=np.int64)\n    rss_arr = np.empty(endi, dtype=np.int64)\n    rss_peaks = np.empty(endi, dtype=np.int64)\n    nobjs_arr = np.empty(endi, dtype=np.int64)\n    garbage_arr = np.empty(endi, dtype=np.int64)\n    open_files_arr = np.empty(endi, dtype=np.int64)\n    rss_peak = 0\n\n    p = psutil.Process()\n\n    for i in range(endi):\n        bench()\n\n        gc.collect()\n\n        rss = p.memory_info().rss\n        malloc, peak = tracemalloc.get_traced_memory()\n        nobjs = len(gc.get_objects())\n        garbage = len(gc.garbage)\n        open_files = len(p.open_files())\n        print(f\"{i: 4d}: pymalloc {malloc: 10d}, rss {rss: 10d}, \"\n              f\"nobjs {nobjs: 10d}, garbage {garbage: 4d}, \"\n              f\"files: {open_files: 4d}\")\n        if i == starti:\n            print(f'{\" warmup done \":-^86s}')\n        malloc_arr[i] = malloc\n        rss_arr[i] = rss\n        if rss > rss_peak:\n            rss_peak = rss\n        rss_peaks[i] = rss_peak\n        nobjs_arr[i] = nobjs\n        garbage_arr[i] = garbage\n        open_files_arr[i] = open_files\n\n    print('Average memory consumed per loop: {:1.4f} bytes\\n'.format(\n        np.sum(rss_peaks[starti+1:] - rss_peaks[starti:-1]) / (endi - starti)))\n\n    from matplotlib import pyplot as plt\n    from matplotlib.ticker import EngFormatter\n    bytes_formatter = EngFormatter(unit='B')\n    fig, (ax1, ax2, ax3) = plt.subplots(3)\n    for ax in (ax1, ax2, ax3):\n        ax.axvline(starti, linestyle='--', color='k')\n    ax1b = ax1.twinx()\n    ax1b.yaxis.set_major_formatter(bytes_formatter)\n    ax1.plot(malloc_arr, 'C0')\n    ax1b.plot(rss_arr, 'C1', label='rss')\n    ax1b.plo"}, {"start_line": 3000, "end_line": 4521, "belongs_to": {"file_name": "memleak.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/tools", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2, 's')\n\n            ax = fig.add_subplot(222)\n            ax.imshow(X)\n\n            ax = fig.add_subplot(223)\n            ax.scatter(np.random.rand(50), np.random.rand(50),\n                       s=100 * np.random.rand(50), c=np.random.rand(50))\n\n            ax = fig.add_subplot(224)\n            ax.pcolor(10 * np.random.rand(50, 50))\n\n        fig.savefig(BytesIO(), dpi=75)\n        fig.canvas.flush_events()\n        plt.close(1)\n\n\nif __name__ == '__main__':\n    import argparse\n\n    parser = argparse.ArgumentParser('Run memory leak tests')\n    parser.add_argument('backend', type=str, nargs=1,\n                        help='backend to test')\n    parser.add_argument('iterations', type=int, nargs=1,\n                        help='number of iterations')\n    parser.add_argument('report', type=str, nargs=1,\n                        help='filename to save report')\n    parser.add_argument('--empty', action='store_true',\n                        help=\"Don't plot any content, just test creating \"\n                        \"and destroying figures\")\n    parser.add_argument('--interactive', action='store_true',\n                        help=\"Turn on interactive mode to actually open \"\n                        \"windows.  Only works with some GUI backends.\")\n\n    args = parser.parse_args()\n\n    import matplotlib\n    matplotlib.use(args.backend[0])\n\n    if args.interactive:\n        import matplotlib.pyplot as plt\n        plt.ion()\n\n    run_memleak_test(\n        MemleakTest(args.empty), args.iterations[0], args.report[0])\n"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "embedding_in_qt_sgskip.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/user_interfaces", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), \".\")\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        # Set up a Line2D.\n        self.xdata = np.linspace(0, 10, 101)\n        self._update_ydata()\n        self._line, = self._dynamic_ax.plot(self.xdata, self.ydata)\n        # The below two timers must be attributes of self, so that the garbage\n        # collector won't clean them after we finish with __init__...\n\n        # The data retrieval may be fast as possible (Using QRunnable could be\n        # even faster).\n        self.data_timer = dynamic_canvas.new_timer(1)\n        self.data_timer.add_callback(self._update_ydata)\n        self.data_timer.start()\n        # Drawing at 50Hz should be fast enough for the GUI to feel smooth, and\n        # not too fast for the GUI to be overloaded with events that need to be\n        # processed while the GUI element is changed.\n        self.drawing_timer = dynamic_canvas.new_timer(20)\n        self.drawing_timer.add_callback(self._update_canvas)\n        self.drawing_timer.start()\n\n    def _update_ydata(self):\n        # Shift the sinusoid as a function of time.\n        self.ydata = np.sin(self.xdata + time.time())\n\n    def _update_canvas(self):\n        self._line.set_data(self.xdata, self.ydata)\n        # It should be safe to use the synchronous draw() method for most drawing\n        # frequencies, but it is safer to use draw_idle().\n        self._line.figure.canvas.draw_idle()\n\n\nif __name__ == \"__main__\":\n    # Check whether there is already a running QApplication (e."}], "retrieved_count": 10, "cost_time": 4.214042663574219}
{"question": "How does the Legend class implement a multi-layered validation strategy to handle conflicting parameters like title_fontsize and title_fontproperties, and what design pattern could be applied to generalize this validation logic across similar parameter conflicts?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "validate_bool,\n    \"legend.loc\": _validate_legend_loc,\n\n    # the number of points in the legend line\n    \"legend.numpoints\":      validate_int,\n    # the number of points in the legend line for scatter\n    \"legend.scatterpoints\":  validate_int,\n    \"legend.fontsize\":       validate_fontsize,\n    \"legend.title_fontsize\": validate_fontsize_None,\n    # color of the legend\n    \"legend.labelcolor\":     _validate_color_or_linecolor,\n    # the relative size of legend markers vs. original\n    \"legend.markerscale\":    validate_float,\n    # using dict in rcParams not yet supported, so make sure it is bool\n    \"legend.shadow\":         validate_bool,\n    # whether or not to draw a frame around legend\n    \"legend.frameon\":        validate_bool,\n    # alpha value of the legend frame\n    \"legend.framealpha\":     validate_float_or_None,\n\n    ## the following dimensions are in fraction of the font size\n    \"legend.borderpad\":      validate_float,  # units are fontsize\n    # the vertical space between the legend entries\n    \"legend.labelspacing\":   validate_float,\n    # the length of the legend lines\n    \"legend.handlelength\":   validate_float,\n    # the length of the legend lines\n    \"legend.handleheight\":   validate_float,\n    # the space between the legend line and legend text\n    \"legend.handletextpad\":  validate_float,\n    # the border between the Axes and legend edge\n    \"legend.borderaxespad\":  validate_float,\n    # the border between the Axes and legend edge\n    \"legend.columnspacing\":  validate_float,\n    \"legend.facecolor\":      validate_color_or_inherit,\n    \"legend.edgecolor\":      validate_color_or_inherit,\n\n    # tick properties\n    \"xtick.top\":           validate_bool,      # draw ticks on top side\n    \"xtick.bottom\":        validate_bool,      # draw ticks on bottom side\n    \"xtick.labeltop\":      validate_bool,      # draw label on top\n    \"xtick.labelbottom\":   validate_bool,      # draw label on bottom\n    \"xtick.major.size\":    validate_float,     # major xtick s"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "the legend entries\n    \"legend.labelspacing\":   validate_float,\n    # the length of the legend lines\n    \"legend.handlelength\":   validate_float,\n    # the length of the legend lines\n    \"legend.handleheight\":   validate_float,\n    # the space between the legend line and legend text\n    \"legend.handletextpad\":  validate_float,\n    # the border between the Axes and legend edge\n    \"legend.borderaxespad\":  validate_float,\n    # the border between the Axes and legend edge\n    \"legend.columnspacing\":  validate_float,\n    \"legend.facecolor\":      validate_color_or_inherit,\n    \"legend.edgecolor\":      validate_color_or_inherit,\n\n    # tick properties\n    \"xtick.top\":           validate_bool,      # draw ticks on top side\n    \"xtick.bottom\":        validate_bool,      # draw ticks on bottom side\n    \"xtick.labeltop\":      validate_bool,      # draw label on top\n    \"xtick.labelbottom\":   validate_bool,      # draw label on bottom\n    \"xtick.major.size\":    validate_float,     # major xtick size in points\n    \"xtick.minor.size\":    validate_float,     # minor xtick size in points\n    \"xtick.major.width\":   validate_float,     # major xtick width in points\n    \"xtick.minor.width\":   validate_float,     # minor xtick width in points\n    \"xtick.major.pad\":     validate_float,     # distance to label in points\n    \"xtick.minor.pad\":     validate_float,     # distance to label in points\n    \"xtick.color\":         validate_color,     # color of xticks\n    \"xtick.labelcolor\":    validate_color_or_inherit,  # color of xtick labels\n    \"xtick.minor.visible\": validate_bool,      # visibility of minor xticks\n    \"xtick.minor.top\":     validate_bool,      # draw top minor xticks\n    \"xtick.minor.bottom\":  validate_bool,      # draw bottom minor xticks\n    \"xtick.major.top\":     validate_bool,      # draw top major xticks\n    \"xtick.major.bottom\":  validate_bool,      # draw bottom major xticks\n    # number of minor xticks\n    \"xtick.minor.ndivs\":   _validate_minor_tick_ndivs,\n    \"xti"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_rcparams.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e don't want these in the\n    # printed in the test suite.\n    with _api.suppress_matplotlib_deprecation_warning():\n        with mpl.rc_context():\n            _copy = mpl.rcParams.copy()\n            for key in _copy:\n                mpl.rcParams[key] = _copy[key]\n        with mpl.rc_context():\n            copy.deepcopy(mpl.rcParams)\n    with pytest.raises(ValueError):\n        validate_bool(None)\n    with pytest.raises(ValueError):\n        with mpl.rc_context():\n            mpl.rcParams['svg.fonttype'] = True\n\n\nlegend_color_tests = [\n    ('face', {'color': 'r'}, mcolors.to_rgba('r')),\n    ('face', {'color': 'inherit', 'axes.facecolor': 'r'},\n     mcolors.to_rgba('r')),\n    ('face', {'color': 'g', 'axes.facecolor': 'r'}, mcolors.to_rgba('g')),\n    ('edge', {'color': 'r'}, mcolors.to_rgba('r')),\n    ('edge', {'color': 'inherit', 'axes.edgecolor': 'r'},\n     mcolors.to_rgba('r')),\n    ('edge', {'color': 'g', 'axes.facecolor': 'r'}, mcolors.to_rgba('g'))\n]\nlegend_color_test_ids = [\n    'same facecolor',\n    'inherited facecolor',\n    'different facecolor',\n    'same edgecolor',\n    'inherited edgecolor',\n    'different facecolor',\n]\n\n\n@pytest.mark.parametrize('color_type, param_dict, target', legend_color_tests,\n                         ids=legend_color_test_ids)\ndef test_legend_colors(color_type, param_dict, target):\n    param_dict[f'legend.{color_type}color'] = param_dict.pop('color')\n    get_func = f'get_{color_type}color'\n\n    with mpl.rc_context(param_dict):\n        _, ax = plt.subplots()\n        ax.plot(range(3), label='test')\n        leg = ax.legend()\n        assert getattr(leg.legendPatch, get_func)() == target\n\n\ndef test_mfc_rcparams():\n    mpl.rcParams['lines.markerfacecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markerfacecolor() == 'r'\n\n\ndef test_mec_rcparams():\n    mpl.rcParams['lines.markeredgecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markeredgecolor() == 'r'\n\n\ndef test_axes_titlecolor_rcparams():"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2:\n        pairs = [(args[0], args[1])]\n    elif len(args) > 2:\n        raise _api.nargs_error('cycler', '0-2', len(args))\n    else:\n        pairs = kwargs.items()\n\n    validated = []\n    for prop, vals in pairs:\n        norm_prop = _prop_aliases.get(prop, prop)\n        validator = _prop_validators.get(norm_prop, None)\n        if validator is None:\n            raise TypeError(\"Unknown artist property: %s\" % prop)\n        vals = validator(vals)\n        # We will normalize the property names as well to reduce\n        # the amount of alias handling code elsewhere.\n        validated.append((norm_prop, vals))\n\n    return reduce(operator.add, (ccycler(k, v) for k, v in validated))\n\n\nclass _DunderChecker(ast.NodeVisitor):\n    def visit_Attribute(self, node):\n        if node.attr.startswith(\"__\") and node.attr.endswith(\"__\"):\n            raise ValueError(\"cycler strings with dunders are forbidden\")\n        self.generic_visit(node)\n\n\n# A validator dedicated to the named legend loc\n_validate_named_legend_loc = ValidateInStrings(\n    'legend.loc',\n    [\n        \"best\",\n        \"upper right\", \"upper left\", \"lower left\", \"lower right\", \"right\",\n        \"center left\", \"center right\", \"lower center\", \"upper center\",\n        \"center\"],\n    ignorecase=True)\n\n\ndef _validate_legend_loc(loc):\n    \"\"\"\n    Confirm that loc is a type which rc.Params[\"legend.loc\"] supports.\n\n    .. versionadded:: 3.8\n\n    Parameters\n    ----------\n    loc : str | int | (float, float) | str((float, float))\n        The location of the legend.\n\n    Returns\n    -------\n    loc : str | int | (float, float) or raise ValueError exception\n        The location of the legend.\n    \"\"\"\n    if isinstance(loc, str):\n        try:\n            return _validate_named_legend_loc(loc)\n        except ValueError:\n            pass\n        try:\n            loc = ast.literal_eval(loc)\n        except (SyntaxError, ValueError):\n            pass\n    if isinstance(loc, int):\n        if 0 <= loc <= 10:\n            return loc\n    if isi"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_rcparams.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e facecolor',\n    'inherited facecolor',\n    'different facecolor',\n    'same edgecolor',\n    'inherited edgecolor',\n    'different facecolor',\n]\n\n\n@pytest.mark.parametrize('color_type, param_dict, target', legend_color_tests,\n                         ids=legend_color_test_ids)\ndef test_legend_colors(color_type, param_dict, target):\n    param_dict[f'legend.{color_type}color'] = param_dict.pop('color')\n    get_func = f'get_{color_type}color'\n\n    with mpl.rc_context(param_dict):\n        _, ax = plt.subplots()\n        ax.plot(range(3), label='test')\n        leg = ax.legend()\n        assert getattr(leg.legendPatch, get_func)() == target\n\n\ndef test_mfc_rcparams():\n    mpl.rcParams['lines.markerfacecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markerfacecolor() == 'r'\n\n\ndef test_mec_rcparams():\n    mpl.rcParams['lines.markeredgecolor'] = 'r'\n    ln = mpl.lines.Line2D([1, 2], [1, 2])\n    assert ln.get_markeredgecolor() == 'r'\n\n\ndef test_axes_titlecolor_rcparams():\n    mpl.rcParams['axes.titlecolor'] = 'r'\n    _, ax = plt.subplots()\n    title = ax.set_title(\"Title\")\n    assert title.get_color() == 'r'\n\n\ndef test_Issue_1713(tmp_path):\n    rcpath = tmp_path / 'test_rcparams.rc'\n    rcpath.write_text('timezone: UTC', encoding='utf-8')\n    with mock.patch('locale.getpreferredencoding', return_value='UTF-32-BE'):\n        rc = mpl.rc_params_from_file(rcpath, True, False)\n    assert rc.get('timezone') == 'UTC'\n\n\ndef test_animation_frame_formats():\n    # Animation frame_format should allow any of the following\n    # if any of these are not allowed, an exception will be raised\n    # test for gh issue #17908\n    for fmt in ['png', 'jpeg', 'tiff', 'raw', 'rgba', 'ppm',\n                'sgi', 'bmp', 'pbm', 'svg']:\n        mpl.rcParams['animation.frame_format'] = fmt\n\n\ndef generate_validator_testcases(valid):\n    validation_tests = (\n        {'validator': validate_bool,\n         'success': (*((_, True) for _ in\n                       ('t', 'y', 'yes', 'on', "}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n    leg = plt.legend(title='Aardvark', title_fontproperties=FontProperties(\n                                       family='serif', size=22))\n    assert leg.get_title().get_size() == 22\n\n    fig, axes = plt.subplots(2, 3, figsize=(10, 6))\n    axes = axes.flat\n    axes[0].plot(range(10), label=\"mock data\")\n    leg0 = axes[0].legend(title='Aardvark', title_fontsize=22)\n    assert leg0.get_title().get_fontsize() == 22\n    axes[1].plot(range(10), label=\"mock data\")\n    leg1 = axes[1].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif', 'size': 22})\n    assert leg1.get_title().get_fontsize() == 22\n    axes[2].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = None\n    leg2 = axes[2].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg2.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[3].plot(range(10), label=\"mock data\")\n    leg3 = axes[3].legend(title='Aardvark')\n    assert leg3.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[4].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = 20\n    leg4 = axes[4].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg4.get_title().get_fontsize() == 20\n    axes[5].plot(range(10), label=\"mock data\")\n    leg5 = axes[5].legend(title='Aardvark')\n    assert leg5.get_title().get_fontsize() == 20\n\n\n@pytest.mark.parametrize('alignment', ('center', 'left', 'right'))\ndef test_legend_alignment(alignment):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = ax.legend(title=\"Aardvark\", alignment=alignment)\n    assert leg.get_children()[0].align == alignment\n    assert leg.get_alignment() == alignment\n\n\n@pytest.mark.parametrize('loc', ('center', 'best',))\ndef test_ax_legend_set_loc(loc):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = ax.legend()\n    leg.set_loc(loc"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n                title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n                title_prop_fp.set_size(title_fontsize)\n        elif title_fontsize is not None:\n            title_prop_fp.set_size(title_fontsize)\n        elif not isinstance(title_fontproperties, FontProperties):\n            title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n            title_prop_fp.set_size(title_fontsize)\n\n        self.set_title(title, prop=title_prop_fp)\n\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n        # set the text color\n\n        color_getters = {  # getter function depends on line or patch\n            'linecolor':       ['get_color',           'get_facecolor'],\n            'markerfacecolor': ['get_markerfacecolor', 'get_facecolor'],\n            'mfc':             ['get_markerfacecolor', 'get_facecolor'],\n            'markeredgecolor': ['get_markeredgecolor', 'get_edgecolor'],\n            'mec':             ['get_markeredgecolor', 'get_edgecolor'],\n        }\n        labelcolor = mpl._val_or_rc(mpl._val_or_rc(labelcolor, 'legend.labelcolor'),\n                                    'text.color')\n        if isinstance(labelcolor, str) and labelcolor in color_getters:\n            getter_names = color_getters[labelcolor]\n            for handle, text in zip(self.legend_handles, self.texts):\n                try:\n                    if handle.get_array() is not None:\n                        continue\n                except AttributeError:\n                    pass\n                for getter_name in getter_names:\n                    try:\n                        color = getattr(handle, getter_name)()\n                        if isinstance(color, np.ndarray):\n                            if (\n                                    color.shape[0] == 1\n                                    or np.isclose(color, color[0]).all()\n                            ):\n                                text.set_color(color[0])\n                            else:\n           "}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "rcsetup.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " scatter plots\n    \"axes3d.depthshade_minalpha\": validate_float,  # min alpha value for depth shading\n\n    \"axes3d.mouserotationstyle\": [\"azel\", \"trackball\", \"sphere\", \"arcball\"],\n    \"axes3d.trackballsize\": validate_float,\n    \"axes3d.trackballborder\": validate_float,\n\n    # scatter props\n    \"scatter.marker\":     _validate_marker,\n    \"scatter.edgecolors\": validate_string,\n\n    \"date.epoch\": _validate_date,\n    \"date.autoformatter.year\":        validate_string,\n    \"date.autoformatter.month\":       validate_string,\n    \"date.autoformatter.day\":         validate_string,\n    \"date.autoformatter.hour\":        validate_string,\n    \"date.autoformatter.minute\":      validate_string,\n    \"date.autoformatter.second\":      validate_string,\n    \"date.autoformatter.microsecond\": validate_string,\n\n    'date.converter':          ['auto', 'concise'],\n    # for auto date locator, choose interval_multiples\n    'date.interval_multiples': validate_bool,\n\n    # legend properties\n    \"legend.fancybox\": validate_bool,\n    \"legend.loc\": _validate_legend_loc,\n\n    # the number of points in the legend line\n    \"legend.numpoints\":      validate_int,\n    # the number of points in the legend line for scatter\n    \"legend.scatterpoints\":  validate_int,\n    \"legend.fontsize\":       validate_fontsize,\n    \"legend.title_fontsize\": validate_fontsize_None,\n    # color of the legend\n    \"legend.labelcolor\":     _validate_color_or_linecolor,\n    # the relative size of legend markers vs. original\n    \"legend.markerscale\":    validate_float,\n    # using dict in rcParams not yet supported, so make sure it is bool\n    \"legend.shadow\":         validate_bool,\n    # whether or not to draw a frame around legend\n    \"legend.frameon\":        validate_bool,\n    # alpha value of the legend frame\n    \"legend.framealpha\":     validate_float_or_None,\n\n    ## the following dimensions are in fraction of the font size\n    \"legend.borderpad\":      validate_float,  # units are fontsize\n    # the vertical space between "}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ardvark')\n    assert leg3.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[4].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = 20\n    leg4 = axes[4].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg4.get_title().get_fontsize() == 20\n    axes[5].plot(range(10), label=\"mock data\")\n    leg5 = axes[5].legend(title='Aardvark')\n    assert leg5.get_title().get_fontsize() == 20\n\n\n@pytest.mark.parametrize('alignment', ('center', 'left', 'right'))\ndef test_legend_alignment(alignment):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = ax.legend(title=\"Aardvark\", alignment=alignment)\n    assert leg.get_children()[0].align == alignment\n    assert leg.get_alignment() == alignment\n\n\n@pytest.mark.parametrize('loc', ('center', 'best',))\ndef test_ax_legend_set_loc(loc):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = ax.legend()\n    leg.set_loc(loc)\n    assert leg._get_loc() == mlegend.Legend.codes[loc]\n\n\n@pytest.mark.parametrize('loc', ('outside right', 'right',))\ndef test_fig_legend_set_loc(loc):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = fig.legend()\n    leg.set_loc(loc)\n\n    loc = loc.split()[1] if loc.startswith(\"outside\") else loc\n    assert leg._get_loc() == mlegend.Legend.codes[loc]\n\n\n@pytest.mark.parametrize('alignment', ('center', 'left', 'right'))\ndef test_legend_set_alignment(alignment):\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label='test')\n    leg = ax.legend()\n    leg.set_alignment(alignment)\n    assert leg.get_children()[0].align == alignment\n    assert leg.get_alignment() == alignment\n\n\n@pytest.mark.parametrize('color', ('red', 'none', (.5, .5, .5)))\ndef test_legend_labelcolor_single(color):\n    # test labelcolor for a single color\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(10), np.arange(10)*1, label='#1')\n    ax.plot(np.arange(10), np.arange(10)*2, label='#2'"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "test_rcparams.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                (([1, 2], 1), ValueError),  # inverted offset/onoff\n                  )\n         },\n    )\n\n    for validator_dict in validation_tests:\n        validator = validator_dict['validator']\n        if valid:\n            for arg, target in validator_dict['success']:\n                yield validator, arg, target\n        else:\n            for arg, error_type in validator_dict['fail']:\n                yield validator, arg, error_type\n\n\n@pytest.mark.parametrize('validator, arg, target',\n                         generate_validator_testcases(True))\ndef test_validator_valid(validator, arg, target):\n    res = validator(arg)\n    if isinstance(target, np.ndarray):\n        np.testing.assert_equal(res, target)\n    elif not isinstance(target, Cycler):\n        assert res == target\n    else:\n        # Cyclers can't simply be asserted equal. They don't implement __eq__\n        assert list(res) == list(target)\n\n\n@pytest.mark.parametrize('validator, arg, exception_type',\n                         generate_validator_testcases(False))\ndef test_validator_invalid(validator, arg, exception_type):\n    with pytest.raises(exception_type):\n        validator(arg)\n\n\ndef test_validate_cycler_bad_color_string():\n    msg = \"'foo' is neither a color sequence name nor can it be interpreted as a list\"\n    with pytest.raises(ValueError, match=msg):\n        validate_cycler(\"cycler('color', 'foo')\")\n\n\n@pytest.mark.parametrize('weight, parsed_weight', [\n    ('bold', 'bold'),\n    ('BOLD', ValueError),  # weight is case-sensitive\n    (100, 100),\n    ('100', 100),\n    (np.array(100), 100),\n    # fractional fontweights are not defined. This should actually raise a\n    # ValueError, but historically did not.\n    (20.6, 20),\n    ('20.6', ValueError),\n    ([100], ValueError),\n])\ndef test_validate_fontweight(weight, parsed_weight):\n    if parsed_weight is ValueError:\n        with pytest.raises(ValueError):\n            validate_fontweight(weight)\n    else:\n        assert validate_fontweight(weight) == parse"}], "retrieved_count": 10, "cost_time": 4.247727870941162}
{"question": "Why does the exception handling overhead in the get_alpha method's try-except block impact performance when called repeatedly in tight rendering loops, and what optimization strategy would minimize this overhead while preserving the fallback behavior?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "have individual alpha values (see `~._ImageBase._make_image` for\n        details). If the alpha value is a scalar, the method returns said value\n        to be applied to the artist as a whole because pixels do not have\n        individual alpha values.\n        \"\"\"\n        return 1.0 if self._alpha is None or np.ndim(self._alpha) > 0 \\\n            else self._alpha\n\n    def changed(self):\n        \"\"\"\n        Call this whenever the mappable is changed so observers can update.\n        \"\"\"\n        self._imcache = None\n        super().changed()\n\n    def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                    unsampled=False, round_to_pixel_border=True):\n        \"\"\"\n        Normalize, rescale, and colormap the image *A* from the given *in_bbox*\n        (in data space), to the given *out_bbox* (in pixel space) clipped to\n        the given *clip_bbox* (also in pixel space), and magnified by the\n        *magnification* factor.\n\n        Parameters\n        ----------\n        A : ndarray\n\n            - a (M, N) array interpreted as scalar (greyscale) image,\n              with one of the dtypes `~numpy.float32`, `~numpy.float64`,\n              `~numpy.float128`, `~numpy.uint16` or `~numpy.uint8`.\n            - (M, N, 4) RGBA image with a dtype of `~numpy.float32`,\n              `~numpy.float64`, `~numpy.float128`, or `~numpy.uint8`.\n\n        in_bbox : `~matplotlib.transforms.Bbox`\n\n        out_bbox : `~matplotlib.transforms.Bbox`\n\n        clip_bbox : `~matplotlib.transforms.Bbox`\n\n        magnification : float, default: 1\n\n        unsampled : bool, default: False\n            If True, the image will not be scaled, but an appropriate\n            affine transformation will be returned instead.\n\n        round_to_pixel_border : bool, default: True\n            If True, the output image size will be rounded to the nearest pixel\n            boundary.  This makes the images align correctly with the Axes.\n            It should not be used if exact scaling i"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " A = np.dstack([A, np.ones(A.shape[:2])])\n                elif np.ndim(alpha) > 0:  # Array alpha\n                    # user-specified array alpha overrides the existing alpha channel\n                    A = np.dstack([A[..., :3], alpha])\n                else:  # Scalar alpha\n                    if A.shape[2] == 3:  # broadcast scalar alpha\n                        A = np.dstack([A, np.full(A.shape[:2], alpha, np.float32)])\n                    else:  # or apply scalar alpha to existing alpha channel\n                        post_apply_alpha = True\n                # Resample in premultiplied alpha space.  (TODO: Consider\n                # implementing premultiplied-space resampling in\n                # span_image_resample_rgba_affine::generate?)\n                if float_rgba_in and np.ndim(alpha) == 0 and np.any(A[..., 3] < 1):\n                    # Do not modify original RGBA input\n                    A = A.copy()\n                A[..., :3] *= A[..., 3:]\n                res = _resample(self, A, out_shape, t)\n                np.divide(res[..., :3], res[..., 3:], out=res[..., :3],\n                            where=res[..., 3:] != 0)\n                if post_apply_alpha:\n                    res[..., 3] *= alpha\n\n            # res is now either a 2D array of normed (int or float) data\n            # or an RGBA array of re-sampled input\n            output = self.to_rgba(res, bytes=True, norm=False)\n            # output is now a correctly sized RGBA array of uint8\n\n            # Apply alpha *after* if the input was greyscale without a mask\n            if A.ndim == 2:\n                alpha = self._get_scalar_alpha()\n                alpha_channel = output[:, :, 3]\n                alpha_channel[:] = (  # Assignment will cast to uint8.\n                    alpha_channel.astype(np.float32) * out_alpha * alpha)\n\n        else:\n            if self._imcache is None:\n                self._imcache = self.to_rgba(A, bytes=True, norm=(A.ndim == 2))\n            output = self._imcache\n\n     "}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n\n        xa = np.array(X, copy=True)\n        if not xa.dtype.isnative:\n            # Native byteorder is faster.\n            xa = xa.byteswap().view(xa.dtype.newbyteorder())\n        if xa.dtype.kind == \"f\":\n            xa *= self.N\n            # xa == 1 (== N after multiplication) is not out of range.\n            xa[xa == self.N] = self.N - 1\n        # Pre-compute the masks before casting to int (which can truncate\n        # negative values to zero or wrap large floats to negative ints).\n        mask_under = xa < 0\n        mask_over = xa >= self.N\n        # If input was masked, get the bad mask from it; else mask out nans.\n        mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)\n        with np.errstate(invalid=\"ignore\"):\n            # We need this cast for unsigned ints as well as floats\n            xa = xa.astype(int)\n        xa[mask_under] = self._i_under\n        xa[mask_over] = self._i_over\n        xa[mask_bad] = self._i_bad\n\n        lut = self._lut\n        if bytes:\n            lut = (lut * 255).astype(np.uint8)\n\n        rgba = lut.take(xa, axis=0, mode='clip')\n\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha *= 255  # Will be cast to uint8 upon assignment.\n            if alpha.shape not in [(), xa.shape]:\n                raise ValueError(\n                    f\"alpha is array-like but its shape {alpha.shape} does \"\n                    f\"not match that of X {xa.shape}\")\n            rgba[..., -1] = alpha\n            # If the \"bad\" color is all zeros, then ignore alpha input.\n            if (lut[-1] == 0).all():\n                rgba[mask_bad] = (0, 0, 0, 0)\n\n        return rgba, mask_bad\n\n    def __copy__(self):\n        cls = self.__class__\n        cmapobject = cls.__new__(cls)\n        cmapobject.__dict__.update(self.__dict__)\n        if self._isinit:\n            cmapobject._lut = np.copy(self._lut)\n        return cmapobject\n\n    def __eq__(self, other):\n        if (not isinstance(other, "}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " image as tuple (numrows, numcols).\"\"\"\n        return self.get_shape()[:2]\n\n    def get_shape(self):\n        \"\"\"\n        Return the shape of the image as tuple (numrows, numcols, channels).\n        \"\"\"\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        return self._A.shape\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : float or 2D array-like or None\n        \"\"\"\n        martist.Artist._set_alpha_for_array(self, alpha)\n        if np.ndim(alpha) not in (0, 2):\n            raise TypeError('alpha must be a float, two-dimensional '\n                            'array, or None')\n        self._imcache = None\n\n    def _get_scalar_alpha(self):\n        \"\"\"\n        Get a scalar alpha value to be applied to the artist as a whole.\n\n        If the alpha value is a matrix, the method returns 1.0 because pixels\n        have individual alpha values (see `~._ImageBase._make_image` for\n        details). If the alpha value is a scalar, the method returns said value\n        to be applied to the artist as a whole because pixels do not have\n        individual alpha values.\n        \"\"\"\n        return 1.0 if self._alpha is None or np.ndim(self._alpha) > 0 \\\n            else self._alpha\n\n    def changed(self):\n        \"\"\"\n        Call this whenever the mappable is changed so observers can update.\n        \"\"\"\n        self._imcache = None\n        super().changed()\n\n    def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                    unsampled=False, round_to_pixel_border=True):\n        \"\"\"\n        Normalize, rescale, and colormap the image *A* from the given *in_bbox*\n        (in data space), to the given *out_bbox* (in pixel space) clipped to\n        the given *clip_bbox* (also in pixel space), and magnified by the\n        *magnification* factor.\n\n        Parameters\n        --------"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " and a dpi value, and returns a (m, n, 3) array and two offsets\n                from the bottom left corner of the image\n        \"\"\"\n        self._agg_filter = filter_func\n        self.stale = True\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `~matplotlib.backend_bases.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : float or None\n            *alpha* must be within the 0-1 range, inclusive.\n        \"\"\"\n        if alpha is not None and not isinstance(alpha, Real):\n            raise TypeError(\n                f'alpha must be numeric or None, not {type(alpha)}')\n        if alpha is not None and not (0 <= alpha <= 1):\n            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n        if alpha != self._alpha:\n            self._alpha = alpha\n            self.pchanged()\n            self.stale = True\n\n    def _set_alpha_for_array(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : array-like or float or None\n            All values must be within the 0-1 range, inclusive.\n            Masked values and nans are not supported.\n        \"\"\"\n        if isinstance(alpha, str):\n            raise TypeError(\"alpha must be numeric or None, not a string\")\n        if not np.iterable(alpha):\n            Artist.set_alpha(self, alpha)\n            return\n        alpha = np.asarray(alpha)\n        if not (0 <= alpha.min()"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                if isinstance(self.norm, mcolors.NoNorm):\n                    A_resampled = A_resampled.astype(A.dtype)\n\n                # Compute out_mask (what screen pixels include \"bad\" data\n                # pixels) and out_alpha (to what extent screen pixels are\n                # covered by data pixels: 0 outside the data extent, 1 inside\n                # (even for bad data), and intermediate values at the edges).\n                mask = (np.where(A.mask, np.float32(np.nan), np.float32(1))\n                        if A.mask.shape == A.shape  # nontrivial mask\n                        else np.ones_like(A, np.float32))\n                # we always have to interpolate the mask to account for\n                # non-affine transformations\n                out_alpha = _resample(self, mask, out_shape, t, resample=True)\n                del mask  # Make sure we don't use mask anymore!\n                out_mask = np.isnan(out_alpha)\n                out_alpha[out_mask] = 1\n                # Apply the pixel-by-pixel alpha values if present\n                alpha = self.get_alpha()\n                if alpha is not None and np.ndim(alpha) > 0:\n                    out_alpha *= _resample(self, alpha, out_shape, t, resample=True)\n                # mask and run through the norm\n                resampled_masked = np.ma.masked_array(A_resampled, out_mask)\n                res = self.norm(resampled_masked)\n            else:\n                if A.ndim == 2:  # interpolation_stage = 'rgba'\n                    self.norm.autoscale_None(A)\n                    A = self.to_rgba(A)\n                if A.dtype == np.uint8:\n                    # uint8 is too imprecise for premultiplied alpha roundtrips.\n                    A = np.divide(A, 0xff, dtype=np.float32)\n                alpha = self.get_alpha()\n                post_apply_alpha = False\n                if alpha is None:  # alpha parameter not specified\n                    if A.shape[2] == 3:  # image has no alpha channel\n                       "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "image.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " the pixel-by-pixel alpha values if present\n                alpha = self.get_alpha()\n                if alpha is not None and np.ndim(alpha) > 0:\n                    out_alpha *= _resample(self, alpha, out_shape, t, resample=True)\n                # mask and run through the norm\n                resampled_masked = np.ma.masked_array(A_resampled, out_mask)\n                res = self.norm(resampled_masked)\n            else:\n                if A.ndim == 2:  # interpolation_stage = 'rgba'\n                    self.norm.autoscale_None(A)\n                    A = self.to_rgba(A)\n                if A.dtype == np.uint8:\n                    # uint8 is too imprecise for premultiplied alpha roundtrips.\n                    A = np.divide(A, 0xff, dtype=np.float32)\n                alpha = self.get_alpha()\n                post_apply_alpha = False\n                if alpha is None:  # alpha parameter not specified\n                    if A.shape[2] == 3:  # image has no alpha channel\n                        A = np.dstack([A, np.ones(A.shape[:2])])\n                elif np.ndim(alpha) > 0:  # Array alpha\n                    # user-specified array alpha overrides the existing alpha channel\n                    A = np.dstack([A[..., :3], alpha])\n                else:  # Scalar alpha\n                    if A.shape[2] == 3:  # broadcast scalar alpha\n                        A = np.dstack([A, np.full(A.shape[:2], alpha, np.float32)])\n                    else:  # or apply scalar alpha to existing alpha channel\n                        post_apply_alpha = True\n                # Resample in premultiplied alpha space.  (TODO: Consider\n                # implementing premultiplied-space resampling in\n                # span_image_resample_rgba_affine::generate?)\n                if float_rgba_in and np.ndim(alpha) == 0 and np.any(A[..., 3] < 1):\n                    # Do not modify original RGBA input\n                    A = A.copy()\n                A[..., :3] *= A[..., 3:]\n                res = _resample(s"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        lut = (lut * 255).astype(np.uint8)\n\n        rgba = lut.take(xa, axis=0, mode='clip')\n\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha *= 255  # Will be cast to uint8 upon assignment.\n            if alpha.shape not in [(), xa.shape]:\n                raise ValueError(\n                    f\"alpha is array-like but its shape {alpha.shape} does \"\n                    f\"not match that of X {xa.shape}\")\n            rgba[..., -1] = alpha\n            # If the \"bad\" color is all zeros, then ignore alpha input.\n            if (lut[-1] == 0).all():\n                rgba[mask_bad] = (0, 0, 0, 0)\n\n        return rgba, mask_bad\n\n    def __copy__(self):\n        cls = self.__class__\n        cmapobject = cls.__new__(cls)\n        cmapobject.__dict__.update(self.__dict__)\n        if self._isinit:\n            cmapobject._lut = np.copy(self._lut)\n        return cmapobject\n\n    def __eq__(self, other):\n        if (not isinstance(other, Colormap) or\n                self.colorbar_extend != other.colorbar_extend):\n            return False\n        # To compare lookup tables the Colormaps have to be initialized\n        if not self._isinit:\n            self._init()\n        if not other._isinit:\n            other._init()\n        return np.array_equal(self._lut, other._lut)\n\n    def get_bad(self):\n        \"\"\"Get the color for masked values.\"\"\"\n        if not self._isinit:\n            self._init()\n        return np.array(self._lut[self._i_bad])\n\n    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set the color for masked values.\"\"\"\n        self._rgba_bad = to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def get_under(self):\n        \"\"\"Get the color for low out-of-range values.\"\"\"\n        if not self._isinit:\n            self._init()\n        return np.array(self._lut[self._i_under])\n\n    def set_under(self, color='k', alpha=None):\n        \"\"\"Set the color for low out-of-range values.\"\""}, {"start_line": 64000, "end_line": 66000, "belongs_to": {"file_name": "colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " X0.mask if np.ma.is_masked(X0) else np.isnan(X0)\n        mask_bad_1 = X1.mask if np.ma.is_masked(X1) else np.isnan(X1)\n        mask_bad = mask_bad_0 | mask_bad_1\n\n        with np.errstate(invalid=\"ignore\"):\n            # We need this cast for unsigned ints as well as floats\n            X0 = X0.astype(int)\n            X1 = X1.astype(int)\n\n        # Set masked values to zero\n        # The corresponding rgb values will be replaced later\n        for X_part in [X0, X1]:\n            X_part[mask_outside] = 0\n            X_part[mask_bad] = 0\n\n        rgba = self._lut[X0, X1]\n        if np.isscalar(X[0]):\n            rgba = np.copy(rgba)\n        rgba[mask_outside] = self._rgba_outside\n        rgba[mask_bad] = self._rgba_bad\n        if bytes:\n            rgba = (rgba * 255).astype(np.uint8)\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha *= 255  # Will be cast to uint8 upon assignment.\n            if np.shape(alpha) not in [(), np.shape(X0)]:\n                raise ValueError(\n                    f\"alpha is array-like but its shape {np.shape(alpha)} does \"\n                    f\"not match that of X[0] {np.shape(X0)}\")\n            rgba[..., -1] = alpha\n            # If the \"bad\" color is all zeros, then ignore alpha input.\n            if (np.array(self._rgba_bad) == 0).all():\n                rgba[mask_bad] = (0, 0, 0, 0)\n\n        if not np.iterable(X[0]):\n            rgba = tuple(rgba)\n        return rgba\n\n    @property\n    def lut(self):\n        \"\"\"\n        For external access to the lut, i.e. for displaying the cmap.\n        For circular colormaps this returns a lut with a circular mask.\n\n        Internal functions (such as to_rgb()) should use _lut\n        which stores the lut without a circular mask\n        A lut without the circular mask is needed in to_rgb() because the\n        conversion from floats to ints results in some some pixel-requests\n        just outside of the circular mask\n\n        \"\"\"\n        "}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "= None\n                success = True\n            elif isinstance(path, Patch):\n                self._clippath = TransformedPatchPath(path)\n                success = True\n            elif isinstance(path, tuple):\n                path, transform = path\n\n        if path is None:\n            self._clippath = None\n            success = True\n        elif isinstance(path, Path):\n            self._clippath = TransformedPath(path, transform)\n            success = True\n        elif isinstance(path, TransformedPatchPath):\n            self._clippath = path\n            success = True\n        elif isinstance(path, TransformedPath):\n            self._clippath = path\n            success = True\n\n        if not success:\n            raise TypeError(\n                \"Invalid arguments to set_clip_path, of type \"\n                f\"{type(path).__name__} and {type(transform).__name__}\")\n        # This may result in the callbacks being hit twice, but guarantees they\n        # will be hit at least once.\n        self.pchanged()\n        self.stale = True\n\n    def get_alpha(self):\n        \"\"\"\n        Return the alpha value used for blending - not supported on all\n        backends.\n        \"\"\"\n        return self._alpha\n\n    def get_visible(self):\n        \"\"\"Return the visibility.\"\"\"\n        return self._visible\n\n    def get_animated(self):\n        \"\"\"Return whether the artist is animated.\"\"\"\n        return self._animated\n\n    def get_in_layout(self):\n        \"\"\"\n        Return boolean flag, ``True`` if artist is included in layout\n        calculations.\n\n        E.g. :ref:`constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n        \"\"\"\n        return self._in_layout\n\n    def _fully_clipped_to_axes(self):\n        \"\"\"\n        Return a boolean flag, ``True`` if the artist is clipped to the Axes\n        and can thus be skipped in layout calculations. Requires `get_clip_on`\n        is True, one of `clip_box` or `clip_path` is set, ``c"}], "retrieved_count": 10, "cost_time": 4.255286931991577}
{"question": "Why does the _update_glyph_map_defs method scale glyph vertices by 64 before path conversion and then apply a 1/64 scale transform in the SVG output?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')\n\n    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                # x64 to go back to FreeType's internal (integral) units.\n                path_data = self._convert_path(\n                    Path(vertices * 64, codes), simplify=False)\n                writer.element(\n                    'path', id=char_id, d=path_data,\n                    transform=_generate_transform([('scale', (1 / 64,))]))\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        # docstring inherited\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n        font_scale = fo"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')\n\n    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                # x64 to go back to FreeType's internal (integral) units.\n                path_dat"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "textpath.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        # Make sure an empty string or one with nothing to print\n        # (e.g. only spaces & newlines) will be valid/empty path\n        if not verts:\n            verts = np.empty((0, 2))\n\n        return verts, codes\n\n    def get_glyphs_with_font(self, font, s, glyph_map=None,\n                             return_new_glyphs_only=False):\n        \"\"\"\n        Convert string *s* to vertices and codes using the provided ttf font.\n        \"\"\"\n\n        if glyph_map is None:\n            glyph_map = OrderedDict()\n\n        if return_new_glyphs_only:\n            glyph_map_new = OrderedDict()\n        else:\n            glyph_map_new = glyph_map\n\n        xpositions = []\n        glyph_ids = []\n        for item in _text_helpers.layout(s, font):\n            char_id = self._get_char_id(item.ft_object, ord(item.char))\n            glyph_ids.append(char_id)\n            xpositions.append(item.x)\n            if char_id not in glyph_map:\n                glyph_map_new[char_id] = item.ft_object.get_path()\n\n        ypositions = [0] * len(xpositions)\n        sizes = [1.] * len(xpositions)\n\n        rects = []\n\n        return (list(zip(glyph_ids, xpositions, ypositions, sizes)),\n                glyph_map_new, rects)\n\n    def get_glyphs_mathtext(self, prop, s, glyph_map=None,\n                            return_new_glyphs_only=False):\n        \"\"\"\n        Parse mathtext string *s* and convert it to a (vertices, codes) pair.\n        \"\"\"\n\n        prop = prop.copy()\n        prop.set_size(self.FONT_SCALE)\n\n        width, height, descent, glyphs, rects = self.mathtext_parser.parse(\n            s, self.DPI, prop)\n\n        if not glyph_map:\n            glyph_map = OrderedDict()\n\n        if return_new_glyphs_only:\n            glyph_map_new = OrderedDict()\n        else:\n            glyph_map_new = glyph_map\n\n        xpositions = []\n        ypositions = []\n        glyph_ids = []\n        sizes = []\n\n        for font, fontsize, ccode, ox, oy in glyphs:\n            char_id = self._get_char_id(font, ccode)\n     "}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "a = self._convert_path(\n                    Path(vertices * 64, codes), simplify=False)\n                writer.element(\n                    'path', id=char_id, d=path_data,\n                    transform=_generate_transform([('scale', (1 / 64,))]))\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        # docstring inherited\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': _generate_css(style),\n            'transform': _generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{glyph"}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ntsize / text2path.FONT_SCALE\n        attrib = {\n            'style': _generate_css(style),\n            'transform': _generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{glyph_id}'})\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{char_id}'})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._conv"}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_id}'})\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{char_id}'})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')\n\n    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        # NOTE: If you change the font styling CSS, then be sure the check for\n        # svg.fonttype = none in `lib/matplotlib/testing/compare.py::convert` remains in\n        # sync. Also be sure to re-generate any SVG using this mode, or else such tests\n        # will fail to use the right converter for the expected images, and they will\n        # fail strangely.\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        font_style = {}\n        color_style = {}\n        if color != '#000000':\n            color_style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            color_style['opacity'] = _short_float_fmt(alpha)\n\n        if not ismath:\n            attrib = {}\n\n            # Separate font style in their s"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "dviread.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".texname)\n            return [0, 0]\n        hd = [\n            _mul1220(metrics.tex_height, self._scale),\n            _mul1220(metrics.tex_depth, self._scale),\n        ]\n        # cmsyXX (symbols font) glyph 0 (\"minus\") has a nonzero descent\n        # so that TeX aligns equations properly\n        # (https://tex.stackexchange.com/q/526103/)\n        # but we actually care about the rasterization depth to align\n        # the dvipng-generated images.\n        if re.match(br'^cmsy\\d+$', self.texname) and char == 0:\n            hd[-1] = 0\n        return hd\n\n    def _index_dvi_to_freetype(self, idx):\n        \"\"\"Convert dvi glyph indices to FreeType ones.\"\"\"\n        # Glyphs indices stored in the dvi file map to FreeType glyph indices\n        # (i.e., which can be passed to FT_Load_Glyph) in various ways:\n        # - if pdftex.map specifies an \".enc\" file for the font, that file maps\n        #   dvi indices to Adobe glyph names, which can then be converted to\n        #   FreeType glyph indices with FT_Get_Name_Index.\n        # - if no \".enc\" file is specified, then the font must be a Type 1\n        #   font, and dvi indices directly index into the font's CharStrings\n        #   vector.\n        # - (xetex & luatex, currently unsupported, can also declare \"native\n        #   fonts\", for which dvi indices are equal to FreeType indices.)\n        if self._encoding is None:\n            psfont = PsfontsMap(find_tex_file(\"pdftex.map\"))[self.texname]\n            if psfont.filename is None:\n                raise ValueError(\"No usable font file found for {} ({}); \"\n                                 \"the font may lack a Type-1 version\"\n                                 .format(psfont.psname.decode(\"ascii\"),\n                                         psfont.texname.decode(\"ascii\")))\n            face = font_manager.get_font(psfont.filename)\n            if psfont.encoding:\n                self._encoding = [face.get_name_index(name)\n                                  for name in _parse_enc(psfon"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        ('translate', (x, y)),\n                             ('rotate', (-angle,))]),\n                         )\n\n            writer.start('text')\n\n            # Sort the characters by font, and output one tspan for each.\n            spans = {}\n            for font, fontsize, thetext, new_x, new_y in glyphs:\n                entry = fm.ttfFontProperty(font)\n                font_style = {}\n                # Separate font style in its separate attributes\n                if entry.style != 'normal':\n                    font_style['font-style'] = entry.style\n                if entry.variant != 'normal':\n                    font_style['font-variant'] = entry.variant\n                if entry.weight != 400:\n                    font_style['font-weight'] = f'{entry.weight}'\n                font_style['font-size'] = f'{_short_float_fmt(fontsize)}px'\n                font_style['font-family'] = f'{entry.name!r}'  # ensure quoting\n                if entry.stretch != 'normal':\n                    font_style['font-stretch'] = entry.stretch\n                style = _generate_css({**font_style, **color_style})\n                if thetext == 32:\n                    thetext = 0xa0  # non-breaking space\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            for style, chars in spans.items():\n                chars.sort()  # Sort by increasing x position\n                for x, y, t in chars:  # Output one tspan for each character\n                    writer.element(\n                        'tspan',\n                        chr(t),\n                        x=_short_float_fmt(x),\n                        y=_short_float_fmt(y),\n                        style=style)\n\n            writer.end('text')\n\n            for x, y, width, height in rects:\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(-y-1),\n                    width=_short_float_fmt(width),\n                    height="}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "textpath.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    ypositions = [0] * len(xpositions)\n        sizes = [1.] * len(xpositions)\n\n        rects = []\n\n        return (list(zip(glyph_ids, xpositions, ypositions, sizes)),\n                glyph_map_new, rects)\n\n    def get_glyphs_mathtext(self, prop, s, glyph_map=None,\n                            return_new_glyphs_only=False):\n        \"\"\"\n        Parse mathtext string *s* and convert it to a (vertices, codes) pair.\n        \"\"\"\n\n        prop = prop.copy()\n        prop.set_size(self.FONT_SCALE)\n\n        width, height, descent, glyphs, rects = self.mathtext_parser.parse(\n            s, self.DPI, prop)\n\n        if not glyph_map:\n            glyph_map = OrderedDict()\n\n        if return_new_glyphs_only:\n            glyph_map_new = OrderedDict()\n        else:\n            glyph_map_new = glyph_map\n\n        xpositions = []\n        ypositions = []\n        glyph_ids = []\n        sizes = []\n\n        for font, fontsize, ccode, ox, oy in glyphs:\n            char_id = self._get_char_id(font, ccode)\n            if char_id not in glyph_map:\n                font.clear()\n                font.set_size(self.FONT_SCALE, self.DPI)\n                font.load_char(ccode, flags=LoadFlags.NO_HINTING)\n                glyph_map_new[char_id] = font.get_path()\n\n            xpositions.append(ox)\n            ypositions.append(oy)\n            glyph_ids.append(char_id)\n            size = fontsize / self.FONT_SCALE\n            sizes.append(size)\n\n        myrects = []\n        for ox, oy, w, h in rects:\n            vert1 = [(ox, oy), (ox, oy + h), (ox + w, oy + h),\n                     (ox + w, oy), (ox, oy), (0, 0)]\n            code1 = [Path.MOVETO,\n                     Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                     Path.CLOSEPOLY]\n            myrects.append((vert1, code1))\n\n        return (list(zip(glyph_ids, xpositions, ypositions, sizes)),\n                glyph_map_new, myrects)\n\n    def get_glyphs_tex(self, prop, s, glyph_map=None,\n                       return_new_glyphs_only="}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "dviread.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ve charmap glyph index.\n\n        If :file:`pdftex.map` specifies an encoding for this glyph's font, that\n        is a mapping of glyph indices to Adobe glyph names; use it to convert\n        dvi indices to glyph names.  Callers can then convert glyph names to\n        glyph indices (with FT_Get_Name_Index/get_name_index), and load the\n        glyph using FT_Load_Glyph/load_glyph.\n\n        If :file:`pdftex.map` specifies no encoding, the indices directly map\n        to the font's \"native\" charmap; glyphs should directly load using\n        FT_Load_Char/load_char after selecting the native charmap.\n        \"\"\"\n        entry = self._get_pdftexmap_entry()\n        return (_parse_enc(entry.encoding)[self.glyph]\n                if entry.encoding is not None else self.glyph)\n\n\n# Opcode argument parsing\n#\n# Each of the following functions takes a Dvi object and delta, which is the\n# difference between the opcode and the minimum opcode with the same meaning.\n# Dvi opcodes often encode the number of argument bytes in this delta.\n_arg_mapping = dict(\n    # raw: Return delta as is.\n    raw=lambda dvi, delta: delta,\n    # u1: Read 1 byte as an unsigned number.\n    u1=lambda dvi, delta: dvi._read_arg(1, signed=False),\n    # u4: Read 4 bytes as an unsigned number.\n    u4=lambda dvi, delta: dvi._read_arg(4, signed=False),\n    # s4: Read 4 bytes as a signed number.\n    s4=lambda dvi, delta: dvi._read_arg(4, signed=True),\n    # slen: Read delta bytes as a signed number, or None if delta is None.\n    slen=lambda dvi, delta: dvi._read_arg(delta, signed=True) if delta else None,\n    # slen1: Read (delta + 1) bytes as a signed number.\n    slen1=lambda dvi, delta: dvi._read_arg(delta + 1, signed=True),\n    # ulen1: Read (delta + 1) bytes as an unsigned number.\n    ulen1=lambda dvi, delta: dvi._read_arg(delta + 1, signed=False),\n    # olen1: Read (delta + 1) bytes as an unsigned number if less than 4 bytes,\n    # as a signed number if 4 bytes.\n    olen1=lambda dvi, delta: dvi._read_arg(delta "}], "retrieved_count": 10, "cost_time": 4.272866249084473}
{"question": "How does the draw method orchestrate the sequence of bbox computation, frame updates, offset calculation, and child rendering to maintain consistency between the patch frame and the positioned child element?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ld offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n\n    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n        bbox = self.get_bbox(renderer)\n        try:  # Some subclasses redefine get_offset to take no args.\n            px, py = self.get_offset(bbox, renderer)\n        except TypeError:\n            px, py = self.get_offset()\n        return bbox.translated(px, py)\n\n    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass PackerBase(OffsetBox):\n    def __init__(self, pad=0., sep=0., width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\", children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, default: 0.0\n            The boundary padding in points.\n\n        sep : float, default: 0.0\n            The spacing between items in points.\n\n        width, height : float, optional\n            Width and height of the container box in pixels, calculated if\n    "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "-------\n    pad : float\n        The padding in points.\n    patch : `.FancyBboxPatch`\n        When *draw_frame* is True, this `.FancyBboxPatch` is made visible and\n        creates a border around the box.\n    \"\"\"\n\n    def __init__(self, child, pad=0., *, draw_frame=False, patch_attrs=None):\n        \"\"\"\n        Parameters\n        ----------\n        child : `~matplotlib.artist.Artist`\n            The contained `.Artist`.\n        pad : float, default: 0.0\n            The padding in points. This will be scaled with the renderer dpi.\n            In contrast, *width* and *height* are in *pixels* and thus not\n            scaled.\n        draw_frame : bool\n            Whether to draw the contained `.FancyBboxPatch`.\n        patch_attrs : dict or None\n            Additional parameters passed to the contained `.FancyBboxPatch`.\n        \"\"\"\n        super().__init__()\n        self.pad = pad\n        self._children = [child]\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=1,  # self.prop.get_size_in_points(),\n            snap=True,\n            visible=draw_frame,\n            boxstyle=\"square,pad=0\",\n        )\n        if patch_attrs is not None:\n            self.patch.update(patch_attrs)\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited.\n        pad = self.pad * renderer.points_to_pixels(1.)\n        return (self._children[0].get_bbox(renderer).padded(pad), [(0, 0)])\n\n    def draw(self, renderer):\n        # docstring inherited\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n\n        self.draw_frame(renderer)\n\n        for c in self.get_visible_children():\n            c.draw(renderer)\n\n        self.stale = False\n\n    def update_frame(self, bbox, fontsize=None):\n       "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "axes3d.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ransforms.Bbox.unit().transformed(trans)\n        # this is the physical aspect of the panel (or figure):\n        fig_aspect = bb.height / bb.width\n\n        box_aspect = 1\n        pb = position.frozen()\n        pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n        self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        # draw the background patch\n        self.patch.draw(renderer)\n        self._frameon = False\n\n        # first, set the aspect\n        # this is duplicated from `axes._base._AxesBase.draw`\n        # but must be called before any of the artist are drawn as\n        # it adjusts the view limits and the size of the bounding box\n        # of the Axes\n        locator = self.get_axes_locator()\n        self.apply_aspect(locator(self, renderer) if locator else None)\n\n        # add the projection matrix to the renderer\n        self.M = self.get_proj()\n        self.invM = np.linalg.inv(self.M)\n\n        collections_and_patches = (\n            artist for artist in self._children\n            if isinstance(artist, (mcoll.Collection, mpatches.Patch))\n            and artist.get_visible())\n        if self.computed_zorder:\n            # Calculate projection of collections and patches and zorder\n            # them. Make sure they are drawn above the grids.\n            zorder_offset = max(axis.get_zorder()\n                                for axis in self._axis_map.values()) + 1\n            collection_zorder = patch_zorder = zorder_offset\n\n            for artist in sorted(collections_and_patches,\n                                 key=lambda artist: artist.do_3d_projection(),\n                                 reverse=True):\n                if isinstance(artist, mcoll.Collection):\n                    artist.zorder = collection_zorder\n                    collection_zorder += 1\n                elif isinstanc"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n        _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False\n\n\nclass PackerBase(OffsetBox):\n    def __init__(self, pad=0., sep=0., width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\", children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, default: 0.0\n            The boundary padding in points.\n\n        sep : float, default: 0.0\n            The spacing between items in points.\n\n        width, height : float, optional\n            Width and height of the container box in pixels, calculated if\n            *None*.\n\n        align : {'top', 'bottom', 'left', 'right', 'center', 'baseline'}, \\\ndefault: 'baseline'\n            Alignment of boxes.\n\n        mode : {'fixed', 'expand', 'equal'}, default: 'fixed'\n            The packing mode.\n\n            - 'fixed' packs the given `.Artist`\\\\s tight with *sep* spacing.\n            - 'expand' uses the maximal available space to distribute the\n              artists with equal spacing in between.\n            - 'equal': Each artist an equal fraction of the available space\n              and is left-aligned (or top-aligned) therein.\n\n        children : list of `.Artist`\n            The artists to pack.\n\n        Notes\n        -----\n        *pad* and *sep* are in points and will be scaled with the renderer\n        dpi, while *width* and *height* are in pixels.\n        \"\"\"\n        super().__init__()\n        self.height = height\n        self.width = width\n        self.sep = sep\n        self.pad = pad\n        self.mode = mode\n        self.align = alig"}, {"start_line": 47000, "end_line": 49000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "renderer)\n        return Bbox.union([child.get_tightbbox(renderer)\n                           for child in self.get_children()])\n\n    def update_positions(self, renderer):\n        \"\"\"Update pixel positions for the annotated point, the text, and the arrow.\"\"\"\n\n        ox0, oy0 = self._get_xy(renderer, self.xybox, self.boxcoords)\n        bbox = self.offsetbox.get_bbox(renderer)\n        fw, fh = self._box_alignment\n        self.offsetbox.set_offset(\n            (ox0 - fw*bbox.width - bbox.x0, oy0 - fh*bbox.height - bbox.y0))\n\n        bbox = self.offsetbox.get_window_extent(renderer)\n        self.patch.set_bounds(bbox.bounds)\n\n        mutation_scale = renderer.points_to_pixels(self.get_fontsize())\n        self.patch.set_mutation_scale(mutation_scale)\n\n        if self.arrowprops:\n            # Use FancyArrowPatch if self.arrowprops has \"arrowstyle\" key.\n\n            # Adjust the starting point of the arrow relative to the textbox.\n            # TODO: Rotation needs to be accounted.\n            arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos\n            arrow_end = self._get_position_xy(renderer)\n            # The arrow (from arrow_begin to arrow_end) will be first clipped\n            # by patchA and patchB, then shrunk by shrinkA and shrinkB (in\n            # points).  If patch A is not set, self.bbox_patch is used.\n            self.arrow_patch.set_positions(arrow_begin, arrow_end)\n\n            if \"mutation_scale\" in self.arrowprops:\n                mutation_scale = renderer.points_to_pixels(\n                    self.arrowprops[\"mutation_scale\"])\n                # Else, use fontsize-based mutation_scale defined above.\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n            patchA = self.arrowprops.get(\"patchA\", self.patch)\n            self.arrow_patch.set_patchA(patchA)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        renderer.open_group(s"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ght=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=1,  # self.prop.get_size_in_points(),\n            snap=True,\n            visible=draw_frame,\n            boxstyle=\"square,pad=0\",\n        )\n        if patch_attrs is not None:\n            self.patch.update(patch_attrs)\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        # docstring inherited.\n        pad = self.pad * renderer.points_to_pixels(1.)\n        return (self._children[0].get_bbox(renderer).padded(pad), [(0, 0)])\n\n    def draw(self, renderer):\n        # docstring inherited\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        px, py = self.get_offset(bbox, renderer)\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n\n        self.draw_frame(renderer)\n\n        for c in self.get_visible_children():\n            c.draw(renderer)\n\n        self.stale = False\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n        self.stale = True\n\n    def draw_frame(self, renderer):\n        # update the location and size of the legend\n        self.update_frame(self.get_window_extent(renderer))\n        self.patch.draw(renderer)\n\n\nclass DrawingArea(OffsetBox):\n    \"\"\"\n    The DrawingArea can contain any Artist as a child. The DrawingArea\n    has a fixed width and height. The position of children relative to\n    the parent is fixed. The children can be clipped at the\n    boundaries of the parent.\n    \"\"\"\n\n    def __init__(self, width, height, xdescent=0., ydescent=0., clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        width, height : float\n            Width and height of the container box.\n        xdescent, ydescent : float\n            Descent of the box in x- and y-direction.\n        clip : bool\n            Whether to clip the children to the box.\n        \"\"\"\n        super().__"}, {"start_line": 126000, "end_line": 128000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the Axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison:\n            for _axis in self._axis_map.values():\n                artists.remove(_axis)\n\n        if not self.get_figure(root=True).canvas.is_saving():\n            artists = [\n                a for a in artists\n                if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            split_index = np.searchsorted(\n                [art.zorder for art in artists],\n                rasterization_zorder, side='right'\n            )\n            artists_rasterized = artists[:split_index]\n            artists = artists[split_index:]\n        else:\n            artists_rasterized = []\n\n        if self.axison and self._frameon:\n            if artists_rasterized:\n                artists_rasterized = [self.patch] + artists_rasterized\n            else:\n                artists = [self.patch] + artists\n\n        if artists_rasterized:\n            _draw_rasterized(self.get_figure(root=True), artists_rasterized, renderer)\n\n        mimage._draw_list_compositing_images(\n            renderer, self, artists, self.get_figure(root=True).suppressComposite)\n\n        renderer.close_group('axes')\n        self.stal"}, {"start_line": 71000, "end_line": 72825, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eturn\n        # Update text positions before `Text.draw` would, so that the\n        # FancyArrowPatch is correctly positioned.\n        self.update_positions(renderer)\n        self.update_bbox_position_size(renderer)\n        if self.arrow_patch is not None:  # FancyArrowPatch\n            if (self.arrow_patch.get_figure(root=False) is None and\n                    (fig := self.get_figure(root=False)) is not None):\n                self.arrow_patch.set_figure(fig)\n            self.arrow_patch.draw(renderer)\n        # Draw text, including FancyBboxPatch, after FancyArrowPatch.\n        # Otherwise, a wedge arrowstyle can land partly on top of the Bbox.\n        Text.draw(self, renderer)\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        # This block is the same as in Text.get_window_extent, but we need to\n        # set the renderer before calling update_positions().\n        if not self.get_visible() or not self._check_xy(renderer):\n            return Bbox.unit()\n        if renderer is not None:\n            self._renderer = renderer\n        if self._renderer is None:\n            self._renderer = self.get_figure(root=True)._get_renderer()\n        if self._renderer is None:\n            raise RuntimeError('Cannot get window extent without renderer')\n\n        self.update_positions(self._renderer)\n\n        text_bbox = Text.get_window_extent(self)\n        bboxes = [text_bbox]\n\n        if self.arrow_patch is not None:\n            bboxes.append(self.arrow_patch.get_window_extent())\n\n        return Bbox.union(bboxes)\n\n    def get_tightbbox(self, renderer=None):\n        # docstring inherited\n        if not self._check_xy(renderer):\n            return Bbox.null()\n        return super().get_tightbbox(renderer)\n\n\n_docstring.interpd.register(Annotation=Annotation.__init__.__doc__)\n"}, {"start_line": 70000, "end_line": 72000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t\n        # clipped by patchA and patchB.  Then it will be shrunk by shrinkA and\n        # shrinkB (in points).  If patchA is not set, self.bbox_patch is used.\n        self.arrow_patch.set_positions(arrow_begin, arrow_end)\n\n        if \"patchA\" in arrowprops:\n            patchA = arrowprops[\"patchA\"]\n        elif self._bbox_patch:\n            patchA = self._bbox_patch\n        elif self.get_text() == \"\":\n            patchA = None\n        else:\n            pad = renderer.points_to_pixels(4)\n            patchA = Rectangle(\n                xy=(bbox.x0 - pad / 2, bbox.y0 - pad / 2),\n                width=bbox.width + pad, height=bbox.height + pad,\n                transform=IdentityTransform(), clip_on=False)\n        self.arrow_patch.set_patchA(patchA)\n\n    @artist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        # Update text positions before `Text.draw` would, so that the\n        # FancyArrowPatch is correctly positioned.\n        self.update_positions(renderer)\n        self.update_bbox_position_size(renderer)\n        if self.arrow_patch is not None:  # FancyArrowPatch\n            if (self.arrow_patch.get_figure(root=False) is None and\n                    (fig := self.get_figure(root=False)) is not None):\n                self.arrow_patch.set_figure(fig)\n            self.arrow_patch.draw(renderer)\n        # Draw text, including FancyBboxPatch, after FancyArrowPatch.\n        # Otherwise, a wedge arrowstyle can land partly on top of the Bbox.\n        Text.draw(self, renderer)\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        # This block is the same as in Text.get_window_extent, but we need to\n        # set the renderer before calling update_positions().\n        if not self.get_visible() or not self._check_xy(renderer):\n            return Bbox.un"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e` subclass\n        \"\"\"\n        return (\n            self._offset(bbox.width, bbox.height, -bbox.x0, -bbox.y0, renderer)\n            if callable(self._offset)\n            else self._offset)\n\n    def set_width(self, width):\n        \"\"\"\n        Set the width of the box.\n\n        Parameters\n        ----------\n        width : float\n        \"\"\"\n        self.width = width\n        self.stale = True\n\n    def set_height(self, height):\n        \"\"\"\n        Set the height of the box.\n\n        Parameters\n        ----------\n        height : float\n        \"\"\"\n        self.height = height\n        self.stale = True\n\n    def get_visible_children(self):\n        r\"\"\"Return a list of the visible child `.Artist`\\s.\"\"\"\n        return [c for c in self._children if c.get_visible()]\n\n    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s.\"\"\"\n        return self._children\n\n    def _get_bbox_and_child_offsets(self, renderer):\n        \"\"\"\n        Return the bbox of the offsetbox and the child offsets.\n\n        The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n\n        Returns\n        -------\n        bbox\n        list of (xoffset, yoffset) pairs\n        \"\"\"\n        raise NotImplementedError(\n            \"get_bbox_and_offsets must be overridden in derived classes\")\n\n    def get_bbox(self, renderer):\n        \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n        bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n        return bbox\n\n    def get_window_extent(self, renderer=None):\n        # docstring inherited\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n        bbox = self.get_bbox(renderer)\n        try:  # Some subclasses redefine get_offset to take no args.\n            px, py = self.get_offset(bbox, renderer)\n        except TypeError:\n            px, py = self.get_offset()\n        return bbox.translated(px, py)\n\n  "}], "retrieved_count": 10, "cost_time": 4.303353548049927}
{"question": "How does the set_bbox_to_anchor method implement polymorphic input handling for bbox parameters of varying types (BboxBase, 2-tuple, 4-tuple) and what validation strategy ensures correctness during coordinate transformation?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "anchor, transform)\n\n    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the box is anchored to.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True\n\n    @_compat_get_offset\n    def get_offset(self, bbox, renderer):\n        # docstring inherited\n        fontsize_in_pixels = renderer.points_to_pixels(self.prop.get_size_in_points())\n        try:\n            borderpad_x, borderpad_y = self.borderpad\n        except TypeError:\n            borderpad_x = self.borderpad\n            borderpad_y = self.borderpad\n        pad_x_pixels = borderpad_x * fontsize_in_pixels\n        pad_y_pixels = borderpad_y * fontsize_in_pixels\n        bbox_to_anchor = self.get_bbox_to_anchor()\n        x0, y0 = _get_anchored_bbox(\n            self.loc,\n            Bbox.from_bounds(0, 0, bbox.width, bbox.height),\n            bbox_to_anchor,\n            pad_x_pixels,\n            pad_y_pixels\n        )\n        return x0 - bbox.x0, y0 - bbox.y0\n\n    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.bounds)\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n\n        # update the location and size of the legend\n        b"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  will use a transform to the bounding box of the parent.\n        \"\"\"\n        if bbox is None:\n            self._bbox_to_anchor = None\n            return\n        elif isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        if transform is None:\n            transform = BboxTransformTo(self.parent.bbox)\n\n        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\n                                               transform)\n        self.stale = True\n\n    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\n        \"\"\"\n        Place the *bbox* inside the *parentbbox* according to a given\n        location code. Return the (x, y) coordinate of the bbox.\n\n        Parameters\n        ----------\n        loc : int\n            A location code in range(1, 11). This corresponds to the possible\n            values for ``self._loc``, excluding \"best\".\n        bbox : `~matplotlib.transforms.Bbox`\n            bbox to be placed, in display coordinates.\n        parentbbox : `~matplotlib.transforms.Bbox`\n            A parent box which will contain the bbox, in display coordinates.\n        \"\"\"\n        pad = self.borderaxespad * renderer.points_to_pixels(self._fontsize)\n        return offsetbox._get_anchored_bbox(\n            loc, bbox, parentbbox,\n            pad, pad)\n\n    def _find_best_position(self, width, height, renderer):\n        \"\"\"Determine the best location to place the legend.\"\"\"\n        assert self.isaxes  # always holds, as this is only called internally\n\n        start_time = time.perf_counter()\n\n        bboxes, lines, offsets = self._auto_legend_data(renderer)\n\n        bbox = Bbox.from_bounds(0, 0, width, height)\n\n        candidates = []\n        f"}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   \"\"\"Return the bbox that the legend will be anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.parent.bbox\n        else:\n            return self._bbox_to_anchor\n\n    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the legend will be anchored to.\n\n        Parameters\n        ----------\n        bbox : `~matplotlib.transforms.BboxBase` or tuple\n            The bounding box can be specified in the following ways:\n\n            - A `.BboxBase` instance\n            - A tuple of ``(left, bottom, width, height)`` in the given\n              transform (normalized axes coordinate if None)\n            - A tuple of ``(left, bottom)`` where the width and height will be\n              assumed to be zero.\n            - *None*, to remove the bbox anchoring, and use the parent bbox.\n\n        transform : `~matplotlib.transforms.Transform`, optional\n            A transform to apply to the bounding box. If not specified, this\n            will use a transform to the bounding box of the parent.\n        \"\"\"\n        if bbox is None:\n            self._bbox_to_anchor = None\n            return\n        elif isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        if transform is None:\n            transform = BboxTransformTo(self.parent.bbox)\n\n        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\n                                               transform)\n        self.stale = True\n\n    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\n        \"\"\"\n        Place the *bbox* inside the *parentbbox* according to a given\n        location code. Return the (x, y) coordinate of the bbox.\n\n        P"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n\n_legend_kw_doc_base = \"\"\"\nbbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n    Box that is used to position the legend in conjunction with *loc*.\n    Defaults to ``axes.bbox`` (if called as a method to `.Axes.legend`) or\n    ``figure.bbox`` (if ``figure.legend``).  This argument allows arbitrary\n    placement of the legend.\n\n    Bbox coordinates are interpreted in the coordinate system given by\n    *bbox_transform*, with the default transform\n    Axes or Figure coordinates, depending on which ``legend`` is called.\n\n    If a 4-tuple or `.BboxBase` is given, then it specifies the bbox\n    ``(x, y, width, height)`` that the legend is placed in.\n    To put the legend in the best location in the bottom right\n    quadrant of the Axes (or figure)::\n\n        loc='best', bbox_to_anchor=(0.5, 0., 0.5, 0.5)\n\n    A 2-tuple ``(x, y)`` places the corner of the legend specified by *loc* at\n    x, y.  For example, to put the legend's upper right-hand corner in the\n    center of the Axes (or figure) the following keywords can be used::\n\n        loc='upper right', bbox_to_anchor=(0.5, 0.5)\n\nncols : int, default: 1\n    The number of columns that the legend has.\n\n    For backward compatibility, the spelling *ncol* is also supported\n    but it is discouraged. If both are given, *ncols* takes precedence.\n\nprop : None or `~matplotlib.font_manager.FontProperties` or dict\n    The font"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " set_child(self, child):\n        \"\"\"Set the child to be anchored.\"\"\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True\n\n    def get_child(self):\n        \"\"\"Return the child.\"\"\"\n        return self._child\n\n    def get_children(self):\n        \"\"\"Return the list of children.\"\"\"\n        return [self._child]\n\n    def get_bbox(self, renderer):\n        # docstring inherited\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return self.get_child().get_bbox(renderer).padded(pad)\n\n    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor, transform)\n\n    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the box is anchored to.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(f\"Invalid bbox: {bbox}\") from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True\n\n    @_compat_get_offset\n    def get_offset(self, bbox, renderer):\n        # docstring inherited\n        fontsize_in_"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "by2 < by1:\n            by2, by1 = by1, by2\n        return ax1 < bx2 and bx1 < ax2 and ay1 < by2 and by1 < ay2\n\n    def transformed(self, transform):\n        \"\"\"\n        Construct a `Bbox` by statically transforming this one by *transform*.\n        \"\"\"\n        pts = self.get_points()\n        ll, ul, lr = transform.transform(np.array(\n            [pts[0], [pts[0, 0], pts[1, 1]], [pts[1, 0], pts[0, 1]]]))\n        return Bbox([ll, [lr[0], ul[1]]])\n\n    coefs = {'C':  (0.5, 0.5),\n             'SW': (0, 0),\n             'S':  (0.5, 0),\n             'SE': (1.0, 0),\n             'E':  (1.0, 0.5),\n             'NE': (1.0, 1.0),\n             'N':  (0.5, 1.0),\n             'NW': (0, 1.0),\n             'W':  (0, 0.5)}\n\n    def anchored(self, c, container):\n        \"\"\"\n        Return a copy of the `Bbox` anchored to *c* within *container*.\n\n        Parameters\n        ----------\n        c : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}\n            Either an (*x*, *y*) pair of relative coordinates (0 is left or\n            bottom, 1 is right or top), 'C' (center), or a cardinal direction\n            ('SW', southwest, is bottom left, etc.).\n        container : `Bbox`\n            The box within which the `Bbox` is positioned.\n\n        See Also\n        --------\n        .Axes.set_anchor\n        \"\"\"\n        l, b, w, h = container.bounds\n        L, B, W, H = self.bounds\n        cx, cy = self.coefs[c] if isinstance(c, str) else c\n        return Bbox(self._points +\n                    [(l + cx * (w - W)) - L,\n                     (b + cy * (h - H)) - B])\n\n    def shrunk(self, mx, my):\n        \"\"\"\n        Return a copy of the `Bbox`, shrunk by the factor *mx*\n        in the *x* direction and the factor *my* in the *y* direction.\n        The lower left corner of the box remains unchanged.  Normally\n        *mx* and *my* will be less than 1, but this is not enforced.\n        \"\"\"\n        w, h = self.size\n        return Bbox([self._points[0],\n                     self._points[0] + ["}, {"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n    def contains(self, x, y):\n        # Docstring inherited.\n        return self._bbox.contains(*self._transform.inverted().transform((x, y)))\n\n    def fully_contains(self, x, y):\n        # Docstring inherited.\n        return self._bbox.fully_contains(*self._transform.inverted().transform((x, y)))\n\n\nclass LockableBbox(BboxBase):\n    \"\"\"\n    A `Bbox` where some elements may be locked at certain values.\n\n    When the child bounding box changes, the bounds of this bbox will update\n    accordingly with the exception of the locked elements.\n    \"\"\"\n    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "offsetbox.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "     -----\n        See `.Legend` for a detailed description of the anchoring mechanism.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        if isinstance(loc, str):\n            loc = _api.check_getitem(self.codes, loc=loc)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=mpl.rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True,\n            visible=frameon,\n            boxstyle=\"square,pad=0\",\n        )\n\n    def set_child(self, child):\n        \"\"\"Set the child to be anchored.\"\"\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True\n\n    def get_child(self):\n        \"\"\"Return the child.\"\"\"\n        return self._child\n\n    def get_children(self):\n        \"\"\"Return the list of children.\"\"\"\n        return [self._child]\n\n    def get_bbox(self, renderer):\n        # docstring inherited\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n        return self.get_child().get_bbox(renderer).padded(pad)\n\n    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_"}, {"start_line": 36000, "end_line": 38000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._points = points\n            self.invalidate()\n\n    def set(self, other):\n        \"\"\"\n        Set this bounding box from the \"frozen\" bounds of another `Bbox`.\n        \"\"\"\n        if np.any(self._points != other.get_points()):\n            self._points = other.get_points()\n            self.invalidate()\n\n    def mutated(self):\n        \"\"\"Return whether the bbox has changed since init.\"\"\"\n        return self.mutatedx() or self.mutatedy()\n\n    def mutatedx(self):\n        \"\"\"Return whether the x-limits have changed since init.\"\"\"\n        return (self._points[0, 0] != self._points_orig[0, 0] or\n                self._points[1, 0] != self._points_orig[1, 0])\n\n    def mutatedy(self):\n        \"\"\"Return whether the y-limits have changed since init.\"\"\"\n        return (self._points[0, 1] != self._points_orig[0, 1] or\n                self._points[1, 1] != self._points_orig[1, 1])\n\n\nclass TransformedBbox(BboxBase):\n    \"\"\"\n    A `Bbox` that is automatically transformed by a given\n    transform.  When either the child bounding box or transform\n    changes, the bounds of this bbox will update accordingly.\n    \"\"\"\n\n    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : `Bbox`\n        transform : `Transform`\n        \"\"\"\n        _api.check_isinstance(BboxBase, bbox=bbox)\n        _api.check_isinstance(Transform, transform=transform)\n        if transform.input_dims != 2 or transform.output_dims != 2:\n            raise ValueError(\n                \"The input and output dimensions of 'transform' must be 2\")\n\n        super().__init__(**kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None\n\n    __str__ = _make_str_method(\"_bbox\", \"_transform\")\n\n    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n        "}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "text.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  return BboxTransformTo(bbox)\n        elif isinstance(coords, BboxBase):\n            return BboxTransformTo(coords)\n        elif isinstance(coords, Transform):\n            return coords\n        elif not isinstance(coords, str):\n            raise TypeError(\n                f\"'xycoords' must be an instance of str, tuple[str, str], Artist, \"\n                f\"Transform, or Callable, not a {type(coords).__name__}\")\n\n        if coords == 'data':\n            return self.axes.transData\n        elif coords == 'polar':\n            from matplotlib.projections import PolarAxes\n            return PolarAxes.PolarTransform() + self.axes.transData\n\n        try:\n            bbox_name, unit = coords.split()\n        except ValueError:  # i.e. len(coords.split()) != 2.\n            raise ValueError(f\"{coords!r} is not a valid coordinate\") from None\n\n        bbox0, xy0 = None, None\n\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.get_figure(root=False).figbbox\n        elif bbox_name == \"subfigure\":\n            bbox0 = self.get_figure(root=False).bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n\n        # reference x, y in display coordinate\n        if bbox0 is not None:\n            xy0 = bbox0.p0\n        elif bbox_name == \"offset\":\n            xy0 = self._get_position_xy(renderer)\n        else:\n            raise ValueError(f\"{coords!r} is not a valid coordinate\")\n\n        if unit == \"points\":\n            tr = Affine2D().scale(\n                self.get_figure(root=True).dpi / 72)  # dpi/72 dots per point\n        elif unit == \"pixels\":\n            tr = Affine2D()\n        elif unit == \"fontsize\":\n            tr = Affine2D().scale(\n                self.get_size() * self.get_figure(root=True).dpi / 72)\n        elif unit == \"fraction\":\n            tr = Affine2D().scale(*bbox0.size)\n        else:\n            raise ValueError(f\"{unit!r} is not a recognized unit\")\n\n        return tr.translate(*xy0)\n\n    def set_annotation_clip"}], "retrieved_count": 10, "cost_time": 4.340232849121094}
{"question": "Why does the FigureCanvasPS class reconcile the dual rendering pathways between _print_figure and _print_figure_tex to maintain consistent PostScript output quality while accommodating both standard and TeX-based text rendering modes?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 38000, "end_line": 40000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:  # Write directly to outfile.\n            with cbook.open_file_cm(outfile, \"w\", encoding=\"latin-1\") as file:\n                if not file_requires_unicode(file):\n                    file = codecs.getwriter(\"latin-1\")(file)\n                print_figure_impl(file)\n\n    def _print_figure_tex(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n            "}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re_tex(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n                                     bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{_get_bbox_header(bbox)}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct boundi"}, {"start_line": 37000, "end_line": 39000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(f\"0 0 {_nums_to_str(width*72, height*72)} rectclip\", file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:  # Write directly to outfile.\n            with cbook.open_file_cm(outfile, \"w\", encoding=\"latin-1\") as file:\n                if not file_requires_unicode(file):\n                    file = codecs.getwriter(\"latin-1\")(file)\n                print_figure_impl(file)\n\n    def _print_figu"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(\"%!PS-Adobe-3.0\", file=fh)\n                if papertype != 'figure':\n                    print(f\"%%DocumentPaperSizes: {papertype}\", file=fh)\n                print(\"%%Pages: 1\", file=fh)\n            print(f\"%%LanguageLevel: 3\\n\"\n                  f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{_get_bbox_header(bbox)}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(_psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(_psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n"}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position, hatchcolors=hatchcolors):\n            ps = f\"{xo:g} {yo:g} {path_id}\"\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1\n\n    @_log_if_debug_on\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = _nums_to_str(*gc.get_rgb()[:3], sep=',')\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to bottom-left alignment, so subtract descent from the text-normal\n        # direction since text is normally positioned by its baseline.\n        rangle = np.radians(angle + 90)\n        pos = _nums_to_str(x - bl * np.cos(rangle), y - bl * np.sin(rangle))\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1\n\n  "}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                         bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{_get_bbox_header(bbox)}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n       "}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ng\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)\n\n    print_ps = functools.partialmethod(_print_ps, \"ps\")\n    print_eps = functools.partialmethod(_print_ps, \"eps\")\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()\n\n\ndef _convert_psfrags(tmppath, psfrags, paper_width, paper_height, orientation):\n    \"\"\"\n    When we want to use the LaTeX backend with postscript, we write PSFrag tags\n    to a temporary postscript file, each one marking a position for LaTeX to\n    render some text. convert_psfrags generates a LaTeX document containing the\n    commands to convert those tags to text. LaTeX/dvips produces the postscript\n    file that includes the actual text.\n    \"\"\"\n    with mpl.rc_context({\n            \"text.latex.preamble\":\n            mpl.rcParams[\"text.latex.preamble\"] +\n            mpl.texmanager._usepackage_if_not_loaded(\"color\") +\n            mpl.texmanager._usepackage_if_not_loaded(\"graphicx\") +\n            mpl.texmanager._usepackage_i"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(*rgbFace[:3], store=False)\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch, gc.get_hatch_linewidth())\n            write(\"gsave\\n\")\n            write(_nums_to_str(*gc.get_hatch_color()[:3]))\n            write(f\" {hatch_name} setpattern fill grestore\\n\")\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")\n\n\nclass _Orientation(Enum):\n    portrait, landscape = range(2)\n\n    def swap_if_landscape(self, shape):\n        return shape[::-1] if self.name == \"landscape\" else shape\n\n\nclass FigureCanvasPS(FigureCanvasBase):\n    fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "tadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)\n\n    def _print_figure(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "backend_ps.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rings in PostScript format\n    \"\"\"\n    s = '/sfnts['\n    pos = 0\n    while pos < len(fontdata):\n        i = bisect.bisect_left(breakpoints, pos + 65534)\n        newpos = breakpoints[i-1]\n        if newpos <= pos:\n            # have to accept a larger string\n            newpos = breakpoints[-1]\n        s += f'<{fontdata[pos:newpos].hex()}00>'  # Always NUL terminate.\n        pos = newpos\n    s += ']def'\n    return '\\n'.join(s[i:i+100] for i in range(0, len(s), 100))\n\n\ndef _log_if_debug_on(meth):\n    \"\"\"\n    Wrap `RendererPS` method *meth* to emit a PS comment with the method name,\n    if the global flag `debugPS` is set.\n    \"\"\"\n    @functools.wraps(meth)\n    def wrapper(self, *args, **kwargs):\n        if debugPS:\n            self._pswriter.write(f\"% {meth.__name__}\\n\")\n        return meth(self, *args, **kwargs)\n\n    return wrapper\n\n\nclass RendererPS(_backend_pdf_ps.RendererPDFPSBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles.\n    \"\"\"\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/afm\")\n    _use_afm_rc_name = \"ps.useafm\"\n\n    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and then scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id ="}], "retrieved_count": 10, "cost_time": 4.334588050842285}
{"question": "Why does the repeated instantiation of figure and axes objects with different DPI values in test_legend_proper_window_extent impact renderer caching and what performance degradation occurs when get_window_extent is called sequentially on legends without renderer state reuse?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ected extent under various dpi...\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x01 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n\n    fig, ax = plt.subplots(dpi=200)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x02 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n    assert pytest.approx(x01*2, 0.1) == x02\n\n\ndef test_window_extent_cached_renderer():\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    leg2 = fig.legend()\n    fig.canvas.draw()\n    # check that get_window_extent will use the cached renderer\n    leg.get_window_extent()\n    leg2.get_window_extent()\n\n\ndef test_legend_title_fontprop_fontsize():\n    # test the title_fontsize kwarg\n    plt.plot(range(10), label=\"mock data\")\n    with pytest.raises(ValueError):\n        plt.legend(title='Aardvark', title_fontsize=22,\n                   title_fontproperties={'family': 'serif', 'size': 22})\n\n    leg = plt.legend(title='Aardvark', title_fontproperties=FontProperties(\n                                       family='serif', size=22))\n    assert leg.get_title().get_size() == 22\n\n    fig, axes = plt.subplots(2, 3, figsize=(10, 6))\n    axes = axes.flat\n    axes[0].plot(range(10), label=\"mock data\")\n    leg0 = axes[0].legend(title='Aardvark', title_fontsize=22)\n    assert leg0.get_title().get_fontsize() == 22\n    axes[1].plot(range(10), label=\"mock data\")\n    leg1 = axes[1].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif', 'size': 22})\n    assert leg1.get_title().get_fontsize() == 22\n    axes[2].plot(range(10), label=\"mock data\")\n    mpl.rcParams['legend.title_fontsize'] = None\n    leg2 = axes[2].legend(title='Aardvark',\n                          title_fontproperties={'family': 'serif'})\n    assert leg2.get_title().get_fontsize() == mpl.rcParams['font.size']\n    axes[3].plot(range(10), label=\"mock data\")\n    leg3 = axes[3].legend(title='A"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " invalid argument to legend shadow\n    # (i.e. not [color|bool]) raises ValueError\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3], label='test')\n    with pytest.raises(ValueError, match=\"dict or bool\"):\n        ax.legend(loc=\"upper left\", shadow=\"aardvark\")  # Bad argument\n\n\ndef test_shadow_framealpha():\n    # Test if framealpha is activated when shadow is True\n    # and framealpha is not explicitly passed'''\n    fig, ax = plt.subplots()\n    ax.plot(range(100), label=\"test\")\n    leg = ax.legend(shadow=True, facecolor='w')\n    assert leg.get_frame().get_alpha() == 1\n\n\ndef test_legend_title_empty():\n    # test that if we don't set the legend title, that\n    # it comes back as an empty string, and that it is not\n    # visible:\n    fig, ax = plt.subplots()\n    ax.plot(range(10), label=\"mock data\")\n    leg = ax.legend()\n    assert leg.get_title().get_text() == \"\"\n    assert not leg.get_title().get_visible()\n\n\ndef test_legend_proper_window_extent():\n    # test that legend returns the expected extent under various dpi...\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x01 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n\n    fig, ax = plt.subplots(dpi=200)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    x02 = leg.get_window_extent(fig.canvas.get_renderer()).x0\n    assert pytest.approx(x01*2, 0.1) == x02\n\n\ndef test_window_extent_cached_renderer():\n    fig, ax = plt.subplots(dpi=100)\n    ax.plot(range(10), label='Aardvark')\n    leg = ax.legend()\n    leg2 = fig.legend()\n    fig.canvas.draw()\n    # check that get_window_extent will use the cached renderer\n    leg.get_window_extent()\n    leg2.get_window_extent()\n\n\ndef test_legend_title_fontprop_fontsize():\n    # test the title_fontsize kwarg\n    plt.plot(range(10), label=\"mock data\")\n    with pytest.raises(ValueError):\n        plt.legend(title='Aardvark', title_fontsize=22,\n                   title_fontproperties={'family': 'serif', 'size': 22})\n"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 790.,  45.],     # lower right\n             [10., 10., 133., 45.],       # left lower\n             [10., 282.5, 133., 317.5],   # left center\n             [10., 555., 133., 590.],     # left upper\n             [667, 10., 790., 45.],       # right lower\n             [667., 282.5, 790., 317.5],  # right center\n             [667., 555., 790., 590.]]    # right upper\n\n    for nn, todo in enumerate(todos):\n        print(todo)\n        fig, axs = plt.subplots(constrained_layout=True, dpi=100)\n        axs.plot(range(10), label='Boo1')\n        leg = fig.legend(loc='outside ' + todo)\n        fig.draw_without_rendering()\n\n        assert_allclose(axs.get_window_extent().extents,\n                        axbb[nn])\n        assert_allclose(leg.get_window_extent().extents,\n                        legbb[nn])\n\n\n@image_comparison(['legend_stackplot.png'],\n                  tol=0 if platform.machine() == 'x86_64' else 0.031)\ndef test_legend_stackplot():\n    \"\"\"Test legend for PolyCollection using stackplot.\"\"\"\n    # related to #1341, #1943, and PR #3303\n    fig, ax = plt.subplots()\n    x = np.linspace(0, 10, 10)\n    y1 = 1.0 * x\n    y2 = 2.0 * x + 1\n    y3 = 3.0 * x + 2\n    ax.stackplot(x, y1, y2, y3, labels=['y1', 'y2', 'y3'])\n    ax.set_xlim(0, 10)\n    ax.set_ylim(0, 70)\n    ax.legend(loc='best')\n\n\ndef test_cross_figure_patch_legend():\n    fig, ax = plt.subplots()\n    fig2, ax2 = plt.subplots()\n\n    brs = ax.bar(range(3), range(3))\n    fig2.legend(brs, 'foo')\n\n\ndef test_nanscatter():\n    fig, ax = plt.subplots()\n\n    h = ax.scatter([np.nan], [np.nan], marker=\"o\",\n                   facecolor=\"r\", edgecolor=\"r\", s=3)\n\n    ax.legend([h], [\"scatter\"])\n\n    fig, ax = plt.subplots()\n    for color in ['red', 'green', 'blue']:\n        n = 750\n        x, y = np.random.rand(2, n)\n        scale = 200.0 * np.random.rand(n)\n        ax.scatter(x, y, c=color, s=scale, label=color,\n                   alpha=0.3, edgecolors='none')\n\n    ax.legend()\n    ax.grid(True)\n\n\ndef test_legend_repeatcheckok():"}, {"start_line": 41000, "end_line": 43000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_facecolor()[:-1]\n    assert lh.get_edgecolor()[:-1] == hh[1].get_edgecolor()[:-1]\n\n\n@needs_usetex\ndef test_usetex_no_warn(caplog):\n    mpl.rcParams['font.family'] = 'serif'\n    mpl.rcParams['font.serif'] = 'Computer Modern'\n    mpl.rcParams['text.usetex'] = True\n\n    fig, ax = plt.subplots()\n    ax.plot(0, 0, label='input')\n    ax.legend(title=\"My legend\")\n\n    fig.canvas.draw()\n    assert \"Font family ['serif'] not found.\" not in caplog.text\n\n\ndef test_warn_big_data_best_loc(monkeypatch):\n    # Force _find_best_position to think it took a long time.\n    counter = itertools.count(0, step=1.5)\n    monkeypatch.setattr(time, 'perf_counter', lambda: next(counter))\n\n    fig, ax = plt.subplots()\n    fig.canvas.draw()  # So that we can call draw_artist later.\n\n    # Place line across all possible legend locations.\n    x = [0.9, 0.1, 0.1, 0.9, 0.9, 0.5]\n    y = [0.95, 0.95, 0.05, 0.05, 0.5, 0.5]\n    ax.plot(x, y, 'o-', label='line')\n\n    with rc_context({'legend.loc': 'best'}):\n        legend = ax.legend()\n    with pytest.warns(UserWarning,\n                      match='Creating legend with loc=\"best\" can be slow with large '\n                      'amounts of data.') as records:\n        fig.draw_artist(legend)  # Don't bother drawing the lines -- it's slow.\n    # The _find_best_position method of Legend is called twice, duplicating\n    # the warning message.\n    assert len(records) == 2\n\n\ndef test_no_warn_big_data_when_loc_specified(monkeypatch):\n    # Force _find_best_position to think it took a long time.\n    counter = itertools.count(0, step=1.5)\n    monkeypatch.setattr(time, 'perf_counter', lambda: next(counter))\n\n    fig, ax = plt.subplots()\n    fig.canvas.draw()\n\n    # Place line across all possible legend locations.\n    x = [0.9, 0.1, 0.1, 0.9, 0.9, 0.5]\n    y = [0.95, 0.95, 0.05, 0.05, 0.5, 0.5]\n    ax.plot(x, y, 'o-', label='line')\n\n    legend = ax.legend('best')\n    fig.draw_artist(legend)  # Check that no warning is emitted.\n\n\n@pytest.mark.parametrize('label_arr"}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "    fig, ax = plt.subplots()\n    ax.fill_between([0, 1, 2], [1, 2, 3], [2, 3, 4],\n                    facecolor='r', edgecolor='face', label='Fill')\n    ax.legend()\n\n\ndef test_legend_text_axes():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2], [3, 4], label='line')\n    leg = ax.legend()\n\n    assert leg.axes is ax\n    assert leg.get_texts()[0].axes is ax\n\n\ndef test_handlerline2d():\n    # Test marker consistency for monolithic Line2D legend handler (#11357).\n    fig, ax = plt.subplots()\n    ax.scatter([0, 1], [0, 1], marker=\"v\")\n    handles = [mlines.Line2D([0], [0], marker=\"v\")]\n    leg = ax.legend(handles, [\"Aardvark\"], numpoints=1)\n    assert handles[0].get_marker() == leg.legend_handles[0].get_marker()\n\n\ndef test_subfigure_legend():\n    # Test that legend can be added to subfigure (#20723)\n    subfig = plt.figure().subfigures()\n    ax = subfig.subplots()\n    ax.plot([0, 1], [0, 1], label=\"line\")\n    leg = subfig.legend()\n    assert leg.get_figure(root=False) is subfig\n\n\ndef test_setting_alpha_keeps_polycollection_color():\n    pc = plt.fill_between([0, 1], [2, 3], color='#123456', label='label')\n    patch = plt.legend().get_patches()[0]\n    patch.set_alpha(0.5)\n    assert patch.get_facecolor()[:3] == tuple(pc.get_facecolor()[0][:3])\n    assert patch.get_edgecolor()[:3] == tuple(pc.get_edgecolor()[0][:3])\n\n\ndef test_legend_markers_from_line2d():\n    # Test that markers can be copied for legend lines (#17960)\n    _markers = ['.', '*', 'v']\n    fig, ax = plt.subplots()\n    lines = [mlines.Line2D([0], [0], ls='None', marker=mark)\n             for mark in _markers]\n    labels = [\"foo\", \"bar\", \"xyzzy\"]\n    markers = [line.get_marker() for line in lines]\n    legend = ax.legend(lines, labels)\n\n    new_markers = [line.get_marker() for line in legend.get_lines()]\n    new_labels = [text.get_text() for text in legend.get_texts()]\n\n    assert markers == new_markers == _markers\n    assert labels == new_labels\n\n\n@check_figures_equal()\ndef test_ncol_ncols(fig_test, fig_ref):\n    "}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_figure_legend_outside():\n    todos = ['upper ' + pos for pos in ['left', 'center', 'right']]\n    todos += ['lower ' + pos for pos in ['left', 'center', 'right']]\n    todos += ['left ' + pos for pos in ['lower', 'center', 'upper']]\n    todos += ['right ' + pos for pos in ['lower', 'center', 'upper']]\n\n    upperext = [20.347556,  27.722556, 790.583, 545.499]\n    lowerext = [20.347556,  71.056556, 790.583, 588.833]\n    leftext = [151.681556, 27.722556, 790.583, 588.833]\n    rightext = [20.347556,  27.722556, 659.249, 588.833]\n    axbb = [upperext, upperext, upperext,\n            lowerext, lowerext, lowerext,\n            leftext, leftext, leftext,\n            rightext, rightext, rightext]\n\n    legbb = [[10., 555., 133., 590.],     # upper left\n             [338.5, 555., 461.5, 590.],  # upper center\n             [667, 555., 790.,  590.],    # upper right\n             [10., 10., 133.,  45.],      # lower left\n             [338.5, 10., 461.5,  45.],   # lower center\n             [667., 10., 790.,  45.],     # lower right\n             [10., 10., 133., 45.],       # left lower\n             [10., 282.5, 133., 317.5],   # left center\n             [10., 555., 133., 590.],     # left upper\n             [667, 10., 790., 45.],       # right lower\n             [667., 282.5, 790., 317.5],  # right center\n             [667., 555., 790., 590.]]    # right upper\n\n    for nn, todo in enumerate(todos):\n        print(todo)\n        fig, axs = plt.subplots(constrained_layout=True, dpi=100)\n        axs.plot(range(10), label='Boo1')\n        leg = fig.legend(loc='outside ' + todo)\n        fig.draw_without_rendering()\n\n        assert_allclose(axs.get_window_extent().extents,\n                        axbb[nn])\n        assert_allclose(leg.get_window_extent().extents,\n                        legbb[nn])\n\n\n@image_comparison(['legend_stackplot.png'],\n                  tol=0 if platform.machine() == 'x86_64' else 0.031)\ndef test_legend_stackplot():\n    \"\"\"Test legend for PolyCollection using stackplo"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " ax.plot(x, y, markers[0], label=labels[0])\n    ax.plot(x, y, markers[1], label=labels[1])\n    ax.plot(x, y, markers[2], label=labels[2])\n    leg = ax.legend(reverse=True)\n    actual_labels = [t.get_text() for t in leg.get_texts()]\n    actual_markers = [h.get_marker() for h in leg.legend_handles]\n    assert actual_labels == list(reversed(labels))\n    assert actual_markers == list(reversed(markers))\n\n\n@check_figures_equal()\ndef test_reverse_legend_display(fig_test, fig_ref):\n    \"\"\"Check that the rendered legend entries are reversed\"\"\"\n    ax = fig_test.subplots()\n    ax.plot([1], 'ro', label=\"first\")\n    ax.plot([2], 'bx', label=\"second\")\n    ax.legend(reverse=True)\n\n    ax = fig_ref.subplots()\n    ax.plot([2], 'bx', label=\"second\")\n    ax.plot([1], 'ro', label=\"first\")\n    ax.legend()\n\n\nclass TestLegendFunction:\n    # Tests the legend function on the Axes and pyplot.\n    def test_legend_no_args(self):\n        lines = plt.plot(range(10), label='hello world')\n        with mock.patch('matplotlib.legend.Legend') as Legend:\n            plt.legend()\n        Legend.assert_called_with(plt.gca(), lines, ['hello world'])\n\n    def test_legend_positional_handles_labels(self):\n        lines = plt.plot(range(10))\n        with mock.patch('matplotlib.legend.Legend') as Legend:\n            plt.legend(lines, ['hello world'])\n        Legend.assert_called_with(plt.gca(), lines, ['hello world'])\n\n    def test_legend_positional_handles_only(self):\n        lines = plt.plot(range(10))\n        with pytest.raises(TypeError, match='but found an Artist'):\n            # a single arg is interpreted as labels\n            # it's a common error to just pass handles\n            plt.legend(lines)\n\n    def test_legend_positional_labels_only(self):\n        lines = plt.plot(range(10), label='hello world')\n        with mock.patch('matplotlib.legend.Legend') as Legend:\n            plt.legend(['foobar'])\n        Legend.assert_called_with(plt.gca(), lines, ['foobar'])\n\n    def test_legend_three_args(self):"}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h pytest.raises(UserWarning, match=\"No artists with labels found\"):\n        plt.legend()\n\n\n@pytest.mark.filterwarnings(\"ignore:No artists with labels found to put in legend\")\ndef test_legend_nolabels_draw():\n    plt.plot([1, 2, 3])\n    plt.legend()\n    assert plt.gca().get_legend() is not None\n\n\ndef test_legend_loc_polycollection():\n    # Test that the legend is placed in the correct\n    # position for 'best' for polycollection\n    x = [3, 4, 5]\n    y1 = [1, 1, 1]\n    y2 = [5, 5, 5]\n    leg_bboxes = []\n    fig, axs = plt.subplots(ncols=2, figsize=(10, 5))\n    for ax, loc in zip(axs.flat, ('best', 'lower left')):\n        ax.fill_between(x, y1, y2, color='gray', alpha=0.5, label='Shaded Area')\n        ax.set_xlim(0, 6)\n        ax.set_ylim(-1, 5)\n        leg = ax.legend(loc=loc)\n        fig.canvas.draw()\n        leg_bboxes.append(\n            leg.get_window_extent().transformed(ax.transAxes.inverted()))\n    assert_allclose(leg_bboxes[1].bounds, leg_bboxes[0].bounds)\n\n\ndef test_legend_text():\n    # Test that legend is place in the correct\n    # position for 'best' when there is text in figure\n    fig, axs = plt.subplots(ncols=2, figsize=(10, 5))\n    leg_bboxes = []\n    for ax, loc in zip(axs.flat, ('best', 'lower left')):\n        x = [1, 2]\n        y = [2, 1]\n        ax.plot(x, y, label='plot name')\n        ax.text(1.5, 2, 'some text blahblah', verticalalignment='top')\n        leg = ax.legend(loc=loc)\n        fig.canvas.draw()\n        leg_bboxes.append(\n            leg.get_window_extent().transformed(ax.transAxes.inverted()))\n    assert_allclose(leg_bboxes[1].bounds, leg_bboxes[0].bounds)\n\n\ndef test_legend_annotate():\n    fig, ax = plt.subplots()\n\n    ax.plot([1, 2, 3], label=\"Line\")\n    ax.annotate(\"a\", xy=(1, 1))\n    ax.legend(loc=0)\n\n    with mock.patch.object(\n            fig, '_get_renderer', wraps=fig._get_renderer) as mocked_get_renderer:\n        fig.savefig(io.BytesIO())\n\n    # Finding the legend position should not require _get_renderer to be called\n    mocked_"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d = ax.legend()\n    with pytest.warns(UserWarning,\n                      match='Creating legend with loc=\"best\" can be slow with large '\n                      'amounts of data.') as records:\n        fig.draw_artist(legend)  # Don't bother drawing the lines -- it's slow.\n    # The _find_best_position method of Legend is called twice, duplicating\n    # the warning message.\n    assert len(records) == 2\n\n\ndef test_no_warn_big_data_when_loc_specified(monkeypatch):\n    # Force _find_best_position to think it took a long time.\n    counter = itertools.count(0, step=1.5)\n    monkeypatch.setattr(time, 'perf_counter', lambda: next(counter))\n\n    fig, ax = plt.subplots()\n    fig.canvas.draw()\n\n    # Place line across all possible legend locations.\n    x = [0.9, 0.1, 0.1, 0.9, 0.9, 0.5]\n    y = [0.95, 0.95, 0.05, 0.05, 0.5, 0.5]\n    ax.plot(x, y, 'o-', label='line')\n\n    legend = ax.legend('best')\n    fig.draw_artist(legend)  # Check that no warning is emitted.\n\n\n@pytest.mark.parametrize('label_array', [['low', 'high'],\n                                         ('low', 'high'),\n                                         np.array(['low', 'high'])])\ndef test_plot_multiple_input_multiple_label(label_array):\n    # test ax.plot() with multidimensional input\n    # and multiple labels\n    x = [1, 2, 3]\n    y = [[1, 2],\n         [2, 5],\n         [4, 9]]\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y, label=label_array)\n    leg = ax.legend()\n    legend_texts = [entry.get_text() for entry in leg.get_texts()]\n    assert legend_texts == ['low', 'high']\n\n\n@pytest.mark.parametrize('label', ['one', 1, int])\ndef test_plot_multiple_input_single_label(label):\n    # test ax.plot() with multidimensional input\n    # and single label\n    x = [1, 2, 3]\n    y = [[1, 2],\n         [2, 5],\n         [4, 9]]\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y, label=label)\n    leg = ax.legend()\n    legend_texts = [entry.get_text() for entry in leg.get_texts()]\n    assert legend_texts == [str(label)] * 2\n\n\ndef test_"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "test_legend.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "():\n    # Test that legend is place in the correct\n    # position for 'best' when there is text in figure\n    fig, axs = plt.subplots(ncols=2, figsize=(10, 5))\n    leg_bboxes = []\n    for ax, loc in zip(axs.flat, ('best', 'lower left')):\n        x = [1, 2]\n        y = [2, 1]\n        ax.plot(x, y, label='plot name')\n        ax.text(1.5, 2, 'some text blahblah', verticalalignment='top')\n        leg = ax.legend(loc=loc)\n        fig.canvas.draw()\n        leg_bboxes.append(\n            leg.get_window_extent().transformed(ax.transAxes.inverted()))\n    assert_allclose(leg_bboxes[1].bounds, leg_bboxes[0].bounds)\n\n\ndef test_legend_annotate():\n    fig, ax = plt.subplots()\n\n    ax.plot([1, 2, 3], label=\"Line\")\n    ax.annotate(\"a\", xy=(1, 1))\n    ax.legend(loc=0)\n\n    with mock.patch.object(\n            fig, '_get_renderer', wraps=fig._get_renderer) as mocked_get_renderer:\n        fig.savefig(io.BytesIO())\n\n    # Finding the legend position should not require _get_renderer to be called\n    mocked_get_renderer.assert_not_called()\n\n\ndef test_boxplot_legend_labels():\n    # Test that legend entries are generated when passing `label`.\n    np.random.seed(19680801)\n    data = np.random.random((10, 4))\n    fig, axs = plt.subplots(nrows=1, ncols=4)\n    legend_labels = ['box A', 'box B', 'box C', 'box D']\n\n    # Testing legend labels and patch passed to legend.\n    bp1 = axs[0].boxplot(data, patch_artist=True, label=legend_labels)\n    assert [v.get_label() for v in bp1['boxes']] == legend_labels\n    handles, labels = axs[0].get_legend_handles_labels()\n    assert labels == legend_labels\n    assert all(isinstance(h, mpl.patches.PathPatch) for h in handles)\n\n    # Testing legend without `box`.\n    bp2 = axs[1].boxplot(data, label=legend_labels, showbox=False)\n    # Without a box, The legend entries should be passed from the medians.\n    assert [v.get_label() for v in bp2['medians']] == legend_labels\n    handles, labels = axs[1].get_legend_handles_labels()\n    assert labels == legend_labels\n"}], "retrieved_count": 10, "cost_time": 1.3001389503479004}
{"question": "Why does the _make_flip_transform method consistently apply a vertical flip transformation, and how does this design choice relate to the coordinate system mismatch between matplotlib and SVG?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ake_flip_transform(clippath_trans)\n            dictkey = (self._get_clippath_id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return {}\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            _, oid = clip\n        return {'clip-path': f'url(#{oid})'}\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=f\"{s}_{self._groupd[s]:d}\")\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "h_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=f\"{s}_{self._groupd[s]:d}\")\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "city\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0 \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        for points, colors in zip(triangles_array, colors_array):\n            self._draw_gouraud_triangle(trans_and_flip.transform(points), colors)\n        writer.end('g')\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which would also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = f'{self.basename}.image{next(self._image_counter)}.png'\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n      "}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "uld also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = f'{self.basename}.image{next(self._image_counter)}.png'\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.heigh"}, {"start_line": 9000, "end_line": 11000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lf.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clip_path_ids = {}\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width=f'{str_width}pt',\n            height=f'{str_height}pt',\n            viewBox=f'0 0 {str_width} {str_height}',\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            id=mpl.rcParams['svg.id'],\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def _get_clippath_id(self, clippath):\n        \"\"\"\n        Returns a stable and unique identifier for the *clippath* argument\n        object within the current rendering context.\n\n        This allows plots that include custom clip paths to produce identical\n        SVG output on each render, provided that the :rc:`svg.hashsalt` config\n        setting and the ``SOURCE_DATE_EPOCH`` build-time environment variable\n        are set to fixed values.\n        \"\"\"\n        if clippath not in self._clip_path_ids:\n            self._clip_path_ids[clippath] = len(self._clip_path_ids)\n        return self._clip_path_ids[clippath]\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush("}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self._get_style(gc, rgbFace))\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **sel"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "rg/2000/svg\",\n            version=\"1.1\",\n            id=mpl.rcParams['svg.id'],\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def _get_clippath_id(self, clippath):\n        \"\"\"\n        Returns a stable and unique identifier for the *clippath* argument\n        object within the current rendering context.\n\n        This allows plots that include custom clip paths to produce identical\n        SVG output on each render, provided that the :rc:`svg.hashsalt` config\n        setting and the ``SOURCE_DATE_EPOCH`` build-time environment variable\n        are set to fixed values.\n        \"\"\"\n        if clippath not in self._clip_path_ids:\n            self._clip_path_ids[clippath] = len(self._clip_path_ids)\n        return self._clip_path_ids[clippath]\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [da"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " writer.start('cc:Agent')\n                writer.element('dc:title', text=agent)\n                writer.end('cc:Agent')\n            writer.end(f'dc:{key.lower()}')\n\n        # Multiple values.\n        keywords = metadata.pop('Keywords', None)\n        if keywords is not None:\n            if isinstance(keywords, str):\n                keywords = [keywords]\n            _check_is_iterable_of_str(keywords, 'Keywords')\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start('dc:subject')\n            writer.start('rdf:Bag')\n            for keyword in keywords:\n                writer.element('rdf:li', text=keyword)\n            writer.end('rdf:Bag')\n            writer.end('dc:subject')\n\n        if mid is not None:\n            writer.close(mid)\n\n        if metadata:\n            raise ValueError('Unknown metadata key(s) passed to SVG writer: ' +\n                             ','.join(metadata))\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.sha256()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return f'{type}{m.hexdigest()[:10]}'\n\n    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        lw = gc.get_hatch_l"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "backend_cairo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "atch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        if rgbFace is not None:\n            ctx.save()\n            _set_rgba(ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n            ctx.fill_preserve()\n            ctx.restore()\n        hatch_path = gc.get_hatch_path()\n        if hatch_path:\n            dpi = int(self.dpi)\n            hatch_surface = ctx.get_target().create_similar(\n                cairo.Content.COLOR_ALPHA, dpi, dpi)\n            hatch_ctx = cairo.Context(hatch_surface)\n            _append_path(hatch_ctx, hatch_path,\n                         Affine2D().scale(dpi, -dpi).translate(0, dpi),\n                         None)\n            hatch_ctx.set_line_width(self.points_to_pixels(gc.get_hatch_linewidth()))\n            hatch_ctx.set_source_rgba(*gc.get_hatch_color())\n            hatch_ctx.fill_preserve()\n            hatch_ctx.stroke()\n            hatch_pattern = cairo.SurfacePattern(hatch_surface)\n            hatch_pattern.set_extend(cairo.Extend.REPEAT)\n            ctx.save()\n            ctx.set_source(hatch_pattern)\n            ctx.fill_preserve()\n            ctx.restore()\n        ctx.stroke()\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            fi"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "backend_svg.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   attrib={'d': dpath,\n                    'fill': f'url(#GR{self._n_gradients:x}_2)',\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1\n\n    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        writer = self.writer\n        writer.start('g', **self._get_clip_attrs(gc))\n        transform = transform.frozen()\n        trans_and_flip = self._make_flip_transform(transform)\n\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0 \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        for points, colors in zip(triangles_array, colors_array):\n            self._draw_gouraud_triangle(trans_and_flip.transform(points), colors)\n        writer.end('g')\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which wo"}], "retrieved_count": 10, "cost_time": 1.2181923389434814}
{"question": "Why does the test_shared_and_moved function verify that tick label visibility remains consistent when axis sharing is combined with explicit tick position changes, and what underlying matplotlib behavior does this test protect against?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         assert tick.tick1line.get_visible() == visible\n    for ax, y_visible, in zip(axs, y_visible):\n        for tick in ax.yaxis.get_major_ticks():\n            assert tick.tick1line.get_visible() == visible\n\n\ndef test_shared():\n    rdim = (4, 4, 2)\n    share = {\n            'all': np.ones(rdim[:2], dtype=bool),\n            'none': np.zeros(rdim[:2], dtype=bool),\n            'row': np.array([\n                [False, True, False, False],\n                [True, False, False, False],\n                [False, False, False, True],\n                [False, False, True, False]]),\n            'col': np.array([\n                [False, False, True, False],\n                [False, False, False, True],\n                [True, False, False, False],\n                [False, True, False, False]]),\n            }\n    visible = {\n            'x': {\n                'all': [False, False, True, True],\n                'col': [False, False, True, True],\n                'row': [True] * 4,\n                'none': [True] * 4,\n                False: [True] * 4,\n                True: [False, False, True, True],\n                },\n            'y': {\n                'all': [True, False, True, False],\n                'col': [True] * 4,\n                'row': [True, False, True, False],\n                'none': [True] * 4,\n                False: [True] * 4,\n                True: [True, False, True, False],\n                },\n            }\n    share[False] = share['none']\n    share[True] = share['all']\n\n    # test default\n    f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2)\n    axs = [a1, a2, a3, a4]\n    check_shared(axs, share['none'], share['none'])\n    plt.close(f)\n\n    # test all option combinations\n    ops = [False, True, 'all', 'none', 'row', 'col', 0, 1]\n    for xo in ops:\n        for yo in ops:\n            f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2, sharex=xo, sharey=yo)\n            axs = [a1, a2, a3, a4]\n            check_shared(axs, share[xo], share[yo])\n            check_ticklabel_visible(axs,"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import itertools\nimport platform\n\nimport numpy as np\nimport pytest\n\nimport matplotlib as mpl\nfrom matplotlib.axes import Axes, SubplotBase\nimport matplotlib.pyplot as plt\nfrom matplotlib.testing.decorators import check_figures_equal, image_comparison\n\n\ndef check_shared(axs, x_shared, y_shared):\n    \"\"\"\n    x_shared and y_shared are n x n boolean matrices; entry (i, j) indicates\n    whether the x (or y) axes of subplots i and j should be shared.\n    \"\"\"\n    for (i1, ax1), (i2, ax2), (i3, (name, shared)) in itertools.product(\n            enumerate(axs),\n            enumerate(axs),\n            enumerate(zip(\"xy\", [x_shared, y_shared]))):\n        if i2 <= i1:\n            continue\n        assert axs[0]._shared_axes[name].joined(ax1, ax2) == shared[i1, i2], \\\n            \"axes %i and %i incorrectly %ssharing %s axis\" % (\n                i1, i2, \"not \" if shared[i1, i2] else \"\", name)\n\n\ndef check_ticklabel_visible(axs, x_visible, y_visible):\n    \"\"\"Check that the x and y ticklabel visibility is as specified.\"\"\"\n    for i, (ax, vx, vy) in enumerate(zip(axs, x_visible, y_visible)):\n        for l in ax.get_xticklabels() + [ax.xaxis.offsetText]:\n            assert l.get_visible() == vx, \\\n                    f\"Visibility of x axis #{i} is incorrectly {vx}\"\n        for l in ax.get_yticklabels() + [ax.yaxis.offsetText]:\n            assert l.get_visible() == vy, \\\n                    f\"Visibility of y axis #{i} is incorrectly {vy}\"\n        # axis label \"visibility\" is toggled by label_outer by resetting the\n        # label to empty, but it can also be empty to start with.\n        if not vx:\n            assert ax.get_xlabel() == \"\"\n        if not vy:\n            assert ax.get_ylabel() == \"\"\n\n\ndef check_tick1_visible(axs, x_visible, y_visible):\n    \"\"\"\n    Check that the x and y tick visibility is as specified.\n\n    Note: This only checks the tick1line, i.e. bottom / left ticks.\n    \"\"\"\n    for ax, visible, in zip(axs, x_visible):\n        for tick in ax.xaxis.get_major_ticks():\n   "}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " visible['x'][xo], visible['y'][yo])\n            plt.close(f)\n\n\n@pytest.mark.parametrize('remove_ticks', [True, False])\n@pytest.mark.parametrize('layout_engine', ['none', 'tight', 'constrained'])\n@pytest.mark.parametrize('with_colorbar', [True, False])\ndef test_label_outer(remove_ticks, layout_engine, with_colorbar):\n    fig = plt.figure(layout=layout_engine)\n    axs = fig.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.set(xlabel=\"foo\", ylabel=\"bar\")\n        if with_colorbar:\n            fig.colorbar(mpl.cm.ScalarMappable(), ax=ax)\n        ax.label_outer(remove_inner_ticks=remove_ticks)\n    check_ticklabel_visible(\n        axs.flat, [False, False, True, True], [True, False, True, False])\n    if remove_ticks:\n        check_tick1_visible(\n            axs.flat, [False, False, True, True], [True, False, True, False])\n    else:\n        check_tick1_visible(\n            axs.flat, [True, True, True, True], [True, True, True, True])\n\n\ndef test_label_outer_span():\n    fig = plt.figure()\n    gs = fig.add_gridspec(3, 3)\n    # +---+---+---+\n    # |   1   |   |\n    # +---+---+---+\n    # |   |   | 3 |\n    # + 2 +---+---+\n    # |   | 4 |   |\n    # +---+---+---+\n    a1 = fig.add_subplot(gs[0, 0:2])\n    a2 = fig.add_subplot(gs[1:3, 0])\n    a3 = fig.add_subplot(gs[1, 2])\n    a4 = fig.add_subplot(gs[2, 1])\n    for ax in fig.axes:\n        ax.label_outer()\n    check_ticklabel_visible(\n        fig.axes, [False, True, False, True], [True, True, False, False])\n\n\ndef test_label_outer_non_gridspec():\n    ax = plt.axes((0, 0, 1, 1))\n    ax.label_outer()  # Does nothing.\n    check_ticklabel_visible([ax], [True], [True])\n\n\ndef test_shared_and_moved():\n    # test if sharey is on, but then tick_left is called that labels don't\n    # re-appear.  Seaborn does this just to be sure yaxis is on left...\n    f, (a1, a2) = plt.subplots(1, 2, sharey=True)\n    check_ticklabel_visible([a2], [True], [False])\n    a2.yaxis.tick_left()\n    check_ticklabel_visible([a2], [True], [False"}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "hide_ticklabels(top, bottom, left, right):\n    # Ideally, we would also test offset-text visibility (and remove\n    # test_subplots_offsettext), but currently, setting rcParams fails to move\n    # the offset texts as well.\n    with plt.rc_context({\"xtick.labeltop\": top, \"xtick.labelbottom\": bottom,\n                         \"ytick.labelleft\": left, \"ytick.labelright\": right}):\n        axs = plt.figure().subplots(3, 3, sharex=True, sharey=True)\n    for (i, j), ax in np.ndenumerate(axs):\n        xtop = ax.xaxis._major_tick_kw[\"label2On\"]\n        xbottom = ax.xaxis._major_tick_kw[\"label1On\"]\n        yleft = ax.yaxis._major_tick_kw[\"label1On\"]\n        yright = ax.yaxis._major_tick_kw[\"label2On\"]\n        assert xtop == (top and i == 0)\n        assert xbottom == (bottom and i == 2)\n        assert yleft == (left and j == 0)\n        assert yright == (right and j == 2)\n\n\n@pytest.mark.parametrize(\"xlabel_position\", [\"bottom\", \"top\"])\n@pytest.mark.parametrize(\"ylabel_position\", [\"left\", \"right\"])\ndef test_subplots_hide_axislabels(xlabel_position, ylabel_position):\n    axs = plt.figure().subplots(3, 3, sharex=True, sharey=True)\n    for (i, j), ax in np.ndenumerate(axs):\n        ax.set(xlabel=\"foo\", ylabel=\"bar\")\n        ax.xaxis.set_label_position(xlabel_position)\n        ax.yaxis.set_label_position(ylabel_position)\n        ax.label_outer()\n        assert bool(ax.get_xlabel()) == (\n            xlabel_position == \"bottom\" and i == 2\n            or xlabel_position == \"top\" and i == 0)\n        assert bool(ax.get_ylabel()) == (\n            ylabel_position == \"left\" and j == 0\n            or ylabel_position == \"right\" and j == 2)\n\n\ndef test_get_gridspec():\n    # ahem, pretty trivial, but...\n    fig, ax = plt.subplots()\n    assert ax.get_subplotspec().get_gridspec() == ax.get_gridspec()\n\n\ndef test_dont_mutate_kwargs():\n    subplot_kw = {'sharex': 'all'}\n    gridspec_kw = {'width_ratios': [1, 2]}\n    fig, ax = plt.subplots(1, 2, subplot_kw=subplot_kw,\n                           gridspe"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "is as specified.\"\"\"\n    for i, (ax, vx, vy) in enumerate(zip(axs, x_visible, y_visible)):\n        for l in ax.get_xticklabels() + [ax.xaxis.offsetText]:\n            assert l.get_visible() == vx, \\\n                    f\"Visibility of x axis #{i} is incorrectly {vx}\"\n        for l in ax.get_yticklabels() + [ax.yaxis.offsetText]:\n            assert l.get_visible() == vy, \\\n                    f\"Visibility of y axis #{i} is incorrectly {vy}\"\n        # axis label \"visibility\" is toggled by label_outer by resetting the\n        # label to empty, but it can also be empty to start with.\n        if not vx:\n            assert ax.get_xlabel() == \"\"\n        if not vy:\n            assert ax.get_ylabel() == \"\"\n\n\ndef check_tick1_visible(axs, x_visible, y_visible):\n    \"\"\"\n    Check that the x and y tick visibility is as specified.\n\n    Note: This only checks the tick1line, i.e. bottom / left ticks.\n    \"\"\"\n    for ax, visible, in zip(axs, x_visible):\n        for tick in ax.xaxis.get_major_ticks():\n            assert tick.tick1line.get_visible() == visible\n    for ax, y_visible, in zip(axs, y_visible):\n        for tick in ax.yaxis.get_major_ticks():\n            assert tick.tick1line.get_visible() == visible\n\n\ndef test_shared():\n    rdim = (4, 4, 2)\n    share = {\n            'all': np.ones(rdim[:2], dtype=bool),\n            'none': np.zeros(rdim[:2], dtype=bool),\n            'row': np.array([\n                [False, True, False, False],\n                [True, False, False, False],\n                [False, False, False, True],\n                [False, False, True, False]]),\n            'col': np.array([\n                [False, False, True, False],\n                [False, False, False, True],\n                [True, False, False, False],\n                [False, True, False, False]]),\n            }\n    visible = {\n            'x': {\n                'all': [False, False, True, True],\n                'col': [False, False, True, True],\n                'row': [True] * 4,\n                'none'"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  fig = plt.figure()\n    gs = fig.add_gridspec(3, 3)\n    # +---+---+---+\n    # |   1   |   |\n    # +---+---+---+\n    # |   |   | 3 |\n    # + 2 +---+---+\n    # |   | 4 |   |\n    # +---+---+---+\n    a1 = fig.add_subplot(gs[0, 0:2])\n    a2 = fig.add_subplot(gs[1:3, 0])\n    a3 = fig.add_subplot(gs[1, 2])\n    a4 = fig.add_subplot(gs[2, 1])\n    for ax in fig.axes:\n        ax.label_outer()\n    check_ticklabel_visible(\n        fig.axes, [False, True, False, True], [True, True, False, False])\n\n\ndef test_label_outer_non_gridspec():\n    ax = plt.axes((0, 0, 1, 1))\n    ax.label_outer()  # Does nothing.\n    check_ticklabel_visible([ax], [True], [True])\n\n\ndef test_shared_and_moved():\n    # test if sharey is on, but then tick_left is called that labels don't\n    # re-appear.  Seaborn does this just to be sure yaxis is on left...\n    f, (a1, a2) = plt.subplots(1, 2, sharey=True)\n    check_ticklabel_visible([a2], [True], [False])\n    a2.yaxis.tick_left()\n    check_ticklabel_visible([a2], [True], [False])\n\n    f, (a1, a2) = plt.subplots(2, 1, sharex=True)\n    check_ticklabel_visible([a1], [False], [True])\n    a2.xaxis.tick_bottom()\n    check_ticklabel_visible([a1], [False], [True])\n\n\ndef test_exceptions():\n    # TODO should this test more options?\n    with pytest.raises(ValueError):\n        plt.subplots(2, 2, sharex='blah')\n    with pytest.raises(ValueError):\n        plt.subplots(2, 2, sharey='blah')\n\n\n@image_comparison(['subplots_offset_text.png'],\n                  tol=0 if platform.machine() == 'x86_64' else 0.028)\ndef test_subplots_offsettext():\n    x = np.arange(0, 1e10, 1e9)\n    y = np.arange(0, 100, 10)+1e4\n    fig, axs = plt.subplots(2, 2, sharex='col', sharey='all')\n    axs[0, 0].plot(x, x)\n    axs[1, 0].plot(x, x)\n    axs[0, 1].plot(y, x)\n    axs[1, 1].plot(y, x)\n\n\n@pytest.mark.parametrize(\"top\", [True, False])\n@pytest.mark.parametrize(\"bottom\", [True, False])\n@pytest.mark.parametrize(\"left\", [True, False])\n@pytest.mark.parametrize(\"right\", [True, False])\ndef test_subplots_"}, {"start_line": 295000, "end_line": 297000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ick in axis.get_major_ticks():\n            assert tick.label1.get_size() == axis._get_tick_label_size(name)\n\n\ndef test_multiplot_autoscale():\n    fig = plt.figure()\n    ax1, ax2 = fig.subplots(2, 1, sharex='all')\n    ax1.plot([18000, 18250, 18500, 18750], [2, 3, 2, 3])\n    ax2.axhspan(-5, 5)\n    xlim = ax1.get_xlim()\n    assert np.allclose(xlim, [18000, 18800])\n\n\ndef test_sharing_does_not_link_positions():\n    fig = plt.figure()\n    ax0 = fig.add_subplot(221)\n    ax1 = fig.add_axes((.6, .6, .3, .3), sharex=ax0)\n    init_pos = ax1.get_position()\n    fig.subplots_adjust(left=0)\n    assert (ax1.get_position().get_points() == init_pos.get_points()).all()\n\n\n@check_figures_equal(extensions=[\"pdf\"])\ndef test_2dcolor_plot(fig_test, fig_ref):\n    color = np.array([0.1, 0.2, 0.3])\n    # plot with 1D-color:\n    axs = fig_test.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape(-1))\n    with pytest.warns(match=\"argument looks like a single numeric RGB\"):\n        axs[1].scatter([1, 2], [1, 2], c=color.reshape(-1))\n    axs[2].step([1, 2], [1, 2], c=color.reshape(-1))\n    axs[3].hist(np.arange(10), color=color.reshape(-1))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape(-1))\n    # plot with 2D-color:\n    axs = fig_ref.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[1].scatter([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[2].step([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n\n\n@check_figures_equal()\ndef test_shared_axes_clear(fig_test, fig_ref):\n    x = np.arange(0.0, 2*np.pi, 0.01)\n    y = np.sin(x)\n\n    axs = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.plot(x, y)\n\n    axs = fig_test.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.clear()\n        ax.plot(x, y)\n\n\ndef test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_subplots.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": [True] * 4,\n                False: [True] * 4,\n                True: [False, False, True, True],\n                },\n            'y': {\n                'all': [True, False, True, False],\n                'col': [True] * 4,\n                'row': [True, False, True, False],\n                'none': [True] * 4,\n                False: [True] * 4,\n                True: [True, False, True, False],\n                },\n            }\n    share[False] = share['none']\n    share[True] = share['all']\n\n    # test default\n    f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2)\n    axs = [a1, a2, a3, a4]\n    check_shared(axs, share['none'], share['none'])\n    plt.close(f)\n\n    # test all option combinations\n    ops = [False, True, 'all', 'none', 'row', 'col', 0, 1]\n    for xo in ops:\n        for yo in ops:\n            f, ((a1, a2), (a3, a4)) = plt.subplots(2, 2, sharex=xo, sharey=yo)\n            axs = [a1, a2, a3, a4]\n            check_shared(axs, share[xo], share[yo])\n            check_ticklabel_visible(axs, visible['x'][xo], visible['y'][yo])\n            plt.close(f)\n\n\n@pytest.mark.parametrize('remove_ticks', [True, False])\n@pytest.mark.parametrize('layout_engine', ['none', 'tight', 'constrained'])\n@pytest.mark.parametrize('with_colorbar', [True, False])\ndef test_label_outer(remove_ticks, layout_engine, with_colorbar):\n    fig = plt.figure(layout=layout_engine)\n    axs = fig.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.set(xlabel=\"foo\", ylabel=\"bar\")\n        if with_colorbar:\n            fig.colorbar(mpl.cm.ScalarMappable(), ax=ax)\n        ax.label_outer(remove_inner_ticks=remove_ticks)\n    check_ticklabel_visible(\n        axs.flat, [False, False, True, True], [True, False, True, False])\n    if remove_ticks:\n        check_tick1_visible(\n            axs.flat, [False, False, True, True], [True, False, True, False])\n    else:\n        check_tick1_visible(\n            axs.flat, [True, True, True, True], [True, True, True, True])\n\n\ndef test_label_outer_span():\n  "}, {"start_line": 296000, "end_line": 298000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2], c=color.reshape(-1))\n    axs[2].step([1, 2], [1, 2], c=color.reshape(-1))\n    axs[3].hist(np.arange(10), color=color.reshape(-1))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape(-1))\n    # plot with 2D-color:\n    axs = fig_ref.subplots(5)\n    axs[0].plot([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[1].scatter([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[2].step([1, 2], [1, 2], c=color.reshape((1, -1)))\n    axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n    axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n\n\n@check_figures_equal()\ndef test_shared_axes_clear(fig_test, fig_ref):\n    x = np.arange(0.0, 2*np.pi, 0.01)\n    y = np.sin(x)\n\n    axs = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.plot(x, y)\n\n    axs = fig_test.subplots(2, 2, sharex=True, sharey=True)\n    for ax in axs.flat:\n        ax.clear()\n        ax.plot(x, y)\n\n\ndef test_shared_axes_retick():\n    fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n\n    for ax in axs.flat:\n        ax.plot([0, 2], 'o-')\n\n    axs[0, 0].set_xticks([-0.5, 0, 1, 1.5])  # should affect all axes xlims\n    for ax in axs.flat:\n        assert ax.get_xlim() == axs[0, 0].get_xlim()\n\n    axs[0, 0].set_yticks([-0.5, 0, 2, 2.5])  # should affect all axes ylims\n    for ax in axs.flat:\n        assert ax.get_ylim() == axs[0, 0].get_ylim()\n\n\n@pytest.mark.parametrize('ha', ['left', 'center', 'right'])\ndef test_ylabel_ha_with_position(ha):\n    fig = Figure()\n    ax = fig.subplots()\n    ax.set_ylabel(\"test\", y=1, ha=ha)\n    ax.yaxis.set_label_position(\"right\")\n    assert ax.yaxis.label.get_ha() == ha\n\n\ndef test_bar_label_location_vertical():\n    ax = plt.gca()\n    xs, heights = [1, 2], [3, -4]\n    rects = ax.bar(xs, heights)\n    labels = ax.bar_label(rects)\n    assert labels[0].xy == (xs[0], heights[0])\n    assert labels[0].get_horizontalalignment() == 'center'\n    assert labels[0].get_verticalalignment() == 'bottom'\n    assert labels[1].xy"}, {"start_line": 297000, "end_line": 299000, "belongs_to": {"file_name": "test_axes.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "sharex='all', sharey='all')\n\n    for ax in axs.flat:\n        ax.plot([0, 2], 'o-')\n\n    axs[0, 0].set_xticks([-0.5, 0, 1, 1.5])  # should affect all axes xlims\n    for ax in axs.flat:\n        assert ax.get_xlim() == axs[0, 0].get_xlim()\n\n    axs[0, 0].set_yticks([-0.5, 0, 2, 2.5])  # should affect all axes ylims\n    for ax in axs.flat:\n        assert ax.get_ylim() == axs[0, 0].get_ylim()\n\n\n@pytest.mark.parametrize('ha', ['left', 'center', 'right'])\ndef test_ylabel_ha_with_position(ha):\n    fig = Figure()\n    ax = fig.subplots()\n    ax.set_ylabel(\"test\", y=1, ha=ha)\n    ax.yaxis.set_label_position(\"right\")\n    assert ax.yaxis.label.get_ha() == ha\n\n\ndef test_bar_label_location_vertical():\n    ax = plt.gca()\n    xs, heights = [1, 2], [3, -4]\n    rects = ax.bar(xs, heights)\n    labels = ax.bar_label(rects)\n    assert labels[0].xy == (xs[0], heights[0])\n    assert labels[0].get_horizontalalignment() == 'center'\n    assert labels[0].get_verticalalignment() == 'bottom'\n    assert labels[1].xy == (xs[1], heights[1])\n    assert labels[1].get_horizontalalignment() == 'center'\n    assert labels[1].get_verticalalignment() == 'top'\n\n\ndef test_bar_label_location_vertical_yinverted():\n    ax = plt.gca()\n    ax.invert_yaxis()\n    xs, heights = [1, 2], [3, -4]\n    rects = ax.bar(xs, heights)\n    labels = ax.bar_label(rects)\n    assert labels[0].xy == (xs[0], heights[0])\n    assert labels[0].get_horizontalalignment() == 'center'\n    assert labels[0].get_verticalalignment() == 'top'\n    assert labels[1].xy == (xs[1], heights[1])\n    assert labels[1].get_horizontalalignment() == 'center'\n    assert labels[1].get_verticalalignment() == 'bottom'\n\n\ndef test_bar_label_location_horizontal():\n    ax = plt.gca()\n    ys, widths = [1, 2], [3, -4]\n    rects = ax.barh(ys, widths)\n    labels = ax.bar_label(rects)\n    assert labels[0].xy == (widths[0], ys[0])\n    assert labels[0].get_horizontalalignment() == 'left'\n    assert labels[0].get_verticalalignment() == 'center'\n    assert labels[1].xy == "}], "retrieved_count": 10, "cost_time": 1.1552417278289795}
{"question": "Why does the test_tricontourf_path function validate that the path generation algorithm correctly handles the topological distinction between simple polygons, boundary-following polygons, and polygons with holes, and what would be the consequences of the path code sequence [1, 2, 2, 2, 79] being incorrectly implemented in the underlying tricontourf rendering system?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 53000, "end_line": 55000, "belongs_to": {"file_name": "test_triangulation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2])\n    assert_array_almost_equal(\n        paths[0].to_polygons(closed_only=False), [expected_vertices])\n\n    # Closed line loop inside domain\n    cs = ax.tricontour(triang, [0, 0, 0, 0, 1], levels=[0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n\ndef test_tricontourf_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Polygon inside domain\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[0.5, 1.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon following boundary and inside domain\n    cs = ax.tricontourf(triang, [1, 0, 0, 0, 0], levels=[0.5, 1.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2], [0, 0], [2, 0]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon is outer boundary with hole\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[-0.5, 0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[0, 0], [4, 0], [4, 4], [0, 4], [0, 0],\n                       "}, {"start_line": 54000, "end_line": 55271, "belongs_to": {"file_name": "test_triangulation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon following boundary and inside domain\n    cs = ax.tricontourf(triang, [1, 0, 0, 0, 0], levels=[0.5, 1.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2], [0, 0], [2, 0]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n    # Polygon is outer boundary with hole\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[-0.5, 0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[0, 0], [4, 0], [4, 4], [0, 4], [0, 0],\n                         [1, 1], [1, 3], [3, 3], [3, 1], [1, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79, 1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), np.split(expected_vertices, [5]))\n"}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "test_triangulation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", z)\n    tcs2 = ax.tricontour(x, y, z)\n    assert tcs2._contour_generator != tcs1._contour_generator\n    tcs3 = ax.tricontour(tcs1, z)\n    assert tcs3._contour_generator == tcs1._contour_generator\n\n\n@check_figures_equal()\ndef test_triplot_with_ls(fig_test, fig_ref):\n    x = [0, 2, 1]\n    y = [0, 0, 1]\n    data = [[0, 1, 2]]\n    fig_test.subplots().triplot(x, y, data, ls='--')\n    fig_ref.subplots().triplot(x, y, data, linestyle='--')\n\n\ndef test_triplot_label():\n    x = [0, 2, 1]\n    y = [0, 0, 1]\n    data = [[0, 1, 2]]\n    fig, ax = plt.subplots()\n    lines, markers = ax.triplot(x, y, data, label='label')\n    handles, labels = ax.get_legend_handles_labels()\n    assert labels == ['label']\n    assert len(handles) == 1\n    assert handles[0] is lines\n\n\ndef test_tricontour_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Line strip from boundary to boundary\n    cs = ax.tricontour(triang, [1, 0, 0, 0, 0], levels=[0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[2, 0], [1, 1], [0, 2]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2])\n    assert_array_almost_equal(\n        paths[0].to_polygons(closed_only=False), [expected_vertices])\n\n    # Closed line loop inside domain\n    cs = ax.tricontour(triang, [0, 0, 0, 0, 1], levels=[0.5])\n    paths = cs.get_paths()\n    assert len(paths) == 1\n    expected_vertices = [[3, 1], [3, 3], [1, 3], [1, 1], [3, 1]]\n    assert_array_almost_equal(paths[0].vertices, expected_vertices)\n    assert_array_equal(paths[0].codes, [1, 2, 2, 2, 79])\n    assert_array_almost_equal(paths[0].to_polygons(), [expected_vertices])\n\n\ndef test_tricontourf_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Polygon inside domain\n    cs = ax.tricontourf(triang, [0, 0, 0, 0, 1], levels=[0.5, 1.5])\n    paths = "}, {"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "test_triangulation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " y = np.array([33.99, 34.01, 34.19, 34.18])\n    triang1 = mtri.Triangulation(x, y, triangles1)\n    triang2 = mtri.Triangulation(x, y, triangles2)\n\n    refiner1 = mtri.UniformTriRefiner(triang1)\n    refiner2 = mtri.UniformTriRefiner(triang2)\n\n    fine_triang1 = refiner1.refine_triangulation(subdiv=1)\n    fine_triang2 = refiner2.refine_triangulation(subdiv=1)\n\n    assert_array_equal(fine_triang1.triangles, fine_triang2.triangles)\n\n\ndef test_qhull_triangle_orientation():\n    # github issue 4437.\n    xi = np.linspace(-2, 2, 100)\n    x, y = map(np.ravel, np.meshgrid(xi, xi))\n    w = (x > y - 1) & (x < -1.95) & (y > -1.2)\n    x, y = x[w], y[w]\n    theta = np.radians(25)\n    x1 = x*np.cos(theta) - y*np.sin(theta)\n    y1 = x*np.sin(theta) + y*np.cos(theta)\n\n    # Calculate Delaunay triangulation using Qhull.\n    triang = mtri.Triangulation(x1, y1)\n\n    # Neighbors returned by Qhull.\n    qhull_neighbors = triang.neighbors\n\n    # Obtain neighbors using own C++ calculation.\n    triang._neighbors = None\n    own_neighbors = triang.neighbors\n\n    assert_array_equal(qhull_neighbors, own_neighbors)\n\n\ndef test_trianalyzer_mismatched_indices():\n    # github issue 4999.\n    x = np.array([0., 1., 0.5, 0., 2.])\n    y = np.array([0., 0., 0.5*np.sqrt(3.), -1., 1.])\n    triangles = np.array([[0, 1, 2], [0, 1, 3], [1, 2, 4]], dtype=np.int32)\n    mask = np.array([False, False, True], dtype=bool)\n    triang = mtri.Triangulation(x, y, triangles, mask=mask)\n    analyser = mtri.TriAnalyzer(triang)\n    # numpy >= 1.10 raises a VisibleDeprecationWarning in the following line\n    # prior to the fix.\n    analyser._get_compressed_triangulation()\n\n\ndef test_tricontourf_decreasing_levels():\n    # github issue 5477.\n    x = [0.0, 1.0, 1.0]\n    y = [0.0, 0.0, 1.0]\n    z = [0.2, 0.4, 0.6]\n    plt.figure()\n    with pytest.raises(ValueError):\n        plt.tricontourf(x, y, z, [1.0, 0.0])\n\n\ndef test_internal_cpp_api() -> None:\n    # Following github issue 8197.\n    from matplotlib import _tri  # noqa: F401, e"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_path.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import platform\nimport re\n\nimport numpy as np\n\nfrom numpy.testing import assert_array_equal\nimport pytest\n\nfrom matplotlib import patches\nfrom matplotlib.path import Path\nfrom matplotlib.patches import Polygon\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nfrom matplotlib import transforms\nfrom matplotlib.backend_bases import MouseEvent\n\n\ndef test_empty_closed_path():\n    path = Path(np.zeros((0, 2)), closed=True)\n    assert path.vertices.shape == (0, 2)\n    assert path.codes is None\n    assert_array_equal(path.get_extents().extents,\n                       transforms.Bbox.null().extents)\n\n\ndef test_readonly_path():\n    path = Path.unit_circle()\n\n    def modify_vertices():\n        path.vertices = path.vertices * 2.0\n\n    with pytest.raises(AttributeError):\n        modify_vertices()\n\n\ndef test_path_exceptions():\n    bad_verts1 = np.arange(12).reshape(4, 3)\n    with pytest.raises(ValueError,\n                       match=re.escape(f'has shape {bad_verts1.shape}')):\n        Path(bad_verts1)\n\n    bad_verts2 = np.arange(12).reshape(2, 3, 2)\n    with pytest.raises(ValueError,\n                       match=re.escape(f'has shape {bad_verts2.shape}')):\n        Path(bad_verts2)\n\n    good_verts = np.arange(12).reshape(6, 2)\n    bad_codes = np.arange(2)\n    msg = re.escape(f\"Your vertices have shape {good_verts.shape} \"\n                    f\"but your codes have shape {bad_codes.shape}\")\n    with pytest.raises(ValueError, match=msg):\n        Path(good_verts, bad_codes)\n\n\ndef test_point_in_path():\n    # Test #1787\n    path = Path._create_closed([(0, 0), (0, 1), (1, 1), (1, 0)])\n    points = [(0.5, 0.5), (1.5, 0.5)]\n    ret = path.contains_points(points)\n    assert ret.dtype == 'bool'\n    np.testing.assert_equal(ret, [True, False])\n\n\n@pytest.mark.parametrize(\n    \"other_path, inside, inverted_inside\",\n    [(Path([(0.25, 0.25), (0.25, 0.75), (0.75, 0.75), (0.75, 0.25), (0.25, 0.25)],\n           closed=True), True, False),\n     (Path([(-0.25,"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_path.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d_verts1.shape}')):\n        Path(bad_verts1)\n\n    bad_verts2 = np.arange(12).reshape(2, 3, 2)\n    with pytest.raises(ValueError,\n                       match=re.escape(f'has shape {bad_verts2.shape}')):\n        Path(bad_verts2)\n\n    good_verts = np.arange(12).reshape(6, 2)\n    bad_codes = np.arange(2)\n    msg = re.escape(f\"Your vertices have shape {good_verts.shape} \"\n                    f\"but your codes have shape {bad_codes.shape}\")\n    with pytest.raises(ValueError, match=msg):\n        Path(good_verts, bad_codes)\n\n\ndef test_point_in_path():\n    # Test #1787\n    path = Path._create_closed([(0, 0), (0, 1), (1, 1), (1, 0)])\n    points = [(0.5, 0.5), (1.5, 0.5)]\n    ret = path.contains_points(points)\n    assert ret.dtype == 'bool'\n    np.testing.assert_equal(ret, [True, False])\n\n\n@pytest.mark.parametrize(\n    \"other_path, inside, inverted_inside\",\n    [(Path([(0.25, 0.25), (0.25, 0.75), (0.75, 0.75), (0.75, 0.25), (0.25, 0.25)],\n           closed=True), True, False),\n     (Path([(-0.25, -0.25), (-0.25, 1.75), (1.75, 1.75), (1.75, -0.25), (-0.25, -0.25)],\n           closed=True), False, True),\n     (Path([(-0.25, -0.25), (-0.25, 1.75), (0.5, 0.5),\n            (1.75, 1.75), (1.75, -0.25), (-0.25, -0.25)],\n           closed=True), False, False),\n     (Path([(0.25, 0.25), (0.25, 1.25), (1.25, 1.25), (1.25, 0.25), (0.25, 0.25)],\n           closed=True), False, False),\n     (Path([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)], closed=True), False, False),\n     (Path([(2, 2), (2, 3), (3, 3), (3, 2), (2, 2)], closed=True), False, False)])\ndef test_contains_path(other_path, inside, inverted_inside):\n    path = Path([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)], closed=True)\n    assert path.contains_path(other_path) is inside\n    assert other_path.contains_path(path) is inverted_inside\n\n\ndef test_contains_points_negative_radius():\n    path = Path.unit_circle()\n\n    points = [(0.0, 0.0), (1.25, 0.0), (0.9, 0.9)]\n    result = path.contains_points(points, radius=-0.5)\n    np.testing.assert_"}, {"start_line": 30000, "end_line": 31390, "belongs_to": {"file_name": "test_contour.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".ma.array(z, mask=m)).levels.tolist() == [0, .5, 1]\n    z = z.ravel()\n    assert plt.tricontour(x, y, z.tolist()).levels.tolist() == [.5]\n    assert plt.tricontour(x, y, z).levels.tolist() == [.5]\n    assert plt.tricontourf(x, y, z.tolist()).levels.tolist() == [0, .5, 1]\n    assert plt.tricontourf(x, y, z).levels.tolist() == [0, .5, 1]\n\n\ndef test_all_nan():\n    x = np.array([[np.nan, np.nan], [np.nan, np.nan]])\n    assert_array_almost_equal(plt.contour(x).levels,\n                              [-1e-13, -7.5e-14, -5e-14, -2.4e-14, 0.0,\n                                2.4e-14, 5e-14, 7.5e-14, 1e-13])\n\n\ndef test_allsegs_allkinds():\n    x, y = np.meshgrid(np.arange(0, 10, 2), np.arange(0, 10, 2))\n    z = np.sin(x) * np.cos(y)\n\n    cs = plt.contour(x, y, z, levels=[0, 0.5])\n\n    # Expect two levels, the first with 5 segments and the second with 4.\n    for result in [cs.allsegs, cs.allkinds]:\n        assert len(result) == 2\n        assert len(result[0]) == 5\n        assert len(result[1]) == 4\n\n\n@image_comparison(baseline_images=['contour_rasterization'],\n                  extensions=['pdf'], style='mpl20', savefig_kwarg={'dpi': 25})\ndef test_contourf_rasterize():\n    fig, ax = plt.subplots()\n    data = [[0, 1], [1, 0]]\n    circle = mpatches.Circle([0.5, 0.5], 0.5, transform=ax.transAxes)\n    cs = ax.contourf(data, clip_path=circle, rasterized=True)\n    assert cs._rasterized\n"}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "test_triangulation.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ourf(triang, [0, 1, 2, np.inf])\n\n    with pytest.raises(ValueError, match='z array must not contain non-finite '\n                                         'values within the triangulation'):\n        plt.tricontourf(triang, [0, 1, 2, -np.inf])\n\n    with pytest.raises(ValueError, match='z array must not contain non-finite '\n                                         'values within the triangulation'):\n        plt.tricontourf(triang, [0, 1, 2, np.nan])\n\n    with pytest.raises(ValueError, match='z must not contain masked points '\n                                         'within the triangulation'):\n        plt.tricontourf(triang, np.ma.array([0, 1, 2, 3], mask=[1, 0, 0, 0]))\n\n\ndef test_tricontourset_reuse():\n    # If TriContourSet returned from one tricontour(f) call is passed as first\n    # argument to another the underlying C++ contour generator will be reused.\n    x = [0.0, 0.5, 1.0]\n    y = [0.0, 1.0, 0.0]\n    z = [1.0, 2.0, 3.0]\n    fig, ax = plt.subplots()\n    tcs1 = ax.tricontourf(x, y, z)\n    tcs2 = ax.tricontour(x, y, z)\n    assert tcs2._contour_generator != tcs1._contour_generator\n    tcs3 = ax.tricontour(tcs1, z)\n    assert tcs3._contour_generator == tcs1._contour_generator\n\n\n@check_figures_equal()\ndef test_triplot_with_ls(fig_test, fig_ref):\n    x = [0, 2, 1]\n    y = [0, 0, 1]\n    data = [[0, 1, 2]]\n    fig_test.subplots().triplot(x, y, data, ls='--')\n    fig_ref.subplots().triplot(x, y, data, linestyle='--')\n\n\ndef test_triplot_label():\n    x = [0, 2, 1]\n    y = [0, 0, 1]\n    data = [[0, 1, 2]]\n    fig, ax = plt.subplots()\n    lines, markers = ax.triplot(x, y, data, label='label')\n    handles, labels = ax.get_legend_handles_labels()\n    assert labels == ['label']\n    assert len(handles) == 1\n    assert handles[0] is lines\n\n\ndef test_tricontour_path():\n    x = [0, 4, 4, 0, 2]\n    y = [0, 0, 4, 4, 2]\n    triang = mtri.Triangulation(x, y)\n    _, ax = plt.subplots()\n\n    # Line strip from boundary to boundary\n    cs = ax.tricontour(triang, [1, 0, 0, 0, 0], levels=["}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "test_path.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "path.vertices, axis=0)\n    maxs = np.max(path.vertices, axis=0)\n    np.testing.assert_allclose(mins, -1)\n    np.testing.assert_allclose(maxs, 1)\n\n\ndef test_disjoint_zero_length_segment():\n    this_path = Path(\n        np.array([\n            [824.85064295, 2056.26489203],\n            [861.69033931, 2041.00539016],\n            [868.57864109, 2057.63522175],\n            [831.73894473, 2072.89472361],\n            [824.85064295, 2056.26489203]]),\n        np.array([1, 2, 2, 2, 79], dtype=Path.code_type))\n\n    outline_path = Path(\n        np.array([\n            [859.91051028, 2165.38461538],\n            [859.06772495, 2149.30331334],\n            [859.06772495, 2181.46591743],\n            [859.91051028, 2165.38461538],\n            [859.91051028, 2165.38461538]]),\n        np.array([1, 2, 2, 2, 2],\n                 dtype=Path.code_type))\n\n    assert not outline_path.intersects_path(this_path)\n    assert not this_path.intersects_path(outline_path)\n\n\ndef test_intersect_zero_length_segment():\n    this_path = Path(\n        np.array([\n            [0, 0],\n            [1, 1],\n        ]))\n\n    outline_path = Path(\n        np.array([\n            [1, 0],\n            [.5, .5],\n            [.5, .5],\n            [0, 1],\n        ]))\n\n    assert outline_path.intersects_path(this_path)\n    assert this_path.intersects_path(outline_path)\n\n\ndef test_cleanup_closepoly():\n    # if the first connected component of a Path ends in a CLOSEPOLY, but that\n    # component contains a NaN, then Path.cleaned should ignore not just the\n    # control points but also the CLOSEPOLY, since it has nowhere valid to\n    # point.\n    paths = [\n        Path([[np.nan, np.nan], [np.nan, np.nan]],\n             [Path.MOVETO, Path.CLOSEPOLY]),\n        # we trigger a different path in the C++ code if we don't pass any\n        # codes explicitly, so we must also make sure that this works\n        Path([[np.nan, np.nan], [np.nan, np.nan]]),\n        # we should also make sure that this cleanup works if there's some\n        # "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_path.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "his_path = Path(\n        np.array([\n            [0, 0],\n            [1, 1],\n        ]))\n\n    outline_path = Path(\n        np.array([\n            [1, 0],\n            [.5, .5],\n            [.5, .5],\n            [0, 1],\n        ]))\n\n    assert outline_path.intersects_path(this_path)\n    assert this_path.intersects_path(outline_path)\n\n\ndef test_cleanup_closepoly():\n    # if the first connected component of a Path ends in a CLOSEPOLY, but that\n    # component contains a NaN, then Path.cleaned should ignore not just the\n    # control points but also the CLOSEPOLY, since it has nowhere valid to\n    # point.\n    paths = [\n        Path([[np.nan, np.nan], [np.nan, np.nan]],\n             [Path.MOVETO, Path.CLOSEPOLY]),\n        # we trigger a different path in the C++ code if we don't pass any\n        # codes explicitly, so we must also make sure that this works\n        Path([[np.nan, np.nan], [np.nan, np.nan]]),\n        # we should also make sure that this cleanup works if there's some\n        # multi-vertex curves\n        Path([[np.nan, np.nan], [np.nan, np.nan], [np.nan, np.nan],\n              [np.nan, np.nan]],\n             [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY])\n    ]\n    for p in paths:\n        cleaned = p.cleaned(remove_nans=True)\n        assert len(cleaned) == 1\n        assert cleaned.codes[0] == Path.STOP\n\n\ndef test_interpolated_moveto():\n    # Initial path has two subpaths with two LINETOs each\n    vertices = np.array([[0, 0],\n                         [0, 1],\n                         [1, 2],\n                         [4, 4],\n                         [4, 5],\n                         [5, 5]])\n    codes = [Path.MOVETO, Path.LINETO, Path.LINETO] * 2\n\n    path = Path(vertices, codes)\n    result = path.interpolated(3)\n\n    # Result should have two subpaths with six LINETOs each\n    expected_subpath_codes = [Path.MOVETO] + [Path.LINETO] * 6\n    np.testing.assert_array_equal(result.codes, expected_subpath_codes * 2)\n\n\ndef test_interpolated_closepoly():\n    cod"}], "retrieved_count": 10, "cost_time": 1.090789556503296}
{"question": "Where does the FontInfo NamedTuple propagate font metrics and glyph data through the mathematical text rendering pipeline, and what control flow determines whether the postscript_name or the FT2Font object is used at different stages of character rendering?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e):\n            cached_font = get_font(basename)\n            self._fonts[basename] = cached_font\n            self._fonts[cached_font.postscript_name] = cached_font\n            self._fonts[cached_font.postscript_name.lower()] = cached_font\n        return T.cast(FT2Font, cached_font)  # FIXME: Not sure this is guaranteed.\n\n    def _get_offset(self, font: FT2Font, glyph: Glyph, fontsize: float,\n                    dpi: float) -> float:\n        if font.postscript_name == 'Cmex10':\n            return (glyph.height / 64 / 2) + (fontsize/3 * dpi/72)\n        return 0.\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        raise NotImplementedError\n\n    # The return value of _get_info is cached per-instance.\n    def _get_info(self, fontname: str, font_class: str, sym: str, fontsize: float,\n                  dpi: float) -> FontInfo:\n        font, num, slanted = self._get_glyph(fontname, font_class, sym)\n        font.set_size(fontsize, dpi)\n        glyph = font.load_char(num, flags=self.load_glyph_flags)\n\n        xmin, ymin, xmax, ymax = (val / 64 for val in glyph.bbox)\n        offset = self._get_offset(font, glyph, fontsize, dpi)\n        metrics = FontMetrics(\n            advance=glyph.linearHoriAdvance / 65536,\n            height=glyph.height / 64,\n            width=glyph.width / 64,\n            xmin=xmin,\n            xmax=xmax,\n            ymin=ymin + offset,\n            ymax=ymax + offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg=glyph.horiBearingY / 64 + offset,\n            slanted=slanted\n        )\n\n        return FontInfo(\n            font=font,\n            fontsize=fontsize,\n            postscript_name=font.postscript_name,\n            metrics=metrics,\n            num=num,\n            glyph=glyph,\n            offset=offset\n        )\n\n    def get_xheight(self, fontname: str, fontsize: float, dpi: float) -> float:\n        font = self._get_font(fontname)\n        font"}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ontsize, dpi)\n        glyph = font.load_char(num, flags=self.load_glyph_flags)\n\n        xmin, ymin, xmax, ymax = (val / 64 for val in glyph.bbox)\n        offset = self._get_offset(font, glyph, fontsize, dpi)\n        metrics = FontMetrics(\n            advance=glyph.linearHoriAdvance / 65536,\n            height=glyph.height / 64,\n            width=glyph.width / 64,\n            xmin=xmin,\n            xmax=xmax,\n            ymin=ymin + offset,\n            ymax=ymax + offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg=glyph.horiBearingY / 64 + offset,\n            slanted=slanted\n        )\n\n        return FontInfo(\n            font=font,\n            fontsize=fontsize,\n            postscript_name=font.postscript_name,\n            metrics=metrics,\n            num=num,\n            glyph=glyph,\n            offset=offset\n        )\n\n    def get_xheight(self, fontname: str, fontsize: float, dpi: float) -> float:\n        font = self._get_font(fontname)\n        font.set_size(fontsize, dpi)\n        pclt = font.get_sfnt_table('pclt')\n        if pclt is None:\n            # Some fonts don't store the xHeight, so we do a poor man's xHeight\n            metrics = self.get_metrics(\n                fontname, mpl.rcParams['mathtext.default'], 'x', fontsize, dpi)\n            return metrics.iceberg\n        x_height = (pclt['xHeight'] / 64) * (fontsize / 12) * (dpi / 100)\n        return x_height\n\n    def get_underline_thickness(self, font: str, fontsize: float, dpi: float) -> float:\n        # This function used to grab underline thickness from the font\n        # metrics, but that information is just too un-reliable, so it\n        # is now hardcoded.\n        return ((0.75 / 12) * fontsize * dpi) / 72\n\n    def get_kern(self, font1: str, fontclass1: str, sym1: str, fontsize1: float,\n                 font2: str, fontclass2: str, sym2: str, fontsize2: float,\n                 dpi: float) -> float:\n        if font1 == font2 and fontsize1 == fontsize2:\n            in"}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "FT2Font).\n    \"\"\"\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        super().__init__(default_font_prop, load_glyph_flags)\n        # Per-instance cache.\n        self._get_info = functools.cache(self._get_info)  # type: ignore[method-assign]\n        self._fonts = {}\n        self.fontmap: dict[str | int, str] = {}\n\n        filename = findfont(self.default_font_prop)\n        default_font = get_font(filename)\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font\n\n    def _get_font(self, font: str | int) -> FT2Font:\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            # NOTE: An int is only passed by subclasses which have placed int keys into\n            # `self.fontmap`, so we must cast this to confirm it to typing.\n            basename = T.cast(str, font)\n        cached_font = self._fonts.get(basename)\n        if cached_font is None and os.path.exists(basename):\n            cached_font = get_font(basename)\n            self._fonts[basename] = cached_font\n            self._fonts[cached_font.postscript_name] = cached_font\n            self._fonts[cached_font.postscript_name.lower()] = cached_font\n        return T.cast(FT2Font, cached_font)  # FIXME: Not sure this is guaranteed.\n\n    def _get_offset(self, font: FT2Font, glyph: Glyph, fontsize: float,\n                    dpi: float) -> float:\n        if font.postscript_name == 'Cmex10':\n            return (glyph.height / 64 / 2) + (fontsize/3 * dpi/72)\n        return 0.\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        raise NotImplementedError\n\n    # The return value of _get_info is cached per-instance.\n    def _get_info(self, fontname: str, font_class: str, sym: str, fontsize: float,\n                  dpi: float) -> FontInfo:\n        font, num, slanted = self._get_glyph(fontname, font_class, sym)\n        font.set_size(f"}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " shifted = ship(self.box, (-xmin, -ymin))\n\n        for ox, oy, info in shifted.glyphs:\n            info.font.draw_glyph_to_bitmap(\n                image, int(ox), int(oy - info.metrics.iceberg), info.glyph,\n                antialiased=antialiased)\n        for x1, y1, x2, y2 in shifted.rects:\n            height = max(int(y2 - y1) - 1, 0)\n            if height == 0:\n                center = (y2 + y1) / 2\n                y = int(center - (height + 1) / 2)\n            else:\n                y = int(y1)\n            x1 = math.floor(x1)\n            x2 = math.ceil(x2)\n            image[y:y+height+1, x1:x2+1] = 0xff\n        return RasterParse(0, 0, w, h + d, d, image)\n\n\nclass FontMetrics(NamedTuple):\n    \"\"\"\n    Metrics of a font.\n\n    Attributes\n    ----------\n    advance : float\n        The advance distance (in points) of the glyph.\n    height : float\n        The height of the glyph in points.\n    width : float\n        The width of the glyph in points.\n    xmin, xmax, ymin, ymax : float\n        The ink rectangle of the glyph.\n    iceberg : float\n        The distance from the baseline to the top of the glyph. (This corresponds to\n        TeX's definition of \"height\".)\n    slanted : bool\n        Whether the glyph should be considered as \"slanted\" (currently used for kerning\n        sub/superscripts).\n    \"\"\"\n    advance: float\n    height: float\n    width: float\n    xmin: float\n    xmax: float\n    ymin: float\n    ymax: float\n    iceberg: float\n    slanted: bool\n\n\nclass FontInfo(NamedTuple):\n    font: FT2Font\n    fontsize: float\n    postscript_name: str\n    metrics: FontMetrics\n    num: int\n    glyph: Glyph\n    offset: float\n\n\nclass Fonts(abc.ABC):\n    \"\"\"\n    An abstract base class for a system of fonts to use for mathtext.\n\n    The class must be able to take symbol keys and font file names and\n    return the character metrics.  It also delegates to a backend class\n    to do the actual drawing.\n    \"\"\"\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "  The ink rectangle of the glyph.\n    iceberg : float\n        The distance from the baseline to the top of the glyph. (This corresponds to\n        TeX's definition of \"height\".)\n    slanted : bool\n        Whether the glyph should be considered as \"slanted\" (currently used for kerning\n        sub/superscripts).\n    \"\"\"\n    advance: float\n    height: float\n    width: float\n    xmin: float\n    xmax: float\n    ymin: float\n    ymax: float\n    iceberg: float\n    slanted: bool\n\n\nclass FontInfo(NamedTuple):\n    font: FT2Font\n    fontsize: float\n    postscript_name: str\n    metrics: FontMetrics\n    num: int\n    glyph: Glyph\n    offset: float\n\n\nclass Fonts(abc.ABC):\n    \"\"\"\n    An abstract base class for a system of fonts to use for mathtext.\n\n    The class must be able to take symbol keys and font file names and\n    return the character metrics.  It also delegates to a backend class\n    to do the actual drawing.\n    \"\"\"\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        \"\"\"\n        Parameters\n        ----------\n        default_font_prop : `~.font_manager.FontProperties`\n            The default non-math font, or the base font for Unicode (generic)\n            font rendering.\n        load_glyph_flags : `.ft2font.LoadFlags`\n            Flags passed to the glyph loader (e.g. ``FT_Load_Glyph`` and\n            ``FT_Load_Char`` for FreeType-based fonts).\n        \"\"\"\n        self.default_font_prop = default_font_prop\n        self.load_glyph_flags = load_glyph_flags\n\n    def get_kern(self, font1: str, fontclass1: str, sym1: str, fontsize1: float,\n                 font2: str, fontclass2: str, sym2: str, fontsize2: float,\n                 dpi: float) -> float:\n        \"\"\"\n        Get the kerning distance for font between *sym1* and *sym2*.\n\n        See `~.Fonts.get_metrics` for a detailed description of the parameters.\n        \"\"\"\n        return 0.\n\n    def _get_font(self, font: str) -> FT2Font:\n        raise NotImplementedError\n\n    def _g"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   2: 'STIXSizeTwoSym',\n                 3: 'STIXSizeThreeSym',\n                 4: 'STIXSizeFourSym',\n                 5: 'STIXSizeFiveSym'}\n\n            for size, name in stixsizedaltfonts.items():\n                fullpath = findfont(name)\n                self.fontmap[size] = fullpath\n                self.fontmap[name] = fullpath\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _map_virtual_font(self, fontname: str, font_class: str,\n                          uniindex: int) -> tuple[str, int]:\n        return fontname, uniindex\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        try:\n            uniindex = get_unicode_index(sym)\n            found_symbol = True\n        except ValueError:\n            uniindex = ord('?')\n            found_symbol = False\n            _log.warning(\"No TeX to Unicode mapping for %a.\", sym)\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                if (uniindex in self._cmr10_substitutions\n                        and font.family_name == \"cmr10\"):\n                    font = get_font(\n                        cbook._get_data_path(\"fonts/ttf/cmsy10.ttf\"))\n                    uniindex = self._cmr10_substitutions[uniindex]\n                glyphindex = font.get_char_ind"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "dviread.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "lh=%d, bc=%d, ec=%d, nw=%d, nh=%d, nd=%d',\n                       lh, bc, ec, nw, nh, nd)\n            header2 = file.read(4*lh)\n            self.checksum, self.design_size = struct.unpack('!2I', header2[:8])\n            # there is also encoding information etc.\n            char_info = file.read(4*(ec-bc+1))\n            widths = struct.unpack(f'!{nw}i', file.read(4*nw))\n            heights = struct.unpack(f'!{nh}i', file.read(4*nh))\n            depths = struct.unpack(f'!{nd}i', file.read(4*nd))\n        self._glyph_metrics = {}\n        for idx, char in enumerate(range(bc, ec+1)):\n            byte0 = char_info[4*idx]\n            byte1 = char_info[4*idx+1]\n            self._glyph_metrics[char] = TexMetrics(\n                tex_width=widths[byte0],\n                tex_height=heights[byte1 >> 4],\n                tex_depth=depths[byte1 & 0xf],\n            )\n\n    def get_metrics(self, idx):\n        \"\"\"Return a glyph's TexMetrics, or None if unavailable.\"\"\"\n        return self._glyph_metrics.get(idx)\n\n    width = _api.deprecated(\"3.11\", alternative=\"get_metrics\")(\n        property(lambda self: {c: m.tex_width for c, m in self._glyph_metrics}))\n    height = _api.deprecated(\"3.11\", alternative=\"get_metrics\")(\n        property(lambda self: {c: m.tex_height for c, m in self._glyph_metrics}))\n    depth = _api.deprecated(\"3.11\", alternative=\"get_metrics\")(\n        property(lambda self: {c: m.tex_depth for c, m in self._glyph_metrics}))\n\n\nPsFont = namedtuple('PsFont', 'texname psname effects encoding filename')\n\n\nclass PsfontsMap:\n    \"\"\"\n    A psfonts.map formatted file, mapping TeX fonts to PS fonts.\n\n    Parameters\n    ----------\n    filename : str or path-like\n\n    Notes\n    -----\n    For historical reasons, TeX knows many Type-1 fonts by different\n    names than the outside world. (For one thing, the names have to\n    fit in eight characters.) Also, TeX's native fonts are not Type-1\n    but Metafont, which is nontrivial to convert to PostScript except\n    as a bitmap. While hi"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "_afm.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "bbox\n            left = min(left, l)\n            miny = min(miny, b)\n            maxy = max(maxy, b + h)\n\n            namelast = name\n\n        return left, miny, total_width, maxy - miny, -miny\n\n    def get_glyph_name(self, glyph_ind):  # For consistency with FT2Font.\n        \"\"\"Get the name of the glyph, i.e., ord(';') is 'semicolon'.\"\"\"\n        return self._metrics[glyph_ind].name\n\n    def get_char_index(self, c):  # For consistency with FT2Font.\n        \"\"\"\n        Return the glyph index corresponding to a character code point.\n\n        Note, for AFM fonts, we treat the glyph index the same as the codepoint.\n        \"\"\"\n        return c\n\n    def get_width_char(self, c):\n        \"\"\"Get the width of the character code from the character metric WX field.\"\"\"\n        return self._metrics[c].width\n\n    def get_width_from_char_name(self, name):\n        \"\"\"Get the width of the character from a type1 character name.\"\"\"\n        return self._metrics_by_name[name].width\n\n    def get_kern_dist_from_name(self, name1, name2):\n        \"\"\"\n        Return the kerning pair distance (possibly 0) for chars *name1* and *name2*.\n        \"\"\"\n        return self._kern.get((name1, name2), 0)\n\n    def get_fontname(self):\n        \"\"\"Return the font name, e.g., 'Times-Roman'.\"\"\"\n        return self._header[b'FontName']\n\n    @property\n    def postscript_name(self):  # For consistency with FT2Font.\n        return self.get_fontname()\n\n    def get_fullname(self):\n        \"\"\"Return the font full name, e.g., 'Times-Roman'.\"\"\"\n        name = self._header.get(b'FullName')\n        if name is None:  # use FontName as a substitute\n            name = self._header[b'FontName']\n        return name\n\n    def get_familyname(self):\n        \"\"\"Return the font family name, e.g., 'Times'.\"\"\"\n        name = self._header.get(b'FamilyName')\n        if name is not None:\n            return name\n\n        # FamilyName not specified so we'll make a guess\n        name = self.get_fullname()\n        extras = (r'(?i)([ -](r"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt_prop, load_glyph_flags)\n        for key, val in self._fontmap.items():\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n        if font is not None and font.get_char_index(num) != 0:\n            return font, num, slanted\n        else:\n            return self._stix_fallback._get_glyph(fontname, font_class, sym)\n\n    # The Bakoma fonts contain many pre-sized alternatives for the\n    # delimiters.  The AutoSizedChar class will use these alternatives\n    # and select the best (closest sized) glyph.\n    _size_alternatives = {\n        '(':           [('rm', '('), ('ex', '\\xa1'), ('ex', '\\xb3'),\n                        ('ex', '\\xb5'), ('ex', '\\xc3')],\n        ')':           [('rm', ')'), ('ex', '\\xa2'), ('ex', '\\xb4'),\n                        ('ex', '\\xb6'), ('ex', '\\x21')],\n        '{':           [('cal', '{'), ('ex', '\\xa9'), ('ex', '\\x6e'),\n                        ('ex', '\\xbd'), ('ex', '\\x28')],\n        '}':           [('cal', '}'), ('ex', '\\xaa'), ('ex', '\\x6f'),\n                        ('ex', '\\xbe'), ('ex', '\\x29')],\n        # The fourth size of '[' is mysteriously missing from the BaKoMa\n        # font, so I've omitted it for both '[' and ']'\n        '[':           [('rm', '['), ('ex', '\\xa3'), ('ex', '\\x68'),\n                        ('ex', '\\x22')],\n        ']':           [('rm', ']'), ('ex', '\\xa4'), ('e"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "dviread.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 'x y height width')\n\n\n# Also a namedtuple, for backcompat.\nclass Text(namedtuple('Text', 'x y font glyph width')):\n    \"\"\"\n    A glyph in the dvi file.\n\n    The *x* and *y* attributes directly position the glyph.  The *font*,\n    *glyph*, and *width* attributes are kept public for back-compatibility,\n    but users wanting to draw the glyph themselves are encouraged to instead\n    load the font specified by `font_path` at `font_size`, warp it with the\n    effects specified by `font_effects`, and load the glyph at the FreeType\n    glyph `index`.\n    \"\"\"\n\n    def _get_pdftexmap_entry(self):\n        return PsfontsMap(find_tex_file(\"pdftex.map\"))[self.font.texname]\n\n    @property\n    def font_path(self):\n        \"\"\"The `~pathlib.Path` to the font for this glyph.\"\"\"\n        psfont = self._get_pdftexmap_entry()\n        if psfont.filename is None:\n            raise ValueError(\"No usable font file found for {} ({}); \"\n                             \"the font may lack a Type-1 version\"\n                             .format(psfont.psname.decode(\"ascii\"),\n                                     psfont.texname.decode(\"ascii\")))\n        return Path(psfont.filename)\n\n    @property\n    def font_size(self):\n        \"\"\"The font size.\"\"\"\n        return self.font.size\n\n    @property\n    def font_effects(self):\n        \"\"\"\n        The \"font effects\" dict for this glyph.\n\n        This dict contains the values for this glyph of SlantFont and\n        ExtendFont (if any), read off :file:`pdftex.map`.\n        \"\"\"\n        return self._get_pdftexmap_entry().effects\n\n    @property\n    def index(self):\n        \"\"\"\n        The FreeType index of this glyph (that can be passed to FT_Load_Glyph).\n        \"\"\"\n        # See DviFont._index_dvi_to_freetype for details on the index mapping.\n        return self.font._index_dvi_to_freetype(self.glyph)\n\n    @property  # To be deprecated together with font_size, font_effects.\n    def glyph_name_or_index(self):\n        \"\"\"\n        Either the glyph name or the nati"}], "retrieved_count": 10, "cost_time": 0.9998581409454346}
{"question": "Where in the matplotlib codebase are the lower-level Colorbar initialization and rendering functions that test_colorbarbase delegates to when instantiating a Colorbar with a colormap?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   # smoke test from #3805\n    ax = plt.gca()\n    Colorbar(ax, cmap=plt.colormaps[\"bone\"])\n\n\ndef test_parentless_mappable():\n    pc = mpl.collections.PatchCollection([], cmap=plt.get_cmap('viridis'), array=[])\n    with pytest.raises(ValueError, match='Unable to determine Axes to steal'):\n        plt.colorbar(pc)\n\n\n@image_comparison(['colorbar_closed_patch.png'], remove_text=True)\ndef test_colorbar_closed_patch():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    fig = plt.figure(figsize=(8, 6))\n    ax1 = fig.add_axes((0.05, 0.85, 0.9, 0.1))\n    ax2 = fig.add_axes((0.1, 0.65, 0.75, 0.1))\n    ax3 = fig.add_axes((0.05, 0.45, 0.9, 0.1))\n    ax4 = fig.add_axes((0.05, 0.25, 0.9, 0.1))\n    ax5 = fig.add_axes((0.05, 0.05, 0.9, 0.1))\n\n    cmap = mpl.colormaps[\"RdBu\"].resampled(5)\n\n    im = ax1.pcolormesh(np.linspace(0, 10, 16).reshape((4, 4)), cmap=cmap)\n\n    # The use of a \"values\" kwarg here is unusual.  It works only\n    # because it is matched to the data range in the image and to\n    # the number of colors in the LUT.\n    values = np.linspace(0, 10, 5)\n    cbar_kw = dict(orientation='horizontal', values=values, ticks=[])\n\n    # The wide line is to show that the closed path is being handled\n    # correctly.  See PR #4186.\n    with rc_context({'axes.linewidth': 16}):\n        plt.colorbar(im, cax=ax2, extend='both', extendfrac=0.5, **cbar_kw)\n        plt.colorbar(im, cax=ax3, extend='both', **cbar_kw)\n        plt.colorbar(im, cax=ax4, extend='both', extendrect=True, **cbar_kw)\n        plt.colorbar(im, cax=ax5, extend='neither', **cbar_kw)\n\n\ndef test_colorbar_ticks():\n    # test fix for #5673\n    fig, ax = plt.subplots()\n    x = np.arange(-3.0, 4.001)\n    y = np.arange(-4.0, 3.001)\n    X, Y = np.meshgrid(x, y)\n    Z = X * Y\n    clevs = np.array([-12, -5, 0, 5, 12], dtype=float)\n    colors = ['r', 'g', 'b', 'c']\n    cs = ax.contourf(X, Y, Z, clevs, colors=colors, extend='neither')\n    cbar = fig.colorbar(cs, ax=ax, o"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "~.ticker.Formatter` may be given instead.\n\ndrawedges : bool\n    Whether to draw lines at color boundaries.\n\nlabel : str\n    The label on the colorbar's long axis.\n\nboundaries, values : None or a sequence\n    If unset, the colormap will be displayed on a 0-1 scale.\n    If sequences, *values* must have a length 1 less than *boundaries*.  For\n    each region delimited by adjacent entries in *boundaries*, the color mapped\n    to the corresponding value in *values* will be used.  The size of each\n    region is determined by the *spacing* parameter.\n    Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other\n    unusual circumstances.\n\nspacing : {'uniform', 'proportional'}\n    For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each\n    color the same space; 'proportional' makes the space proportional to the\n    data interval.\"\"\")\n\n\ndef _set_ticks_on_axis_warn(*args, **kwargs):\n    # a top level function which gets put in at the axes'\n    # set_xticks and set_yticks by Colorbar.__init__.\n    _api.warn_external(\"Use the colorbar set_ticks() method instead.\")\n\n\nclass _ColorbarSpine(mspines.Spine):\n    def __init__(self, axes):\n        self._ax = axes\n        super().__init__(axes, 'colorbar', mpath.Path(np.empty((0, 2))))\n        mpatches.Patch.set_transform(self, axes.transAxes)\n\n    def get_window_extent(self, renderer=None):\n        # This Spine has no Axis associated with it, and doesn't need to adjust\n        # its location, so we can directly get the window extent from the\n        # super-super-class.\n        return mpatches.Patch.get_window_extent(self, renderer=renderer)\n\n    def set_xy(self, xy):\n        self._path = mpath.Path(xy, closed=True)\n        self._xy = xy\n        self.stale = True\n\n    def draw(self, renderer):\n        ret = mpatches.Patch.draw(self, renderer)\n        self.stale = False\n        return ret\n\n\nclass _ColorbarAxesLocator:\n    \"\"\"\n    Shrink the Axes if there are triangular or rectangular extends.\n    \"\"\"\n "}, {"start_line": 52000, "end_line": 54000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "          self.norm.vmin, self.norm.vmax = new_xbound\n        elif self.orientation == 'vertical':\n            self.norm.vmin, self.norm.vmax = new_ybound\n\n    def drag_pan(self, button, key, x, y):\n        # docstring inherited\n        points = self.ax._get_pan_points(button, key, x, y)\n        if points is not None:\n            if self.orientation == 'horizontal':\n                self.norm.vmin, self.norm.vmax = points[:, 0]\n            elif self.orientation == 'vertical':\n                self.norm.vmin, self.norm.vmax = points[:, 1]\n\n\nColorbarBase = Colorbar  # Backcompat API\n\n\ndef _normalize_location_orientation(location, orientation):\n    if location is None:\n        location = _get_ticklocation_from_orientation(orientation)\n    loc_settings = _api.check_getitem({\n        \"left\":   {\"location\": \"left\", \"anchor\": (1.0, 0.5),\n                   \"panchor\": (0.0, 0.5), \"pad\": 0.10},\n        \"right\":  {\"location\": \"right\", \"anchor\": (0.0, 0.5),\n                   \"panchor\": (1.0, 0.5), \"pad\": 0.05},\n        \"top\":    {\"location\": \"top\", \"anchor\": (0.5, 0.0),\n                   \"panchor\": (0.5, 1.0), \"pad\": 0.05},\n        \"bottom\": {\"location\": \"bottom\", \"anchor\": (0.5, 1.0),\n                   \"panchor\": (0.5, 0.0), \"pad\": 0.15},\n    }, location=location)\n    loc_settings[\"orientation\"] = _get_orientation_from_location(location)\n    if orientation is not None and orientation != loc_settings[\"orientation\"]:\n        # Allow the user to pass both if they are consistent.\n        raise TypeError(\"location and orientation are mutually exclusive\")\n    return loc_settings\n\n\ndef _get_orientation_from_location(location):\n    return _api.check_getitem(\n        {None: None, \"left\": \"vertical\", \"right\": \"vertical\",\n         \"top\": \"horizontal\", \"bottom\": \"horizontal\"}, location=location)\n\n\ndef _get_ticklocation_from_orientation(orientation):\n    return _api.check_getitem(\n        {None: \"right\", \"vertical\": \"right\", \"horizontal\": \"bottom\"},\n        orientation=orientation)\n\n\n@_d"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   def __init__(self, cbar):\n        self._cbar = cbar\n        self._orig_locator = cbar.ax._axes_locator\n\n    def __call__(self, ax, renderer):\n        if self._orig_locator is not None:\n            pos = self._orig_locator(ax, renderer)\n        else:\n            pos = ax.get_position(original=True)\n        if self._cbar.extend == 'neither':\n            return pos\n\n        y, extendlen = self._cbar._proportional_y()\n        if not self._cbar._extend_lower():\n            extendlen[0] = 0\n        if not self._cbar._extend_upper():\n            extendlen[1] = 0\n        len = sum(extendlen) + 1\n        shrink = 1 / len\n        offset = extendlen[0] / len\n        # we need to reset the aspect ratio of the axes to account\n        # of the extends...\n        if hasattr(ax, '_colorbar_info'):\n            aspect = ax._colorbar_info['aspect']\n        else:\n            aspect = False\n        # now shrink and/or offset to take into account the\n        # extend tri/rectangles.\n        if self._cbar.orientation == 'vertical':\n            if aspect:\n                self._cbar.ax.set_box_aspect(aspect*shrink)\n            pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)\n        else:\n            if aspect:\n                self._cbar.ax.set_box_aspect(1/(aspect * shrink))\n            pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)\n        return pos\n\n    def get_subplotspec(self):\n        # make tight_layout happy..\n        return (\n            self._cbar.ax.get_subplotspec()\n            or getattr(self._orig_locator, \"get_subplotspec\", lambda: None)())\n\n\n@_docstring.interpd\nclass Colorbar:\n    r\"\"\"\n    Draw a colorbar in an existing Axes.\n\n    Typically, colorbars are created using `.Figure.colorbar` or\n    `.pyplot.colorbar` and associated with `.ColorizingArtist`\\s (such as an\n    `.AxesImage` generated via `~.axes.Axes.imshow`).\n\n    In order to draw a colorbar not associated with other elements in the\n    figure, e.g. when showing a colormap by itself"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", one can create an empty\n    `.ColorizingArtist`, or directly pass *cmap* and *norm* instead of *mappable*\n    to `Colorbar`.\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    Attributes\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The `~.axes.Axes` instance in which the colorbar is drawn.\n    lines : list\n        A list of `.LineCollection` (empty if no lines were drawn).\n    dividers : `.LineCollection`\n        A LineCollection (empty if *drawedges* is ``False``).\n    \"\"\"\n\n    n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n\n    def __init__(\n        self, ax, mappable=None, *,\n        alpha=None,\n        location=None,\n        extend=None,\n        extendfrac=None,\n        extendrect=False,\n        ticks=None,\n        format=None,\n        values=None,\n        boundaries=None,\n        spacing='uniform',\n        drawedges=False,\n        label='',\n        cmap=None, norm=None,  # redundant with *mappable*\n        orientation=None, ticklocation='auto',  # redundant with *location*\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The `~.axes.Axes` instance in which the colorbar is drawn.\n\n        mappable : `.ColorizingArtist`\n            The mappable whose colormap and norm will be used.\n\n            To show the colors versus index instead of on a 0-1 scale, set the\n            mappable's norm to ``colors.NoNorm()``.\n\n        alpha : float\n            The colorbar transparency between 0 (transparent) and 1 (opaque).\n\n        location : None or {'left', 'right', 'top', 'bottom'}\n            Set the colorbar's *orientation* and *ticklocation*. Colorbars on\n            the left and right are vertical, colorbars at the top and bottom\n            are horizontal. The *ticklocation* is the same as *location*, so if\n            *location* is 'top', the ticks are on the top. *orientation* and/or\n            *ticklocation* can be provided as well and overrides"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "test_colors.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re useful)\n    ax.tick_params(labelleft=False, labelbottom=False)\n\n\n@image_comparison(baseline_images=['boundarynorm_and_colorbar'],\n                  extensions=['png'], tol=1.0)\ndef test_boundarynorm_and_colorbarbase():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['pcolormesh.snap'] = False\n\n    # Make a figure and axes with dimensions as desired.\n    fig = plt.figure()\n    ax1 = fig.add_axes((0.05, 0.80, 0.9, 0.15))\n    ax2 = fig.add_axes((0.05, 0.475, 0.9, 0.15))\n    ax3 = fig.add_axes((0.05, 0.15, 0.9, 0.15))\n\n    # Set the colormap and bounds\n    bounds = [-1, 2, 5, 7, 12, 15]\n    cmap = mpl.colormaps['viridis']\n\n    # Default behavior\n    norm = mcolors.BoundaryNorm(bounds, cmap.N)\n    cb1 = mcolorbar.ColorbarBase(ax1, cmap=cmap, norm=norm, extend='both',\n                                 orientation='horizontal', spacing='uniform')\n    # New behavior\n    norm = mcolors.BoundaryNorm(bounds, cmap.N, extend='both')\n    cb2 = mcolorbar.ColorbarBase(ax2, cmap=cmap, norm=norm,\n                                 orientation='horizontal')\n\n    # User can still force to any extend='' if really needed\n    norm = mcolors.BoundaryNorm(bounds, cmap.N, extend='both')\n    cb3 = mcolorbar.ColorbarBase(ax3, cmap=cmap, norm=norm,\n                                 extend='neither', orientation='horizontal')\n\n\ndef test_cmap_and_norm_from_levels_and_colors2():\n    levels = [-1, 2, 2.5, 3]\n    colors = ['red', (0, 1, 0), 'blue', (0.5, 0.5, 0.5), (0.0, 0.0, 0.0, 1.0)]\n    clr = mcolors.to_rgba_array(colors)\n    bad = (0.1, 0.1, 0.1, 0.1)\n    no_color = (0.0, 0.0, 0.0, 0.0)\n    masked_value = 'masked_value'\n\n    # Define the test values which are of interest.\n    # Note: levels are lev[i] <= v < lev[i+1]\n    tests = [('both', None, {-2: clr[0],\n                             -1: clr[1],\n                             2: clr[2],\n                             2.25: clr[2],\n                             3: clr[4],\n                             3.5: clr[4],\n       "}, {"start_line": 13000, "end_line": 15000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "              and getattr(cmap, 'colorbar_extend', False) is not False):\n                extend = cmap.colorbar_extend\n            elif hasattr(norm, 'extend'):\n                extend = norm.extend\n            else:\n                extend = 'neither'\n        self.alpha = None\n        # Call set_alpha to handle array-like alphas properly\n        self.set_alpha(alpha)\n        self.cmap = cmap\n        self.norm = norm\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = _api.check_getitem(\n            {'neither': slice(0, None), 'both': slice(1, -1),\n             'min': slice(1, None), 'max': slice(0, -1)},\n            extend=extend)\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self._filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self._extend_patches = []\n        self.solids = None\n        self.solids_patches = []\n        self.lines = []\n\n        for spine in self.ax.spines.values():\n            spine.set_visible(False)\n        self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n\n        self.dividers = collections.LineCollection(\n            [],\n            colors=[mpl.rcParams['axes.edgecolor']],\n            linewidths=[0.5 * mpl.rcParams['axes.linewidth']],\n            clip_on=False)\n        self.ax.add_collection(self.dividers, autolim=False)\n\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n\n        if ticklocation == 'auto':\n            ticklocation = _get_ticklocation_from_orientation(\n                orientation) if location is None else location\n        self.ticklocation = ticklocation\n\n        self.set_label(label)\n        self._reset_locator_formatter_scale()\n\n        if np.iterable(ticks):\n            self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n       "}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "test_colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", 10)+1)\n    cb = fig.colorbar(pc, ax=ax[0], extend='both')\n    cb.ax.set_yscale('log')\n\n    pc = ax[1].pcolormesh(np.arange(100).reshape(10, 10)+1)\n    cb = fig.colorbar(pc, ax=ax[1], extend='both')\n    cb.ax.set_ylim(20, 90)\n\n\n@check_figures_equal()\ndef test_axes_handles_same_functions(fig_ref, fig_test):\n    # prove that cax and cb.ax are functionally the same\n    for nn, fig in enumerate([fig_ref, fig_test]):\n        ax = fig.add_subplot()\n        pc = ax.pcolormesh(np.ones(300).reshape(10, 30))\n        cax = fig.add_axes((0.9, 0.1, 0.03, 0.8))\n        cb = fig.colorbar(pc, cax=cax)\n        if nn == 0:\n            caxx = cax\n        else:\n            caxx = cb.ax\n        caxx.set_yticks(np.arange(0, 20))\n        caxx.set_yscale('log')\n        caxx.set_position([0.92, 0.1, 0.02, 0.7])\n\n\ndef test_inset_colorbar_layout():\n    fig, ax = plt.subplots(constrained_layout=True, figsize=(3, 6))\n    pc = ax.imshow(np.arange(100).reshape(10, 10))\n    cax = ax.inset_axes([1.02, 0.1, 0.03, 0.8])\n    cb = fig.colorbar(pc, cax=cax)\n\n    fig.draw_without_rendering()\n    # make sure this is in the figure. In the colorbar swapping\n    # it was being dropped from the list of children...\n    np.testing.assert_allclose(cb.ax.get_position().bounds,\n                               [0.87, 0.342, 0.0237, 0.315], atol=0.01)\n    assert cb.ax in ax.child_axes\n\n\n@image_comparison(['colorbar_twoslope.png'], remove_text=True,\n                  style='mpl20')\ndef test_twoslope_colorbar():\n    # Note that the second tick = 20, and should be in the middle\n    # of the colorbar (white)\n    # There should be no tick right at the bottom, nor at the top.\n    fig, ax = plt.subplots()\n\n    norm = mcolors.TwoSlopeNorm(20, 5, 95)\n    pc = ax.pcolormesh(np.arange(1, 11), np.arange(1, 11),\n                       np.arange(100).reshape(10, 10),\n                       norm=norm, cmap='RdBu_r')\n    fig.colorbar(pc)\n\n\n@check_figures_equal()\ndef test_remove_cb_whose_mappable_has_no_figure(fig_ref, fig_test):\n  "}, {"start_line": 7000, "end_line": 9000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".orientation == 'vertical':\n            if aspect:\n                self._cbar.ax.set_box_aspect(aspect*shrink)\n            pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)\n        else:\n            if aspect:\n                self._cbar.ax.set_box_aspect(1/(aspect * shrink))\n            pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)\n        return pos\n\n    def get_subplotspec(self):\n        # make tight_layout happy..\n        return (\n            self._cbar.ax.get_subplotspec()\n            or getattr(self._orig_locator, \"get_subplotspec\", lambda: None)())\n\n\n@_docstring.interpd\nclass Colorbar:\n    r\"\"\"\n    Draw a colorbar in an existing Axes.\n\n    Typically, colorbars are created using `.Figure.colorbar` or\n    `.pyplot.colorbar` and associated with `.ColorizingArtist`\\s (such as an\n    `.AxesImage` generated via `~.axes.Axes.imshow`).\n\n    In order to draw a colorbar not associated with other elements in the\n    figure, e.g. when showing a colormap by itself, one can create an empty\n    `.ColorizingArtist`, or directly pass *cmap* and *norm* instead of *mappable*\n    to `Colorbar`.\n\n    Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n\n    Attributes\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The `~.axes.Axes` instance in which the colorbar is drawn.\n    lines : list\n        A list of `.LineCollection` (empty if no lines were drawn).\n    dividers : `.LineCollection`\n        A LineCollection (empty if *drawedges* is ``False``).\n    \"\"\"\n\n    n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n\n    def __init__(\n        self, ax, mappable=None, *,\n        alpha=None,\n        location=None,\n        extend=None,\n        extendfrac=None,\n        extendrect=False,\n        ticks=None,\n        format=None,\n        values=None,\n        boundaries=None,\n        spacing='uniform',\n        drawedges=False,\n        label='',\n        cmap=None, norm=None,  # redundant with *mappable*\n        orientation"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "colorbar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "le.colorbar = self\n        mappable.colorbar_cid = mappable.callbacks.connect(\n            'changed', self.update_normal)\n\n        location_orientation = _get_orientation_from_location(location)\n\n        _api.check_in_list(\n            [None, 'vertical', 'horizontal'], orientation=orientation)\n        _api.check_in_list(\n            ['auto', 'left', 'right', 'top', 'bottom'],\n            ticklocation=ticklocation)\n        _api.check_in_list(\n            ['uniform', 'proportional'], spacing=spacing)\n\n        if location_orientation is not None and orientation is not None:\n            if location_orientation != orientation:\n                raise TypeError(\n                    \"location and orientation are mutually exclusive\")\n        else:\n            orientation = orientation or location_orientation or \"vertical\"\n\n        self.ax = ax\n        self.ax._axes_locator = _ColorbarAxesLocator(self)\n\n        if extend is None:\n            if (not isinstance(mappable, contour.ContourSet)\n                    and getattr(cmap, 'colorbar_extend', False) is not False):\n                extend = cmap.colorbar_extend\n            elif hasattr(norm, 'extend'):\n                extend = norm.extend\n            else:\n                extend = 'neither'\n        self.alpha = None\n        # Call set_alpha to handle array-like alphas properly\n        self.set_alpha(alpha)\n        self.cmap = cmap\n        self.norm = norm\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = _api.check_getitem(\n            {'neither': slice(0, None), 'both': slice(1, -1),\n             'min': slice(1, None), 'max': slice(0, -1)},\n            extend=extend)\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self._filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self._extend_patches = []\n        self.solids = None\n        self.solids_patche"}], "retrieved_count": 10, "cost_time": 1.0210285186767578}
{"question": "Where in the AxLine class is the coordinate transformation logic applied to reconcile between data coordinates and display coordinates before computing the line endpoints?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " self._xy2])\n            dx = x2 - x1\n            dy = y2 - y1\n            if dx == 0:\n                if dy == 0:\n                    raise ValueError(\n                        f\"Cannot draw a line through two identical points \"\n                        f\"(x={(x1, x2)}, y={(y1, y2)})\")\n                slope = np.inf\n            else:\n                slope = dy / dx\n        else:\n            # one point and a slope were given\n            x1, y1 = points_transform.transform(self._xy1)\n            slope = self._slope\n        (vxlo, vylo), (vxhi, vyhi) = ax.transScale.transform(ax.viewLim)\n        # General case: find intersections with view limits in either\n        # direction, and draw between the middle two points.\n        if slope == 0:\n            start = vxlo, y1\n            stop = vxhi, y1\n        elif np.isinf(slope):\n            start = x1, vylo\n            stop = x1, vyhi\n        else:\n            _, start, stop, _ = sorted([\n                (vxlo, y1 + (vxlo - x1) * slope),\n                (vxhi, y1 + (vxhi - x1) * slope),\n                (x1 + (vylo - y1) / slope, vylo),\n                (x1 + (vyhi - y1) / slope, vyhi),\n            ])\n        return (BboxTransformTo(Bbox([start, stop]))\n                + ax.transLimits + ax.transAxes)\n\n    def draw(self, renderer):\n        self._transformed_path = None  # Force regen.\n        super().draw(renderer)\n\n    def get_xy1(self):\n        \"\"\"Return the *xy1* value of the line.\"\"\"\n        return self._xy1\n\n    def get_xy2(self):\n        \"\"\"Return the *xy2* value of the line.\"\"\"\n        return self._xy2\n\n    def get_slope(self):\n        \"\"\"Return the *slope* value of the line.\"\"\"\n        return self._slope\n\n    def set_xy1(self, *args, **kwargs):\n        \"\"\"\n        Set the *xy1* value of the line.\n\n        Parameters\n        ----------\n        xy1 : tuple[float, float]\n            Points for the line to pass through.\n        \"\"\"\n        params = _api.select_matching_signature([\n            lambda self, x, y: locals(), "}, {"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        ax = plt.axes()\n        trans = mtransforms.blended_transform_factory(ax.transAxes,\n                                                      ax.transData)\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, -5.],\n                                     [-np.inf, 35.]]))\n\n    def test_line_extent_predata_transform_coords(self):\n        # a simple line in (offset + data) coordinates\n        ax = plt.axes()\n        trans = mtransforms.Affine2D().scale(10) + ax.transData\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[1., -50.], [12., 350.]]))\n\n    def test_line_extent_compound_coords2(self):\n        # a simple line in (offset + data) coordinates in the y component, and\n        # in axes coordinates in the x\n        ax = plt.axes()\n        trans = mtransforms.blended_transform_factory(\n            ax.transAxes, mtransforms.Affine2D().scale(10) + ax.transData)\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, -50.], [-np.inf, 350.]]))\n\n    def test_line_extents_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        plt.plot(np.arange(10), transform=offset + ax.transData)\n        expected_data_lim = np.array([[0., 0.], [9.,  9.]]) + 10\n        assert_array_almost_equal(ax.dataLim.get_points(), expected_data_lim)\n\n    def test_line_extents_non_affine(self):\n        ax = plt.axes()\n        offset = mtransforms.Affine2D().translate(10, 10)\n        na_offset = NonAffineForTest(mtransforms.Affine2D().translate(10, 10))\n        plt.plot(np.arange(10), transform=offset + na_offset + ax.transData)\n        expected_data_lim = np.array([[0., 0.], [9.,  9.]]) + 20\n        assert_array_almost_equal(ax.dataLim.g"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "custom_projection.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/misc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "._get_affine_transform()\n\n        # 3) This is the transformation from Axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the '+' operator, these\n        # transforms will be applied \"in order\".  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and Axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the equator.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, 4.0)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, -4.0)\n\n        # Now set up the transforms for the latitude ticks.  The input to\n        # these transforms are in Axes space in x and display space in\n        # y.  Therefore, the input values will be in range (0, -ymin),\n        # (1, ymax).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be"}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "np.float64)\n\n        # check we have the expected results from doing the affine part only\n        assert_array_almost_equal(na_pts, na_expected)\n        # check we have the expected results from a full transformation\n        assert_array_almost_equal(all_pts, all_expected)\n        # check we have the expected results from doing the transformation in\n        # two steps\n        assert_array_almost_equal(self.stack1.transform_affine(na_pts),\n                                  all_expected)\n        # check that getting the affine transformation first, then fully\n        # transforming using that yields the same result as before.\n        assert_array_almost_equal(self.stack1.get_affine().transform(na_pts),\n                                  all_expected)\n\n        # check that the affine part of stack1 & stack2 are equivalent\n        # (i.e. the optimization is working)\n        expected_result = (self.ta2 + self.ta3).get_matrix()\n        result = self.stack1.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n        result = self.stack2.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n\nclass TestTransformPlotInterface:\n    def test_line_extent_axes_coords(self):\n        # a simple line in axes coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transAxes)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, np.inf],\n                                     [-np.inf, -np.inf]]))\n\n    def test_line_extent_data_coords(self):\n        # a simple line in data coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transData)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[0.1,  0.5], [1.2,  0.9]]))\n\n    def test_line_extent_compound_coords1(self):\n        # a simple line in data coordinates in the y component, and in axes\n        # coordinates in the x"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "assert_array_equal(expected_result, result)\n\n        result = self.stack2.get_affine().get_matrix()\n        assert_array_equal(expected_result, result)\n\n\nclass TestTransformPlotInterface:\n    def test_line_extent_axes_coords(self):\n        # a simple line in axes coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transAxes)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, np.inf],\n                                     [-np.inf, -np.inf]]))\n\n    def test_line_extent_data_coords(self):\n        # a simple line in data coordinates\n        ax = plt.axes()\n        ax.plot([0.1, 1.2, 0.8], [0.9, 0.5, 0.8], transform=ax.transData)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[0.1,  0.5], [1.2,  0.9]]))\n\n    def test_line_extent_compound_coords1(self):\n        # a simple line in data coordinates in the y component, and in axes\n        # coordinates in the x\n        ax = plt.axes()\n        trans = mtransforms.blended_transform_factory(ax.transAxes,\n                                                      ax.transData)\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[np.inf, -5.],\n                                     [-np.inf, 35.]]))\n\n    def test_line_extent_predata_transform_coords(self):\n        # a simple line in (offset + data) coordinates\n        ax = plt.axes()\n        trans = mtransforms.Affine2D().scale(10) + ax.transData\n        ax.plot([0.1, 1.2, 0.8], [35, -5, 18], transform=trans)\n        assert_array_equal(ax.dataLim.get_points(),\n                           np.array([[1., -50.], [12., 350.]]))\n\n    def test_line_extent_compound_coords2(self):\n        # a simple line in (offset + data) coordinates in the y component, and\n        # in axes coordinates in the x\n        ax = plt.axes()\n        trans = mtransforms.blended_transfo"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "geo.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/projections", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "UTION)\n\n        self.transAffine = self._get_affine_transform()\n\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # This is the transform for longitude ticks.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1, self._longitude_cap * 2) \\\n            .translate(0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, 4)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, -4)\n\n        # This is the transform for latitude ticks.\n        yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8, 0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8, 0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        _api"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "custom_projection.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/examples/misc", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ormation, see\n        # the inline documentation there.\n\n        # The goal of the first two transformations is to get from the\n        # data space (in this case longitude and latitude) to Axes\n        # space.  It is separated into a non-affine and affine part so\n        # that the non-affine part does not have to be recomputed when\n        # a simple affine change to the figure has been made (such as\n        # resizing the window or changing the dpi).\n\n        # 1) The core transformation from data space into\n        # rectilinear space defined in the HammerTransform class.\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        # 2) The above has an output range that is not in the unit\n        # rectangle, so scale and translate it so it fits correctly\n        # within the Axes.  The peculiar calculations of xscale and\n        # yscale are specific to an Aitoff-Hammer projection, so don't\n        # worry about them too much.\n        self.transAffine = self._get_affine_transform()\n\n        # 3) This is the transformation from Axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the '+' operator, these\n        # transforms will be applied \"in order\".  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and Axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display spa"}, {"start_line": 96000, "end_line": 98000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_method = self._children.remove\n        self.stale = True\n        return txt\n\n    def _update_line_limits(self, line):\n        \"\"\"\n        Figures out the data limit of the given line, updating `.Axes.dataLim`.\n        \"\"\"\n        path = line.get_path()\n        if path.vertices.size == 0:\n            return\n\n        line_trf = line.get_transform()\n\n        if line_trf == self.transData:\n            data_path = path\n        elif any(line_trf.contains_branch_seperately(self.transData)):\n            # Compute the transform from line coordinates to data coordinates.\n            trf_to_data = line_trf - self.transData\n            # If transData is affine we can use the cached non-affine component\n            # of line's path (since the non-affine part of line_trf is\n            # entirely encapsulated in trf_to_data).\n            if self.transData.is_affine:\n                line_trans_path = line._get_transformed_path()\n                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n                data_path = trf_to_data.transform_path_affine(na_path)\n            else:\n                data_path = trf_to_data.transform_path(path)\n        else:\n            # For backwards compatibility we update the dataLim with the\n            # coordinate range of the given path, even though the coordinate\n            # systems are completely different. This may occur in situations\n            # such as when ax.transAxes is passed through for absolute\n            # positioning.\n            data_path = path\n\n        if not data_path.vertices.size:\n            return\n\n        updatex, updatey = line_trf.contains_branch_seperately(self.transData)\n        if self.name != \"rectilinear\":\n            # This block is mostly intended to handle axvline in polar plots,\n            # for which updatey would otherwise be True.\n            if updatex and line_trf == self.get_yaxis_transform():\n                updatex = False\n            if updatey and line_trf == self.get_xaxis_transfo"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "transforms_tutorial.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ation, but you may not\n# need to compute the potentially expensive nonlinear scales or\n# projections on simple navigation events.  It is also possible to\n# multiply affine transformation matrices together, and then apply them\n# to coordinates in one step.  This is not true of all possible\n# transformations.\n#\n#\n# Here is how the ``ax.transData`` instance is defined in the basic\n# separable axis :class:`~matplotlib.axes.Axes` class::\n#\n#   self.transData = self.transScale + (self.transLimits + self.transAxes)\n#\n# We've been introduced to the ``transAxes`` instance above in\n# :ref:`axes-coords`, which maps the (0, 0), (1, 1) corners of the\n# Axes or subplot bounding box to *display* space, so let's look at\n# these other two pieces.\n#\n# ``self.transLimits`` is the transformation that takes you from\n# *data* to *axes* coordinates; i.e., it maps your view xlim and ylim\n# to the unit space of the Axes (and ``transAxes`` then takes that unit\n# space to display space).  We can see this in action here\n#\n# .. sourcecode:: ipython\n#\n#     In [80]: ax = plt.subplot()\n#\n#     In [81]: ax.set_xlim(0, 10)\n#     Out[81]: (0, 10)\n#\n#     In [82]: ax.set_ylim(-1, 1)\n#     Out[82]: (-1, 1)\n#\n#     In [84]: ax.transLimits.transform((0, -1))\n#     Out[84]: array([ 0.,  0.])\n#\n#     In [85]: ax.transLimits.transform((10, -1))\n#     Out[85]: array([ 1.,  0.])\n#\n#     In [86]: ax.transLimits.transform((10, 1))\n#     Out[86]: array([ 1.,  1.])\n#\n#     In [87]: ax.transLimits.transform((5, 0))\n#     Out[87]: array([ 0.5,  0.5])\n#\n# and we can use this same inverted transformation to go from the unit\n# *axes* coordinates back to *data* coordinates.\n#\n# .. sourcecode:: ipython\n#\n#     In [90]: inv.transform((0.25, 0.25))\n#     Out[90]: array([ 2.5, -0.5])\n#\n# The final piece is the ``self.transScale`` attribute, which is\n# responsible for the optional non-linear scaling of the data, e.g., for\n# logarithmic axes.  When an Axes is initially setup, this is just set to\n# the identity transform, si"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "artists.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/tutorials", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "         TransformWrapper(\n#                         BlendedAffine2D(\n#                             IdentityTransform(),\n#                             IdentityTransform())))),\n#             BboxTransformTo(\n#                 TransformedBbox(\n#                     Bbox(x0=0.125, y0=0.10999999999999999, x1=0.9, y1=0.88),\n#                     BboxTransformTo(\n#                         TransformedBbox(\n#                             Bbox(x0=0.0, y0=0.0, x1=6.4, y1=4.8),\n#                             Affine2D(\n#                                 [[100.   0.   0.]\n#                                  [  0. 100.   0.]\n#                                  [  0.   0.   1.]])))))))\n#\n#     # the default Axes transformation is ax.transData\n#     In [269]: print(ax.transData)\n#     CompositeGenericTransform(\n#         TransformWrapper(\n#             BlendedAffine2D(\n#                 IdentityTransform(),\n#                 IdentityTransform())),\n#         CompositeGenericTransform(\n#             BboxTransformFrom(\n#                 TransformedBbox(\n#                     Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0),\n#                     TransformWrapper(\n#                         BlendedAffine2D(\n#                             IdentityTransform(),\n#                             IdentityTransform())))),\n#             BboxTransformTo(\n#                 TransformedBbox(\n#                     Bbox(x0=0.125, y0=0.10999999999999999, x1=0.9, y1=0.88),\n#                     BboxTransformTo(\n#                         TransformedBbox(\n#                             Bbox(x0=0.0, y0=0.0, x1=6.4, y1=4.8),\n#                             Affine2D(\n#                                 [[100.   0.   0.]\n#                                  [  0. 100.   0.]\n#                                  [  0.   0.   1.]])))))))\n#\n#     # notice that the xlimits of the Axes have not been changed\n#     In [270]: print(ax.get_xlim())\n#     (0.0, 1.0)\n#\n#     # but the data limits have been updated to encompass the rectangle\n#     In "}], "retrieved_count": 10, "cost_time": 1.11277437210083}
{"question": "Where does the glyph lookup control flow in DejaVuSerifFonts traverse the fallback chain from the _fontmap dictionary through DejaVuFonts parent class to ultimately reach StixSerif when a glyph is not found?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")\n            font = self._get_font('ex')\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    return super()._get_glyph('ex', font_class, sym)\n            # otherwise return regular glyph\n            return super()._get_glyph(fontname, font_class, sym)\n\n\nclass DejaVuSerifFonts(DejaVuFonts):\n    \"\"\"\n    A font handling class for the DejaVu Serif fonts\n\n    If a glyph is not found it will fallback to Stix Serif\n    \"\"\"\n    _fontmap = {\n        'rm': 'DejaVu Serif',\n        'it': 'DejaVu Serif:italic',\n        'bf': 'DejaVu Serif:weight=bold',\n        'bfit': 'DejaVu Serif:italic:bold',\n        'sf': 'DejaVu Sans',\n        'tt': 'DejaVu Sans Mono',\n        'ex': 'DejaVu Serif Display',\n        0:    'DejaVu Serif',\n    }\n\n\nclass DejaVuSansFonts(DejaVuFonts):\n    \"\"\"\n    A font handling class for the DejaVu Sans fonts\n\n    If a glyph is not found it will fallback to Stix Sans\n    \"\"\"\n    _fontmap = {\n        'rm': 'DejaVu Sans',\n        'it': 'DejaVu Sans:italic',\n        'bf': 'DejaVu Sans:weight=bold',\n        'bfit': 'DejaVu Sans:italic:bold',\n        'sf': 'DejaVu Sans',\n        'tt': 'DejaVu Sans Mono',\n        'ex': 'DejaVu Sans Display',\n        0:    'DejaVu Sans',\n    }\n\n\nclass StixFonts(UnicodeFonts):\n    \"\"\"\n    A font handling class for the STIX fonts.\n\n    In addition to what UnicodeFonts provides, this class:\n\n    - supports \"virtual fonts\" which are complete alpha numeric\n      character sets with different font styles at special Unicode\n      code points, such as \"Blackboard\".\n\n    - handles sized alternative characters for the STIXSizeX fonts.\n    \"\"\"\n    _fontmap: dict[str | int, str] = {\n        'rm': 'STIXGeneral',\n        'it': 'STIXGeneral:italic',\n        'bf': 'STIXGeneral:weight=bold',\n        'bfit': 'STIXGeneral:italic:bold',\n        'nonunirm': 'STIXNonUnicode',\n        'nonuniit': 'STIXNonUnicode:italic',\n        'nonunibf': 'STIXNonUnicode:weight"}, {"start_line": 24000, "end_line": 26000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ex(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self._fallback_font:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self._fallback_font, StixFonts)):\n                    fontname = 'rm'\n\n                g = self._fallback_font._get_glyph(fontname, font_class, sym)\n                family = g[0].family_name\n                if family in list(BakomaFonts._fontmap.values()):\n                    family = \"Computer Modern\"\n                _log.info(\"Substituting symbol %s from %s\", sym, family)\n                return g\n\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym)\n                _log.warning(\"Font %r does not have a glyph for %a [U+%x], \"\n                             \"substituting with a dummy symbol.\",\n                             new_fontname, sym, uniindex)\n                font = self._get_font('rm')\n                uniindex = 0xA4  # currency char, for lack of anything better\n                slanted = False\n\n        return font, uniindex, slanted\n\n    def get_sized_alternatives_for_symbol(self, fontname: str,\n                                          sym: str) -> list[tuple[str, str]]:\n        if self._fallback_font:\n            return self._fallback_font.get_sized_alternatives_for_symbol(\n                fontname, sym)\n        return [(fontname, sym)]\n\n\nclass DejaVuFonts(UnicodeFonts, metaclass=abc.ABCMeta):\n    _fontmap: dict[str | int, str] = {}\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        # This must come first so the backend's owner is set correctly\n        if isinstance(self, DejaVuSerifFonts):\n            self._fallback_font = StixFonts(default_font_prop, load_glyph_flags)\n        else:\n            self._fallback_font = StixSansFonts(defaul"}, {"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "t_font_prop, load_glyph_flags)\n        self.bakoma = BakomaFonts(default_font_prop, load_glyph_flags)\n        TruetypeFonts.__init__(self, default_font_prop, load_glyph_flags)\n        # Include Stix sized alternatives for glyphs\n        self._fontmap.update({\n            1: 'STIXSizeOneSym',\n            2: 'STIXSizeTwoSym',\n            3: 'STIXSizeThreeSym',\n            4: 'STIXSizeFourSym',\n            5: 'STIXSizeFiveSym',\n        })\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        # Override prime symbol to use Bakoma.\n        if sym == r'\\prime':\n            return self.bakoma._get_glyph(fontname, font_class, sym)\n        else:\n            # check whether the glyph is available in the display font\n            uniindex = get_unicode_index(sym)\n            font = self._get_font('ex')\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    return super()._get_glyph('ex', font_class, sym)\n            # otherwise return regular glyph\n            return super()._get_glyph(fontname, font_class, sym)\n\n\nclass DejaVuSerifFonts(DejaVuFonts):\n    \"\"\"\n    A font handling class for the DejaVu Serif fonts\n\n    If a glyph is not found it will fallback to Stix Serif\n    \"\"\"\n    _fontmap = {\n        'rm': 'DejaVu Serif',\n        'it': 'DejaVu Serif:italic',\n        'bf': 'DejaVu Serif:weight=bold',\n        'bfit': 'DejaVu Serif:italic:bold',\n        'sf': 'DejaVu Sans',\n        'tt': 'DejaVu Sans Mono',\n        'ex': 'DejaVu Serif Display',\n        0:    'DejaVu Serif',\n    }\n\n\nclass DejaVuSansFonts(DejaVuFonts):\n    \"\"\"\n    A font handling class for the DejaVu Sans fonts\n\n    If a glyph is not found it will fallback to Stix Sans\n    \"\"\"\n    _fontma"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "           new_fontname, sym, uniindex)\n                font = self._get_font('rm')\n                uniindex = 0xA4  # currency char, for lack of anything better\n                slanted = False\n\n        return font, uniindex, slanted\n\n    def get_sized_alternatives_for_symbol(self, fontname: str,\n                                          sym: str) -> list[tuple[str, str]]:\n        if self._fallback_font:\n            return self._fallback_font.get_sized_alternatives_for_symbol(\n                fontname, sym)\n        return [(fontname, sym)]\n\n\nclass DejaVuFonts(UnicodeFonts, metaclass=abc.ABCMeta):\n    _fontmap: dict[str | int, str] = {}\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        # This must come first so the backend's owner is set correctly\n        if isinstance(self, DejaVuSerifFonts):\n            self._fallback_font = StixFonts(default_font_prop, load_glyph_flags)\n        else:\n            self._fallback_font = StixSansFonts(default_font_prop, load_glyph_flags)\n        self.bakoma = BakomaFonts(default_font_prop, load_glyph_flags)\n        TruetypeFonts.__init__(self, default_font_prop, load_glyph_flags)\n        # Include Stix sized alternatives for glyphs\n        self._fontmap.update({\n            1: 'STIXSizeOneSym',\n            2: 'STIXSizeTwoSym',\n            3: 'STIXSizeThreeSym',\n            4: 'STIXSizeFourSym',\n            5: 'STIXSizeFiveSym',\n        })\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        # Override prime symbol to use Bakoma.\n        if sym == r'\\prime':\n            return self.bakoma._get_glyph(fontname, font_class, sym)\n        else:\n            # check whether the glyph is available in the display font\n            uniindex = get_unicode_index(sym"}, {"start_line": 29000, "end_line": 31000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "=bold',\n        0: 'STIXGeneral',\n        1: 'STIXSizeOneSym',\n        2: 'STIXSizeTwoSym',\n        3: 'STIXSizeThreeSym',\n        4: 'STIXSizeFourSym',\n        5: 'STIXSizeFiveSym',\n    }\n    _fallback_font = None\n    _sans = False\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        TruetypeFonts.__init__(self, default_font_prop, load_glyph_flags)\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n\n    def _map_virtual_font(self, fontname: str, font_class: str,\n                          uniindex: int) -> tuple[str, int]:\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        font_mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and font_mapping is None\n                and fontname not in ('regular', 'default')):\n            font_mapping = stix_virtual_fonts['sf']\n            doing_sans_conversion = True\n        else:\n            doing_sans_conversion = False\n\n        if isinstance(font_mapping, dict):\n            try:\n                mapping = font_mapping[font_class]\n            except KeyError:\n                mapping = font_mapping['rm']\n        elif isinstance(font_mapping, list):\n            mapping = font_mapping\n        else:\n            mapping = None\n\n        if mapping is not None:\n            # Binary search for the source glyph\n            lo = 0\n            hi = len(mapping)\n            while lo < hi:\n                mid = (lo+hi)//2\n                range = mapping[mid]\n                if uniindex < range[0]:\n                    hi = mid\n                elif uniindex <= range[1]:\n                    break\n                else:\n                    lo = mid + 1\n\n            if range[0] <= uniindex <= range[1]:\n                uniindex = uniindex - range[0] + range[3]\n                fontname = range[2]\n            elif not doing_sans_convers"}, {"start_line": 22000, "end_line": 24000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   2: 'STIXSizeTwoSym',\n                 3: 'STIXSizeThreeSym',\n                 4: 'STIXSizeFourSym',\n                 5: 'STIXSizeFiveSym'}\n\n            for size, name in stixsizedaltfonts.items():\n                fullpath = findfont(name)\n                self.fontmap[size] = fullpath\n                self.fontmap[name] = fullpath\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _map_virtual_font(self, fontname: str, font_class: str,\n                          uniindex: int) -> tuple[str, int]:\n        return fontname, uniindex\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        try:\n            uniindex = get_unicode_index(sym)\n            found_symbol = True\n        except ValueError:\n            uniindex = ord('?')\n            found_symbol = False\n            _log.warning(\"No TeX to Unicode mapping for %a.\", sym)\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                if (uniindex in self._cmr10_substitutions\n                        and font.family_name == \"cmr10\"):\n                    font = get_font(\n                        cbook._get_data_path(\"fonts/ttf/cmsy10.ttf\"))\n                    uniindex = self._cmr10_substitutions[uniindex]\n                glyphindex = font.get_char_ind"}, {"start_line": 28000, "end_line": 30000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "p = {\n        'rm': 'DejaVu Sans',\n        'it': 'DejaVu Sans:italic',\n        'bf': 'DejaVu Sans:weight=bold',\n        'bfit': 'DejaVu Sans:italic:bold',\n        'sf': 'DejaVu Sans',\n        'tt': 'DejaVu Sans Mono',\n        'ex': 'DejaVu Sans Display',\n        0:    'DejaVu Sans',\n    }\n\n\nclass StixFonts(UnicodeFonts):\n    \"\"\"\n    A font handling class for the STIX fonts.\n\n    In addition to what UnicodeFonts provides, this class:\n\n    - supports \"virtual fonts\" which are complete alpha numeric\n      character sets with different font styles at special Unicode\n      code points, such as \"Blackboard\".\n\n    - handles sized alternative characters for the STIXSizeX fonts.\n    \"\"\"\n    _fontmap: dict[str | int, str] = {\n        'rm': 'STIXGeneral',\n        'it': 'STIXGeneral:italic',\n        'bf': 'STIXGeneral:weight=bold',\n        'bfit': 'STIXGeneral:italic:bold',\n        'nonunirm': 'STIXNonUnicode',\n        'nonuniit': 'STIXNonUnicode:italic',\n        'nonunibf': 'STIXNonUnicode:weight=bold',\n        0: 'STIXGeneral',\n        1: 'STIXSizeOneSym',\n        2: 'STIXSizeTwoSym',\n        3: 'STIXSizeThreeSym',\n        4: 'STIXSizeFourSym',\n        5: 'STIXSizeFiveSym',\n    }\n    _fallback_font = None\n    _sans = False\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        TruetypeFonts.__init__(self, default_font_prop, load_glyph_flags)\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n\n    def _map_virtual_font(self, fontname: str, font_class: str,\n                          uniindex: int) -> tuple[str, int]:\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        font_mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and font_mapping is None\n                and fontname not in ('regular', 'default')):\n            font_mapping = stix_virtual_fonts['sf']\n        "}, {"start_line": 23000, "end_line": 25000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                if (uniindex in self._cmr10_substitutions\n                        and font.family_name == \"cmr10\"):\n                    font = get_font(\n                        cbook._get_data_path(\"fonts/ttf/cmsy10.ttf\"))\n                    uniindex = self._cmr10_substitutions[uniindex]\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self._fallback_font:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self._fallback_font, StixFonts)):\n                    fontname = 'rm'\n\n                g = self._fallback_font._get_glyph(fontname, font_class, sym)\n                family = g[0].family_name\n                if family in list(BakomaFonts._fontmap.values()):\n                    family = \"Computer Modern\"\n                _log.info(\"Substituting symbol %s from %s\", sym, family)\n                return g\n\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym)\n                _log.warning(\"Font %r does not have a glyph for %a [U+%x], \"\n                             \"substituting with a dummy symbol.\",\n                  "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nt_prop, load_glyph_flags)\n        for key, val in self._fontmap.items():\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _get_glyph(self, fontname: str, font_class: str,\n                   sym: str) -> tuple[FT2Font, int, bool]:\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n        if font is not None and font.get_char_index(num) != 0:\n            return font, num, slanted\n        else:\n            return self._stix_fallback._get_glyph(fontname, font_class, sym)\n\n    # The Bakoma fonts contain many pre-sized alternatives for the\n    # delimiters.  The AutoSizedChar class will use these alternatives\n    # and select the best (closest sized) glyph.\n    _size_alternatives = {\n        '(':           [('rm', '('), ('ex', '\\xa1'), ('ex', '\\xb3'),\n                        ('ex', '\\xb5'), ('ex', '\\xc3')],\n        ')':           [('rm', ')'), ('ex', '\\xa2'), ('ex', '\\xb4'),\n                        ('ex', '\\xb6'), ('ex', '\\x21')],\n        '{':           [('cal', '{'), ('ex', '\\xa9'), ('ex', '\\x6e'),\n                        ('ex', '\\xbd'), ('ex', '\\x28')],\n        '}':           [('cal', '}'), ('ex', '\\xaa'), ('ex', '\\x6f'),\n                        ('ex', '\\xbe'), ('ex', '\\x29')],\n        # The fourth size of '[' is mysteriously missing from the BaKoMa\n        # font, so I've omitted it for both '[' and ']'\n        '[':           [('rm', '['), ('ex', '\\xa3'), ('ex', '\\x68'),\n                        ('ex', '\\x22')],\n        ']':           [('rm', ']'), ('ex', '\\xa4'), ('e"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "_mathtext.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ": str,\n                                          sym: str) -> list[tuple[str, str]]:\n        return self._size_alternatives.get(sym, [(fontname, sym)])\n\n\nclass UnicodeFonts(TruetypeFonts):\n    \"\"\"\n    An abstract base class for handling Unicode fonts.\n\n    While some reasonably complete Unicode fonts (such as DejaVu) may\n    work in some situations, the only Unicode font I'm aware of with a\n    complete set of math symbols is STIX.\n\n    This class will \"fallback\" on the Bakoma fonts when a required\n    symbol cannot be found in the font.\n    \"\"\"\n\n    # Some glyphs are not present in the `cmr10` font, and must be brought in\n    # from `cmsy10`. Map the Unicode indices of those glyphs to the indices at\n    # which they are found in `cmsy10`.\n    _cmr10_substitutions = {\n        0x00D7: 0x00A3,  # Multiplication sign.\n        0x2212: 0x00A1,  # Minus sign.\n    }\n\n    def __init__(self, default_font_prop: FontProperties, load_glyph_flags: LoadFlags):\n        # This must come first so the backend's owner is set correctly\n        fallback_rc = mpl.rcParams['mathtext.fallback']\n        font_cls: type[TruetypeFonts] | None = {\n            'stix': StixFonts,\n            'stixsans': StixSansFonts,\n            'cm': BakomaFonts\n        }.get(fallback_rc)\n        self._fallback_font = (font_cls(default_font_prop, load_glyph_flags)\n                               if font_cls else None)\n\n        super().__init__(default_font_prop, load_glyph_flags)\n        for texfont in \"cal rm tt it bf sf bfit\".split():\n            prop = mpl.rcParams['mathtext.' + texfont]\n            font = findfont(prop)\n            self.fontmap[texfont] = font\n        prop = FontProperties('cmex10')\n        font = findfont(prop)\n        self.fontmap['ex'] = font\n\n        # include STIX sized alternatives for glyphs if fallback is STIX\n        if isinstance(self._fallback_font, StixFonts):\n            stixsizedaltfonts = {\n                 0: 'STIXGeneral',\n                 1: 'STIXSizeOneSym',\n              "}], "retrieved_count": 10, "cost_time": 1.0037331581115723}
{"question": "Where does the conditional evaluation of tick visibility and orientation in _update_label determine the data flow path for computing axislabel_pad, and what is the consequence of the nested boolean condition on the major_ticks.get_tick_out() call?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 34000, "end_line": 36000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       tr = (self._axis_artist_helper.get_axislabel_transform(self.axes)\n              + self.offset_transform)\n        self.label = AxisLabel(\n            0, 0, \"__from_axes__\",\n            color=\"auto\",\n            fontsize=kwargs.get(\"labelsize\", mpl.rcParams['axes.labelsize']),\n            fontweight=mpl.rcParams['axes.labelweight'],\n            axis=self.axis,\n            transform=tr,\n            axis_direction=self._axis_direction,\n        )\n        self.label.set_figure(self.axes.get_figure(root=False))\n        labelpad = kwargs.get(\"labelpad\", 5)\n        self.label.set_pad(labelpad)\n\n    def _update_label(self, renderer):\n        if not self.label.get_visible():\n            return\n\n        if self._ticklabel_add_angle != self._axislabel_add_angle:\n            if ((self.major_ticks.get_visible()\n                 and not self.major_ticks.get_tick_out())\n                or (self.minor_ticks.get_visible()\n                    and not self.major_ticks.get_tick_out())):\n                axislabel_pad = self.major_ticks._ticksize\n            else:\n                axislabel_pad = 0\n        else:\n            axislabel_pad = max(self.major_ticklabels._axislabel_pad,\n                                self.minor_ticklabels._axislabel_pad)\n\n        self.label._external_pad = axislabel_pad\n\n        xy, angle_tangent = \\\n            self._axis_artist_helper.get_axislabel_pos_angle(self.axes)\n        if xy is None:\n            return\n\n        angle_label = angle_tangent - 90\n\n        x, y = xy\n        self.label._ref_angle = angle_label + self._axislabel_add_angle\n        self.label.set(x=x, y=y)\n\n    def _draw_label(self, renderer):\n        self._update_label(renderer)\n        self.label.draw(renderer)\n\n    def set_label(self, s):\n        # docstring inherited\n        self.label.set_text(s)\n\n    def get_tightbbox(self, renderer=None):\n        if not self.get_visible():\n            return\n        self._axis_artist_helper.update_lim(self.axes)\n        self._update_ticks(rendere"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "l, label])\n\n        return ticks_loc_angle, ticklabels_loc_angle_label\n\n    def _update_ticks(self, renderer=None):\n        # set extra pad for major and minor ticklabels: use ticksize of\n        # majorticks even for minor ticks. not clear what is best.\n\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        if self.major_ticks.get_visible() and self.major_ticks.get_tick_out():\n            ticklabel_pad = self.major_ticks._ticksize * dpi_cor\n            self.major_ticklabels._external_pad = ticklabel_pad\n            self.minor_ticklabels._external_pad = ticklabel_pad\n        else:\n            self.major_ticklabels._external_pad = 0\n            self.minor_ticklabels._external_pad = 0\n\n        majortick_iter, minortick_iter = \\\n            self._axis_artist_helper.get_tick_iterators(self.axes)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(majortick_iter)\n        self.major_ticks.set_locs_angles(tick_loc_angle)\n        self.major_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n\n        tick_loc_angle, ticklabel_loc_angle_label = \\\n            self._get_tick_info(minortick_iter)\n        self.minor_ticks.set_locs_angles(tick_loc_angle)\n        self.minor_ticklabels.set_locs_angles_labels(ticklabel_loc_angle_label)\n\n    def _draw_ticks(self, renderer):\n        self._update_ticks(renderer)\n        self.major_ticks.draw(renderer)\n        self.major_ticklabels.draw(renderer)\n        self.minor_ticks.draw(renderer)\n        self.minor_ticklabels.draw(renderer)\n        if (self.major_ticklabels.get_visible()\n                or self.minor_ticklabels.get_visible()):\n            self._draw_offsetText(renderer)\n\n    _offsetText_pos = dict(left=(0, 1, \"bottom\", \"right\"),\n                           right=(1, 1, \"bottom\", \"left\"),\n                           bottom=(1, 0, \"top\", \"right\"),\n                           top=(1, 1, \"bottom\", "}, {"start_line": 50000, "end_line": 52000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ormatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.offsetText]\n              if a.get_visible()),\n            *tlb1, *tlb2,\n        ]\n        # take care of label\n        if self.label.get_visible():\n            bb = self.label.get_window_extent(renderer)\n            # for constrained/tight_layout, we want to ignore the label's\n            # width/height because the adjustments they make can't be improved.\n            # this code collapses the relevant direction\n            if for_layout_only:\n                if self.axis_name == \"x\" and bb.width > 0:\n                    bb.x0 = (bb.x0 + bb.x1) / 2 - 0.5\n                    bb.x1 = bb.x0 + 1.0\n                if self.axis_name == \"y\" and bb.height > 0:\n                    bb.y0 = (bb.y0 + bb.y1) / 2 - 0.5\n                    bb.y1 = bb.y0 + 1.0\n            bboxes.append(bb)\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None\n\n    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # Shift label away from axes to avoid overlapping ticklabels.\n        self._update_label_position(renderer)\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n"}, {"start_line": 35000, "end_line": 37000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   axislabel_pad = self.major_ticks._ticksize\n            else:\n                axislabel_pad = 0\n        else:\n            axislabel_pad = max(self.major_ticklabels._axislabel_pad,\n                                self.minor_ticklabels._axislabel_pad)\n\n        self.label._external_pad = axislabel_pad\n\n        xy, angle_tangent = \\\n            self._axis_artist_helper.get_axislabel_pos_angle(self.axes)\n        if xy is None:\n            return\n\n        angle_label = angle_tangent - 90\n\n        x, y = xy\n        self.label._ref_angle = angle_label + self._axislabel_add_angle\n        self.label.set(x=x, y=y)\n\n    def _draw_label(self, renderer):\n        self._update_label(renderer)\n        self.label.draw(renderer)\n\n    def set_label(self, s):\n        # docstring inherited\n        self.label.set_text(s)\n\n    def get_tightbbox(self, renderer=None):\n        if not self.get_visible():\n            return\n        self._axis_artist_helper.update_lim(self.axes)\n        self._update_ticks(renderer)\n        self._update_label(renderer)\n\n        self.line.set_path(self._axis_artist_helper.get_line(self.axes))\n        if self.get_axisline_style() is not None:\n            self.line.set_line_mutation_scale(self.major_ticklabels.get_size())\n\n        bb = [\n            *self.major_ticklabels.get_window_extents(renderer),\n            *self.minor_ticklabels.get_window_extents(renderer),\n            self.label.get_window_extent(renderer),\n            self.offsetText.get_window_extent(renderer),\n            self.line.get_window_extent(renderer),\n        ]\n        bb = [b for b in bb if b and (b.width != 0 or b.height != 0)]\n        if bb:\n            _bbox = Bbox.union(bb)\n            return _bbox\n        else:\n            return None\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n        self._axis_artist_helper.update_lim(self.ax"}, {"start_line": 51000, "end_line": 53000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None\n\n    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # Shift label away from axes to avoid overlapping ticklabels.\n        self._update_label_position(renderer)\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False\n\n    def get_gridlines(self):\n        r\"\"\"Return this Axis' grid lines as a list of `.Line2D`\\s.\"\"\"\n        ticks = self.get_major_ticks()\n        return cbook.silent_list('Line2D gridline',\n                                 [tick.gridline for tick in ticks])\n\n    def set_label(self, s):\n        \"\"\"Assigning legend labels is not supported. Raises RuntimeError.\"\"\"\n        raise RuntimeError(\n            \"A legend label cannot be assigned to an Axis. Did you mean to \"\n            \"set the axis label via set_label_text()?\")\n\n    def get_label(self):\n        \"\"\"\n        [*Discouraged*] Return the axis label as a Text instance.\n\n        .. admonition:: Discouraged\n\n           This overrides `.Artist.get_label`, which is for legend labels, with a new\n           semantic. It is recommended to use the attribute ``Axis.label"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "polar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/projections", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n        padx = pad * np.cos(angle) / 72\n        pady = pad * np.sin(angle) / 72\n        self._text1_translate._t = (padx, pady)\n        self._text1_translate.invalidate()\n        self._text2_translate._t = (-padx, -pady)\n        self._text2_translate.invalidate()\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding("}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "if label_direction == \"left\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"left\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"right\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"right\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"bottom\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"bottom\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_ascent\n                pad = max_ascent + max_descent\n        elif label_direction == \"top\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"top\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_descent\n                pad = max_ascent + max_descent\n\n        # r : offset\n        # pad : total height of the ticklabels. This will be used to\n        # calculate the pad for the axislabel.\n        return r, pad\n\n    _default_alignments = dict(left=(\"center\", \"right\"),\n                               right=(\"center\", \"left\"),\n                               bottom=(\"baseline\", \"center\"),\n                               top=(\"baseline\", \"center\"))\n\n    _default_angles = dict(left=90,\n                           right=-90,\n                           bottom=0,\n                           top=180)\n\n    def draw(self, renderer):\n        if not self.get_visible():\n            self._axislabel_pad = self._external_pad\n            return\n\n        r, total_width = self."}, {"start_line": 99000, "end_line": 101000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "el.set_verticalalignment(_api.check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'left':\n            # Union with extents of the left spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"left\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x0 - self.labelpad * self.get_figure(root=True).dpi / 72, y))\n        else:\n            # Union with extents of the right spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"right\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x1 + self.labelpad * self.get_figure(root=True).dpi / 72, y))\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, _ = self.offsetText.get_position()\n        if 'outline' in self.axes.spines:\n            # Special case for colorbars:\n            bbox = self.axes.spines['outline'].get_window_extent()\n        else:\n            bbox = self.axes.bbox\n        top = bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72)\n        )\n\n    def set_"}, {"start_line": 21000, "end_line": 23000, "belongs_to": {"file_name": "polar.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/projections", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "             elif angle < -23.5:\n                    return 'right', 'bottom'\n                elif angle < 22.5:\n                    return 'right', 'center'\n                elif angle < 67.5:\n                    return 'right', 'top'\n                elif angle < 112.5:\n                    return 'center', 'top'\n                elif angle < 157.5:\n                    return 'left', 'top'\n                elif angle < 202.5:\n                    return 'left', 'center'\n                elif angle < 247.5:\n                    return 'left', 'bottom'\n                else:\n                    return 'center', 'bottom'\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker "}, {"start_line": 90000, "end_line": 92000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'bottom':\n            # Union with extents of the bottom spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"bottom\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y0 - self.labelpad * self.get_figure(root=True).dpi / 72))\n        else:\n            # Union with extents of the top spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"top\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y1 + self.labelpad * self.get_figure(root=True).dpi / 72))\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not hasattr(self, '_tick_position'):\n            self._tick_position = 'bottom'\n        if self._tick_position == 'bottom':\n            if not len(bboxes):\n                bottom = self.axes.bbox.ymin\n            else:\n                bbox = mtransforms.Bbox.union(bboxes)\n                bottom = bbox.y0\n            y = bottom - self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72\n        else:\n            if not len(bboxes2):\n     "}], "retrieved_count": 10, "cost_time": 0.9742355346679688}
{"question": "Where is the NonAffineForTest class defined that is instantiated in the setup_method of TestBasicTransform?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 26000, "end_line": 28000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "   tpath = trans.transform_path_non_affine(path)\n    result = tpath.iter_segments(trans.get_affine(),\n                                 clip=(0, 0, 100, 100),\n                                 simplify=False)\n    tpoints, tcodes = zip(*result)\n    assert_allclose(tcodes, path.codes[:-1])  # No longer closed.\n\n\nclass NonAffineForTest(mtransforms.Transform):\n    \"\"\"\n    A class which looks like a non affine transform, but does whatever\n    the given transform does (even if it is affine). This is very useful\n    for testing NonAffine behaviour with a simple Affine transform.\n\n    \"\"\"\n    is_affine = False\n    output_dims = 2\n    input_dims = 2\n\n    def __init__(self, real_trans, *args, **kwargs):\n        self.real_trans = real_trans\n        super().__init__(*args, **kwargs)\n\n    def transform_non_affine(self, values):\n        return self.real_trans.transform(values)\n\n    def transform_path_non_affine(self, path):\n        return self.real_trans.transform_path(path)\n\n\nclass TestBasicTransform:\n    def setup_method(self):\n\n        self.ta1 = mtransforms.Affine2D(shorthand_name='ta1').rotate(np.pi / 2)\n        self.ta2 = mtransforms.Affine2D(shorthand_name='ta2').translate(10, 0)\n        self.ta3 = mtransforms.Affine2D(shorthand_name='ta3').scale(1, 2)\n\n        self.tn1 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn1')\n        self.tn2 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn2')\n        self.tn3 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn3')\n\n        # creates a transform stack which looks like ((A, (N, A)), A)\n        self.stack1 = (self.ta1 + (self.tn1 + self.ta2)) + self.ta3\n        # creates a transform stack which looks like (((A, N), A), A)\n        self.stack2 = self.ta1 + self.tn1 + self.ta2 + self.ta3\n        # creates a transform stack which is a subset of sta"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ransform`` is True.\n\n        \"\"\"\n        input_dims = output_dims = 2\n        is_affine = False\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.raise_on_transform = False\n            self.underlying_transform = mtransforms.Affine2D().scale(10, 10)\n\n        def transform_path_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform_path(path)\n        transform_path = transform_path_non_affine\n\n        def transform_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform(path)\n        transform = transform_non_affine\n\n    my_trans = AssertingNonAffineTransform()\n    ax = plt.axes()\n    plt.plot(np.arange(10), transform=my_trans + ax.transData)\n    plt.draw()\n    # enable the transform to raise an exception if it's non-affine transform\n    # method is triggered again.\n    my_trans.raise_on_transform = True\n    ax.transAxes.invalidate()\n    plt.draw()\n\n\ndef test_external_transform_api():\n    class ScaledBy:\n        def __init__(self, scale_factor):\n            self._scale_factor = scale_factor\n\n        def _as_mpl_transform(self, axes):\n            return (mtransforms.Affine2D().scale(self._scale_factor)\n                    + axes.transData)\n\n    ax = plt.axes()\n    line, = plt.plot(np.arange(10), transform=ScaledBy(10))\n    ax.set_xlim(0, 100)\n    ax.set_ylim(0, 100)\n    # assert that the top transform of the line is the scale transform.\n    assert_allclose(line.get_transform()._a.get_matrix(),\n                    mtransforms.Affine2D().scale(10).get_matrix())\n\n\n@image_comparison(['pre_transform_data'], remove_text=True, style='mpl20',\n                  tol=0.05)\ndef test_pre_transform_plotting():\n    # a catch-all for as many as"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ransform(points)\n    expected = np.array([[5, 0], [5, 0], [5, 0]])\n    assert_almost_equal(actual, expected)\n\n    t = mtransforms.Affine2D.from_values(0, 0, 0, 0, 0, 6)\n    actual = t.transform(points)\n    expected = np.array([[0, 6], [0, 6], [0, 6]])\n    assert_almost_equal(actual, expected)\n\n\ndef test_affine_inverted_invalidated():\n    # Ensure that the an affine transform is not declared valid on access\n    point = [1.0, 1.0]\n    t = mtransforms.Affine2D()\n\n    assert_almost_equal(point, t.transform(t.inverted().transform(point)))\n    # Change and access the transform\n    t.translate(1.0, 1.0).get_matrix()\n    assert_almost_equal(point, t.transform(t.inverted().transform(point)))\n\n\ndef test_clipping_of_log():\n    # issue 804\n    path = Path._create_closed([(0.2, -99), (0.4, -99), (0.4, 20), (0.2, 20)])\n    # something like this happens in plotting logarithmic histograms\n    trans = mtransforms.BlendedGenericTransform(\n        mtransforms.Affine2D(), scale.LogTransform(10, 'clip'))\n    tpath = trans.transform_path_non_affine(path)\n    result = tpath.iter_segments(trans.get_affine(),\n                                 clip=(0, 0, 100, 100),\n                                 simplify=False)\n    tpoints, tcodes = zip(*result)\n    assert_allclose(tcodes, path.codes[:-1])  # No longer closed.\n\n\nclass NonAffineForTest(mtransforms.Transform):\n    \"\"\"\n    A class which looks like a non affine transform, but does whatever\n    the given transform does (even if it is affine). This is very useful\n    for testing NonAffine behaviour with a simple Affine transform.\n\n    \"\"\"\n    is_affine = False\n    output_dims = 2\n    input_dims = 2\n\n    def __init__(self, real_trans, *args, **kwargs):\n        self.real_trans = real_trans\n        super().__init__(*args, **kwargs)\n\n    def transform_non_affine(self, values):\n        return self.real_trans.transform(values)\n\n    def transform_path_non_affine(self, path):\n        return self.real_trans.transform_path(path)\n\n\nclass TestBasicTransform"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       [5.0, 1.0, 0.0],\n                           [0.0, 0.0, 1.0]])\n        after = np.array([[1.0, 3.0, 0.0],\n                          [5.0, 1.0, 0.0],\n                          [0.0, 0.0, 1.0]])\n\n        # Translation and skew present\n        base = mtransforms.Affine2D.from_values(1, 5, 4, 1, 2, 3)\n        t = mtransforms.AffineDeltaTransform(base)\n        assert_array_equal(t.get_matrix(), before)\n\n        # Mess with the internal structure of `base` without invalidating\n        # This should not affect this transform because it's a passthrough:\n        # it's always invalid\n        base.get_matrix()[0, 1:] = 3\n        assert_array_equal(t.get_matrix(), after)\n\n        # Invalidate the base\n        base.invalidate()\n        assert_array_equal(t.get_matrix(), after)\n\n\ndef test_non_affine_caching():\n    class AssertingNonAffineTransform(mtransforms.Transform):\n        \"\"\"\n        This transform raises an assertion error when called when it\n        shouldn't be and ``self.raise_on_transform`` is True.\n\n        \"\"\"\n        input_dims = output_dims = 2\n        is_affine = False\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.raise_on_transform = False\n            self.underlying_transform = mtransforms.Affine2D().scale(10, 10)\n\n        def transform_path_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform_path(path)\n        transform_path = transform_path_non_affine\n\n        def transform_non_affine(self, path):\n            assert not self.raise_on_transform, \\\n                'Invalidated affine part of transform unnecessarily.'\n            return self.underlying_transform.transform(path)\n        transform = transform_non_affine\n\n    my_trans = AssertingNonAffineTransform()\n    ax = plt.axes()\n    plt.plot(np.arange(10), transform=my_trans + ax.transData)\n    "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "      b1 = copy.copy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n    def test_deepcopy(self):\n        a = mtransforms.Affine2D()\n        b = mtransforms.Affine2D()\n        s = a + b\n        # Updating a dependee shouldn't invalidate a deepcopy of the dependent.\n        s.get_matrix()  # resolve it.\n        s1 = copy.deepcopy(s)\n        assert not s._invalid and not s1._invalid\n        a.translate(1, 2)\n        assert s._invalid and not s1._invalid\n        assert_array_equal(s1.get_matrix(), mtransforms.Affine2D().get_matrix())\n        # Updating a deepcopy of a dependee shouldn't invalidate a dependent.\n        s.get_matrix()  # resolve it.\n        b1 = copy.deepcopy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n\nclass TestAffineDeltaTransform:\n    def test_invalidate(self):\n        before = np.array([[1.0, 4.0, 0.0],\n                           [5.0, 1.0, 0.0],\n                           [0.0, 0.0, 1.0]])\n        after = np.array([[1.0, 3.0, 0.0],\n                          [5.0, 1.0, 0.0],\n                          [0.0, 0.0, 1.0]])\n\n        # Translation and skew present\n        base = mtransforms.Affine2D.from_values(1, 5, 4, 1, 2, 3)\n        t = mtransforms.AffineDeltaTransform(base)\n        assert_array_equal(t.get_matrix(), before)\n\n        # Mess with the internal structure of `base` without invalidating\n        # This should not affect this transform because it's a passthrough:\n        # it's always invalid\n        base.get_matrix()[0, 1:] = 3\n        assert_array_equal(t.get_matrix(), after)\n\n        # Invalidate the base\n        base.invalidate()\n        assert_array_equal(t.get_matrix(), after)\n\n\ndef test_non_affine_caching():\n    class AssertingNonAffineTransform(mtransforms.Transform):\n        \"\"\"\n        This transform raises an assertion error when called when it\n        shouldn't be and ``self.raise_on_t"}, {"start_line": 60000, "end_line": 62000, "belongs_to": {"file_name": "transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "d.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix\n        # note we do not wrap other properties here since the transform's\n        # child can be changed with WrappedTransform.set and so checking\n        # is_affine and other such properties may be dangerous.\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0\n\n    input_dims = property(lambda self: self._child.input_dims)\n    output_dims = property(lambda self: self._child.output_dims)\n    is_affine = property(lambda self: self._child.is_affine)\n    is_separable = property(lambda self: self._child.is_separable)\n    has_inverse = property(lambda self: self._child.has_inverse)\n\n\nclass AffineBase(Transform):\n    \"\"\"\n    The base class of all affine transformations of any number of dimensions.\n    \"\"\"\n    is_affine = True\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._inverted = None\n\n    def __array__(self, *args, **kwargs):\n        # optimises the access of the transform matrix vs. the superclass\n        return self.get_matrix()\n\n    def __eq__(self, other):\n        if getattr(other, \"is_affine\", False) and hasattr(other, \"get_matrix\"):\n            return (self.get_matrix() == other.get_matrix()).all()\n        return NotImplemented\n\n    def transform(self, values):\n        # docstring inherited\n        return self.transform_affine(values)\n\n    def transform_affine(self, values):\n        # docstring inherited\n        raise NotImplementedError('Affine subclasses should override this '\n                                  'method.')\n\n    def transform_non_affine(self, values):\n        # docstring inherited\n        return values\n\n    def transform_path(self, path):"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ":\n    def setup_method(self):\n\n        self.ta1 = mtransforms.Affine2D(shorthand_name='ta1').rotate(np.pi / 2)\n        self.ta2 = mtransforms.Affine2D(shorthand_name='ta2').translate(10, 0)\n        self.ta3 = mtransforms.Affine2D(shorthand_name='ta3').scale(1, 2)\n\n        self.tn1 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn1')\n        self.tn2 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn2')\n        self.tn3 = NonAffineForTest(mtransforms.Affine2D().translate(1, 2),\n                                    shorthand_name='tn3')\n\n        # creates a transform stack which looks like ((A, (N, A)), A)\n        self.stack1 = (self.ta1 + (self.tn1 + self.ta2)) + self.ta3\n        # creates a transform stack which looks like (((A, N), A), A)\n        self.stack2 = self.ta1 + self.tn1 + self.ta2 + self.ta3\n        # creates a transform stack which is a subset of stack2\n        self.stack2_subset = self.tn1 + self.ta2 + self.ta3\n\n        # when in debug, the transform stacks can produce dot images:\n#        self.stack1.write_graphviz(file('stack1.dot', 'w'))\n#        self.stack2.write_graphviz(file('stack2.dot', 'w'))\n#        self.stack2_subset.write_graphviz(file('stack2_subset.dot', 'w'))\n\n    def test_transform_depth(self):\n        assert self.stack1.depth == 4\n        assert self.stack2.depth == 4\n        assert self.stack2_subset.depth == 3\n\n    def test_left_to_right_iteration(self):\n        stack3 = (self.ta1 + (self.tn1 + (self.ta2 + self.tn2))) + self.ta3\n#        stack3.write_graphviz(file('stack3.dot', 'w'))\n\n        target_transforms = [stack3,\n                             (self.tn1 + (self.ta2 + self.tn2)) + self.ta3,\n                             (self.ta2 + self.tn2) + self.ta3,\n                             self.tn2 + self.ta3,\n                             self.ta3,\n                             ]\n        r = [rh for _, rh in stack3."}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n                                  [[69, -88], [78, -90], [81, -84]])\n\n        trans = (Affine2D().translate(23, 42)\n                 .skew_deg(26.5650512, 14.0362435))  # ~atan(0.5), ~atan(0.25)\n        trans_added = (Affine2D().translate(23, 42) +\n                       Affine2D().skew_deg(26.5650512, 14.0362435))\n        assert_array_equal(trans.get_matrix(), trans_added.get_matrix())\n        assert_array_almost_equal(trans.transform(self.single_point), [45.5, 49])\n        assert_array_almost_equal(trans.transform(self.multiple_points),\n                                  [[45, 49.75], [48.5, 51.5], [48, 48.75]])\n\n    def test_invalid_transform(self):\n        t = mtransforms.Affine2D()\n        # There are two different exceptions, since the wrong number of\n        # dimensions is caught when constructing an array_view, and that\n        # raises a ValueError, and a wrong shape with a possible number\n        # of dimensions is caught by our CALL_CPP macro, which always\n        # raises the less precise RuntimeError.\n        with pytest.raises(ValueError):\n            t.transform(1)\n        with pytest.raises(ValueError):\n            t.transform([[[1]]])\n        with pytest.raises(RuntimeError):\n            t.transform([])\n        with pytest.raises(RuntimeError):\n            t.transform([1])\n        with pytest.raises(ValueError):\n            t.transform([[1]])\n        with pytest.raises(ValueError):\n            t.transform([[1, 2, 3]])\n\n    def test_copy(self):\n        a = mtransforms.Affine2D()\n        b = mtransforms.Affine2D()\n        s = a + b\n        # Updating a dependee should invalidate a copy of the dependent.\n        s.get_matrix()  # resolve it.\n        s1 = copy.copy(s)\n        assert not s._invalid and not s1._invalid\n        a.translate(1, 2)\n        assert s._invalid and s1._invalid\n        assert (s1.get_matrix() == a.get_matrix()).all()\n        # Updating a copy of a dependee shouldn't invalidate a dependent.\n        s.get_matrix()  # resolve it.\n  "}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "f.stack2)\n        x, y = blend.contains_branch_seperately(self.stack2_subset)\n        stack_blend = self.tn3 + blend\n        sx, sy = stack_blend.contains_branch_seperately(self.stack2_subset)\n        assert x is sx is False\n        assert y is sy is True\n\n    def test_affine_simplification(self):\n        # tests that a transform stack only calls as much is absolutely\n        # necessary \"non-affine\" allowing the best possible optimization with\n        # complex transformation stacks.\n        points = np.array([[0, 0], [10, 20], [np.nan, 1], [-1, 0]],\n                          dtype=np.float64)\n        na_pts = self.stack1.transform_non_affine(points)\n        all_pts = self.stack1.transform(points)\n\n        na_expected = np.array([[1., 2.], [-19., 12.],\n                                [np.nan, np.nan], [1., 1.]], dtype=np.float64)\n        all_expected = np.array([[11., 4.], [-9., 24.],\n                                 [np.nan, np.nan], [11., 2.]],\n                                dtype=np.float64)\n\n        # check we have the expected results from doing the affine part only\n        assert_array_almost_equal(na_pts, na_expected)\n        # check we have the expected results from a full transformation\n        assert_array_almost_equal(all_pts, all_expected)\n        # check we have the expected results from doing the transformation in\n        # two steps\n        assert_array_almost_equal(self.stack1.transform_affine(na_pts),\n                                  all_expected)\n        # check that getting the affine transformation first, then fully\n        # transforming using that yields the same result as before.\n        assert_array_almost_equal(self.stack1.get_affine().transform(na_pts),\n                                  all_expected)\n\n        # check that the affine part of stack1 & stack2 are equivalent\n        # (i.e. the optimization is working)\n        expected_result = (self.ta2 + self.ta3).get_matrix()\n        result = self.stack1.get_affine().get_matrix()\n        "}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "test_transforms.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "the less precise RuntimeError.\n        with pytest.raises(ValueError):\n            t.transform(1)\n        with pytest.raises(ValueError):\n            t.transform([[[1]]])\n        with pytest.raises(RuntimeError):\n            t.transform([])\n        with pytest.raises(RuntimeError):\n            t.transform([1])\n        with pytest.raises(ValueError):\n            t.transform([[1]])\n        with pytest.raises(ValueError):\n            t.transform([[1, 2, 3]])\n\n    def test_copy(self):\n        a = mtransforms.Affine2D()\n        b = mtransforms.Affine2D()\n        s = a + b\n        # Updating a dependee should invalidate a copy of the dependent.\n        s.get_matrix()  # resolve it.\n        s1 = copy.copy(s)\n        assert not s._invalid and not s1._invalid\n        a.translate(1, 2)\n        assert s._invalid and s1._invalid\n        assert (s1.get_matrix() == a.get_matrix()).all()\n        # Updating a copy of a dependee shouldn't invalidate a dependent.\n        s.get_matrix()  # resolve it.\n        b1 = copy.copy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n    def test_deepcopy(self):\n        a = mtransforms.Affine2D()\n        b = mtransforms.Affine2D()\n        s = a + b\n        # Updating a dependee shouldn't invalidate a deepcopy of the dependent.\n        s.get_matrix()  # resolve it.\n        s1 = copy.deepcopy(s)\n        assert not s._invalid and not s1._invalid\n        a.translate(1, 2)\n        assert s._invalid and not s1._invalid\n        assert_array_equal(s1.get_matrix(), mtransforms.Affine2D().get_matrix())\n        # Updating a deepcopy of a dependee shouldn't invalidate a dependent.\n        s.get_matrix()  # resolve it.\n        b1 = copy.deepcopy(b)\n        b1.translate(3, 4)\n        assert not s._invalid\n        assert_array_equal(s.get_matrix(), a.get_matrix())\n\n\nclass TestAffineDeltaTransform:\n    def test_invalidate(self):\n        before = np.array([[1.0, 4.0, 0.0],\n                    "}], "retrieved_count": 10, "cost_time": 0.9233388900756836}
{"question": "Where is the _update_prop method that is called by update_prop in HandlerRegularPolyCollection defined, and what is its inheritance chain?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "dle.set_linestyle(dashes)\n        legend_handle.set_linewidth(lw)\n\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        # docstring inherited\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n        ydata = np.full_like(xdata, (height - ydescent) / 2)\n        legline = Line2D(xdata, ydata)\n\n        self.update_prop(legline, orig_handle, legend)\n        legline.set_transform(trans)\n\n        return [legline]\n\n\nclass HandlerRegularPolyCollection(HandlerNpointsYoffsets):\n    r\"\"\"Handler for `.RegularPolyCollection`\\s.\"\"\"\n\n    def __init__(self, yoffsets=None, sizes=None, **kwargs):\n        super().__init__(yoffsets=yoffsets, **kwargs)\n\n        self._sizes = sizes\n\n    def get_numpoints(self, legend):\n        if self._numpoints is None:\n            return legend.scatterpoints\n        else:\n            return self._numpoints\n\n    def get_sizes(self, legend, orig_handle,\n                  xdescent, ydescent, width, height, fontsize):\n        if self._sizes is None:\n            handle_sizes = orig_handle.get_sizes()\n            if not len(handle_sizes):\n                handle_sizes = [1]\n            size_max = max(handle_sizes) * legend.markerscale ** 2\n            size_min = min(handle_sizes) * legend.markerscale ** 2\n\n            numpoints = self.get_numpoints(legend)\n            if numpoints < 4:\n                sizes = [.5 * (size_max + size_min), size_max,\n                         size_min][:numpoints]\n            else:\n                rng = (size_max - size_min)\n                sizes = rng * np.linspace(0, 1, numpoints) + size_min\n        else:\n            sizes = self._sizes\n\n        return sizes\n\n    def update_prop(self, legend_handle, orig_handle, legend):\n\n        self._update_prop(legend_handle, orig_handle)\n\n        legend_handle.set_figure(legend.get_figure(root=False))\n        # legend._"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "                 xdescent, ydescent, width, height, fontsize, trans):\n        # docstring inherited\n        if orig_handle.get_fill() or (orig_handle.get_hatch() is not None):\n            p = self._create_patch(orig_handle, xdescent, ydescent, width,\n                                   height)\n            self.update_prop(p, orig_handle, legend)\n        else:\n            p = self._create_line(orig_handle, width, height)\n        p.set_transform(trans)\n        return [p]\n\n\nclass HandlerLineCollection(HandlerLine2D):\n    \"\"\"\n    Handler for `.LineCollection` instances.\n    \"\"\"\n    def get_numpoints(self, legend):\n        if self._numpoints is None:\n            return legend.scatterpoints\n        else:\n            return self._numpoints\n\n    def _default_update_prop(self, legend_handle, orig_handle):\n        lw = orig_handle.get_linewidths()[0]\n        dashes = orig_handle._us_linestyles[0]\n        color = orig_handle.get_colors()[0]\n        legend_handle.set_color(color)\n        legend_handle.set_linestyle(dashes)\n        legend_handle.set_linewidth(lw)\n\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        # docstring inherited\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n        ydata = np.full_like(xdata, (height - ydescent) / 2)\n        legline = Line2D(xdata, ydata)\n\n        self.update_prop(legline, orig_handle, legend)\n        legline.set_transform(trans)\n\n        return [legline]\n\n\nclass HandlerRegularPolyCollection(HandlerNpointsYoffsets):\n    r\"\"\"Handler for `.RegularPolyCollection`\\s.\"\"\"\n\n    def __init__(self, yoffsets=None, sizes=None, **kwargs):\n        super().__init__(yoffsets=yoffsets, **kwargs)\n\n        self._sizes = sizes\n\n    def get_numpoints(self, legend):\n        if self._numpoints is None:\n            return legend.scatterpoints\n        else:\n            return self._nump"}, {"start_line": 27000, "end_line": 29000, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "reate_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n        # docstring inherited\n        handler_map = legend.get_legend_handler_map()\n\n        if self._ndivide is None:\n            ndivide = len(orig_handle)\n        else:\n            ndivide = self._ndivide\n\n        if self._pad is None:\n            pad = legend.borderpad * fontsize\n        else:\n            pad = self._pad * fontsize\n\n        if ndivide > 1:\n            width = (width - pad * (ndivide - 1)) / ndivide\n\n        xds_cycle = cycle(xdescent - (width + pad) * np.arange(ndivide))\n\n        a_list = []\n        for handle1 in orig_handle:\n            handler = legend.get_legend_handler(handler_map, handle1)\n            _a_list = handler.create_artists(\n                legend, handle1,\n                next(xds_cycle), ydescent, width, height, fontsize, trans)\n            a_list.extend(_a_list)\n\n        return a_list\n\n\nclass HandlerPolyCollection(HandlerBase):\n    \"\"\"\n    Handler for `.PolyCollection` used in `~.Axes.fill_between` and\n    `~.Axes.stackplot`.\n    \"\"\"\n    def _update_prop(self, legend_handle, orig_handle):\n        def first_color(colors):\n            if colors.size == 0:\n                return (0, 0, 0, 0)\n            return tuple(colors[0])\n\n        def get_first(prop_array):\n            if len(prop_array):\n                return prop_array[0]\n            else:\n                return None\n\n        # orig_handle is a PolyCollection and legend_handle is a Patch.\n        # Directly set Patch color attributes (must be RGBA tuples).\n        legend_handle._facecolor = first_color(orig_handle.get_facecolor())\n        legend_handle._edgecolor = first_color(orig_handle.get_edgecolor())\n        legend_handle._hatch_color = first_color(orig_handle.get_hatchcolor())\n        legend_handle._original_facecolor = orig_handle._original_facecolor\n        legend_handle._original_edgecolor = orig_handle._original_edgecolor\n  "}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "collections.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s():\n            return\n        # Allow possibility to call 'self.set_array(None)'.\n        if self._A is not None:\n            # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)\n            if self._A.ndim > 1 and not isinstance(self, _MeshData):\n                raise ValueError('Collections can only map rank 1 arrays')\n            if np.iterable(self._alpha):\n                if self._alpha.size != self._A.size:\n                    raise ValueError(\n                        f'Data array shape, {self._A.shape} '\n                        'is incompatible with alpha array shape, '\n                        f'{self._alpha.shape}. '\n                        'This can occur with the deprecated '\n                        'behavior of the \"flat\" shading option, '\n                        'in which a row and/or column of the data '\n                        'array is dropped.')\n                # pcolormesh, scatter, maybe others flatten their _A\n                self._alpha = self._alpha.reshape(self._A.shape)\n            self._mapped_colors = self.to_rgba(self._A, self._alpha)\n\n        if self._face_is_mapped:\n            self._facecolors = self._mapped_colors\n        else:\n            self._set_facecolor(self._original_facecolor)\n        if self._edge_is_mapped:\n            self._edgecolors = self._mapped_colors\n        else:\n            self._set_edgecolor(self._original_edgecolor)\n        self.stale = True\n\n    def get_fill(self):\n        \"\"\"Return whether face is colored.\"\"\"\n        return not cbook._str_lower_equal(self._original_facecolor, \"none\")\n\n    def update_from(self, other):\n        \"\"\"Copy properties from other to self.\"\"\"\n\n        artist.Artist.update_from(self, other)\n        self._antialiaseds = other._antialiaseds\n        self._mapped_colors = other._mapped_colors\n        self._edge_is_mapped = other._edge_is_mapped\n        self._original_edgecolor = other._original_edgecolor\n        self._edgecolors = other._edgecolors\n        self._face_is_mapped = o"}, {"start_line": 25000, "end_line": 27000, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "xdata_marker, ydata[:len(xdata_marker)])\n        self.update_prop(leg_markerline, markerline, legend)\n\n        leg_stemlines = [Line2D([x, x], [bottom, y])\n                         for x, y in zip(xdata_marker, ydata)]\n\n        if using_linecoll:\n            # change the function used by update_prop() from the default\n            # to one that handles LineCollection\n            with cbook._setattr_cm(\n                    self, _update_prop_func=self._copy_collection_props):\n                for line in leg_stemlines:\n                    self.update_prop(line, stemlines, legend)\n\n        else:\n            for lm, m in zip(leg_stemlines, stemlines):\n                self.update_prop(lm, m, legend)\n\n        leg_baseline = Line2D([np.min(xdata), np.max(xdata)],\n                              [bottom, bottom])\n        self.update_prop(leg_baseline, baseline, legend)\n\n        artists = [*leg_stemlines, leg_baseline, leg_markerline]\n        for artist in artists:\n            artist.set_transform(trans)\n        return artists\n\n    def _copy_collection_props(self, legend_handle, orig_handle):\n        \"\"\"\n        Copy properties from the `.LineCollection` *orig_handle* to the\n        `.Line2D` *legend_handle*.\n        \"\"\"\n        legend_handle.set_color(orig_handle.get_color()[0])\n        legend_handle.set_linestyle(orig_handle.get_linestyle()[0])\n\n\nclass HandlerTuple(HandlerBase):\n    \"\"\"\n    Handler for Tuple.\n    \"\"\"\n\n    def __init__(self, ndivide=1, pad=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        ndivide : int or None, default: 1\n            The number of sections to divide the legend area into.  If None,\n            use the length of the input tuple.\n        pad : float, default: :rc:`legend.borderpad`\n            Padding in units of fraction of font size.\n        **kwargs\n            Keyword arguments forwarded to `.HandlerBase`.\n        \"\"\"\n        self._ndivide = ndivide\n        self._pad = pad\n        super().__init__(**kwargs)\n\n    def c"}, {"start_line": 28000, "end_line": 29820, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ction(HandlerBase):\n    \"\"\"\n    Handler for `.PolyCollection` used in `~.Axes.fill_between` and\n    `~.Axes.stackplot`.\n    \"\"\"\n    def _update_prop(self, legend_handle, orig_handle):\n        def first_color(colors):\n            if colors.size == 0:\n                return (0, 0, 0, 0)\n            return tuple(colors[0])\n\n        def get_first(prop_array):\n            if len(prop_array):\n                return prop_array[0]\n            else:\n                return None\n\n        # orig_handle is a PolyCollection and legend_handle is a Patch.\n        # Directly set Patch color attributes (must be RGBA tuples).\n        legend_handle._facecolor = first_color(orig_handle.get_facecolor())\n        legend_handle._edgecolor = first_color(orig_handle.get_edgecolor())\n        legend_handle._hatch_color = first_color(orig_handle.get_hatchcolor())\n        legend_handle._original_facecolor = orig_handle._original_facecolor\n        legend_handle._original_edgecolor = orig_handle._original_edgecolor\n        legend_handle._fill = orig_handle.get_fill()\n        legend_handle._hatch = orig_handle.get_hatch()\n        # Setters are fine for the remaining attributes.\n        legend_handle.set_linewidth(get_first(orig_handle.get_linewidths()))\n        legend_handle.set_linestyle(get_first(orig_handle.get_linestyles()))\n        legend_handle.set_transform(get_first(orig_handle.get_transforms()))\n        # Alpha is already taken into account by the color attributes.\n\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        # docstring inherited\n        p = Rectangle(xy=(-xdescent, -ydescent),\n                      width=width, height=height)\n        self.update_prop(p, orig_handle, legend)\n        p.set_transform(trans)\n        return [p]\n"}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "collections.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "shape(self._A.shape)\n            self._mapped_colors = self.to_rgba(self._A, self._alpha)\n\n        if self._face_is_mapped:\n            self._facecolors = self._mapped_colors\n        else:\n            self._set_facecolor(self._original_facecolor)\n        if self._edge_is_mapped:\n            self._edgecolors = self._mapped_colors\n        else:\n            self._set_edgecolor(self._original_edgecolor)\n        self.stale = True\n\n    def get_fill(self):\n        \"\"\"Return whether face is colored.\"\"\"\n        return not cbook._str_lower_equal(self._original_facecolor, \"none\")\n\n    def update_from(self, other):\n        \"\"\"Copy properties from other to self.\"\"\"\n\n        artist.Artist.update_from(self, other)\n        self._antialiaseds = other._antialiaseds\n        self._mapped_colors = other._mapped_colors\n        self._edge_is_mapped = other._edge_is_mapped\n        self._original_edgecolor = other._original_edgecolor\n        self._edgecolors = other._edgecolors\n        self._face_is_mapped = other._face_is_mapped\n        self._original_facecolor = other._original_facecolor\n        self._facecolors = other._facecolors\n        self._linewidths = other._linewidths\n        self._linestyles = other._linestyles\n        self._us_linestyles = other._us_linestyles\n        self._pickradius = other._pickradius\n        self._hatch = other._hatch\n        self._hatchcolors = other._hatchcolors\n\n        # update_from for scalarmappable\n        self._A = other._A\n        self.norm = other.norm\n        self.cmap = other.cmap\n        self.stale = True\n\n\nclass _CollectionWithSizes(Collection):\n    \"\"\"\n    Base class for collections that have an array of sizes.\n    \"\"\"\n    _factor = 1.0\n\n    def get_sizes(self):\n        \"\"\"\n        Return the sizes ('areas') of the elements in the collection.\n\n        Returns\n        -------\n        array\n            The 'area' of each element.\n        \"\"\"\n        return self._sizes\n\n    def set_sizes(self, sizes, dpi=72.0):\n        \"\"\"\n        Set the sizes o"}, {"start_line": 42000, "end_line": 44000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "v))\n                else:\n                    func = getattr(self, f\"set_{k}\", None)\n                    if not callable(func):\n                        raise AttributeError(\n                            errfmt.format(cls=type(self), prop_name=k),\n                            name=k)\n                    ret.append(func(v))\n        if ret:\n            self.pchanged()\n            self.stale = True\n        return ret\n\n    def update(self, props):\n        \"\"\"\n        Update this artist's properties from the dict *props*.\n\n        Parameters\n        ----------\n        props : dict\n        \"\"\"\n        return self._update_props(\n            props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n\n    def _internal_update(self, kwargs):\n        \"\"\"\n        Update artist properties without prenormalizing them, but generating\n        errors as if calling `set`.\n\n        The lack of prenormalization is to maintain backcompatibility.\n        \"\"\"\n        return self._update_props(\n            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n\n    def set(self, **kwargs):\n        # docstring and signature are auto-generated via\n        # Artist._update_set_signature_and_docstring() at the end of the\n        # module.\n        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n\n    @contextlib.contextmanager\n    def _cm_set(self, **kwargs):\n        \"\"\"\n        `.Artist.set` context-manager that restores original values at exit.\n        \"\"\"\n        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n        try:\n            self.set(**kwargs)\n            yield\n        finally:\n            self.set(**orig_vals)\n\n    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *Non"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "legend_handler.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "set_artist_props(legend_handle)\n        legend_handle.set_clip_box(None)\n        legend_handle.set_clip_path(None)\n\n    def create_collection(self, orig_handle, sizes, offsets, offset_transform):\n        return type(orig_handle)(\n            orig_handle.get_numsides(),\n            rotation=orig_handle.get_rotation(), sizes=sizes,\n            offsets=offsets, offset_transform=offset_transform,\n        )\n\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n        # docstring inherited\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n\n        ydata = self.get_ydata(legend, xdescent, ydescent,\n                               width, height, fontsize)\n\n        sizes = self.get_sizes(legend, orig_handle, xdescent, ydescent,\n                               width, height, fontsize)\n\n        p = self.create_collection(\n            orig_handle, sizes,\n            offsets=list(zip(xdata_marker, ydata)), offset_transform=trans)\n\n        self.update_prop(p, orig_handle, legend)\n        p.set_offset_transform(trans)\n        return [p]\n\n\nclass HandlerPathCollection(HandlerRegularPolyCollection):\n    r\"\"\"Handler for `.PathCollection`\\s, which are used by `~.Axes.scatter`.\"\"\"\n\n    def create_collection(self, orig_handle, sizes, offsets, offset_transform):\n        return type(orig_handle)(\n            [orig_handle.get_paths()[0]], sizes=sizes,\n            offsets=offsets, offset_transform=offset_transform,\n        )\n\n\nclass HandlerCircleCollection(HandlerRegularPolyCollection):\n    r\"\"\"Handler for `.CircleCollection`\\s.\"\"\"\n\n    def create_collection(self, orig_handle, sizes, offsets, offset_transform):\n        return type(orig_handle)(\n            sizes, offsets=offsets, offset_transform=offset_transform)\n\n\nclass HandlerErrorbar(HandlerLine2D):\n    \"\"\"Handler for Errorbars.\"\"\"\n\n    def __init__(sel"}, {"start_line": 40000, "end_line": 42000, "belongs_to": {"file_name": "artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nst sticky edges and cannot\n        cross them.  For example, if the upper data limit is 1.0, the upper\n        view limit computed by simple margin application is 1.2, but there is a\n        sticky edge at 1.1, then the actual upper view limit will be 1.1.\n\n        This attribute cannot be assigned to; however, the ``x`` and ``y``\n        lists can be modified in place as needed.\n\n        Examples\n        --------\n        >>> artist.sticky_edges.x[:] = (xmin, xmax)\n        >>> artist.sticky_edges.y[:] = (ymin, ymax)\n\n        \"\"\"\n        return self._sticky_edges\n\n    def update_from(self, other):\n        \"\"\"Copy properties from *other* to *self*.\"\"\"\n        self._transform = other._transform\n        self._transformSet = other._transformSet\n        self._visible = other._visible\n        self._alpha = other._alpha\n        self.clipbox = other.clipbox\n        self._clipon = other._clipon\n        self._clippath = other._clippath\n        self._label = other._label\n        self._sketch = other._sketch\n        self._path_effects = other._path_effects\n        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n        self.pchanged()\n        self.stale = True\n\n    def properties(self):\n        \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n        return ArtistInspector(self).properties()\n\n    def _update_props(self, props, errfmt):\n        \"\"\"\n        Helper for `.Artist.set` and `.Artist.update`.\n\n        *errfmt* is used to generate error messages for invalid property\n        names; it gets formatted with ``type(self)`` for \"{cls}\" and the\n        property name for \"{prop_name}\".\n        \"\"\"\n        ret = []\n        with cbook._setattr_cm(self, eventson=False):\n            for k, v in props.items():\n                # Allow attributes we want to be able to update through\n                # art.update, art.set, setp.\n                if k == \"axes\":\n                    ret.append(setattr(self, k, "}], "retrieved_count": 10, "cost_time": 0.9033689498901367}
{"question": "Where is the logic that determines how ticklabel offsets are calculated based on vertical and horizontal alignment properties, and which methods invoke this calculation during the rendering pipeline?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "eters\n        ----------\n        label_direction : {\"left\", \"bottom\", \"right\", \"top\"}\n\n        \"\"\"\n        self.set_default_alignment(label_direction)\n        self.set_default_angle(label_direction)\n        self._axis_direction = label_direction\n\n    def invert_axis_direction(self):\n        label_direction = self._get_opposite_direction(self._axis_direction)\n        self.set_axis_direction(label_direction)\n\n    def _get_ticklabels_offsets(self, renderer, label_direction):\n        \"\"\"\n        Calculate the ticklabel offsets from the tick and their total heights.\n\n        The offset only takes account the offset due to the vertical alignment\n        of the ticklabels: if axis direction is bottom and va is 'top', it will\n        return 0; if va is 'baseline', it will return (height-descent).\n        \"\"\"\n        whd_list = self.get_texts_widths_heights_descents(renderer)\n\n        if not whd_list:\n            return 0, 0\n\n        r = 0\n        va, ha = self.get_va(), self.get_ha()\n\n        if label_direction == \"left\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"left\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"right\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"right\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"bottom\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"bottom\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_ascent\n                pad = max_ascent + max_descent\n        elif label_direction == \"top\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"top\":\n                r = pad\n            el"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "if label_direction == \"left\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"left\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"right\":\n            pad = max(w for w, h, d in whd_list)\n            if ha == \"right\":\n                r = pad\n            elif ha == \"center\":\n                r = .5 * pad\n        elif label_direction == \"bottom\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"bottom\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_ascent\n                pad = max_ascent + max_descent\n        elif label_direction == \"top\":\n            pad = max(h for w, h, d in whd_list)\n            if va == \"top\":\n                r = pad\n            elif va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_descent\n                pad = max_ascent + max_descent\n\n        # r : offset\n        # pad : total height of the ticklabels. This will be used to\n        # calculate the pad for the axislabel.\n        return r, pad\n\n    _default_alignments = dict(left=(\"center\", \"right\"),\n                               right=(\"center\", \"left\"),\n                               bottom=(\"baseline\", \"center\"),\n                               top=(\"baseline\", \"center\"))\n\n    _default_angles = dict(left=90,\n                           right=-90,\n                           bottom=0,\n                           top=180)\n\n    def draw(self, renderer):\n        if not self.get_visible():\n            self._axislabel_pad = self._external_pad\n            return\n\n        r, total_width = self."}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "if va == \"center\":\n                r = .5 * pad\n            elif va == \"baseline\":\n                max_ascent = max(h - d for w, h, d in whd_list)\n                max_descent = max(d for w, h, d in whd_list)\n                r = max_descent\n                pad = max_ascent + max_descent\n\n        # r : offset\n        # pad : total height of the ticklabels. This will be used to\n        # calculate the pad for the axislabel.\n        return r, pad\n\n    _default_alignments = dict(left=(\"center\", \"right\"),\n                               right=(\"center\", \"left\"),\n                               bottom=(\"baseline\", \"center\"),\n                               top=(\"baseline\", \"center\"))\n\n    _default_angles = dict(left=90,\n                           right=-90,\n                           bottom=0,\n                           top=180)\n\n    def draw(self, renderer):\n        if not self.get_visible():\n            self._axislabel_pad = self._external_pad\n            return\n\n        r, total_width = self._get_ticklabels_offsets(renderer,\n                                                      self._axis_direction)\n\n        pad = self._external_pad + renderer.points_to_pixels(self.get_pad())\n        self._offset_radius = r + pad\n\n        for (x, y), a, l in self._locs_angles_labels:\n            if not l.strip():\n                continue\n            self._ref_angle = a\n            self.set_x(x)\n            self.set_y(y)\n            self.set_text(l)\n            LabelBase.draw(self, renderer)\n\n        # the value saved will be used to draw axislabel.\n        self._axislabel_pad = total_width + pad\n\n    def set_locs_angles_labels(self, locs_angles_labels):\n        self._locs_angles_labels = locs_angles_labels\n\n    def get_window_extents(self, renderer=None):\n        if renderer is None:\n            renderer = self.get_figure(root=True)._get_renderer()\n\n        if not self.get_visible():\n            self._axislabel_pad = self._external_pad\n            return []\n\n        bboxes = []\n\n        r,"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "axis3d.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "2\n            outerindex = 1\n\n        pos = _move_from_center(outeredgep, centers, labeldeltas,\n                                self._axmask())\n        olx, oly, olz = proj3d.proj_transform(*pos, self.axes.M)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.set_position((olx, oly))\n        angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy, dx)))\n        self.offsetText.set_rotation(angle)\n        # Must set rotation mode to \"anchor\" so that\n        # the alignment point is used as the \"fulcrum\" for rotation.\n        self.offsetText.set_rotation_mode('anchor')\n\n        # ----------------------------------------------------------------------\n        # Note: the following statement for determining the proper alignment of\n        # the offset text. This was determined entirely by trial-and-error\n        # and should not be in any way considered as \"the way\".  There are\n        # still some edge cases where alignment is not quite right, but this\n        # seems to be more of a geometry issue (in other words, I might be\n        # using the wrong reference points).\n        #\n        # (TT, FF, TF, FT) are the shorthand for the tuple of\n        #   (centpt[tickdir] <= pep[tickdir, outerindex],\n        #    centpt[index] <= pep[index, outerindex])\n        #\n        # Three-letters (e.g., TFT, FTT) are short-hand for the array of bools\n        # from the variable 'highs'.\n        # ---------------------------------------------------------------------\n        centpt = proj3d.proj_transform(*centers, self.axes.M)\n        if centpt[tickdir] > pep[tickdir, outerindex]:\n            # if FT and if highs has an even number of Trues\n            if (centpt[index] <= pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually, this means align right, except for the FTT case,\n                # in which offset for axis 1 and 2 are aligned left.\n                if highs.tolist() == [False, Tru"}, {"start_line": 14000, "end_line": 16000, "belongs_to": {"file_name": "axis_artist.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/axisartist", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " # docstring inherited\n        return self._axis.get_ticklabels()[0]\n\n    def set_axis_direction(self, label_direction):\n        \"\"\"\n        Adjust the text angle and text alignment of ticklabels\n        according to the Matplotlib convention.\n\n        The *label_direction* must be one of [left, right, bottom, top].\n\n        =====================    ========== ========= ========== ==========\n        Property                 left       bottom    right      top\n        =====================    ========== ========= ========== ==========\n        ticklabel angle          90         0         -90        180\n        ticklabel va             center     baseline  center     baseline\n        ticklabel ha             right      center    right      center\n        =====================    ========== ========= ========== ==========\n\n        Note that the text angles are actually relative to (90 + angle\n        of the direction to the ticklabel), which gives 0 for bottom\n        axis.\n\n        Parameters\n        ----------\n        label_direction : {\"left\", \"bottom\", \"right\", \"top\"}\n\n        \"\"\"\n        self.set_default_alignment(label_direction)\n        self.set_default_angle(label_direction)\n        self._axis_direction = label_direction\n\n    def invert_axis_direction(self):\n        label_direction = self._get_opposite_direction(self._axis_direction)\n        self.set_axis_direction(label_direction)\n\n    def _get_ticklabels_offsets(self, renderer, label_direction):\n        \"\"\"\n        Calculate the ticklabel offsets from the tick and their total heights.\n\n        The offset only takes account the offset due to the vertical alignment\n        of the ticklabels: if axis direction is bottom and va is 'top', it will\n        return 0; if va is 'baseline', it will return (height-descent).\n        \"\"\"\n        whd_list = self.get_texts_widths_heights_descents(renderer)\n\n        if not whd_list:\n            return 0, 0\n\n        r = 0\n        va, ha = self.get_va(), self.get_ha()\n\n        "}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "axis3d.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "his\n        # seems to be more of a geometry issue (in other words, I might be\n        # using the wrong reference points).\n        #\n        # (TT, FF, TF, FT) are the shorthand for the tuple of\n        #   (centpt[tickdir] <= pep[tickdir, outerindex],\n        #    centpt[index] <= pep[index, outerindex])\n        #\n        # Three-letters (e.g., TFT, FTT) are short-hand for the array of bools\n        # from the variable 'highs'.\n        # ---------------------------------------------------------------------\n        centpt = proj3d.proj_transform(*centers, self.axes.M)\n        if centpt[tickdir] > pep[tickdir, outerindex]:\n            # if FT and if highs has an even number of Trues\n            if (centpt[index] <= pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually, this means align right, except for the FTT case,\n                # in which offset for axis 1 and 2 are aligned left.\n                if highs.tolist() == [False, True, True] and index in (1, 2):\n                    align = 'left'\n                else:\n                    align = 'right'\n            else:\n                # The FF case\n                align = 'left'\n        else:\n            # if TF and if highs has an even number of Trues\n            if (centpt[index] > pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually mean align left, except if it is axis 2\n                align = 'right' if index == 2 else 'left'\n            else:\n                # The TT case\n                align = 'right'\n\n        self.offsetText.set_va('center')\n        self.offsetText.set_ha(align)\n        self.offsetText.draw(renderer)\n\n    def _draw_labels(self, renderer, edgep1, edgep2, labeldeltas, centers, dx, dy):\n        label = self._axinfo[\"label\"]\n\n        # Draw labels\n        lxyz = 0.5 * (edgep1 + edgep2)\n        lxyz = _move_from_center(lxyz, centers, labeldeltas, self._axmask())\n        tlx, tly, tlz = "}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "axis3d.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", self.axes.M)\n\n            # Get position of label\n            labeldeltas = (tick.get_pad() + default_label_offset) * points\n\n            pos[tickdir] = edgep1_tickdir\n            pos = _move_from_center(pos, centers, labeldeltas, self._axmask())\n            lx, ly, lz = proj3d.proj_transform(*pos, self.axes.M)\n\n            _tick_update_position(tick, (x1, x2), (y1, y2), (lx, ly))\n            tick.tick1line.set_linewidth(tick_lw[tick._major])\n            tick.draw(renderer)\n\n    def _draw_offset_text(self, renderer, edgep1, edgep2, labeldeltas, centers,\n                          highs, pep, dx, dy):\n        # Get general axis information:\n        info = self._axinfo\n        index = info[\"i\"]\n        juggled = info[\"juggled\"]\n        tickdir = info[\"tickdir\"]\n\n        # Which of the two edge points do we want to\n        # use for locating the offset text?\n        if juggled[2] == 2:\n            outeredgep = edgep1\n            outerindex = 0\n        else:\n            outeredgep = edgep2\n            outerindex = 1\n\n        pos = _move_from_center(outeredgep, centers, labeldeltas,\n                                self._axmask())\n        olx, oly, olz = proj3d.proj_transform(*pos, self.axes.M)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.set_position((olx, oly))\n        angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy, dx)))\n        self.offsetText.set_rotation(angle)\n        # Must set rotation mode to \"anchor\" so that\n        # the alignment point is used as the \"fulcrum\" for rotation.\n        self.offsetText.set_rotation_mode('anchor')\n\n        # ----------------------------------------------------------------------\n        # Note: the following statement for determining the proper alignment of\n        # the offset text. This was determined entirely by trial-and-error\n        # and should not be in any way considered as \"the way\".  There are\n        # still some edge cases where alignment is not quite right, but t"}, {"start_line": 90000, "end_line": 92000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'bottom':\n            # Union with extents of the bottom spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"bottom\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y0 - self.labelpad * self.get_figure(root=True).dpi / 72))\n        else:\n            # Union with extents of the top spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"top\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (x, bbox.y1 + self.labelpad * self.get_figure(root=True).dpi / 72))\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not hasattr(self, '_tick_position'):\n            self._tick_position = 'bottom'\n        if self._tick_position == 'bottom':\n            if not len(bboxes):\n                bottom = self.axes.bbox.ymin\n            else:\n                bbox = mtransforms.Bbox.union(bboxes)\n                bottom = bbox.y0\n            y = bottom - self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72\n        else:\n            if not len(bboxes2):\n     "}, {"start_line": 99000, "end_line": 101000, "belongs_to": {"file_name": "axis.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "el.set_verticalalignment(_api.check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n\n        if self.label_position == 'left':\n            # Union with extents of the left spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes, self.axes.spines.get(\"left\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x0 - self.labelpad * self.get_figure(root=True).dpi / 72, y))\n        else:\n            # Union with extents of the right spine if present, of the axes otherwise.\n            bbox = mtransforms.Bbox.union([\n                *bboxes2, self.axes.spines.get(\"right\", self.axes).get_window_extent()])\n            self.label.set_position(\n                (bbox.x1 + self.labelpad * self.get_figure(root=True).dpi / 72, y))\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, _ = self.offsetText.get_position()\n        if 'outline' in self.axes.spines:\n            # Special case for colorbars:\n            bbox = self.axes.spines['outline'].get_window_extent()\n        else:\n            bbox = self.axes.bbox\n        top = bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.get_figure(root=True).dpi / 72)\n        )\n\n    def set_"}, {"start_line": 20000, "end_line": 22000, "belongs_to": {"file_name": "axis3d.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/mpl_toolkits/mplot3d", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "e, True] and index in (1, 2):\n                    align = 'left'\n                else:\n                    align = 'right'\n            else:\n                # The FF case\n                align = 'left'\n        else:\n            # if TF and if highs has an even number of Trues\n            if (centpt[index] > pep[index, outerindex]\n                    and np.count_nonzero(highs) % 2 == 0):\n                # Usually mean align left, except if it is axis 2\n                align = 'right' if index == 2 else 'left'\n            else:\n                # The TT case\n                align = 'right'\n\n        self.offsetText.set_va('center')\n        self.offsetText.set_ha(align)\n        self.offsetText.draw(renderer)\n\n    def _draw_labels(self, renderer, edgep1, edgep2, labeldeltas, centers, dx, dy):\n        label = self._axinfo[\"label\"]\n\n        # Draw labels\n        lxyz = 0.5 * (edgep1 + edgep2)\n        lxyz = _move_from_center(lxyz, centers, labeldeltas, self._axmask())\n        tlx, tly, tlz = proj3d.proj_transform(*lxyz, self.axes.M)\n        self.label.set_position((tlx, tly))\n        if self.get_rotate_label(self.label.get_text()):\n            angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy, dx)))\n            self.label.set_rotation(angle)\n        self.label.set_va(label['va'])\n        self.label.set_ha(label['ha'])\n        self.label.set_rotation_mode(label['rotation_mode'])\n        self.label.draw(renderer)\n\n    @artist.allow_rasterization\n    def draw(self, renderer):\n        self.label._transform = self.axes.transData\n        self.offsetText._transform = self.axes.transData\n        renderer.open_group(\"axis3d\", gid=self.get_gid())\n\n        # Get general axis information:\n        mins, maxs, tc, highs = self._get_coord_info()\n        centers, deltas = self._calc_centers_deltas(maxs, mins)\n\n        # Calculate offset distances\n        # A rough estimate; points are ambiguous since 3D plots rotate\n        reltoinches = self.get_figure(root=False).dpi_scale_trans.i"}], "retrieved_count": 10, "cost_time": 0.8834524154663086}
{"question": "Where is the chain of responsibility that connects the add_toolitem method's position calculation logic through _get_tool_pos to the separator management in _groups, and how does this chain determine the final insertion index for tools?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 45000, "end_line": 47000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = (pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool)\n        return pos\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n     "}, {"start_line": 46000, "end_line": 48000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()\n\n    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems.pop(name, []):\n            self.DeleteTool(tool.Id)\n\n    def set_message(self, s):\n        self._label_text.SetLabel(s)\n\n\n@backend_tools._register_tool_class(_FigureCanvasWxBase)\nclass ConfigureSubplotsWx(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.config"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_"}, {"start_line": 124000, "end_line": 126000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "       position : int, default: -1\n            The position within the group to place this tool.\n        \"\"\"\n        tool = self.toolmanager.get_tool(tool)\n        image = self._get_image_filename(tool)\n        toggle = getattr(tool, 'toggled', None) is not None\n        self.add_toolitem(tool.name, group, position,\n                          image, tool.description, toggle)\n        if toggle:\n            self.toolmanager.toolmanager_connect('tool_trigger_%s' % tool.name,\n                                                 self._tool_toggled_cbk)\n            # If initially toggled\n            if tool.toggled:\n                self.toggle_toolitem(tool.name, True)\n\n    def _get_image_filename(self, tool):\n        \"\"\"Resolve a tool icon's filename.\"\"\"\n        if not tool.image:\n            return None\n        if os.path.isabs(tool.image):\n            filename = tool.image\n        else:\n            if \"image\" in getattr(tool, \"__dict__\", {}):\n                raise ValueError(\"If 'tool.image' is an instance variable, \"\n                                 \"it must be an absolute path\")\n            for cls in type(tool).__mro__:\n                if \"image\" in vars(cls):\n                    try:\n                        src = inspect.getfile(cls)\n                        break\n                    except (OSError, TypeError):\n                        raise ValueError(\"Failed to locate source file \"\n                                         \"where 'tool.image' is defined\") from None\n            else:\n                raise ValueError(\"Failed to find parent class defining 'tool.image'\")\n            filename = str(pathlib.Path(src).parent / tool.image)\n        for filename in [filename, filename + self._icon_extension]:\n            if os.path.isfile(filename):\n                return os.path.abspath(filename)\n        for fname in [  # Fallback; once deprecation elapses.\n            tool.image,\n            tool.image + self._icon_extension,\n            cbook._get_data_path(\"images\", tool.image"}, {"start_line": 44000, "end_line": 46000, "belongs_to": {"file_name": "backend_wx.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ry_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)\n\n\n# tools for matplotlib.backend_managers.ToolManager:\n\nclass ToolbarWx(ToolContainerBase, wx.ToolBar):\n    _icon_extension = '.svg'\n\n    def __init__(self, toolmanager, parent=None, style=wx.TB_BOTTOM):\n        if parent is None:\n            parent = toolmanager.canvas.GetParent()\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them.\n\n    def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = (pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool)\n        return pos\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the "}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "backend_gtk4.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self._tool_box.append(sep)\n\n    def set_message(self, s):\n        self._message.set_label(s)\n\n\n@backend_tools._register_tool_class(FigureCanvasGTK4)\nclass SaveFigureGTK4(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classi"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "backend_gtk3.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "nd(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        for toolitem, _signal in self._toolitems.pop(name, []):\n            for group in self._groups:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n\n    def _add_separator(self):\n"}, {"start_line": 125000, "end_line": 127000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " an instance variable, \"\n                                 \"it must be an absolute path\")\n            for cls in type(tool).__mro__:\n                if \"image\" in vars(cls):\n                    try:\n                        src = inspect.getfile(cls)\n                        break\n                    except (OSError, TypeError):\n                        raise ValueError(\"Failed to locate source file \"\n                                         \"where 'tool.image' is defined\") from None\n            else:\n                raise ValueError(\"Failed to find parent class defining 'tool.image'\")\n            filename = str(pathlib.Path(src).parent / tool.image)\n        for filename in [filename, filename + self._icon_extension]:\n            if os.path.isfile(filename):\n                return os.path.abspath(filename)\n        for fname in [  # Fallback; once deprecation elapses.\n            tool.image,\n            tool.image + self._icon_extension,\n            cbook._get_data_path(\"images\", tool.image),\n            cbook._get_data_path(\"images\", tool.image + self._icon_extension),\n        ]:\n            if os.path.isfile(fname):\n                _api.warn_deprecated(\n                    \"3.9\", message=f\"Loading icon {tool.image!r} from the current \"\n                    \"directory or from Matplotlib's image directory.  This behavior \"\n                    \"is deprecated since %(since)s and will be removed in %(removal)s; \"\n                    \"Tool.image should be set to a path relative to the Tool's source \"\n                    \"file, or to an absolute path.\")\n                return os.path.abspath(fname)\n\n    def trigger_tool(self, name):\n        \"\"\"\n        Trigger the tool.\n\n        Parameters\n        ----------\n        name : str\n            Name (id) of the tool triggered from within the container.\n        \"\"\"\n        self.toolmanager.trigger_tool(name, sender=self)\n\n    def add_toolitem(self, name, group, position, image, description, toggle):\n        \"\"\"\n        A hook to add "}, {"start_line": 39000, "end_line": 41000, "belongs_to": {"file_name": "backend_qt.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))\n\n    def _add_to_group(self, group, name, button, position):\n        gr = self._groups.get(group, [])\n        if not gr:\n            sep = self.insertSeparator(self._message_action)\n            gr.append(sep)\n        before = gr[position]\n        widget = self.insertWidget(before, button)\n        gr.insert(position, widget)\n        self._groups[group] = gr\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)\n\n    def remove_toolitem(self, name):\n        for button, handler in self._toolitems.pop(name, []):\n            button.setParent(None)\n\n    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass ConfigureSubplotsQt(backend_tools.ConfigureSubplotsBase):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._subplot_dialog = None\n\n    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(self)\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure"}, {"start_line": 126000, "end_line": 128000, "belongs_to": {"file_name": "backend_bases.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "),\n            cbook._get_data_path(\"images\", tool.image + self._icon_extension),\n        ]:\n            if os.path.isfile(fname):\n                _api.warn_deprecated(\n                    \"3.9\", message=f\"Loading icon {tool.image!r} from the current \"\n                    \"directory or from Matplotlib's image directory.  This behavior \"\n                    \"is deprecated since %(since)s and will be removed in %(removal)s; \"\n                    \"Tool.image should be set to a path relative to the Tool's source \"\n                    \"file, or to an absolute path.\")\n                return os.path.abspath(fname)\n\n    def trigger_tool(self, name):\n        \"\"\"\n        Trigger the tool.\n\n        Parameters\n        ----------\n        name : str\n            Name (id) of the tool triggered from within the container.\n        \"\"\"\n        self.toolmanager.trigger_tool(name, sender=self)\n\n    def add_toolitem(self, name, group, position, image, description, toggle):\n        \"\"\"\n        A hook to add a toolitem to the container.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to add an element to the toolbar.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolContainerBase.add_tool`.\n\n        The callback associated with the button click event\n        must be *exactly* ``self.trigger_tool(name)``.\n\n        Parameters\n        ----------\n        name : str\n            Name of the tool to add, this gets used as the tool's ID and as the\n            default label of the buttons.\n        group : str\n            Name of the group that this tool belongs to.\n        position : int\n            Position of the tool within its group, if -1 it goes at the end.\n        image : str\n            Filename of the image for the button or `None`.\n        description : str\n            Description of the tool, used for the tooltips."}], "retrieved_count": 10, "cost_time": 1.0238687992095947}
{"question": "Where does the cycler property cycle mechanism propagate through the data flow when ax.plot() is called multiple times, and what control flow ensures that the linestyle values are correctly sequenced across successive plot invocations?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_cycles.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ay(['r', 'g', 'y']),\n                      marker=iter(['.', '*', 'x']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_color() for l in ax.lines] == ['r', 'g', 'y', 'r']\n    assert [l.get_marker() for l in ax.lines] == ['.', '*', 'x', '.']\n\n\ndef test_linestylecycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('ls', ['-', '--', ':']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_linestyle() for l in ax.lines] == ['-', '--', ':', '-']\n\n\ndef test_fillcycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('c',  ['r', 'g', 'y']) +\n                      cycler('hatch', ['xx', 'O', '|-']) +\n                      cycler('linestyle', ['-', '--', ':']))\n    for _ in range(4):\n        ax.fill(range(10), range(10))\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in ['r', 'g', 'y', 'r']])\n    assert [p.get_hatch() for p in ax.patches] == ['xx', 'O', '|-', 'xx']\n    assert [p.get_linestyle() for p in ax.patches] == ['-', '--', ':', '-']\n\n\ndef test_fillcycle_ignore():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('color',  ['r', 'g', 'y']) +\n                      cycler('hatch', ['xx', 'O', '|-']) +\n                      cycler('marker', ['.', '*', 'D']))\n    t = range(10)\n    # Should not advance the cycler, even though there is an\n    # unspecified property in the cycler \"marker\".\n    # \"marker\" is not a Polygon property, and should be ignored.\n    ax.fill(t, t, 'r', hatch='xx')\n    # Allow the cycler to advance, but specify some properties\n    ax.fill(t, t, hatch='O')\n    ax.fill(t, t)\n    ax.fill(t, t)\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in ['r', 'r', 'g', 'y']])\n    assert [p.get_hatch() for p in ax.patches] == ['xx', 'O', 'O', '|-']\n\n\ndef test_property_collision_plot():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle('linewidth', [2, 4])\n    t = ran"}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_cycles.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "ge(10)\n    for c in range(1, 4):\n        ax.plot(t, t, lw=0.1)\n    ax.plot(t, t)\n    ax.plot(t, t)\n    assert [l.get_linewidth() for l in ax.lines] == [0.1, 0.1, 0.1, 2, 4]\n\n\ndef test_property_collision_fill():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(linewidth=[2, 3, 4, 5, 6], facecolor='bgcmy')\n    t = range(10)\n    for c in range(1, 4):\n        ax.fill(t, t, lw=0.1)\n    ax.fill(t, t)\n    ax.fill(t, t)\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in 'bgcmy'])\n    assert [p.get_linewidth() for p in ax.patches] == [0.1, 0.1, 0.1, 5, 6]\n\n\ndef test_valid_input_forms():\n    fig, ax = plt.subplots()\n    # These should not raise an error.\n    ax.set_prop_cycle(None)\n    ax.set_prop_cycle(cycler('linewidth', [1, 2]))\n    ax.set_prop_cycle('color', 'rgywkbcm')\n    ax.set_prop_cycle('lw', (1, 2))\n    ax.set_prop_cycle('linewidth', [1, 2])\n    ax.set_prop_cycle('linewidth', iter([1, 2]))\n    ax.set_prop_cycle('linewidth', np.array([1, 2]))\n    ax.set_prop_cycle('color', np.array([[1, 0, 0],\n                                         [0, 1, 0],\n                                         [0, 0, 1]]))\n    ax.set_prop_cycle('dashes', [[], [13, 2], [8, 3, 1, 3]])\n    ax.set_prop_cycle(lw=[1, 2], color=['k', 'w'], ls=['-', '--'])\n    ax.set_prop_cycle(lw=np.array([1, 2]),\n                      color=np.array(['k', 'w']),\n                      ls=np.array(['-', '--']))\n\n\ndef test_cycle_reset():\n    fig, ax = plt.subplots()\n    prop0 = StringIO()\n    prop1 = StringIO()\n    prop2 = StringIO()\n\n    with contextlib.redirect_stdout(prop0):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n\n    ax.set_prop_cycle(linewidth=[10, 9, 4])\n    with contextlib.redirect_stdout(prop1):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop1.getvalue() != prop0.getvalue()\n\n    ax.set_prop_cycle(None)\n    with contextlib.redirect_stdout(prop2):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop2.getvalue() == p"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_cycles.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import contextlib\nfrom io import StringIO\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pytest\n\nfrom cycler import cycler\n\n\ndef test_colorcycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('color', ['r', 'g', 'y']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_color() for l in ax.lines] == ['r', 'g', 'y', 'r']\n\n\ndef test_marker_cycle():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('c', ['r', 'g', 'y']) +\n                      cycler('marker', ['.', '*', 'x']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_color() for l in ax.lines] == ['r', 'g', 'y', 'r']\n    assert [l.get_marker() for l in ax.lines] == ['.', '*', 'x', '.']\n\n\ndef test_valid_marker_cycles():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler(marker=[1, \"+\", \".\", 4]))\n\n\ndef test_marker_cycle_kwargs_arrays_iterators():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(c=np.array(['r', 'g', 'y']),\n                      marker=iter(['.', '*', 'x']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_color() for l in ax.lines] == ['r', 'g', 'y', 'r']\n    assert [l.get_marker() for l in ax.lines] == ['.', '*', 'x', '.']\n\n\ndef test_linestylecycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('ls', ['-', '--', ':']))\n    for _ in range(4):\n        ax.plot(range(10), range(10))\n    assert [l.get_linestyle() for l in ax.lines] == ['-', '--', ':', '-']\n\n\ndef test_fillcycle_basic():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('c',  ['r', 'g', 'y']) +\n                      cycler('hatch', ['xx', 'O', '|-']) +\n                      cycler('linestyle', ['-', '--', ':']))\n    for _ in range(4):\n        ax.fill(range(10), range(10))\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in ['r', 'g', 'y', 'r']])\n    assert [p.get_hatch() for p in ax.patches] == ['xx', '"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_cycles.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "O', '|-', 'xx']\n    assert [p.get_linestyle() for p in ax.patches] == ['-', '--', ':', '-']\n\n\ndef test_fillcycle_ignore():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(cycler('color',  ['r', 'g', 'y']) +\n                      cycler('hatch', ['xx', 'O', '|-']) +\n                      cycler('marker', ['.', '*', 'D']))\n    t = range(10)\n    # Should not advance the cycler, even though there is an\n    # unspecified property in the cycler \"marker\".\n    # \"marker\" is not a Polygon property, and should be ignored.\n    ax.fill(t, t, 'r', hatch='xx')\n    # Allow the cycler to advance, but specify some properties\n    ax.fill(t, t, hatch='O')\n    ax.fill(t, t)\n    ax.fill(t, t)\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in ['r', 'r', 'g', 'y']])\n    assert [p.get_hatch() for p in ax.patches] == ['xx', 'O', 'O', '|-']\n\n\ndef test_property_collision_plot():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle('linewidth', [2, 4])\n    t = range(10)\n    for c in range(1, 4):\n        ax.plot(t, t, lw=0.1)\n    ax.plot(t, t)\n    ax.plot(t, t)\n    assert [l.get_linewidth() for l in ax.lines] == [0.1, 0.1, 0.1, 2, 4]\n\n\ndef test_property_collision_fill():\n    fig, ax = plt.subplots()\n    ax.set_prop_cycle(linewidth=[2, 3, 4, 5, 6], facecolor='bgcmy')\n    t = range(10)\n    for c in range(1, 4):\n        ax.fill(t, t, lw=0.1)\n    ax.fill(t, t)\n    ax.fill(t, t)\n    assert ([p.get_facecolor() for p in ax.patches]\n            == [mpl.colors.to_rgba(c) for c in 'bgcmy'])\n    assert [p.get_linewidth() for p in ax.patches] == [0.1, 0.1, 0.1, 5, 6]\n\n\ndef test_valid_input_forms():\n    fig, ax = plt.subplots()\n    # These should not raise an error.\n    ax.set_prop_cycle(None)\n    ax.set_prop_cycle(cycler('linewidth', [1, 2]))\n    ax.set_prop_cycle('color', 'rgywkbcm')\n    ax.set_prop_cycle('lw', (1, 2))\n    ax.set_prop_cycle('linewidth', [1, 2])\n    ax.set_prop_cycle('linewidth', iter([1, 2]))\n    ax.set_prop_cycle('linewidth', np.array([1,"}, {"start_line": 8000, "end_line": 10000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "val_or_rc(cycler, 'axes.prop_cycle')]\n\n    def __call__(self, axes, *args, data=None, return_kwargs=False, **kwargs):\n        axes._process_unit_info(kwargs=kwargs)\n\n        for pos_only in \"xy\":\n            if pos_only in kwargs:\n                raise _api.kwarg_error(inspect.stack()[1].function, pos_only)\n\n        if not args:\n            return\n\n        if data is None:  # Process dict views\n            args = [cbook.sanitize_sequence(a) for a in args]\n        else:  # Process the 'data' kwarg.\n            replaced = [mpl._replacer(data, arg) for arg in args]\n            if len(args) == 1:\n                label_namer_idx = 0\n            elif len(args) == 2:  # Can be x, y or y, c.\n                # Figure out what the second argument is.\n                # 1) If the second argument cannot be a format shorthand, the\n                #    second argument is the label_namer.\n                # 2) Otherwise (it could have been a format shorthand),\n                #    a) if we did perform a substitution, emit a warning, and\n                #       use it as label_namer.\n                #    b) otherwise, it is indeed a format shorthand; use the\n                #       first argument as label_namer.\n                try:\n                    _process_plot_format(args[1])\n                except ValueError:  # case 1)\n                    label_namer_idx = 1\n                else:\n                    if replaced[1] is not args[1]:  # case 2a)\n                        _api.warn_external(\n                            f\"Second argument {args[1]!r} is ambiguous: could \"\n                            f\"be a format string but is in 'data'; using as \"\n                            f\"data.  If it was intended as data, set the \"\n                            f\"format string to an empty string to suppress \"\n                            f\"this warning.  If it was intended as a format \"\n                            f\"string, explicitly pass the x-values as well.  \"\n                            f\"Alt"}, {"start_line": 4000, "end_line": 5996, "belongs_to": {"file_name": "test_cycles.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": " 2]))\n    ax.set_prop_cycle('color', np.array([[1, 0, 0],\n                                         [0, 1, 0],\n                                         [0, 0, 1]]))\n    ax.set_prop_cycle('dashes', [[], [13, 2], [8, 3, 1, 3]])\n    ax.set_prop_cycle(lw=[1, 2], color=['k', 'w'], ls=['-', '--'])\n    ax.set_prop_cycle(lw=np.array([1, 2]),\n                      color=np.array(['k', 'w']),\n                      ls=np.array(['-', '--']))\n\n\ndef test_cycle_reset():\n    fig, ax = plt.subplots()\n    prop0 = StringIO()\n    prop1 = StringIO()\n    prop2 = StringIO()\n\n    with contextlib.redirect_stdout(prop0):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n\n    ax.set_prop_cycle(linewidth=[10, 9, 4])\n    with contextlib.redirect_stdout(prop1):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop1.getvalue() != prop0.getvalue()\n\n    ax.set_prop_cycle(None)\n    with contextlib.redirect_stdout(prop2):\n        plt.getp(ax.plot([1, 2], label=\"label\")[0])\n    assert prop2.getvalue() == prop0.getvalue()\n\n\ndef test_invalid_input_forms():\n    fig, ax = plt.subplots()\n\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle(1)\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle([1, 2])\n\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle('color', 'fish')\n\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle('linewidth', 1)\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle('linewidth', {1, 2})\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle(linewidth=1, color='r')\n\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle('foobar', [1, 2])\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle(foobar=[1, 2])\n\n    with pytest.raises((TypeError, ValueError)):\n        ax.set_prop_cycle(cycler(foobar=[1, 2]))\n    with pytest.raises(ValueError):\n        ax.set_prop_cycle(cycler(color='rgb', c='cmy'))\n"}, {"start_line": 13000, "end_line": 14962, "belongs_to": {"file_name": "test_lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "et']\n    colors = cmap(np.linspace(0.2, 0.8, len(cases)))\n\n    x = np.linspace(-1, 1)\n    y = 5 * x**2\n\n    axs = fig_ref.add_subplot()\n    for i, markevery in enumerate(cases):\n        axs.plot(y - i, 'o-', markevery=markevery, color=colors[i])\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler(markevery=cases,\n                                                    color=colors)\n\n    ax = fig_test.add_subplot()\n    for i, _ in enumerate(cases):\n        ax.plot(y - i, 'o-')\n\n\ndef test_axline_setters():\n    fig, ax = plt.subplots()\n    line1 = ax.axline((.1, .1), slope=0.6)\n    line2 = ax.axline((.1, .1), (.8, .4))\n    # Testing xy1, xy2 and slope setters.\n    # This should not produce an error.\n    line1.set_xy1((.2, .3))\n    line1.set_slope(2.4)\n    line2.set_xy1((.3, .2))\n    line2.set_xy2((.6, .8))\n    # Testing xy1, xy2 and slope getters.\n    # Should return the modified values.\n    assert line1.get_xy1() == (.2, .3)\n    assert line1.get_slope() == 2.4\n    assert line2.get_xy1() == (.3, .2)\n    assert line2.get_xy2() == (.6, .8)\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        line1.set_xy1(.2, .3)\n    with pytest.warns(mpl.MatplotlibDeprecationWarning):\n        line2.set_xy2(.6, .8)\n    # Testing setting xy2 and slope together.\n    # These test should raise a ValueError\n    with pytest.raises(ValueError,\n                       match=\"Cannot set an 'xy2' value while 'slope' is set\"):\n        line1.set_xy2(.2, .3)\n\n    with pytest.raises(ValueError,\n                       match=\"Cannot set a 'slope' value while 'xy2' is set\"):\n        line2.set_slope(3)\n\n\ndef test_axline_small_slope():\n    \"\"\"Test that small slopes are not coerced to zero in the transform.\"\"\"\n    line = plt.axline((0, 0), slope=1e-14)\n    p1 = line.get_transform().transform_point((0, 0))\n    p2 = line.get_transform().transform_point((1, 1))\n    # y-values must be slightly different\n    dy = p2[1] - p1[1]\n    assert dy > 0\n    assert dy < 4e-12\n"}, {"start_line": 6000, "end_line": 8000, "belongs_to": {"file_name": "_base.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/axes", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "n mlines.lineStyles:  # First, the two-char styles.\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = fmt[i:i+2]\n            i += 2\n        elif c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(errfmt.format(fmt, \"two linestyle symbols\"))\n            linestyle = c\n            i += 1\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(errfmt.format(fmt, \"two marker symbols\"))\n            marker = c\n            i += 1\n        elif c in mcolors.get_named_colors_mapping():\n            if color is not None:\n                raise ValueError(errfmt.format(fmt, \"two color symbols\"))\n            color = c\n            i += 1\n        elif c == \"C\":\n            cn_color = re.match(r\"C\\d+\", fmt[i:])\n            if not cn_color:\n                raise ValueError(errfmt.format(fmt, \"'C' must be followed by a number\"))\n            color = mcolors.to_rgba(cn_color[0])\n            i += len(cn_color[0])\n        else:\n            raise ValueError(errfmt.format(fmt, f\"unrecognized character {c!r}\"))\n\n    if linestyle is None and marker is None:\n        linestyle = mpl.rcParams['lines.linestyle']\n    if linestyle is None:\n        linestyle = 'None'\n    if marker is None:\n        marker = 'None'\n\n    return linestyle, marker, color\n\n\nclass _process_plot_var_args:\n    \"\"\"\n    Process variable length arguments to `~.Axes.plot`, to support ::\n\n      plot(t, s)\n      plot(t1, s1, t2, s2)\n      plot(t1, s1, 'ko', t2, s2)\n      plot(t1, s1, 'ko', t2, s2, 'r--', t3, e3)\n\n    an arbitrary number of *x*, *y*, *fmt* are allowed\n    \"\"\"\n\n    def __init__(self, output='Line2D'):\n        _api.check_in_list(['Line2D', 'Polygon', 'coordinates'], output=output)\n        self.output = output\n        self.set_prop_cycle(None)\n\n    def set_prop_cycle(self, cycler):\n        self._idx = 0\n        self._cycler_items = [*mpl._"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "color_cycle.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/galleries/users_explain/artists", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "give you the ``i``-th offset sine curve. Let's set the\n# default ``prop_cycle`` using :func:`matplotlib.pyplot.rc`.  We'll combine a\n# color cycler and a linestyle cycler by adding (``+``) two ``cycler``'s\n# together.  See the bottom of this tutorial for more information about\n# combining different cyclers.\ndefault_cycler = (cycler(color=['r', 'g', 'b', 'y']) +\n                  cycler(linestyle=['-', '--', ':', '-.']))\n\nplt.rc('lines', linewidth=4)\nplt.rc('axes', prop_cycle=default_cycler)\n\n# %%\n# Now we'll generate a figure with two Axes, one on top of the other. On the\n# first axis, we'll plot with the default cycler. On the second axis, we'll\n# set the ``prop_cycle`` using :func:`matplotlib.axes.Axes.set_prop_cycle`,\n# which will only set the ``prop_cycle`` for this :mod:`matplotlib.axes.Axes`\n# instance. We'll use a second ``cycler`` that combines a color cycler and a\n# linewidth cycler.\ncustom_cycler = (cycler(color=['c', 'm', 'y', 'k']) +\n                 cycler(lw=[1, 2, 3, 4]))\n\nfig, (ax0, ax1) = plt.subplots(nrows=2)\nax0.plot(yy)\nax0.set_title('Set default color cycle to rgby')\nax1.set_prop_cycle(custom_cycler)\nax1.plot(yy)\nax1.set_title('Set axes color cycle to cmyk')\n\n# Add a bit more space between the two plots.\nfig.subplots_adjust(hspace=0.3)\nplt.show()\n\n# %%\n# Setting ``prop_cycle`` in the :file:`matplotlibrc` file or style files\n# ----------------------------------------------------------------------\n#\n# Remember, a custom cycler can be set in your :file:`matplotlibrc`\n# file or a style file (:file:`style.mplstyle`) under ``axes.prop_cycle``, e.g.\n#\n# .. code-block:: none\n#\n#    axes.prop_cycle : cycler(color=['red', 'royalblue', 'gray'])\n#\n# For colors, a single string may be used either for one of the\n# :doc:`/gallery/color/color_sequences`\n#\n# .. code-block:: none\n#\n#    axes.prop_cycle : cycler(color='Accent')\n#\n# or if each color has a single character name:\n#\n# .. code-block:: none\n#\n#    axes.prop_cycle : cycler(color='bgrcmyk')\n#\n# Cycling th"}, {"start_line": 12000, "end_line": 14000, "belongs_to": {"file_name": "test_lines.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "s(mouse_event)\n    assert found\n    assert_array_equal(indices['ind'], [0])\n\n    # And if we modify the pickradius after creation, it should work as well.\n    l2, = ax.plot([0, 1], [0, 1], picker=True)\n    found, indices = l2.contains(mouse_event)\n    assert not found\n    l2.set_pickradius(20)\n    found, indices = l2.contains(mouse_event)\n    assert found\n    assert_array_equal(indices['ind'], [0])\n\n\n@check_figures_equal()\ndef test_input_copy(fig_test, fig_ref):\n\n    t = np.arange(0, 6, 2)\n    l, = fig_test.add_subplot().plot(t, t, \".-\")\n    t[:] = range(3)\n    # Trigger cache invalidation\n    l.set_drawstyle(\"steps\")\n    fig_ref.add_subplot().plot([0, 2, 4], [0, 2, 4], \".-\", drawstyle=\"steps\")\n\n\n@check_figures_equal()\ndef test_markevery_prop_cycle(fig_test, fig_ref):\n    \"\"\"Test that we can set markevery prop_cycle.\"\"\"\n    cases = [None, 8, (30, 8), [16, 24, 30], [0, -1],\n             slice(100, 200, 3), 0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cmap = mpl.colormaps['jet']\n    colors = cmap(np.linspace(0.2, 0.8, len(cases)))\n\n    x = np.linspace(-1, 1)\n    y = 5 * x**2\n\n    axs = fig_ref.add_subplot()\n    for i, markevery in enumerate(cases):\n        axs.plot(y - i, 'o-', markevery=markevery, color=colors[i])\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler(markevery=cases,\n                                                    color=colors)\n\n    ax = fig_test.add_subplot()\n    for i, _ in enumerate(cases):\n        ax.plot(y - i, 'o-')\n\n\ndef test_axline_setters():\n    fig, ax = plt.subplots()\n    line1 = ax.axline((.1, .1), slope=0.6)\n    line2 = ax.axline((.1, .1), (.8, .4))\n    # Testing xy1, xy2 and slope setters.\n    # This should not produce an error.\n    line1.set_xy1((.2, .3))\n    line1.set_slope(2.4)\n    line2.set_xy1((.3, .2))\n    line2.set_xy2((.6, .8))\n    # Testing xy1, xy2 and slope getters.\n    # Should return the modified values.\n    assert line1.get_xy1() == (.2, .3)\n    assert line1.get_slope() == 2.4\n    assert line2.get_xy1() == "}], "retrieved_count": 10, "cost_time": 0.8545272350311279}
{"question": "Where in the codebase are the lower-level helper functions that test_pdflatex delegates to for configuring the PGF backend and rendering the test figure?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "y')\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_pdflatex.pdf'], style='default',\n                  tol=11.71 if _old_gs_version else 0)\ndef test_pdflatex():\n    rc_pdflatex = {'font.family': 'serif',\n                   'pgf.rcfonts': False,\n                   'pgf.texsystem': 'pdflatex',\n                   'pgf.preamble': ('\\\\usepackage[utf8x]{inputenc}'\n                                    '\\\\usepackage[T1]{fontenc}')}\n    mpl.rcParams.update(rc_pdflatex)\n    create_figure()\n\n\n# test updating the rc parameters for each figure\n@needs_pgf_xelatex\n@needs_pgf_pdflatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_rcupdate():\n    rc_sets = [{'font.family': 'sans-serif',\n                'font.size': 30,\n                'figure.subplot.left': .2,\n                'lines.markersize': 10,\n                'pgf.rcfonts': False,\n                'pgf.texsystem': 'xelatex'},\n               {'font.family': 'monospace',\n                'font.size': 10,\n                'figure.subplot.left': .1,\n                'lines.markersize': 20,\n                'pgf.rcfonts': False,\n                'pgf.texsystem': 'pdflatex',\n                'pgf.preamble': ('\\\\usepackage[utf8x]{inputenc}'\n                                 '\\\\usepackage[T1]{fontenc}'\n                                 '\\\\usepackage{sfmath}')}]\n    tol = [0, 13.2] if _old_gs_version else [0, 0]\n    for i, rc_set in enumerate(rc_sets):\n        with mpl.rc_context(rc_set):\n            for substring, pkg in [('sfmath', 'sfmath'), ('utf8x', 'ucs')]:\n                if (substring in mpl.rcParams['pgf.preamble']\n                        and not _has_tex_package(pkg)):\n                    pytest.skip(f'needs {pkg}.sty')\n            create_figure()\n            compare_figure(f'pgf_rcupdate{i + 1}.pdf', tol=tol[i])\n\n\n# test backend-side clipping, since large numbers are not supported by TeX\n@needs_pgf_xelatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_pathclip():\n    np.random.seed(196808"}, {"start_line": 33000, "end_line": 35000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with ((tmppath / \"figure.pdf\").open(\"rb\") as orig,\n                  cbook.open_file_cm(fname_or_fh, \"wb\") as dest):\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with (png_path.open(\"rb\") as orig,\n                  cbook.open_file_cm(fname_or_fh, \"wb\") as dest):\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def get_renderer(self):\n        return RendererPgf(self.figure, None)\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()\n\n\nFigureManagerPgf = FigureManagerBase\n\n\n@_Backend.export\nclass _BackendPgf(_Backend):\n    FigureCanvas = FigureCanvasPgf\n\n\nclass PdfPages:\n    \"\"\"\n    A multi-page PDF file using the pgf backend\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ", fname), expected)\n    err = compare_images(expected, actual, tol=tol)\n    if err:\n        raise ImageComparisonFailure(err)\n\n\n@needs_pgf_xelatex\n@needs_ghostscript\n@pytest.mark.backend('pgf')\ndef test_tex_special_chars(tmp_path):\n    fig = plt.figure()\n    fig.text(.5, .5, \"%_^ $a_b^c$\")\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\", backend=\"pgf\")\n    buf.seek(0)\n    t = plt.imread(buf)\n    assert not (t == 1).all()  # The leading \"%\" didn't eat up everything.\n\n\ndef create_figure():\n    plt.figure()\n    x = np.linspace(0, 1, 15)\n\n    # line plot\n    plt.plot(x, x ** 2, \"b-\")\n\n    # marker\n    plt.plot(x, 1 - x**2, \"g>\")\n\n    # filled paths and patterns\n    plt.fill_between([0., .4], [.4, 0.], hatch='//', facecolor=\"lightgray\",\n                     edgecolor=\"red\")\n    plt.fill([3, 3, .8, .8, 3], [2, -2, -2, 0, 2], \"b\")\n\n    # text and typesetting\n    plt.plot([0.9], [0.5], \"ro\", markersize=3)\n    plt.text(0.9, 0.5, 'unicode (, , \\N{Section Sign}) and math ($\\\\mu_i = x_i^2$)',\n             ha='right', fontsize=20)\n    plt.ylabel('sans-serif, blue, $\\\\frac{\\\\sqrt{x}}{y^2}$..',\n               family='sans-serif', color='blue')\n    plt.text(1, 1, 'should be clipped as default clip_box is Axes bbox',\n             fontsize=20, clip_on=True)\n\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n\n\n# test compiling a figure to pdf with xelatex\n@needs_pgf_xelatex\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_xelatex.pdf'], style='default')\ndef test_xelatex():\n    rc_xelatex = {'font.family': 'serif',\n                  'pgf.rcfonts': False}\n    mpl.rcParams.update(rc_xelatex)\n    create_figure()\n\n\ntry:\n    _old_gs_version = \\\n        mpl._get_executable_info('gs').version < parse_version('9.50')\nexcept mpl.ExecutableNotFoundError:\n    _old_gs_version = True\n\n\n# test compiling a figure to pdf with pdflatex\n@needs_pgf_pdflatex\n@pytest.mark.skipif(not _has_tex_package('type1ec'), reason='needs type1ec.sty')\n@pytest.mark.skipif(not _has_tex_package('ucs'), reason='needs ucs.st"}, {"start_line": 2000, "end_line": 4000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ")',\n             ha='right', fontsize=20)\n    plt.ylabel('sans-serif, blue, $\\\\frac{\\\\sqrt{x}}{y^2}$..',\n               family='sans-serif', color='blue')\n    plt.text(1, 1, 'should be clipped as default clip_box is Axes bbox',\n             fontsize=20, clip_on=True)\n\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n\n\n# test compiling a figure to pdf with xelatex\n@needs_pgf_xelatex\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_xelatex.pdf'], style='default')\ndef test_xelatex():\n    rc_xelatex = {'font.family': 'serif',\n                  'pgf.rcfonts': False}\n    mpl.rcParams.update(rc_xelatex)\n    create_figure()\n\n\ntry:\n    _old_gs_version = \\\n        mpl._get_executable_info('gs').version < parse_version('9.50')\nexcept mpl.ExecutableNotFoundError:\n    _old_gs_version = True\n\n\n# test compiling a figure to pdf with pdflatex\n@needs_pgf_pdflatex\n@pytest.mark.skipif(not _has_tex_package('type1ec'), reason='needs type1ec.sty')\n@pytest.mark.skipif(not _has_tex_package('ucs'), reason='needs ucs.sty')\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_pdflatex.pdf'], style='default',\n                  tol=11.71 if _old_gs_version else 0)\ndef test_pdflatex():\n    rc_pdflatex = {'font.family': 'serif',\n                   'pgf.rcfonts': False,\n                   'pgf.texsystem': 'pdflatex',\n                   'pgf.preamble': ('\\\\usepackage[utf8x]{inputenc}'\n                                    '\\\\usepackage[T1]{fontenc}')}\n    mpl.rcParams.update(rc_pdflatex)\n    create_figure()\n\n\n# test updating the rc parameters for each figure\n@needs_pgf_xelatex\n@needs_pgf_pdflatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_rcupdate():\n    rc_sets = [{'font.family': 'sans-serif',\n                'font.size': 30,\n                'figure.subplot.left': .2,\n                'lines.markersize': 10,\n                'pgf.rcfonts': False,\n                'pgf.texsystem': 'xelatex'},\n               {'font.family': 'monospace',\n                'font.size': 10,\n                'figu"}, {"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "re.subplot.left': .1,\n                'lines.markersize': 20,\n                'pgf.rcfonts': False,\n                'pgf.texsystem': 'pdflatex',\n                'pgf.preamble': ('\\\\usepackage[utf8x]{inputenc}'\n                                 '\\\\usepackage[T1]{fontenc}'\n                                 '\\\\usepackage{sfmath}')}]\n    tol = [0, 13.2] if _old_gs_version else [0, 0]\n    for i, rc_set in enumerate(rc_sets):\n        with mpl.rc_context(rc_set):\n            for substring, pkg in [('sfmath', 'sfmath'), ('utf8x', 'ucs')]:\n                if (substring in mpl.rcParams['pgf.preamble']\n                        and not _has_tex_package(pkg)):\n                    pytest.skip(f'needs {pkg}.sty')\n            create_figure()\n            compare_figure(f'pgf_rcupdate{i + 1}.pdf', tol=tol[i])\n\n\n# test backend-side clipping, since large numbers are not supported by TeX\n@needs_pgf_xelatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_pathclip():\n    np.random.seed(19680801)\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    fig, axs = plt.subplots(1, 2)\n\n    axs[0].plot([0., 1e100], [0., 1e100])\n    axs[0].set_xlim(0, 1)\n    axs[0].set_ylim(0, 1)\n\n    axs[1].scatter([0, 1], [1, 1])\n    axs[1].hist(np.random.normal(size=1000), bins=20, range=[-10, 10])\n    axs[1].set_xscale('log')\n\n    fig.savefig(BytesIO(), format=\"pdf\")  # No image comparison.\n\n\n# test mixed mode rendering\n@needs_pgf_xelatex\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_mixedmode.pdf'], style='default')\ndef test_mixedmode():\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    Y, X = np.ogrid[-1:1:40j, -1:1:40j]\n    plt.pcolor(X**2 + Y**2).set_rasterized(True)\n\n\n# test bbox_inches clipping\n@needs_pgf_xelatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_bbox_inches():\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n    ax1.plot(range(5))\n    ax2."}, {"start_line": 5000, "end_line": 7000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "01)\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    fig, axs = plt.subplots(1, 2)\n\n    axs[0].plot([0., 1e100], [0., 1e100])\n    axs[0].set_xlim(0, 1)\n    axs[0].set_ylim(0, 1)\n\n    axs[1].scatter([0, 1], [1, 1])\n    axs[1].hist(np.random.normal(size=1000), bins=20, range=[-10, 10])\n    axs[1].set_xscale('log')\n\n    fig.savefig(BytesIO(), format=\"pdf\")  # No image comparison.\n\n\n# test mixed mode rendering\n@needs_pgf_xelatex\n@pytest.mark.backend('pgf')\n@image_comparison(['pgf_mixedmode.pdf'], style='default')\ndef test_mixedmode():\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    Y, X = np.ogrid[-1:1:40j, -1:1:40j]\n    plt.pcolor(X**2 + Y**2).set_rasterized(True)\n\n\n# test bbox_inches clipping\n@needs_pgf_xelatex\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\ndef test_bbox_inches():\n    mpl.rcParams.update({'font.family': 'serif', 'pgf.rcfonts': False})\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n    ax1.plot(range(5))\n    ax2.plot(range(5))\n    plt.tight_layout()\n    bbox = ax1.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    compare_figure('pgf_bbox_inches.pdf', savefig_kwargs={'bbox_inches': bbox},\n                   tol=0)\n\n\n@mpl.style.context('default')\n@pytest.mark.backend('pgf')\n@pytest.mark.parametrize('system', [\n    pytest.param('lualatex', marks=[needs_pgf_lualatex]),\n    pytest.param('pdflatex', marks=[needs_pgf_pdflatex]),\n    pytest.param('xelatex', marks=[needs_pgf_xelatex]),\n])\ndef test_pdf_pages(system):\n    rc_pdflatex = {\n        'font.family': 'serif',\n        'pgf.rcfonts': False,\n        'pgf.texsystem': system,\n    }\n    mpl.rcParams.update(rc_pdflatex)\n\n    fig1, ax1 = plt.subplots()\n    ax1.plot(range(5))\n    fig1.tight_layout()\n\n    fig2, ax2 = plt.subplots(figsize=(3, 2))\n    ax2.plot(range(5))\n    fig2.tight_layout()\n\n    path = os.path.join(result_dir, f'pdfpages_{system}.pdf')\n    md = {\n        'Author': 'me',\n        'Title': 'Multipage PDF with pgf',\n      "}, {"start_line": 32000, "end_line": 34000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "gf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)\n\n    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    _DOCUMENTCLASS,\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with ((tmppath / \"figure.pdf\").open(\"rb\") as orig,\n                  cbook.open_file_cm(fname_or_fh, \"wb\") as dest):\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert"}, {"start_line": 10000, "end_line": 12000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "g.suptitle(r\"this is ok\")\n    fig.savefig(BytesIO(), format=\"pgf\")\n\n\n@needs_pgf_xelatex\ndef test_bbox_inches_tight():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]])\n    fig.savefig(BytesIO(), format=\"pdf\", backend=\"pgf\", bbox_inches=\"tight\")\n\n\n@needs_pgf_xelatex\n@needs_ghostscript\ndef test_png_transparency():  # Actually, also just testing that png works.\n    buf = BytesIO()\n    plt.figure().savefig(buf, format=\"png\", backend=\"pgf\", transparent=True)\n    buf.seek(0)\n    t = plt.imread(buf)\n    assert (t[..., 3] == 0).all()  # fully transparent.\n\n\n@needs_pgf_xelatex\ndef test_unknown_font(caplog):\n    with caplog.at_level(\"WARNING\"):\n        mpl.rcParams[\"font.family\"] = \"this-font-does-not-exist\"\n        plt.figtext(.5, .5, \"hello, world\")\n        plt.savefig(BytesIO(), format=\"pgf\")\n    assert \"Ignoring unknown font: this-font-does-not-exist\" in [\n        r.getMessage() for r in caplog.records]\n\n\n@check_figures_equal(extensions=[\"pdf\"])\n@pytest.mark.parametrize(\"texsystem\", (\"pdflatex\", \"xelatex\", \"lualatex\"))\n@pytest.mark.backend(\"pgf\")\ndef test_minus_signs_with_tex(fig_test, fig_ref, texsystem):\n    if not _check_for_pgf(texsystem):\n        pytest.skip(texsystem + ' + pgf is required')\n    mpl.rcParams[\"pgf.texsystem\"] = texsystem\n    fig_test.text(.5, .5, \"$-1$\")\n    fig_ref.text(.5, .5, \"$\\N{MINUS SIGN}1$\")\n\n\n@pytest.mark.backend(\"pgf\")\ndef test_sketch_params():\n    fig, ax = plt.subplots(figsize=(3, 3))\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_frame_on(False)\n    handle, = ax.plot([0, 1])\n    handle.set_sketch_params(scale=5, length=30, randomness=42)\n\n    with BytesIO() as fd:\n        fig.savefig(fd, format='pgf')\n        buf = fd.getvalue().decode()\n\n    baseline = r\"\"\"\\pgfpathmoveto{\\pgfqpoint{0.375000in}{0.300000in}}%\n\\pgfpathlineto{\\pgfqpoint{2.700000in}{2.700000in}}%\n\\usepgfmodule{decorations}%\n\\usepgflibrary{decorations.pathmorphing}%\n\\pgfkeys{/pgf/decoration/.cd, \"\"\" \\\n    r\"\"\"segment length = 0.150000in, amplitude = 0.100000"}, {"start_line": 0, "end_line": 2000, "belongs_to": {"file_name": "test_backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import datetime\nfrom io import BytesIO\nimport os\nimport shutil\n\nimport numpy as np\nfrom packaging.version import parse as parse_version\nimport pytest\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.testing import _has_tex_package, _check_for_pgf\nfrom matplotlib.testing.exceptions import ImageComparisonFailure\nfrom matplotlib.testing.compare import compare_images\nfrom matplotlib.backends.backend_pgf import PdfPages\nfrom matplotlib.testing.decorators import (\n    _image_directories, check_figures_equal, image_comparison)\nfrom matplotlib.testing._markers import (\n    needs_ghostscript, needs_pgf_lualatex, needs_pgf_pdflatex,\n    needs_pgf_xelatex)\n\n\nbaseline_dir, result_dir = _image_directories(lambda: 'dummy func')\n\n\ndef compare_figure(fname, savefig_kwargs={}, tol=0):\n    actual = os.path.join(result_dir, fname)\n    plt.savefig(actual, **savefig_kwargs)\n\n    expected = os.path.join(result_dir, \"expected_%s\" % fname)\n    shutil.copyfile(os.path.join(baseline_dir, fname), expected)\n    err = compare_images(expected, actual, tol=tol)\n    if err:\n        raise ImageComparisonFailure(err)\n\n\n@needs_pgf_xelatex\n@needs_ghostscript\n@pytest.mark.backend('pgf')\ndef test_tex_special_chars(tmp_path):\n    fig = plt.figure()\n    fig.text(.5, .5, \"%_^ $a_b^c$\")\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\", backend=\"pgf\")\n    buf.seek(0)\n    t = plt.imread(buf)\n    assert not (t == 1).all()  # The leading \"%\" didn't eat up everything.\n\n\ndef create_figure():\n    plt.figure()\n    x = np.linspace(0, 1, 15)\n\n    # line plot\n    plt.plot(x, x ** 2, \"b-\")\n\n    # marker\n    plt.plot(x, 1 - x**2, \"g>\")\n\n    # filled paths and patterns\n    plt.fill_between([0., .4], [.4, 0.], hatch='//', facecolor=\"lightgray\",\n                     edgecolor=\"red\")\n    plt.fill([3, 3, .8, .8, 3], [2, -2, -2, 0, 2], \"b\")\n\n    # text and typesetting\n    plt.plot([0.9], [0.5], \"ro\", markersize=3)\n    plt.text(0.9, 0.5, 'unicode (, , \\N{Section Sign}) and math ($\\\\mu_i = x_i^2$"}, {"start_line": 31000, "end_line": 33000, "belongs_to": {"file_name": "backend_pgf.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "self.figure.get_figheight()\n        dpi = self.figure.dpi\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        _writeln(fh, r\"\\begingroup\")\n        _writeln(fh, r\"\\makeatletter\")\n        _writeln(fh, r\"\\begin{pgfpicture}\")\n        _writeln(fh,\n                 r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\"\n                 % (w, h))\n        _writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        _writeln(fh, r\"\\end{pgfpicture}\")\n        _writeln(fh, r\"\\makeatother\")\n        _writeln(fh, r\"\\endgroup\")\n\n    def print_pgf(self, fname_or_fh, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)\n\n    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    _DOCUMENTCLASS,"}], "retrieved_count": 10, "cost_time": 0.8071849346160889}
{"question": "Where is the bootstrap logic that initializes the matplotlib_inline.backend_inline module located, and how does it determine whether to use the 'inline' backend identifier versus the full module path based on IPython version compatibility?", "answer": "", "relative_code_list": null, "ground_truth": null, "score": null, "retrieved_content": [{"start_line": 4000, "end_line": 6000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "        self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entry.name, entry.value) for entry in entry_points]\n\n        # For backward compatibility, if matplotlib-inline and/or ipympl are installed\n        # but too old to include entry points, create them. Do not import ipympl\n        # directly as this calls matplotlib.use() whilst in this function.\n        def backward_compatible_entry_points(\n                entries, module_name, threshold_version, names, target):\n            from matplotlib import _parse_to_version_info\n            try:\n                module_version = im.version(module_name)\n                if _parse_to_version_info(module_version) < threshold_version:\n                    for name in names:\n                        entries.append((name, target))\n            except im.PackageNotFoundError:\n                pass\n\n        names = [entry[0] for entry in entries]\n        if \"inline\" not in names:\n            backward_compatible_entry_points(\n                entries, \"matplotlib_inline\", (0, 1, 7), [\"inline\"],\n                \"matp"}, {"start_line": 19000, "end_line": 21000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactive.\n    try:\n        install_repl_displayhook()\n    except NotImplementedError as err:\n        _log.warning(\"Fallback to a different backend\")\n        raise ImportError from err\n\n\ndef _warn_if_gui_out_of_main_thread() -> None:\n    warn = False\n    canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)\n    if canvas_class.required_interactive_framework:\n        if hasattr(threading, 'get_native_id'):\n            # This compares native thread ids because even if Python-level\n            # Thread objects match, the underlying OS thread (which is what\n            # really matters) may be different on Python implementations with\n            # green threads.\n            if threading.get_native_id() != threading.main_thread().native_id:\n                warn = True\n        else:\n            # Fall back to Python-level Thread if native IDs are unavailable,\n            # mainly for PyPy.\n            if threading.current_thread() is not threading.main_thread():\n              "}, {"start_line": 3000, "end_line": 5000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "try points or\n        # \"module://some.backend\" syntax.\n        self._name_to_module = {\n            \"notebook\": \"nbagg\",\n        }\n\n    def _backend_module_name(self, backend):\n        if backend.startswith(\"module://\"):\n            return backend[9:]\n\n        # Return name of module containing the specified backend.\n        # Does not check if the backend is valid, use is_valid_backend for that.\n        backend = backend.lower()\n\n        # Check if have specific name to module mapping.\n        backend = self._name_to_module.get(backend, backend)\n\n        return (backend[9:] if backend.startswith(\"module://\")\n                else f\"matplotlib.backends.backend_{backend}\")\n\n    def _clear(self):\n        # Clear all dynamically-added data, used for testing only.\n        self.__init__()\n\n    def _ensure_entry_points_loaded(self):\n        # Load entry points, if they have not already been loaded.\n        if not self._loaded_entry_points:\n            entries = self._read_entry_points()\n            self._validate_and_store_entry_points(entries)\n            self._loaded_entry_points = True\n\n    def _get_gui_framework_by_loading(self, backend):\n        # Determine GUI framework for a backend by loading its module and reading the\n        # FigureCanvas.required_interactive_framework attribute.\n        # Returns \"headless\" if there is no GUI framework.\n        module = self.load_backend_module(backend)\n        canvas_class = module.FigureCanvas\n        return canvas_class.required_interactive_framework or \"headless\"\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entr"}, {"start_line": 17000, "end_line": 19000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "() -> None:\n            if matplotlib.is_interactive():\n                manager = _pylab_helpers.Gcf.get_active()\n                if manager:\n                    manager.canvas.draw_idle()\n\n        backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n            new_figure_manager_given_figure)\n        backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n            new_figure_manager)\n        backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n            draw_if_interactive)\n\n    # If the manager explicitly overrides pyplot_show, use it even if a global\n    # show is already present, as the latter may be here for backcompat.\n    manager_class = getattr(canvas_class, \"manager_class\", None)\n    # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n    # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n    # thus always different (being bound to different classes).  We also have to use\n    # getattr_static instead of vars as manager_class could have no __dict__.\n    manager_pyplot_show = inspect.getattr_static(manager_class, \"pyplot_show\", None)\n    base_pyplot_show = inspect.getattr_static(FigureManagerBase, \"pyplot_show\", None)\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend"}, {"start_line": 0, "end_line": 1613, "belongs_to": {"file_name": "test_backend_inline.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/tests", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "import os\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nimport pytest\n\nfrom matplotlib.testing import subprocess_run_for_testing\n\nnbformat = pytest.importorskip('nbformat')\npytest.importorskip('nbconvert')\npytest.importorskip('ipykernel')\npytest.importorskip('matplotlib_inline')\n\n\ndef test_ipynb():\n    nb_path = Path(__file__).parent / 'data/test_inline_01.ipynb'\n\n    with TemporaryDirectory() as tmpdir:\n        out_path = Path(tmpdir, \"out.ipynb\")\n\n        subprocess_run_for_testing(\n            [\"jupyter\", \"nbconvert\", \"--to\", \"notebook\",\n             \"--execute\", \"--ExecutePreprocessor.timeout=500\",\n             \"--output\", str(out_path), str(nb_path)],\n            env={**os.environ, \"IPYTHONDIR\": tmpdir},\n            check=True)\n        with out_path.open() as out:\n            nb = nbformat.read(out, nbformat.current_nbformat)\n\n    errors = [output for cell in nb.cells for output in cell.get(\"outputs\", [])\n              if output.output_type == \"error\"]\n    assert not errors\n\n    import IPython\n    if IPython.version_info[:2] >= (8, 24):\n        expected_backend = \"inline\"\n    else:\n        # This code can be removed when Python 3.12, the latest version supported by\n        # IPython < 8.24, reaches end-of-life in late 2028.\n        expected_backend = \"module://matplotlib_inline.backend_inline\"\n    backend_outputs = nb.cells[2][\"outputs\"]\n    assert backend_outputs[0][\"data\"][\"text/plain\"] == f\"'{expected_backend}'\"\n\n    image = nb.cells[1][\"outputs\"][1][\"data\"]\n    assert image[\"text/plain\"] == \"<Figure size 300x200 with 1 Axes>\"\n    assert \"image/png\" in image\n"}, {"start_line": 15000, "end_line": 17000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "# get without triggering backend resolution\n\n    module = backend_registry.load_backend_module(newbackend)\n    canvas_class = module.FigureCanvas\n\n    required_framework = canvas_class.required_interactive_framework\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new_figure_manager() and show() functions from the backend.\n\n    # Classically, backends can directly export these functions.  This should\n    # keep working for backcompat.\n    new_figure_manager = getattr(module, \"new_figure_manager\", None)\n    show = getattr(module, \"show\", None)\n\n    # In that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive"}, {"start_line": 18000, "end_line": 20000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "have to use\n    # getattr_static instead of vars as manager_class could have no __dict__.\n    manager_pyplot_show = inspect.getattr_static(manager_class, \"pyplot_show\", None)\n    base_pyplot_show = inspect.getattr_static(FigureManagerBase, \"pyplot_show\", None)\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactiv"}, {"start_line": 16000, "end_line": 18000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "that classical approach, backends are implemented as modules, but\n    # \"inherit\" default method implementations from backend_bases._Backend.\n    # This is achieved by creating a \"class\" that inherits from\n    # backend_bases._Backend and whose body is filled with the module globals.\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(module))\n\n    # However, the newer approach for defining new_figure_manager and\n    # show is to derive them from canvas methods.  In that case, also\n    # update backend_mod accordingly; also, per-backend customization of\n    # draw_if_interactive is disabled.\n    if new_figure_manager is None:\n\n        def new_figure_manager_given_figure(num, figure):\n            return canvas_class.new_manager(figure, num)\n\n        def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n\n        def draw_if_interactive() -> None:\n            if matplotlib.is_interactive():\n                manager = _pylab_helpers.Gcf.get_active()\n                if manager:\n                    manager.canvas.draw_idle()\n\n        backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n            new_figure_manager_given_figure)\n        backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n            new_figure_manager)\n        backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n            draw_if_interactive)\n\n    # If the manager explicitly overrides pyplot_show, use it even if a global\n    # show is already present, as the latter may be here for backcompat.\n    manager_class = getattr(canvas_class, \"manager_class\", None)\n    # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n    # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n    # thus always different (being bound to different classes).  We also "}, {"start_line": 11000, "end_line": 13000, "belongs_to": {"file_name": "pyplot.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": "_ReplDisplayHook.IPYTHON\n\n    if mod_ipython.version_info[:2] < (8, 24):\n        # Use of backend2gui is not needed for IPython >= 8.24 as that functionality\n        # has been moved to Matplotlib.\n        # This code can be removed when Python 3.12, the latest version supported by\n        # IPython < 8.24, reaches end-of-life in late 2028.\n        from IPython.core.pylabtools import backend2gui\n        ipython_gui_name = backend2gui.get(get_backend())\n    else:\n        _, ipython_gui_name = backend_registry.resolve_backend(get_backend())\n    # trigger IPython's eventloop integration, if available\n    if ipython_gui_name:\n        ip.enable_gui(ipython_gui_name)\n\n\ndef uninstall_repl_displayhook() -> None:\n    \"\"\"Disconnect from the display hook of the current shell.\"\"\"\n    global _REPL_DISPLAYHOOK\n    if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n        from IPython import get_ipython\n        ip = get_ipython()\n        ip.events.unregister(\"post_execute\", _draw_all_if_interactive)\n    _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n\n\ndraw_all = _pylab_helpers.Gcf.draw_all\n\n\n# Ensure this appears in the pyplot docs.\n@_copy_docstring_and_deprecators(matplotlib.set_loglevel)\ndef set_loglevel(level: LogLevel) -> None:\n    return matplotlib.set_loglevel(level)\n\n\n@_copy_docstring_and_deprecators(Artist.findobj)\ndef findobj(\n    o: Artist | None = None,\n    match: Callable[[Artist], bool] | type[Artist] | None = None,\n    include_self: bool = True\n) -> list[Artist]:\n    if o is None:\n        o = gcf()\n    return o.findobj(match, include_self=include_self)\n\n\n_backend_mod: type[matplotlib.backend_bases._Backend] | None = None\n\n\ndef _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:\n    \"\"\"\n    Ensure that a backend is selected and return it.\n\n    This is currently private, but may be made public in the future.\n    \"\"\"\n    if _backend_mod is None:\n        # Use rcParams._get(\"backend\") to avoid going through the fallback\n        # logic (which will (re)import pyplot"}, {"start_line": 1000, "end_line": 3000, "belongs_to": {"file_name": "registry.py", "upper_path": "/data2/raymone/swebench-repos/matplotlib/lib/matplotlib/backends", "module": "", "define_class": [], "imports": []}, "relative_function": [], "code": ".9\n    \"\"\"\n    # Mapping of built-in backend name to GUI framework, or \"headless\" for no\n    # GUI framework. Built-in backends are those which are included in the\n    # Matplotlib repo. A backend with name 'name' is located in the module\n    # f\"matplotlib.backends.backend_{name.lower()}\"\n    _BUILTIN_BACKEND_TO_GUI_FRAMEWORK = {\n        \"gtk3agg\": \"gtk3\",\n        \"gtk3cairo\": \"gtk3\",\n        \"gtk4agg\": \"gtk4\",\n        \"gtk4cairo\": \"gtk4\",\n        \"macosx\": \"macosx\",\n        \"nbagg\": \"nbagg\",\n        \"notebook\": \"nbagg\",\n        \"qtagg\": \"qt\",\n        \"qtcairo\": \"qt\",\n        \"qt5agg\": \"qt5\",\n        \"qt5cairo\": \"qt5\",\n        \"tkagg\": \"tk\",\n        \"tkcairo\": \"tk\",\n        \"webagg\": \"webagg\",\n        \"wx\": \"wx\",\n        \"wxagg\": \"wx\",\n        \"wxcairo\": \"wx\",\n        \"agg\": \"headless\",\n        \"cairo\": \"headless\",\n        \"pdf\": \"headless\",\n        \"pgf\": \"headless\",\n        \"ps\": \"headless\",\n        \"svg\": \"headless\",\n        \"template\": \"headless\",\n    }\n\n    # Reverse mapping of gui framework to preferred built-in backend.\n    _GUI_FRAMEWORK_TO_BACKEND = {\n        \"gtk3\": \"gtk3agg\",\n        \"gtk4\": \"gtk4agg\",\n        \"headless\": \"agg\",\n        \"macosx\": \"macosx\",\n        \"qt\": \"qtagg\",\n        \"qt5\": \"qt5agg\",\n        \"qt6\": \"qtagg\",\n        \"tk\": \"tkagg\",\n        \"wx\": \"wxagg\",\n    }\n\n    def __init__(self):\n        # Only load entry points when first needed.\n        self._loaded_entry_points = False\n\n        # Mapping of non-built-in backend to GUI framework, added dynamically from\n        # entry points and from matplotlib.use(\"module://some.backend\") format.\n        # New entries have an \"unknown\" GUI framework that is determined when first\n        # needed by calling _get_gui_framework_by_loading.\n        self._backend_to_gui_framework = {}\n\n        # Mapping of backend name to module name, where different from\n        # f\"matplotlib.backends.backend_{backend_name.lower()}\". These are either\n        # hardcoded for backward compatibility, or loaded from en"}], "retrieved_count": 10, "cost_time": 0.7915887832641602}
